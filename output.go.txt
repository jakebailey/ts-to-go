// Code generated by ts-to-go at 497316f7e847bc22a009244ba80a45c3bc6fe6b6. DO NOT EDIT.

package output

func __COND__[C comparable, T any](cond C, a T, b T) T {
	var zero C
	if cond != zero {
		return a
	}
	return b
}

var ambientModuleSymbolRegex = regexp.MustParse(`^".+"$`)
var anon = "(anonymous)" /* as __String & string */
type ReferenceHint int32

const (
	ReferenceHintUnspecified ReferenceHint = iota
	ReferenceHintIdentifier
	ReferenceHintProperty
	ReferenceHintExportAssignment
	ReferenceHintJsx
	ReferenceHintAsyncFunction
	ReferenceHintExportImportEquals
	ReferenceHintExportSpecifier
	ReferenceHintDecorator
)

var nextSymbolId = 1
var nextNodeId = 1
var nextMergeId = 1
var nextFlowId = 1

type IterationUse int32

const (
	IterationUseAllowsSyncIterablesFlag  IterationUse = 1 << 0
	IterationUseAllowsAsyncIterablesFlag IterationUse = 1 << 1
	IterationUseAllowsStringInputFlag    IterationUse = 1 << 2
	IterationUseForOfFlag                IterationUse = 1 << 3
	IterationUseYieldStarFlag            IterationUse = 1 << 4
	IterationUseSpreadFlag               IterationUse = 1 << 5
	IterationUseDestructuringFlag        IterationUse = 1 << 6
	IterationUsePossiblyOutOfBounds      IterationUse = 1 << 7
	// Spread, Destructuring, Array element assignment
	IterationUseElement                  IterationUse = IterationUseAllowsSyncIterablesFlag
	IterationUseSpread                   IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseSpreadFlag
	IterationUseDestructuring            IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseDestructuringFlag
	IterationUseForOf                    IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
	IterationUseForAwaitOf               IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
	IterationUseYieldStar                IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseYieldStarFlag
	IterationUseAsyncYieldStar           IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseIterationUseYieldStarFlag
	IterationUseGeneratorReturnType      IterationUse = IterationUseAllowsSyncIterablesFlag
	IterationUseAsyncGeneratorReturnType IterationUse = IterationUseAllowsAsyncIterablesFlag
)

type IterationTypeKind int32

const (
	IterationTypeKindYield IterationTypeKind = iota
	IterationTypeKindReturn
	IterationTypeKindNext
)

type IterationTypesResolver struct {
	iterableCacheKey/* TODO(TS-TO-GO) TypeNode UnionType: "iterationTypesOfAsyncIterable" | "iterationTypesOfIterable" */ any
	iteratorCacheKey/* TODO(TS-TO-GO) TypeNode UnionType: "iterationTypesOfAsyncIterator" | "iterationTypesOfIterator" */ any
	iteratorSymbolName/* TODO(TS-TO-GO) TypeNode UnionType: "asyncIterator" | "iterator" */ any
	getGlobalIteratorType         func(reportErrors bool) GenericType
	getGlobalIterableType         func(reportErrors bool) GenericType
	getGlobalIterableIteratorType func(reportErrors bool) GenericType
	getGlobalIteratorObjectType   func(reportErrors bool) GenericType
	getGlobalGeneratorType        func(reportErrors bool) GenericType
	getGlobalBuiltinIteratorTypes func() []GenericType
	resolveIterationType          func(type_ Type, errorNode Node) Type
	mustHaveANextMethodDiagnostic DiagnosticMessage
	mustBeAMethodDiagnostic       DiagnosticMessage
	mustHaveAValueDiagnostic      DiagnosticMessage
}
type WideningKind int32

const (
	WideningKindNormal WideningKind = iota
	WideningKindFunctionReturn
	WideningKindGeneratorNext
	WideningKindGeneratorYield
)

// dprint-ignore
type TypeFacts int32

const (
	TypeFactsNone               TypeFacts = 0
	TypeFactsTypeofEQString     TypeFacts = 1 << 0
	TypeFactsTypeofEQNumber     TypeFacts = 1 << 1
	TypeFactsTypeofEQBigInt     TypeFacts = 1 << 2
	TypeFactsTypeofEQBoolean    TypeFacts = 1 << 3
	TypeFactsTypeofEQSymbol     TypeFacts = 1 << 4
	TypeFactsTypeofEQObject     TypeFacts = 1 << 5
	TypeFactsTypeofEQFunction   TypeFacts = 1 << 6
	TypeFactsTypeofEQHostObject TypeFacts = 1 << 7
	TypeFactsTypeofNEString     TypeFacts = 1 << 8
	TypeFactsTypeofNENumber     TypeFacts = 1 << 9
	TypeFactsTypeofNEBigInt     TypeFacts = 1 << 10
	TypeFactsTypeofNEBoolean    TypeFacts = 1 << 11
	TypeFactsTypeofNESymbol     TypeFacts = 1 << 12
	TypeFactsTypeofNEObject     TypeFacts = 1 << 13
	TypeFactsTypeofNEFunction   TypeFacts = 1 << 14
	TypeFactsTypeofNEHostObject TypeFacts = 1 << 15
	TypeFactsEQUndefined        TypeFacts = 1 << 16
	TypeFactsEQNull             TypeFacts = 1 << 17
	TypeFactsEQUndefinedOrNull  TypeFacts = 1 << 18
	TypeFactsNEUndefined        TypeFacts = 1 << 19
	TypeFactsNENull             TypeFacts = 1 << 20
	TypeFactsNEUndefinedOrNull  TypeFacts = 1 << 21
	TypeFactsTruthy             TypeFacts = 1 << 22
	TypeFactsFalsy              TypeFacts = 1 << 23
	TypeFactsIsUndefined        TypeFacts = 1 << 24
	TypeFactsIsNull             TypeFacts = 1 << 25
	TypeFactsIsUndefinedOrNull  TypeFacts = TypeFactsIsUndefined | TypeFactsIsNull
	TypeFactsAll                TypeFacts = (1 << 27) - 1
	// The following members encode facts about particular kinds of types for use in the getTypeFacts function.
	// The presence of a particular fact means that the given test is true for some (and possibly all) values
	// of that kind of type.
	TypeFactsBaseStringStrictFacts     TypeFacts = TypeFactsTypeofEQString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseStringFacts           TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsStringStrictFacts         TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsStringFacts               TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
	TypeFactsEmptyStringStrictFacts    TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsFalsy
	TypeFactsEmptyStringFacts          TypeFacts = TypeFactsBaseTypeFactsStringFacts
	TypeFactsNonEmptyStringStrictFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy
	TypeFactsNonEmptyStringFacts       TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
	TypeFactsBaseNumberStrictFacts     TypeFacts = TypeFactsTypeofEQNumber | TypeFactsTypeofNEString | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseNumberFacts           TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsNumberStrictFacts         TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsNumberFacts               TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
	TypeFactsZeroNumberStrictFacts     TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsFalsy
	TypeFactsZeroNumberFacts           TypeFacts = TypeFactsBaseTypeFactsNumberFacts
	TypeFactsNonZeroNumberStrictFacts  TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy
	TypeFactsNonZeroNumberFacts        TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
	TypeFactsBaseBigIntStrictFacts     TypeFacts = TypeFactsTypeofEQBigInt | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseBigIntFacts           TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsBigIntStrictFacts         TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsBigIntFacts               TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
	TypeFactsZeroBigIntStrictFacts     TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsFalsy
	TypeFactsZeroBigIntFacts           TypeFacts = TypeFactsBaseTypeFactsBigIntFacts
	TypeFactsNonZeroBigIntStrictFacts  TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy
	TypeFactsNonZeroBigIntFacts        TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
	TypeFactsBaseBooleanStrictFacts    TypeFacts = TypeFactsTypeofEQBoolean | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseBooleanFacts          TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsBooleanStrictFacts        TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsBooleanFacts              TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
	TypeFactsFalseStrictFacts          TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsFalsy
	TypeFactsFalseFacts                TypeFacts = TypeFactsBaseTypeFactsBooleanFacts
	TypeFactsTrueStrictFacts           TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy
	TypeFactsTrueFacts                 TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
	TypeFactsSymbolStrictFacts         TypeFacts = TypeFactsTypeofEQSymbol | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsSymbolFacts               TypeFacts = TypeFactsSymbolStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsObjectStrictFacts         TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsObjectFacts               TypeFacts = TypeFactsObjectStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsFunctionStrictFacts       TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsFunctionFacts             TypeFacts = TypeFactsFunctionStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsVoidFacts                 TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy
	TypeFactsUndefinedFacts            TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy | TypeFactsIsUndefined
	TypeFactsNullFacts                 TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNEUndefined | TypeFactsFalsy | TypeFactsIsNull
	TypeFactsEmptyObjectStrictFacts    TypeFacts = TypeFactsAll & ~(TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsTypeFactsIsUndefinedOrNull)
	TypeFactsEmptyObjectFacts          TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
	TypeFactsUnknownFacts              TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
	TypeFactsAllTypeofNE               TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsNEUndefined
	// Masks
	TypeFactsOrFactsMask  TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofNEObject
	TypeFactsAndFactsMask TypeFacts = TypeFactsAll & ~TypeFactsOrFactsMask
)

var typeofNEFacts ReadonlyMap[string, TypeFacts] = NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"string":    TypeFactsTypeofNEString,
	"number":    TypeFactsTypeofNENumber,
	"bigint":    TypeFactsTypeofNEBigInt,
	"boolean":   TypeFactsTypeofNEBoolean,
	"symbol":    TypeFactsTypeofNESymbol,
	"undefined": TypeFactsNEUndefined,
	"object":    TypeFactsTypeofNEObject,
	"function":  TypeFactsTypeofNEFunction,
}))

type TypeSystemEntity /* TODO(TS-TO-GO) TypeNode UnionType: Node | Symbol | Type | Signature */ any
type TypeSystemPropertyName int32

const (
	TypeSystemPropertyNameType TypeSystemPropertyName = iota
	TypeSystemPropertyNameResolvedBaseConstructorType
	TypeSystemPropertyNameDeclaredType
	TypeSystemPropertyNameResolvedReturnType
	TypeSystemPropertyNameImmediateBaseConstraint
	TypeSystemPropertyNameResolvedTypeArguments
	TypeSystemPropertyNameResolvedBaseTypes
	TypeSystemPropertyNameWriteType
	TypeSystemPropertyNameParameterInitializerContainsUndefined
)

// dprint-ignore
type CheckMode int32

const (
	CheckModeNormal               CheckMode = 0
	CheckModeContextual           CheckMode = 1 << 0
	CheckModeInferential          CheckMode = 1 << 1
	CheckModeSkipContextSensitive CheckMode = 1 << 2
	CheckModeSkipGenericFunctions CheckMode = 1 << 3
	CheckModeIsForSignatureHelp   CheckMode = 1 << 4
	CheckModeRestBindingElement   CheckMode = 1 << 5
	//   e.g. in `const { a, ...rest } = foo`, when checking the type of `foo` to determine the type of `rest`,
	//   we need to preserve generic types instead of substituting them for constraints
	CheckModeTypeOnly CheckMode = 1 << 6
)

/** @internal */
type SignatureCheckMode int32

const (
	SignatureCheckModeNone               SignatureCheckMode = 0
	SignatureCheckModeBivariantCallback  SignatureCheckMode = 1 << 0
	SignatureCheckModeStrictCallback     SignatureCheckMode = 1 << 1
	SignatureCheckModeIgnoreReturnTypes  SignatureCheckMode = 1 << 2
	SignatureCheckModeStrictArity        SignatureCheckMode = 1 << 3
	SignatureCheckModeStrictTopSignature SignatureCheckMode = 1 << 4
	SignatureCheckModeCallback           SignatureCheckMode = SignatureCheckModeBivariantSignatureCheckModeCallback | SignatureCheckModeStrictSignatureCheckModeCallback
)

type IntersectionState int32

const (
	IntersectionStateNone   IntersectionState = 0
	IntersectionStateSource IntersectionState = 1 << 0
	IntersectionStateTarget IntersectionState = 1 << 1
)

type RecursionFlags int32

const (
	RecursionFlagsNone   RecursionFlags = 0
	RecursionFlagsSource RecursionFlags = 1 << 0
	RecursionFlagsTarget RecursionFlags = 1 << 1
	RecursionFlagsBoth   RecursionFlags = RecursionFlagsSource | RecursionFlagsTarget
)

type MappedTypeModifiers int32

const (
	MappedTypeModifiersIncludeReadonly MappedTypeModifiers = 1 << 0
	MappedTypeModifiersExcludeReadonly MappedTypeModifiers = 1 << 1
	MappedTypeModifiersIncludeOptional MappedTypeModifiers = 1 << 2
	MappedTypeModifiersExcludeOptional MappedTypeModifiers = 1 << 3
)

type MappedTypeNameTypeKind int32

const (
	MappedTypeNameTypeKindNone MappedTypeNameTypeKind = iota
	MappedTypeNameTypeKindFiltering
	MappedTypeNameTypeKindRemapping
)

type ExpandingFlags int32

const (
	ExpandingFlagsNone   ExpandingFlags = 0
	ExpandingFlagsSource ExpandingFlags = 1
	ExpandingFlagsTarget ExpandingFlags = 1 << 1
	ExpandingFlagsBoth   ExpandingFlags = ExpandingFlagsSource | ExpandingFlagsTarget
)

type MembersOrExportsResolutionKind string

const (
	MembersOrExportsResolutionKindresolvedExports MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedExports"
	MembersOrExportsResolutionKindresolvedMembers MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedMembers"
)

type UnusedKind int32

const (
	UnusedKindLocal UnusedKind = iota
	UnusedKindParameter
)

/** @param containingNode Node to check for parse error */
type AddUnusedDiagnostic func(containingNode Node, type_ UnusedKind, diagnostic DiagnosticWithLocation)

var isNotOverloadAndNotAccessor = and(isNotOverload, isNotAccessor)

type DeclarationMeaning int32

const (
	DeclarationMeaningGetAccessor                DeclarationMeaning = 1
	DeclarationMeaningSetAccessor                DeclarationMeaning = 2
	DeclarationMeaningPropertyAssignment         DeclarationMeaning = 4
	DeclarationMeaningMethod                     DeclarationMeaning = 8
	DeclarationMeaningPrivateStatic              DeclarationMeaning = 16
	DeclarationMeaningGetOrSetAccessor           DeclarationMeaning = DeclarationMeaningGetAccessor | DeclarationMeaningSetAccessor
	DeclarationMeaningPropertyAssignmentOrMethod DeclarationMeaning = DeclarationMeaningPropertyAssignment | DeclarationMeaningMethod
)

type DeclarationSpaces int32

const (
	DeclarationSpacesNone            DeclarationSpaces = 0
	DeclarationSpacesExportValue     DeclarationSpaces = 1 << 0
	DeclarationSpacesExportType      DeclarationSpaces = 1 << 1
	DeclarationSpacesExportNamespace DeclarationSpaces = 1 << 2
)

type MinArgumentCountFlags int32

const (
	MinArgumentCountFlagsNone                    MinArgumentCountFlags = 0
	MinArgumentCountFlagsStrongArityForUntypedJS MinArgumentCountFlags = 1 << 0
	MinArgumentCountFlagsVoidIsNonOptional       MinArgumentCountFlags = 1 << 1
)

type IntrinsicTypeKind int32

const (
	IntrinsicTypeKindUppercase IntrinsicTypeKind = iota
	IntrinsicTypeKindLowercase
	IntrinsicTypeKindCapitalize
	IntrinsicTypeKindUncapitalize
	IntrinsicTypeKindNoInfer
)

var intrinsicTypeKinds ReadonlyMap[string, IntrinsicTypeKind] = NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"Uppercase":    IntrinsicTypeKindUppercase,
	"Lowercase":    IntrinsicTypeKindLowercase,
	"Capitalize":   IntrinsicTypeKindCapitalize,
	"Uncapitalize": IntrinsicTypeKindUncapitalize,
	"NoInfer":      IntrinsicTypeKindNoInfer,
}))
var SymbolLinks = /* TODO(TS-TO-GO) Node ClassExpression: class implements SymbolLinks { declare _symbolLinksBrand: any;
} */TODO

func NodeLinks(this NodeLinks) {
	this.flags = NodeCheckFlagsNone
}

/** @internal */
func getNodeId(node Node) number {
	if !node.id {
		node.id = nextNodeId
		nextNodeId++
	}
	return node.id
}

/** @internal */
func getSymbolId(symbol Symbol) SymbolId {
	if !symbol.id {
		symbol.id = nextSymbolId
		nextSymbolId++
	}
	return symbol.id
}

/** @internal */
func isInstantiatedModule(node ModuleDeclaration, preserveConstEnums bool) bool {
	moduleState := getModuleInstanceState(node)
	return moduleState == ModuleInstanceStateInstantiated || (preserveConstEnums && moduleState == ModuleInstanceStateConstEnumOnly)
}

/** @internal */
func createTypeChecker(host TypeCheckerHost) TypeChecker {
	// Why var? It avoids TDZ checks in the runtime which can be costly.
	// See: https://github.com/microsoft/TypeScript/issues/52924
	/* eslint-disable no-var */
	var deferredDiagnosticsCallbacks []func() = []never{}
	addLazyDiagnostic := func(arg func()) {
		deferredDiagnosticsCallbacks.push(arg)
	}
	// Cancellation that controls whether or not we can cancel in the middle of type checking.
	// In general cancelling is *not* safe for the type checker.  We might be in the middle of
	// computing something, and we will leave our internals in an inconsistent state.  Callers
	// who set the cancellation token should catch if a cancellation exception occurs, and
	// should throw away and create a new TypeChecker.
	//
	// Currently we only support setting the cancellation token when getting diagnostics.  This
	// is because diagnostics can be quite expensive, and we want to allow hosts to bail out if
	// they no longer need the information (for example, if the user started editing again).
	var cancellationToken CancellationToken
	var scanner *Scanner
	Symbol := objectAllocator.getSymbolConstructor()
	Type := objectAllocator.getTypeConstructor()
	Signature := objectAllocator.getSignatureConstructor()
	typeCount := 0
	symbolCount := 0
	totalInstantiationCount := 0
	instantiationCount := 0
	instantiationDepth := 0
	inlineLevel := 0
	var currentNode Node
	var varianceTypeParameter *TypeParameter
	isInferencePartiallyBlocked := false
	emptySymbols := createSymbolTable()
	arrayVariances := []VarianceFlags{VarianceFlagsCovariant}
	compilerOptions := host.getCompilerOptions()
	languageVersion := getEmitScriptTarget(compilerOptions)
	moduleKind := getEmitModuleKind(compilerOptions)
	legacyDecorators := !!compilerOptions.experimentalDecorators
	useDefineForClassFields := getUseDefineForClassFields(compilerOptions)
	emitStandardClassFields := getEmitStandardClassFields(compilerOptions)
	allowSyntheticDefaultImports := getAllowSyntheticDefaultImports(compilerOptions)
	strictNullChecks := getStrictOptionValue(compilerOptions, "strictNullChecks")
	strictFunctionTypes := getStrictOptionValue(compilerOptions, "strictFunctionTypes")
	strictBindCallApply := getStrictOptionValue(compilerOptions, "strictBindCallApply")
	strictPropertyInitialization := getStrictOptionValue(compilerOptions, "strictPropertyInitialization")
	strictBuiltinIteratorReturn := getStrictOptionValue(compilerOptions, "strictBuiltinIteratorReturn")
	noImplicitAny := getStrictOptionValue(compilerOptions, "noImplicitAny")
	noImplicitThis := getStrictOptionValue(compilerOptions, "noImplicitThis")
	useUnknownInCatchVariables := getStrictOptionValue(compilerOptions, "useUnknownInCatchVariables")
	exactOptionalPropertyTypes := compilerOptions.exactOptionalPropertyTypes
	noUncheckedSideEffectImports := !!compilerOptions.noUncheckedSideEffectImports
	checkBinaryExpression := createCheckBinaryExpression()
	emitResolver := createResolver()
	nodeBuilder := createNodeBuilder()
	syntacticNodeBuilder := createSyntacticTypeNodeBuilder(compilerOptions, map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"isEntityNameVisible":             isEntityNameVisible,
		"isExpandoFunctionDeclaration":    isExpandoFunctionDeclaration,
		"getAllAccessorDeclarations":      getAllAccessorDeclarationsForDeclaration,
		"requiresAddingImplicitUndefined": requiresAddingImplicitUndefined,
		"isUndefinedIdentifierExpression": func(node Identifier) bool {
			Debug.assert(isExpressionNode(node))
			return getSymbolAtLocation(node) == undefinedSymbol
		},
		"isDefinitelyReferenceToGlobalSymbolObject": isDefinitelyReferenceToGlobalSymbolObject,
	})
	evaluate := createEvaluator(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"evaluateElementAccessExpression": evaluateElementAccessExpression,
		"evaluateEntityNameExpression":    evaluateEntityNameExpression,
	})
	globals := createSymbolTable()
	undefinedSymbol := createSymbol(SymbolFlagsProperty, "undefined" /* as __String */)
	undefinedSymbol.declarations = []never{}
	globalThisSymbol := createSymbol(SymbolFlagsModule, "globalThis" /* as __String */, CheckFlagsReadonly)
	globalThisSymbol.exports = globals
	globalThisSymbol.declarations = []never{}
	globals.set(globalThisSymbol.escapedName, globalThisSymbol)
	argumentsSymbol := createSymbol(SymbolFlagsProperty, "arguments" /* as __String */)
	requireSymbol := createSymbol(SymbolFlagsProperty, "require" /* as __String */)
	var isolatedModulesLikeFlagName string
	// TODO(TS-TO-GO): converted from conditional expression
	switch {
	case compilerOptions.verbatimModuleSyntax:
		isolatedModulesLikeFlagName = "verbatimModuleSyntax"
	default:
		isolatedModulesLikeFlagName = "isolatedModules"
	}
	canCollectSymbolAliasAccessabilityData := !compilerOptions.verbatimModuleSyntax
	/** This will be set during calls to `getResolvedSignature` where services determines an apparent number of arguments greater than what is actually provided. */
	var apparentArgumentCount *number
	var lastGetCombinedNodeFlagsNode Node
	lastGetCombinedNodeFlagsResult := NodeFlagsNone
	var lastGetCombinedModifierFlagsNode Declaration
	lastGetCombinedModifierFlagsResult := ModifierFlagsNone
	resolveName := createNameResolver(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"compilerOptions":                  compilerOptions,
		"requireSymbol":                    requireSymbol,
		"argumentsSymbol":                  argumentsSymbol,
		"globals":                          globals,
		"getSymbolOfDeclaration":           getSymbolOfDeclaration,
		"error":                            error,
		"getRequiresScopeChangeCache":      getRequiresScopeChangeCache,
		"setRequiresScopeChangeCache":      setRequiresScopeChangeCache,
		"lookup":                           getSymbol,
		"onPropertyWithInvalidInitializer": checkAndReportErrorForInvalidInitializer,
		"onFailedToResolveSymbol":          onFailedToResolveSymbol,
		"onSuccessfullyResolvedSymbol":     onSuccessfullyResolvedSymbol,
	})
	resolveNameForSymbolSuggestion := createNameResolver(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"compilerOptions":             compilerOptions,
		"requireSymbol":               requireSymbol,
		"argumentsSymbol":             argumentsSymbol,
		"globals":                     globals,
		"getSymbolOfDeclaration":      getSymbolOfDeclaration,
		"error":                       error,
		"getRequiresScopeChangeCache": getRequiresScopeChangeCache,
		"setRequiresScopeChangeCache": setRequiresScopeChangeCache,
		"lookup":                      getSuggestionForSymbolNameLookup,
	})
	// for public members that accept a Node or one of its subtypes, we must guard against
	// synthetic nodes created during transformations by calling `getParseTreeNode`.
	// for most of these, we perform the guard only on `checker` to avoid any possible
	// extra cost of calling `getParseTreeNode` when calling these functions from inside the
	// checker.
	var checker TypeChecker = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"getNodeCount": func() number {
			return reduceLeft(host.getSourceFiles(), func(n number, s SourceFile) number {
				return n + s.nodeCount
			}, 0)
		},
		"getIdentifierCount": func() number {
			return reduceLeft(host.getSourceFiles(), func(n number, s SourceFile) number {
				return n + s.identifierCount
			}, 0)
		},
		"getSymbolCount": func() number {
			return reduceLeft(host.getSourceFiles(), func(n number, s SourceFile) number {
				return n + s.symbolCount
			}, symbolCount)
		},
		"getTypeCount": func() number {
			return typeCount
		},
		"getInstantiationCount": func() number {
			return totalInstantiationCount
		},
		"getRelationCacheSizes": func() /* TODO(TS-TO-GO) inferred type { assignable: number; identity: number; subtype: number; strictSubtype: number; } */ any {
			return (map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"assignable":    assignableRelation.size,
				"identity":      identityRelation.size,
				"subtype":       subtypeRelation.size,
				"strictSubtype": strictSubtypeRelation.size,
			})
		},
		"isUndefinedSymbol": func(symbol Symbol) bool {
			return symbol == undefinedSymbol
		},
		"isArgumentsSymbol": func(symbol Symbol) bool {
			return symbol == argumentsSymbol
		},
		"isUnknownSymbol": func(symbol Symbol) bool {
			return symbol == unknownSymbol
		},
		"getMergedSymbol":        getMergedSymbol,
		"symbolIsValue":          symbolIsValue,
		"getDiagnostics":         getDiagnostics,
		"getGlobalDiagnostics":   getGlobalDiagnostics,
		"getRecursionIdentity":   getRecursionIdentity,
		"getUnmatchedProperties": getUnmatchedProperties,
		"getTypeOfSymbolAtLocation": func(symbol Symbol, locationIn Node) Type {
			location := getParseTreeNode(locationIn)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case location:
				return getTypeOfSymbolAtLocation(symbol, location)
			default:
				return errorType
			}
		},
		"getTypeOfSymbol": getTypeOfSymbol,
		"getSymbolsOfParameterPropertyDeclaration": func(parameterIn ParameterDeclaration, parameterName string) /* TODO(TS-TO-GO) inferred type [Symbol, Symbol] */ any {
			parameter := getParseTreeNode(parameterIn, isParameter)
			if parameter == nil {
				return Debug.fail("Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.")
			}
			Debug.assert(isParameterPropertyDeclaration(parameter, parameter.parent))
			return getSymbolsOfParameterPropertyDeclaration(parameter, escapeLeadingUnderscores(parameterName))
		},
		"getDeclaredTypeOfSymbol": getDeclaredTypeOfSymbol,
		"getPropertiesOfType":     getPropertiesOfType,
		"getPropertyOfType": func(type_ Type, name string) Symbol {
			return getPropertyOfType(type_, escapeLeadingUnderscores(name))
		},
		"getPrivateIdentifierPropertyOfType": func(leftType Type, name string, location Node) Symbol {
			node := getParseTreeNode(location)
			if !node {
				return nil
			}
			propName := escapeLeadingUnderscores(name)
			lexicallyScopedIdentifier := lookupSymbolForPrivateIdentifierDeclaration(propName, node)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case lexicallyScopedIdentifier:
				return getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier)
			default:
				return nil
			}
		},
		"getTypeOfPropertyOfType": func(type_ Type, name string) Type {
			return getTypeOfPropertyOfType(type_, escapeLeadingUnderscores(name))
		},
		"getIndexInfoOfType": func(type_ Type, kind IndexKind) *IndexInfo {
			return getIndexInfoOfType(type_, __COND__(kind == IndexKindString, stringType, numberType))
		},
		"getIndexInfosOfType":        getIndexInfosOfType,
		"getIndexInfosOfIndexSymbol": getIndexInfosOfIndexSymbol,
		"getSignaturesOfType":        getSignaturesOfType,
		"getIndexTypeOfType": func(type_ Type, kind IndexKind) Type {
			return getIndexTypeOfType(type_, __COND__(kind == IndexKindString, stringType, numberType))
		},
		"getIndexType": func(type_ Type) Type {
			return getIndexType(type_)
		},
		"getBaseTypes":             getBaseTypes,
		"getBaseTypeOfLiteralType": getBaseTypeOfLiteralType,
		"getWidenedType":           getWidenedType,
		"getWidenedLiteralType":    getWidenedLiteralType,
		"getTypeFromTypeNode": func(nodeIn TypeNode) Type {
			node := getParseTreeNode(nodeIn, isTypeNode)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node:
				return getTypeFromTypeNode(node)
			default:
				return errorType
			}
		},
		"getParameterType":                     getTypeAtPosition,
		"getParameterIdentifierInfoAtPosition": getParameterIdentifierInfoAtPosition,
		"getPromisedTypeOfPromise":             getPromisedTypeOfPromise,
		"getAwaitedType": func(type_ Type) Type {
			return getAwaitedType(type_)
		},
		"getReturnTypeOfSignature":             getReturnTypeOfSignature,
		"isNullableType":                       isNullableType,
		"getNullableType":                      getNullableType,
		"getNonNullableType":                   getNonNullableType,
		"getNonOptionalType":                   removeOptionalTypeMarker,
		"getTypeArguments":                     getTypeArguments,
		"typeToTypeNode":                       nodeBuilder.typeToTypeNode,
		"typePredicateToTypePredicateNode":     nodeBuilder.typePredicateToTypePredicateNode,
		"indexInfoToIndexSignatureDeclaration": nodeBuilder.indexInfoToIndexSignatureDeclaration,
		"signatureToSignatureDeclaration":      nodeBuilder.signatureToSignatureDeclaration,
		"symbolToEntityName":                   nodeBuilder.symbolToEntityName,
		"symbolToExpression":                   nodeBuilder.symbolToExpression,
		"symbolToNode":                         nodeBuilder.symbolToNode,
		"symbolToTypeParameterDeclarations":    nodeBuilder.symbolToTypeParameterDeclarations,
		"symbolToParameterDeclaration":         nodeBuilder.symbolToParameterDeclaration,
		"typeParameterToDeclaration":           nodeBuilder.typeParameterToDeclaration,
		"getSymbolsInScope": func(locationIn Node, meaning SymbolFlags) []Symbol {
			location := getParseTreeNode(locationIn)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case location:
				return getSymbolsInScope(location, meaning)
			default:
				return []never{}
			}
		},
		"getSymbolAtLocation": func(nodeIn Node) Symbol {
			node := getParseTreeNode(nodeIn)
			// set ignoreErrors: true because any lookups invoked by the API shouldn't cause any new errors
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node:
				return getSymbolAtLocation(node /*ignoreErrors*/, true)
			default:
				return nil
			}
		},
		"getIndexInfosAtLocation": func(nodeIn Node) *[]IndexInfo {
			node := getParseTreeNode(nodeIn)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node:
				return getIndexInfosAtLocation(node)
			default:
				return nil
			}
		},
		"getShorthandAssignmentValueSymbol": func(nodeIn Node) Symbol {
			node := getParseTreeNode(nodeIn)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node:
				return getShorthandAssignmentValueSymbol(node)
			default:
				return nil
			}
		},
		"getExportSpecifierLocalTargetSymbol": func(nodeIn /* TODO(TS-TO-GO) inferred type Identifier | ExportSpecifier */ any) Symbol {
			node := getParseTreeNode(nodeIn, isExportSpecifier)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node:
				return getExportSpecifierLocalTargetSymbol(node)
			default:
				return nil
			}
		},
		"getExportSymbolOfSymbol": func(symbol Symbol) Symbol {
			return getMergedSymbol(symbol.exportSymbol || symbol)
		},
		"getTypeAtLocation": func(nodeIn Node) Type {
			node := getParseTreeNode(nodeIn)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node:
				return getTypeOfNode(node)
			default:
				return errorType
			}
		},
		"getTypeOfAssignmentPattern": func(nodeIn AssignmentPattern) Type {
			node := getParseTreeNode(nodeIn, isAssignmentPattern)
			return node && getTypeOfAssignmentPattern(node) || errorType
		},
		"getPropertySymbolOfDestructuringAssignment": func(locationIn Identifier) Symbol {
			location := getParseTreeNode(locationIn, isIdentifier)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case location:
				return getPropertySymbolOfDestructuringAssignment(location)
			default:
				return nil
			}
		},
		"signatureToString": func(signature Signature, enclosingDeclaration Node, flags *TypeFormatFlags, kind *SignatureKind) string {
			return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind)
		},
		"typeToString": func(type_ Type, enclosingDeclaration Node, flags *TypeFormatFlags) string {
			return typeToString(type_, getParseTreeNode(enclosingDeclaration), flags)
		},
		"symbolToString": func(symbol Symbol, enclosingDeclaration Node, meaning *SymbolFlags, flags *SymbolFormatFlags) string {
			return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags)
		},
		"typePredicateToString": func(predicate TypePredicate, enclosingDeclaration Node, flags *TypeFormatFlags) string {
			return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags)
		},
		"writeSignature": func(signature Signature, enclosingDeclaration Node, flags *TypeFormatFlags, kind *SignatureKind, writer *EmitTextWriter) string {
			return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind, writer)
		},
		"writeType": func(type_ Type, enclosingDeclaration Node, flags *TypeFormatFlags, writer *EmitTextWriter) string {
			return typeToString(type_, getParseTreeNode(enclosingDeclaration), flags, writer)
		},
		"writeSymbol": func(symbol Symbol, enclosingDeclaration Node, meaning *SymbolFlags, flags *SymbolFormatFlags, writer *EmitTextWriter) string {
			return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags, writer)
		},
		"writeTypePredicate": func(predicate TypePredicate, enclosingDeclaration Node, flags *TypeFormatFlags, writer *EmitTextWriter) string {
			return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags, writer)
		},
		"getAugmentedPropertiesOfType": getAugmentedPropertiesOfType,
		"getRootSymbols":               getRootSymbols,
		"getSymbolOfExpando":           getSymbolOfExpando,
		"getContextualType": func(nodeIn Expression, contextFlags ContextFlags) Type {
			node := getParseTreeNode(nodeIn, isExpression)
			if !node {
				return nil
			}
			if contextFlags & ContextFlagsCompletions {
				return runWithInferenceBlockedFromSourceNode(node, func() Type {
					return getContextualType(node, contextFlags)
				})
			}
			return getContextualType(node, contextFlags)
		},
		"getContextualTypeForObjectLiteralElement": func(nodeIn ObjectLiteralElementLike) Type {
			node := getParseTreeNode(nodeIn, isObjectLiteralElementLike)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node:
				return getContextualTypeForObjectLiteralElement(node /*contextFlags*/, nil)
			default:
				return nil
			}
		},
		"getContextualTypeForArgumentAtIndex": func(nodeIn CallLikeExpression, argIndex number) Type {
			node := getParseTreeNode(nodeIn, isCallLikeExpression)
			return node && getContextualTypeForArgumentAtIndex(node, argIndex)
		},
		"getContextualTypeForJsxAttribute": func(nodeIn /* TODO(TS-TO-GO) inferred type JsxAttribute | JsxSpreadAttribute */ any) Type {
			node := getParseTreeNode(nodeIn, isJsxAttributeLike)
			return node && getContextualTypeForJsxAttribute(node /*contextFlags*/, nil)
		},
		"isContextSensitive":                isContextSensitive,
		"getTypeOfPropertyOfContextualType": getTypeOfPropertyOfContextualType,
		"getFullyQualifiedName":             getFullyQualifiedName,
		"getResolvedSignature": func(node CallLikeExpression, candidatesOutArray *[]Signature, argumentCount *number) *Signature {
			return getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckModeNormal)
		},
		"getCandidateSignaturesForStringLiteralCompletions": getCandidateSignaturesForStringLiteralCompletions,
		"getResolvedSignatureForSignatureHelp": func(node CallLikeExpression, candidatesOutArray *[]Signature, argumentCount *number) *Signature {
			return runWithoutResolvedSignatureCaching(node, func() *Signature {
				return getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckModeIsForSignatureHelp)
			})
		},
		"getExpandedParameters":      getExpandedParameters,
		"hasEffectiveRestParameter":  hasEffectiveRestParameter,
		"containsArgumentsReference": containsArgumentsReference,
		"getConstantValue": func(nodeIn /* TODO(TS-TO-GO) inferred type PropertyAccessExpression | ElementAccessExpression | EnumMember */ any) * /* TODO(TS-TO-GO) inferred type string | number */ any {
			node := getParseTreeNode(nodeIn, canHaveConstantValue)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node:
				return getConstantValue(node)
			default:
				return nil
			}
		},
		"isValidPropertyAccess": func(nodeIn /* TODO(TS-TO-GO) inferred type PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, propertyName string) bool {
			node := getParseTreeNode(nodeIn, isPropertyAccessOrQualifiedNameOrImportTypeNode)
			return !!node && isValidPropertyAccess(node, escapeLeadingUnderscores(propertyName))
		},
		"isValidPropertyAccessForCompletions": func(nodeIn /* TODO(TS-TO-GO) inferred type PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, type_ Type, property Symbol) bool {
			node := getParseTreeNode(nodeIn, isPropertyAccessExpression)
			return !!node && isValidPropertyAccessForCompletions(node, type_, property)
		},
		"getSignatureFromDeclaration": func(declarationIn SignatureDeclaration) *Signature {
			declaration := getParseTreeNode(declarationIn, isFunctionLike)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case declaration:
				return getSignatureFromDeclaration(declaration)
			default:
				return nil
			}
		},
		"isImplementationOfOverload": func(nodeIn SignatureDeclaration) *bool {
			node := getParseTreeNode(nodeIn, isFunctionLike)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node:
				return isImplementationOfOverload(node)
			default:
				return nil
			}
		},
		"getImmediateAliasedSymbol":        getImmediateAliasedSymbol,
		"getAliasedSymbol":                 resolveAlias,
		"getEmitResolver":                  getEmitResolver,
		"requiresAddingImplicitUndefined":  requiresAddingImplicitUndefined,
		"getExportsOfModule":               getExportsOfModuleAsArray,
		"getExportsAndPropertiesOfModule":  getExportsAndPropertiesOfModule,
		"forEachExportAndPropertyOfModule": forEachExportAndPropertyOfModule,
		"getSymbolWalker":                  createGetSymbolWalker(getRestTypeOfSignature, getTypePredicateOfSignature, getReturnTypeOfSignature, getBaseTypes, resolveStructuredTypeMembers, getTypeOfSymbol, getResolvedSymbol, getConstraintOfTypeParameter, getFirstIdentifier, getTypeArguments),
		"getAmbientModules":                getAmbientModules,
		"getJsxIntrinsicTagNamesAt":        getJsxIntrinsicTagNamesAt,
		"isOptionalParameter": func(nodeIn ParameterDeclaration) bool {
			node := getParseTreeNode(nodeIn, isParameter)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node:
				return isOptionalParameter(node)
			default:
				return false
			}
		},
		"tryGetMemberInModuleExports": func(name string, symbol Symbol) Symbol {
			return tryGetMemberInModuleExports(escapeLeadingUnderscores(name), symbol)
		},
		"tryGetMemberInModuleExportsAndProperties": func(name string, symbol Symbol) Symbol {
			return tryGetMemberInModuleExportsAndProperties(escapeLeadingUnderscores(name), symbol)
		},
		"tryFindAmbientModule": func(moduleName string) Symbol {
			return tryFindAmbientModule(moduleName /*withAugmentations*/, true)
		},
		"getApparentType":     getApparentType,
		"getUnionType":        getUnionType,
		"isTypeAssignableTo":  isTypeAssignableTo,
		"createAnonymousType": createAnonymousType,
		"createSignature":     createSignature,
		"createSymbol":        createSymbol,
		"createIndexInfo":     createIndexInfo,
		"getAnyType": func() IntrinsicType {
			return anyType
		},
		"getStringType": func() IntrinsicType {
			return stringType
		},
		"getStringLiteralType": getStringLiteralType,
		"getNumberType": func() IntrinsicType {
			return numberType
		},
		"getNumberLiteralType": getNumberLiteralType,
		"getBigIntType": func() IntrinsicType {
			return bigintType
		},
		"getBigIntLiteralType":      getBigIntLiteralType,
		"createPromiseType":         createPromiseType,
		"createArrayType":           createArrayType,
		"getElementTypeOfArrayType": getElementTypeOfArrayType,
		"getBooleanType": func() Type {
			return booleanType
		},
		"getFalseType": func(fresh any) FreshableIntrinsicType {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case fresh:
				return falseType
			default:
				return regularFalseType
			}
		},
		"getTrueType": func(fresh any) FreshableIntrinsicType {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case fresh:
				return trueType
			default:
				return regularTrueType
			}
		},
		"getVoidType": func() IntrinsicType {
			return voidType
		},
		"getUndefinedType": func() IntrinsicType {
			return undefinedType
		},
		"getNullType": func() IntrinsicType {
			return nullType
		},
		"getESSymbolType": func() IntrinsicType {
			return esSymbolType
		},
		"getNeverType": func() IntrinsicType {
			return neverType
		},
		"getOptionalType": func() IntrinsicType {
			return optionalType
		},
		"getPromiseType": func() GenericType {
			return getGlobalPromiseType(false)
		},
		"getPromiseLikeType": func() GenericType {
			return getGlobalPromiseLikeType(false)
		},
		"getAnyAsyncIterableType": func() *TypeReference {
			type_ := getGlobalAsyncIterableType(false)
			if type_ == emptyGenericType {
				return nil
			}
			return createTypeReference(type_, []IntrinsicType{anyType, anyType, anyType})
		},
		"isSymbolAccessible":                           isSymbolAccessible,
		"isArrayType":                                  isArrayType,
		"isTupleType":                                  isTupleType,
		"isArrayLikeType":                              isArrayLikeType,
		"isEmptyAnonymousObjectType":                   isEmptyAnonymousObjectType,
		"isTypeInvalidDueToUnionDiscriminant":          isTypeInvalidDueToUnionDiscriminant,
		"getExactOptionalProperties":                   getExactOptionalProperties,
		"getAllPossiblePropertiesOfTypes":              getAllPossiblePropertiesOfTypes,
		"getSuggestedSymbolForNonexistentProperty":     getSuggestedSymbolForNonexistentProperty,
		"getSuggestedSymbolForNonexistentJSXAttribute": getSuggestedSymbolForNonexistentJSXAttribute,
		"getSuggestedSymbolForNonexistentSymbol": func(location Node, name string, meaning SymbolFlags) Symbol {
			return getSuggestedSymbolForNonexistentSymbol(location, escapeLeadingUnderscores(name), meaning)
		},
		"getSuggestedSymbolForNonexistentModule":      getSuggestedSymbolForNonexistentModule,
		"getSuggestedSymbolForNonexistentClassMember": getSuggestedSymbolForNonexistentClassMember,
		"getBaseConstraintOfType":                     getBaseConstraintOfType,
		"getDefaultFromTypeParameter": func(type_ Type) Type {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case type_ && type_.flags&TypeFlagsTypeParameter:
				return getDefaultFromTypeParameter(type_ /* as TypeParameter */)
			default:
				return nil
			}
		},
		"resolveName": func(name string, location Node, meaning SymbolFlags, excludeGlobals bool) Symbol {
			return resolveName(location, escapeLeadingUnderscores(name), meaning /*nameNotFoundMessage*/, nil /*isUse*/, false, excludeGlobals)
		},
		"getJsxNamespace": func(n Node) string {
			return unescapeLeadingUnderscores(getJsxNamespace(n))
		},
		"getJsxFragmentFactory": func(n Node) *string {
			jsxFragmentFactory := getJsxFragmentFactoryEntity(n)
			return jsxFragmentFactory && unescapeLeadingUnderscores(getFirstIdentifier(jsxFragmentFactory).escapedText)
		},
		"getAccessibleSymbolChain":    getAccessibleSymbolChain,
		"getTypePredicateOfSignature": getTypePredicateOfSignature,
		"resolveExternalModuleName": func(moduleSpecifierIn Expression) Symbol {
			moduleSpecifier := getParseTreeNode(moduleSpecifierIn, isExpression)
			return moduleSpecifier && resolveExternalModuleName(moduleSpecifier, moduleSpecifier /*ignoreErrors*/, true)
		},
		"resolveExternalModuleSymbol": resolveExternalModuleSymbol,
		"tryGetThisTypeAt": func(nodeIn Node, includeGlobalThis *bool, container *ThisContainer) Type {
			node := getParseTreeNode(nodeIn)
			return node && tryGetThisTypeAt(node, includeGlobalThis, container)
		},
		"getTypeArgumentConstraint": func(nodeIn TypeNode) Type {
			node := getParseTreeNode(nodeIn, isTypeNode)
			return node && getTypeArgumentConstraint(node)
		},
		"getSuggestionDiagnostics": func(fileIn SourceFile, ct CancellationToken) []DiagnosticWithLocation {
			file := getParseTreeNode(fileIn, isSourceFile) || Debug.fail("Could not determine parsed source file.")
			if skipTypeChecking(file, compilerOptions, host) {
				return emptyArray
			}
			var diagnostics *[]DiagnosticWithLocation
			// TODO(TS-TO-GO): try
			{
				// Record the cancellation token so it can be checked later on during checkSourceElement.
				// Do this in a finally block so we can ensure that it gets reset back to nothing after
				// this call is done.
				cancellationToken = ct
				// Ensure file is type checked, with _eager_ diagnostic production, so identifiers are registered as potentially unused
				checkSourceFileWithEagerDiagnostics(file)
				Debug.assert(!!(getNodeLinks(file).flags & NodeCheckFlagsTypeChecked))
				diagnostics = addRange(diagnostics, suggestionDiagnostics.getDiagnostics(file.fileName))
				checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), func(containingNode Node, kind UnusedKind, diag DiagnosticWithLocation) {
					if !containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags&NodeFlagsAmbient)) {
						(diagnostics || ( /* TODO(TS-TO-GO) Node BinaryExpression: diagnostics = [] */ TODO)).push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
							/* TODO(TS-TO-GO) Node SpreadAssignment: ...diag */
							"category": DiagnosticCategorySuggestion,
						})
					}
				})
				return diagnostics || emptyArray
			}
			/* TODO(TS-TO-GO) Node Block: { cancellationToken = undefined; } */
			/* TODO(TS-TO-GO) Node TryStatement: try { // Record the cancellation token so it can be checked later on during checkSourceElement. // Do this in a finally block so we can ensure that it gets reset back to nothing after // this call is done. cancellationToken = ct; // Ensure file is type checked, with _eager_ diagnostic production, so identifiers are registered as potentially unused checkSourceFileWithEagerDiagnostics(file); Debug.assert(!!(getNodeLinks(file).flags & NodeCheckFlags.TypeChecked)); diagnostics = addRange(diagnostics, suggestionDiagnostics.getDiagnostics(file.fileName)); checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), (containingNode, kind, diag) => { if (!containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) { (diagnostics || (diagnostics = [])).push({ ...diag, category: DiagnosticCategory.Suggestion }); } }); return diagnostics || emptyArray; } finally { cancellationToken = undefined; } */
		},
		"runWithCancellationToken": func(token CancellationToken, callback /* TODO(TS-TO-GO) inferred type ((checker: TypeChecker) => T) | ((checker: TypeChecker) => T) */ any) T {
			// TODO(TS-TO-GO): try
			{
				cancellationToken = token
				return callback(checker)
			}
			/* TODO(TS-TO-GO) Node Block: { cancellationToken = undefined; } */
			/* TODO(TS-TO-GO) Node TryStatement: try { cancellationToken = token; return callback(checker); } finally { cancellationToken = undefined; } */
		},
		"getLocalTypeParametersOfClassOrInterfaceOrTypeAlias": getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,
		"isDeclarationVisible":                                isDeclarationVisible,
		"isPropertyAccessible":                                isPropertyAccessible,
		"getTypeOnlyAliasDeclaration":                         getTypeOnlyAliasDeclaration,
		"getMemberOverrideModifierStatus":                     getMemberOverrideModifierStatus,
		"isTypeParameterPossiblyReferenced":                   isTypeParameterPossiblyReferenced,
		"typeHasCallOrConstructSignatures":                    typeHasCallOrConstructSignatures,
		"getSymbolFlags":                                      getSymbolFlags,
	}
	getCandidateSignaturesForStringLiteralCompletions := func(call CallLikeExpression, editingArgument Node) []Signature {
		candidatesSet := NewSet[Signature]()
		var candidates []Signature = []never{}
		// first, get candidates when inference is blocked from the source node.
		runWithInferenceBlockedFromSourceNode(editingArgument, func() *Signature {
			return getResolvedSignatureWorker(call, candidates /*argumentCount*/, nil, CheckModeNormal)
		})
		for _, candidate := range candidates {
			candidatesSet.add(candidate)
		}
		// reset candidates for second pass
		candidates.length = 0
		// next, get candidates where the source node is considered for inference.
		runWithoutResolvedSignatureCaching(editingArgument, func() *Signature {
			return getResolvedSignatureWorker(call, candidates /*argumentCount*/, nil, CheckModeNormal)
		})
		for _, candidate := range candidates {
			candidatesSet.add(candidate)
		}
		return arrayFrom(candidatesSet)
	}
	runWithoutResolvedSignatureCaching := func(node Node, fn func() T) T {
		node = findAncestor(node, isCallLikeOrFunctionLikeExpression)
		if node {
			cachedResolvedSignatures := []never{}
			cachedTypes := []never{}
			for node {
				nodeLinks := getNodeLinks(node)
				cachedResolvedSignatures.push([]any{nodeLinks, nodeLinks.resolvedSignature} /* as const */)
				nodeLinks.resolvedSignature = nil
				if isFunctionExpressionOrArrowFunction(node) {
					symbolLinks := getSymbolLinks(getSymbolOfDeclaration(node))
					type_ := symbolLinks.type_
					cachedTypes.push([]any{symbolLinks, type_} /* as const */)
					symbolLinks.type_ = nil
				}
				node = findAncestor(node.parent, isCallLikeOrFunctionLikeExpression)
			}
			result := fn()
			for _, TODO_IDENTIFIER := range cachedResolvedSignatures {
				nodeLinks.resolvedSignature = resolvedSignature
			}
			for _, TODO_IDENTIFIER := range cachedTypes {
				symbolLinks.type_ = type_
			}
			return result
		}
		return fn()
	}
	runWithInferenceBlockedFromSourceNode := func(node Node, fn func() T) T {
		containingCall := findAncestor(node, isCallLikeExpression)
		if containingCall {
			toMarkSkip := node
			// TODO(TS-TO-GO): refactor do-while loop approximation
			for ok := true; ok; ok = toMarkSkip && toMarkSkip != containingCall {
				getNodeLinks(toMarkSkip).skipDirectInference = true
				toMarkSkip = toMarkSkip.parent
			}
		}
		isInferencePartiallyBlocked = true
		result := runWithoutResolvedSignatureCaching(node, fn)
		isInferencePartiallyBlocked = false
		if containingCall {
			toMarkSkip := node
			// TODO(TS-TO-GO): refactor do-while loop approximation
			for ok := true; ok; ok = toMarkSkip && toMarkSkip != containingCall {
				getNodeLinks(toMarkSkip).skipDirectInference = nil
				toMarkSkip = toMarkSkip.parent
			}
		}
		return result
	}
	getResolvedSignatureWorker := func(nodeIn CallLikeExpression, candidatesOutArray *[]Signature, argumentCount *number, checkMode CheckMode) *Signature {
		node := getParseTreeNode(nodeIn, isCallLikeExpression)
		apparentArgumentCount = argumentCount
		var res *Signature
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case !node:
			res = nil
		default:
			res = getResolvedSignature(node, candidatesOutArray, checkMode)
		}
		apparentArgumentCount = nil
		return res
	}
	tupleTypes := NewMap[string, GenericType]()
	unionTypes := NewMap[string, UnionType]()
	unionOfUnionTypes := NewMap[string, Type]()
	intersectionTypes := NewMap[string, Type]()
	stringLiteralTypes := NewMap[string, StringLiteralType]()
	numberLiteralTypes := NewMap[number, NumberLiteralType]()
	bigIntLiteralTypes := NewMap[string, BigIntLiteralType]()
	enumLiteralTypes := NewMap[string, LiteralType]()
	indexedAccessTypes := NewMap[string, IndexedAccessType]()
	templateLiteralTypes := NewMap[string, TemplateLiteralType]()
	stringMappingTypes := NewMap[string, StringMappingType]()
	substitutionTypes := NewMap[string, SubstitutionType]()
	subtypeReductionCache := NewMap[string, []Type]()
	decoratorContextOverrideTypeCache := NewMap[string, Type]()
	cachedTypes := NewMap[string, Type]()
	var evolvingArrayTypes []EvolvingArrayType = []never{}
	var undefinedProperties SymbolTable = NewMap()
	markerTypes := NewSet[number]()
	unknownSymbol := createSymbol(SymbolFlagsProperty, "unknown" /* as __String */)
	resolvingSymbol := createSymbol(0, InternalSymbolNameResolving)
	unresolvedSymbols := NewMap[string, TransientSymbol]()
	errorTypes := NewMap[string, Type]()
	// We specifically create the `undefined` and `null` types before any other types that can occur in
	// unions such that they are given low type IDs and occur first in the sorted list of union constituents.
	// We can then just examine the first constituent(s) of a union to check for their presence.
	seenIntrinsicNames := NewSet[string]()
	anyType := createIntrinsicType(TypeFlagsAny, "any")
	autoType := createIntrinsicType(TypeFlagsAny, "any", ObjectFlagsNonInferrableType, "auto")
	wildcardType := createIntrinsicType(TypeFlagsAny, "any" /*objectFlags*/, nil, "wildcard")
	blockedStringType := createIntrinsicType(TypeFlagsAny, "any" /*objectFlags*/, nil, "blocked string")
	errorType := createIntrinsicType(TypeFlagsAny, "error")
	unresolvedType := createIntrinsicType(TypeFlagsAny, "unresolved")
	nonInferrableAnyType := createIntrinsicType(TypeFlagsAny, "any", ObjectFlagsContainsWideningType, "non-inferrable")
	intrinsicMarkerType := createIntrinsicType(TypeFlagsAny, "intrinsic")
	unknownType := createIntrinsicType(TypeFlagsUnknown, "unknown")
	undefinedType := createIntrinsicType(TypeFlagsUndefined, "undefined")
	var undefinedWideningType IntrinsicType
	// TODO(TS-TO-GO): converted from conditional expression
	switch {
	case strictNullChecks:
		undefinedWideningType = undefinedType
	default:
		undefinedWideningType = createIntrinsicType(TypeFlagsUndefined, "undefined", ObjectFlagsContainsWideningType, "widening")
	}
	missingType := createIntrinsicType(TypeFlagsUndefined, "undefined" /*objectFlags*/, nil, "missing")
	var undefinedOrMissingType IntrinsicType
	// TODO(TS-TO-GO): converted from conditional expression
	switch {
	case exactOptionalPropertyTypes:
		undefinedOrMissingType = missingType
	default:
		undefinedOrMissingType = undefinedType
	}
	optionalType := createIntrinsicType(TypeFlagsUndefined, "undefined" /*objectFlags*/, nil, "optional")
	nullType := createIntrinsicType(TypeFlagsNull, "null")
	var nullWideningType IntrinsicType
	// TODO(TS-TO-GO): converted from conditional expression
	switch {
	case strictNullChecks:
		nullWideningType = nullType
	default:
		nullWideningType = createIntrinsicType(TypeFlagsNull, "null", ObjectFlagsContainsWideningType, "widening")
	}
	stringType := createIntrinsicType(TypeFlagsString, "string")
	numberType := createIntrinsicType(TypeFlagsNumber, "number")
	bigintType := createIntrinsicType(TypeFlagsBigInt, "bigint")
	falseType := createIntrinsicType(TypeFlagsBooleanLiteral, "false" /*objectFlags*/, nil, "fresh") /* as FreshableIntrinsicType */
	regularFalseType := createIntrinsicType(TypeFlagsBooleanLiteral, "false")                        /* as FreshableIntrinsicType */
	trueType := createIntrinsicType(TypeFlagsBooleanLiteral, "true" /*objectFlags*/, nil, "fresh")   /* as FreshableIntrinsicType */
	regularTrueType := createIntrinsicType(TypeFlagsBooleanLiteral, "true")                          /* as FreshableIntrinsicType */
	trueType.regularType = regularTrueType
	trueType.freshType = trueType
	regularTrueType.regularType = regularTrueType
	regularTrueType.freshType = trueType
	falseType.regularType = regularFalseType
	falseType.freshType = falseType
	regularFalseType.regularType = regularFalseType
	regularFalseType.freshType = falseType
	booleanType := getUnionType([]FreshableIntrinsicType{regularFalseType, regularTrueType})
	esSymbolType := createIntrinsicType(TypeFlagsESSymbol, "symbol")
	voidType := createIntrinsicType(TypeFlagsVoid, "void")
	neverType := createIntrinsicType(TypeFlagsNever, "never")
	silentNeverType := createIntrinsicType(TypeFlagsNever, "never", ObjectFlagsNonInferrableType, "silent")
	implicitNeverType := createIntrinsicType(TypeFlagsNever, "never" /*objectFlags*/, nil, "implicit")
	unreachableNeverType := createIntrinsicType(TypeFlagsNever, "never" /*objectFlags*/, nil, "unreachable")
	nonPrimitiveType := createIntrinsicType(TypeFlagsNonPrimitive, "object")
	stringOrNumberType := getUnionType([]IntrinsicType{stringType, numberType})
	stringNumberSymbolType := getUnionType([]IntrinsicType{stringType, numberType, esSymbolType})
	numberOrBigIntType := getUnionType([]IntrinsicType{numberType, bigintType})
	templateConstraintType := getUnionType([]Type{stringType, numberType, booleanType, bigintType, nullType, undefinedType}) /* as UnionType */
	numericStringType := getTemplateLiteralType([]string{"", ""}, []IntrinsicType{numberType})
	// The `${number}` type
	var restrictiveMapper TypeMapper = makeFunctionTypeMapper(func(t Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case t.flags & TypeFlagsTypeParameter:
			return getRestrictiveTypeParameter(t /* as TypeParameter */)
		default:
			return t
		}
	}, func() string {
		return "(restrictive mapper)"
	})
	var permissiveMapper TypeMapper = makeFunctionTypeMapper(func(t Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case t.flags & TypeFlagsTypeParameter:
			return wildcardType
		default:
			return t
		}
	}, func() string {
		return "(permissive mapper)"
	})
	uniqueLiteralType := createIntrinsicType(TypeFlagsNever, "never" /*objectFlags*/, nil, "unique literal")
	// `uniqueLiteralType` is a special `never` flagged by union reduction to behave as a literal
	var uniqueLiteralMapper TypeMapper = makeFunctionTypeMapper(func(t Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case t.flags & TypeFlagsTypeParameter:
			return uniqueLiteralType
		default:
			return t
		}
	}, func() string {
		return "(unique literal mapper)"
	})
	// replace all type parameters with the unique literal type (disregarding constraints)
	var outofbandVarianceMarkerHandler *func(onlyUnreliable bool)
	reportUnreliableMapper := makeFunctionTypeMapper(func(t Type) Type {
		if outofbandVarianceMarkerHandler && (t == markerSuperType || t == markerSubType || t == markerOtherType) {
			outofbandVarianceMarkerHandler(true)
		}
		return t
	}, func() string {
		return "(unmeasurable reporter)"
	})
	reportUnmeasurableMapper := makeFunctionTypeMapper(func(t Type) Type {
		if outofbandVarianceMarkerHandler && (t == markerSuperType || t == markerSubType || t == markerOtherType) {
			outofbandVarianceMarkerHandler(false)
		}
		return t
	}, func() string {
		return "(unreliable reporter)"
	})
	emptyObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	emptyJsxObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	emptyJsxObjectType.objectFlags |= ObjectFlagsJsxAttributes
	emptyTypeLiteralSymbol := createSymbol(SymbolFlagsTypeLiteral, InternalSymbolNameType)
	emptyTypeLiteralSymbol.members = createSymbolTable()
	emptyTypeLiteralType := createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, emptyArray, emptyArray, emptyArray)
	unknownEmptyObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	var unknownUnionType Type
	// TODO(TS-TO-GO): converted from conditional expression
	switch {
	case strictNullChecks:
		unknownUnionType = getUnionType([] /* TODO(TS-TO-GO) inferred type IntrinsicType | ResolvedType */ any{undefinedType, nullType, unknownEmptyObjectType})
	default:
		unknownUnionType = unknownType
	}
	emptyGenericType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray) /* as ObjectType */ /* as GenericType */
	emptyGenericType.instantiations = NewMap[string, TypeReference]()
	anyFunctionType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	// The anyFunctionType contains the anyFunctionType by definition. The flag is further propagated
	// in getPropagatingFlagsOfTypes, and it is checked in inferFromTypes.
	anyFunctionType.objectFlags |= ObjectFlagsNonInferrableType
	noConstraintType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	circularConstraintType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	resolvingDefaultType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	markerSuperType := createTypeParameter()
	markerSubType := createTypeParameter()
	markerSubType.constraint = markerSuperType
	markerOtherType := createTypeParameter()
	markerSuperTypeForCheck := createTypeParameter()
	markerSubTypeForCheck := createTypeParameter()
	markerSubTypeForCheck.constraint = markerSuperTypeForCheck
	noTypePredicate := createTypePredicate(TypePredicateKindIdentifier, "<<unresolved>>", 0, anyType)
	anySignature := createSignature(nil /*typeParameters*/, nil /*thisParameter*/, nil, emptyArray, anyType /*resolvedTypePredicate*/, nil, 0, SignatureFlagsNone)
	unknownSignature := createSignature(nil /*typeParameters*/, nil /*thisParameter*/, nil, emptyArray, errorType /*resolvedTypePredicate*/, nil, 0, SignatureFlagsNone)
	resolvingSignature := createSignature(nil /*typeParameters*/, nil /*thisParameter*/, nil, emptyArray, anyType /*resolvedTypePredicate*/, nil, 0, SignatureFlagsNone)
	silentNeverSignature := createSignature(nil /*typeParameters*/, nil /*thisParameter*/, nil, emptyArray, silentNeverType /*resolvedTypePredicate*/, nil, 0, SignatureFlagsNone)
	enumNumberIndexInfo := createIndexInfo(numberType, stringType /*isReadonly*/, true)
	iterationTypesCache := NewMap[string, IterationTypes]()
	// cache for common IterationTypes instances
	var noIterationTypes IterationTypes = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		/* TODO(TS-TO-GO) Node GetAccessor: get yieldType(): Type { return Debug.fail("Not supported"); } */
		/* TODO(TS-TO-GO) Node GetAccessor: get returnType(): Type { return Debug.fail("Not supported"); } */
		/* TODO(TS-TO-GO) Node GetAccessor: get nextType(): Type { return Debug.fail("Not supported"); } */
	}
	anyIterationTypes := createIterationTypes(anyType, anyType, anyType)
	var asyncIterationTypesResolver IterationTypesResolver = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"iterableCacheKey":              "iterationTypesOfAsyncIterable",
		"iteratorCacheKey":              "iterationTypesOfAsyncIterator",
		"iteratorSymbolName":            "asyncIterator",
		"getGlobalIteratorType":         getGlobalAsyncIteratorType,
		"getGlobalIterableType":         getGlobalAsyncIterableType,
		"getGlobalIterableIteratorType": getGlobalAsyncIterableIteratorType,
		"getGlobalIteratorObjectType":   getGlobalAsyncIteratorObjectType,
		"getGlobalGeneratorType":        getGlobalAsyncGeneratorType,
		"getGlobalBuiltinIteratorTypes": getGlobalBuiltinAsyncIteratorTypes,
		"resolveIterationType": func(type_ Type, errorNode Node) Type {
			return getAwaitedType(type_, errorNode, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
		},
		"mustHaveANextMethodDiagnostic": Diagnostics.An_async_iterator_must_have_a_next_method,
		"mustBeAMethodDiagnostic":       Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,
		"mustHaveAValueDiagnostic":      Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,
	}
	var syncIterationTypesResolver IterationTypesResolver = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"iterableCacheKey":              "iterationTypesOfIterable",
		"iteratorCacheKey":              "iterationTypesOfIterator",
		"iteratorSymbolName":            "iterator",
		"getGlobalIteratorType":         getGlobalIteratorType,
		"getGlobalIterableType":         getGlobalIterableType,
		"getGlobalIterableIteratorType": getGlobalIterableIteratorType,
		"getGlobalIteratorObjectType":   getGlobalIteratorObjectType,
		"getGlobalGeneratorType":        getGlobalGeneratorType,
		"getGlobalBuiltinIteratorTypes": getGlobalBuiltinIteratorTypes,
		"resolveIterationType": func(type_ Type, _errorNode Node) Type {
			return type_
		},
		"mustHaveANextMethodDiagnostic": Diagnostics.An_iterator_must_have_a_next_method,
		"mustBeAMethodDiagnostic":       Diagnostics.The_0_property_of_an_iterator_must_be_a_method,
		"mustHaveAValueDiagnostic":      Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,
	}
	type DuplicateInfoForSymbol struct {
		firstFileLocations  []Declaration
		secondFileLocations []Declaration
		isBlockScoped       bool
	}
	type DuplicateInfoForFiles struct {
		firstFile          SourceFile
		secondFile         SourceFile
		conflictingSymbols Map[string, DuplicateInfoForSymbol]
	}
	/** Key is "/path/to/a.ts|/path/to/b.ts". */
	var amalgamatedDuplicates *Map[string, DuplicateInfoForFiles]
	reverseMappedCache := NewMap[string, Type]()
	reverseHomomorphicMappedCache := NewMap[string, Type]()
	var ambientModulesCache *[]Symbol
	/**
	 * List of every ambient module with a "*" wildcard.
	 * Unlike other ambient modules, these can't be stored in `globals` because symbol tables only deal with exact matches.
	 * This is only used if there is no exact match.
	 */
	var patternAmbientModules []PatternAmbientModule
	var patternAmbientModuleAugmentations *Map[string, Symbol]
	var globalObjectType ObjectType
	var globalFunctionType ObjectType
	var globalCallableFunctionType ObjectType
	var globalNewableFunctionType ObjectType
	var globalArrayType GenericType
	var globalReadonlyArrayType GenericType
	var globalStringType ObjectType
	var globalNumberType ObjectType
	var globalBooleanType ObjectType
	var globalRegExpType ObjectType
	var globalThisType GenericType
	var anyArrayType Type
	var autoArrayType Type
	var anyReadonlyArrayType Type
	var deferredGlobalNonNullableTypeAlias Symbol
	// The library files are only loaded when the feature is used.
	// This allows users to just specify library files they want to used through --lib
	// and they will not get an error from not having unrelated library files
	var deferredGlobalESSymbolConstructorSymbol Symbol
	var deferredGlobalESSymbolConstructorTypeSymbol Symbol
	var deferredGlobalESSymbolType *ObjectType
	var deferredGlobalTypedPropertyDescriptorType GenericType
	var deferredGlobalPromiseType *GenericType
	var deferredGlobalPromiseLikeType *GenericType
	var deferredGlobalPromiseConstructorSymbol Symbol
	var deferredGlobalPromiseConstructorLikeType *ObjectType
	var deferredGlobalIterableType *GenericType
	var deferredGlobalIteratorType *GenericType
	var deferredGlobalIterableIteratorType *GenericType
	var deferredGlobalIteratorObjectType *GenericType
	var deferredGlobalGeneratorType *GenericType
	var deferredGlobalIteratorYieldResultType *GenericType
	var deferredGlobalIteratorReturnResultType *GenericType
	var deferredGlobalAsyncIterableType *GenericType
	var deferredGlobalAsyncIteratorType *GenericType
	var deferredGlobalAsyncIterableIteratorType *GenericType
	var deferredGlobalBuiltinIteratorTypes *[]GenericType
	var deferredGlobalBuiltinAsyncIteratorTypes *[]GenericType
	var deferredGlobalAsyncIteratorObjectType *GenericType
	var deferredGlobalAsyncGeneratorType *GenericType
	var deferredGlobalTemplateStringsArrayType *ObjectType
	var deferredGlobalImportMetaType ObjectType
	var deferredGlobalImportMetaExpressionType ObjectType
	var deferredGlobalImportCallOptionsType *ObjectType
	var deferredGlobalImportAttributesType *ObjectType
	var deferredGlobalDisposableType *ObjectType
	var deferredGlobalAsyncDisposableType *ObjectType
	var deferredGlobalExtractSymbol Symbol
	var deferredGlobalOmitSymbol Symbol
	var deferredGlobalAwaitedSymbol Symbol
	var deferredGlobalBigIntType *ObjectType
	var deferredGlobalNaNSymbol Symbol
	var deferredGlobalRecordSymbol Symbol
	var deferredGlobalClassDecoratorContextType *GenericType
	var deferredGlobalClassMethodDecoratorContextType *GenericType
	var deferredGlobalClassGetterDecoratorContextType *GenericType
	var deferredGlobalClassSetterDecoratorContextType *GenericType
	var deferredGlobalClassAccessorDecoratorContextType *GenericType
	var deferredGlobalClassAccessorDecoratorTargetType *GenericType
	var deferredGlobalClassAccessorDecoratorResultType *GenericType
	var deferredGlobalClassFieldDecoratorContextType *GenericType
	allPotentiallyUnusedIdentifiers := NewMap[Path, []PotentiallyUnusedIdentifier]()
	// key is file name
	flowLoopStart := 0
	flowLoopCount := 0
	sharedFlowCount := 0
	flowAnalysisDisabled := false
	flowInvocationCount := 0
	var lastFlowNode *FlowNode
	var lastFlowNodeReachable bool
	var flowTypeCache *[]Type
	var contextualTypeNodes []Node = []never{}
	var contextualTypes []Type = []never{}
	var contextualIsCache []bool = []never{}
	contextualTypeCount := 0
	var contextualBindingPatterns []BindingPattern = []never{}
	var inferenceContextNodes []Node = []never{}
	var inferenceContexts []*InferenceContext = []never{}
	inferenceContextCount := 0
	emptyStringType := getStringLiteralType("")
	zeroType := getNumberLiteralType(0)
	zeroBigIntType := getBigIntLiteralType(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"negative":    false,
		"base10Value": "0",
	})
	var resolutionTargets []TypeSystemEntity = []never{}
	var resolutionResults []bool = []never{}
	var resolutionPropertyNames []TypeSystemPropertyName = []never{}
	resolutionStart := 0
	inVarianceComputation := false
	suggestionCount := 0
	maximumSuggestionCount := 10
	var mergedSymbols []Symbol = []never{}
	var symbolLinks []SymbolLinks = []never{}
	var nodeLinks []NodeLinks = []never{}
	var flowLoopCaches []Map[string, Type] = []never{}
	var flowLoopNodes []FlowNode = []never{}
	var flowLoopKeys []string = []never{}
	var flowLoopTypes [][]Type = []never{}
	var sharedFlowNodes []FlowNode = []never{}
	var sharedFlowTypes []FlowType = []never{}
	var flowNodeReachable []*bool = []never{}
	var flowNodePostSuper []*bool = []never{}
	var potentialThisCollisions []Node = []never{}
	var potentialNewTargetCollisions []Node = []never{}
	var potentialWeakMapSetCollisions []Node = []never{}
	var potentialReflectCollisions []Node = []never{}
	var potentialUnusedRenamedBindingElementsInTypes []BindingElement = []never{}
	var awaitedTypeStack []number = []never{}
	var reverseMappedSourceStack []Type = []never{}
	var reverseMappedTargetStack []Type = []never{}
	reverseExpandingFlags := ExpandingFlagsNone
	diagnostics := createDiagnosticCollection()
	suggestionDiagnostics := createDiagnosticCollection()
	typeofType := createTypeofType()
	var _jsxNamespace __String
	var _jsxFactoryEntity *EntityName
	subtypeRelation := NewMap[string, RelationComparisonResult]()
	strictSubtypeRelation := NewMap[string, RelationComparisonResult]()
	assignableRelation := NewMap[string, RelationComparisonResult]()
	comparableRelation := NewMap[string, RelationComparisonResult]()
	identityRelation := NewMap[string, RelationComparisonResult]()
	enumRelation := NewMap[string, RelationComparisonResult]()
	// Extensions suggested for path imports when module resolution is node16 or higher.
	// The first element of each tuple is the extension a file has.
	// The second element of each tuple is the extension that should be used in a path import.
	// e.g. if we want to import file `foo.mts`, we should write `import {} from "./foo.mjs".
	var suggestedExtensions [] /* TODO(TS-TO-GO) TypeNode TupleType: [string, string] */ any = [] /* TODO(TS-TO-GO) inferred type [string, string] */ any{[]any{".mts", ".mjs"}, []any{".ts", ".js"}, []any{".cts", ".cjs"}, []any{".mjs", ".mjs"}, []any{".js", ".js"}, []any{".cjs", ".cjs"}, []any{".tsx", __COND__(compilerOptions.jsx == JsxEmitPreserve, ".jsx", ".js")}, []any{".jsx", ".jsx"}, []any{".json", ".json"}}
	/* eslint-enable no-var */
	initializeTypeChecker()
	return checker
	isDefinitelyReferenceToGlobalSymbolObject := func(node Node) bool {
		if !isPropertyAccessExpression(node) {
			return false
		}
		if !isIdentifier(node.name) {
			return false
		}
		if !isPropertyAccessExpression(node.expression) && !isIdentifier(node.expression) {
			return false
		}
		if isIdentifier(node.expression) {
			// Exactly `Symbol.something` and `Symbol` either does not resolve or definitely resolves to the global Symbol
			return idText(node.expression) == "Symbol" && getResolvedSymbol(node.expression) == (getGlobalSymbol("Symbol" /* as __String */, SymbolFlagsValue|SymbolFlagsExportValue /*diagnostic*/, nil) || unknownSymbol)
		}
		if !isIdentifier(node.expression.expression) {
			return false
		}
		// Exactly `globalThis.Symbol.something` and `globalThis` resolves to the global `globalThis`
		return idText(node.expression.name) == "Symbol" && idText(node.expression.expression) == "globalThis" && getResolvedSymbol(node.expression.expression) == globalThisSymbol
	}
	getCachedType := func(key *string) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case key:
			return cachedTypes.get(key)
		default:
			return nil
		}
	}
	setCachedType := func(key *string, type_ Type) Type {
		if key {
			cachedTypes.set(key, type_)
		}
		return type_
	}
	getJsxNamespace := func(location Node) __String {
		if location {
			file := getSourceFileOfNode(location)
			if file {
				if isJsxOpeningFragment(location) {
					if file.localJsxFragmentNamespace {
						return file.localJsxFragmentNamespace
					}
					jsxFragmentPragma := file.pragmas.get("jsxfrag")
					if jsxFragmentPragma {
						var chosenPragma /* TODO(TS-TO-GO) inferred type { arguments: { factory: string; }; range: CommentRange; } */ any
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isArray(jsxFragmentPragma):
							chosenPragma = jsxFragmentPragma[0]
						default:
							chosenPragma = jsxFragmentPragma
						}
						file.localJsxFragmentFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion)
						visitNode(file.localJsxFragmentFactory, markAsSynthetic, isEntityName)
						if file.localJsxFragmentFactory {
							file.localJsxFragmentNamespace = getFirstIdentifier(file.localJsxFragmentFactory).escapedText
							return file.localJsxFragmentNamespace
						}
					}
					entity := getJsxFragmentFactoryEntity(location)
					if entity {
						file.localJsxFragmentFactory = entity
						file.localJsxFragmentNamespace = getFirstIdentifier(entity).escapedText
						return file.localJsxFragmentNamespace
					}
				} else {
					localJsxNamespace := getLocalJsxNamespace(file)
					if localJsxNamespace {
						file.localJsxNamespace = localJsxNamespace
						return file.localJsxNamespace
					}
				}
			}
		}
		if !_jsxNamespace {
			_jsxNamespace = "React" /* as __String */
			if compilerOptions.jsxFactory {
				_jsxFactoryEntity = parseIsolatedEntityName(compilerOptions.jsxFactory, languageVersion)
				visitNode(_jsxFactoryEntity, markAsSynthetic)
				if _jsxFactoryEntity {
					_jsxNamespace = getFirstIdentifier(_jsxFactoryEntity).escapedText
				}
			} else if compilerOptions.reactNamespace {
				_jsxNamespace = escapeLeadingUnderscores(compilerOptions.reactNamespace)
			}
		}
		if !_jsxFactoryEntity {
			_jsxFactoryEntity = factory.createQualifiedName(factory.createIdentifier(unescapeLeadingUnderscores(_jsxNamespace)), "createElement")
		}
		return _jsxNamespace
	}
	getLocalJsxNamespace := func(file SourceFile) *__String {
		if file.localJsxNamespace {
			return file.localJsxNamespace
		}
		jsxPragma := file.pragmas.get("jsx")
		if jsxPragma {
			var chosenPragma /* TODO(TS-TO-GO) inferred type { arguments: { factory: string; }; range: CommentRange; } */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isArray(jsxPragma):
				chosenPragma = jsxPragma[0]
			default:
				chosenPragma = jsxPragma
			}
			file.localJsxFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion)
			visitNode(file.localJsxFactory, markAsSynthetic, isEntityName)
			if file.localJsxFactory {
				file.localJsxNamespace = getFirstIdentifier(file.localJsxFactory).escapedText
				return file.localJsxNamespace
			}
		}
	}
	markAsSynthetic := func(node T) VisitResult[T] {
		setTextRangePosEnd(node, -1, -1)
		return visitEachChildWorker(node, markAsSynthetic /*context*/, nil)
	}
	getEmitResolver := func(sourceFile SourceFile, cancellationToken CancellationToken, skipDiagnostics bool) EmitResolver {
		// Ensure we have all the type information in place for this file so that all the
		// emitter questions of this resolver will return the right information.
		if !skipDiagnostics {
			getDiagnostics(sourceFile, cancellationToken)
		}
		return emitResolver
	}
	lookupOrIssueError := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		var diagnostic Diagnostic
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case location:
			diagnostic = createDiagnosticForNode(location, message, args...)
		default:
			diagnostic = createCompilerDiagnostic(message, args...)
		}
		existing := diagnostics.lookup(diagnostic)
		if existing {
			return existing
		} else {
			diagnostics.add(diagnostic)
			return diagnostic
		}
	}
	errorSkippedOn := func(key CompilerOptions, location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := error(location, message, args...)
		diagnostic.skippedOn = key
		return diagnostic
	}
	createError := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case location:
			return createDiagnosticForNode(location, message, args...)
		default:
			return createCompilerDiagnostic(message, args...)
		}
	}
	error := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := createError(location, message, args...)
		diagnostics.add(diagnostic)
		return diagnostic
	}
	addErrorOrSuggestion := func(isError bool, diagnostic Diagnostic) {
		if isError {
			diagnostics.add(diagnostic)
		} else {
			suggestionDiagnostics.add(map[any]any{ /* TODO(TS-TO-GO): was object literal */
				/* TODO(TS-TO-GO) Node SpreadAssignment: ...diagnostic */
				"category": DiagnosticCategorySuggestion,
			})
		}
	}
	errorOrSuggestion := func(isError bool, location Node, message /* TODO(TS-TO-GO) TypeNode UnionType: DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) {
		// Pseudo-synthesized input node
		if location.pos < 0 || location.end < 0 {
			if !isError {
				return
				// Drop suggestions (we have no span to suggest on)
			}
			// Issue errors globally
			file := getSourceFileOfNode(location)
			addErrorOrSuggestion(isError, __COND__( /* TODO(TS-TO-GO) Node BinaryExpression: "message" in message */ TODO, createFileDiagnostic(file, 0, 0, message, args...), createDiagnosticForFileFromMessageChain(file, message)))
			// eslint-disable-line local/no-in-operator
			return
		}
		addErrorOrSuggestion(isError, __COND__( /* TODO(TS-TO-GO) Node BinaryExpression: "message" in message */ TODO, createDiagnosticForNode(location, message, args...), createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(location), location, message)))
		// eslint-disable-line local/no-in-operator
	}
	errorAndMaybeSuggestAwait := func(location Node, maybeMissingAwait bool, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := error(location, message, args...)
		if maybeMissingAwait {
			related := createDiagnosticForNode(location, Diagnostics.Did_you_forget_to_use_await)
			addRelatedInfo(diagnostic, related)
		}
		return diagnostic
	}
	addDeprecatedSuggestionWorker := func(declarations /* TODO(TS-TO-GO) TypeNode UnionType: Node | Node[] */ any, diagnostic DiagnosticWithLocation) DiagnosticWithLocation {
		var deprecatedTag *JSDocDeprecatedTag
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case Array.isArray(declarations):
			deprecatedTag = forEach(declarations, getJSDocDeprecatedTag)
		default:
			deprecatedTag = getJSDocDeprecatedTag(declarations)
		}
		if deprecatedTag {
			addRelatedInfo(diagnostic, createDiagnosticForNode(deprecatedTag, Diagnostics.The_declaration_was_marked_as_deprecated_here))
		}
		// We call `addRelatedInfo()` before adding the diagnostic to prevent duplicates.
		suggestionDiagnostics.add(diagnostic)
		return diagnostic
	}
	isDeprecatedSymbol := func(symbol Symbol) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
		parentSymbol := getParentOfSymbol(symbol)
		if parentSymbol && length(symbol.declarations) > 1 {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case parentSymbol.flags & SymbolFlagsInterface:
				return some(symbol.declarations, isDeprecatedDeclaration)
			default:
				return every(symbol.declarations, isDeprecatedDeclaration)
			}
		}
		return !!symbol.valueDeclaration && isDeprecatedDeclaration(symbol.valueDeclaration) || length(symbol.declarations) && every(symbol.declarations, isDeprecatedDeclaration)
	}
	isDeprecatedDeclaration := func(declaration Declaration) bool {
		return !!(getCombinedNodeFlagsCached(declaration) & NodeFlagsDeprecated)
	}
	addDeprecatedSuggestion := func(location Node, declarations []Node, deprecatedEntity string) DiagnosticWithLocation {
		diagnostic := createDiagnosticForNode(location, Diagnostics._0_is_deprecated, deprecatedEntity)
		return addDeprecatedSuggestionWorker(declarations, diagnostic)
	}
	addDeprecatedSuggestionWithSignature := func(location Node, declaration Node, deprecatedEntity *string, signatureString string) DiagnosticWithLocation {
		var diagnostic DiagnosticWithLocation
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case deprecatedEntity:
			diagnostic = createDiagnosticForNode(location, Diagnostics.The_signature_0_of_1_is_deprecated, signatureString, deprecatedEntity)
		default:
			diagnostic = createDiagnosticForNode(location, Diagnostics._0_is_deprecated, signatureString)
		}
		return addDeprecatedSuggestionWorker(declaration, diagnostic)
	}
	createSymbol := func(flags SymbolFlags, name __String, checkFlags CheckFlags) TransientSymbol {
		symbolCount++
		symbol := NewSymbol(flags|SymbolFlagsTransient, name) /* as TransientSymbol */
		symbol.links = NewSymbolLinks()                       /* as TransientSymbolLinks */
		symbol.links.checkFlags = checkFlags || CheckFlagsNone
		return symbol
	}
	createParameter := func(name __String, type_ Type) TransientSymbol {
		symbol := createSymbol(SymbolFlagsFunctionScopedVariable, name)
		symbol.links.type_ = type_
		return symbol
	}
	createProperty := func(name __String, type_ Type) TransientSymbol {
		symbol := createSymbol(SymbolFlagsProperty, name)
		symbol.links.type_ = type_
		return symbol
	}
	getExcludedSymbolFlags := func(flags SymbolFlags) SymbolFlags {
		var result SymbolFlags = 0
		if flags & SymbolFlagsBlockScopedVariable {
			result |= SymbolFlagsBlockScopedVariableExcludes
		}
		if flags & SymbolFlagsFunctionScopedVariable {
			result |= SymbolFlagsFunctionScopedVariableExcludes
		}
		if flags & SymbolFlagsProperty {
			result |= SymbolFlagsPropertyExcludes
		}
		if flags & SymbolFlagsEnumMember {
			result |= SymbolFlagsEnumMemberExcludes
		}
		if flags & SymbolFlagsFunction {
			result |= SymbolFlagsFunctionExcludes
		}
		if flags & SymbolFlagsClass {
			result |= SymbolFlagsClassExcludes
		}
		if flags & SymbolFlagsInterface {
			result |= SymbolFlagsInterfaceExcludes
		}
		if flags & SymbolFlagsRegularEnum {
			result |= SymbolFlagsRegularEnumExcludes
		}
		if flags & SymbolFlagsConstEnum {
			result |= SymbolFlagsConstEnumExcludes
		}
		if flags & SymbolFlagsValueModule {
			result |= SymbolFlagsValueModuleExcludes
		}
		if flags & SymbolFlagsMethod {
			result |= SymbolFlagsMethodExcludes
		}
		if flags & SymbolFlagsGetAccessor {
			result |= SymbolFlagsGetAccessorExcludes
		}
		if flags & SymbolFlagsSetAccessor {
			result |= SymbolFlagsSetAccessorExcludes
		}
		if flags & SymbolFlagsTypeParameter {
			result |= SymbolFlagsTypeParameterExcludes
		}
		if flags & SymbolFlagsTypeAlias {
			result |= SymbolFlagsTypeAliasExcludes
		}
		if flags & SymbolFlagsAlias {
			result |= SymbolFlagsAliasExcludes
		}
		return result
	}
	recordMergedSymbol := func(target Symbol, source Symbol) {
		if !source.mergeId {
			source.mergeId = nextMergeId
			nextMergeId++
		}
		mergedSymbols[source.mergeId] = target
	}
	cloneSymbol := func(symbol Symbol) TransientSymbol {
		result := createSymbol(symbol.flags, symbol.escapedName)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol.declarations:
			result.declarations = symbol.declarations.slice()
		default:
			result.declarations = []never{}
		}
		result.parent = symbol.parent
		if symbol.valueDeclaration {
			result.valueDeclaration = symbol.valueDeclaration
		}
		if symbol.constEnumOnlyModule {
			result.constEnumOnlyModule = true
		}
		if symbol.members {
			result.members = NewMap(symbol.members)
		}
		if symbol.exports {
			result.exports = NewMap(symbol.exports)
		}
		recordMergedSymbol(result, symbol)
		return result
	}
	/**
	 * Note: if target is transient, then it is mutable, and mergeSymbol with both mutate and return it.
	 * If target is not transient, mergeSymbol will produce a transient clone, mutate that and return it.
	 */
	mergeSymbol := func(target Symbol, source Symbol, unidirectional bool /*  = false */) Symbol {
		if !(target.flags & getExcludedSymbolFlags(source.flags)) || (source.flags|target.flags)&SymbolFlagsAssignment {
			if source == target {
				// This can happen when an export assigned namespace exports something also erroneously exported at the top level
				// See `declarationFileNoCrashOnExtraExportModifier` for an example
				return target
			}
			if !(target.flags & SymbolFlagsTransient) {
				resolvedTarget := resolveSymbol(target)
				if resolvedTarget == unknownSymbol {
					return source
				}
				if !(resolvedTarget.flags & getExcludedSymbolFlags(source.flags)) || (source.flags|resolvedTarget.flags)&SymbolFlagsAssignment {
					target = cloneSymbol(resolvedTarget)
				} else {
					reportMergeSymbolError(target, source)
					return source
				}
			}
			// Javascript static-property-assignment declarations always merge, even though they are also values
			if source.flags&SymbolFlagsValueModule && target.flags&SymbolFlagsValueModule && target.constEnumOnlyModule && !source.constEnumOnlyModule {
				// reset flag when merging instantiated module into value module that has only const enums
				target.constEnumOnlyModule = false
			}
			target.flags |= source.flags
			if source.valueDeclaration {
				setValueDeclaration(target, source.valueDeclaration)
			}
			addRange(target.declarations, source.declarations)
			if source.members {
				if !target.members {
					target.members = createSymbolTable()
				}
				mergeSymbolTable(target.members, source.members, unidirectional)
			}
			if source.exports {
				if !target.exports {
					target.exports = createSymbolTable()
				}
				mergeSymbolTable(target.exports, source.exports, unidirectional, target)
			}
			if !unidirectional {
				recordMergedSymbol(target, source)
			}
		} else if target.flags & SymbolFlagsNamespaceModule {
			// Do not report an error when merging `var globalThis` with the built-in `globalThis`,
			// as we will already report a "Declaration name conflicts..." error, and this error
			// won't make much sense.
			if target != globalThisSymbol {
				error(source.declarations && getNameOfDeclaration(source.declarations[0]), Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity, symbolToString(target))
			}
		} else {
			reportMergeSymbolError(target, source)
		}
		return target
		reportMergeSymbolError := func(target Symbol, source Symbol) {
			isEitherEnum := !!(target.flags&SymbolFlagsEnum || source.flags&SymbolFlagsEnum)
			isEitherBlockScoped := !!(target.flags&SymbolFlagsBlockScopedVariable || source.flags&SymbolFlagsBlockScopedVariable)
			var message DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isEitherEnum:
				message = Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations
			case isEitherBlockScoped:
				message = Diagnostics.Cannot_redeclare_block_scoped_variable_0
			default:
				message = Diagnostics.Duplicate_identifier_0
			}
			sourceSymbolFile := source.declarations && getSourceFileOfNode(source.declarations[0])
			targetSymbolFile := target.declarations && getSourceFileOfNode(target.declarations[0])
			isSourcePlainJs := isPlainJsFile(sourceSymbolFile, compilerOptions.checkJs)
			isTargetPlainJs := isPlainJsFile(targetSymbolFile, compilerOptions.checkJs)
			symbolName := symbolToString(source)
			// Collect top-level duplicate identifier errors into one mapping, so we can then merge their diagnostics if there are a bunch
			if sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && sourceSymbolFile != targetSymbolFile {
				var firstFile SourceFile
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case comparePaths(sourceSymbolFile.path, targetSymbolFile.path) == ComparisonLessThan:
					firstFile = sourceSymbolFile
				default:
					firstFile = targetSymbolFile
				}
				var secondFile SourceFile
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case firstFile == sourceSymbolFile:
					secondFile = targetSymbolFile
				default:
					secondFile = sourceSymbolFile
				}
				filesDuplicates := getOrUpdate(amalgamatedDuplicates, __TEMPLATE__(firstFile.path, "|", secondFile.path), func() DuplicateInfoForFiles {
					return (map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"firstFile":          firstFile,
						"secondFile":         secondFile,
						"conflictingSymbols": NewMap(),
					})
				})
				conflictingSymbolInfo := getOrUpdate(filesDuplicates.conflictingSymbols, symbolName, func() DuplicateInfoForSymbol {
					return (map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"isBlockScoped":       isEitherBlockScoped,
						"firstFileLocations":  []never{},
						"secondFileLocations": []never{},
					})
				})
				if !isSourcePlainJs {
					addDuplicateLocations(conflictingSymbolInfo.firstFileLocations, source)
				}
				if !isTargetPlainJs {
					addDuplicateLocations(conflictingSymbolInfo.secondFileLocations, target)
				}
			} else {
				if !isSourcePlainJs {
					addDuplicateDeclarationErrorsForSymbols(source, message, symbolName, target)
				}
				if !isTargetPlainJs {
					addDuplicateDeclarationErrorsForSymbols(target, message, symbolName, source)
				}
			}
		}
		addDuplicateLocations := func(locs []Declaration, symbol Symbol) {
			if symbol.declarations {
				for _, decl := range symbol.declarations {
					pushIfUnique(locs, decl)
				}
			}
		}
	}
	addDuplicateDeclarationErrorsForSymbols := func(target Symbol, message DiagnosticMessage, symbolName string, source Symbol) {
		forEach(target.declarations, func(node Declaration) {
			addDuplicateDeclarationError(node, message, symbolName, source.declarations)
		})
	}
	addDuplicateDeclarationError := func(node Declaration, message DiagnosticMessage, symbolName string, relatedNodes *[]Declaration) {
		errorNode := (__COND__(getExpandoInitializer(node /*isPrototypeAssignment*/, false), getNameOfExpando(node), getNameOfDeclaration(node))) || node
		err := lookupOrIssueError(errorNode, message, symbolName)
		for _, relatedNode := range relatedNodes || emptyArray {
			adjustedNode := (__COND__(getExpandoInitializer(relatedNode /*isPrototypeAssignment*/, false), getNameOfExpando(relatedNode), getNameOfDeclaration(relatedNode))) || relatedNode
			if adjustedNode == errorNode {
				continue
			}
			err.relatedInformation = err.relatedInformation || []never{}
			leadingMessage := createDiagnosticForNode(adjustedNode, Diagnostics._0_was_also_declared_here, symbolName)
			followOnMessage := createDiagnosticForNode(adjustedNode, Diagnostics.and_here)
			if length(err.relatedInformation) >= 5 || some(err.relatedInformation, func(r DiagnosticRelatedInformation) bool {
				return compareDiagnostics(r, followOnMessage) == ComparisonEqualTo || compareDiagnostics(r, leadingMessage) == ComparisonEqualTo
			}) {
				continue
			}
			addRelatedInfo(err, __COND__(!length(err.relatedInformation), leadingMessage, followOnMessage))
		}
	}
	combineSymbolTables := func(first *SymbolTable, second *SymbolTable) *SymbolTable {
		if !first. /* TODO(TS-TO-GO): was ? */ size {
			return second
		}
		if !second. /* TODO(TS-TO-GO): was ? */ size {
			return first
		}
		combined := createSymbolTable()
		mergeSymbolTable(combined, first)
		mergeSymbolTable(combined, second)
		return combined
	}
	mergeSymbolTable := func(target SymbolTable, source SymbolTable, unidirectional bool /*  = false */, mergedParent Symbol) {
		source.forEach(func(sourceSymbol Symbol, id __String) {
			targetSymbol := target.get(id)
			var merged Symbol
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case targetSymbol:
				merged = mergeSymbol(targetSymbol, sourceSymbol, unidirectional)
			default:
				merged = getMergedSymbol(sourceSymbol)
			}
			if mergedParent && targetSymbol {
				// If a merge was performed on the target symbol, set its parent to the merged parent that initiated the merge
				// of its exports. Otherwise, `merged` came only from `sourceSymbol` and can keep its parent:
				//
				// // a.ts
				// export interface A { x: number; }
				//
				// // b.ts
				// declare module "./a" {
				//   interface A { y: number; }
				//   interface B {}
				// }
				//
				// When merging the module augmentation into a.ts, the symbol for `A` will itself be merged, so its parent
				// should be the merged module symbol. But the symbol for `B` has only one declaration, so its parent should
				// be the module augmentation symbol, which contains its only declaration.
				merged.parent = mergedParent
			}
			target.set(id, merged)
		})
	}
	mergeModuleAugmentation := func(moduleName /* TODO(TS-TO-GO) TypeNode UnionType: StringLiteral | Identifier */ any) {
		moduleAugmentation := moduleName.parent /* as ModuleDeclaration */
		if moduleAugmentation.symbol.declarations[0] != moduleAugmentation {
			// this is a combined symbol for multiple augmentations within the same file.
			// its symbol already has accumulated information for all declarations
			// so we need to add it just once - do the work only for first declaration
			Debug.assert(moduleAugmentation.symbol.declarations.length > 1)
			return
		}
		if isGlobalScopeAugmentation(moduleAugmentation) {
			mergeSymbolTable(globals, moduleAugmentation.symbol.exports)
		} else {
			// find a module that about to be augmented
			// do not validate names of augmentations that are defined in ambient context
			var moduleNotFoundError *DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !(moduleName.parent.parent.flags & NodeFlagsAmbient):
				moduleNotFoundError = Diagnostics.Invalid_module_name_in_augmentation_module_0_cannot_be_found
			default:
				moduleNotFoundError = nil
			}
			mainModule := resolveExternalModuleNameWorker(moduleName, moduleName, moduleNotFoundError /*ignoreErrors*/, false /*isForAugmentation*/, true)
			if !mainModule {
				return
			}
			// obtain item referenced by 'export='
			mainModule = resolveExternalModuleSymbol(mainModule)
			if mainModule.flags & SymbolFlagsNamespace {
				// If we're merging an augmentation to a pattern ambient module, we want to
				// perform the merge unidirectionally from the augmentation ('a.foo') to
				// the pattern ('*.foo'), so that 'getMergedSymbol()' on a.foo gives you
				// all the exports both from the pattern and from the augmentation, but
				// 'getMergedSymbol()' on *.foo only gives you exports from *.foo.
				if some(patternAmbientModules, func(module PatternAmbientModule) bool {
					return mainModule == module.symbol
				}) {
					merged := mergeSymbol(moduleAugmentation.symbol, mainModule /*unidirectional*/, true)
					if !patternAmbientModuleAugmentations {
						patternAmbientModuleAugmentations = NewMap()
					}
					// moduleName will be a StringLiteral since this is not `declare global`.
					patternAmbientModuleAugmentations.set((moduleName /* as StringLiteral */).text, merged)
				} else {
					if mainModule.exports. /* TODO(TS-TO-GO): was ? */ get(InternalSymbolNameExportStar) && moduleAugmentation.symbol.exports. /* TODO(TS-TO-GO): was ? */ size {
						// We may need to merge the module augmentation's exports into the target symbols of the resolved exports
						resolvedExports := getResolvedMembersOrExportsOfSymbol(mainModule, MembersOrExportsResolutionKindresolvedExports)
						for _, TODO_IDENTIFIER := range arrayFrom(moduleAugmentation.symbol.exports.entries()) {
							if resolvedExports.has(key) && !mainModule.exports.has(key) {
								mergeSymbol(resolvedExports.get(key), value)
							}
						}
					}
					mergeSymbol(mainModule, moduleAugmentation.symbol)
				}
			} else {
				// moduleName will be a StringLiteral since this is not `declare global`.
				error(moduleName, Diagnostics.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity, (moduleName /* as StringLiteral */).text)
			}
		}
	}
	addUndefinedToGlobalsOrErrorOnRedeclaration := func() {
		name := undefinedSymbol.escapedName
		targetSymbol := globals.get(name)
		if targetSymbol {
			forEach(targetSymbol.declarations, func(declaration Declaration) {
				// checkTypeNameIsReserved will have added better diagnostics for type declarations.
				if !isTypeDeclaration(declaration) {
					diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, unescapeLeadingUnderscores(name)))
				}
			})
		} else {
			globals.set(name, undefinedSymbol)
		}
	}
	getSymbolLinks := func(symbol Symbol) SymbolLinks {
		if symbol.flags & SymbolFlagsTransient {
			return (symbol /* as TransientSymbol */).links
		}
		id := getSymbolId(symbol)
		return /* TODO(TS-TO-GO) Node BinaryExpression: symbolLinks[id] ??= new SymbolLinks() */ TODO
	}
	getNodeLinks := func(node Node) NodeLinks {
		nodeId := getNodeId(node)
		return nodeLinks[nodeId] || ( /* TODO(TS-TO-GO) Node BinaryExpression: nodeLinks[nodeId] = new (NodeLinks as any)() */ TODO)
	}
	getSymbol := func(symbols SymbolTable, name __String, meaning SymbolFlags) Symbol {
		if meaning {
			symbol := getMergedSymbol(symbols.get(name))
			if symbol {
				if symbol.flags & meaning {
					return symbol
				}
				if symbol.flags & SymbolFlagsAlias {
					targetFlags := getSymbolFlags(symbol)
					// `targetFlags` will be `SymbolFlags.All` if an error occurred in alias resolution; this avoids cascading errors
					if targetFlags & meaning {
						return symbol
					}
				}
			}
		}
		// return undefined if we can't find a symbol.
	}
	/**
	 * Get symbols that represent parameter-property-declaration as parameter and as property declaration
	 * @param parameter a parameterDeclaration node
	 * @param parameterName a name of the parameter to get the symbols for.
	 * @return a tuple of two symbols
	 */
	getSymbolsOfParameterPropertyDeclaration := func(parameter ParameterPropertyDeclaration, parameterName __String) /* TODO(TS-TO-GO) TypeNode TupleType: [Symbol, Symbol] */ any {
		constructorDeclaration := parameter.parent
		classDeclaration := parameter.parent.parent
		parameterSymbol := getSymbol(constructorDeclaration.locals, parameterName, SymbolFlagsValue)
		propertySymbol := getSymbol(getMembersOfSymbol(classDeclaration.symbol), parameterName, SymbolFlagsValue)
		if parameterSymbol && propertySymbol {
			return []any{parameterSymbol, propertySymbol}
		}
		return Debug.fail("There should exist two symbols, one as property declaration and one as parameter declaration")
	}
	isBlockScopedNameDeclaredBeforeUse := func(declaration Declaration, usage Node) bool {
		declarationFile := getSourceFileOfNode(declaration)
		useFile := getSourceFileOfNode(usage)
		declContainer := getEnclosingBlockScopeContainer(declaration)
		if declarationFile != useFile {
			if (moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) || (!compilerOptions.outFile) || isInTypeQuery(usage) || declaration.flags&NodeFlagsAmbient {
				// nodes are in different files and order cannot be determined
				return true
			}
			// declaration is after usage
			// can be legal if usage is deferred (i.e. inside function or in initializer of instance property)
			if isUsedInFunctionOrInstanceProperty(usage, declaration) {
				return true
			}
			sourceFiles := host.getSourceFiles()
			return sourceFiles.indexOf(declarationFile) <= sourceFiles.indexOf(useFile)
		}
		// deferred usage in a type context is always OK regardless of the usage position:
		if !!(usage.flags & NodeFlagsJSDoc) || isInTypeQuery(usage) || isInAmbientOrTypeNode(usage) {
			return true
		}
		if declaration.pos <= usage.pos && !(isPropertyDeclaration(declaration) && isThisProperty(usage.parent) && !declaration.initializer && !declaration.exclamationToken) {
			// declaration is before usage
			if declaration.kind == SyntaxKindBindingElement {
				// still might be illegal if declaration and usage are both binding elements (eg var [a = b, b = b] = [1, 2])
				errorBindingElement := getAncestor(usage, SyntaxKindBindingElement) /* as BindingElement */
				if errorBindingElement {
					return findAncestor(errorBindingElement, isBindingElement) != findAncestor(declaration, isBindingElement) || declaration.pos < errorBindingElement.pos
				}
				// or it might be illegal if usage happens before parent variable is declared (eg var [a] = a)
				return isBlockScopedNameDeclaredBeforeUse(getAncestor(declaration, SyntaxKindVariableDeclaration) /* as Declaration */, usage)
			} else if declaration.kind == SyntaxKindVariableDeclaration {
				// still might be illegal if usage is in the initializer of the variable declaration (eg var a = a)
				return !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration /* as VariableDeclaration */, usage)
			} else if isClassLike(declaration) {
				// still might be illegal if the usage is within a computed property name in the class (eg class A { static p = "a"; [A.p]() {} })
				// or when used within a decorator in the class (e.g. `@dec(A.x) class A { static x = "x" }`),
				// except when used in a function that is not an IIFE (e.g., `@dec(() => A.x) class A { ... }`)
				container := findAncestor(usage, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case n == declaration:
						return "quit"
					case isComputedPropertyName(n):
						return n.parent.parent == declaration
					default:
						return !legacyDecorators && isDecorator(n) && (n.parent == declaration || isMethodDeclaration(n.parent) && n.parent.parent == declaration || isGetOrSetAccessorDeclaration(n.parent) && n.parent.parent == declaration || isPropertyDeclaration(n.parent) && n.parent.parent == declaration || isParameter(n.parent) && n.parent.parent.parent == declaration)
					}
				})
				if !container {
					return true
				}
				if !legacyDecorators && isDecorator(container) {
					return !!findAncestor(usage, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case n == container:
							return "quit"
						default:
							return isFunctionLike(n) && !getImmediatelyInvokedFunctionExpression(n)
						}
					})
				}
				return false
			} else if isPropertyDeclaration(declaration) {
				// still might be illegal if a self-referencing property initializer (eg private x = this.x)
				return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage /*stopAtAnyPropertyDeclaration*/, false)
			} else if isParameterPropertyDeclaration(declaration, declaration.parent) {
				// foo = this.bar is illegal in emitStandardClassFields when bar is a parameter property
				return !(emitStandardClassFields && getContainingClass(declaration) == getContainingClass(usage) && isUsedInFunctionOrInstanceProperty(usage, declaration))
			}
			return true
		}
		// declaration is after usage, but it can still be legal if usage is deferred:
		// 1. inside an export specifier
		// 2. inside a function
		// 3. inside an instance property initializer, a reference to a non-instance property
		//    (except when emitStandardClassFields: true and the reference is to a parameter property)
		// 4. inside a static property initializer, a reference to a static method in the same class
		// 5. inside a TS export= declaration (since we will move the export statement during emit to avoid TDZ)
		if usage.parent.kind == SyntaxKindExportSpecifier || (usage.parent.kind == SyntaxKindExportAssignment && (usage.parent /* as ExportAssignment */).isExportEquals) {
			// export specifiers do not use the variable, they only make it available for use
			return true
		}
		// When resolving symbols for exports, the `usage` location passed in can be the export site directly
		if usage.kind == SyntaxKindExportAssignment && (usage /* as ExportAssignment */).isExportEquals {
			return true
		}
		if isUsedInFunctionOrInstanceProperty(usage, declaration) {
			if emitStandardClassFields && getContainingClass(declaration) && (isPropertyDeclaration(declaration) || isParameterPropertyDeclaration(declaration, declaration.parent)) {
				return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage /*stopAtAnyPropertyDeclaration*/, true)
			} else {
				return true
			}
		}
		return false
		isImmediatelyUsedInInitializerOfBlockScopedVariable := func(declaration VariableDeclaration, usage Node) bool {
			switch declaration.parent.parent.kind {
			case SyntaxKindVariableStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindForStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindForOfStatement:
				if isSameScopeDescendentOf(usage, declaration, declContainer) {
					return true
				}
				break
			}
			// ForIn/ForOf case - use site should not be used in expression part
			grandparent := declaration.parent.parent
			return isForInOrOfStatement(grandparent) && isSameScopeDescendentOf(usage, grandparent.expression, declContainer)
		}
		isUsedInFunctionOrInstanceProperty := func(usage Node, declaration Node) bool {
			return !!findAncestor(usage, func(current Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
				if current == declContainer {
					return "quit"
				}
				if isFunctionLike(current) {
					return true
				}
				if isClassStaticBlockDeclaration(current) {
					return declaration.pos < usage.pos
				}
				propertyDeclaration := tryCast(current.parent, isPropertyDeclaration)
				if propertyDeclaration {
					initializerOfProperty := propertyDeclaration.initializer == current
					if initializerOfProperty {
						if isStatic(current.parent) {
							if declaration.kind == SyntaxKindMethodDeclaration {
								return true
							}
							if isPropertyDeclaration(declaration) && getContainingClass(usage) == getContainingClass(declaration) {
								propName := declaration.name
								if isIdentifier(propName) || isPrivateIdentifier(propName) {
									type_ := getTypeOfSymbol(getSymbolOfDeclaration(declaration))
									staticBlocks := filter(declaration.parent.members, isClassStaticBlockDeclaration)
									if isPropertyInitializedInStaticBlocks(propName, type_, staticBlocks, declaration.parent.pos, current.pos) {
										return true
									}
								}
							}
						} else {
							isDeclarationInstanceProperty := declaration.kind == SyntaxKindPropertyDeclaration && !isStatic(declaration)
							if !isDeclarationInstanceProperty || getContainingClass(usage) != getContainingClass(declaration) {
								return true
							}
						}
					}
				}
				return false
			})
		}
		/** stopAtAnyPropertyDeclaration is used for detecting ES-standard class field use-before-def errors */
		isPropertyImmediatelyReferencedWithinDeclaration := func(declaration /* TODO(TS-TO-GO) TypeNode UnionType: PropertyDeclaration | ParameterPropertyDeclaration */ any, usage Node, stopAtAnyPropertyDeclaration bool) bool {
			// always legal if usage is after declaration
			if usage.end > declaration.end {
				return false
			}
			// still might be legal if usage is deferred (e.g. x: any = () => this.x)
			// otherwise illegal if immediately referenced within the declaration (e.g. x: any = this.x)
			ancestorChangingReferenceScope := findAncestor(usage, func(node Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
				if node == declaration {
					return "quit"
				}
				switch node.kind {
				case SyntaxKindArrowFunction:
					return true
				case SyntaxKindPropertyDeclaration:
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case stopAtAnyPropertyDeclaration && (isPropertyDeclaration(declaration) && node.parent == declaration.parent || isParameterPropertyDeclaration(declaration, declaration.parent) && node.parent == declaration.parent.parent):
						return "quit"
					default:
						return true
					}
				case SyntaxKindBlock:
					switch node.parent.kind {
					case SyntaxKindGetAccessor:
						fallthrough // TODO(TS-TO-GO): merge cases
					case SyntaxKindMethodDeclaration:
						fallthrough // TODO(TS-TO-GO): merge cases
					case SyntaxKindSetAccessor:
						return true
					default:
						return false
					}
					fallthrough
				default:
					return false
				}
			})
			return ancestorChangingReferenceScope == nil
		}
	}
	getRequiresScopeChangeCache := func(node FunctionLikeDeclaration) *bool {
		return getNodeLinks(node).declarationRequiresScopeChange
	}
	setRequiresScopeChangeCache := func(node FunctionLikeDeclaration, value bool) {
		getNodeLinks(node).declarationRequiresScopeChange = value
	}
	// The invalid initializer error is needed in two situation:
	// 1. When result is undefined, after checking for a missing "this."
	// 2. When result is defined
	checkAndReportErrorForInvalidInitializer := func(errorLocation Node, name __String, propertyWithInvalidInitializer PropertyDeclaration, result Symbol) bool {
		if !emitStandardClassFields {
			if errorLocation && !result && checkAndReportErrorForMissingPrefix(errorLocation, name, name) {
				return true
			}
			// We have a match, but the reference occurred within a property initializer and the identifier also binds
			// to a local variable in the constructor where the code will be emitted. Note that this is actually allowed
			// with emitStandardClassFields because the scope semantics are different.
			error(errorLocation, __COND__(errorLocation && propertyWithInvalidInitializer.type_ && textRangeContainsPositionInclusive(propertyWithInvalidInitializer.type_, errorLocation.pos), Diagnostics.Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor, Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor), declarationNameToString(propertyWithInvalidInitializer.name), diagnosticName(name))
			return true
		}
		return false
	}
	onFailedToResolveSymbol := func(errorLocation Node, nameArg /* TODO(TS-TO-GO) TypeNode UnionType: __String | Identifier */ any, meaning SymbolFlags, nameNotFoundMessage DiagnosticMessage) {
		var name /* TODO(TS-TO-GO) inferred type (string & { __escapedIdentifier: void; }) | (void & { __escapedIdentifier: void; }) | InternalSymbolName */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isString(nameArg):
			name = nameArg
		default:
			name = (nameArg /* as Identifier */).escapedText
		}
		addLazyDiagnostic(func() {
			if !errorLocation || errorLocation.parent.kind != SyntaxKindJSDocLink && !checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) && !checkAndReportErrorForExtendingInterface(errorLocation) && !checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) && !checkAndReportErrorForExportingPrimitiveType(errorLocation, name) && !checkAndReportErrorForUsingNamespaceAsTypeOrValue(errorLocation, name, meaning) && !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) && !checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning) {
				var suggestion Symbol
				var suggestedLib *string
				// Report missing lib first
				if nameArg {
					suggestedLib = getSuggestedLibForNonExistentName(nameArg)
					if suggestedLib {
						error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg), suggestedLib)
					}
				}
				// then spelling suggestions
				if !suggestedLib && suggestionCount < maximumSuggestionCount {
					suggestion = getSuggestedSymbolForNonexistentSymbol(errorLocation, name, meaning)
					isGlobalScopeAugmentationDeclaration := suggestion. /* TODO(TS-TO-GO): was ? */ valueDeclaration && isAmbientModule(suggestion.valueDeclaration) && isGlobalScopeAugmentation(suggestion.valueDeclaration)
					if isGlobalScopeAugmentationDeclaration {
						suggestion = nil
					}
					if suggestion {
						suggestionName := symbolToString(suggestion)
						isUncheckedJS := isUncheckedJSSuggestion(errorLocation, suggestion /*excludeClasses*/, false)
						var message DiagnosticMessage
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case meaning == SymbolFlagsNamespace || nameArg && /* TODO(TS-TO-GO) Node TypeOfExpression: typeof nameArg */ TODO != "string" && nodeIsSynthesized(nameArg):
							message = Diagnostics.Cannot_find_namespace_0_Did_you_mean_1
						case isUncheckedJS:
							message = Diagnostics.Could_not_find_name_0_Did_you_mean_1
						default:
							message = Diagnostics.Cannot_find_name_0_Did_you_mean_1
						}
						diagnostic := createError(errorLocation, message, diagnosticName(nameArg), suggestionName)
						diagnostic.canonicalHead = getCanonicalDiagnostic(nameNotFoundMessage, diagnosticName(nameArg))
						addErrorOrSuggestion(!isUncheckedJS, diagnostic)
						if suggestion.valueDeclaration {
							addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName))
						}
					}
				}
				// And then fall back to unspecified "not found"
				if !suggestion && !suggestedLib && nameArg {
					error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg))
				}
				suggestionCount++
			}
		})
	}
	onSuccessfullyResolvedSymbol := func(errorLocation Node, result Symbol, meaning SymbolFlags, lastLocation Node, associatedDeclarationForContainingInitializerOrBindingName /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | BindingElement | undefined */ any, withinDeferredContext bool) {
		addLazyDiagnostic(func() {
			name := result.escapedName
			isInExternalModule := lastLocation && isSourceFile(lastLocation) && isExternalOrCommonJsModule(lastLocation)
			// Only check for block-scoped variable if we have an error location and are looking for the
			// name with variable meaning
			//      For example,
			//          declare module foo {
			//              interface bar {}
			//          }
			//      const foo/*1*/: foo/*2*/.bar;
			// The foo at /*1*/ and /*2*/ will share same symbol with two meanings:
			// block-scoped variable and namespace module. However, only when we
			// try to resolve name in /*1*/ which is used in variable position,
			// we want to check for block-scoped
			if errorLocation && (meaning&SymbolFlagsBlockScopedVariable || ((meaning&SymbolFlagsClass || meaning&SymbolFlagsEnum) && (meaning&SymbolFlagsValue) == SymbolFlagsValue)) {
				exportOrLocalSymbol := getExportSymbolOfValueSymbolIfExported(result)
				if exportOrLocalSymbol.flags&SymbolFlagsBlockScopedVariable || exportOrLocalSymbol.flags&SymbolFlagsClass || exportOrLocalSymbol.flags&SymbolFlagsEnum {
					checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation)
				}
			}
			// If we're in an external module, we can't reference value symbols created from UMD export declarations
			if isInExternalModule && (meaning&SymbolFlagsValue) == SymbolFlagsValue && !(errorLocation.flags & NodeFlagsJSDoc) {
				merged := getMergedSymbol(result)
				if length(merged.declarations) && every(merged.declarations, func(d Declaration) bool {
					return isNamespaceExportDeclaration(d) || isSourceFile(d) && !!d.symbol.globalExports
				}) {
					errorOrSuggestion(!compilerOptions.allowUmdGlobalAccess, errorLocation, Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead, unescapeLeadingUnderscores(name))
				}
			}
			// If we're in a parameter initializer or binding name, we can't reference the values of the parameter whose initializer we're within or parameters to the right
			if associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning&SymbolFlagsValue) == SymbolFlagsValue {
				candidate := getMergedSymbol(getLateBoundSymbol(result))
				root := getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName) /* as ParameterDeclaration */
				// A parameter initializer or binding pattern initializer within a parameter cannot refer to itself
				if candidate == getSymbolOfDeclaration(associatedDeclarationForContainingInitializerOrBindingName) {
					error(errorLocation, Diagnostics.Parameter_0_cannot_reference_itself, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name))
				} else if candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && getSymbol(root.parent.locals, candidate.escapedName, meaning) == candidate {
					error(errorLocation, Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name), declarationNameToString(errorLocation /* as Identifier */))
				}
			}
			if errorLocation && meaning&SymbolFlagsValue && result.flags&SymbolFlagsAlias && !(result.flags & SymbolFlagsValue) && !isValidTypeOnlyAliasUseSite(errorLocation) {
				typeOnlyDeclaration := getTypeOnlyAliasDeclaration(result, SymbolFlagsValue)
				if typeOnlyDeclaration {
					var message DiagnosticMessage
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case typeOnlyDeclaration.kind == SyntaxKindExportSpecifier || typeOnlyDeclaration.kind == SyntaxKindExportDeclaration || typeOnlyDeclaration.kind == SyntaxKindNamespaceExport:
						message = Diagnostics._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type
					default:
						message = Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type
					}
					unescapedName := unescapeLeadingUnderscores(name)
					addTypeOnlyDeclarationRelatedInfo(error(errorLocation, message, unescapedName), typeOnlyDeclaration, unescapedName)
				}
			}
			// Look at 'compilerOptions.isolatedModules' and not 'getIsolatedModules(...)' (which considers 'verbatimModuleSyntax')
			// here because 'verbatimModuleSyntax' will already have an error for importing a type without 'import type'.
			if compilerOptions.isolatedModules && result && isInExternalModule && (meaning&SymbolFlagsValue) == SymbolFlagsValue {
				isGlobal := getSymbol(globals, name, meaning) == result
				nonValueSymbol := isGlobal && isSourceFile(lastLocation) && lastLocation.locals && getSymbol(lastLocation.locals, name, ~SymbolFlagsValue)
				if nonValueSymbol {
					importDecl := nonValueSymbol.declarations. /* TODO(TS-TO-GO): was ? */ find(func(d Declaration) bool {
						return d.kind == SyntaxKindImportSpecifier || d.kind == SyntaxKindImportClause || d.kind == SyntaxKindNamespaceImport || d.kind == SyntaxKindImportEqualsDeclaration
					})
					if importDecl && !isTypeOnlyImportDeclaration(importDecl) {
						error(importDecl, Diagnostics.Import_0_conflicts_with_global_value_used_in_this_file_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, unescapeLeadingUnderscores(name))
					}
				}
			}
		})
	}
	addTypeOnlyDeclarationRelatedInfo := func(diagnostic Diagnostic, typeOnlyDeclaration *TypeOnlyCompatibleAliasDeclaration, unescapedName string) Diagnostic {
		if !typeOnlyDeclaration {
			return diagnostic
		}
		return addRelatedInfo(diagnostic, createDiagnosticForNode(typeOnlyDeclaration, __COND__(typeOnlyDeclaration.kind == SyntaxKindExportSpecifier || typeOnlyDeclaration.kind == SyntaxKindExportDeclaration || typeOnlyDeclaration.kind == SyntaxKindNamespaceExport, Diagnostics._0_was_exported_here, Diagnostics._0_was_imported_here), unescapedName))
	}
	diagnosticName := func(nameArg /* TODO(TS-TO-GO) TypeNode UnionType: __String | Identifier | PrivateIdentifier */ any) string {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isString(nameArg):
			return unescapeLeadingUnderscores(nameArg /* as __String */)
		default:
			return declarationNameToString(nameArg /* as Identifier */)
		}
	}
	checkAndReportErrorForMissingPrefix := func(errorLocation Node, name __String, nameArg /* TODO(TS-TO-GO) TypeNode UnionType: __String | Identifier */ any) bool {
		if !isIdentifier(errorLocation) || errorLocation.escapedText != name || isTypeReferenceIdentifier(errorLocation) || isInTypeQuery(errorLocation) {
			return false
		}
		container := getThisContainer(errorLocation /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
		var location Node = container
		for location {
			if isClassLike(location.parent) {
				classSymbol := getSymbolOfDeclaration(location.parent)
				if !classSymbol {
					break
				}
				// Check to see if a static member exists.
				constructorType := getTypeOfSymbol(classSymbol)
				if getPropertyOfType(constructorType, name) {
					error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0, diagnosticName(nameArg), symbolToString(classSymbol))
					return true
				}
				// No static member is present.
				// Check if we're in an instance method and look for a relevant instance member.
				if location == container && !isStatic(location) {
					instanceType := (getDeclaredTypeOfSymbol(classSymbol) /* as InterfaceType */).thisType
					// TODO: GH#18217
					if getPropertyOfType(instanceType, name) {
						error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0, diagnosticName(nameArg))
						return true
					}
				}
			}
			location = location.parent
		}
		return false
	}
	checkAndReportErrorForExtendingInterface := func(errorLocation Node) bool {
		expression := getEntityNameForExtendingInterface(errorLocation)
		if expression && resolveEntityName(expression, SymbolFlagsInterface /*ignoreErrors*/, true) {
			error(errorLocation, Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements, getTextOfNode(expression))
			return true
		}
		return false
	}
	/**
	 * Climbs up parents to an ExpressionWithTypeArguments, and returns its expression,
	 * but returns undefined if that expression is not an EntityNameExpression.
	 */
	getEntityNameForExtendingInterface := func(node Node) *EntityNameExpression {
		switch node.kind {
		case SyntaxKindIdentifier:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertyAccessExpression:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node.parent:
				return getEntityNameForExtendingInterface(node.parent)
			default:
				return nil
			}
		case SyntaxKindExpressionWithTypeArguments:
			if isEntityNameExpression((node /* as ExpressionWithTypeArguments */).expression) {
				return (node /* as ExpressionWithTypeArguments */).expression /* as EntityNameExpression */
			}
			fallthrough
		default:
			return nil
		}
	}
	checkAndReportErrorForUsingTypeAsNamespace := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		namespaceMeaning := SymbolFlagsNamespace | (__COND__(isInJSFile(errorLocation), SymbolFlagsValue, 0))
		if meaning == namespaceMeaning {
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsType&~namespaceMeaning /*nameNotFoundMessage*/, nil /*isUse*/, false))
			parent := errorLocation.parent
			if symbol {
				if isQualifiedName(parent) {
					Debug.assert(parent.left == errorLocation, "Should only be resolving left side of qualified name as a namespace")
					propName := parent.right.escapedText
					propType := getPropertyOfType(getDeclaredTypeOfSymbol(symbol), propName)
					if propType {
						error(parent, Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, unescapeLeadingUnderscores(name), unescapeLeadingUnderscores(propName))
						return true
					}
				}
				error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here, unescapeLeadingUnderscores(name))
				return true
			}
		}
		return false
	}
	checkAndReportErrorForUsingValueAsType := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if meaning & (SymbolFlagsType & ~SymbolFlagsNamespace) {
			symbol := resolveSymbol(resolveName(errorLocation, name, ~SymbolFlagsType&SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, false))
			if symbol && !(symbol.flags & SymbolFlagsNamespace) {
				error(errorLocation, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, unescapeLeadingUnderscores(name))
				return true
			}
		}
		return false
	}
	isPrimitiveTypeName := func(name __String) bool {
		return name == "any" || name == "string" || name == "number" || name == "boolean" || name == "never" || name == "unknown"
	}
	checkAndReportErrorForExportingPrimitiveType := func(errorLocation Node, name __String) bool {
		if isPrimitiveTypeName(name) && errorLocation.parent.kind == SyntaxKindExportSpecifier {
			error(errorLocation, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, name /* as string */)
			return true
		}
		return false
	}
	checkAndReportErrorForUsingTypeAsValue := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if meaning & SymbolFlagsValue {
			if isPrimitiveTypeName(name) {
				grandparent := errorLocation.parent.parent
				if grandparent && grandparent.parent && isHeritageClause(grandparent) {
					heritageKind := grandparent.token
					containerKind := grandparent.parent.kind
					if containerKind == SyntaxKindInterfaceDeclaration && heritageKind == SyntaxKindExtendsKeyword {
						error(errorLocation, Diagnostics.An_interface_cannot_extend_a_primitive_type_like_0_It_can_only_extend_other_named_object_types, unescapeLeadingUnderscores(name))
					} else if containerKind == SyntaxKindClassDeclaration && heritageKind == SyntaxKindExtendsKeyword {
						error(errorLocation, Diagnostics.A_class_cannot_extend_a_primitive_type_like_0_Classes_can_only_extend_constructable_values, unescapeLeadingUnderscores(name))
					} else if containerKind == SyntaxKindClassDeclaration && heritageKind == SyntaxKindImplementsKeyword {
						error(errorLocation, Diagnostics.A_class_cannot_implement_a_primitive_type_like_0_It_can_only_implement_other_named_object_types, unescapeLeadingUnderscores(name))
					}
				} else {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, unescapeLeadingUnderscores(name))
				}
				return true
			}
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsType&~SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, false))
			allFlags := symbol && getSymbolFlags(symbol)
			if symbol && allFlags != nil && !(allFlags & SymbolFlagsValue) {
				rawName := unescapeLeadingUnderscores(name)
				if isES2015OrLaterConstructorName(name) {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later, rawName)
				} else if maybeMappedType(errorLocation, symbol) {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0, rawName, __COND__(rawName == "K", "P", "K"))
				} else {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, rawName)
				}
				return true
			}
		}
		return false
	}
	maybeMappedType := func(node Node, symbol Symbol) bool {
		container := findAncestor(node.parent, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isComputedPropertyName(n) || isPropertySignature(n):
				return false
			default:
				return isTypeLiteralNode(n) || "quit"
			}
		}) /* as TypeLiteralNode | undefined */
		if container && container.members.length == 1 {
			type_ := getDeclaredTypeOfSymbol(symbol)
			return !!(type_.flags & TypeFlagsUnion) && allTypesAssignableToKind(type_, TypeFlagsStringOrNumberLiteral /*strict*/, true)
		}
		return false
	}
	isES2015OrLaterConstructorName := func(n __String) bool {
		switch n {
		case "Promise":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Symbol":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Map":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "WeakMap":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Set":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "WeakSet":
			return true
		}
		return false
	}
	checkAndReportErrorForUsingNamespaceAsTypeOrValue := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if meaning & (SymbolFlagsValue & ~SymbolFlagsType) {
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsNamespaceModule /*nameNotFoundMessage*/, nil /*isUse*/, false))
			if symbol {
				error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_value, unescapeLeadingUnderscores(name))
				return true
			}
		} else if meaning & (SymbolFlagsType & ~SymbolFlagsValue) {
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsModule /*nameNotFoundMessage*/, nil /*isUse*/, false))
			if symbol {
				error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_type, unescapeLeadingUnderscores(name))
				return true
			}
		}
		return false
	}
	checkResolvedBlockScopedVariable := func(result Symbol, errorLocation Node) {
		Debug.assert(!!(result.flags&SymbolFlagsBlockScopedVariable || result.flags&SymbolFlagsClass || result.flags&SymbolFlagsEnum))
		if result.flags&(SymbolFlagsFunction|SymbolFlagsFunctionScopedVariable|SymbolFlagsAssignment) && result.flags&SymbolFlagsClass {
			// constructor functions aren't block scoped
			return
		}
		// Block-scoped variables cannot be used before their definition
		declaration := result.declarations. /* TODO(TS-TO-GO): was ? */ find(func(d Declaration) bool {
			return isBlockOrCatchScoped(d) || isClassLike(d) || (d.kind == SyntaxKindEnumDeclaration)
		})
		if declaration == nil {
			return Debug.fail("checkResolvedBlockScopedVariable could not find block-scoped declaration")
		}
		if !(declaration.flags & NodeFlagsAmbient) && !isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation) {
			var diagnosticMessage TODO
			declarationName := declarationNameToString(getNameOfDeclaration(declaration))
			if result.flags & SymbolFlagsBlockScopedVariable {
				diagnosticMessage = error(errorLocation, Diagnostics.Block_scoped_variable_0_used_before_its_declaration, declarationName)
			} else if result.flags & SymbolFlagsClass {
				diagnosticMessage = error(errorLocation, Diagnostics.Class_0_used_before_its_declaration, declarationName)
			} else if result.flags & SymbolFlagsRegularEnum {
				diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName)
			} else {
				Debug.assert(!!(result.flags & SymbolFlagsConstEnum))
				if getIsolatedModules(compilerOptions) {
					diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName)
				}
			}
			if diagnosticMessage {
				addRelatedInfo(diagnosticMessage, createDiagnosticForNode(declaration, Diagnostics._0_is_declared_here, declarationName))
			}
		}
	}
	/* Starting from 'initial' node walk up the parent chain until 'stopAt' node is reached.
	 * If at any point current node is equal to 'parent' node - return true.
	 * If current node is an IIFE, continue walking up.
	 * Return false if 'stopAt' node is reached or isFunctionLike(current) === true.
	 */
	isSameScopeDescendentOf := func(initial Node, parent Node, stopAt Node) bool {
		return !!parent && !!findAncestor(initial, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			return n == parent || (__COND__(n == stopAt || isFunctionLike(n) && (!getImmediatelyInvokedFunctionExpression(n) || (getFunctionFlags(n)&FunctionFlagsAsyncGenerator)), "quit", false))
		})
	}
	getAnyImportSyntax := func(node Node) *AnyImportOrJsDocImport {
		switch node.kind {
		case SyntaxKindImportEqualsDeclaration:
			return node /* as ImportEqualsDeclaration */
		case SyntaxKindImportClause:
			return (node /* as ImportClause */).parent
		case SyntaxKindNamespaceImport:
			return (node /* as NamespaceImport */).parent.parent
		case SyntaxKindImportSpecifier:
			return (node /* as ImportSpecifier */).parent.parent.parent
		default:
			return nil
		}
	}
	getDeclarationOfAliasSymbol := func(symbol Symbol) Declaration {
		return symbol.declarations && findLast(symbol.declarations, isAliasSymbolDeclaration)
	}
	/**
	 * An alias symbol is created by one of the following declarations:
	 * import <symbol> = ...
	 * import <symbol> from ...
	 * import * as <symbol> from ...
	 * import { x as <symbol> } from ...
	 * export { x as <symbol> } from ...
	 * export * as ns <symbol> from ...
	 * export = <EntityNameExpression>
	 * export default <EntityNameExpression>
	 * module.exports = <EntityNameExpression>
	 * {<Identifier>}
	 * {name: <EntityNameExpression>}
	 * const { x } = require ...
	 */
	isAliasSymbolDeclaration := func(node Node) bool {
		return node.kind == SyntaxKindImportEqualsDeclaration || node.kind == SyntaxKindNamespaceExportDeclaration || node.kind == SyntaxKindImportClause && !!(node /* as ImportClause */).name || node.kind == SyntaxKindNamespaceImport || node.kind == SyntaxKindNamespaceExport || node.kind == SyntaxKindImportSpecifier || node.kind == SyntaxKindExportSpecifier || node.kind == SyntaxKindExportAssignment && exportAssignmentIsAlias(node /* as ExportAssignment */) || isBinaryExpression(node) && getAssignmentDeclarationKind(node) == AssignmentDeclarationKindModuleExports && exportAssignmentIsAlias(node) || isAccessExpression(node) && isBinaryExpression(node.parent) && node.parent.left == node && node.parent.operatorToken.kind == SyntaxKindEqualsToken && isAliasableOrJsExpression(node.parent.right) || node.kind == SyntaxKindShorthandPropertyAssignment || node.kind == SyntaxKindPropertyAssignment && isAliasableOrJsExpression((node /* as PropertyAssignment */).initializer) || node.kind == SyntaxKindVariableDeclaration && isVariableDeclarationInitializedToBareOrAccessedRequire(node) || node.kind == SyntaxKindBindingElement && isVariableDeclarationInitializedToBareOrAccessedRequire(node.parent.parent)
	}
	isAliasableOrJsExpression := func(e Expression) bool {
		return isAliasableExpression(e) || isFunctionExpression(e) && isJSConstructor(e)
	}
	getTargetOfImportEqualsDeclaration := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportEqualsDeclaration | VariableDeclaration */ any, dontResolveAlias bool) Symbol {
		commonJSPropertyAccess := getCommonJSPropertyAccess(node)
		if commonJSPropertyAccess {
			name := (getLeftmostAccessExpression(commonJSPropertyAccess.expression) /* as CallExpression */).arguments[0] /* as StringLiteral */
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isIdentifier(commonJSPropertyAccess.name):
				return resolveSymbol(getPropertyOfType(resolveExternalModuleTypeByLiteral(name), commonJSPropertyAccess.name.escapedText))
			default:
				return nil
			}
		}
		if isVariableDeclaration(node) || node.moduleReference.kind == SyntaxKindExternalModuleReference {
			immediate := resolveExternalModuleName(node, getExternalModuleRequireArgument(node) || getExternalModuleImportEqualsDeclarationExpression(node))
			resolved := resolveExternalModuleSymbol(immediate)
			markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved /*overwriteEmpty*/, false)
			return resolved
		}
		resolved := getSymbolOfPartOfRightHandSideOfImportEquals(node.moduleReference, dontResolveAlias)
		checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved)
		return resolved
	}
	checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol := func(node ImportEqualsDeclaration, resolved Symbol) {
		if markSymbolOfAliasDeclarationIfTypeOnly(node /*immediateTarget*/, nil, resolved /*overwriteEmpty*/, false) && !node.isTypeOnly {
			typeOnlyDeclaration := getTypeOnlyAliasDeclaration(getSymbolOfDeclaration(node))
			isExport := typeOnlyDeclaration.kind == SyntaxKindExportSpecifier || typeOnlyDeclaration.kind == SyntaxKindExportDeclaration
			var message DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isExport:
				message = Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type
			default:
				message = Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type
			}
			var relatedMessage DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isExport:
				relatedMessage = Diagnostics._0_was_exported_here
			default:
				relatedMessage = Diagnostics._0_was_imported_here
			}
			// TODO: how to get name for export *?
			var name string
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case typeOnlyDeclaration.kind == SyntaxKindExportDeclaration:
				name = "*"
			default:
				name = moduleExportNameTextUnescaped(typeOnlyDeclaration.name)
			}
			addRelatedInfo(error(node.moduleReference, message), createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, name))
		}
	}
	resolveExportByName := func(moduleSymbol Symbol, name __String, sourceNode *TypeOnlyCompatibleAliasDeclaration, dontResolveAlias bool) Symbol {
		exportValue := moduleSymbol.exports.get(InternalSymbolNameExportEquals)
		var exportSymbol Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case exportValue:
			exportSymbol = getPropertyOfType(getTypeOfSymbol(exportValue), name /*skipObjectFunctionPropertyAugment*/, true)
		default:
			exportSymbol = moduleSymbol.exports.get(name)
		}
		resolved := resolveSymbol(exportSymbol, dontResolveAlias)
		markSymbolOfAliasDeclarationIfTypeOnly(sourceNode, exportSymbol, resolved /*overwriteEmpty*/, false)
		return resolved
	}
	isSyntacticDefault := func(node Node) bool {
		return ((isExportAssignment(node) && !node.isExportEquals) || hasSyntacticModifier(node, ModifierFlagsDefault) || isExportSpecifier(node) || isNamespaceExport(node))
	}
	getEmitSyntaxForModuleSpecifierExpression := func(usage Expression) ResolutionMode {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isStringLiteralLike(usage):
			return host.getEmitSyntaxForUsageLocation(getSourceFileOfNode(usage), usage)
		default:
			return nil
		}
	}
	isESMFormatImportImportingCommonjsFormatFile := func(usageMode ResolutionMode, targetMode ResolutionMode) bool {
		return usageMode == ModuleKindESNext && targetMode == ModuleKindCommonJS
	}
	isOnlyImportableAsDefault := func(usage Expression) bool {
		// In Node.js, JSON modules don't get named exports
		if ModuleKindNode16 <= moduleKind && moduleKind <= ModuleKindNodeNext {
			usageMode := getEmitSyntaxForModuleSpecifierExpression(usage)
			return usageMode == ModuleKindESNext && endsWith((usage /* as StringLiteralLike */).text, ExtensionJson)
		}
		return false
	}
	canHaveSyntheticDefault := func(file *SourceFile, moduleSymbol Symbol, dontResolveAlias bool, usage Expression) bool {
		usageMode := file && getEmitSyntaxForModuleSpecifierExpression(usage)
		if file && usageMode != nil {
			targetMode := host.getImpliedNodeFormatForEmit(file)
			if usageMode == ModuleKindESNext && targetMode == ModuleKindCommonJS && ModuleKindNode16 <= moduleKind && moduleKind <= ModuleKindNodeNext {
				// In Node.js, CommonJS modules always have a synthetic default when imported into ESM
				return true
			}
			if usageMode == ModuleKindESNext && targetMode == ModuleKindESNext {
				// No matter what the `module` setting is, if we're confident that both files
				// are ESM, there cannot be a synthetic default.
				return false
			}
		}
		if !allowSyntheticDefaultImports {
			return false
		}
		// Declaration files (and ambient modules)
		if !file || file.isDeclarationFile {
			// Definitely cannot have a synthetic default if they have a syntactic default member specified
			defaultExportSymbol := resolveExportByName(moduleSymbol, InternalSymbolNameDefault /*sourceNode*/, nil /*dontResolveAlias*/, true)
			// Dont resolve alias because we want the immediately exported symbol's declaration
			if defaultExportSymbol && some(defaultExportSymbol.declarations, isSyntacticDefault) {
				return false
			}
			// It _might_ still be incorrect to assume there is no __esModule marker on the import at runtime, even if there is no `default` member
			// So we check a bit more,
			if resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule") /*sourceNode*/, nil, dontResolveAlias) {
				// If there is an `__esModule` specified in the declaration (meaning someone explicitly added it or wrote it in their code),
				// it definitely is a module and does not have a synthetic default
				return false
			}
			// There are _many_ declaration files not written with esmodules in mind that still get compiled into a format with __esModule set
			// Meaning there may be no default at runtime - however to be on the permissive side, we allow access to a synthetic default member
			// as there is no marker to indicate if the accompanying JS has `__esModule` or not, or is even native esm
			return true
		}
		// TypeScript files never have a synthetic default (as they are always emitted with an __esModule marker) _unless_ they contain an export= statement
		if !isSourceFileJS(file) {
			return hasExportAssignmentSymbol(moduleSymbol)
		}
		// JS files have a synthetic default if they do not contain ES2015+ module syntax (export = is not valid in js) _and_ do not have an __esModule marker
		return /* TODO(TS-TO-GO) Node TypeOfExpression: typeof file.externalModuleIndicator */ TODO != "object" && !resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule") /*sourceNode*/, nil, dontResolveAlias)
	}
	getTargetOfImportClause := func(node ImportClause, dontResolveAlias bool) Symbol {
		moduleSymbol := resolveExternalModuleName(node, node.parent.moduleSpecifier)
		if moduleSymbol {
			return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
		}
	}
	getTargetofModuleDefault := func(moduleSymbol Symbol, node /* TODO(TS-TO-GO) TypeNode UnionType: ImportClause | ImportOrExportSpecifier */ any, dontResolveAlias bool) Symbol {
		var exportDefaultSymbol Symbol
		if isShorthandAmbientModuleSymbol(moduleSymbol) {
			exportDefaultSymbol = moduleSymbol
		} else {
			exportDefaultSymbol = resolveExportByName(moduleSymbol, InternalSymbolNameDefault, node, dontResolveAlias)
		}
		file := moduleSymbol.declarations. /* TODO(TS-TO-GO): was ? */ find(isSourceFile)
		specifier := getModuleSpecifierForImportOrExport(node)
		if !specifier {
			return exportDefaultSymbol
		}
		hasDefaultOnly := isOnlyImportableAsDefault(specifier)
		hasSyntheticDefault := canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, specifier)
		if !exportDefaultSymbol && !hasSyntheticDefault && !hasDefaultOnly {
			if hasExportAssignmentSymbol(moduleSymbol) && !allowSyntheticDefaultImports {
				var compilerOptionName /* TODO(TS-TO-GO) inferred type "allowSyntheticDefaultImports" | "esModuleInterop" */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case moduleKind >= ModuleKindES2015:
					compilerOptionName = "allowSyntheticDefaultImports"
				default:
					compilerOptionName = "esModuleInterop"
				}
				exportEqualsSymbol := moduleSymbol.exports.get(InternalSymbolNameExportEquals)
				exportAssignment := exportEqualsSymbol.valueDeclaration
				err := error(node.name, Diagnostics.Module_0_can_only_be_default_imported_using_the_1_flag, symbolToString(moduleSymbol), compilerOptionName)
				if exportAssignment {
					addRelatedInfo(err, createDiagnosticForNode(exportAssignment, Diagnostics.This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag, compilerOptionName))
				}
			} else if isImportClause(node) {
				reportNonDefaultExport(moduleSymbol, node)
			} else {
				errorNoModuleMemberSymbol(moduleSymbol, moduleSymbol, node, isImportOrExportSpecifier(node) && node.propertyName || node.name)
			}
		} else if hasSyntheticDefault || hasDefaultOnly {
			// per emit behavior, a synthetic default overrides a "real" .default member if `__esModule` is not present
			resolved := resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias)
			markSymbolOfAliasDeclarationIfTypeOnly(node, moduleSymbol, resolved /*overwriteEmpty*/, false)
			return resolved
		}
		markSymbolOfAliasDeclarationIfTypeOnly(node, exportDefaultSymbol /*finalTarget*/, nil /*overwriteEmpty*/, false)
		return exportDefaultSymbol
	}
	getModuleSpecifierForImportOrExport := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportOrExportSpecifier */ any) Expression {
		switch node.kind {
		case SyntaxKindImportClause:
			return node.parent.moduleSpecifier
		case SyntaxKindImportEqualsDeclaration:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isExternalModuleReference(node.moduleReference):
				return node.moduleReference.expression
			default:
				return nil
			}
		case SyntaxKindNamespaceImport:
			return node.parent.parent.moduleSpecifier
		case SyntaxKindImportSpecifier:
			return node.parent.parent.parent.moduleSpecifier
		case SyntaxKindExportSpecifier:
			return node.parent.parent.moduleSpecifier
		default:
			return Debug.assertNever(node)
		}
	}
	reportNonDefaultExport := func(moduleSymbol Symbol, node ImportClause) {
		if moduleSymbol.exports. /* TODO(TS-TO-GO): was ? */ has(node.symbol.escapedName) {
			error(node.name, Diagnostics.Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead, symbolToString(moduleSymbol), symbolToString(node.symbol))
		} else {
			diagnostic := error(node.name, Diagnostics.Module_0_has_no_default_export, symbolToString(moduleSymbol))
			exportStar := moduleSymbol.exports. /* TODO(TS-TO-GO): was ? */ get(InternalSymbolNameExportStar)
			if exportStar {
				defaultExport := exportStar.declarations. /* TODO(TS-TO-GO): was ? */ find(func(decl Declaration) bool {
					return !!(isExportDeclaration(decl) && decl.moduleSpecifier && resolveExternalModuleName(decl, decl.moduleSpecifier). /* TODO(TS-TO-GO): was ? */ exports. /* TODO(TS-TO-GO): was ? */ has(InternalSymbolNameDefault))
				})
				if defaultExport {
					addRelatedInfo(diagnostic, createDiagnosticForNode(defaultExport, Diagnostics.export_Asterisk_does_not_re_export_a_default))
				}
			}
		}
	}
	getTargetOfNamespaceImport := func(node NamespaceImport, dontResolveAlias bool) Symbol {
		moduleSpecifier := node.parent.parent.moduleSpecifier
		immediate := resolveExternalModuleName(node, moduleSpecifier)
		resolved := resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias /*suppressInteropError*/, false)
		markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved /*overwriteEmpty*/, false)
		return resolved
	}
	getTargetOfNamespaceExport := func(node NamespaceExport, dontResolveAlias bool) Symbol {
		moduleSpecifier := node.parent.moduleSpecifier
		immediate := moduleSpecifier && resolveExternalModuleName(node, moduleSpecifier)
		resolved := moduleSpecifier && resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias /*suppressInteropError*/, false)
		markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved /*overwriteEmpty*/, false)
		return resolved
	}
	// This function creates a synthetic symbol that combines the value side of one symbol with the
	// type/namespace side of another symbol. Consider this example:
	//
	//   declare module graphics {
	//       interface Point {
	//           x: number;
	//           y: number;
	//       }
	//   }
	//   declare var graphics: {
	//       Point: new (x: number, y: number) => graphics.Point;
	//   }
	//   declare module "graphics" {
	//       export = graphics;
	//   }
	//
	// An 'import { Point } from "graphics"' needs to create a symbol that combines the value side 'Point'
	// property with the type/namespace side interface 'Point'.
	combineValueAndTypeSymbols := func(valueSymbol Symbol, typeSymbol Symbol) Symbol {
		if valueSymbol == unknownSymbol && typeSymbol == unknownSymbol {
			return unknownSymbol
		}
		if valueSymbol.flags & (SymbolFlagsType | SymbolFlagsNamespace) {
			return valueSymbol
		}
		result := createSymbol(valueSymbol.flags|typeSymbol.flags, valueSymbol.escapedName)
		Debug.assert(valueSymbol.declarations || typeSymbol.declarations)
		result.declarations = deduplicate(concatenate(valueSymbol.declarations, typeSymbol.declarations), equateValues)
		result.parent = valueSymbol.parent || typeSymbol.parent
		if valueSymbol.valueDeclaration {
			result.valueDeclaration = valueSymbol.valueDeclaration
		}
		if typeSymbol.members {
			result.members = NewMap(typeSymbol.members)
		}
		if valueSymbol.exports {
			result.exports = NewMap(valueSymbol.exports)
		}
		return result
	}
	getExportOfModule := func(symbol Symbol, nameText __String, specifier Declaration, dontResolveAlias bool) Symbol {
		if symbol.flags & SymbolFlagsModule {
			exportSymbol := getExportsOfSymbol(symbol).get(nameText)
			resolved := resolveSymbol(exportSymbol, dontResolveAlias)
			exportStarDeclaration := getSymbolLinks(symbol).typeOnlyExportStarMap. /* TODO(TS-TO-GO): was ? */ get(nameText)
			markSymbolOfAliasDeclarationIfTypeOnly(specifier, exportSymbol, resolved /*overwriteEmpty*/, false, exportStarDeclaration, nameText)
			return resolved
		}
	}
	getPropertyOfVariable := func(symbol Symbol, name __String) Symbol {
		if symbol.flags & SymbolFlagsVariable {
			typeAnnotation := (symbol.valueDeclaration /* as VariableDeclaration */).type_
			if typeAnnotation {
				return resolveSymbol(getPropertyOfType(getTypeFromTypeNode(typeAnnotation), name))
			}
		}
	}
	getExternalModuleMember := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportDeclaration | ExportDeclaration | VariableDeclaration | JSDocImportTag */ any, specifier /* TODO(TS-TO-GO) TypeNode UnionType: ImportOrExportSpecifier | BindingElement | PropertyAccessExpression */ any, dontResolveAlias bool /*  = false */) Symbol {
		moduleSpecifier := getExternalModuleRequireArgument(node) || (node /* as ImportDeclaration | ExportDeclaration | JSDocImportTag */).moduleSpecifier
		moduleSymbol := resolveExternalModuleName(node, moduleSpecifier)
		// TODO: GH#18217
		name := !isPropertyAccessExpression(specifier) && specifier.propertyName || specifier.name
		if !isIdentifier(name) && name.kind != SyntaxKindStringLiteral {
			return nil
		}
		nameText := moduleExportNameTextEscaped(name)
		suppressInteropError := nameText == InternalSymbolNameDefault && allowSyntheticDefaultImports
		targetSymbol := resolveESModuleSymbol(moduleSymbol, moduleSpecifier /*dontResolveAlias*/, false, suppressInteropError)
		if targetSymbol {
			// Note: The empty string is a valid module export name:
			//
			//   import { "" as foo } from "./foo";
			//   export { foo as "" };
			//
			if nameText || name.kind == SyntaxKindStringLiteral {
				if isShorthandAmbientModuleSymbol(moduleSymbol) {
					return moduleSymbol
				}
				var symbolFromVariable Symbol
				// First check if module was specified with "export=". If so, get the member from the resolved type
				if moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get(InternalSymbolNameExportEquals) {
					symbolFromVariable = getPropertyOfType(getTypeOfSymbol(targetSymbol), nameText /*skipObjectFunctionPropertyAugment*/, true)
				} else {
					symbolFromVariable = getPropertyOfVariable(targetSymbol, nameText)
				}
				// if symbolFromVariable is export - get its final target
				symbolFromVariable = resolveSymbol(symbolFromVariable, dontResolveAlias)
				symbolFromModule := getExportOfModule(targetSymbol, nameText, specifier, dontResolveAlias)
				if symbolFromModule == nil && nameText == InternalSymbolNameDefault {
					file := moduleSymbol.declarations. /* TODO(TS-TO-GO): was ? */ find(isSourceFile)
					if isOnlyImportableAsDefault(moduleSpecifier) || canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, moduleSpecifier) {
						symbolFromModule = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias)
					}
				}
				var symbol Symbol
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case symbolFromModule && symbolFromVariable && symbolFromModule != symbolFromVariable:
					symbol = combineValueAndTypeSymbols(symbolFromVariable, symbolFromModule)
				default:
					symbol = symbolFromModule || symbolFromVariable
				}
				if !symbol {
					errorNoModuleMemberSymbol(moduleSymbol, targetSymbol, node, name)
				}
				return symbol
			}
		}
	}
	errorNoModuleMemberSymbol := func(moduleSymbol Symbol, targetSymbol Symbol, node Node, name ModuleExportName) {
		moduleName := getFullyQualifiedName(moduleSymbol, node)
		declarationName := declarationNameToString(name)
		var suggestion Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isIdentifier(name):
			suggestion = getSuggestedSymbolForNonexistentModule(name, targetSymbol)
		default:
			suggestion = nil
		}
		if suggestion != nil {
			suggestionName := symbolToString(suggestion)
			diagnostic := error(name, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, moduleName, declarationName, suggestionName)
			if suggestion.valueDeclaration {
				addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName))
			}
		} else {
			if moduleSymbol.exports. /* TODO(TS-TO-GO): was ? */ has(InternalSymbolNameDefault) {
				error(name, Diagnostics.Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead, moduleName, declarationName)
			} else {
				reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName)
			}
		}
	}
	reportNonExportedMember := func(node Node, name ModuleExportName, declarationName string, moduleSymbol Symbol, moduleName string) {
		localSymbol := tryCast(moduleSymbol.valueDeclaration, canHaveLocals). /* TODO(TS-TO-GO): was ? */ locals. /* TODO(TS-TO-GO): was ? */ get(moduleExportNameTextEscaped(name))
		exports := moduleSymbol.exports
		if localSymbol {
			exportedEqualsSymbol := exports. /* TODO(TS-TO-GO): was ? */ get(InternalSymbolNameExportEquals)
			if exportedEqualsSymbol {
				__COND__(getSymbolIfSameReference(exportedEqualsSymbol, localSymbol), reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName), error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName))
			} else {
				var exportedSymbol Symbol
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case exports:
					exportedSymbol = find(symbolsToArray(exports), func(symbol Symbol) bool {
						return !!getSymbolIfSameReference(symbol, localSymbol)
					})
				default:
					exportedSymbol = nil
				}
				var diagnostic Diagnostic
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case exportedSymbol:
					diagnostic = error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_exported_as_2, moduleName, declarationName, symbolToString(exportedSymbol))
				default:
					diagnostic = error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_not_exported, moduleName, declarationName)
				}
				if localSymbol.declarations {
					addRelatedInfo(diagnostic, map_(localSymbol.declarations, func(decl Declaration, index number) DiagnosticWithLocation {
						return createDiagnosticForNode(decl, __COND__(index == 0, Diagnostics._0_is_declared_here, Diagnostics.and_here), declarationName)
					})...)
				}
			}
		} else {
			error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName)
		}
	}
	reportInvalidImportEqualsExportMember := func(node Node, name ModuleExportName, declarationName string, moduleName string) {
		if moduleKind >= ModuleKindES2015 {
			var message DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case getESModuleInterop(compilerOptions):
				message = Diagnostics._0_can_only_be_imported_by_using_a_default_import
			default:
				message = Diagnostics._0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import
			}
			error(name, message, declarationName)
		} else {
			if isInJSFile(node) {
				var message DiagnosticMessage
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case getESModuleInterop(compilerOptions):
					message = Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import
				default:
					message = Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import
				}
				error(name, message, declarationName)
			} else {
				var message DiagnosticMessage
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case getESModuleInterop(compilerOptions):
					message = Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import
				default:
					message = Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import
				}
				error(name, message, declarationName, declarationName, moduleName)
			}
		}
	}
	getTargetOfImportSpecifier := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportSpecifier | BindingElement */ any, dontResolveAlias bool) Symbol {
		if isImportSpecifier(node) && moduleExportNameIsDefault(node.propertyName || node.name) {
			specifier := getModuleSpecifierForImportOrExport(node)
			moduleSymbol := specifier && resolveExternalModuleName(node, specifier)
			if moduleSymbol {
				return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
			}
		}
		var root /* TODO(TS-TO-GO) inferred type VariableDeclaration | ImportDeclaration | JSDocImportTag */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isBindingElement(node):
			root = getRootDeclaration(node) /* as VariableDeclaration */
		default:
			root = node.parent.parent.parent
		}
		commonJSPropertyAccess := getCommonJSPropertyAccess(root)
		resolved := getExternalModuleMember(root, commonJSPropertyAccess || node, dontResolveAlias)
		name := node.propertyName || node.name
		if commonJSPropertyAccess && resolved && isIdentifier(name) {
			return resolveSymbol(getPropertyOfType(getTypeOfSymbol(resolved), name.escapedText), dontResolveAlias)
		}
		markSymbolOfAliasDeclarationIfTypeOnly(node /*immediateTarget*/, nil, resolved /*overwriteEmpty*/, false)
		return resolved
	}
	getCommonJSPropertyAccess := func(node Node) *PropertyAccessExpression {
		if isVariableDeclaration(node) && node.initializer && isPropertyAccessExpression(node.initializer) {
			return node.initializer
		}
	}
	getTargetOfNamespaceExportDeclaration := func(node NamespaceExportDeclaration, dontResolveAlias bool) Symbol {
		if canHaveSymbol(node.parent) {
			resolved := resolveExternalModuleSymbol(node.parent.symbol, dontResolveAlias)
			markSymbolOfAliasDeclarationIfTypeOnly(node /*immediateTarget*/, nil, resolved /*overwriteEmpty*/, false)
			return resolved
		}
	}
	getTargetOfExportSpecifier := func(node ExportSpecifier, meaning SymbolFlags, dontResolveAlias bool) Symbol {
		name := node.propertyName || node.name
		if moduleExportNameIsDefault(name) {
			specifier := getModuleSpecifierForImportOrExport(node)
			moduleSymbol := specifier && resolveExternalModuleName(node, specifier)
			if moduleSymbol {
				return getTargetofModuleDefault(moduleSymbol, node, !!dontResolveAlias)
			}
		}
		var resolved Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.parent.parent.moduleSpecifier:
			resolved = getExternalModuleMember(node.parent.parent, node, dontResolveAlias)
		case name.kind == SyntaxKindStringLiteral:
			resolved = nil
		default:
			resolved = resolveEntityName(name, meaning /*ignoreErrors*/, false, dontResolveAlias)
		}
		markSymbolOfAliasDeclarationIfTypeOnly(node /*immediateTarget*/, nil, resolved /*overwriteEmpty*/, false)
		return resolved
	}
	getTargetOfExportAssignment := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ExportAssignment | BinaryExpression */ any, dontResolveAlias bool) Symbol {
		var expression Expression
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isExportAssignment(node):
			expression = node.expression
		default:
			expression = node.right
		}
		resolved := getTargetOfAliasLikeExpression(expression, dontResolveAlias)
		markSymbolOfAliasDeclarationIfTypeOnly(node /*immediateTarget*/, nil, resolved /*overwriteEmpty*/, false)
		return resolved
	}
	getTargetOfAliasLikeExpression := func(expression Expression, dontResolveAlias bool) Symbol {
		if isClassExpression(expression) {
			return checkExpressionCached(expression).symbol
		}
		if !isEntityName(expression) && !isEntityNameExpression(expression) {
			return nil
		}
		aliasLike := resolveEntityName(expression, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace /*ignoreErrors*/, true, dontResolveAlias)
		if aliasLike {
			return aliasLike
		}
		checkExpressionCached(expression)
		return getNodeLinks(expression).resolvedSymbol
	}
	getTargetOfAccessExpression := func(node AccessExpression, dontRecursivelyResolve bool) Symbol {
		if !(isBinaryExpression(node.parent) && node.parent.left == node && node.parent.operatorToken.kind == SyntaxKindEqualsToken) {
			return nil
		}
		return getTargetOfAliasLikeExpression(node.parent.right, dontRecursivelyResolve)
	}
	getTargetOfAliasDeclaration := func(node Declaration, dontRecursivelyResolve bool /*  = false */) Symbol {
		switch node.kind {
		case SyntaxKindImportEqualsDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindVariableDeclaration:
			return getTargetOfImportEqualsDeclaration(node /* as ImportEqualsDeclaration | VariableDeclaration */, dontRecursivelyResolve)
		case SyntaxKindImportClause:
			return getTargetOfImportClause(node /* as ImportClause */, dontRecursivelyResolve)
		case SyntaxKindNamespaceImport:
			return getTargetOfNamespaceImport(node /* as NamespaceImport */, dontRecursivelyResolve)
		case SyntaxKindNamespaceExport:
			return getTargetOfNamespaceExport(node /* as NamespaceExport */, dontRecursivelyResolve)
		case SyntaxKindImportSpecifier:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBindingElement:
			return getTargetOfImportSpecifier(node /* as ImportSpecifier | BindingElement */, dontRecursivelyResolve)
		case SyntaxKindExportSpecifier:
			return getTargetOfExportSpecifier(node /* as ExportSpecifier */, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, dontRecursivelyResolve)
		case SyntaxKindExportAssignment:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBinaryExpression:
			return getTargetOfExportAssignment(node /* as ExportAssignment | BinaryExpression */, dontRecursivelyResolve)
		case SyntaxKindNamespaceExportDeclaration:
			return getTargetOfNamespaceExportDeclaration(node /* as NamespaceExportDeclaration */, dontRecursivelyResolve)
		case SyntaxKindShorthandPropertyAssignment:
			return resolveEntityName((node /* as ShorthandPropertyAssignment */).name, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace /*ignoreErrors*/, true, dontRecursivelyResolve)
		case SyntaxKindPropertyAssignment:
			return getTargetOfAliasLikeExpression((node /* as PropertyAssignment */).initializer, dontRecursivelyResolve)
		case SyntaxKindElementAccessExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertyAccessExpression:
			return getTargetOfAccessExpression(node /* as AccessExpression */, dontRecursivelyResolve)
		default:
			return Debug.fail()
		}
	}
	/**
	 * Indicates that a symbol is an alias that does not merge with a local declaration.
	 * OR Is a JSContainer which may merge an alias with a local declaration
	 */
	isNonLocalAlias := func(symbol Symbol, excludes number /*  = SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace */) /* TODO(TS-TO-GO) TypeNode TypePredicate: symbol is Symbol */ any {
		if !symbol {
			return false
		}
		return (symbol.flags&(SymbolFlagsAlias|excludes)) == SymbolFlagsAlias || !!(symbol.flags&SymbolFlagsAlias && symbol.flags&SymbolFlagsAssignment)
	}
	/* TODO(TS-TO-GO): function resolveSymbol(symbol: Symbol, dontResolveAlias?: boolean): Symbol; */
	/* TODO(TS-TO-GO): function resolveSymbol(symbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined; */
	resolveSymbol := func(symbol Symbol, dontResolveAlias bool) Symbol {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case !dontResolveAlias && isNonLocalAlias(symbol):
			return resolveAlias(symbol)
		default:
			return symbol
		}
	}
	resolveAlias := func(symbol Symbol) Symbol {
		Debug.assert((symbol.flags&SymbolFlagsAlias) != 0, "Should only get Alias here.")
		links := getSymbolLinks(symbol)
		if !links.aliasTarget {
			links.aliasTarget = resolvingSymbol
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				return Debug.fail()
			}
			target := getTargetOfAliasDeclaration(node)
			if links.aliasTarget == resolvingSymbol {
				links.aliasTarget = target || unknownSymbol
			} else {
				error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol))
			}
		} else if links.aliasTarget == resolvingSymbol {
			links.aliasTarget = unknownSymbol
		}
		return links.aliasTarget
	}
	tryResolveAlias := func(symbol Symbol) Symbol {
		links := getSymbolLinks(symbol)
		if links.aliasTarget != resolvingSymbol {
			return resolveAlias(symbol)
		}
		return nil
	}
	/**
	 * Gets combined flags of a `symbol` and all alias targets it resolves to. `resolveAlias`
	 * is typically recursive over chains of aliases, but stops mid-chain if an alias is merged
	 * with another exported symbol, e.g.
	 * ```ts
	 * // a.ts
	 * export const a = 0;
	 * // b.ts
	 * export { a } from "./a";
	 * export type a = number;
	 * // c.ts
	 * import { a } from "./b";
	 * ```
	 * Calling `resolveAlias` on the `a` in c.ts would stop at the merged symbol exported
	 * from b.ts, even though there is still more alias to resolve. Consequently, if we were
	 * trying to determine if the `a` in c.ts has a value meaning, looking at the flags on
	 * the local symbol and on the symbol returned by `resolveAlias` is not enough.
	 * @returns SymbolFlags.All if `symbol` is an alias that ultimately resolves to `unknown`;
	 * combined flags of all alias targets otherwise.
	 */
	getSymbolFlags := func(symbol Symbol, excludeTypeOnlyMeanings bool, excludeLocalMeanings bool) SymbolFlags {
		typeOnlyDeclaration := excludeTypeOnlyMeanings && getTypeOnlyAliasDeclaration(symbol)
		typeOnlyDeclarationIsExportStar := typeOnlyDeclaration && isExportDeclaration(typeOnlyDeclaration)
		typeOnlyResolution := typeOnlyDeclaration && (__COND__(typeOnlyDeclarationIsExportStar, resolveExternalModuleName(typeOnlyDeclaration.moduleSpecifier, typeOnlyDeclaration.moduleSpecifier /*ignoreErrors*/, true), resolveAlias(typeOnlyDeclaration.symbol)))
		var typeOnlyExportStarTargets *SymbolTable
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case typeOnlyDeclarationIsExportStar && typeOnlyResolution:
			typeOnlyExportStarTargets = getExportsOfModule(typeOnlyResolution)
		default:
			typeOnlyExportStarTargets = nil
		}
		var flags SymbolFlags
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case excludeLocalMeanings:
			flags = SymbolFlagsNone
		default:
			flags = symbol.flags
		}
		var seenSymbols TODO
		for symbol.flags & SymbolFlagsAlias {
			target := getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol))
			if !typeOnlyDeclarationIsExportStar && target == typeOnlyResolution || typeOnlyExportStarTargets. /* TODO(TS-TO-GO): was ? */ get(target.escapedName) == target {
				break
			}
			if target == unknownSymbol {
				return SymbolFlagsAll
			}
			// Optimizations - try to avoid creating or adding to
			// `seenSymbols` if possible
			if target == symbol || seenSymbols. /* TODO(TS-TO-GO): was ? */ has(target) {
				break
			}
			if target.flags & SymbolFlagsAlias {
				if seenSymbols {
					seenSymbols.add(target)
				} else {
					seenSymbols = NewSet([]Symbol{symbol, target})
				}
			}
			flags |= target.flags
			symbol = target
		}
		return flags
	}
	/**
	 * Marks a symbol as type-only if its declaration is syntactically type-only.
	 * If it is not itself marked type-only, but resolves to a type-only alias
	 * somewhere in its resolution chain, save a reference to the type-only alias declaration
	 * so the alias _not_ marked type-only can be identified as _transitively_ type-only.
	 *
	 * This function is called on each alias declaration that could be type-only or resolve to
	 * another type-only alias during `resolveAlias`, so that later, when an alias is used in a
	 * JS-emitting expression, we can quickly determine if that symbol is effectively type-only
	 * and issue an error if so.
	 *
	 * @param aliasDeclaration The alias declaration not marked as type-only
	 * @param immediateTarget The symbol to which the alias declaration immediately resolves
	 * @param finalTarget The symbol to which the alias declaration ultimately resolves
	 * @param overwriteEmpty Checks `resolvesToSymbol` for type-only declarations even if `aliasDeclaration`
	 * has already been marked as not resolving to a type-only alias. Used when recursively resolving qualified
	 * names of import aliases, e.g. `import C = a.b.C`. If namespace `a` is not found to be type-only, the
	 * import declaration will initially be marked as not resolving to a type-only symbol. But, namespace `b`
	 * must still be checked for a type-only marker, overwriting the previous negative result if found.
	 */
	markSymbolOfAliasDeclarationIfTypeOnly := func(aliasDeclaration Declaration, immediateTarget Symbol, finalTarget Symbol, overwriteEmpty bool, exportStarDeclaration /* TODO(TS-TO-GO) TypeNode IntersectionType: ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */ any, exportStarName __String) bool {
		if !aliasDeclaration || isPropertyAccessExpression(aliasDeclaration) {
			return false
		}
		// If the declaration itself is type-only, mark it and return.
		// No need to check what it resolves to.
		sourceSymbol := getSymbolOfDeclaration(aliasDeclaration)
		if isTypeOnlyImportOrExportDeclaration(aliasDeclaration) {
			links := getSymbolLinks(sourceSymbol)
			links.typeOnlyDeclaration = aliasDeclaration
			return true
		}
		if exportStarDeclaration {
			links := getSymbolLinks(sourceSymbol)
			links.typeOnlyDeclaration = exportStarDeclaration
			if sourceSymbol.escapedName != exportStarName {
				links.typeOnlyExportStarName = exportStarName
			}
			return true
		}
		links := getSymbolLinks(sourceSymbol)
		return markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, immediateTarget, overwriteEmpty) || markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, finalTarget, overwriteEmpty)
	}
	markSymbolOfAliasDeclarationIfTypeOnlyWorker := func(aliasDeclarationLinks SymbolLinks, target Symbol, overwriteEmpty bool) bool {
		if target && (aliasDeclarationLinks.typeOnlyDeclaration == nil || overwriteEmpty && aliasDeclarationLinks.typeOnlyDeclaration == false) {
			exportSymbol := /* TODO(TS-TO-GO) Node BinaryExpression: target.exports?.get(InternalSymbolName.ExportEquals) ?? target */ TODO
			typeOnly := exportSymbol.declarations && find(exportSymbol.declarations, isTypeOnlyImportOrExportDeclaration)
			aliasDeclarationLinks.typeOnlyDeclaration = /* TODO(TS-TO-GO) Node BinaryExpression: typeOnly ?? getSymbolLinks(exportSymbol).typeOnlyDeclaration ?? false */ TODO
		}
		return !!aliasDeclarationLinks.typeOnlyDeclaration
	}
	/** Indicates that a symbol directly or indirectly resolves to a type-only import or export. */
	getTypeOnlyAliasDeclaration := func(symbol Symbol, include SymbolFlags) *TypeOnlyAliasDeclaration {
		if !(symbol.flags & SymbolFlagsAlias) {
			return nil
		}
		links := getSymbolLinks(symbol)
		if links.typeOnlyDeclaration == nil {
			// We need to set a WIP value here to prevent reentrancy during `getImmediateAliasedSymbol` which, paradoxically, can depend on this
			links.typeOnlyDeclaration = false
			resolved := resolveSymbol(symbol)
			// While usually the alias will have been marked during the pass by the full typecheck, we may still need to calculate the alias declaration now
			markSymbolOfAliasDeclarationIfTypeOnly(symbol.declarations[0], getDeclarationOfAliasSymbol(symbol) && getImmediateAliasedSymbol(symbol), resolved /*overwriteEmpty*/, true)
		}
		if include == nil {
			return links.typeOnlyDeclaration || nil
		}
		if links.typeOnlyDeclaration {
			var resolved Symbol
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case links.typeOnlyDeclaration.kind == SyntaxKindExportDeclaration:
				resolved = resolveSymbol(getExportsOfModule(links.typeOnlyDeclaration.symbol.parent).get(links.typeOnlyExportStarName || symbol.escapedName))
			default:
				resolved = resolveAlias(links.typeOnlyDeclaration.symbol)
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case getSymbolFlags(resolved) & include:
				return links.typeOnlyDeclaration
			default:
				return nil
			}
		}
		return nil
	}
	// This function is only for imports with entity names
	getSymbolOfPartOfRightHandSideOfImportEquals := func(entityName EntityName, dontResolveAlias bool) Symbol {
		// There are three things we might try to look for. In the following examples,
		// the search term is enclosed in |...|:
		//
		//     import a = |b|; // Namespace
		//     import a = |b.c|; // Value, type, namespace
		//     import a = |b.c|.d; // Namespace
		if entityName.kind == SyntaxKindIdentifier && isRightSideOfQualifiedNameOrPropertyAccess(entityName) {
			entityName = entityName.parent /* as QualifiedName */
		}
		// Check for case 1 and 3 in the above example
		if entityName.kind == SyntaxKindIdentifier || entityName.parent.kind == SyntaxKindQualifiedName {
			return resolveEntityName(entityName, SymbolFlagsNamespace /*ignoreErrors*/, false, dontResolveAlias)
		} else {
			// Case 2 in above example
			// entityName.kind could be a QualifiedName or a Missing identifier
			Debug.assert(entityName.parent.kind == SyntaxKindImportEqualsDeclaration)
			return resolveEntityName(entityName, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace /*ignoreErrors*/, false, dontResolveAlias)
		}
	}
	getFullyQualifiedName := func(symbol Symbol, containingLocation Node) string {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol.parent:
			return getFullyQualifiedName(symbol.parent, containingLocation) + "." + symbolToString(symbol)
		default:
			return symbolToString(symbol, containingLocation /*meaning*/, nil, SymbolFormatFlagsDoNotIncludeSymbolChain|SymbolFormatFlagsAllowAnyNodeKind)
		}
	}
	getContainingQualifiedNameNode := func(node QualifiedName) QualifiedName {
		for isQualifiedName(node.parent) {
			node = node.parent
		}
		return node
	}
	tryGetQualifiedNameAsValue := func(node QualifiedName) Symbol {
		var left /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | QualifiedName */ any = getFirstIdentifier(node)
		symbol := resolveName(left, left, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, true)
		if !symbol {
			return nil
		}
		for isQualifiedName(left.parent) {
			type_ := getTypeOfSymbol(symbol)
			symbol = getPropertyOfType(type_, left.parent.right.escapedText)
			if !symbol {
				return nil
			}
			left = left.parent
		}
		return symbol
	}
	/**
	 * Resolves a qualified name and any involved aliases.
	 */
	resolveEntityName := func(name EntityNameOrEntityNameExpression, meaning SymbolFlags, ignoreErrors bool, dontResolveAlias bool, location Node) Symbol {
		if nodeIsMissing(name) {
			return nil
		}
		namespaceMeaning := SymbolFlagsNamespace | (__COND__(isInJSFile(name), meaning&SymbolFlagsValue, 0))
		var symbol Symbol
		if name.kind == SyntaxKindIdentifier {
			var message DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case meaning == namespaceMeaning || nodeIsSynthesized(name):
				message = Diagnostics.Cannot_find_namespace_0
			default:
				message = getCannotFindNameDiagnosticForName(getFirstIdentifier(name))
			}
			var symbolFromJSPrototype Symbol
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isInJSFile(name) && !nodeIsSynthesized(name):
				symbolFromJSPrototype = resolveEntityNameFromAssignmentDeclaration(name, meaning)
			default:
				symbolFromJSPrototype = nil
			}
			symbol = getMergedSymbol(resolveName(location || name, name, meaning, __COND__(ignoreErrors || symbolFromJSPrototype, nil, message) /*isUse*/, true /*excludeGlobals*/, false))
			if !symbol {
				return getMergedSymbol(symbolFromJSPrototype)
			}
		} else if name.kind == SyntaxKindQualifiedName || name.kind == SyntaxKindPropertyAccessExpression {
			var left /* TODO(TS-TO-GO) inferred type Identifier | QualifiedName | PropertyAccessEntityNameExpression */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case name.kind == SyntaxKindQualifiedName:
				left = name.left
			default:
				left = name.expression
			}
			var right Identifier
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case name.kind == SyntaxKindQualifiedName:
				right = name.right
			default:
				right = name.name
			}
			namespace := resolveEntityName(left, namespaceMeaning, ignoreErrors /*dontResolveAlias*/, false, location)
			if !namespace || nodeIsMissing(right) {
				return nil
			} else if namespace == unknownSymbol {
				return namespace
			}
			if namespace.valueDeclaration && isInJSFile(namespace.valueDeclaration) && getEmitModuleResolutionKind(compilerOptions) != ModuleResolutionKindBundler && isVariableDeclaration(namespace.valueDeclaration) && namespace.valueDeclaration.initializer && isCommonJsRequire(namespace.valueDeclaration.initializer) {
				moduleName := (namespace.valueDeclaration.initializer /* as CallExpression */).arguments[0] /* as StringLiteral */
				moduleSym := resolveExternalModuleName(moduleName, moduleName)
				if moduleSym {
					resolvedModuleSymbol := resolveExternalModuleSymbol(moduleSym)
					if resolvedModuleSymbol {
						namespace = resolvedModuleSymbol
					}
				}
			}
			symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, meaning))
			if !symbol && (namespace.flags & SymbolFlagsAlias) {
				// `namespace` can be resolved further if there was a symbol merge with a re-export
				symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(resolveAlias(namespace)), right.escapedText, meaning))
			}
			if !symbol {
				if !ignoreErrors {
					namespaceName := getFullyQualifiedName(namespace)
					declarationName := declarationNameToString(right)
					suggestionForNonexistentModule := getSuggestedSymbolForNonexistentModule(right, namespace)
					if suggestionForNonexistentModule {
						error(right, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, namespaceName, declarationName, symbolToString(suggestionForNonexistentModule))
						return nil
					}
					containingQualifiedName := isQualifiedName(name) && getContainingQualifiedNameNode(name)
					canSuggestTypeof := globalObjectType && (meaning & SymbolFlagsType) && containingQualifiedName && !isTypeOfExpression(containingQualifiedName.parent) && tryGetQualifiedNameAsValue(containingQualifiedName)
					if canSuggestTypeof {
						error(containingQualifiedName, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, entityNameToString(containingQualifiedName))
						return nil
					}
					if meaning&SymbolFlagsNamespace && isQualifiedName(name.parent) {
						exportedTypeSymbol := getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, SymbolFlagsType))
						if exportedTypeSymbol {
							error(name.parent.right, Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, symbolToString(exportedTypeSymbol), unescapeLeadingUnderscores(name.parent.right.escapedText))
							return nil
						}
					}
					error(right, Diagnostics.Namespace_0_has_no_exported_member_1, namespaceName, declarationName)
				}
				return nil
			}
		} else {
			Debug.assertNever(name, "Unknown entity name kind.")
		}
		if !nodeIsSynthesized(name) && isEntityName(name) && (symbol.flags&SymbolFlagsAlias || name.parent.kind == SyntaxKindExportAssignment) {
			markSymbolOfAliasDeclarationIfTypeOnly(getAliasDeclarationFromName(name), symbol /*finalTarget*/, nil /*overwriteEmpty*/, true)
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case (symbol.flags & meaning) || dontResolveAlias:
			return symbol
		default:
			return resolveAlias(symbol)
		}
	}
	/**
	 * 1. For prototype-property methods like `A.prototype.m = function () ...`, try to resolve names in the scope of `A` too.
	 * Note that prototype-property assignment to locations outside the current file (eg globals) doesn't work, so
	 * name resolution won't work either.
	 * 2. For property assignments like `{ x: function f () { } }`, try to resolve names in the scope of `f` too.
	 */
	resolveEntityNameFromAssignmentDeclaration := func(name Identifier, meaning SymbolFlags) Symbol {
		if isJSDocTypeReference(name.parent) {
			secondaryLocation := getAssignmentDeclarationLocation(name.parent)
			if secondaryLocation {
				return resolveName(secondaryLocation, name, meaning /*nameNotFoundMessage*/, nil /*isUse*/, true)
			}
		}
	}
	getAssignmentDeclarationLocation := func(node TypeReferenceNode) Node {
		typeAlias := findAncestor(node, func(node Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !(isJSDocNode(node) || node.flags&NodeFlagsJSDoc):
				return "quit"
			default:
				return isJSDocTypeAlias(node)
			}
		})
		if typeAlias {
			return
		}
		host := getJSDocHost(node)
		if host && isExpressionStatement(host) && isPrototypePropertyAssignment(host.expression) {
			// /** @param {K} p */ X.prototype.m = function () { } <-- look for K on X's declaration
			symbol := getSymbolOfDeclaration(host.expression.left)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		if host && isFunctionExpression(host) && isPrototypePropertyAssignment(host.parent) && isExpressionStatement(host.parent.parent) {
			// X.prototype.m = /** @param {K} p */ function () { } <-- look for K on X's declaration
			symbol := getSymbolOfDeclaration(host.parent.left)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		if host && (isObjectLiteralMethod(host) || isPropertyAssignment(host)) && isBinaryExpression(host.parent.parent) && getAssignmentDeclarationKind(host.parent.parent) == AssignmentDeclarationKindPrototype {
			// X.prototype = { /** @param {K} p */m() { } } <-- look for K on X's declaration
			symbol := getSymbolOfDeclaration(host.parent.parent.left /* as BindableStaticNameExpression */)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		sig := getEffectiveJSDocHost(node)
		if sig && isFunctionLike(sig) {
			symbol := getSymbolOfDeclaration(sig)
			return symbol && symbol.valueDeclaration
		}
	}
	getDeclarationOfJSPrototypeContainer := func(symbol Symbol) * /* TODO(TS-TO-GO) inferred type Expression | Declaration */ any {
		decl := symbol.parent.valueDeclaration
		if !decl {
			return nil
		}
		var initializer Expression
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isAssignmentDeclaration(decl):
			initializer = getAssignedExpandoInitializer(decl)
		case hasOnlyExpressionInitializer(decl):
			initializer = getDeclaredExpandoInitializer(decl)
		default:
			initializer = nil
		}
		return initializer || decl
	}
	/**
	 * Get the real symbol of a declaration with an expando initializer.
	 *
	 * Normally, declarations have an associated symbol, but when a declaration has an expando
	 * initializer, the expando's symbol is the one that has all the members merged into it.
	 */
	getExpandoSymbol := func(symbol Symbol) Symbol {
		decl := symbol.valueDeclaration
		if !decl || !isInJSFile(decl) || symbol.flags&SymbolFlagsTypeAlias || getExpandoInitializer(decl /*isPrototypeAssignment*/, false) {
			return nil
		}
		var init Expression
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isVariableDeclaration(decl):
			init = getDeclaredExpandoInitializer(decl)
		default:
			init = getAssignedExpandoInitializer(decl)
		}
		if init {
			initSymbol := getSymbolOfNode(init)
			if initSymbol {
				return mergeJSSymbols(initSymbol, symbol)
			}
		}
	}
	resolveExternalModuleName := func(location Node, moduleReferenceExpression Expression, ignoreErrors bool) Symbol {
		isClassic := getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindClassic
		var errorMessage DiagnosticMessage
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isClassic:
			errorMessage = Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option
		default:
			errorMessage = Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations
		}
		return resolveExternalModuleNameWorker(location, moduleReferenceExpression, __COND__(ignoreErrors, nil, errorMessage), ignoreErrors)
	}
	resolveExternalModuleNameWorker := func(location Node, moduleReferenceExpression Expression, moduleNotFoundError *DiagnosticMessage, ignoreErrors bool /*  = false */, isForAugmentation bool /*  = false */) Symbol {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isStringLiteralLike(moduleReferenceExpression):
			return resolveExternalModule(location, moduleReferenceExpression.text, moduleNotFoundError, __COND__(!ignoreErrors, moduleReferenceExpression, nil), isForAugmentation)
		default:
			return nil
		}
	}
	resolveExternalModule := func(location Node, moduleReference string, moduleNotFoundError *DiagnosticMessage, errorNode Node, isForAugmentation bool /*  = false */) Symbol {
		if errorNode && startsWith(moduleReference, "@types/") {
			diag := Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1
			withoutAtTypePrefix := removePrefix(moduleReference, "@types/")
			error(errorNode, diag, withoutAtTypePrefix, moduleReference)
		}
		ambientModule := tryFindAmbientModule(moduleReference /*withAugmentations*/, true)
		if ambientModule {
			return ambientModule
		}
		currentSourceFile := getSourceFileOfNode(location)
		var contextSpecifier Expression
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isStringLiteralLike(location):
			contextSpecifier = location
		default:
			contextSpecifier = (__COND__(isModuleDeclaration(location), location, __COND__(location.parent && isModuleDeclaration(location.parent) && location.parent.name == location, location.parent, nil))). /* TODO(TS-TO-GO): was ? */ name || (__COND__(isLiteralImportTypeNode(location), location, nil)). /* TODO(TS-TO-GO): was ? */ argument.literal || (__COND__(isInJSFile(location) && isJSDocImportTag(location), location.moduleSpecifier, nil)) || (__COND__(isVariableDeclaration(location) && location.initializer && isRequireCall(location.initializer /*requireStringLiteralLikeArgument*/, true), location.initializer.arguments[0], nil)) || findAncestor(location, isImportCall). /* TODO(TS-TO-GO): was ? */ arguments[0] || findAncestor(location, isImportDeclaration). /* TODO(TS-TO-GO): was ? */ moduleSpecifier || findAncestor(location, isExternalModuleImportEqualsDeclaration). /* TODO(TS-TO-GO): was ? */ moduleReference.expression || findAncestor(location, isExportDeclaration). /* TODO(TS-TO-GO): was ? */ moduleSpecifier
		}
		var mode ResolutionMode
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case contextSpecifier && isStringLiteralLike(contextSpecifier):
			mode = host.getModeForUsageLocation(currentSourceFile, contextSpecifier)
		default:
			mode = host.getDefaultResolutionModeForFile(currentSourceFile)
		}
		moduleResolutionKind := getEmitModuleResolutionKind(compilerOptions)
		resolvedModule := host.getResolvedModule(currentSourceFile, moduleReference, mode). /* TODO(TS-TO-GO): was ? */ resolvedModule
		resolutionDiagnostic := errorNode && resolvedModule && getResolutionDiagnostic(compilerOptions, resolvedModule, currentSourceFile)
		sourceFile := resolvedModule && (!resolutionDiagnostic || resolutionDiagnostic == Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set) && host.getSourceFile(resolvedModule.resolvedFileName)
		if sourceFile {
			// If there's a resolutionDiagnostic we need to report it even if a sourceFile is found.
			if resolutionDiagnostic {
				error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName)
			}
			if resolvedModule.resolvedUsingTsExtension && isDeclarationFileName(moduleReference) {
				importOrExport := findAncestor(location, isImportDeclaration). /* TODO(TS-TO-GO): was ? */ importClause || findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration))
				if errorNode && importOrExport && !importOrExport.isTypeOnly || findAncestor(location, isImportCall) {
					error(errorNode, Diagnostics.A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_file_0_instead, getSuggestedImportSource(Debug.checkDefined(tryExtractTSExtension(moduleReference))))
				}
			} else if resolvedModule.resolvedUsingTsExtension && !shouldAllowImportingTsExtension(compilerOptions, currentSourceFile.fileName) {
				importOrExport := findAncestor(location, isImportDeclaration). /* TODO(TS-TO-GO): was ? */ importClause || findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration))
				if errorNode && !(importOrExport. /* TODO(TS-TO-GO): was ? */ isTypeOnly || findAncestor(location, isImportTypeNode)) {
					tsExtension := Debug.checkDefined(tryExtractTSExtension(moduleReference))
					error(errorNode, Diagnostics.An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled, tsExtension)
				}
			}
			if sourceFile.symbol {
				if errorNode && resolvedModule.isExternalLibraryImport && !resolutionExtensionIsTSOrJson(resolvedModule.extension) {
					errorOnImplicitAnyModule(false, errorNode, currentSourceFile, mode, resolvedModule, moduleReference)
				}
				if errorNode && (moduleResolutionKind == ModuleResolutionKindNode16 || moduleResolutionKind == ModuleResolutionKindNodeNext) {
					isSyncImport := (currentSourceFile.impliedNodeFormat == ModuleKindCommonJS && !findAncestor(location, isImportCall)) || !!findAncestor(location, isImportEqualsDeclaration)
					overrideHost := findAncestor(location, func(l Node) bool {
						return isImportTypeNode(l) || isExportDeclaration(l) || isImportDeclaration(l) || isJSDocImportTag(l)
					})
					// An override clause will take effect for type-only imports and import types, and allows importing the types across formats, regardless of
					// normal mode restrictions
					if isSyncImport && sourceFile.impliedNodeFormat == ModuleKindESNext && !hasResolutionModeOverride(overrideHost) {
						if findAncestor(location, isImportEqualsDeclaration) {
							// ImportEquals in a ESM file resolving to another ESM file
							error(errorNode, Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead, moduleReference)
						} else {
							// CJS file resolving to an ESM file
							var diagnosticDetails TODO
							ext := tryGetExtensionFromPath(currentSourceFile.fileName)
							if ext == ExtensionTs || ext == ExtensionJs || ext == ExtensionTsx || ext == ExtensionJsx {
								diagnosticDetails = createModeMismatchDetails(currentSourceFile)
							}
							var message DiagnosticMessage
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case overrideHost. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindImportDeclaration && overrideHost.importClause. /* TODO(TS-TO-GO): was ? */ isTypeOnly:
								message = Diagnostics.Type_only_import_of_an_ECMAScript_module_from_a_CommonJS_module_must_have_a_resolution_mode_attribute
							case overrideHost. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindImportType:
								message = Diagnostics.Type_import_of_an_ECMAScript_module_from_a_CommonJS_module_must_have_a_resolution_mode_attribute
							default:
								message = Diagnostics.The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead
							}
							diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chainDiagnosticMessages(diagnosticDetails, message, moduleReference)))
						}
					}
				}
				// merged symbol is module declaration symbol combined with all augmentations
				return getMergedSymbol(sourceFile.symbol)
			}
			if errorNode && moduleNotFoundError && !isSideEffectImport(errorNode) {
				// report errors only if it was requested
				error(errorNode, Diagnostics.File_0_is_not_a_module, sourceFile.fileName)
			}
			return nil
		}
		if patternAmbientModules {
			pattern := findBestPatternMatch(patternAmbientModules, func(_ PatternAmbientModule) Pattern {
				return _.pattern
			}, moduleReference)
			if pattern {
				// If the module reference matched a pattern ambient module ('*.foo') but there's also a
				// module augmentation by the specific name requested ('a.foo'), we store the merged symbol
				// by the augmentation name ('a.foo'), because asking for *.foo should not give you exports
				// from a.foo.
				augmentation := patternAmbientModuleAugmentations && patternAmbientModuleAugmentations.get(moduleReference)
				if augmentation {
					return getMergedSymbol(augmentation)
				}
				return getMergedSymbol(pattern.symbol)
			}
		}
		if !errorNode {
			return nil
		}
		// May be an untyped module. If so, ignore resolutionDiagnostic.
		if resolvedModule && !resolutionExtensionIsTSOrJson(resolvedModule.extension) && resolutionDiagnostic == nil || resolutionDiagnostic == Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type {
			if isForAugmentation {
				diag := Diagnostics.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented
				error(errorNode, diag, moduleReference, resolvedModule.resolvedFileName)
			} else {
				errorOnImplicitAnyModule(noImplicitAny && !!moduleNotFoundError, errorNode, currentSourceFile, mode, resolvedModule, moduleReference)
			}
			// Failed imports and untyped modules are both treated in an untyped manner; only difference is whether we give a diagnostic first.
			return nil
		}
		if moduleNotFoundError {
			// See if this was possibly a projectReference redirect
			if resolvedModule {
				redirect := host.getProjectReferenceRedirect(resolvedModule.resolvedFileName)
				if redirect {
					error(errorNode, Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect, resolvedModule.resolvedFileName)
					return nil
				}
			}
			if resolutionDiagnostic {
				error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName)
			} else {
				isExtensionlessRelativePathImport := pathIsRelative(moduleReference) && !hasExtension(moduleReference)
				resolutionIsNode16OrNext := moduleResolutionKind == ModuleResolutionKindNode16 || moduleResolutionKind == ModuleResolutionKindNodeNext
				if !getResolveJsonModule(compilerOptions) && fileExtensionIs(moduleReference, ExtensionJson) && moduleResolutionKind != ModuleResolutionKindClassic && hasJsonModuleEmitEnabled(compilerOptions) {
					error(errorNode, Diagnostics.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension, moduleReference)
				} else if mode == ModuleKindESNext && resolutionIsNode16OrNext && isExtensionlessRelativePathImport {
					absoluteRef := getNormalizedAbsolutePath(moduleReference, getDirectoryPath(currentSourceFile.path))
					suggestedExt := suggestedExtensions.find(func(TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [string, string] */ any) bool {
						return host.fileExists(absoluteRef + actualExt)
					})[1]
					if suggestedExt {
						error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0, moduleReference+suggestedExt)
					} else {
						error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path)
					}
				} else {
					if host.getResolvedModule(currentSourceFile, moduleReference, mode). /* TODO(TS-TO-GO): was ? */ alternateResult {
						errorInfo := createModuleNotFoundChain(currentSourceFile, host, moduleReference, mode, moduleReference)
						errorOrSuggestion(true, errorNode, chainDiagnosticMessages(errorInfo, moduleNotFoundError, moduleReference))
					} else {
						error(errorNode, moduleNotFoundError, moduleReference)
					}
				}
			}
		}
		return nil
		getSuggestedImportSource := func(tsExtension string) string {
			importSourceWithoutExtension := removeExtension(moduleReference, tsExtension)
			/**
			 * Direct users to import source with .js extension if outputting an ES module.
			 * @see https://github.com/microsoft/TypeScript/issues/42151
			 */
			if emitModuleKindIsNonNodeESM(moduleKind) || mode == ModuleKindESNext {
				preferTs := isDeclarationFileName(moduleReference) && shouldAllowImportingTsExtension(compilerOptions)
				var ext /* TODO(TS-TO-GO) inferred type ".mts" | ".mjs" | ".ts" | ".js" | ".cts" | ".cjs" */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case tsExtension == ExtensionMts || tsExtension == ExtensionDmts:
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case preferTs:
						ext = ".mts"
					default:
						ext = ".mjs"
					}
				case tsExtension == ExtensionCts || tsExtension == ExtensionDmts:
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case preferTs:
						ext = ".cts"
					default:
						ext = ".cjs"
					}
				case preferTs:
					ext = ".ts"
				default:
					ext = ".js"
				}
				return importSourceWithoutExtension + ext
			}
			return importSourceWithoutExtension
		}
	}
	errorOnImplicitAnyModule := func(isError bool, errorNode Node, sourceFile SourceFile, mode ResolutionMode, TODO_IDENTIFIER ResolvedModuleFull, moduleReference string) {
		if isSideEffectImport(errorNode) {
			return
		}
		var errorInfo *DiagnosticMessageChain
		if !isExternalModuleNameRelative(moduleReference) && packageId {
			errorInfo = createModuleNotFoundChain(sourceFile, host, moduleReference, mode, packageId.name)
		}
		errorOrSuggestion(isError, errorNode, chainDiagnosticMessages(errorInfo, Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type, moduleReference, resolvedFileName))
	}
	/* TODO(TS-TO-GO): function resolveExternalModuleSymbol(moduleSymbol: Symbol, dontResolveAlias?: boolean): Symbol; */
	/* TODO(TS-TO-GO): function resolveExternalModuleSymbol(moduleSymbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined; */
	resolveExternalModuleSymbol := func(moduleSymbol Symbol, dontResolveAlias bool) Symbol {
		if moduleSymbol. /* TODO(TS-TO-GO): was ? */ exports {
			exportEquals := resolveSymbol(moduleSymbol.exports.get(InternalSymbolNameExportEquals), dontResolveAlias)
			exported := getCommonJsExportEquals(getMergedSymbol(exportEquals), getMergedSymbol(moduleSymbol))
			return getMergedSymbol(exported) || moduleSymbol
		}
		return nil
	}
	getCommonJsExportEquals := func(exported Symbol, moduleSymbol Symbol) Symbol {
		if !exported || exported == unknownSymbol || exported == moduleSymbol || moduleSymbol.exports.size == 1 || exported.flags&SymbolFlagsAlias {
			return exported
		}
		links := getSymbolLinks(exported)
		if links.cjsExportMerged {
			return links.cjsExportMerged
		}
		var merged Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case exported.flags & SymbolFlagsTransient:
			merged = exported
		default:
			merged = cloneSymbol(exported)
		}
		merged.flags = merged.flags | SymbolFlagsValueModule
		if merged.exports == nil {
			merged.exports = createSymbolTable()
		}
		moduleSymbol.exports.forEach(func(s Symbol, name __String) {
			if name == InternalSymbolNameExportEquals {
				return
			}
			merged.exports.set(name, __COND__(merged.exports.has(name), mergeSymbol(merged.exports.get(name), s), s))
		})
		if merged == exported {
			// We just mutated a symbol, reset any cached links we may have already set
			// (Notably required to make late bound members appear)
			getSymbolLinks(merged).resolvedExports = nil
			getSymbolLinks(merged).resolvedMembers = nil
		}
		getSymbolLinks(merged).cjsExportMerged = merged
		links.cjsExportMerged = merged
		return links.cjsExportMerged
	}
	// An external module with an 'export =' declaration may be referenced as an ES6 module provided the 'export ='
	// references a symbol that is at least declared as a module or a variable. The target of the 'export =' may
	// combine other declarations with the module or variable (e.g. a class/module, function/module, interface/variable).
	resolveESModuleSymbol := func(moduleSymbol Symbol, referencingLocation Node, dontResolveAlias bool, suppressInteropError bool) Symbol {
		symbol := resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias)
		if !dontResolveAlias && symbol {
			if !suppressInteropError && !(symbol.flags & (SymbolFlagsModule | SymbolFlagsVariable)) && !getDeclarationOfKind(symbol, SyntaxKindSourceFile) {
				var compilerOptionName /* TODO(TS-TO-GO) inferred type "allowSyntheticDefaultImports" | "esModuleInterop" */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case moduleKind >= ModuleKindES2015:
					compilerOptionName = "allowSyntheticDefaultImports"
				default:
					compilerOptionName = "esModuleInterop"
				}
				error(referencingLocation, Diagnostics.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export, compilerOptionName)
				return symbol
			}
			referenceParent := referencingLocation.parent
			if (isImportDeclaration(referenceParent) && getNamespaceDeclarationNode(referenceParent)) || isImportCall(referenceParent) {
				var reference Expression
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isImportCall(referenceParent):
					reference = referenceParent.arguments[0]
				default:
					reference = referenceParent.moduleSpecifier
				}
				type_ := getTypeOfSymbol(symbol)
				defaultOnlyType := getTypeWithSyntheticDefaultOnly(type_, symbol, moduleSymbol, reference)
				if defaultOnlyType {
					return cloneTypeAsModuleType(symbol, defaultOnlyType, referenceParent)
				}
				targetFile := moduleSymbol. /* TODO(TS-TO-GO): was ? */ declarations. /* TODO(TS-TO-GO): was ? */ find(isSourceFile)
				isEsmCjsRef := targetFile && isESMFormatImportImportingCommonjsFormatFile(getEmitSyntaxForModuleSpecifierExpression(reference), host.getImpliedNodeFormatForEmit(targetFile))
				if getESModuleInterop(compilerOptions) || isEsmCjsRef {
					sigs := getSignaturesOfStructuredType(type_, SignatureKindCall)
					if !sigs || !sigs.length {
						sigs = getSignaturesOfStructuredType(type_, SignatureKindConstruct)
					}
					if (sigs && sigs.length) || getPropertyOfType(type_, InternalSymbolNameDefault /*skipObjectFunctionPropertyAugment*/, true) || isEsmCjsRef {
						var moduleType Type
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case type_.flags & TypeFlagsStructuredType:
							moduleType = getTypeWithSyntheticDefaultImportType(type_, symbol, moduleSymbol, reference)
						default:
							moduleType = createDefaultPropertyWrapperForModule(symbol, symbol.parent)
						}
						return cloneTypeAsModuleType(symbol, moduleType, referenceParent)
					}
				}
			}
		}
		return symbol
	}
	/**
	 * Create a new symbol which has the module's type less the call and construct signatures
	 */
	cloneTypeAsModuleType := func(symbol Symbol, moduleType Type, referenceParent /* TODO(TS-TO-GO) TypeNode UnionType: ImportDeclaration | ImportCall */ any) TransientSymbol {
		result := createSymbol(symbol.flags, symbol.escapedName)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol.declarations:
			result.declarations = symbol.declarations.slice()
		default:
			result.declarations = []never{}
		}
		result.parent = symbol.parent
		result.links.target = symbol
		result.links.originatingImport = referenceParent
		if symbol.valueDeclaration {
			result.valueDeclaration = symbol.valueDeclaration
		}
		if symbol.constEnumOnlyModule {
			result.constEnumOnlyModule = true
		}
		if symbol.members {
			result.members = NewMap(symbol.members)
		}
		if symbol.exports {
			result.exports = NewMap(symbol.exports)
		}
		resolvedModuleType := resolveStructuredTypeMembers(moduleType /* as StructuredType */)
		// Should already be resolved from the signature checks above
		result.links.type_ = createAnonymousType(result, resolvedModuleType.members, emptyArray, emptyArray, resolvedModuleType.indexInfos)
		return result
	}
	hasExportAssignmentSymbol := func(moduleSymbol Symbol) bool {
		return moduleSymbol.exports.get(InternalSymbolNameExportEquals) != nil
	}
	getExportsOfModuleAsArray := func(moduleSymbol Symbol) []Symbol {
		return symbolsToArray(getExportsOfModule(moduleSymbol))
	}
	getExportsAndPropertiesOfModule := func(moduleSymbol Symbol) []Symbol {
		exports := getExportsOfModuleAsArray(moduleSymbol)
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if exportEquals != moduleSymbol {
			type_ := getTypeOfSymbol(exportEquals)
			if shouldTreatPropertiesOfExternalModuleAsExports(type_) {
				addRange(exports, getPropertiesOfType(type_))
			}
		}
		return exports
	}
	forEachExportAndPropertyOfModule := func(moduleSymbol Symbol, cb func(symbol Symbol, key __String)) {
		exports := getExportsOfModule(moduleSymbol)
		exports.forEach(func(symbol Symbol, key __String) {
			if !isReservedMemberName(key) {
				cb(symbol, key)
			}
		})
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if exportEquals != moduleSymbol {
			type_ := getTypeOfSymbol(exportEquals)
			if shouldTreatPropertiesOfExternalModuleAsExports(type_) {
				forEachPropertyOfType(type_, func(symbol Symbol, escapedName __String) {
					cb(symbol, escapedName)
				})
			}
		}
	}
	tryGetMemberInModuleExports := func(memberName __String, moduleSymbol Symbol) Symbol {
		symbolTable := getExportsOfModule(moduleSymbol)
		if symbolTable {
			return symbolTable.get(memberName)
		}
	}
	tryGetMemberInModuleExportsAndProperties := func(memberName __String, moduleSymbol Symbol) Symbol {
		symbol := tryGetMemberInModuleExports(memberName, moduleSymbol)
		if symbol {
			return symbol
		}
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if exportEquals == moduleSymbol {
			return nil
		}
		type_ := getTypeOfSymbol(exportEquals)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case shouldTreatPropertiesOfExternalModuleAsExports(type_):
			return getPropertyOfType(type_, memberName)
		default:
			return nil
		}
	}
	shouldTreatPropertiesOfExternalModuleAsExports := func(resolvedExternalModuleType Type) bool {
		return !(resolvedExternalModuleType.flags&TypeFlagsPrimitive || getObjectFlags(resolvedExternalModuleType)&ObjectFlagsClass || isArrayType(resolvedExternalModuleType) || isTupleType(resolvedExternalModuleType))
	}
	getExportsOfSymbol := func(symbol Symbol) SymbolTable {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol.flags & SymbolFlagsLateBindingContainer:
			return getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKindresolvedExports)
		case symbol.flags & SymbolFlagsModule:
			return getExportsOfModule(symbol)
		default:
			return symbol.exports || emptySymbols
		}
	}
	getExportsOfModule := func(moduleSymbol Symbol) SymbolTable {
		links := getSymbolLinks(moduleSymbol)
		if !links.resolvedExports {
			TODO_IDENTIFIER := getExportsOfModuleWorker(moduleSymbol)
			links.resolvedExports = exports
			links.typeOnlyExportStarMap = typeOnlyExportStarMap
		}
		return links.resolvedExports
	}
	type ExportCollisionTracker struct {
		specifierText        string
		exportsWithDuplicate []ExportDeclaration
	}
	type ExportCollisionTrackerTable Map[__String, ExportCollisionTracker]
	/**
	 * Extends one symbol table with another while collecting information on name collisions for error message generation into the `lookupTable` argument
	 * Not passing `lookupTable` and `exportNode` disables this collection, and just extends the tables
	 */
	extendExportSymbols := func(target SymbolTable, source *SymbolTable, lookupTable ExportCollisionTrackerTable, exportNode ExportDeclaration) {
		if !source {
			return
		}
		source.forEach(func(sourceSymbol Symbol, id __String) {
			if id == InternalSymbolNameDefault {
				return
			}
			targetSymbol := target.get(id)
			if !targetSymbol {
				target.set(id, sourceSymbol)
				if lookupTable && exportNode {
					lookupTable.set(id, map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"specifierText": getTextOfNode(exportNode.moduleSpecifier),
					})
				}
			} else if lookupTable && exportNode && targetSymbol && resolveSymbol(targetSymbol) != resolveSymbol(sourceSymbol) {
				collisionTracker := lookupTable.get(id)
				if !collisionTracker.exportsWithDuplicate {
					collisionTracker.exportsWithDuplicate = []ExportDeclaration{exportNode}
				} else {
					collisionTracker.exportsWithDuplicate.push(exportNode)
				}
			}
		})
	}
	getExportsOfModuleWorker := func(moduleSymbol Symbol) /* TODO(TS-TO-GO) inferred type { exports: SymbolTable; typeOnlyExportStarMap: Map<__String, ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; }> | undefined; } */ any {
		var visitedSymbols []Symbol = []never{}
		var typeOnlyExportStarMap *Map[__String /* TODO(TS-TO-GO) TypeNode IntersectionType: ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */, any]
		nonTypeOnlyNames := NewSet[__String]()
		// A module defined by an 'export=' consists of one export that needs to be resolved
		moduleSymbol = resolveExternalModuleSymbol(moduleSymbol)
		exports := visit(moduleSymbol) || emptySymbols
		if typeOnlyExportStarMap {
			nonTypeOnlyNames.forEach(func(name __String) bool {
				return typeOnlyExportStarMap.delete(name)
			})
		}
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"exports":               exports,
			"typeOnlyExportStarMap": typeOnlyExportStarMap,
		}
		// The ES6 spec permits export * declarations in a module to circularly reference the module itself. For example,
		// module 'a' can 'export * from "b"' and 'b' can 'export * from "a"' without error.
		visit := func(symbol Symbol, exportStar ExportDeclaration, isTypeOnly bool) *SymbolTable {
			if !isTypeOnly && symbol. /* TODO(TS-TO-GO): was ? */ exports {
				// Add non-type-only names before checking if we've visited this module,
				// because we might have visited it via an 'export type *', and visiting
				// again with 'export *' will override the type-onlyness of its exports.
				symbol.exports.forEach(func(_ Symbol, name __String) Set[__String] {
					return nonTypeOnlyNames.add(name)
				})
			}
			if !(symbol && symbol.exports && pushIfUnique(visitedSymbols, symbol)) {
				return
			}
			symbols := NewMap(symbol.exports)
			// All export * declarations are collected in an __export symbol by the binder
			exportStars := symbol.exports.get(InternalSymbolNameExportStar)
			if exportStars {
				nestedSymbols := createSymbolTable()
				var lookupTable ExportCollisionTrackerTable = NewMap()
				if exportStars.declarations {
					for _, node := range exportStars.declarations {
						resolvedModule := resolveExternalModuleName(node, (node /* as ExportDeclaration */).moduleSpecifier)
						exportedSymbols := visit(resolvedModule, node /* as ExportDeclaration */, isTypeOnly || (node /* as ExportDeclaration */).isTypeOnly)
						extendExportSymbols(nestedSymbols, exportedSymbols, lookupTable, node /* as ExportDeclaration */)
					}
				}
				lookupTable.forEach(func(TODO_IDENTIFIER ExportCollisionTracker, id __String) {
					// It's not an error if the file with multiple `export *`s with duplicate names exports a member with that name itself
					if id == "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id) {
						return
					}
					for _, node := range exportsWithDuplicate {
						diagnostics.add(createDiagnosticForNode(node, Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity, lookupTable.get(id).specifierText, unescapeLeadingUnderscores(id)))
					}
				})
				extendExportSymbols(symbols, nestedSymbols)
			}
			if exportStar. /* TODO(TS-TO-GO): was ? */ isTypeOnly {
				/* TODO(TS-TO-GO) Node BinaryExpression: typeOnlyExportStarMap ??= new Map() */ TODO
				symbols.forEach(func(_ Symbol, escapedName __String) Map[__String /* TODO(TS-TO-GO) inferred type ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */, any] {
					return typeOnlyExportStarMap.set(escapedName, exportStar /* as ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */)
				})
			}
			return symbols
		}
	}
	/* TODO(TS-TO-GO): function getMergedSymbol(symbol: Symbol): Symbol; */
	/* TODO(TS-TO-GO): function getMergedSymbol(symbol: Symbol | undefined): Symbol | undefined; */
	getMergedSymbol := func(symbol Symbol) Symbol {
		var merged Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol && symbol.mergeId && ( /* TODO(TS-TO-GO) Node BinaryExpression: merged = mergedSymbols[symbol.mergeId] */ TODO):
			return merged
		default:
			return symbol
		}
	}
	getSymbolOfDeclaration := func(node Declaration) Symbol {
		return getMergedSymbol(node.symbol && getLateBoundSymbol(node.symbol))
	}
	/**
	 * Get the merged symbol for a node. If you know the node is a `Declaration`, it is faster and more type safe to
	 * use use `getSymbolOfDeclaration` instead.
	 */
	getSymbolOfNode := func(node Node) Symbol {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case canHaveSymbol(node):
			return getSymbolOfDeclaration(node)
		default:
			return nil
		}
	}
	getParentOfSymbol := func(symbol Symbol) Symbol {
		return getMergedSymbol(symbol.parent && getLateBoundSymbol(symbol.parent))
	}
	getFunctionExpressionParentSymbolOrSymbol := func(symbol Symbol) Symbol {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol.valueDeclaration. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindArrowFunction || symbol.valueDeclaration. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindFunctionExpression:
			return getSymbolOfNode(symbol.valueDeclaration.parent) || symbol
		default:
			return symbol
		}
	}
	getAlternativeContainingModules := func(symbol Symbol, enclosingDeclaration Node) []Symbol {
		containingFile := getSourceFileOfNode(enclosingDeclaration)
		id := getNodeId(containingFile)
		links := getSymbolLinks(symbol)
		var results *[]Symbol
		if links.extendedContainersByFile && ( /* TODO(TS-TO-GO) Node BinaryExpression: results = links.extendedContainersByFile.get(id) */ TODO) {
			return results
		}
		if containingFile && containingFile.imports {
			// Try to make an import using an import already in the enclosing file, if possible
			for _, importRef := range containingFile.imports {
				if nodeIsSynthesized(importRef) {
					continue
					// Synthetic names can't be resolved by `resolveExternalModuleName` - they'll cause a debug assert if they error
				}
				// Synthetic names can't be resolved by `resolveExternalModuleName` - they'll cause a debug assert if they error
				resolvedModule := resolveExternalModuleName(enclosingDeclaration, importRef /*ignoreErrors*/, true)
				if !resolvedModule {
					continue
				}
				ref := getAliasForSymbolInContainer(resolvedModule, symbol)
				if !ref {
					continue
				}
				results = append(results, resolvedModule)
			}
			if length(results) {
				(links.extendedContainersByFile || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.extendedContainersByFile = new Map() */ TODO)).set(id, results)
				return results
			}
		}
		if links.extendedContainers {
			return links.extendedContainers
		}
		// No results from files already being imported by this file - expand search (expensive, but not location-specific, so cached)
		otherFiles := host.getSourceFiles()
		for _, file := range otherFiles {
			if !isExternalModule(file) {
				continue
			}
			sym := getSymbolOfDeclaration(file)
			ref := getAliasForSymbolInContainer(sym, symbol)
			if !ref {
				continue
			}
			results = append(results, sym)
		}
		links.extendedContainers = results || emptyArray
		return links.extendedContainers
	}
	/**
	 * Attempts to find the symbol corresponding to the container a symbol is in - usually this
	 * is just its' `.parent`, but for locals, this value is `undefined`
	 */
	getContainersOfSymbol := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) *[]Symbol {
		container := getParentOfSymbol(symbol)
		// Type parameters end up in the `members` lists but are not externally visible
		if container && !(symbol.flags & SymbolFlagsTypeParameter) {
			return getWithAlternativeContainers(container)
		}
		candidates := mapDefined(symbol.declarations, func(d Declaration) Symbol {
			if !isAmbientModule(d) && d.parent {
				// direct children of a module
				if hasNonGlobalAugmentationExternalModuleSymbol(d.parent) {
					return getSymbolOfDeclaration(d.parent /* as Declaration */)
				}
				// export ='d member of an ambient module
				if isModuleBlock(d.parent) && d.parent.parent && resolveExternalModuleSymbol(getSymbolOfDeclaration(d.parent.parent)) == symbol {
					return getSymbolOfDeclaration(d.parent.parent)
				}
			}
			if isClassExpression(d) && isBinaryExpression(d.parent) && d.parent.operatorToken.kind == SyntaxKindEqualsToken && isAccessExpression(d.parent.left) && isEntityNameExpression(d.parent.left.expression) {
				if isModuleExportsAccessExpression(d.parent.left) || isExportsIdentifier(d.parent.left.expression) {
					return getSymbolOfDeclaration(getSourceFileOfNode(d))
				}
				checkExpressionCached(d.parent.left.expression)
				return getNodeLinks(d.parent.left.expression).resolvedSymbol
			}
		})
		if !length(candidates) {
			return nil
		}
		containers := mapDefined(candidates, func(candidate Symbol) Symbol {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case getAliasForSymbolInContainer(candidate, symbol):
				return candidate
			default:
				return nil
			}
		})
		var bestContainers []Symbol = []never{}
		var alternativeContainers []Symbol = []never{}
		for _, container := range containers {
			TODO_IDENTIFIER := getWithAlternativeContainers(container)
			bestContainers = append(bestContainers, bestMatch)
			alternativeContainers = addRange(alternativeContainers, rest)
		}
		return concatenate(bestContainers, alternativeContainers)
		getWithAlternativeContainers := func(container Symbol) []Symbol {
			additionalContainers := mapDefined(container.declarations, fileSymbolIfFileSymbolExportEqualsContainer)
			reexportContainers := enclosingDeclaration && getAlternativeContainingModules(symbol, enclosingDeclaration)
			objectLiteralContainer := getVariableDeclarationOfObjectLiteral(container, meaning)
			if enclosingDeclaration && container.flags&getQualifiedLeftMeaning(meaning) && getAccessibleSymbolChain(container, enclosingDeclaration, SymbolFlagsNamespace /*useOnlyExternalAliasing*/, false) {
				return append(concatenate(concatenate([]Symbol{container}, additionalContainers), reexportContainers), objectLiteralContainer)
				// This order expresses a preference for the real container if it is in scope
			}
			// we potentially have a symbol which is a member of the instance side of something - look for a variable in scope with the container's type
			// which may be acting like a namespace (eg, `Symbol` acts like a namespace when looking up `Symbol.toStringTag`)
			var firstVariableMatch Symbol
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !(container.flags & getQualifiedLeftMeaning(meaning)) && container.flags&SymbolFlagsType && getDeclaredTypeOfSymbol(container).flags&TypeFlagsObject && meaning == SymbolFlagsValue:
				firstVariableMatch = forEachSymbolTableInScope(enclosingDeclaration, func(t SymbolTable) Symbol {
					return forEachEntry(t, func(s Symbol) Symbol {
						if s.flags&getQualifiedLeftMeaning(meaning) && getTypeOfSymbol(s) == getDeclaredTypeOfSymbol(container) {
							return s
						}
					})
				})
			default:
				firstVariableMatch = nil
			}
			var res []Symbol
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case firstVariableMatch:
				res = []Symbol{firstVariableMatch /* TODO(TS-TO-GO) Node SpreadElement: ...additionalContainers */, container}
			default:
				res = []Symbol{ /* TODO(TS-TO-GO) Node SpreadElement: ...additionalContainers */ container}
			}
			res = append(res, objectLiteralContainer)
			res = addRange(res, reexportContainers)
			return res
		}
		fileSymbolIfFileSymbolExportEqualsContainer := func(d Declaration) Symbol {
			return container && getFileSymbolIfFileSymbolExportEqualsContainer(d, container)
		}
	}
	getVariableDeclarationOfObjectLiteral := func(symbol Symbol, meaning SymbolFlags) Symbol {
		// If we're trying to reference some object literal in, eg `var a = { x: 1 }`, the symbol for the literal, `__object`, is distinct
		// from the symbol of the declaration it is being assigned to. Since we can use the declaration to refer to the literal, however,
		// we'd like to make that connection here - potentially causing us to paint the declaration's visibility, and therefore the literal.
		var firstDecl /* TODO(TS-TO-GO) TypeNode UnionType: Node | false */ any = !!length(symbol.declarations) && first(symbol.declarations)
		if meaning&SymbolFlagsValue && firstDecl && firstDecl.parent && isVariableDeclaration(firstDecl.parent) {
			if isObjectLiteralExpression(firstDecl) && firstDecl == firstDecl.parent.initializer || isTypeLiteralNode(firstDecl) && firstDecl == firstDecl.parent.type_ {
				return getSymbolOfDeclaration(firstDecl.parent)
			}
		}
	}
	getFileSymbolIfFileSymbolExportEqualsContainer := func(d Declaration, container Symbol) Symbol {
		fileSymbol := getExternalModuleContainer(d)
		exported := fileSymbol && fileSymbol.exports && fileSymbol.exports.get(InternalSymbolNameExportEquals)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case exported && getSymbolIfSameReference(exported, container):
			return fileSymbol
		default:
			return nil
		}
	}
	getAliasForSymbolInContainer := func(container Symbol, symbol Symbol) Symbol {
		if container == getParentOfSymbol(symbol) {
			// fast path, `symbol` is either already the alias or isn't aliased
			return symbol
		}
		// Check if container is a thing with an `export=` which points directly at `symbol`, and if so, return
		// the container itself as the alias for the symbol
		exportEquals := container.exports && container.exports.get(InternalSymbolNameExportEquals)
		if exportEquals && getSymbolIfSameReference(exportEquals, symbol) {
			return container
		}
		exports := getExportsOfSymbol(container)
		quick := exports.get(symbol.escapedName)
		if quick && getSymbolIfSameReference(quick, symbol) {
			return quick
		}
		return forEachEntry(exports, func(exported Symbol) Symbol {
			if getSymbolIfSameReference(exported, symbol) {
				return exported
			}
		})
	}
	/**
	 * Checks if two symbols, through aliasing and/or merging, refer to the same thing
	 */
	getSymbolIfSameReference := func(s1 Symbol, s2 Symbol) Symbol {
		if getMergedSymbol(resolveSymbol(getMergedSymbol(s1))) == getMergedSymbol(resolveSymbol(getMergedSymbol(s2))) {
			return s1
		}
	}
	/* TODO(TS-TO-GO): function getExportSymbolOfValueSymbolIfExported(symbol: Symbol): Symbol; */
	/* TODO(TS-TO-GO): function getExportSymbolOfValueSymbolIfExported(symbol: Symbol | undefined): Symbol | undefined; */
	getExportSymbolOfValueSymbolIfExported := func(symbol Symbol) Symbol {
		return getMergedSymbol(symbol && (symbol.flags&SymbolFlagsExportValue) != 0 && symbol.exportSymbol || symbol)
	}
	symbolIsValue := func(symbol Symbol, includeTypeOnlyMembers bool) bool {
		return !!(symbol.flags&SymbolFlagsValue || symbol.flags&SymbolFlagsAlias && getSymbolFlags(symbol, !includeTypeOnlyMembers)&SymbolFlagsValue)
	}
	createType := func(flags TypeFlags) Type {
		result := NewType(checker, flags)
		typeCount++
		result.id = typeCount
		tracing. /* TODO(TS-TO-GO): was ? */ recordType(result)
		return result
	}
	createTypeWithSymbol := func(flags TypeFlags, symbol Symbol) Type {
		result := createType(flags)
		result.symbol = symbol
		return result
	}
	createOriginType := func(flags TypeFlags) Type {
		return NewType(checker, flags)
	}
	createIntrinsicType := func(kind TypeFlags, intrinsicName string, objectFlags ObjectFlags /*  = ObjectFlags.None */, debugIntrinsicName string) IntrinsicType {
		checkIntrinsicName(intrinsicName, debugIntrinsicName)
		type_ := createType(kind) /* as IntrinsicType */
		type_.intrinsicName = intrinsicName
		type_.debugIntrinsicName = debugIntrinsicName
		type_.objectFlags = objectFlags | ObjectFlagsCouldContainTypeVariablesComputed | ObjectFlagsIsGenericTypeComputed | ObjectFlagsIsUnknownLikeUnionComputed | ObjectFlagsIsNeverIntersectionComputed
		return type_
	}
	checkIntrinsicName := func(name string, debug *string) {
		key := __TEMPLATE__(name, "," /* TODO(TS-TO-GO) Node BinaryExpression: debug ?? "" */, TODO)
		if seenIntrinsicNames.has(key) {
			Debug.fail(__TEMPLATE__("Duplicate intrinsic type name ", name, __COND__(debug, __TEMPLATE__(" (", debug, ")"), ""), "; you may need to pass a name to createIntrinsicType."))
		}
		seenIntrinsicNames.add(key)
	}
	createObjectType := func(objectFlags ObjectFlags, symbol Symbol) ObjectType {
		type_ := createTypeWithSymbol(TypeFlagsObject, symbol) /* as ObjectType */
		type_.objectFlags = objectFlags
		type_.members = nil
		type_.properties = nil
		type_.callSignatures = nil
		type_.constructSignatures = nil
		type_.indexInfos = nil
		return type_
	}
	createTypeofType := func() Type {
		return getUnionType(arrayFrom(typeofNEFacts.keys(), getStringLiteralType))
	}
	createTypeParameter := func(symbol Symbol) TypeParameter {
		return createTypeWithSymbol(TypeFlagsTypeParameter, symbol) /* as TypeParameter */
	}
	// A reserved member name starts with two underscores, but the third character cannot be an underscore,
	// @, or #. A third underscore indicates an escaped form of an identifier that started
	// with at least two underscores. The @ character indicates that the name is denoted by a well known ES
	// Symbol instance and the # character indicates that the name is a PrivateIdentifier.
	isReservedMemberName := func(name __String) bool {
		return (name /* as string */).charCodeAt(0) == CharacterCodes_ && (name /* as string */).charCodeAt(1) == CharacterCodes_ && (name /* as string */).charCodeAt(2) != CharacterCodes_ && (name /* as string */).charCodeAt(2) != CharacterCodesat && (name /* as string */).charCodeAt(2) != CharacterCodeshash
	}
	getNamedMembers := func(members SymbolTable) []Symbol {
		var result *[]Symbol
		members.forEach(func(symbol Symbol, id __String) {
			if isNamedMember(symbol, id) {
				(result || ( /* TODO(TS-TO-GO) Node BinaryExpression: result = [] */ TODO)).push(symbol)
			}
		})
		return result || emptyArray
	}
	isNamedMember := func(member Symbol, escapedName __String) bool {
		return !isReservedMemberName(escapedName) && symbolIsValue(member)
	}
	getNamedOrIndexSignatureMembers := func(members SymbolTable) []Symbol {
		result := getNamedMembers(members)
		index := getIndexSymbolFromSymbolTable(members)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case index:
			return concatenate(result, []Symbol{index})
		default:
			return result
		}
	}
	setStructuredTypeMembers := func(type_ StructuredType, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
		resolved := type_ /* as ResolvedType */
		resolved.members = members
		resolved.properties = emptyArray
		resolved.callSignatures = callSignatures
		resolved.constructSignatures = constructSignatures
		resolved.indexInfos = indexInfos
		// This can loop back to getPropertyOfType() which would crash if `callSignatures` & `constructSignatures` are not initialized.
		if members != emptySymbols {
			resolved.properties = getNamedMembers(members)
		}
		return resolved
	}
	createAnonymousType := func(symbol Symbol, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
		return setStructuredTypeMembers(createObjectType(ObjectFlagsAnonymous, symbol), members, callSignatures, constructSignatures, indexInfos)
	}
	getResolvedTypeWithoutAbstractConstructSignatures := func(type_ ResolvedType) ObjectType {
		if type_.constructSignatures.length == 0 {
			return type_
		}
		if type_.objectTypeWithoutAbstractConstructSignatures {
			return type_.objectTypeWithoutAbstractConstructSignatures
		}
		constructSignatures := filter(type_.constructSignatures, func(signature Signature) bool {
			return !(signature.flags & SignatureFlagsAbstract)
		})
		if type_.constructSignatures == constructSignatures {
			return type_
		}
		typeCopy := createAnonymousType(type_.symbol, type_.members, type_.callSignatures, __COND__(some(constructSignatures), constructSignatures, emptyArray), type_.indexInfos)
		type_.objectTypeWithoutAbstractConstructSignatures = typeCopy
		typeCopy.objectTypeWithoutAbstractConstructSignatures = typeCopy
		return typeCopy
	}
	forEachSymbolTableInScope := func(enclosingDeclaration Node, callback func(symbolTable SymbolTable, ignoreQualification bool, isLocalNameLookup bool, scopeNode Node) T) T {
		var result T
		for location := enclosingDeclaration; location; location = location.parent {
			// Locals of a source file are not in scope (because they get merged into the global symbol table)
			if canHaveLocals(location) && location.locals && !isGlobalSourceFile(location) {
				if /* TODO(TS-TO-GO) Node BinaryExpression: result = callback(location.locals, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location) */ TODO {
					return result
				}
			}
			switch location.kind {
			case SyntaxKindSourceFile:
				if !isExternalOrCommonJsModule(location /* as SourceFile */) {
					break
				}
				fallthrough
			case SyntaxKindModuleDeclaration:
				sym := getSymbolOfDeclaration(location /* as ModuleDeclaration */)
				if /* TODO(TS-TO-GO) Node BinaryExpression: result = callback(sym?.exports || emptySymbols, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location) */ TODO {
					return result
				}
				break
			case SyntaxKindClassDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindClassExpression:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindInterfaceDeclaration:
				var table *Map[__String, Symbol]
				(getSymbolOfDeclaration(location /* as ClassLikeDeclaration | InterfaceDeclaration */).members || emptySymbols).forEach(func(memberSymbol Symbol, key __String) {
					if memberSymbol.flags & (SymbolFlagsType & ~SymbolFlagsAssignment) {
						(table || ( /* TODO(TS-TO-GO) Node BinaryExpression: table = createSymbolTable() */ TODO)).set(key, memberSymbol)
					}
				})
				if table && ( /* TODO(TS-TO-GO) Node BinaryExpression: result = callback(table, /*ignoreQualification* / undefined, /*isLocalNameLookup* / false, location) */ TODO) {
					return result
				}
				break
			}
		}
		return callback(globals /*ignoreQualification*/, nil /*isLocalNameLookup*/, true)
	}
	getQualifiedLeftMeaning := func(rightMeaning SymbolFlags) /* TODO(TS-TO-GO) inferred type SymbolFlags.Value | SymbolFlags.Namespace */ any {
		// If we are looking in value space, the parent meaning is value, other wise it is namespace
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case rightMeaning == SymbolFlagsValue:
			return SymbolFlagsValue
		default:
			return SymbolFlagsNamespace
		}
	}
	getAccessibleSymbolChain := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags, useOnlyExternalAliasing bool, visitedSymbolTablesMap Map[number, []SymbolTable] /*  = new Map<SymbolId, SymbolTable[]>() */) *[]Symbol {
		if !(symbol && !isPropertyOrMethodDeclarationSymbol(symbol)) {
			return nil
		}
		links := getSymbolLinks(symbol)
		cache := ( /* TODO(TS-TO-GO) Node BinaryExpression: links.accessibleChainCache ||= new Map() */ TODO)
		// Go from enclosingDeclaration to the first scope we check, so the cache is keyed off the scope and thus shared more
		firstRelevantLocation := forEachSymbolTableInScope(enclosingDeclaration, func(_ SymbolTable, __ *bool, ___ *bool, node Node) Node {
			return node
		})
		key := __TEMPLATE__(__COND__(useOnlyExternalAliasing, 0, 1), "|", firstRelevantLocation && getNodeId(firstRelevantLocation), "|", meaning)
		if cache.has(key) {
			return cache.get(key)
		}
		id := getSymbolId(symbol)
		visitedSymbolTables := visitedSymbolTablesMap.get(id)
		if !visitedSymbolTables {
			visitedSymbolTablesMap.set(id /* TODO(TS-TO-GO) Node BinaryExpression: visitedSymbolTables = [] */, TODO)
		}
		result := forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable)
		cache.set(key, result)
		return result
		/**
		 * @param {ignoreQualification} boolean Set when a symbol is being looked for through the exports of another symbol (meaning we have a route to qualify it already)
		 */
		getAccessibleSymbolChainFromSymbolTable := func(symbols SymbolTable, ignoreQualification bool, isLocalNameLookup bool) *[]Symbol {
			if !pushIfUnique(visitedSymbolTables, symbols) {
				return nil
			}
			result := trySymbolTable(symbols, ignoreQualification, isLocalNameLookup)
			visitedSymbolTables.pop()
			return result
		}
		canQualifySymbol := func(symbolFromSymbolTable Symbol, meaning SymbolFlags) bool {
			// If the symbol is equivalent and doesn't need further qualification, this symbol is accessible
			return !needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning) || !!getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing, visitedSymbolTablesMap)
		}
		isAccessible := func(symbolFromSymbolTable Symbol, resolvedAliasSymbol Symbol, ignoreQualification bool) bool {
			return (symbol == (resolvedAliasSymbol || symbolFromSymbolTable) || getMergedSymbol(symbol) == getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) && !some(symbolFromSymbolTable.declarations, hasNonGlobalAugmentationExternalModuleSymbol) && (ignoreQualification || canQualifySymbol(getMergedSymbol(symbolFromSymbolTable), meaning))
		}
		trySymbolTable := func(symbols SymbolTable, ignoreQualification *bool, isLocalNameLookup *bool) *[]Symbol {
			// If symbol is directly available by its name in the symbol table
			if isAccessible(symbols.get(symbol.escapedName) /*resolvedAliasSymbol*/, nil, ignoreQualification) {
				return []Symbol{symbol}
			}
			// Check if symbol is any of the aliases in scope
			result := forEachEntry(symbols, func(symbolFromSymbolTable Symbol) *[]Symbol {
				if symbolFromSymbolTable.flags&SymbolFlagsAlias && symbolFromSymbolTable.escapedName != InternalSymbolNameExportEquals && symbolFromSymbolTable.escapedName != InternalSymbolNameDefault && !(isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && isExternalModule(getSourceFileOfNode(enclosingDeclaration))) && (!useOnlyExternalAliasing || some(symbolFromSymbolTable.declarations, isExternalModuleImportEqualsDeclaration)) && (__COND__(isLocalNameLookup, !some(symbolFromSymbolTable.declarations, isNamespaceReexportDeclaration), true)) && (ignoreQualification || !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKindExportSpecifier)) {
					resolvedImportedSymbol := resolveAlias(symbolFromSymbolTable)
					candidate := getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification)
					if candidate {
						return candidate
					}
				}
				if symbolFromSymbolTable.escapedName == symbol.escapedName && symbolFromSymbolTable.exportSymbol {
					if isAccessible(getMergedSymbol(symbolFromSymbolTable.exportSymbol) /*resolvedAliasSymbol*/, nil, ignoreQualification) {
						return []Symbol{symbol}
					}
				}
			})
			// If there's no result and we're looking at the global symbol table, treat `globalThis` like an alias and try to lookup thru that
			return result || (__COND__(symbols == globals, getCandidateListForSymbol(globalThisSymbol, globalThisSymbol, ignoreQualification), nil))
		}
		getCandidateListForSymbol := func(symbolFromSymbolTable Symbol, resolvedImportedSymbol Symbol, ignoreQualification *bool) *[]Symbol {
			if isAccessible(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification) {
				return []Symbol{symbolFromSymbolTable}
			}
			// Look in the exported members, if we can find accessibleSymbolChain, symbol is accessible using this chain
			// but only if the symbolFromSymbolTable can be qualified
			candidateTable := getExportsOfSymbol(resolvedImportedSymbol)
			accessibleSymbolsFromExports := candidateTable && getAccessibleSymbolChainFromSymbolTable(candidateTable /*ignoreQualification*/, true)
			if accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning)) {
				return []Symbol{symbolFromSymbolTable}.concat(accessibleSymbolsFromExports)
			}
		}
	}
	needsQualification := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) bool {
		qualify := false
		forEachSymbolTableInScope(enclosingDeclaration, func(symbolTable SymbolTable) bool {
			// If symbol of this name is not available in the symbol table we are ok
			symbolFromSymbolTable := getMergedSymbol(symbolTable.get(symbol.escapedName))
			if !symbolFromSymbolTable {
				// Continue to the next symbol table
				return false
			}
			// If the symbol with this name is present it should refer to the symbol
			if symbolFromSymbolTable == symbol {
				// No need to qualify
				return true
			}
			// Qualify if the symbol from symbol table has same meaning as expected
			shouldResolveAlias := symbolFromSymbolTable.flags&SymbolFlagsAlias && !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKindExportSpecifier)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case shouldResolveAlias:
				symbolFromSymbolTable = resolveAlias(symbolFromSymbolTable)
			default:
				symbolFromSymbolTable = symbolFromSymbolTable
			}
			var flags SymbolFlags
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case shouldResolveAlias:
				flags = getSymbolFlags(symbolFromSymbolTable)
			default:
				flags = symbolFromSymbolTable.flags
			}
			if flags & meaning {
				qualify = true
				return true
			}
			// Continue to the next symbol table
			return false
		})
		return qualify
	}
	isPropertyOrMethodDeclarationSymbol := func(symbol Symbol) bool {
		if symbol.declarations && symbol.declarations.length {
			for _, declaration := range symbol.declarations {
				switch declaration.kind {
				case SyntaxKindPropertyDeclaration:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindMethodDeclaration:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindGetAccessor:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindSetAccessor:
					continue
					fallthrough
				default:
					return false
				}
			}
			return true
		}
		return false
	}
	isTypeSymbolAccessible := func(typeSymbol Symbol, enclosingDeclaration Node) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlagsType /*shouldComputeAliasesToMakeVisible*/, false /*allowModules*/, true)
		return access.accessibility == SymbolAccessibilityAccessible
	}
	isValueSymbolAccessible := func(typeSymbol Symbol, enclosingDeclaration Node) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlagsValue /*shouldComputeAliasesToMakeVisible*/, false /*allowModules*/, true)
		return access.accessibility == SymbolAccessibilityAccessible
	}
	isSymbolAccessibleByFlags := func(typeSymbol Symbol, enclosingDeclaration Node, flags SymbolFlags) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, flags /*shouldComputeAliasesToMakeVisible*/, false /*allowModules*/, false)
		return access.accessibility == SymbolAccessibilityAccessible
	}
	isAnySymbolAccessible := func(symbols *[]Symbol, enclosingDeclaration Node, initialSymbol Symbol, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) *SymbolAccessibilityResult {
		if !length(symbols) {
			return
		}
		var hadAccessibleChain Symbol
		earlyModuleBail := false
		for _, symbol := range symbols {
			// Symbol is accessible if it by itself is accessible
			accessibleSymbolChain := getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning /*useOnlyExternalAliasing*/, false)
			if accessibleSymbolChain {
				hadAccessibleChain = symbol
				hasAccessibleDeclarations := hasVisibleDeclarations(accessibleSymbolChain[0], shouldComputeAliasesToMakeVisible)
				if hasAccessibleDeclarations {
					return hasAccessibleDeclarations
				}
			}
			if allowModules {
				if some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
					if shouldComputeAliasesToMakeVisible {
						earlyModuleBail = true
						// Generally speaking, we want to use the aliases that already exist to refer to a module, if present
						// In order to do so, we need to find those aliases in order to retain them in declaration emit; so
						// if we are in declaration emit, we cannot use the fast path for module visibility until we've exhausted
						// all other visibility options (in order to capture the possible aliases used to reference the module)
						continue
					}
					// Any meaning of a module symbol is always accessible via an `import` type
					return map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"accessibility": SymbolAccessibilityAccessible,
					}
				}
			}
			// If we haven't got the accessible symbol, it doesn't mean the symbol is actually inaccessible.
			// It could be a qualified symbol and hence verify the path
			// e.g.:
			// module m {
			//     export class c {
			//     }
			// }
			// const x: typeof m.c
			// In the above example when we start with checking if typeof m.c symbol is accessible,
			// we are going to see if c can be accessed in scope directly.
			// But it can't, hence the accessible is going to be undefined, but that doesn't mean m.c is inaccessible
			// It is accessible if the parent m is accessible because then m.c can be accessed through qualification
			containers := getContainersOfSymbol(symbol, enclosingDeclaration, meaning)
			parentResult := isAnySymbolAccessible(containers, enclosingDeclaration, initialSymbol, __COND__(initialSymbol == symbol, getQualifiedLeftMeaning(meaning), meaning), shouldComputeAliasesToMakeVisible, allowModules)
			if parentResult {
				return parentResult
			}
		}
		if earlyModuleBail {
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"accessibility": SymbolAccessibilityAccessible,
			}
		}
		if hadAccessibleChain {
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"accessibility":   SymbolAccessibilityNotAccessible,
				"errorSymbolName": symbolToString(initialSymbol, enclosingDeclaration, meaning),
				"errorModuleName": __COND__(hadAccessibleChain != initialSymbol, symbolToString(hadAccessibleChain, enclosingDeclaration, SymbolFlagsNamespace), nil),
			}
		}
	}
	/**
	 * Check if the given symbol in given enclosing declaration is accessible and mark all associated alias to be visible if requested
	 *
	 * @param symbol a Symbol to check if accessible
	 * @param enclosingDeclaration a Node containing reference to the symbol
	 * @param meaning a SymbolFlags to check if such meaning of the symbol is accessible
	 * @param shouldComputeAliasToMakeVisible a boolean value to indicate whether to return aliases to be mark visible in case the symbol is accessible
	 */
	isSymbolAccessible := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool) SymbolAccessibilityResult {
		return isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible /*allowModules*/, true)
	}
	isSymbolAccessibleWorker := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) SymbolAccessibilityResult {
		if symbol && enclosingDeclaration {
			result := isAnySymbolAccessible([]Symbol{symbol}, enclosingDeclaration, symbol, meaning, shouldComputeAliasesToMakeVisible, allowModules)
			if result {
				return result
			}
			// This could be a symbol that is not exported in the external module
			// or it could be a symbol from different external module that is not aliased and hence cannot be named
			symbolExternalModule := forEach(symbol.declarations, getExternalModuleContainer)
			if symbolExternalModule {
				enclosingExternalModule := getExternalModuleContainer(enclosingDeclaration)
				if symbolExternalModule != enclosingExternalModule {
					// name from different external module that is not visible
					return map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"accessibility":   SymbolAccessibilityCannotBeNamed,
						"errorSymbolName": symbolToString(symbol, enclosingDeclaration, meaning),
						"errorModuleName": symbolToString(symbolExternalModule),
						"errorNode":       __COND__(isInJSFile(enclosingDeclaration), enclosingDeclaration, nil),
					}
				}
			}
			// Just a local name that is not accessible
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"accessibility":   SymbolAccessibilityNotAccessible,
				"errorSymbolName": symbolToString(symbol, enclosingDeclaration, meaning),
			}
		}
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"accessibility": SymbolAccessibilityAccessible,
		}
	}
	getExternalModuleContainer := func(declaration Node) Symbol {
		node := findAncestor(declaration, hasExternalModuleSymbol)
		return node && getSymbolOfDeclaration(node /* as AmbientModuleDeclaration | SourceFile */)
	}
	hasExternalModuleSymbol := func(declaration Node) bool {
		return isAmbientModule(declaration) || (declaration.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(declaration /* as SourceFile */))
	}
	hasNonGlobalAugmentationExternalModuleSymbol := func(declaration Node) bool {
		return isModuleWithStringLiteralName(declaration) || (declaration.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(declaration /* as SourceFile */))
	}
	hasVisibleDeclarations := func(symbol Symbol, shouldComputeAliasToMakeVisible bool) *SymbolVisibilityResult {
		var aliasesToMakeVisible *[]LateVisibilityPaintedStatement
		if !every(filter(symbol.declarations, func(d Declaration) bool {
			return d.kind != SyntaxKindIdentifier
		}), getIsDeclarationVisible) {
			return nil
		}
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"accessibility":        SymbolAccessibilityAccessible,
			"aliasesToMakeVisible": aliasesToMakeVisible,
		}
		getIsDeclarationVisible := func(declaration Declaration) bool {
			if !isDeclarationVisible(declaration) {
				// Mark the unexported alias as visible if its parent is visible
				// because these kind of aliases can be used to name types in declaration file
				anyImportSyntax := getAnyImportSyntax(declaration)
				if anyImportSyntax && !hasSyntacticModifier(anyImportSyntax, ModifierFlagsExport) && isDeclarationVisible(anyImportSyntax.parent) {
					return addVisibleAlias(declaration, anyImportSyntax)
				} else if isVariableDeclaration(declaration) && isVariableStatement(declaration.parent.parent) && !hasSyntacticModifier(declaration.parent.parent, ModifierFlagsExport) && isDeclarationVisible(declaration.parent.parent.parent) {
					return addVisibleAlias(declaration, declaration.parent.parent)
				} else if isLateVisibilityPaintedStatement(declaration) && !hasSyntacticModifier(declaration, ModifierFlagsExport) && isDeclarationVisible(declaration.parent) {
					return addVisibleAlias(declaration, declaration)
				} else if isBindingElement(declaration) {
					if symbol.flags&SymbolFlagsAlias && isInJSFile(declaration) && declaration.parent. /* TODO(TS-TO-GO): was ? */ parent && isVariableDeclaration(declaration.parent.parent) && declaration.parent.parent.parent. /* TODO(TS-TO-GO): was ? */ parent && isVariableStatement(declaration.parent.parent.parent.parent) && !hasSyntacticModifier(declaration.parent.parent.parent.parent, ModifierFlagsExport) && declaration.parent.parent.parent.parent.parent && isDeclarationVisible(declaration.parent.parent.parent.parent.parent) {
						return addVisibleAlias(declaration, declaration.parent.parent.parent.parent)
					} else if symbol.flags & SymbolFlagsBlockScopedVariable {
						variableStatement := findAncestor(declaration, isVariableStatement)
						if hasSyntacticModifier(variableStatement, ModifierFlagsExport) {
							return true
						}
						if !isDeclarationVisible(variableStatement.parent) {
							return false
						}
						return addVisibleAlias(declaration, variableStatement)
					}
				}
				// Declaration is not visible
				return false
			}
			return true
		}
		addVisibleAlias := func(declaration Declaration, aliasingStatement LateVisibilityPaintedStatement) bool {
			// In function "buildTypeDisplay" where we decide whether to write type-alias or serialize types,
			// we want to just check if type- alias is accessible or not but we don't care about emitting those alias at that time
			// since we will do the emitting later in trackSymbol.
			if shouldComputeAliasToMakeVisible {
				getNodeLinks(declaration).isVisible = true
				aliasesToMakeVisible = appendIfUnique(aliasesToMakeVisible, aliasingStatement)
			}
			return true
		}
	}
	getMeaningOfEntityNameReference := func(entityName EntityNameOrEntityNameExpression) SymbolFlags {
		// get symbol of the first identifier of the entityName
		var meaning SymbolFlags
		if entityName.parent.kind == SyntaxKindTypeQuery || entityName.parent.kind == SyntaxKindExpressionWithTypeArguments && !isPartOfTypeNode(entityName.parent) || entityName.parent.kind == SyntaxKindComputedPropertyName || entityName.parent.kind == SyntaxKindTypePredicate && (entityName.parent /* as TypePredicateNode */).parameterName == entityName {
			// Typeof value
			meaning = SymbolFlagsValue | SymbolFlagsExportValue
		} else if entityName.kind == SyntaxKindQualifiedName || entityName.kind == SyntaxKindPropertyAccessExpression || entityName.parent.kind == SyntaxKindImportEqualsDeclaration || (entityName.parent.kind == SyntaxKindQualifiedName && (entityName.parent /* as QualifiedName */).left == entityName) || (entityName.parent.kind == SyntaxKindPropertyAccessExpression && (entityName.parent /* as PropertyAccessExpression */).expression == entityName) || (entityName.parent.kind == SyntaxKindElementAccessExpression && (entityName.parent /* as ElementAccessExpression */).expression == entityName) {
			// Left identifier from type reference or TypeAlias
			// Entity name of the import declaration
			meaning = SymbolFlagsNamespace
		} else {
			// Type Reference or TypeAlias entity = Identifier
			meaning = SymbolFlagsType
		}
		return meaning
	}
	isEntityNameVisible := func(entityName EntityNameOrEntityNameExpression, enclosingDeclaration Node, shouldComputeAliasToMakeVisible bool /*  = true */) SymbolVisibilityResult {
		meaning := getMeaningOfEntityNameReference(entityName)
		firstIdentifier := getFirstIdentifier(entityName)
		symbol := resolveName(enclosingDeclaration, firstIdentifier.escapedText, meaning /*nameNotFoundMessage*/, nil /*isUse*/, false)
		if symbol && symbol.flags&SymbolFlagsTypeParameter && meaning&SymbolFlagsType {
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"accessibility": SymbolAccessibilityAccessible,
			}
		}
		if !symbol && isThisIdentifier(firstIdentifier) && isSymbolAccessible(getSymbolOfDeclaration(getThisContainer(firstIdentifier /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)), firstIdentifier, meaning /*shouldComputeAliasesToMakeVisible*/, false).accessibility == SymbolAccessibilityAccessible {
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"accessibility": SymbolAccessibilityAccessible,
			}
		}
		if !symbol {
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"accessibility":   SymbolAccessibilityNotResolved,
				"errorSymbolName": getTextOfNode(firstIdentifier),
				"errorNode":       firstIdentifier,
			}
		}
		// Verify if the symbol is accessible
		return hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) || map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"accessibility":   SymbolAccessibilityNotAccessible,
			"errorSymbolName": getTextOfNode(firstIdentifier),
			"errorNode":       firstIdentifier,
		}
	}
	symbolToString := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags, flags SymbolFormatFlags /*  = SymbolFormatFlags.AllowAnyNodeKind */, writer EmitTextWriter) string {
		nodeFlags := NodeBuilderFlagsIgnoreErrors
		internalNodeFlags := InternalNodeBuilderFlagsNone
		if flags & SymbolFormatFlagsUseOnlyExternalAliasing {
			nodeFlags |= NodeBuilderFlagsUseOnlyExternalAliasing
		}
		if flags & SymbolFormatFlagsWriteTypeParametersOrArguments {
			nodeFlags |= NodeBuilderFlagsWriteTypeParametersInQualifiedName
		}
		if flags & SymbolFormatFlagsUseAliasDefinedOutsideCurrentScope {
			nodeFlags |= NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope
		}
		if flags & SymbolFormatFlagsDoNotIncludeSymbolChain {
			internalNodeFlags |= InternalNodeBuilderFlagsDoNotIncludeSymbolChain
		}
		if flags & SymbolFormatFlagsWriteComputedProps {
			internalNodeFlags |= InternalNodeBuilderFlagsWriteComputedProps
		}
		var builder /* TODO(TS-TO-GO) inferred type ((symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => EntityName | undefined) | ((symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => Expression | ComputedPropertyName | undefined) */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case flags & SymbolFormatFlagsAllowAnyNodeKind:
			builder = nodeBuilder.symbolToNode
		default:
			builder = nodeBuilder.symbolToEntityName
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case writer:
			return symbolToStringWorker(writer).getText()
		default:
			return usingSingleLineStringWriter(symbolToStringWorker)
		}
		symbolToStringWorker := func(writer EmitTextWriter) EmitTextWriter {
			entity := builder(symbol, meaning, enclosingDeclaration, nodeFlags, internalNodeFlags)
			// add neverAsciiEscape for GH#39027
			var printer Printer
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case enclosingDeclaration. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindSourceFile:
				printer = createPrinterWithRemoveCommentsNeverAsciiEscape()
			default:
				printer = createPrinterWithRemoveComments()
			}
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			printer.writeNode(EmitHintUnspecified, entity /*sourceFile*/, sourceFile, writer)
			return writer
		}
	}
	signatureToString := func(signature Signature, enclosingDeclaration Node, flags TypeFormatFlags /*  = TypeFormatFlags.None */, kind SignatureKind, writer EmitTextWriter) string {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case writer:
			return signatureToStringWorker(writer).getText()
		default:
			return usingSingleLineStringWriter(signatureToStringWorker)
		}
		signatureToStringWorker := func(writer EmitTextWriter) EmitTextWriter {
			var sigOutput SyntaxKind
			if flags & TypeFormatFlagsWriteArrowStyleSignature {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case kind == SignatureKindConstruct:
					sigOutput = SyntaxKindConstructorType
				default:
					sigOutput = SyntaxKindFunctionType
				}
			} else {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case kind == SignatureKindConstruct:
					sigOutput = SyntaxKindConstructSignature
				default:
					sigOutput = SyntaxKindCallSignature
				}
			}
			sig := nodeBuilder.signatureToSignatureDeclaration(signature, sigOutput, enclosingDeclaration, toNodeBuilderFlags(flags)|NodeBuilderFlagsIgnoreErrors|NodeBuilderFlagsWriteTypeParametersInQualifiedName)
			printer := createPrinterWithRemoveCommentsOmitTrailingSemicolon()
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			printer.writeNode(EmitHintUnspecified, sig /*sourceFile*/, sourceFile, getTrailingSemicolonDeferringWriter(writer))
			// TODO: GH#18217
			return writer
		}
	}
	typeToString := func(type_ Type, enclosingDeclaration Node, flags TypeFormatFlags /*  = TypeFormatFlags.AllowUniqueESSymbolType | TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter /*  = createTextWriter("") */) string {
		noTruncation := compilerOptions.noErrorTruncation || flags&TypeFormatFlagsNoTruncation
		typeNode := nodeBuilder.typeToTypeNode(type_, enclosingDeclaration, toNodeBuilderFlags(flags)|NodeBuilderFlagsIgnoreErrors|(__COND__(noTruncation, NodeBuilderFlagsNoTruncation, NodeBuilderFlagsNone)) /*internalFlags*/, nil)
		if typeNode == nil {
			return Debug.fail("should always get typenode")
		}
		// The unresolved type gets a synthesized comment on `any` to hint to users that it's not a plain `any`.
		// Otherwise, we always strip comments out.
		var printer Printer
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_ != unresolvedType:
			printer = createPrinterWithRemoveComments()
		default:
			printer = createPrinterWithDefaults()
		}
		sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
		printer.writeNode(EmitHintUnspecified, typeNode /*sourceFile*/, sourceFile, writer)
		result := writer.getText()
		var maxLength number
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case noTruncation:
			maxLength = noTruncationMaximumTruncationLength * 2
		default:
			maxLength = defaultMaximumTruncationLength * 2
		}
		if maxLength && result && result.length >= maxLength {
			return result.substr(0, maxLength-len("...")) + "..."
		}
		return result
	}
	getTypeNamesForErrorDisplay := func(left Type, right Type) /* TODO(TS-TO-GO) TypeNode TupleType: [string, string] */ any {
		var leftStr string
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbolValueDeclarationIsContextSensitive(left.symbol):
			leftStr = typeToString(left, left.symbol.valueDeclaration)
		default:
			leftStr = typeToString(left)
		}
		var rightStr string
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbolValueDeclarationIsContextSensitive(right.symbol):
			rightStr = typeToString(right, right.symbol.valueDeclaration)
		default:
			rightStr = typeToString(right)
		}
		if leftStr == rightStr {
			leftStr = getTypeNameForErrorDisplay(left)
			rightStr = getTypeNameForErrorDisplay(right)
		}
		return []any{leftStr, rightStr}
	}
	getTypeNameForErrorDisplay := func(type_ Type) string {
		return typeToString(type_ /*enclosingDeclaration*/, nil, TypeFormatFlagsUseFullyQualifiedType)
	}
	symbolValueDeclarationIsContextSensitive := func(symbol Symbol) bool {
		return symbol && !!symbol.valueDeclaration && isExpression(symbol.valueDeclaration) && !isContextSensitive(symbol.valueDeclaration)
	}
	toNodeBuilderFlags := func(flags TypeFormatFlags /*  = TypeFormatFlags.None */) NodeBuilderFlags {
		return flags & TypeFormatFlagsNodeBuilderFlagsMask
	}
	isClassInstanceSide := func(type_ Type) bool {
		return !!type_.symbol && !!(type_.symbol.flags & SymbolFlagsClass) && (type_ == getDeclaredTypeOfClassOrInterface(type_.symbol) || (!!(type_.flags & TypeFlagsObject) && !!(getObjectFlags(type_) & ObjectFlagsIsClassInstanceClone)))
	}
	/**
	 * Same as getTypeFromTypeNode, but for use in createNodeBuilder
	 * Inside createNodeBuilder we shadow getTypeFromTypeNode to make sure anyone using this function will call the local version that does type mapping if appropriate
	 * This function is used to still be able to call the original getTypeFromTypeNode from the local scope version of getTypeFromTypeNode
	 */
	getTypeFromTypeNodeWithoutContext := func(node TypeNode) Type {
		return getTypeFromTypeNode(node)
	}
	createNodeBuilder := func() /* TODO(TS-TO-GO) inferred type { typeToTypeNode: (type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeNode | undefined; typePredicateToTypePredicateNode: (typePredicate: TypePredicate, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypePredicateNode | undefined; expressionOrTypeToTypeNode: (expr: Expression | JsxAttributeValue | undefined, type: Type, addUndefined?: boolean, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeNode | undefined; serializeTypeForDeclaration: (declaration: Declaration, type: Type, symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeNode | undefined; serializeReturnTypeForSignature: (signature: Signature, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeNode | undefined; indexInfoToIndexSignatureDeclaration: (indexInfo: IndexInfo, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => IndexSignatureDeclaration | undefined; signatureToSignatureDeclaration: (signature: Signature, kind: SignatureDeclaration["kind"], enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => SignatureDeclaration | undefined; symbolToEntityName: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => EntityName | undefined; symbolToExpression: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => Expression | undefined; symbolToTypeParameterDeclarations: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => NodeArray<TypeParameterDeclaration> | undefined; symbolToParameterDeclaration: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => ParameterDeclaration | undefined; typeParameterToDeclaration: (parameter: TypeParameter, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeParameterDeclaration | undefined; symbolTableToDeclarationStatements: (symbolTable: SymbolTable, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => Statement[] | undefined; symbolToNode: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => Expression | ComputedPropertyName | undefined; } */ any {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"typeToTypeNode": func(type_ Type, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) TypeNode {
					return typeToTypeNodeHelper(type_, context)
				})
			},
			"typePredicateToTypePredicateNode": func(typePredicate TypePredicate, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypePredicateNode {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) TypePredicateNode {
					return typePredicateToTypePredicateNodeHelper(typePredicate, context)
				})
			},
			"expressionOrTypeToTypeNode": func(expr /* TODO(TS-TO-GO) TypeNode UnionType: Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) TypeNode {
					return expressionOrTypeToTypeNode(context, expr, type_, addUndefined)
				})
			},
			"serializeTypeForDeclaration": func(declaration Declaration, type_ Type, symbol Symbol, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) TypeNode {
					return serializeTypeForDeclaration(context, declaration, type_, symbol)
				})
			},
			"serializeReturnTypeForSignature": func(signature Signature, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) *TypeNode {
					return serializeReturnTypeForSignature(context, signature)
				})
			},
			"indexInfoToIndexSignatureDeclaration": func(indexInfo IndexInfo, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *IndexSignatureDeclaration {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) IndexSignatureDeclaration {
					return indexInfoToIndexSignatureDeclarationHelper(indexInfo, context /*typeNode*/, nil)
				})
			},
			"signatureToSignatureDeclaration": func(signature Signature, kind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: SignatureDeclaration["kind"] */ any, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *SignatureDeclaration {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) SignatureDeclaration {
					return signatureToSignatureDeclarationHelper(signature, kind, context)
				})
			},
			"symbolToEntityName": func(symbol Symbol, meaning SymbolFlags, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *EntityName {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) EntityName {
					return symbolToName(symbol, context, meaning /*expectsIdentifier*/, false)
				})
			},
			"symbolToExpression": func(symbol Symbol, meaning SymbolFlags, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) Expression {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) Expression {
					return symbolToExpression(symbol, context, meaning)
				})
			},
			"symbolToTypeParameterDeclarations": func(symbol Symbol, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *NodeArray[TypeParameterDeclaration] {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) *NodeArray[TypeParameterDeclaration] {
					return typeParametersToTypeParameterDeclarations(symbol, context)
				})
			},
			"symbolToParameterDeclaration": func(symbol Symbol, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *ParameterDeclaration {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) ParameterDeclaration {
					return symbolToParameterDeclaration(symbol, context)
				})
			},
			"typeParameterToDeclaration": func(parameter TypeParameter, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeParameterDeclaration {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) TypeParameterDeclaration {
					return typeParameterToDeclaration(parameter, context)
				})
			},
			"symbolTableToDeclarationStatements": func(symbolTable SymbolTable, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *[]Statement {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) []Statement {
					return symbolTableToDeclarationStatements(symbolTable, context)
				})
			},
			"symbolToNode": func(symbol Symbol, meaning SymbolFlags, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) * /* TODO(TS-TO-GO) inferred type Expression | ComputedPropertyName */ any {
				return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type Expression | ComputedPropertyName */ any {
					return symbolToNode(symbol, context, meaning)
				})
			},
		}
		/* TODO(TS-TO-GO): function getTypeFromTypeNode(context: NodeBuilderContext, node: TypeNode, noMappedTypes?: false): Type; */
		/* TODO(TS-TO-GO): function getTypeFromTypeNode(context: NodeBuilderContext, node: TypeNode, noMappedTypes: true): Type | undefined; */
		getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes bool) Type {
			type_ := getTypeFromTypeNodeWithoutContext(node)
			if !context.mapper {
				return type_
			}
			mappedType := instantiateType(type_, context.mapper)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case noMappedTypes && mappedType != type_:
				return nil
			default:
				return mappedType
			}
		}
		/**
		 * Unlike the utilities `setTextRange`, this checks if the `location` we're trying to set on `range` is within the
		 * same file as the active context. If not, the range is not applied. This prevents us from copying ranges across files,
		 * which will confuse the node printer (as it assumes all node ranges are within the current file).
		 * Additionally, if `range` _isn't synthetic_, or isn't in the current file, it will _copy_ it to _remove_ its' position
		 * information.
		 *
		 * It also calls `setOriginalNode` to setup a `.original` pointer, since you basically *always* want these in the node builder.
		 */
		setTextRange := func(context NodeBuilderContext, range_ T, location Node) T {
			if !nodeIsSynthesized(range_) || !(range_.flags & NodeFlagsSynthesized) || !context.enclosingFile || context.enclosingFile != getSourceFileOfNode(getOriginalNode(range_)) {
				range_ = factory.cloneNode(range_)
				// if `range` is synthesized or originates in another file, copy it so it definitely has synthetic positions
			}
			if range_ == location {
				return range_
			}
			if !location {
				return range_
			}
			// Don't overwrite the original node if `range` has an `original` node that points either directly or indirectly to `location`
			original := range_.original
			for original && original != location {
				original = original.original
			}
			if !original {
				setOriginalNode(range_, location)
			}
			// only set positions if range comes from the same file since copying text across files isn't supported by the emitter
			if context.enclosingFile && context.enclosingFile == getSourceFileOfNode(getOriginalNode(location)) {
				return setTextRangeWorker(range_, location)
			}
			return range_
		}
		/**
		 * Same as expressionOrTypeToTypeNodeHelper, but also checks if the expression can be syntactically typed.
		 */
		expressionOrTypeToTypeNode := func(context NodeBuilderContext, expr /* TODO(TS-TO-GO) TypeNode UnionType: Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) TypeNode {
			restoreFlags := saveRestoreFlags(context)
			if expr && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
				syntacticNodeBuilder.serializeTypeOfExpression(expr, context, addUndefined)
			}
			context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
			result := expressionOrTypeToTypeNodeHelper(context, expr, type_, addUndefined)
			restoreFlags()
			return result
		}
		expressionOrTypeToTypeNodeHelper := func(context NodeBuilderContext, expr /* TODO(TS-TO-GO) TypeNode UnionType: Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) TypeNode {
			if expr {
				var typeNode *TypeNode
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isAssertionExpression(expr):
					typeNode = expr.type_
				case isJSDocTypeAssertion(expr):
					typeNode = getJSDocTypeAssertionType(expr)
				default:
					typeNode = nil
				}
				if typeNode && !isConstTypeReference(typeNode) {
					result := tryReuseExistingTypeNode(context, typeNode, type_, expr.parent, addUndefined)
					if result {
						return result
					}
				}
			}
			if addUndefined {
				type_ = getOptionalType(type_)
			}
			return typeToTypeNodeHelper(type_, context)
		}
		tryReuseExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode, type_ Type, host Node, addUndefined bool) *TypeNode {
			originalType := type_
			if addUndefined {
				type_ = getOptionalType(type_, !isParameter(host))
			}
			clone := tryReuseExistingNonParameterTypeNode(context, typeNode, type_, host)
			if clone {
				// explicitly add `| undefined` if it's missing from the input type nodes and the type contains `undefined` (and not the missing type)
				if addUndefined && containsNonMissingUndefinedType(type_) && !someType(getTypeFromTypeNode(context, typeNode), func(t Type) bool {
					return !!(t.flags & TypeFlagsUndefined)
				}) {
					return factory.createUnionTypeNode([]TypeNode{clone, factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)})
				}
				return clone
			}
			if addUndefined && originalType != type_ {
				cloneMissingUndefined := tryReuseExistingNonParameterTypeNode(context, typeNode, originalType, host)
				if cloneMissingUndefined {
					return factory.createUnionTypeNode([]TypeNode{cloneMissingUndefined, factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)})
				}
			}
			return nil
		}
		tryReuseExistingNonParameterTypeNode := func(context NodeBuilderContext, existing TypeNode, type_ Type, host Node /*  = context.enclosingDeclaration */, annotationType Type /*  = getTypeFromTypeNode(context, existing, /*noMappedTypes* / true) */) *TypeNode {
			if annotationType && typeNodeIsEquivalentToType(host, type_, annotationType) && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type_) {
				result := tryReuseExistingTypeNodeHelper(context, existing)
				if result {
					return result
				}
			}
			return nil
		}
		symbolToNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) /* TODO(TS-TO-GO) inferred type Expression | ComputedPropertyName */ any {
			if context.internalFlags & InternalNodeBuilderFlagsWriteComputedProps {
				if symbol.valueDeclaration {
					name := getNameOfDeclaration(symbol.valueDeclaration)
					if name && isComputedPropertyName(name) {
						return name
					}
				}
				nameType := getSymbolLinks(symbol).nameType
				if nameType && nameType.flags&(TypeFlagsEnumLiteral|TypeFlagsUniqueESSymbol) {
					context.enclosingDeclaration = nameType.symbol.valueDeclaration
					return factory.createComputedPropertyName(symbolToExpression(nameType.symbol, context, meaning))
				}
			}
			return symbolToExpression(symbol, context, meaning)
		}
		withContext := func(enclosingDeclaration Node, flags *NodeBuilderFlags, internalFlags *InternalNodeBuilderFlags, tracker *SymbolTracker, cb func(context NodeBuilderContext) T) *T {
			var moduleResolverHost *ModuleSpecifierResolutionHost
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case tracker. /* TODO(TS-TO-GO): was ? */ trackSymbol:
				moduleResolverHost = tracker.moduleResolverHost
			case (internalFlags || InternalNodeBuilderFlagsNone) & InternalNodeBuilderFlagsDoNotIncludeSymbolChain:
				moduleResolverHost = createBasicNodeBuilderModuleSpecifierResolutionHost(host)
			default:
				moduleResolverHost = nil
			}
			var context NodeBuilderContext = map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"enclosingDeclaration":                  enclosingDeclaration,
				"enclosingFile":                         enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration),
				"flags":                                 flags || NodeBuilderFlagsNone,
				"internalFlags":                         internalFlags || InternalNodeBuilderFlagsNone,
				"tracker":                               nil,
				"encounteredError":                      false,
				"reportedDiagnostic":                    false,
				"visitedTypes":                          nil,
				"symbolDepth":                           nil,
				"inferTypeParameters":                   nil,
				"approximateLength":                     0,
				"trackedSymbols":                        nil,
				"bundled":                               !!compilerOptions.outFile && !!enclosingDeclaration && isExternalOrCommonJsModule(getSourceFileOfNode(enclosingDeclaration)),
				"truncating":                            false,
				"usedSymbolNames":                       nil,
				"remappedSymbolNames":                   nil,
				"remappedSymbolReferences":              nil,
				"reverseMappedStack":                    nil,
				"mustCreateTypeParameterSymbolList":     true,
				"typeParameterSymbolList":               nil,
				"mustCreateTypeParametersNamesLookups":  true,
				"typeParameterNames":                    nil,
				"typeParameterNamesByText":              nil,
				"typeParameterNamesByTextNextNameCount": nil,
				"mapper":                                nil,
			}
			context.tracker = NewSymbolTrackerImpl(context, tracker, moduleResolverHost)
			resultingNode := cb(context)
			if context.truncating && context.flags&NodeBuilderFlagsNoTruncation {
				context.tracker.reportTruncationError()
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case context.encounteredError:
				return nil
			default:
				return resultingNode
			}
		}
		saveRestoreFlags := func(context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type () => void */ any {
			flags := context.flags
			internalFlags := context.internalFlags
			return restore
			restore := func() {
				context.flags = flags
				context.internalFlags = internalFlags
			}
		}
		checkTruncationLength := func(context NodeBuilderContext) bool {
			if context.truncating {
				return context.truncating
			}
			context.truncating = context.approximateLength > (__COND__((context.flags & NodeBuilderFlagsNoTruncation), noTruncationMaximumTruncationLength, defaultMaximumTruncationLength))
			return context.truncating
		}
		typeToTypeNodeHelper := func(type_ Type, context NodeBuilderContext) TypeNode {
			restoreFlags := saveRestoreFlags(context)
			typeNode := typeToTypeNodeWorker(type_, context)
			restoreFlags()
			return typeNode
		}
		typeToTypeNodeWorker := func(type_ Type, context NodeBuilderContext) TypeNode {
			if cancellationToken && cancellationToken.throwIfCancellationRequested {
				cancellationToken.throwIfCancellationRequested()
			}
			inTypeAlias := context.flags & NodeBuilderFlagsInTypeAlias
			context.flags &= ~NodeBuilderFlagsInTypeAlias
			if !type_ {
				if !(context.flags & NodeBuilderFlagsAllowEmptyUnionOrIntersection) {
					context.encounteredError = true
					return nil
					// TODO: GH#18217
				}
				context.approximateLength += 3
				return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
			}
			if !(context.flags & NodeBuilderFlagsNoTypeReduction) {
				type_ = getReducedType(type_)
			}
			if type_.flags & TypeFlagsAny {
				if type_.aliasSymbol {
					return factory.createTypeReferenceNode(symbolToEntityNameNode(type_.aliasSymbol), mapToTypeNodes(type_.aliasTypeArguments, context))
				}
				if type_ == unresolvedType {
					return addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), SyntaxKindMultiLineCommentTrivia, "unresolved")
				}
				context.approximateLength += 3
				return factory.createKeywordTypeNode(__COND__(type_ == intrinsicMarkerType, SyntaxKindIntrinsicKeyword, SyntaxKindAnyKeyword))
			}
			if type_.flags & TypeFlagsUnknown {
				return factory.createKeywordTypeNode(SyntaxKindUnknownKeyword)
			}
			if type_.flags & TypeFlagsString {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindStringKeyword)
			}
			if type_.flags & TypeFlagsNumber {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindNumberKeyword)
			}
			if type_.flags & TypeFlagsBigInt {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindBigIntKeyword)
			}
			if type_.flags&TypeFlagsBoolean && !type_.aliasSymbol {
				context.approximateLength += 7
				return factory.createKeywordTypeNode(SyntaxKindBooleanKeyword)
			}
			if type_.flags & TypeFlagsEnumLike {
				if type_.symbol.flags & SymbolFlagsEnumMember {
					parentSymbol := getParentOfSymbol(type_.symbol)
					parentName := symbolToTypeNode(parentSymbol, context, SymbolFlagsType)
					if getDeclaredTypeOfSymbol(parentSymbol) == type_ {
						return parentName
					}
					memberName := symbolName(type_.symbol)
					if isIdentifierText(memberName, ScriptTargetES5) {
						return appendReferenceToType(parentName /* as TypeReferenceNode | ImportTypeNode */, factory.createTypeReferenceNode(memberName /*typeArguments*/, nil))
					}
					if isImportTypeNode(parentName) {
						(parentName /* as any */).isTypeOf = true
						// mutably update, node is freshly manufactured anyhow
						return factory.createIndexedAccessTypeNode(parentName, factory.createLiteralTypeNode(factory.createStringLiteral(memberName)))
					} else if isTypeReferenceNode(parentName) {
						return factory.createIndexedAccessTypeNode(factory.createTypeQueryNode(parentName.typeName), factory.createLiteralTypeNode(factory.createStringLiteral(memberName)))
					} else {
						return Debug.fail("Unhandled type node kind returned from `symbolToTypeNode`.")
					}
				}
				return symbolToTypeNode(type_.symbol, context, SymbolFlagsType)
			}
			if type_.flags & TypeFlagsStringLiteral {
				context.approximateLength += (type_ /* as StringLiteralType */).value.length + 2
				return factory.createLiteralTypeNode(setEmitFlags(factory.createStringLiteral((type_ /* as StringLiteralType */).value, !!(context.flags&NodeBuilderFlagsUseSingleQuotesForStringLiteralType)), EmitFlagsNoAsciiEscaping))
			}
			if type_.flags & TypeFlagsNumberLiteral {
				value := (type_ /* as NumberLiteralType */).value
				context.approximateLength += ("" + value).length
				return factory.createLiteralTypeNode(__COND__(value < 0, factory.createPrefixUnaryExpression(SyntaxKindMinusToken, factory.createNumericLiteral(-value)), factory.createNumericLiteral(value)))
			}
			if type_.flags & TypeFlagsBigIntLiteral {
				context.approximateLength += (pseudoBigIntToString((type_ /* as BigIntLiteralType */).value).length) + 1
				return factory.createLiteralTypeNode(factory.createBigIntLiteral((type_ /* as BigIntLiteralType */).value))
			}
			if type_.flags & TypeFlagsBooleanLiteral {
				context.approximateLength += (type_ /* as IntrinsicType */).intrinsicName.length
				return factory.createLiteralTypeNode(__COND__((type_ /* as IntrinsicType */).intrinsicName == "true", factory.createTrue(), factory.createFalse()))
			}
			if type_.flags & TypeFlagsUniqueESSymbol {
				if !(context.flags & NodeBuilderFlagsAllowUniqueESSymbolType) {
					if isValueSymbolAccessible(type_.symbol, context.enclosingDeclaration) {
						context.approximateLength += 6
						return symbolToTypeNode(type_.symbol, context, SymbolFlagsValue)
					}
					if context.tracker.reportInaccessibleUniqueSymbolError {
						context.tracker.reportInaccessibleUniqueSymbolError()
					}
				}
				context.approximateLength += 13
				return factory.createTypeOperatorNode(SyntaxKindUniqueKeyword, factory.createKeywordTypeNode(SyntaxKindSymbolKeyword))
			}
			if type_.flags & TypeFlagsVoid {
				context.approximateLength += 4
				return factory.createKeywordTypeNode(SyntaxKindVoidKeyword)
			}
			if type_.flags & TypeFlagsUndefined {
				context.approximateLength += 9
				return factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)
			}
			if type_.flags & TypeFlagsNull {
				context.approximateLength += 4
				return factory.createLiteralTypeNode(factory.createNull())
			}
			if type_.flags & TypeFlagsNever {
				context.approximateLength += 5
				return factory.createKeywordTypeNode(SyntaxKindNeverKeyword)
			}
			if type_.flags & TypeFlagsESSymbol {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindSymbolKeyword)
			}
			if type_.flags & TypeFlagsNonPrimitive {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindObjectKeyword)
			}
			if isThisTypeParameter(type_) {
				if context.flags & NodeBuilderFlagsInObjectTypeLiteral {
					if !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowThisInObjectLiteral) {
						context.encounteredError = true
					}
					context.tracker.reportInaccessibleThisError()
				}
				context.approximateLength += 4
				return factory.createThisTypeNode()
			}
			if !inTypeAlias && type_.aliasSymbol && (context.flags&NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope || isTypeSymbolAccessible(type_.aliasSymbol, context.enclosingDeclaration)) {
				typeArgumentNodes := mapToTypeNodes(type_.aliasTypeArguments, context)
				if isReservedMemberName(type_.aliasSymbol.escapedName) && !(type_.aliasSymbol.flags & SymbolFlagsClass) {
					return factory.createTypeReferenceNode(factory.createIdentifier(""), typeArgumentNodes)
				}
				if length(typeArgumentNodes) == 1 && type_.aliasSymbol == globalArrayType.symbol {
					return factory.createArrayTypeNode(typeArgumentNodes[0])
				}
				return symbolToTypeNode(type_.aliasSymbol, context, SymbolFlagsType, typeArgumentNodes)
			}
			objectFlags := getObjectFlags(type_)
			if objectFlags & ObjectFlagsReference {
				Debug.assert(!!(type_.flags & TypeFlagsObject))
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case (type_ /* as TypeReference */).node:
					return visitAndTransformType(type_ /* as TypeReference */, typeReferenceToTypeNode)
				default:
					return typeReferenceToTypeNode(type_ /* as TypeReference */)
				}
			}
			if type_.flags&TypeFlagsTypeParameter || objectFlags&ObjectFlagsClassOrInterface {
				if type_.flags&TypeFlagsTypeParameter && contains(context.inferTypeParameters, type_) {
					context.approximateLength += symbolName(type_.symbol).length + 6
					var constraintNode *TypeNode
					constraint := getConstraintOfTypeParameter(type_ /* as TypeParameter */)
					if constraint {
						// If the infer type has a constraint that is not the same as the constraint
						// we would have normally inferred based on context, we emit the constraint
						// using `infer T extends ?`. We omit inferred constraints from type references
						// as they may be elided.
						inferredConstraint := getInferredTypeParameterConstraint(type_ /* as TypeParameter */ /*omitTypeReferences*/, true)
						if !(inferredConstraint && isTypeIdenticalTo(constraint, inferredConstraint)) {
							context.approximateLength += 9
							constraintNode = constraint && typeToTypeNodeHelper(constraint, context)
						}
					}
					return factory.createInferTypeNode(typeParameterToDeclarationWithConstraint(type_ /* as TypeParameter */, context, constraintNode))
				}
				if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && type_.flags&TypeFlagsTypeParameter {
					name := typeParameterToName(type_, context)
					context.approximateLength += idText(name).length
					return factory.createTypeReferenceNode(factory.createIdentifier(idText(name)) /*typeArguments*/, nil)
				}
				// Ignore constraint/default when creating a usage (as opposed to declaration) of a type parameter.
				if type_.symbol {
					return symbolToTypeNode(type_.symbol, context, SymbolFlagsType)
				}
				var name string
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case (type_ == markerSuperTypeForCheck || type_ == markerSubTypeForCheck) && varianceTypeParameter && varianceTypeParameter.symbol:
					name = (__COND__(type_ == markerSubTypeForCheck, "sub-", "super-")) + symbolName(varianceTypeParameter.symbol)
				default:
					name = "?"
				}
				return factory.createTypeReferenceNode(factory.createIdentifier(name) /*typeArguments*/, nil)
			}
			if type_.flags&TypeFlagsUnion && (type_ /* as UnionType */).origin {
				type_ = (type_ /* as UnionType */).origin
			}
			if type_.flags & (TypeFlagsUnion | TypeFlagsIntersection) {
				var types []Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case type_.flags & TypeFlagsUnion:
					types = formatUnionTypes((type_ /* as UnionType */).types)
				default:
					types = (type_ /* as IntersectionType */).types
				}
				if length(types) == 1 {
					return typeToTypeNodeHelper(types[0], context)
				}
				typeNodes := mapToTypeNodes(types, context /*isBareList*/, true)
				if typeNodes && typeNodes.length > 0 {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case type_.flags & TypeFlagsUnion:
						return factory.createUnionTypeNode(typeNodes)
					default:
						return factory.createIntersectionTypeNode(typeNodes)
					}
				} else {
					if !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowEmptyUnionOrIntersection) {
						context.encounteredError = true
					}
					return nil
					// TODO: GH#18217
				}
			}
			if objectFlags & (ObjectFlagsAnonymous | ObjectFlagsMapped) {
				Debug.assert(!!(type_.flags & TypeFlagsObject))
				// The type is an object literal type.
				return createAnonymousTypeNode(type_ /* as ObjectType */)
			}
			if type_.flags & TypeFlagsIndex {
				indexedType := (type_ /* as IndexType */).type_
				context.approximateLength += 6
				indexTypeNode := typeToTypeNodeHelper(indexedType, context)
				return factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, indexTypeNode)
			}
			if type_.flags & TypeFlagsTemplateLiteral {
				texts := (type_ /* as TemplateLiteralType */).texts
				types := (type_ /* as TemplateLiteralType */).types
				templateHead := factory.createTemplateHead(texts[0])
				templateSpans := factory.createNodeArray(map_(types, func(t Type, i number) TemplateLiteralTypeSpan {
					return factory.createTemplateLiteralTypeSpan(typeToTypeNodeHelper(t, context), (__COND__(i < types.length-1, factory.createTemplateMiddle, factory.createTemplateTail))(texts[i+1]))
				}))
				context.approximateLength += 2
				return factory.createTemplateLiteralType(templateHead, templateSpans)
			}
			if type_.flags & TypeFlagsStringMapping {
				typeNode := typeToTypeNodeHelper((type_ /* as StringMappingType */).type_, context)
				return symbolToTypeNode((type_ /* as StringMappingType */).symbol, context, SymbolFlagsType, []TypeNode{typeNode})
			}
			if type_.flags & TypeFlagsIndexedAccess {
				objectTypeNode := typeToTypeNodeHelper((type_ /* as IndexedAccessType */).objectType, context)
				indexTypeNode := typeToTypeNodeHelper((type_ /* as IndexedAccessType */).indexType, context)
				context.approximateLength += 2
				return factory.createIndexedAccessTypeNode(objectTypeNode, indexTypeNode)
			}
			if type_.flags & TypeFlagsConditional {
				return visitAndTransformType(type_, func(type_ Type) ConditionalTypeNode {
					return conditionalTypeToTypeNode(type_ /* as ConditionalType */)
				})
			}
			if type_.flags & TypeFlagsSubstitution {
				typeNode := typeToTypeNodeHelper((type_ /* as SubstitutionType */).baseType, context)
				noInferSymbol := isNoInferType(type_) && getGlobalTypeSymbol("NoInfer" /* as __String */ /*reportErrors*/, false)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case noInferSymbol:
					return symbolToTypeNode(noInferSymbol, context, SymbolFlagsType, []TypeNode{typeNode})
				default:
					return typeNode
				}
			}
			return Debug.fail("Should be unreachable.")
			conditionalTypeToTypeNode := func(type_ ConditionalType) ConditionalTypeNode {
				checkTypeNode := typeToTypeNodeHelper(type_.checkType, context)
				context.approximateLength += 15
				if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && type_.root.isDistributive && !(type_.checkType.flags & TypeFlagsTypeParameter) {
					newParam := createTypeParameter(createSymbol(SymbolFlagsTypeParameter, "T" /* as __String */))
					name := typeParameterToName(newParam, context)
					newTypeVariable := factory.createTypeReferenceNode(name)
					context.approximateLength += 37
					// 15 each for two added conditionals, 7 for an added infer type
					newMapper := prependTypeMapping(type_.root.checkType, newParam, type_.mapper)
					saveInferTypeParameters := context.inferTypeParameters
					context.inferTypeParameters = type_.root.inferTypeParameters
					extendsTypeNode := typeToTypeNodeHelper(instantiateType(type_.root.extendsType, newMapper), context)
					context.inferTypeParameters = saveInferTypeParameters
					trueTypeNode := typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, type_.root.node.trueType), newMapper))
					falseTypeNode := typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, type_.root.node.falseType), newMapper))
					// outermost conditional makes `T` a type parameter, allowing the inner conditionals to be distributive
					// second conditional makes `T` have `T & checkType` substitution, so it is correctly usable as the checkType
					// inner conditional runs the check the user provided on the check type (distributively) and returns the result
					// checkType extends infer T ? T extends checkType ? T extends extendsType<T> ? trueType<T> : falseType<T> : never : never;
					// this is potentially simplifiable to
					// checkType extends infer T ? T extends checkType & extendsType<T> ? trueType<T> : falseType<T> : never;
					// but that may confuse users who read the output more.
					// On the other hand,
					// checkType extends infer T extends checkType ? T extends extendsType<T> ? trueType<T> : falseType<T> : never;
					// may also work with `infer ... extends ...` in, but would produce declarations only compatible with the latest TS.
					return factory.createConditionalTypeNode(checkTypeNode, factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode(newTypeVariable.typeName) /* as Identifier */)), factory.createConditionalTypeNode(factory.createTypeReferenceNode(factory.cloneNode(name)), typeToTypeNodeHelper(type_.checkType, context), factory.createConditionalTypeNode(newTypeVariable, extendsTypeNode, trueTypeNode, falseTypeNode), factory.createKeywordTypeNode(SyntaxKindNeverKeyword)), factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
				}
				saveInferTypeParameters := context.inferTypeParameters
				context.inferTypeParameters = type_.root.inferTypeParameters
				extendsTypeNode := typeToTypeNodeHelper(type_.extendsType, context)
				context.inferTypeParameters = saveInferTypeParameters
				trueTypeNode := typeToTypeNodeOrCircularityElision(getTrueTypeFromConditionalType(type_))
				falseTypeNode := typeToTypeNodeOrCircularityElision(getFalseTypeFromConditionalType(type_))
				return factory.createConditionalTypeNode(checkTypeNode, extendsTypeNode, trueTypeNode, falseTypeNode)
			}
			typeToTypeNodeOrCircularityElision := func(type_ Type) TypeNode {
				if type_.flags & TypeFlagsUnion {
					if context.visitedTypes. /* TODO(TS-TO-GO): was ? */ has(getTypeId(type_)) {
						if !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) {
							context.encounteredError = true
							context.tracker. /* TODO(TS-TO-GO): was ? */ reportCyclicStructureError()
						}
						return createElidedInformationPlaceholder(context)
					}
					return visitAndTransformType(type_, func(type_ Type) TypeNode {
						return typeToTypeNodeHelper(type_, context)
					})
				}
				return typeToTypeNodeHelper(type_, context)
			}
			isMappedTypeHomomorphic := func(type_ MappedType) bool {
				return !!getHomomorphicTypeVariable(type_)
			}
			isHomomorphicMappedTypeWithNonHomomorphicInstantiation := func(type_ MappedType) bool {
				return !!type_.target && isMappedTypeHomomorphic(type_.target /* as MappedType */) && !isMappedTypeHomomorphic(type_)
			}
			createMappedTypeNodeFromType := func(type_ MappedType) /* TODO(TS-TO-GO) inferred type MappedTypeNode | ConditionalTypeNode */ any {
				Debug.assert(!!(type_.flags & TypeFlagsObject))
				var readonlyToken * /* TODO(TS-TO-GO) inferred type ReadonlyKeyword | PlusToken | MinusToken */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case type_.declaration.readonlyToken:
					readonlyToken = factory.createToken(type_.declaration.readonlyToken.kind) /* as ReadonlyKeyword | PlusToken | MinusToken */
				default:
					readonlyToken = nil
				}
				var questionToken * /* TODO(TS-TO-GO) inferred type QuestionToken | PlusToken | MinusToken */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case type_.declaration.questionToken:
					questionToken = factory.createToken(type_.declaration.questionToken.kind) /* as QuestionToken | PlusToken | MinusToken */
				default:
					questionToken = nil
				}
				var appropriateConstraintTypeNode TypeNode
				var newTypeVariable *TypeReferenceNode
				// If the mapped type isn't `keyof` constraint-declared, _but_ still has modifiers preserved, and its naive instantiation won't preserve modifiers because its constraint isn't `keyof` constrained, we have work to do
				needsModifierPreservingWrapper := !isMappedTypeWithKeyofConstraintDeclaration(type_) && !(getModifiersTypeFromMappedType(type_).flags & TypeFlagsUnknown) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && !(getConstraintTypeFromMappedType(type_).flags&TypeFlagsTypeParameter && getConstraintOfTypeParameter(getConstraintTypeFromMappedType(type_)). /* TODO(TS-TO-GO): was ? */ flags&TypeFlagsIndex)
				if isMappedTypeWithKeyofConstraintDeclaration(type_) {
					// We have a { [P in keyof T]: X }
					// We do this to ensure we retain the toplevel keyof-ness of the type which may be lost due to keyof distribution during `getConstraintTypeFromMappedType`
					if isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type_) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
						newParam := createTypeParameter(createSymbol(SymbolFlagsTypeParameter, "T" /* as __String */))
						name := typeParameterToName(newParam, context)
						newTypeVariable = factory.createTypeReferenceNode(name)
					}
					appropriateConstraintTypeNode = factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, newTypeVariable || typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context))
				} else if needsModifierPreservingWrapper {
					// So, step 1: new type variable
					newParam := createTypeParameter(createSymbol(SymbolFlagsTypeParameter, "T" /* as __String */))
					name := typeParameterToName(newParam, context)
					newTypeVariable = factory.createTypeReferenceNode(name)
					// step 2: make that new type variable itself the constraint node, making the mapped type `{[K in T_1]: Template}`
					appropriateConstraintTypeNode = newTypeVariable
				} else {
					appropriateConstraintTypeNode = typeToTypeNodeHelper(getConstraintTypeFromMappedType(type_), context)
				}
				typeParameterNode := typeParameterToDeclarationWithConstraint(getTypeParameterFromMappedType(type_), context, appropriateConstraintTypeNode)
				var nameTypeNode *TypeNode
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case type_.declaration.nameType:
					nameTypeNode = typeToTypeNodeHelper(getNameTypeFromMappedType(type_), context)
				default:
					nameTypeNode = nil
				}
				templateTypeNode := typeToTypeNodeHelper(removeMissingType(getTemplateTypeFromMappedType(type_), !!(getMappedTypeModifiers(type_)&MappedTypeModifiersIncludeOptional)), context)
				mappedTypeNode := factory.createMappedTypeNode(readonlyToken, typeParameterNode, nameTypeNode, questionToken, templateTypeNode /*members*/, nil)
				context.approximateLength += 10
				result := setEmitFlags(mappedTypeNode, EmitFlagsSingleLine)
				if isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type_) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
					// homomorphic mapped type with a non-homomorphic naive inlining
					// wrap it with a conditional like `SomeModifiersType extends infer U ? {..the mapped type...} : never` to ensure the resulting
					// type stays homomorphic
					originalConstraint := instantiateType(getConstraintOfTypeParameter(getTypeFromTypeNode(context, (type_.declaration.typeParameter.constraint /* as TypeOperatorNode */).type_) /* as TypeParameter */) || unknownType, type_.mapper)
					return factory.createConditionalTypeNode(typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context), factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode(newTypeVariable.typeName) /* as Identifier */, __COND__(originalConstraint.flags&TypeFlagsUnknown, nil, typeToTypeNodeHelper(originalConstraint, context)))), result, factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
				} else if needsModifierPreservingWrapper {
					// and step 3: once the mapped type is reconstructed, create a `ConstraintType extends infer T_1 extends keyof ModifiersType ? {[K in T_1]: Template} : never`
					// subtly different from the `keyof` constraint case, by including the `keyof` constraint on the `infer` type parameter, it doesn't rely on the constraint type being itself
					// constrained to a `keyof` type to preserve its modifier-preserving behavior. This is all basically because we preserve modifiers for a wider set of mapped types than
					// just homomorphic ones.
					return factory.createConditionalTypeNode(typeToTypeNodeHelper(getConstraintTypeFromMappedType(type_), context), factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode(newTypeVariable.typeName) /* as Identifier */, factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context)))), result, factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
				}
				return result
			}
			createAnonymousTypeNode := func(type_ ObjectType) TypeNode {
				typeId := type_.id
				symbol := type_.symbol
				if symbol {
					isInstantiationExpressionType := !!(getObjectFlags(type_) & ObjectFlagsInstantiationExpressionType)
					if isInstantiationExpressionType {
						instantiationExpressionType := type_ /* as InstantiationExpressionType */
						existing := instantiationExpressionType.node
						if isTypeQueryNode(existing) {
							typeNode := tryReuseExistingNonParameterTypeNode(context, existing, type_)
							if typeNode {
								return typeNode
							}
						}
						if context.visitedTypes. /* TODO(TS-TO-GO): was ? */ has(typeId) {
							return createElidedInformationPlaceholder(context)
						}
						return visitAndTransformType(type_, createTypeNodeFromObjectType)
					}
					var isInstanceType /* TODO(TS-TO-GO) inferred type SymbolFlags.Value | SymbolFlags.Type */ any
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isClassInstanceSide(type_):
						isInstanceType = SymbolFlagsType
					default:
						isInstanceType = SymbolFlagsValue
					}
					if isJSConstructor(symbol.valueDeclaration) {
						// Instance and static types share the same symbol; only add 'typeof' for the static side.
						return symbolToTypeNode(symbol, context, isInstanceType)
					} else if symbol.flags&SymbolFlagsClass && !getBaseTypeVariableOfClass(symbol) && !(symbol.valueDeclaration && isClassLike(symbol.valueDeclaration) && context.flags&NodeBuilderFlagsWriteClassExpressionAsTypeLiteral && (!isClassDeclaration(symbol.valueDeclaration) || isSymbolAccessible(symbol, context.enclosingDeclaration, isInstanceType /*shouldComputeAliasesToMakeVisible*/, false).accessibility != SymbolAccessibilityAccessible)) || symbol.flags&(SymbolFlagsEnum|SymbolFlagsValueModule) || shouldWriteTypeOfFunctionSymbol() {
						return symbolToTypeNode(symbol, context, isInstanceType)
					} else if context.visitedTypes. /* TODO(TS-TO-GO): was ? */ has(typeId) {
						// If type is an anonymous type literal in a type alias declaration, use type alias name
						typeAlias := getTypeAliasForTypeLiteral(type_)
						if typeAlias {
							// The specified symbol flags need to be reinterpreted as type flags
							return symbolToTypeNode(typeAlias, context, SymbolFlagsType)
						} else {
							return createElidedInformationPlaceholder(context)
						}
					} else {
						return visitAndTransformType(type_, createTypeNodeFromObjectType)
					}
				} else {
					// Anonymous types without a symbol are never circular.
					return createTypeNodeFromObjectType(type_)
				}
				shouldWriteTypeOfFunctionSymbol := func() *bool {
					isStaticMethodSymbol := !!(symbol.flags & SymbolFlagsMethod) && some(symbol.declarations, func(declaration Declaration) bool {
						return isStatic(declaration)
					})
					isNonLocalFunctionSymbol := !!(symbol.flags & SymbolFlagsFunction) && (symbol.parent || forEach(symbol.declarations, func(declaration Declaration) bool {
						return declaration.parent.kind == SyntaxKindSourceFile || declaration.parent.kind == SyntaxKindModuleBlock
					}))
					if isStaticMethodSymbol || isNonLocalFunctionSymbol {
						// typeof is allowed only for static/non local functions
						return (!!(context.flags & NodeBuilderFlagsUseTypeOfFunction) || (context.visitedTypes. /* TODO(TS-TO-GO): was ? */ has(typeId))) && (!(context.flags & NodeBuilderFlagsUseStructuralFallback) || isValueSymbolAccessible(symbol, context.enclosingDeclaration))
						// And the build is going to succeed without visibility error or there is no structural fallback allowed
					}
				}
			}
			visitAndTransformType := func(type_ T, transform func(type_ T) TypeNode) TypeNode {
				typeId := type_.id
				isConstructorObject := getObjectFlags(type_)&ObjectFlagsAnonymous && type_.symbol && type_.symbol.flags&SymbolFlagsClass
				var id *string
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case getObjectFlags(type_)&ObjectFlagsReference && (type_ /* as TypeReference & T */).node:
					id = "N" + getNodeId((type_ /* as TypeReference & T */).node)
				case type_.flags & TypeFlagsConditional:
					id = "N" + getNodeId((type_ /* as ConditionalType & T */).root.node)
				case type_.symbol:
					id = (__COND__(isConstructorObject, "+", "")) + getSymbolId(type_.symbol)
				default:
					id = nil
				}
				// Since instantiations of the same anonymous type have the same symbol, tracking symbols instead
				// of types allows us to catch circular references to instantiations of the same anonymous type
				if !context.visitedTypes {
					context.visitedTypes = NewSet()
				}
				if id && !context.symbolDepth {
					context.symbolDepth = NewMap()
				}
				links := context.enclosingDeclaration && getNodeLinks(context.enclosingDeclaration)
				key := __TEMPLATE__(getTypeId(type_), "|", context.flags, "|", context.internalFlags)
				if links {
					/* TODO(TS-TO-GO) Node BinaryExpression: links.serializedTypes ||= new Map() */ TODO
				}
				cachedResult := links. /* TODO(TS-TO-GO): was ? */ serializedTypes. /* TODO(TS-TO-GO): was ? */ get(key)
				if cachedResult {
					// TODO:: check if we instead store late painted statements associated with this?
					cachedResult.trackedSymbols. /* TODO(TS-TO-GO): was ? */ forEach(func(TODO_IDENTIFIER TrackedSymbol) bool {
						return context.tracker.trackSymbol(symbol, enclosingDeclaration, meaning)
					})
					if cachedResult.truncating {
						context.truncating = true
					}
					context.approximateLength += cachedResult.addedLength
					return deepCloneOrReuseNode(cachedResult.node)
				}
				var depth *number
				if id {
					depth = context.symbolDepth.get(id) || 0
					if depth > 10 {
						return createElidedInformationPlaceholder(context)
					}
					context.symbolDepth.set(id, depth+1)
				}
				context.visitedTypes.add(typeId)
				prevTrackedSymbols := context.trackedSymbols
				context.trackedSymbols = nil
				startLength := context.approximateLength
				result := transform(type_)
				addedLength := context.approximateLength - startLength
				if !context.reportedDiagnostic && !context.encounteredError {
					links. /* TODO(TS-TO-GO): was ? */ serializedTypes. /* TODO(TS-TO-GO): was ? */ set(key, map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"node":           result,
						"truncating":     context.truncating,
						"addedLength":    addedLength,
						"trackedSymbols": context.trackedSymbols,
					})
				}
				context.visitedTypes.delete(typeId)
				if id {
					context.symbolDepth.set(id, depth)
				}
				context.trackedSymbols = prevTrackedSymbols
				return result
				deepCloneOrReuseNode := func(node T) T {
					if !nodeIsSynthesized(node) && getParseTreeNode(node) == node {
						return node
					}
					return setTextRange(context, factory.cloneNode(visitEachChildWorker(node, deepCloneOrReuseNode /*context*/, nil, deepCloneOrReuseNodes, deepCloneOrReuseNode)), node)
				}
				deepCloneOrReuseNodes := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
					if nodes && nodes.length == 0 {
						// Ensure we explicitly make a copy of an empty array; visitNodes will not do this unless the array has elements,
						// which can lead to us reusing the same empty NodeArray more than once within the same AST during type noding.
						return setTextRangeWorker(factory.createNodeArray(nil, nodes.hasTrailingComma), nodes)
					}
					return visitNodes(nodes, visitor, test, start, count)
				}
			}
			createTypeNodeFromObjectType := func(type_ ObjectType) TypeNode {
				if isGenericMappedType(type_) || (type_ /* as MappedType */).containsError {
					return createMappedTypeNodeFromType(type_ /* as MappedType */)
				}
				resolved := resolveStructuredTypeMembers(type_)
				if !resolved.properties.length && !resolved.indexInfos.length {
					if !resolved.callSignatures.length && !resolved.constructSignatures.length {
						context.approximateLength += 2
						return setEmitFlags(factory.createTypeLiteralNode(nil), EmitFlagsSingleLine)
					}
					if resolved.callSignatures.length == 1 && !resolved.constructSignatures.length {
						signature := resolved.callSignatures[0]
						signatureNode := signatureToSignatureDeclarationHelper(signature, SyntaxKindFunctionType, context) /* as FunctionTypeNode */
						return signatureNode
					}
					if resolved.constructSignatures.length == 1 && !resolved.callSignatures.length {
						signature := resolved.constructSignatures[0]
						signatureNode := signatureToSignatureDeclarationHelper(signature, SyntaxKindConstructorType, context) /* as ConstructorTypeNode */
						return signatureNode
					}
				}
				abstractSignatures := filter(resolved.constructSignatures, func(signature Signature) bool {
					return !!(signature.flags & SignatureFlagsAbstract)
				})
				if some(abstractSignatures) {
					types := map_(abstractSignatures, func(s Signature) ObjectType {
						return getOrCreateTypeFromSignature(s)
					})
					// count the number of type elements excluding abstract constructors
					typeElementCount := resolved.callSignatures.length + (resolved.constructSignatures.length - abstractSignatures.length) + resolved.indexInfos.length + (__COND__(context.flags&NodeBuilderFlagsWriteClassExpressionAsTypeLiteral, countWhere(resolved.properties, func(p Symbol) bool {
						return !(p.flags & SymbolFlagsPrototype)
					}), length(resolved.properties)))
					// don't include an empty object literal if there were no other static-side
					// properties to write, i.e. `abstract class C { }` becomes `abstract new () => {}`
					// and not `(abstract new () => {}) & {}`
					if typeElementCount {
						// create a copy of the object type without any abstract construct signatures.
						types.push(getResolvedTypeWithoutAbstractConstructSignatures(resolved))
					}
					return typeToTypeNodeHelper(getIntersectionType(types), context)
				}
				restoreFlags := saveRestoreFlags(context)
				context.flags |= NodeBuilderFlagsInObjectTypeLiteral
				members := createTypeNodesFromResolvedType(resolved)
				restoreFlags()
				typeLiteralNode := factory.createTypeLiteralNode(members)
				context.approximateLength += 2
				setEmitFlags(typeLiteralNode, __COND__((context.flags&NodeBuilderFlagsMultilineObjectLiterals), 0, EmitFlagsSingleLine))
				return typeLiteralNode
			}
			typeReferenceToTypeNode := func(type_ TypeReference) TypeNode {
				var typeArguments []Type = getTypeArguments(type_)
				if type_.target == globalArrayType || type_.target == globalReadonlyArrayType {
					if context.flags & NodeBuilderFlagsWriteArrayAsGenericType {
						typeArgumentNode := typeToTypeNodeHelper(typeArguments[0], context)
						return factory.createTypeReferenceNode(__COND__(type_.target == globalArrayType, "Array", "ReadonlyArray"), []TypeNode{typeArgumentNode})
					}
					elementType := typeToTypeNodeHelper(typeArguments[0], context)
					arrayType := factory.createArrayTypeNode(elementType)
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case type_.target == globalArrayType:
						return arrayType
					default:
						return factory.createTypeOperatorNode(SyntaxKindReadonlyKeyword, arrayType)
					}
				} else if type_.target.objectFlags & ObjectFlagsTuple {
					typeArguments = sameMap(typeArguments, func(t Type, i number) Type {
						return removeMissingType(t, !!((type_.target /* as TupleType */).elementFlags[i] & ElementFlagsOptional))
					})
					if typeArguments.length > 0 {
						arity := getTypeReferenceArity(type_)
						tupleConstituentNodes := mapToTypeNodes(typeArguments.slice(0, arity), context)
						if tupleConstituentNodes {
							TODO_IDENTIFIER := type_.target /* as TupleType */
							for i := 0; i < tupleConstituentNodes.length; i++ {
								flags := (type_.target /* as TupleType */).elementFlags[i]
								labeledElementDeclaration := labeledElementDeclarations[i]
								if labeledElementDeclaration {
									tupleConstituentNodes[i] = factory.createNamedTupleMember(__COND__(flags&ElementFlagsVariable, factory.createToken(SyntaxKindDotDotDotToken), nil), factory.createIdentifier(unescapeLeadingUnderscores(getTupleElementLabel(labeledElementDeclaration))), __COND__(flags&ElementFlagsOptional, factory.createToken(SyntaxKindQuestionToken), nil), __COND__(flags&ElementFlagsRest, factory.createArrayTypeNode(tupleConstituentNodes[i]), tupleConstituentNodes[i]))
								} else {
									// TODO(TS-TO-GO): converted from conditional expression
									switch {
									case flags & ElementFlagsVariable:
										tupleConstituentNodes[i] = factory.createRestTypeNode(__COND__(flags&ElementFlagsRest, factory.createArrayTypeNode(tupleConstituentNodes[i]), tupleConstituentNodes[i]))
									case flags & ElementFlagsOptional:
										tupleConstituentNodes[i] = factory.createOptionalTypeNode(tupleConstituentNodes[i])
									default:
										tupleConstituentNodes[i] = tupleConstituentNodes[i]
									}
								}
							}
							tupleTypeNode := setEmitFlags(factory.createTupleTypeNode(tupleConstituentNodes), EmitFlagsSingleLine)
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case (type_.target /* as TupleType */).readonly:
								return factory.createTypeOperatorNode(SyntaxKindReadonlyKeyword, tupleTypeNode)
							default:
								return tupleTypeNode
							}
						}
					}
					if context.encounteredError || (context.flags & NodeBuilderFlagsAllowEmptyTuple) {
						tupleTypeNode := setEmitFlags(factory.createTupleTypeNode([]never{}), EmitFlagsSingleLine)
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case (type_.target /* as TupleType */).readonly:
							return factory.createTypeOperatorNode(SyntaxKindReadonlyKeyword, tupleTypeNode)
						default:
							return tupleTypeNode
						}
					}
					context.encounteredError = true
					return nil
					// TODO: GH#18217
				} else if context.flags&NodeBuilderFlagsWriteClassExpressionAsTypeLiteral && type_.symbol.valueDeclaration && isClassLike(type_.symbol.valueDeclaration) && !isValueSymbolAccessible(type_.symbol, context.enclosingDeclaration) {
					return createAnonymousTypeNode(type_)
				} else {
					outerTypeParameters := type_.target.outerTypeParameters
					i := 0
					var resultType /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ImportTypeNode | undefined */ any
					if outerTypeParameters {
						length := outerTypeParameters.length
						for i < length {
							// Find group of type arguments for type parameters with the same declaring container.
							start := i
							parent := getParentSymbolOfTypeParameter(outerTypeParameters[i])
							// TODO(TS-TO-GO): refactor do-while loop approximation
							for ok := true; ok; ok = i < length && getParentSymbolOfTypeParameter(outerTypeParameters[i]) == parent {
								i++
							}
							// When type parameters are their own type arguments for the whole group (i.e. we have
							// the default outer type arguments), we don't show the group.
							if !rangeEquals(outerTypeParameters, typeArguments, start, i) {
								typeArgumentSlice := mapToTypeNodes(typeArguments.slice(start, i), context)
								restoreFlags := saveRestoreFlags(context)
								context.flags |= NodeBuilderFlagsForbidIndexedAccessSymbolReferences
								ref := symbolToTypeNode(parent, context, SymbolFlagsType, typeArgumentSlice) /* as TypeReferenceNode | ImportTypeNode */
								restoreFlags()
								// TODO(TS-TO-GO): converted from conditional expression
								switch {
								case !resultType:
									resultType = ref
								default:
									resultType = appendReferenceToType(resultType, ref /* as TypeReferenceNode */)
								}
							}
						}
					}
					var typeArgumentNodes *[]TypeNode
					if typeArguments.length > 0 {
						typeParameterCount := 0
						if type_.target.typeParameters {
							typeParameterCount = Math.min(type_.target.typeParameters.length, typeArguments.length)
							// Maybe we should do this for more types, but for now we only elide type arguments that are
							// identical to their associated type parameters' defaults for `Iterable`, `IterableIterator`,
							// `AsyncIterable`, and `AsyncIterableIterator` to provide backwards-compatible .d.ts emit due
							// to each now having three type parameters instead of only one.
							if isReferenceToType(type_, getGlobalIterableType(false)) || isReferenceToType(type_, getGlobalIterableIteratorType(false)) || isReferenceToType(type_, getGlobalAsyncIterableType(false)) || isReferenceToType(type_, getGlobalAsyncIterableIteratorType(false)) {
								if !type_.node || !isTypeReferenceNode(type_.node) || !type_.node.typeArguments || type_.node.typeArguments.length < typeParameterCount {
									for typeParameterCount > 0 {
										typeArgument := typeArguments[typeParameterCount-1]
										typeParameter := type_.target.typeParameters[typeParameterCount-1]
										defaultType := getDefaultFromTypeParameter(typeParameter)
										if !defaultType || !isTypeIdenticalTo(typeArgument, defaultType) {
											break
										}
										typeParameterCount--
									}
								}
							}
						}
						typeArgumentNodes = mapToTypeNodes(typeArguments.slice(i, typeParameterCount), context)
					}
					restoreFlags := saveRestoreFlags(context)
					context.flags |= NodeBuilderFlagsForbidIndexedAccessSymbolReferences
					finalRef := symbolToTypeNode(type_.symbol, context, SymbolFlagsType, typeArgumentNodes)
					restoreFlags()
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case !resultType:
						return finalRef
					default:
						return appendReferenceToType(resultType, finalRef /* as TypeReferenceNode */)
					}
				}
			}
			appendReferenceToType := func(root /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ImportTypeNode */ any, ref TypeReferenceNode) /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ImportTypeNode */ any {
				if isImportTypeNode(root) {
					// first shift type arguments
					typeArguments := root.typeArguments
					qualifier := root.qualifier
					if qualifier {
						if isIdentifier(qualifier) {
							if typeArguments != getIdentifierTypeArguments(qualifier) {
								qualifier = setIdentifierTypeArguments(factory.cloneNode(qualifier), typeArguments)
							}
						} else {
							if typeArguments != getIdentifierTypeArguments(qualifier.right) {
								qualifier = factory.updateQualifiedName(qualifier, qualifier.left, setIdentifierTypeArguments(factory.cloneNode(qualifier.right), typeArguments))
							}
						}
					}
					typeArguments = ref.typeArguments
					// then move qualifiers
					ids := getAccessStack(ref)
					for _, id := range ids {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case qualifier:
							qualifier = factory.createQualifiedName(qualifier, id)
						default:
							qualifier = id
						}
					}
					return factory.updateImportTypeNode(root, root.argument, root.attributes, qualifier, typeArguments, root.isTypeOf)
				} else {
					// first shift type arguments
					typeArguments := root.typeArguments
					typeName := root.typeName
					if isIdentifier(typeName) {
						if typeArguments != getIdentifierTypeArguments(typeName) {
							typeName = setIdentifierTypeArguments(factory.cloneNode(typeName), typeArguments)
						}
					} else {
						if typeArguments != getIdentifierTypeArguments(typeName.right) {
							typeName = factory.updateQualifiedName(typeName, typeName.left, setIdentifierTypeArguments(factory.cloneNode(typeName.right), typeArguments))
						}
					}
					typeArguments = ref.typeArguments
					// then move qualifiers
					ids := getAccessStack(ref)
					for _, id := range ids {
						typeName = factory.createQualifiedName(typeName, id)
					}
					return factory.updateTypeReferenceNode(root, typeName, typeArguments)
				}
			}
			getAccessStack := func(ref TypeReferenceNode) []Identifier {
				state := ref.typeName
				ids := []never{}
				for !isIdentifier(state) {
					ids.unshift(state.right)
					state = state.left
				}
				ids.unshift(state)
				return ids
			}
			createTypeNodesFromResolvedType := func(resolvedType ResolvedType) *[]TypeElement {
				if checkTruncationLength(context) {
					return []PropertySignature{factory.createPropertySignature(nil, "..." /*questionToken*/, nil /*type*/, nil)}
				}
				var typeElements []TypeElement = []never{}
				for _, signature := range resolvedType.callSignatures {
					typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKindCallSignature, context) /* as CallSignatureDeclaration */)
				}
				for _, signature := range resolvedType.constructSignatures {
					if signature.flags & SignatureFlagsAbstract {
						continue
					}
					typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKindConstructSignature, context) /* as ConstructSignatureDeclaration */)
				}
				for _, info := range resolvedType.indexInfos {
					typeElements.push(indexInfoToIndexSignatureDeclarationHelper(info, context, __COND__(resolvedType.objectFlags&ObjectFlagsReverseMapped, createElidedInformationPlaceholder(context), nil)))
				}
				properties := resolvedType.properties
				if !properties {
					return typeElements
				}
				i := 0
				for _, propertySymbol := range properties {
					i++
					if context.flags & NodeBuilderFlagsWriteClassExpressionAsTypeLiteral {
						if propertySymbol.flags & SymbolFlagsPrototype {
							continue
						}
						if getDeclarationModifierFlagsFromSymbol(propertySymbol)&(ModifierFlagsPrivate|ModifierFlagsProtected) && context.tracker.reportPrivateInBaseOfClassExpression {
							context.tracker.reportPrivateInBaseOfClassExpression(unescapeLeadingUnderscores(propertySymbol.escapedName))
						}
					}
					if checkTruncationLength(context) && (i+2 < properties.length-1) {
						typeElements.push(factory.createPropertySignature(nil, __TEMPLATE__("... ", properties.length-i, " more ...") /*questionToken*/, nil /*type*/, nil))
						addPropertyToElementList(properties[properties.length-1], context, typeElements)
						break
					}
					addPropertyToElementList(propertySymbol, context, typeElements)
				}
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case typeElements.length:
					return typeElements
				default:
					return nil
				}
			}
		}
		createElidedInformationPlaceholder := func(context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type TypeReferenceNode | KeywordTypeNode<SyntaxKind.AnyKeyword> */ any {
			context.approximateLength += 3
			if !(context.flags & NodeBuilderFlagsNoTruncation) {
				return factory.createTypeReferenceNode(factory.createIdentifier("...") /*typeArguments*/, nil)
			}
			return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
		}
		shouldUsePlaceholderForProperty := func(propertySymbol Symbol, context NodeBuilderContext) bool {
			// Use placeholders for reverse mapped types we've either
			// (1) already descended into, or
			// (2) are nested reverse mappings within a mapping over a non-anonymous type, or
			// (3) are deeply nested properties that originate from the same mapped type.
			// Condition (2) is a restriction mostly just to
			// reduce the blowup in printback size from doing, eg, a deep reverse mapping over `Window`.
			// Since anonymous types usually come from expressions, this allows us to preserve the output
			// for deep mappings which likely come from expressions, while truncating those parts which
			// come from mappings over library functions.
			// Condition (3) limits printing of possibly infinitely deep reverse mapped types.
			depth := 3
			return !!(getCheckFlags(propertySymbol) & CheckFlagsReverseMapped) && (contains(context.reverseMappedStack, propertySymbol /* as ReverseMappedSymbol */) || (context.reverseMappedStack[0] && !(getObjectFlags(last(context.reverseMappedStack).links.propertyType) & ObjectFlagsAnonymous)) || isDeeplyNestedReverseMappedTypeProperty())
			isDeeplyNestedReverseMappedTypeProperty := func() bool {
				if ( /* TODO(TS-TO-GO) Node BinaryExpression: context.reverseMappedStack?.length ?? 0 */ TODO) < depth {
					return false
				}
				for i := 0; i < depth; i++ {
					prop := context.reverseMappedStack[context.reverseMappedStack.length-1-i]
					if prop.links.mappedType.symbol != (propertySymbol /* as ReverseMappedSymbol */).links.mappedType.symbol {
						return false
					}
				}
				return true
			}
		}
		addPropertyToElementList := func(propertySymbol Symbol, context NodeBuilderContext, typeElements []TypeElement) {
			propertyIsReverseMapped := !!(getCheckFlags(propertySymbol) & CheckFlagsReverseMapped)
			var propertyType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case shouldUsePlaceholderForProperty(propertySymbol, context):
				propertyType = anyType
			default:
				propertyType = getNonMissingTypeOfSymbol(propertySymbol)
			}
			saveEnclosingDeclaration := context.enclosingDeclaration
			context.enclosingDeclaration = nil
			if context.tracker.canTrackSymbol && isLateBoundName(propertySymbol.escapedName) {
				if propertySymbol.declarations {
					decl := first(propertySymbol.declarations)
					if hasLateBindableName(decl) {
						if isBinaryExpression(decl) {
							name := getNameOfDeclaration(decl)
							if name && isElementAccessExpression(name) && isPropertyAccessEntityNameExpression(name.argumentExpression) {
								trackComputedName(name.argumentExpression, saveEnclosingDeclaration, context)
							}
						} else {
							trackComputedName(decl.name.expression, saveEnclosingDeclaration, context)
						}
					}
				} else {
					context.tracker.reportNonSerializableProperty(symbolToString(propertySymbol))
				}
			}
			context.enclosingDeclaration = propertySymbol.valueDeclaration || propertySymbol.declarations[0] || saveEnclosingDeclaration
			propertyName := getPropertyNameNodeForSymbol(propertySymbol, context)
			context.enclosingDeclaration = saveEnclosingDeclaration
			context.approximateLength += symbolName(propertySymbol).length + 1
			if propertySymbol.flags & SymbolFlagsAccessor {
				writeType := getWriteTypeOfSymbol(propertySymbol)
				if propertyType != writeType && !isErrorType(propertyType) && !isErrorType(writeType) {
					getterDeclaration := getDeclarationOfKind(propertySymbol, SyntaxKindGetAccessor)
					getterSignature := getSignatureFromDeclaration(getterDeclaration)
					typeElements.push(setCommentRange(context, signatureToSignatureDeclarationHelper(getterSignature, SyntaxKindGetAccessor, context, map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"name": propertyName,
					}), /* as GetAccessorDeclaration */ getterDeclaration))
					setterDeclaration := getDeclarationOfKind(propertySymbol, SyntaxKindSetAccessor)
					setterSignature := getSignatureFromDeclaration(setterDeclaration)
					typeElements.push(setCommentRange(context, signatureToSignatureDeclarationHelper(setterSignature, SyntaxKindSetAccessor, context, map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"name": propertyName,
					}), /* as SetAccessorDeclaration */ setterDeclaration))
					return
				}
			}
			var optionalToken * /* TODO(TS-TO-GO) inferred type PunctuationToken<SyntaxKind.QuestionToken> */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case propertySymbol.flags & SymbolFlagsOptional:
				optionalToken = factory.createToken(SyntaxKindQuestionToken)
			default:
				optionalToken = nil
			}
			if propertySymbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod) && !getPropertiesOfObjectType(propertyType).length && !isReadonlySymbol(propertySymbol) {
				signatures := getSignaturesOfType(filterType(propertyType, func(t Type) bool {
					return !(t.flags & TypeFlagsUndefined)
				}), SignatureKindCall)
				for _, signature := range signatures {
					methodDeclaration := signatureToSignatureDeclarationHelper(signature, SyntaxKindMethodSignature, context, map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"name":          propertyName,
						"questionToken": optionalToken,
					}) /* as MethodSignature */
					typeElements.push(preserveCommentsOn(methodDeclaration))
				}
				if signatures.length || !optionalToken {
					return
				}
			}
			var propertyTypeNode TypeNode
			if shouldUsePlaceholderForProperty(propertySymbol, context) {
				propertyTypeNode = createElidedInformationPlaceholder(context)
			} else {
				if propertyIsReverseMapped {
					/* TODO(TS-TO-GO) Node BinaryExpression: context.reverseMappedStack ||= [] */ TODO
					context.reverseMappedStack.push(propertySymbol /* as ReverseMappedSymbol */)
				}
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case propertyType:
					propertyTypeNode = serializeTypeForDeclaration(context /*declaration*/, nil, propertyType, propertySymbol)
				default:
					propertyTypeNode = factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
				}
				if propertyIsReverseMapped {
					context.reverseMappedStack.pop()
				}
			}
			var modifiers *[] /* TODO(TS-TO-GO) inferred type ModifierToken<SyntaxKind.ReadonlyKeyword> */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isReadonlySymbol(propertySymbol):
				modifiers = [] /* TODO(TS-TO-GO) inferred type ModifierToken<SyntaxKind.ReadonlyKeyword> */ any{factory.createToken(SyntaxKindReadonlyKeyword)}
			default:
				modifiers = nil
			}
			if modifiers {
				context.approximateLength += 9
			}
			propertySignature := factory.createPropertySignature(modifiers, propertyName, optionalToken, propertyTypeNode)
			typeElements.push(preserveCommentsOn(propertySignature))
			preserveCommentsOn := func(node T) T {
				jsdocPropertyTag := propertySymbol.declarations. /* TODO(TS-TO-GO): was ? */ find(func(d Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: d is JSDocPropertyTag */ any {
					return d.kind == SyntaxKindJSDocPropertyTag
				})
				if jsdocPropertyTag {
					commentText := getTextOfJSDocComment(jsdocPropertyTag.comment)
					if commentText {
						setSyntheticLeadingComments(node, [] /* TODO(TS-TO-GO) inferred type { kind: SyntaxKind.MultiLineCommentTrivia; text: string; pos: -1; end: -1; hasTrailingNewLine: true; } */ any{map[any]any{ /* TODO(TS-TO-GO): was object literal */
							"kind":               SyntaxKindMultiLineCommentTrivia,
							"text":               "*\n * " + commentText.replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\n/g */ TODO, "\n * ") + "\n ",
							"pos":                -1,
							"end":                -1,
							"hasTrailingNewLine": true,
						}})
					}
				} else if propertySymbol.valueDeclaration {
					// Copy comments to node for declaration emit
					setCommentRange(context, node, propertySymbol.valueDeclaration)
				}
				return node
			}
		}
		setCommentRange := func(context NodeBuilderContext, node T, range_ Node) T {
			if context.enclosingFile && context.enclosingFile == getSourceFileOfNode(range_) {
				// Copy comments to node for declaration emit
				return setCommentRangeWorker(node, range_)
			}
			return node
		}
		mapToTypeNodes := func(types *[]Type, context NodeBuilderContext, isBareList bool) *[]TypeNode {
			if some(types) {
				if checkTruncationLength(context) {
					if !isBareList {
						return []TypeReferenceNode{factory.createTypeReferenceNode("..." /*typeArguments*/, nil)}
					} else if types.length > 2 {
						return []TypeNode{typeToTypeNodeHelper(types[0], context), factory.createTypeReferenceNode(__TEMPLATE__("... ", types.length-2, " more ...") /*typeArguments*/, nil), typeToTypeNodeHelper(types[types.length-1], context)}
					}
				}
				mayHaveNameCollisions := !(context.flags & NodeBuilderFlagsUseFullyQualifiedType)
				/** Map from type reference identifier text to [type, index in `result` where the type node is] */
				var seenNames * /* TODO(TS-TO-GO) inferred type MultiMap<__String, [Type, number]> */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case mayHaveNameCollisions:
					seenNames = createMultiMap()
				default:
					seenNames = nil
				}
				var result []TypeNode = []never{}
				i := 0
				for _, type_ := range types {
					i++
					if checkTruncationLength(context) && (i+2 < types.length-1) {
						result.push(factory.createTypeReferenceNode(__TEMPLATE__("... ", types.length-i, " more ...") /*typeArguments*/, nil))
						typeNode := typeToTypeNodeHelper(types[types.length-1], context)
						if typeNode {
							result.push(typeNode)
						}
						break
					}
					context.approximateLength += 2
					// Account for whitespace + separator
					typeNode := typeToTypeNodeHelper(type_, context)
					if typeNode {
						result.push(typeNode)
						if seenNames && isIdentifierTypeReference(typeNode) {
							seenNames.add(typeNode.typeName.escapedText, []any{type_, result.length - 1})
						}
					}
				}
				if seenNames {
					// To avoid printing types like `[Foo, Foo]` or `Bar & Bar` where
					// occurrences of the same name actually come from different
					// namespaces, go through the single-identifier type reference nodes
					// we just generated, and see if any names were generated more than
					// once while referring to different types. If so, regenerate the
					// type node for each entry by that name with the
					// `UseFullyQualifiedType` flag enabled.
					restoreFlags := saveRestoreFlags(context)
					context.flags |= NodeBuilderFlagsUseFullyQualifiedType
					seenNames.forEach(func(types [] /* TODO(TS-TO-GO) inferred type [Type, number] */ any) {
						if !arrayIsHomogeneous(types, func(TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [Type, number] */ any, TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [Type, number] */ any) bool {
							return typesAreSameReference(a, b)
						}) {
							for _, TODO_IDENTIFIER := range types {
								result[resultIndex] = typeToTypeNodeHelper(type_, context)
							}
						}
					})
					restoreFlags()
				}
				return result
			}
		}
		typesAreSameReference := func(a Type, b Type) bool {
			return a == b || !!a.symbol && a.symbol == b.symbol || !!a.aliasSymbol && a.aliasSymbol == b.aliasSymbol
		}
		indexInfoToIndexSignatureDeclarationHelper := func(indexInfo IndexInfo, context NodeBuilderContext, typeNode *TypeNode) IndexSignatureDeclaration {
			name := getNameFromIndexInfo(indexInfo) || "x"
			indexerTypeNode := typeToTypeNodeHelper(indexInfo.keyType, context)
			indexingParameter := factory.createParameterDeclaration(nil, nil, name, nil, indexerTypeNode, nil)
			if !typeNode {
				typeNode = typeToTypeNodeHelper(indexInfo.type_ || anyType, context)
			}
			if !indexInfo.type_ && !(context.flags & NodeBuilderFlagsAllowEmptyIndexInfoType) {
				context.encounteredError = true
			}
			context.approximateLength += name.length + 4
			return factory.createIndexSignature(__COND__(indexInfo.isReadonly, [] /* TODO(TS-TO-GO) inferred type ModifierToken<SyntaxKind.ReadonlyKeyword> */ any{factory.createToken(SyntaxKindReadonlyKeyword)}, nil), []ParameterDeclaration{indexingParameter}, typeNode)
		}
		type SignatureToSignatureDeclarationOptions struct {
			modifiers     []Modifier
			name          PropertyName
			questionToken QuestionToken
		}
		signatureToSignatureDeclarationHelper := func(signature Signature, kind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: SignatureDeclaration["kind"] */ any, context NodeBuilderContext, options SignatureToSignatureDeclarationOptions) SignatureDeclaration {
			var typeParameters *[]TypeParameterDeclaration
			var typeArguments *[]TypeNode
			expandedParams := getExpandedParameters(signature /*skipUnionExpanding*/, true)[0]
			cleanup := enterNewScope(context, signature.declaration, expandedParams, signature.typeParameters, signature.parameters, signature.mapper)
			context.approximateLength += 3
			// Usually a signature contributes a few more characters than this, but 3 is the minimum
			if context.flags&NodeBuilderFlagsWriteTypeArgumentsOfSignature && signature.target && signature.mapper && signature.target.typeParameters {
				typeArguments = signature.target.typeParameters.map_(func(parameter TypeParameter) TypeNode {
					return typeToTypeNodeHelper(instantiateType(parameter, signature.mapper), context)
				})
			} else {
				typeParameters = signature.typeParameters && signature.typeParameters.map_(func(parameter TypeParameter) TypeParameterDeclaration {
					return typeParameterToDeclaration(parameter, context)
				})
			}
			restoreFlags := saveRestoreFlags(context)
			context.flags &= ~NodeBuilderFlagsSuppressAnyReturnType
			// If the expanded parameter list had a variadic in a non-trailing position, don't expand it
			parameters := (__COND__(some(expandedParams, func(p Symbol) bool {
				return p != expandedParams[expandedParams.length-1] && !!(getCheckFlags(p) & CheckFlagsRestParameter)
			}), signature.parameters, expandedParams)).map_(func(parameter Symbol) ParameterDeclaration {
				return symbolToParameterDeclaration(parameter, context, kind == SyntaxKindConstructor)
			})
			var thisParameter *ParameterDeclaration
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case context.flags & NodeBuilderFlagsOmitThisParameter:
				thisParameter = nil
			default:
				thisParameter = tryGetThisParameterDeclaration(signature, context)
			}
			if thisParameter {
				parameters.unshift(thisParameter)
			}
			restoreFlags()
			returnTypeNode := serializeReturnTypeForSignature(context, signature)
			modifiers := options. /* TODO(TS-TO-GO): was ? */ modifiers
			if (kind == SyntaxKindConstructorType) && signature.flags&SignatureFlagsAbstract {
				flags := modifiersToFlags(modifiers)
				modifiers = factory.createModifiersFromModifierFlags(flags | ModifierFlagsAbstract)
			}
			var node /* TODO(TS-TO-GO) inferred type SetAccessorDeclaration | MethodDeclaration | GetAccessorDeclaration | CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | FunctionDeclaration | ConstructorDeclaration | FunctionExpression | ArrowFunction */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case kind == SyntaxKindCallSignature:
				node = factory.createCallSignature(typeParameters, parameters, returnTypeNode)
			case kind == SyntaxKindConstructSignature:
				node = factory.createConstructSignature(typeParameters, parameters, returnTypeNode)
			case kind == SyntaxKindMethodSignature:
				node = factory.createMethodSignature(modifiers /* TODO(TS-TO-GO) Node BinaryExpression: options?.name ?? factory.createIdentifier("") */, TODO, options. /* TODO(TS-TO-GO): was ? */ questionToken, typeParameters, parameters, returnTypeNode)
			case kind == SyntaxKindMethodDeclaration:
				node = factory.createMethodDeclaration(modifiers /*asteriskToken*/, nil /* TODO(TS-TO-GO) Node BinaryExpression: options?.name ?? factory.createIdentifier("") */, TODO /*questionToken*/, nil, typeParameters, parameters, returnTypeNode /*body*/, nil)
			case kind == SyntaxKindConstructor:
				node = factory.createConstructorDeclaration(modifiers, parameters /*body*/, nil)
			case kind == SyntaxKindGetAccessor:
				node = factory.createGetAccessorDeclaration(modifiers /* TODO(TS-TO-GO) Node BinaryExpression: options?.name ?? factory.createIdentifier("") */, TODO, parameters, returnTypeNode /*body*/, nil)
			case kind == SyntaxKindSetAccessor:
				node = factory.createSetAccessorDeclaration(modifiers /* TODO(TS-TO-GO) Node BinaryExpression: options?.name ?? factory.createIdentifier("") */, TODO, parameters /*body*/, nil)
			case kind == SyntaxKindIndexSignature:
				node = factory.createIndexSignature(modifiers, parameters, returnTypeNode)
			case kind == SyntaxKindJSDocFunctionType:
				node = factory.createJSDocFunctionType(parameters, returnTypeNode)
			case kind == SyntaxKindFunctionType:
				node = factory.createFunctionTypeNode(typeParameters, parameters /* TODO(TS-TO-GO) Node BinaryExpression: returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier("")) */, TODO)
			case kind == SyntaxKindConstructorType:
				node = factory.createConstructorTypeNode(modifiers, typeParameters, parameters /* TODO(TS-TO-GO) Node BinaryExpression: returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier("")) */, TODO)
			case kind == SyntaxKindFunctionDeclaration:
				node = factory.createFunctionDeclaration(modifiers /*asteriskToken*/, nil, __COND__(options. /* TODO(TS-TO-GO): was ? */ name, cast(options.name, isIdentifier), factory.createIdentifier("")), typeParameters, parameters, returnTypeNode /*body*/, nil)
			case kind == SyntaxKindFunctionExpression:
				node = factory.createFunctionExpression(modifiers /*asteriskToken*/, nil, __COND__(options. /* TODO(TS-TO-GO): was ? */ name, cast(options.name, isIdentifier), factory.createIdentifier("")), typeParameters, parameters, returnTypeNode, factory.createBlock([]never{}))
			case kind == SyntaxKindArrowFunction:
				node = factory.createArrowFunction(modifiers, typeParameters, parameters, returnTypeNode /*equalsGreaterThanToken*/, nil, factory.createBlock([]never{}))
			default:
				node = Debug.assertNever(kind)
			}
			if typeArguments {
				node.typeArguments = factory.createNodeArray(typeArguments)
			}
			if signature.declaration. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindJSDocSignature && signature.declaration.parent.kind == SyntaxKindJSDocOverloadTag {
				comment := getTextOfNode(signature.declaration.parent.parent /*includeTrivia*/, true).slice(2, -2).split(regexp.MustParse(`\r\n|\n|\r`)).map_(func(line string) string {
					return line.replace(regexp.MustParse(`^\s+`), " ")
				}).join("\n")
				addSyntheticLeadingComment(node, SyntaxKindMultiLineCommentTrivia, comment /*hasTrailingNewLine*/, true)
			}
			cleanup()
			return node
		}
		type IntroducesNewScopeNode /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature | MappedTypeNode */ any
		isNewScopeNode := func(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is IntroducesNewScopeNode */ any {
			return isFunctionLike(node) || isJSDocSignature(node) || isMappedTypeNode(node)
		}
		getTypeParametersInScope := func(node /* TODO(TS-TO-GO) TypeNode UnionType: IntroducesNewScopeNode | ConditionalTypeNode */ any) *[]TypeParameter {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isFunctionLike(node) || isJSDocSignature(node):
				return getSignatureFromDeclaration(node).typeParameters
			case isConditionalTypeNode(node):
				return getInferTypeParameters(node)
			default:
				return []TypeParameter{getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter))}
			}
		}
		getParametersInScope := func(node /* TODO(TS-TO-GO) TypeNode UnionType: IntroducesNewScopeNode | ConditionalTypeNode */ any) *[]Symbol {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isFunctionLike(node) || isJSDocSignature(node):
				return getSignatureFromDeclaration(node).parameters
			default:
				return nil
			}
		}
		enterNewScope := func(context NodeBuilderContext, declaration /* TODO(TS-TO-GO) TypeNode UnionType: IntroducesNewScopeNode | ConditionalTypeNode | undefined */ any, expandedParams *[]Symbol, typeParameters *[]TypeParameter, originalParameters *[]Symbol, mapper TypeMapper) /* TODO(TS-TO-GO) inferred type () => void */ any {
			cleanupContext := cloneNodeBuilderContext(context)
			// For regular function/method declarations, the enclosing declaration will already be signature.declaration,
			// so this is a no-op, but for arrow functions and function expressions, the enclosing declaration will be
			// the declaration that the arrow function / function expression is assigned to.
			//
			// If the parameters or return type include "typeof globalThis.paramName", using the wrong scope will lead
			// us to believe that we can emit "typeof paramName" instead, even though that would refer to the parameter,
			// not the global. Make sure we are in the right scope by changing the enclosingDeclaration to the function.
			//
			// We can't use the declaration directly; it may be in another file and so we may lose access to symbols
			// accessible to the current enclosing declaration, or gain access to symbols not accessible to the current
			// enclosing declaration. To keep this chain accurate, insert a fake scope into the chain which makes the
			// function's parameters visible.
			var cleanupParams *func()
			var cleanupTypeParams *func()
			oldEnclosingDecl := context.enclosingDeclaration
			oldMapper := context.mapper
			if mapper {
				context.mapper = mapper
			}
			if context.enclosingDeclaration && declaration {
				// As a performance optimization, reuse the same fake scope within this chain.
				// This is especially needed when we are working on an excessively deep type;
				// if we don't do this, then we spend all of our time adding more and more
				// scopes that need to be searched in isSymbolAccessible later. Since all we
				// really want to do is to mark certain names as unavailable, we can just keep
				// all of the names we're introducing in one large table and push/pop from it as
				// needed; isSymbolAccessible will walk upward and find the closest "fake" scope,
				// which will conveniently report on any and all faked scopes in the chain.
				//
				// It'd likely be better to store this somewhere else for isSymbolAccessible, but
				// since that API _only_ uses the enclosing declaration (and its parents), this is
				// seems like the best way to inject names into that search process.
				//
				// Note that we only check the most immediate enclosingDeclaration; the only place we
				// could potentially add another fake scope into the chain is right here, so we don't
				// traverse all ancestors.
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case !some(expandedParams):
					cleanupParams = nil
				default:
					cleanupParams = pushFakeScope("params", func(add /* TODO(TS-TO-GO) inferred type (name: __String, symbol: Symbol) => void */ any) {
						if !expandedParams {
							return
						}
						for pIndex := 0; pIndex < expandedParams.length; pIndex++ {
							param := expandedParams[pIndex]
							originalParam := originalParameters[pIndex]
							if originalParameters && originalParam != param {
								// Can't reference parameters that come from an expansion
								add(param.escapedName, unknownSymbol)
								// Can't reference the original expanded parameter either
								if originalParam {
									add(originalParam.escapedName, unknownSymbol)
								}
							} else if !forEach(param.declarations, func(d Declaration) *true {
								if isParameter(d) && isBindingPattern(d.name) {
									bindPattern(d.name)
									return true
								}
								return nil
								bindPattern := func(p BindingPattern) {
									forEach(p.elements, func(e /* TODO(TS-TO-GO) inferred type BindingElement | OmittedExpression */ any) {
										switch e.kind {
										case SyntaxKindOmittedExpression:
											return
										case SyntaxKindBindingElement:
											return bindElement(e)
										default:
											return Debug.assertNever(e)
										}
									})
								}
								bindElement := func(e BindingElement) {
									if isBindingPattern(e.name) {
										return bindPattern(e.name)
									}
									symbol := getSymbolOfDeclaration(e)
									add(symbol.escapedName, symbol)
								}
							}) {
								add(param.escapedName, param)
							}
						}
					})
				}
				if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && some(typeParameters) {
					cleanupTypeParams = pushFakeScope("typeParams", func(add /* TODO(TS-TO-GO) inferred type (name: __String, symbol: Symbol) => void */ any) {
						for _, typeParam := range /* TODO(TS-TO-GO) Node BinaryExpression: typeParameters ?? emptyArray */ TODO {
							typeParamName := typeParameterToName(typeParam, context).escapedText
							add(typeParamName, typeParam.symbol)
						}
					})
				}
				pushFakeScope := func(kind /* TODO(TS-TO-GO) TypeNode UnionType: "params" | "typeParams" */ any, addAll func(addSymbol func(name __String, symbol Symbol))) * /* TODO(TS-TO-GO) inferred type (() => void) */ any {
					// We only ever need to look two declarations upward.
					Debug.assert(context.enclosingDeclaration)
					var existingFakeScope Node
					if getNodeLinks(context.enclosingDeclaration).fakeScopeForSignatureDeclaration == kind {
						existingFakeScope = context.enclosingDeclaration
					} else if context.enclosingDeclaration.parent && getNodeLinks(context.enclosingDeclaration.parent).fakeScopeForSignatureDeclaration == kind {
						existingFakeScope = context.enclosingDeclaration.parent
					}
					Debug.assertOptionalNode(existingFakeScope, isBlock)
					locals := /* TODO(TS-TO-GO) Node BinaryExpression: existingFakeScope?.locals ?? createSymbolTable() */ TODO
					var newLocals *[]__String
					var oldLocals *[] /* TODO(TS-TO-GO) TypeNode TypeLiteral: { name: __String; oldSymbol: Symbol; } */ any
					addAll(func(name __String, symbol Symbol) {
						// Add cleanup information only if we don't own the fake scope
						if existingFakeScope {
							oldSymbol := locals.get(name)
							if !oldSymbol {
								newLocals = append(newLocals, name)
							} else {
								oldLocals = append(oldLocals, map[any]any{ /* TODO(TS-TO-GO): was object literal */
									"name":      name,
									"oldSymbol": oldSymbol,
								})
							}
						}
						locals.set(name, symbol)
					})
					if !existingFakeScope {
						// Use a Block for this; the type of the node doesn't matter so long as it
						// has locals, and this is cheaper/easier than using a function-ish Node.
						fakeScope := factory.createBlock(emptyArray)
						getNodeLinks(fakeScope).fakeScopeForSignatureDeclaration = kind
						fakeScope.locals = locals
						setParent(fakeScope, context.enclosingDeclaration)
						context.enclosingDeclaration = fakeScope
					} else {
						// We did not create the current scope, so we have to clean it up
						return func /* undo */ () {
							forEach(newLocals, func(s __String) bool {
								return locals.delete(s)
							})
							forEach(oldLocals, func(s /* TODO(TS-TO-GO) inferred type { name: __String; oldSymbol: Symbol; } */ any) SymbolTable {
								return locals.set(s.name, s.oldSymbol)
							})
						}
					}
				}
			}
			return func() {
				cleanupParams()
				cleanupTypeParams()
				cleanupContext()
				context.enclosingDeclaration = oldEnclosingDecl
				context.mapper = oldMapper
			}
		}
		tryGetThisParameterDeclaration := func(signature Signature, context NodeBuilderContext) *ParameterDeclaration {
			if signature.thisParameter {
				return symbolToParameterDeclaration(signature.thisParameter, context)
			}
			if signature.declaration && isInJSFile(signature.declaration) {
				thisTag := getJSDocThisTag(signature.declaration)
				if thisTag && thisTag.typeExpression {
					return factory.createParameterDeclaration(nil, nil, "this", nil, typeToTypeNodeHelper(getTypeFromTypeNode(context, thisTag.typeExpression), context))
				}
			}
		}
		typeParameterToDeclarationWithConstraint := func(type_ TypeParameter, context NodeBuilderContext, constraintNode *TypeNode) TypeParameterDeclaration {
			restoreFlags := saveRestoreFlags(context)
			context.flags &= ~NodeBuilderFlagsWriteTypeParametersInQualifiedName
			// Avoids potential infinite loop when building for a claimspace with a generic
			modifiers := factory.createModifiersFromModifierFlags(getTypeParameterModifiers(type_))
			name := typeParameterToName(type_, context)
			defaultParameter := getDefaultFromTypeParameter(type_)
			defaultParameterNode := defaultParameter && typeToTypeNodeHelper(defaultParameter, context)
			restoreFlags()
			return factory.createTypeParameterDeclaration(modifiers, name, constraintNode, defaultParameterNode)
		}
		typeToTypeNodeHelperWithPossibleReusableTypeNode := func(type_ Type, typeNode *TypeNode, context NodeBuilderContext) TypeNode {
			return typeNode && tryReuseExistingNonParameterTypeNode(context, typeNode, type_) || typeToTypeNodeHelper(type_, context)
		}
		typeParameterToDeclaration := func(type_ TypeParameter, context NodeBuilderContext, constraint Type /*  = getConstraintOfTypeParameter(type) */) TypeParameterDeclaration {
			constraintNode := constraint && typeToTypeNodeHelperWithPossibleReusableTypeNode(constraint, getConstraintDeclaration(type_), context)
			return typeParameterToDeclarationWithConstraint(type_, context, constraintNode)
		}
		typePredicateToTypePredicateNodeHelper := func(typePredicate TypePredicate, context NodeBuilderContext) TypePredicateNode {
			var assertsModifier * /* TODO(TS-TO-GO) inferred type KeywordToken<SyntaxKind.AssertsKeyword> */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case typePredicate.kind == TypePredicateKindAssertsThis || typePredicate.kind == TypePredicateKindAssertsIdentifier:
				assertsModifier = factory.createToken(SyntaxKindAssertsKeyword)
			default:
				assertsModifier = nil
			}
			var parameterName /* TODO(TS-TO-GO) inferred type Identifier | ThisTypeNode */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case typePredicate.kind == TypePredicateKindIdentifier || typePredicate.kind == TypePredicateKindAssertsIdentifier:
				parameterName = setEmitFlags(factory.createIdentifier(typePredicate.parameterName), EmitFlagsNoAsciiEscaping)
			default:
				parameterName = factory.createThisTypeNode()
			}
			typeNode := typePredicate.type_ && typeToTypeNodeHelper(typePredicate.type_, context)
			return factory.createTypePredicateNode(assertsModifier, parameterName, typeNode)
		}
		getEffectiveParameterDeclaration := func(parameterSymbol Symbol) /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag | undefined */ any {
			var parameterDeclaration /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag | undefined */ any = getDeclarationOfKind(parameterSymbol, SyntaxKindParameter)
			if parameterDeclaration {
				return parameterDeclaration
			}
			if !isTransientSymbol(parameterSymbol) {
				return getDeclarationOfKind(parameterSymbol, SyntaxKindJSDocParameterTag)
			}
		}
		symbolToParameterDeclaration := func(parameterSymbol Symbol, context NodeBuilderContext, preserveModifierFlags bool) ParameterDeclaration {
			parameterDeclaration := getEffectiveParameterDeclaration(parameterSymbol)
			parameterType := getTypeOfSymbol(parameterSymbol)
			parameterTypeNode := serializeTypeForDeclaration(context, parameterDeclaration, parameterType, parameterSymbol)
			var modifiers *[]Modifier
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !(context.flags & NodeBuilderFlagsOmitParameterModifiers) && preserveModifierFlags && parameterDeclaration && canHaveModifiers(parameterDeclaration):
				modifiers = map_(getModifiers(parameterDeclaration), factory.cloneNode)
			default:
				modifiers = nil
			}
			isRest := parameterDeclaration && isRestParameter(parameterDeclaration) || getCheckFlags(parameterSymbol)&CheckFlagsRestParameter
			var dotDotDotToken * /* TODO(TS-TO-GO) inferred type PunctuationToken<SyntaxKind.DotDotDotToken> */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isRest:
				dotDotDotToken = factory.createToken(SyntaxKindDotDotDotToken)
			default:
				dotDotDotToken = nil
			}
			name := parameterToParameterDeclarationName(parameterSymbol, parameterDeclaration, context)
			isOptional := parameterDeclaration && isOptionalParameter(parameterDeclaration) || getCheckFlags(parameterSymbol)&CheckFlagsOptionalParameter
			var questionToken * /* TODO(TS-TO-GO) inferred type PunctuationToken<SyntaxKind.QuestionToken> */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isOptional:
				questionToken = factory.createToken(SyntaxKindQuestionToken)
			default:
				questionToken = nil
			}
			parameterNode := factory.createParameterDeclaration(modifiers, dotDotDotToken, name, questionToken, parameterTypeNode, nil)
			context.approximateLength += symbolName(parameterSymbol).length + 3
			return parameterNode
		}
		parameterToParameterDeclarationName := func(parameterSymbol Symbol, parameterDeclaration /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag | undefined */ any, context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type string | BindingName */ any {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case parameterDeclaration:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case parameterDeclaration.name:
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case parameterDeclaration.name.kind == SyntaxKindIdentifier:
						return setEmitFlags(factory.cloneNode(parameterDeclaration.name), EmitFlagsNoAsciiEscaping)
					case parameterDeclaration.name.kind == SyntaxKindQualifiedName:
						return setEmitFlags(factory.cloneNode(parameterDeclaration.name.right), EmitFlagsNoAsciiEscaping)
					default:
						return cloneBindingName(parameterDeclaration.name)
					}
				default:
					return symbolName(parameterSymbol)
				}
			default:
				return symbolName(parameterSymbol)
			}
			cloneBindingName := func(node BindingName) BindingName {
				return elideInitializerAndSetEmitFlags(node) /* as BindingName */
				elideInitializerAndSetEmitFlags := func(node Node) Node {
					if context.tracker.canTrackSymbol && isComputedPropertyName(node) && isLateBindableName(node) {
						trackComputedName(node.expression, context.enclosingDeclaration, context)
					}
					visited := visitEachChildWorker(node, elideInitializerAndSetEmitFlags /*context*/, nil /*nodesVisitor*/, nil, elideInitializerAndSetEmitFlags)
					if isBindingElement(visited) {
						visited = factory.updateBindingElement(visited, visited.dotDotDotToken, visited.propertyName, visited.name, nil)
					}
					if !nodeIsSynthesized(visited) {
						visited = factory.cloneNode(visited)
					}
					return setEmitFlags(visited, EmitFlagsSingleLine|EmitFlagsNoAsciiEscaping)
				}
			}
		}
		trackComputedName := func(accessExpression EntityNameOrEntityNameExpression, enclosingDeclaration Node, context NodeBuilderContext) {
			if !context.tracker.canTrackSymbol {
				return
			}
			// get symbol of the first identifier of the entityName
			firstIdentifier := getFirstIdentifier(accessExpression)
			name := resolveName(firstIdentifier, firstIdentifier.escapedText, SymbolFlagsValue|SymbolFlagsExportValue /*nameNotFoundMessage*/, nil /*isUse*/, true)
			if name {
				context.tracker.trackSymbol(name, enclosingDeclaration, SymbolFlagsValue)
			}
		}
		lookupSymbolChain := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) []Symbol {
			context.tracker.trackSymbol(symbol, context.enclosingDeclaration, meaning)
			return lookupSymbolChainWorker(symbol, context, meaning, yieldModuleSymbol)
		}
		lookupSymbolChainWorker := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) []Symbol {
			// Try to get qualified name if the symbol is not a type parameter and there is an enclosing declaration.
			var chain []Symbol
			isTypeParameter := symbol.flags & SymbolFlagsTypeParameter
			if !isTypeParameter && (context.enclosingDeclaration || context.flags&NodeBuilderFlagsUseFullyQualifiedType) && !(context.internalFlags & InternalNodeBuilderFlagsDoNotIncludeSymbolChain) {
				chain = Debug.checkDefined(getSymbolChain(symbol, meaning /*endOfChain*/, true))
				Debug.assert(chain && chain.length > 0)
			} else {
				chain = []Symbol{symbol}
			}
			return chain
			/** @param endOfChain Set to false for recursive calls; non-recursive calls should always output something. */
			getSymbolChain := func(symbol Symbol, meaning SymbolFlags, endOfChain bool) *[]Symbol {
				accessibleSymbolChain := getAccessibleSymbolChain(symbol, context.enclosingDeclaration, meaning, !!(context.flags & NodeBuilderFlagsUseOnlyExternalAliasing))
				var parentSpecifiers []*string
				if !accessibleSymbolChain || needsQualification(accessibleSymbolChain[0], context.enclosingDeclaration, __COND__(accessibleSymbolChain.length == 1, meaning, getQualifiedLeftMeaning(meaning))) {
					// Go up and add our parent.
					parents := getContainersOfSymbol(__COND__(accessibleSymbolChain, accessibleSymbolChain[0], symbol), context.enclosingDeclaration, meaning)
					if length(parents) {
						parentSpecifiers = parents.map_(func(symbol Symbol) *string {
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol):
								return getSpecifierForModuleSymbol(symbol, context)
							default:
								return nil
							}
						})
						indices := parents.map_(func(_ Symbol, i number) number {
							return i
						})
						indices.sort(sortByBestName)
						sortedParents := indices.map_(func(i number) Symbol {
							return parents[i]
						})
						for _, parent := range sortedParents {
							parentChain := getSymbolChain(parent, getQualifiedLeftMeaning(meaning) /*endOfChain*/, false)
							if parentChain {
								if parent.exports && parent.exports.get(InternalSymbolNameExportEquals) && getSymbolIfSameReference(parent.exports.get(InternalSymbolNameExportEquals), symbol) {
									// parentChain root _is_ symbol - symbol is a module export=, so it kinda looks like it's own parent
									// No need to lookup an alias for the symbol in itself
									accessibleSymbolChain = parentChain
									break
								}
								accessibleSymbolChain = parentChain.concat(accessibleSymbolChain || []Symbol{getAliasForSymbolInContainer(parent, symbol) || symbol})
								break
							}
						}
					}
				}
				if accessibleSymbolChain {
					return accessibleSymbolChain
				}
				if endOfChain || !(symbol.flags & (SymbolFlagsTypeLiteral | SymbolFlagsObjectLiteral)) {
					// If a parent symbol is an external module, don't write it. (We prefer just `x` vs `"foo/bar".x`.)
					if !endOfChain && !yieldModuleSymbol && !!forEach(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
						return
					}
					return []Symbol{symbol}
				}
				sortByBestName := func(a number, b number) number {
					specifierA := parentSpecifiers[a]
					specifierB := parentSpecifiers[b]
					if specifierA && specifierB {
						isBRelative := pathIsRelative(specifierB)
						if pathIsRelative(specifierA) == isBRelative {
							// Both relative or both non-relative, sort by number of parts
							return moduleSpecifiers.countPathComponents(specifierA) - moduleSpecifiers.countPathComponents(specifierB)
						}
						if isBRelative {
							// A is non-relative, B is relative: prefer A
							return -1
						}
						// A is relative, B is non-relative: prefer B
						return 1
					}
					return 0
				}
			}
		}
		typeParametersToTypeParameterDeclarations := func(symbol Symbol, context NodeBuilderContext) *NodeArray[TypeParameterDeclaration] {
			var typeParameterNodes *NodeArray[TypeParameterDeclaration]
			targetSymbol := getTargetSymbol(symbol)
			if targetSymbol.flags & (SymbolFlagsClass | SymbolFlagsInterface | SymbolFlagsTypeAlias) {
				typeParameterNodes = factory.createNodeArray(map_(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol), func(tp TypeParameter) TypeParameterDeclaration {
					return typeParameterToDeclaration(tp, context)
				}))
			}
			return typeParameterNodes
		}
		lookupTypeParameterNodes := func(chain []Symbol, index number, context NodeBuilderContext) *[] /* TODO(TS-TO-GO) inferred type TypeNode[] | readonly TypeParameterDeclaration */ any {
			Debug.assert(chain && 0 <= index && index < chain.length)
			symbol := chain[index]
			symbolId := getSymbolId(symbol)
			if context.typeParameterSymbolList. /* TODO(TS-TO-GO): was ? */ has(symbolId) {
				return nil
			}
			if context.mustCreateTypeParameterSymbolList {
				context.mustCreateTypeParameterSymbolList = false
				context.typeParameterSymbolList = NewSet(context.typeParameterSymbolList)
			}
			context.typeParameterSymbolList.add(symbolId)
			var typeParameterNodes /* TODO(TS-TO-GO) TypeNode UnionType: readonly TypeNode[] | readonly TypeParameterDeclaration[] | undefined */ any
			if context.flags&NodeBuilderFlagsWriteTypeParametersInQualifiedName && index < (chain.length-1) {
				parentSymbol := symbol
				nextSymbol := chain[index+1]
				if getCheckFlags(nextSymbol) & CheckFlagsInstantiated {
					params := getTypeParametersOfClassOrInterface(__COND__(parentSymbol.flags&SymbolFlagsAlias, resolveAlias(parentSymbol), parentSymbol))
					// NOTE: cast to TransientSymbol should be safe because only TransientSymbol can have CheckFlags.Instantiated
					typeParameterNodes = mapToTypeNodes(map_(params, func(t TypeParameter) Type {
						return getMappedType(t, (nextSymbol /* as TransientSymbol */).links.mapper)
					}), context)
				} else {
					typeParameterNodes = typeParametersToTypeParameterDeclarations(symbol, context)
				}
			}
			return typeParameterNodes
		}
		/**
		 * Given A[B][C][D], finds A[B]
		 */
		getTopmostIndexedAccessType := func(top IndexedAccessTypeNode) IndexedAccessTypeNode {
			if isIndexedAccessTypeNode(top.objectType) {
				return getTopmostIndexedAccessType(top.objectType)
			}
			return top
		}
		getSpecifierForModuleSymbol := func(symbol Symbol, context NodeBuilderContext, overrideImportMode ResolutionMode) string {
			file := getDeclarationOfKind(symbol, SyntaxKindSourceFile)
			if !file {
				equivalentFileSymbol := firstDefined(symbol.declarations, func(d Declaration) Symbol {
					return getFileSymbolIfFileSymbolExportEqualsContainer(d, symbol)
				})
				if equivalentFileSymbol {
					file = getDeclarationOfKind(equivalentFileSymbol, SyntaxKindSourceFile)
				}
			}
			if file && file.moduleName != nil {
				// Use the amd name if it is available
				return file.moduleName
			}
			if !file {
				if ambientModuleSymbolRegex.test(symbol.escapedName /* as string */) {
					return (symbol.escapedName /* as string */).substring(1, (symbol.escapedName /* as string */).length-1)
				}
			}
			if !context.enclosingFile || !context.tracker.moduleResolverHost {
				// If there's no context declaration, we can't lookup a non-ambient specifier, so we just use the symbol name
				if ambientModuleSymbolRegex.test(symbol.escapedName /* as string */) {
					return (symbol.escapedName /* as string */).substring(1, (symbol.escapedName /* as string */).length-1)
				}
				return getSourceFileOfNode(getNonAugmentationDeclaration(symbol)).fileName
				// A resolver may not be provided for baselines and errors - in those cases we use the fileName in full
			}
			enclosingDeclaration := getOriginalNode(context.enclosingDeclaration)
			var originalModuleSpecifier *StringLiteralLike
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case canHaveModuleSpecifier(enclosingDeclaration):
				originalModuleSpecifier = tryGetModuleSpecifierFromDeclaration(enclosingDeclaration)
			default:
				originalModuleSpecifier = nil
			}
			contextFile := context.enclosingFile
			resolutionMode := overrideImportMode || originalModuleSpecifier && host.getModeForUsageLocation(contextFile, originalModuleSpecifier) || contextFile && host.getDefaultResolutionModeForFile(contextFile)
			cacheKey := createModeAwareCacheKey(contextFile.path, resolutionMode)
			links := getSymbolLinks(symbol)
			specifier := links.specifierCache && links.specifierCache.get(cacheKey)
			if !specifier {
				isBundle := !!compilerOptions.outFile
				// For declaration bundles, we need to generate absolute paths relative to the common source dir for imports,
				// just like how the declaration emitter does for the ambient module declarations - we can easily accomplish this
				// using the `baseUrl` compiler option (which we would otherwise never use in declaration emit) and a non-relative
				// specifier preference
				TODO_IDENTIFIER := context.tracker
				var specifierCompilerOptions CompilerOptions
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isBundle:
					specifierCompilerOptions = map[any]any{ /* TODO(TS-TO-GO): was object literal */
						/* TODO(TS-TO-GO) Node SpreadAssignment: ...compilerOptions */
						"baseUrl": moduleResolverHost.getCommonSourceDirectory(),
					}
				default:
					specifierCompilerOptions = compilerOptions
				}
				specifier = first(moduleSpecifiers.getModuleSpecifiers(symbol, checker, specifierCompilerOptions, contextFile, moduleResolverHost, map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"importModuleSpecifierPreference": __COND__(isBundle, "non-relative", "project-relative"),
					"importModuleSpecifierEnding":     __COND__(isBundle, "minimal", __COND__(resolutionMode == ModuleKindESNext, "js", nil)),
				}, map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"overrideImportMode": overrideImportMode,
				}))
				/* TODO(TS-TO-GO) Node BinaryExpression: links.specifierCache ??= new Map() */ TODO
				links.specifierCache.set(cacheKey, specifier)
			}
			return specifier
		}
		symbolToEntityNameNode := func(symbol Symbol) EntityName {
			identifier := factory.createIdentifier(unescapeLeadingUnderscores(symbol.escapedName))
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case symbol.parent:
				return factory.createQualifiedName(symbolToEntityNameNode(symbol.parent), identifier)
			default:
				return identifier
			}
		}
		symbolToTypeNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, overrideTypeArguments []TypeNode) TypeNode {
			chain := lookupSymbolChain(symbol, context, meaning, !(context.flags & NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope))
			// If we're using aliases outside the current scope, dont bother with the module
			isTypeOf := meaning == SymbolFlagsValue
			if some(chain[0].declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
				// module is root, must use `ImportTypeNode`
				var nonRootParts * /* TODO(TS-TO-GO) inferred type EntityName | IndexedAccessTypeNode */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case chain.length > 1:
					nonRootParts = createAccessFromSymbolChain(chain, chain.length-1, 1)
				default:
					nonRootParts = nil
				}
				typeParameterNodes := overrideTypeArguments || lookupTypeParameterNodes(chain, 0, context)
				contextFile := getSourceFileOfNode(getOriginalNode(context.enclosingDeclaration))
				targetFile := getSourceFileOfModule(chain[0])
				var specifier *string
				var attributes *ImportAttributes
				if getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNode16 || getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNodeNext {
					// An `import` type directed at an esm format file is only going to resolve in esm mode - set the esm mode assertion
					if targetFile. /* TODO(TS-TO-GO): was ? */ impliedNodeFormat == ModuleKindESNext && targetFile.impliedNodeFormat != contextFile. /* TODO(TS-TO-GO): was ? */ impliedNodeFormat {
						specifier = getSpecifierForModuleSymbol(chain[0], context, ModuleKindESNext)
						attributes = factory.createImportAttributes(factory.createNodeArray([]ImportAttribute{factory.createImportAttribute(factory.createStringLiteral("resolution-mode"), factory.createStringLiteral("import"))}))
					}
				}
				if !specifier {
					specifier = getSpecifierForModuleSymbol(chain[0], context)
				}
				if !(context.flags & NodeBuilderFlagsAllowNodeModulesRelativePaths) && getEmitModuleResolutionKind(compilerOptions) != ModuleResolutionKindClassic && specifier.includes("/node_modules/") {
					oldSpecifier := specifier
					if getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNode16 || getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNodeNext {
						// We might be able to write a portable import type using a mode override; try specifier generation again, but with a different mode set
						var swappedMode /* TODO(TS-TO-GO) inferred type ModuleKind.CommonJS | ModuleKind.ESNext */ any
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case contextFile. /* TODO(TS-TO-GO): was ? */ impliedNodeFormat == ModuleKindESNext:
							swappedMode = ModuleKindCommonJS
						default:
							swappedMode = ModuleKindESNext
						}
						specifier = getSpecifierForModuleSymbol(chain[0], context, swappedMode)
						if specifier.includes("/node_modules/") {
							// Still unreachable :(
							specifier = oldSpecifier
						} else {
							attributes = factory.createImportAttributes(factory.createNodeArray([]ImportAttribute{factory.createImportAttribute(factory.createStringLiteral("resolution-mode"), factory.createStringLiteral(__COND__(swappedMode == ModuleKindESNext, "import", "require")))}))
						}
					}
					if !attributes {
						// If ultimately we can only name the symbol with a reference that dives into a `node_modules` folder, we should error
						// since declaration files with these kinds of references are liable to fail when published :(
						context.encounteredError = true
						if context.tracker.reportLikelyUnsafeImportRequiredError {
							context.tracker.reportLikelyUnsafeImportRequiredError(oldSpecifier)
						}
					}
				}
				lit := factory.createLiteralTypeNode(factory.createStringLiteral(specifier))
				context.approximateLength += specifier.length + 10
				// specifier + import("")
				if !nonRootParts || isEntityName(nonRootParts) {
					if nonRootParts {
						var lastId Identifier
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isIdentifier(nonRootParts):
							lastId = nonRootParts
						default:
							lastId = nonRootParts.right
						}
						setIdentifierTypeArguments(lastId /*typeArguments*/, nil)
					}
					return factory.createImportTypeNode(lit, attributes, nonRootParts /* as EntityName */, typeParameterNodes /* as readonly TypeNode[] */, isTypeOf)
				} else {
					splitNode := getTopmostIndexedAccessType(nonRootParts)
					qualifier := (splitNode.objectType /* as TypeReferenceNode */).typeName
					return factory.createIndexedAccessTypeNode(factory.createImportTypeNode(lit, attributes, qualifier, typeParameterNodes /* as readonly TypeNode[] */, isTypeOf), splitNode.indexType)
				}
			}
			entityName := createAccessFromSymbolChain(chain, chain.length-1, 0)
			if isIndexedAccessTypeNode(entityName) {
				return entityName
				// Indexed accesses can never be `typeof`
			}
			if isTypeOf {
				return factory.createTypeQueryNode(entityName)
			} else {
				var lastId Identifier
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isIdentifier(entityName):
					lastId = entityName
				default:
					lastId = entityName.right
				}
				lastTypeArgs := getIdentifierTypeArguments(lastId)
				setIdentifierTypeArguments(lastId /*typeArguments*/, nil)
				return factory.createTypeReferenceNode(entityName, lastTypeArgs /* as NodeArray<TypeNode> */)
			}
			createAccessFromSymbolChain := func(chain []Symbol, index number, stopper number) /* TODO(TS-TO-GO) TypeNode UnionType: EntityName | IndexedAccessTypeNode */ any {
				var typeParameterNodes *[] /* TODO(TS-TO-GO) inferred type TypeNode[] | readonly TypeParameterDeclaration */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case index == (chain.length - 1):
					typeParameterNodes = overrideTypeArguments
				default:
					typeParameterNodes = lookupTypeParameterNodes(chain, index, context)
				}
				symbol := chain[index]
				parent := chain[index-1]
				var symbolName *string
				if index == 0 {
					context.flags |= NodeBuilderFlagsInInitialEntityName
					symbolName = getNameOfSymbolAsWritten(symbol, context)
					context.approximateLength += (__COND__(symbolName, symbolName.length, 0)) + 1
					context.flags ^= NodeBuilderFlagsInInitialEntityName
				} else {
					if parent && getExportsOfSymbol(parent) {
						exports := getExportsOfSymbol(parent)
						forEachEntry(exports, func(ex Symbol, name __String) *true {
							if getSymbolIfSameReference(ex, symbol) && !isLateBoundName(name) && name != InternalSymbolNameExportEquals {
								symbolName = unescapeLeadingUnderscores(name)
								return true
							}
						})
					}
				}
				if symbolName == nil {
					name := firstDefined(symbol.declarations, getNameOfDeclaration)
					if name && isComputedPropertyName(name) && isEntityName(name.expression) {
						LHS := createAccessFromSymbolChain(chain, index-1, stopper)
						if isEntityName(LHS) {
							return factory.createIndexedAccessTypeNode(factory.createParenthesizedType(factory.createTypeQueryNode(LHS)), factory.createTypeQueryNode(name.expression))
						}
						return LHS
					}
					symbolName = getNameOfSymbolAsWritten(symbol, context)
				}
				context.approximateLength += symbolName.length + 1
				if !(context.flags & NodeBuilderFlagsForbidIndexedAccessSymbolReferences) && parent && getMembersOfSymbol(parent) && getMembersOfSymbol(parent).get(symbol.escapedName) && getSymbolIfSameReference(getMembersOfSymbol(parent).get(symbol.escapedName), symbol) {
					// Should use an indexed access
					LHS := createAccessFromSymbolChain(chain, index-1, stopper)
					if isIndexedAccessTypeNode(LHS) {
						return factory.createIndexedAccessTypeNode(LHS, factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)))
					} else {
						return factory.createIndexedAccessTypeNode(factory.createTypeReferenceNode(LHS, typeParameterNodes /* as readonly TypeNode[] */), factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)))
					}
				}
				identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
				if typeParameterNodes {
					setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
				}
				identifier.symbol = symbol
				if index > stopper {
					LHS := createAccessFromSymbolChain(chain, index-1, stopper)
					if !isEntityName(LHS) {
						return Debug.fail("Impossible construct - an export of an indexed access cannot be reachable")
					}
					return factory.createQualifiedName(LHS, identifier)
				}
				return identifier
			}
		}
		typeParameterShadowsOtherTypeParameterInScope := func(escapedName __String, context NodeBuilderContext, type_ TypeParameter) bool {
			result := resolveName(context.enclosingDeclaration, escapedName, SymbolFlagsType /*nameNotFoundMessage*/, nil /*isUse*/, false)
			if result && result.flags&SymbolFlagsTypeParameter {
				return result != type_.symbol
			}
			return false
		}
		typeParameterToName := func(type_ TypeParameter, context NodeBuilderContext) Identifier {
			if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && context.typeParameterNames {
				cached := context.typeParameterNames.get(getTypeId(type_))
				if cached {
					return cached
				}
			}
			result := symbolToName(type_.symbol, context, SymbolFlagsType /*expectsIdentifier*/, true)
			if !(result.kind & SyntaxKindIdentifier) {
				return factory.createIdentifier("(Missing type parameter)")
			}
			decl := type_.symbol. /* TODO(TS-TO-GO): was ? */ declarations[0]
			if decl && isTypeParameterDeclaration(decl) {
				result = setTextRange(context, result, decl.name)
			}
			if context.flags & NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
				rawtext := result.escapedText /* as string */
				i := context.typeParameterNamesByTextNextNameCount. /* TODO(TS-TO-GO): was ? */ get(rawtext) || 0
				text := rawtext
				for context.typeParameterNamesByText. /* TODO(TS-TO-GO): was ? */ has(text) || typeParameterShadowsOtherTypeParameterInScope(text /* as __String */, context, type_) {
					i++
					text = __TEMPLATE__(rawtext, "_", i)
				}
				if text != rawtext {
					typeArguments := getIdentifierTypeArguments(result)
					result = factory.createIdentifier(text)
					setIdentifierTypeArguments(result, typeArguments)
				}
				if context.mustCreateTypeParametersNamesLookups {
					context.mustCreateTypeParametersNamesLookups = false
					context.typeParameterNames = NewMap(context.typeParameterNames)
					context.typeParameterNamesByTextNextNameCount = NewMap(context.typeParameterNamesByTextNextNameCount)
					context.typeParameterNamesByText = NewSet(context.typeParameterNamesByText)
				}
				// avoiding iterations of the above loop turns out to be worth it when `i` starts to get large, so we cache the max
				// `i` we've used thus far, to save work later
				context.typeParameterNamesByTextNextNameCount.set(rawtext, i)
				context.typeParameterNames.set(getTypeId(type_), result)
				context.typeParameterNamesByText.add(text)
			}
			return result
		}
		/* TODO(TS-TO-GO): function symbolToName(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, expectsIdentifier: true): Identifier; */
		/* TODO(TS-TO-GO): function symbolToName(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, expectsIdentifier: false): EntityName; */
		symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier bool) EntityName {
			chain := lookupSymbolChain(symbol, context, meaning)
			if expectsIdentifier && chain.length != 1 && !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowQualifiedNameInPlaceOfIdentifier) {
				context.encounteredError = true
			}
			return createEntityNameFromSymbolChain(chain, chain.length-1)
			createEntityNameFromSymbolChain := func(chain []Symbol, index number) EntityName {
				typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
				symbol := chain[index]
				if index == 0 {
					context.flags |= NodeBuilderFlagsInInitialEntityName
				}
				symbolName := getNameOfSymbolAsWritten(symbol, context)
				if index == 0 {
					context.flags ^= NodeBuilderFlagsInInitialEntityName
				}
				identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
				if typeParameterNodes {
					setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
				}
				identifier.symbol = symbol
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case index > 0:
					return factory.createQualifiedName(createEntityNameFromSymbolChain(chain, index-1), identifier)
				default:
					return identifier
				}
			}
		}
		symbolToExpression := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) Expression {
			chain := lookupSymbolChain(symbol, context, meaning)
			return createExpressionFromSymbolChain(chain, chain.length-1)
			createExpressionFromSymbolChain := func(chain []Symbol, index number) Expression {
				typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
				symbol := chain[index]
				if index == 0 {
					context.flags |= NodeBuilderFlagsInInitialEntityName
				}
				symbolName := getNameOfSymbolAsWritten(symbol, context)
				if index == 0 {
					context.flags ^= NodeBuilderFlagsInInitialEntityName
				}
				firstChar := symbolName.charCodeAt(0)
				if isSingleOrDoubleQuote(firstChar) && some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
					return factory.createStringLiteral(getSpecifierForModuleSymbol(symbol, context))
				}
				if index == 0 || canUsePropertyAccess(symbolName, languageVersion) {
					identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
					if typeParameterNodes {
						setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
					}
					identifier.symbol = symbol
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case index > 0:
						return factory.createPropertyAccessExpression(createExpressionFromSymbolChain(chain, index-1), identifier)
					default:
						return identifier
					}
				} else {
					if firstChar == CharacterCodesopenBracket {
						symbolName = symbolName.substring(1, symbolName.length-1)
						firstChar = symbolName.charCodeAt(0)
					}
					var expression Expression
					if isSingleOrDoubleQuote(firstChar) && !(symbol.flags & SymbolFlagsEnumMember) {
						expression = factory.createStringLiteral(stripQuotes(symbolName).replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\\./g */ TODO, func(s string) string {
							return s.substring(1)
						}), firstChar == CharacterCodessingleQuote)
					} else if ("" + +symbolName) == symbolName {
						expression = factory.createNumericLiteral(+symbolName)
					}
					if !expression {
						identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
						if typeParameterNodes {
							setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
						}
						identifier.symbol = symbol
						expression = identifier
					}
					return factory.createElementAccessExpression(createExpressionFromSymbolChain(chain, index-1), expression)
				}
			}
		}
		isStringNamed := func(d Declaration) bool {
			name := getNameOfDeclaration(d)
			if !name {
				return false
			}
			if isComputedPropertyName(name) {
				type_ := checkExpression(name.expression)
				return !!(type_.flags & TypeFlagsStringLike)
			}
			if isElementAccessExpression(name) {
				type_ := checkExpression(name.argumentExpression)
				return !!(type_.flags & TypeFlagsStringLike)
			}
			return isStringLiteral(name)
		}
		isSingleQuotedStringNamed := func(d Declaration) bool {
			name := getNameOfDeclaration(d)
			return !!(name && isStringLiteral(name) && (name.singleQuote || !nodeIsSynthesized(name) && startsWith(getTextOfNode(name /*includeTrivia*/, false), "'")))
		}
		getPropertyNameNodeForSymbol := func(symbol Symbol, context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type Identifier | StringLiteral | NumericLiteral | ComputedPropertyName */ any {
			stringNamed := !!length(symbol.declarations) && every(symbol.declarations, isStringNamed)
			singleQuote := !!length(symbol.declarations) && every(symbol.declarations, isSingleQuotedStringNamed)
			isMethod := !!(symbol.flags & SymbolFlagsMethod)
			fromNameType := getPropertyNameNodeForSymbolFromNameType(symbol, context, singleQuote, stringNamed, isMethod)
			if fromNameType {
				return fromNameType
			}
			rawName := unescapeLeadingUnderscores(symbol.escapedName)
			return createPropertyNameNodeForIdentifierOrLiteral(rawName, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod)
		}
		// See getNameForSymbolFromNameType for a stringy equivalent
		getPropertyNameNodeForSymbolFromNameType := func(symbol Symbol, context NodeBuilderContext, singleQuote bool, stringNamed bool, isMethod bool) * /* TODO(TS-TO-GO) inferred type Identifier | StringLiteral | NumericLiteral | ComputedPropertyName */ any {
			nameType := getSymbolLinks(symbol).nameType
			if nameType {
				if nameType.flags & TypeFlagsStringOrNumberLiteral {
					name := "" + (nameType /* as StringLiteralType | NumberLiteralType */).value
					if !isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && (stringNamed || !isNumericLiteralName(name)) {
						return factory.createStringLiteral(name, !!singleQuote)
					}
					if isNumericLiteralName(name) && startsWith(name, "-") {
						return factory.createComputedPropertyName(factory.createPrefixUnaryExpression(SyntaxKindMinusToken, factory.createNumericLiteral(-name)))
					}
					return createPropertyNameNodeForIdentifierOrLiteral(name, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod)
				}
				if nameType.flags & TypeFlagsUniqueESSymbol {
					return factory.createComputedPropertyName(symbolToExpression((nameType /* as UniqueESSymbolType */).symbol, context, SymbolFlagsValue))
				}
			}
		}
		cloneNodeBuilderContext := func(context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type () => void */ any {
			// Make type parameters created within this context not consume the name outside this context
			// The symbol serializer ends up creating many sibling scopes that all need "separate" contexts when
			// it comes to naming things - within a normal `typeToTypeNode` call, the node builder only ever descends
			// through the type tree, so the only cases where we could have used distinct sibling scopes was when there
			// were multiple generic overloads with similar generated type parameter names
			// The effect:
			// When we write out
			// export const x: <T>(x: T) => T
			// export const y: <T>(x: T) => T
			// we write it out like that, rather than as
			// export const x: <T>(x: T) => T
			// export const y: <T_1>(x: T_1) => T_1
			oldMustCreateTypeParameterSymbolList := context.mustCreateTypeParameterSymbolList
			oldMustCreateTypeParametersNamesLookups := context.mustCreateTypeParametersNamesLookups
			context.mustCreateTypeParameterSymbolList = true
			context.mustCreateTypeParametersNamesLookups = true
			oldTypeParameterNames := context.typeParameterNames
			oldTypeParameterNamesByText := context.typeParameterNamesByText
			oldTypeParameterNamesByTextNextNameCount := context.typeParameterNamesByTextNextNameCount
			oldTypeParameterSymbolList := context.typeParameterSymbolList
			return func() {
				context.typeParameterNames = oldTypeParameterNames
				context.typeParameterNamesByText = oldTypeParameterNamesByText
				context.typeParameterNamesByTextNextNameCount = oldTypeParameterNamesByTextNextNameCount
				context.typeParameterSymbolList = oldTypeParameterSymbolList
				context.mustCreateTypeParameterSymbolList = oldMustCreateTypeParameterSymbolList
				context.mustCreateTypeParametersNamesLookups = oldMustCreateTypeParametersNamesLookups
			}
		}
		getDeclarationWithTypeAnnotation := func(symbol Symbol, enclosingDeclaration Node) Declaration {
			return symbol.declarations && find(symbol.declarations, func(s Declaration) bool {
				return !!getNonlocalEffectiveTypeAnnotationNode(s) && (!enclosingDeclaration || !!findAncestor(s, func(n Node) bool {
					return n == enclosingDeclaration
				}))
			})
		}
		existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount := func(existing TypeNode, type_ Type) bool {
			// In JS, you can say something like `Foo` and get a `Foo<any>` implicitly - we don't want to preserve that original `Foo` in these cases, though.
			if !(getObjectFlags(type_) & ObjectFlagsReference) {
				return true
			}
			if !isTypeReferenceNode(existing) {
				return true
			}
			// `type` is a reference type, and `existing` is a type reference node, but we still need to make sure they refer to the _same_ target type
			// before we go comparing their type argument counts.
			getTypeFromTypeReference(existing)
			// call to ensure symbol is resolved
			symbol := getNodeLinks(existing).resolvedSymbol
			existingTarget := symbol && getDeclaredTypeOfSymbol(symbol)
			if !existingTarget || existingTarget != (type_ /* as TypeReference */).target {
				return true
			}
			return length(existing.typeArguments) >= getMinTypeArgumentCount((type_ /* as TypeReference */).target.typeParameters)
		}
		getEnclosingDeclarationIgnoringFakeScope := func(enclosingDeclaration Node) Node {
			for getNodeLinks(enclosingDeclaration).fakeScopeForSignatureDeclaration {
				enclosingDeclaration = enclosingDeclaration.parent
			}
			return enclosingDeclaration
		}
		/**
		 * Unlike `typeToTypeNodeHelper`, this handles setting up the `AllowUniqueESSymbolType` flag
		 * so a `unique symbol` is returned when appropriate for the input symbol, rather than `typeof sym`
		 * @param context - The node builder context. Any reused nodes are checked to be pulled from within the scope of the context's enclosingDeclaration.
		 * @param declaration - The preferred declaration to pull existing type nodes from (the symbol will be used as a fallback to find any annotated declaration)
		 * @param type - The type to write; an existing annotation must match this type if it's used, otherwise this is the type serialized as a new type node
		 * @param symbol - The symbol is used both to find an existing annotation if declaration is not provided, and to determine if `unique symbol` should be printed
		 */
		serializeTypeForDeclaration := func(context NodeBuilderContext, declaration Declaration, type_ Type, symbol Symbol) TypeNode {
			addUndefinedForParameter := declaration && (isParameter(declaration) || isJSDocParameterTag(declaration)) && requiresAddingImplicitUndefined(declaration, context.enclosingDeclaration)
			enclosingDeclaration := context.enclosingDeclaration
			restoreFlags := saveRestoreFlags(context)
			if declaration && hasInferredType(declaration) && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
				syntacticNodeBuilder.serializeTypeOfDeclaration(declaration, context)
			}
			context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
			if enclosingDeclaration && (!isErrorType(type_) || (context.internalFlags & InternalNodeBuilderFlagsAllowUnresolvedNames)) {
				var declWithExistingAnnotation Declaration
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case declaration && getNonlocalEffectiveTypeAnnotationNode(declaration):
					declWithExistingAnnotation = declaration
				default:
					declWithExistingAnnotation = getDeclarationWithTypeAnnotation(symbol)
				}
				if declWithExistingAnnotation && !isFunctionLikeDeclaration(declWithExistingAnnotation) && !isGetAccessorDeclaration(declWithExistingAnnotation) {
					// try to reuse the existing annotation
					existing := getNonlocalEffectiveTypeAnnotationNode(declWithExistingAnnotation)
					// explicitly add `| undefined` to optional mapped properties whose type contains `undefined` (and not `missing`)
					addUndefined := addUndefinedForParameter || !!(symbol.flags&SymbolFlagsProperty && symbol.flags&SymbolFlagsOptional && isOptionalDeclaration(declWithExistingAnnotation) && (symbol /* as MappedSymbol */).links. /* TODO(TS-TO-GO): was ? */ mappedType && containsNonMissingUndefinedType(type_))
					result := !isTypePredicateNode(existing) && tryReuseExistingTypeNode(context, existing, type_, declWithExistingAnnotation, addUndefined)
					if result {
						restoreFlags()
						return result
					}
				}
			}
			if type_.flags&TypeFlagsUniqueESSymbol && type_.symbol == symbol && (!context.enclosingDeclaration || some(symbol.declarations, func(d Declaration) bool {
				return getSourceFileOfNode(d) == getSourceFileOfNode(context.enclosingDeclaration)
			})) {
				context.flags |= NodeBuilderFlagsAllowUniqueESSymbolType
			}
			decl := /* TODO(TS-TO-GO) Node BinaryExpression: declaration ?? symbol.valueDeclaration ?? symbol.declarations?.[0] */ TODO
			var expr Expression
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case decl && isDeclarationWithPossibleInnerTypeNodeReuse(decl):
				expr = getPossibleTypeNodeReuseExpression(decl)
			default:
				expr = nil
			}
			result := expressionOrTypeToTypeNode(context, expr, type_, addUndefinedForParameter)
			restoreFlags()
			return result
		}
		typeNodeIsEquivalentToType := func(annotatedDeclaration Node, type_ Type, typeFromTypeNode Type) bool {
			if typeFromTypeNode == type_ {
				return true
			}
			if annotatedDeclaration && (isParameter(annotatedDeclaration) || isPropertySignature(annotatedDeclaration) || isPropertyDeclaration(annotatedDeclaration)) && annotatedDeclaration.questionToken {
				return getTypeWithFacts(type_, TypeFactsNEUndefined) == typeFromTypeNode
			}
			return false
		}
		serializeReturnTypeForSignature := func(context NodeBuilderContext, signature Signature) *TypeNode {
			suppressAny := context.flags & NodeBuilderFlagsSuppressAnyReturnType
			restoreFlags := saveRestoreFlags(context)
			if suppressAny {
				context.flags &= ~NodeBuilderFlagsSuppressAnyReturnType
				// suppress only toplevel `any`s
			}
			// suppress only toplevel `any`s
			var returnTypeNode *TypeNode
			returnType := getReturnTypeOfSignature(signature)
			if returnType && !(suppressAny && isTypeAny(returnType)) {
				if signature.declaration && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
					syntacticNodeBuilder.serializeReturnTypeForSignature(signature.declaration, context)
				}
				context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
				returnTypeNode = serializeReturnTypeForSignatureWorker(context, signature)
			} else if !suppressAny {
				returnTypeNode = factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
			}
			restoreFlags()
			return returnTypeNode
		}
		serializeReturnTypeForSignatureWorker := func(context NodeBuilderContext, signature Signature) TypeNode {
			typePredicate := getTypePredicateOfSignature(signature)
			type_ := getReturnTypeOfSignature(signature)
			if context.enclosingDeclaration && (!isErrorType(type_) || (context.internalFlags & InternalNodeBuilderFlagsAllowUnresolvedNames)) && signature.declaration && !nodeIsSynthesized(signature.declaration) {
				annotation := getNonlocalEffectiveReturnTypeAnnotationNode(signature.declaration)
				if annotation {
					result := tryReuseExistingTypeNode(context, annotation, type_, context.enclosingDeclaration)
					if result {
						return result
					}
				}
			}
			if typePredicate {
				return typePredicateToTypePredicateNodeHelper(typePredicate, context)
			}
			expr := signature.declaration && getPossibleTypeNodeReuseExpression(signature.declaration)
			return expressionOrTypeToTypeNode(context, expr, type_)
		}
		trackExistingEntityName := func(node T, context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type { introducesError: boolean; node: T; sym?: undefined; } | { introducesError: boolean; node: T; sym: Symbol | undefined; } */ any {
			introducesError := false
			leftmost := getFirstIdentifier(node)
			if isInJSFile(node) && (isExportsIdentifier(leftmost) || isModuleExportsAccessExpression(leftmost.parent) || (isQualifiedName(leftmost.parent) && isModuleIdentifier(leftmost.parent.left) && isExportsIdentifier(leftmost.parent.right))) {
				introducesError = true
				return map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"introducesError": introducesError,
					"node":            node,
				}
			}
			meaning := getMeaningOfEntityNameReference(node)
			var sym Symbol
			if isThisIdentifier(leftmost) {
				// `this` isn't a bindable identifier - skip resolution, find a relevant `this` symbol directly and avoid exhaustive scope traversal
				sym = getSymbolOfDeclaration(getThisContainer(leftmost /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false))
				if isSymbolAccessible(sym, leftmost, meaning /*shouldComputeAliasesToMakeVisible*/, false).accessibility != SymbolAccessibilityAccessible {
					introducesError = true
					context.tracker.reportInaccessibleThisError()
				}
				return map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"introducesError": introducesError,
					"node":            attachSymbolToLeftmostIdentifier(node), /* as T */
				}
			}
			sym = resolveEntityName(leftmost, meaning /*ignoreErrors*/, true /*dontResolveAlias*/, true)
			if context.enclosingDeclaration && !(sym && sym.flags&SymbolFlagsTypeParameter) {
				sym = getExportSymbolOfValueSymbolIfExported(sym)
				// Some declarations may be transplanted to a new location.
				// When this happens we need to make sure that the name has the same meaning at both locations
				// We also check for the unknownSymbol because when we create a fake scope some parameters may actually not be usable
				// either because they are the expanded rest parameter,
				// or because they are the newly added parameters from the tuple, which might have different meanings in the original context
				symAtLocation := resolveEntityName(leftmost, meaning /*ignoreErrors*/, true /*dontResolveAlias*/, true, context.enclosingDeclaration)
				if symAtLocation == unknownSymbol || (symAtLocation == nil && sym != nil) || (symAtLocation && sym && !getSymbolIfSameReference(getExportSymbolOfValueSymbolIfExported(symAtLocation), sym)) {
					// In isolated declaration we will not do rest parameter expansion so there is no need to report on these.
					if symAtLocation != unknownSymbol {
						context.tracker.reportInferenceFallback(node)
					}
					introducesError = true
					return map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"introducesError": introducesError,
						"node":            node,
						"sym":             sym,
					}
				} else {
					sym = symAtLocation
				}
			}
			if sym {
				// If a parameter is resolvable in the current context it is also visible, so no need to go to symbol accesibility
				if sym.flags&SymbolFlagsFunctionScopedVariable && sym.valueDeclaration {
					if isPartOfParameterDeclaration(sym.valueDeclaration) || isJSDocParameterTag(sym.valueDeclaration) {
						return map[any]any{ /* TODO(TS-TO-GO): was object literal */
							"introducesError": introducesError,
							"node":            attachSymbolToLeftmostIdentifier(node), /* as T */
						}
					}
				}
				if !(sym.flags & SymbolFlagsTypeParameter) && !isDeclarationName(node) && isSymbolAccessible(sym, context.enclosingDeclaration, meaning /*shouldComputeAliasesToMakeVisible*/, false).accessibility != SymbolAccessibilityAccessible {
					context.tracker.reportInferenceFallback(node)
					introducesError = true
				} else {
					context.tracker.trackSymbol(sym, context.enclosingDeclaration, meaning)
				}
				return map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"introducesError": introducesError,
					"node":            attachSymbolToLeftmostIdentifier(node), /* as T */
				}
			}
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"introducesError": introducesError,
				"node":            node,
			}
			/**
			 * Attaches a `.symbol` member to an identifier, cloning it to do so, so symbol information
			 * is smuggled out for symbol display information.
			 */
			attachSymbolToLeftmostIdentifier := func(node Node) Node {
				if node == leftmost {
					type_ := getDeclaredTypeOfSymbol(sym)
					var name Identifier
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case sym.flags & SymbolFlagsTypeParameter:
						name = typeParameterToName(type_, context)
					default:
						name = factory.cloneNode(node /* as Identifier */)
					}
					name.symbol = sym
					// for quickinfo, which uses identifier symbol information
					return setTextRange(context, setEmitFlags(name, EmitFlagsNoAsciiEscaping), node)
				}
				updated := visitEachChildWorker(node, func(c Node) Node {
					return attachSymbolToLeftmostIdentifier(c)
				}, /*context*/ nil)
				if updated != node {
					setTextRange(context, updated, node)
				}
				return updated
			}
		}
		serializeTypeName := func(context NodeBuilderContext, node EntityName, isTypeOf bool, typeArguments []TypeNode) *TypeNode {
			var meaning /* TODO(TS-TO-GO) inferred type SymbolFlags.Value | SymbolFlags.Type */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isTypeOf:
				meaning = SymbolFlagsValue
			default:
				meaning = SymbolFlagsType
			}
			symbol := resolveEntityName(node, meaning /*ignoreErrors*/, true)
			if !symbol {
				return nil
			}
			var resolvedSymbol Symbol
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case symbol.flags & SymbolFlagsAlias:
				resolvedSymbol = resolveAlias(symbol)
			default:
				resolvedSymbol = symbol
			}
			if isSymbolAccessible(symbol, context.enclosingDeclaration, meaning /*shouldComputeAliasesToMakeVisible*/, false).accessibility != SymbolAccessibilityAccessible {
				return nil
			}
			return symbolToTypeNode(resolvedSymbol, context, meaning, typeArguments)
		}
		canReuseTypeNode := func(context NodeBuilderContext, existing TypeNode) /* TODO(TS-TO-GO) inferred type number | boolean */ any {
			if isInJSFile(existing) {
				if isLiteralImportTypeNode(existing) {
					// Ensure resolvedSymbol is present
					getTypeFromImportTypeNode(existing)
					nodeSymbol := getNodeLinks(existing).resolvedSymbol
					return (!nodeSymbol || !((!existing.isTypeOf && !(nodeSymbol.flags & SymbolFlagsType)) || !(length(existing.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))))
				}
			}
			if isThisTypeNode(existing) {
				if context.mapper == nil {
					return true
				}
				type_ := getTypeFromTypeNode(context, existing /*noMappedTypes*/, true)
				return !!type_
			}
			if isTypeReferenceNode(existing) {
				if isConstTypeReference(existing) {
					return false
				}
				type_ := getTypeFromTypeReference(existing)
				symbol := getNodeLinks(existing).resolvedSymbol
				if !symbol {
					return false
				}
				if symbol.flags & SymbolFlagsTypeParameter {
					type_ := getDeclaredTypeOfSymbol(symbol)
					if context.mapper && getMappedType(type_, context.mapper) != type_ {
						return false
					}
				}
				if isInJSDoc(existing) {
					return existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type_) && !getIntendedTypeFromJSDocTypeReference(existing) && (symbol.flags & SymbolFlagsType)
					// JSDoc type annotations can reference values (meaning typeof value) as well as types. We only reuse type nodes
				}
			}
			if isTypeOperatorNode(existing) && existing.operator == SyntaxKindUniqueKeyword && existing.type_.kind == SyntaxKindSymbolKeyword {
				effectiveEnclosingContext := context.enclosingDeclaration && getEnclosingDeclarationIgnoringFakeScope(context.enclosingDeclaration)
				return !!findAncestor(existing, func(n Node) bool {
					return n == effectiveEnclosingContext
				})
			}
			return true
		}
		serializeExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode) TypeNode {
			type_ := getTypeFromTypeNode(context, typeNode)
			return typeToTypeNodeHelper(type_, context)
		}
		/**
		 * Do you mean to call this directly? You probably should use `tryReuseExistingTypeNode` instead,
		 * which performs sanity checking on the type before doing this.
		 */
		tryReuseExistingTypeNodeHelper := func(context NodeBuilderContext, existing TypeNode) *TypeNode {
			if cancellationToken && cancellationToken.throwIfCancellationRequested {
				cancellationToken.throwIfCancellationRequested()
			}
			hadError := false
			TODO_IDENTIFIER := createRecoveryBoundary()
			transformed := visitNode(existing, visitExistingNodeTreeSymbols, isTypeNode)
			if !finalizeBoundary() {
				return nil
			}
			context.approximateLength += existing.end - existing.pos
			return transformed
			visitExistingNodeTreeSymbols := func(node Node) Node {
				// If there was an error in a sibling node bail early, the result will be discarded anyway
				if hadError {
					return node
				}
				recover := startRecoveryScope()
				var onExitNewScope * /* TODO(TS-TO-GO) inferred type (() => void) */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isNewScopeNode(node):
					onExitNewScope = onEnterNewScope(node)
				default:
					onExitNewScope = nil
				}
				result := visitExistingNodeTreeSymbolsWorker(node)
				onExitNewScope()
				// If there was an error, maybe we can recover by serializing the actual type of the node
				if hadError {
					if isTypeNode(node) && !isTypePredicateNode(node) {
						recover()
						return serializeExistingTypeNode(context, node)
					}
					return node
				}
				// We want to clone the subtree, so when we mark it up with __pos and __end in quickfixes,
				//  we don't get odd behavior because of reused nodes. We also need to clone to _remove_
				//  the position information if the node comes from a different file than the one the node builder
				//  is set to build for (even though we are reusing the node structure, the position information
				//  would make the printer print invalid spans for literals and identifiers, and the formatter would
				//  choke on the mismatched positonal spans between a parent and an injected child from another file).
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case result:
					return setTextRange(context, result, node)
				default:
					return nil
				}
			}
			createRecoveryBoundary := func() /* TODO(TS-TO-GO) inferred type { startRecoveryScope: () => () => void; finalizeBoundary: () => boolean; } */ any {
				var trackedSymbols []TrackedSymbol
				var unreportedErrors []func()
				oldTracker := context.tracker
				oldTrackedSymbols := context.trackedSymbols
				context.trackedSymbols = nil
				oldEncounteredError := context.encounteredError
				context.tracker = NewSymbolTrackerImpl(context, map[any]any{ /* TODO(TS-TO-GO): was object literal */
					/* TODO(TS-TO-GO) Node SpreadAssignment: ...oldTracker.inner */
					"reportCyclicStructureError": func() {
						markError(func() {
							return oldTracker.reportCyclicStructureError()
						})
					},
					"reportInaccessibleThisError": func() {
						markError(func() {
							return oldTracker.reportInaccessibleThisError()
						})
					},
					"reportInaccessibleUniqueSymbolError": func() {
						markError(func() {
							return oldTracker.reportInaccessibleUniqueSymbolError()
						})
					},
					"reportLikelyUnsafeImportRequiredError": func(specifier string) {
						markError(func() {
							return oldTracker.reportLikelyUnsafeImportRequiredError(specifier)
						})
					},
					"reportNonSerializableProperty": func(name string) {
						markError(func() {
							return oldTracker.reportNonSerializableProperty(name)
						})
					},
					"trackSymbol": func(sym Symbol, decl Node, meaning SymbolFlags) false {
						( /* TODO(TS-TO-GO) Node BinaryExpression: trackedSymbols ??= [] */ TODO).push([]any{sym, decl, meaning})
						return false
					},
					"moduleResolverHost": context.tracker.moduleResolverHost,
				}, context.tracker.moduleResolverHost)
				return map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"startRecoveryScope": startRecoveryScope,
					"finalizeBoundary":   finalizeBoundary,
				}
				markError := func(unreportedError func()) {
					hadError = true
					( /* TODO(TS-TO-GO) Node BinaryExpression: unreportedErrors ??= [] */ TODO).push(unreportedError)
				}
				startRecoveryScope := func() /* TODO(TS-TO-GO) inferred type () => void */ any {
					trackedSymbolsTop := /* TODO(TS-TO-GO) Node BinaryExpression: trackedSymbols?.length ?? 0 */ TODO
					unreportedErrorsTop := /* TODO(TS-TO-GO) Node BinaryExpression: unreportedErrors?.length ?? 0 */ TODO
					return func() {
						hadError = false
						// Reset the tracked symbols to before the error
						if trackedSymbols {
							trackedSymbols.length = trackedSymbolsTop
						}
						if unreportedErrors {
							unreportedErrors.length = unreportedErrorsTop
						}
					}
				}
				finalizeBoundary := func() bool {
					context.tracker = oldTracker
					context.trackedSymbols = oldTrackedSymbols
					context.encounteredError = oldEncounteredError
					unreportedErrors. /* TODO(TS-TO-GO): was ? */ forEach(func(fn /* TODO(TS-TO-GO) inferred type () => void */ any) {
						return fn()
					})
					if hadError {
						return false
					}
					trackedSymbols. /* TODO(TS-TO-GO): was ? */ forEach(func(TODO_IDENTIFIER TrackedSymbol) bool {
						return context.tracker.trackSymbol(symbol, enclosingDeclaration, meaning)
					})
					return true
				}
			}
			onEnterNewScope := func(node /* TODO(TS-TO-GO) TypeNode UnionType: IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO(TS-TO-GO) inferred type () => void */ any {
				return enterNewScope(context, node, getParametersInScope(node), getTypeParametersInScope(node))
			}
			tryVisitSimpleTypeNode := func(node TypeNode) *TypeNode {
				innerNode := skipTypeParentheses(node)
				switch innerNode.kind {
				case SyntaxKindTypeReference:
					return tryVisitTypeReference(innerNode /* as TypeReferenceNode */)
				case SyntaxKindTypeQuery:
					return tryVisitTypeQuery(innerNode /* as TypeQueryNode */)
				case SyntaxKindIndexedAccessType:
					return tryVisitIndexedAccess(innerNode /* as IndexedAccessTypeNode */)
				case SyntaxKindTypeOperator:
					typeOperatorNode := innerNode /* as TypeOperatorNode */
					if typeOperatorNode.operator == SyntaxKindKeyOfKeyword {
						return tryVisitKeyOf(typeOperatorNode)
					}
				}
				return visitNode(node, visitExistingNodeTreeSymbols, isTypeNode)
			}
			tryVisitIndexedAccess := func(node IndexedAccessTypeNode) *TypeNode {
				resultObjectType := tryVisitSimpleTypeNode(node.objectType)
				if resultObjectType == nil {
					return nil
				}
				return factory.updateIndexedAccessTypeNode(node, resultObjectType, visitNode(node.indexType, visitExistingNodeTreeSymbols, isTypeNode))
			}
			tryVisitKeyOf := func(node TypeOperatorNode) *TypeNode {
				Debug.assertEqual(node.operator, SyntaxKindKeyOfKeyword)
				type_ := tryVisitSimpleTypeNode(node.type_)
				if type_ == nil {
					return nil
				}
				return factory.updateTypeOperatorNode(node, type_)
			}
			tryVisitTypeQuery := func(node TypeQueryNode) *TypeNode {
				TODO_IDENTIFIER := trackExistingEntityName(node.exprName, context)
				if !introducesError {
					return factory.updateTypeQueryNode(node, exprName, visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode))
				}
				serializedName := serializeTypeName(context, node.exprName /*isTypeOf*/, true)
				if serializedName {
					return setTextRange(context, serializedName, node.exprName)
				}
			}
			tryVisitTypeReference := func(node TypeReferenceNode) *TypeNode {
				if canReuseTypeNode(context, node) {
					TODO_IDENTIFIER := trackExistingEntityName(node.typeName, context)
					typeArguments := visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode)
					if !introducesError {
						updated := factory.updateTypeReferenceNode(node, newName, typeArguments)
						return setTextRange(context, updated, node)
					} else {
						serializedName := serializeTypeName(context, node.typeName /*isTypeOf*/, false, typeArguments)
						if serializedName {
							return setTextRange(context, serializedName, node.typeName)
						}
					}
				}
			}
			visitExistingNodeTreeSymbolsWorker := func(node Node) Node {
				if isJSDocTypeExpression(node) {
					// Unwrap JSDocTypeExpressions
					return visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode)
				}
				// We don't _actually_ support jsdoc namepath types, emit `any` instead
				if isJSDocAllType(node) || node.kind == SyntaxKindJSDocNamepathType {
					return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
				}
				if isJSDocUnknownType(node) {
					return factory.createKeywordTypeNode(SyntaxKindUnknownKeyword)
				}
				if isJSDocNullableType(node) {
					return factory.createUnionTypeNode([]TypeNode{visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode), factory.createLiteralTypeNode(factory.createNull())})
				}
				if isJSDocOptionalType(node) {
					return factory.createUnionTypeNode([]TypeNode{visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode), factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)})
				}
				if isJSDocNonNullableType(node) {
					return visitNode(node.type_, visitExistingNodeTreeSymbols)
				}
				if isJSDocVariadicType(node) {
					return factory.createArrayTypeNode(visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode))
				}
				if isJSDocTypeLiteral(node) {
					return factory.createTypeLiteralNode(map_(node.jsDocPropertyTags, func(t JSDocPropertyLikeTag) PropertySignature {
						name := visitNode(__COND__(isIdentifier(t.name), t.name, t.name.right), visitExistingNodeTreeSymbols, isIdentifier)
						typeViaParent := getTypeOfPropertyOfType(getTypeFromTypeNode(context, node), name.escapedText)
						var overrideTypeNode *TypeNode
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case typeViaParent && t.typeExpression && getTypeFromTypeNode(context, t.typeExpression.type_) != typeViaParent:
							overrideTypeNode = typeToTypeNodeHelper(typeViaParent, context)
						default:
							overrideTypeNode = nil
						}
						return factory.createPropertySignature(nil, name, __COND__(t.isBracketed || t.typeExpression && isJSDocOptionalType(t.typeExpression.type_), factory.createToken(SyntaxKindQuestionToken), nil), overrideTypeNode || (t.typeExpression && visitNode(t.typeExpression.type_, visitExistingNodeTreeSymbols, isTypeNode)) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
					}))
				}
				if isTypeReferenceNode(node) && isIdentifier(node.typeName) && node.typeName.escapedText == "" {
					return setOriginalNode(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), node)
				}
				if (isExpressionWithTypeArguments(node) || isTypeReferenceNode(node)) && isJSDocIndexSignature(node) {
					return factory.createTypeLiteralNode([]IndexSignatureDeclaration{factory.createIndexSignature(nil, []ParameterDeclaration{factory.createParameterDeclaration(nil, nil, "x", nil, visitNode(node.typeArguments[0], visitExistingNodeTreeSymbols, isTypeNode))}, visitNode(node.typeArguments[1], visitExistingNodeTreeSymbols, isTypeNode))})
				}
				if isJSDocFunctionType(node) {
					if isJSDocConstructSignature(node) {
						var newTypeNode *TypeNode
						return factory.createConstructorTypeNode(nil, visitNodes(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), mapDefined(node.parameters, func(p ParameterDeclaration, i number) *ParameterDeclaration {
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case p.name && isIdentifier(p.name) && p.name.escapedText == "new":
								return ( /* TODO(TS-TO-GO) Node BinaryExpression: newTypeNode = p.type, undefined */ TODO)
							default:
								return factory.createParameterDeclaration(nil, getEffectiveDotDotDotForParameter(p), setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p), factory.cloneNode(p.questionToken), visitNode(p.type_, visitExistingNodeTreeSymbols, isTypeNode), nil)
							}
						}), visitNode(newTypeNode || node.type_, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
					} else {
						return factory.createFunctionTypeNode(visitNodes(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), map_(node.parameters, func(p ParameterDeclaration, i number) ParameterDeclaration {
							return factory.createParameterDeclaration(nil, getEffectiveDotDotDotForParameter(p), setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p), factory.cloneNode(p.questionToken), visitNode(p.type_, visitExistingNodeTreeSymbols, isTypeNode), nil)
						}), visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
					}
				}
				if isThisTypeNode(node) {
					if canReuseTypeNode(context, node) {
						return node
					}
					hadError = true
					return node
				}
				if isTypeParameterDeclaration(node) {
					return factory.updateTypeParameterDeclaration(node, visitNodes(node.modifiers, visitExistingNodeTreeSymbols, isModifier), setTextRange(context, typeParameterToName(getDeclaredTypeOfSymbol(getSymbolOfDeclaration(node)), context), node), visitNode(node.constraint, visitExistingNodeTreeSymbols, isTypeNode), visitNode(node.default_, visitExistingNodeTreeSymbols, isTypeNode))
				}
				if isIndexedAccessTypeNode(node) {
					result := tryVisitIndexedAccess(node)
					if !result {
						hadError = true
						return node
					}
					return result
				}
				if isTypeReferenceNode(node) {
					result := tryVisitTypeReference(node)
					if result {
						return result
					}
					hadError = true
					return node
				}
				if isLiteralImportTypeNode(node) {
					nodeSymbol := getNodeLinks(node).resolvedSymbol
					if isInJSDoc(node) && nodeSymbol && ((!node.isTypeOf && !(nodeSymbol.flags & SymbolFlagsType)) || !(length(node.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))) {
						return setTextRange(context, typeToTypeNodeHelper(getTypeFromTypeNode(context, node), context), node)
					}
					return factory.updateImportTypeNode(node, factory.updateLiteralTypeNode(node.argument, rewriteModuleSpecifier(node, node.argument.literal)), visitNode(node.attributes, visitExistingNodeTreeSymbols, isImportAttributes), visitNode(node.qualifier, visitExistingNodeTreeSymbols, isEntityName), visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode), node.isTypeOf)
				}
				if isNamedDeclaration(node) && node.name.kind == SyntaxKindComputedPropertyName && !isLateBindableName(node.name) {
					if !hasDynamicName(node) {
						return visitEachChild(node, visitExistingNodeTreeSymbols)
					}
					if !(context.internalFlags&InternalNodeBuilderFlagsAllowUnresolvedNames && isEntityNameExpression(node.name.expression) && checkComputedPropertyName(node.name).flags&TypeFlagsAny) {
						return nil
					}
				}
				if (isFunctionLike(node) && !node.type_) || (isPropertyDeclaration(node) && !node.type_ && !node.initializer) || (isPropertySignature(node) && !node.type_ && !node.initializer) || (isParameter(node) && !node.type_ && !node.initializer) {
					visited := visitEachChild(node, visitExistingNodeTreeSymbols)
					if visited == node {
						visited = setTextRange(context, factory.cloneNode(node), node)
					}
					(visited /* as Mutable<typeof visited> */).type_ = factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
					if isParameter(node) {
						(visited /* as Mutable<ParameterDeclaration> */).modifiers = nil
					}
					return visited
				}
				if isTypeQueryNode(node) {
					result := tryVisitTypeQuery(node)
					if !result {
						hadError = true
						return node
					}
					return result
				}
				if isComputedPropertyName(node) && isEntityNameExpression(node.expression) {
					TODO_IDENTIFIER := trackExistingEntityName(node.expression, context)
					if !introducesError {
						return factory.updateComputedPropertyName(node, result)
					} else {
						type_ := getWidenedType(getRegularTypeOfExpression(node.expression))
						computedPropertyNameType := typeToTypeNodeHelper(type_, context)
						var literal TODO
						if isLiteralTypeNode(computedPropertyNameType) {
							literal = computedPropertyNameType.literal
						} else {
							evaluated := evaluateEntityNameExpression(node.expression)
							var literalNode * /* TODO(TS-TO-GO) inferred type StringLiteral | NumericLiteral */ any
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case /* TODO(TS-TO-GO) Node TypeOfExpression: typeof evaluated.value */ TODO == "string":
								literalNode = factory.createStringLiteral(evaluated.value /*isSingleQuote*/, nil)
							case /* TODO(TS-TO-GO) Node TypeOfExpression: typeof evaluated.value */ TODO == "number":
								literalNode = factory.createNumericLiteral(evaluated.value /*numericLiteralFlags*/, 0)
							default:
								literalNode = nil
							}
							if !literalNode {
								if isImportTypeNode(computedPropertyNameType) {
									trackComputedName(node.expression, context.enclosingDeclaration, context)
								}
								return node
							}
							literal = literalNode
						}
						if literal.kind == SyntaxKindStringLiteral && isIdentifierText(literal.text, getEmitScriptTarget(compilerOptions)) {
							return factory.createIdentifier(literal.text)
						}
						if literal.kind == SyntaxKindNumericLiteral && !literal.text.startsWith("-") {
							return literal
						}
						return factory.updateComputedPropertyName(node, literal)
					}
				}
				if isTypePredicateNode(node) {
					var parameterName TODO
					if isIdentifier(node.parameterName) {
						TODO_IDENTIFIER := trackExistingEntityName(node.parameterName, context)
						// Should not usually happen the only case is when a type predicate comes from a JSDoc type annotation with it's own parameter symbol definition.
						// /** @type {(v: unknown) => v is undefined} */
						// const isUndef = v => v === undefined;
						hadError = hadError || introducesError
						parameterName = result
					} else {
						parameterName = factory.cloneNode(node.parameterName)
					}
					return factory.updateTypePredicateNode(node, factory.cloneNode(node.assertsModifier), parameterName, visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode))
				}
				if isTupleTypeNode(node) || isTypeLiteralNode(node) || isMappedTypeNode(node) {
					visited := visitEachChild(node, visitExistingNodeTreeSymbols)
					clone := setTextRange(context, __COND__(visited == node, factory.cloneNode(node), visited), node)
					flags := getEmitFlags(clone)
					setEmitFlags(clone, flags|(__COND__(context.flags&NodeBuilderFlagsMultilineObjectLiterals && isTypeLiteralNode(node), 0, EmitFlagsSingleLine)))
					return clone
				}
				if isStringLiteral(node) && !!(context.flags & NodeBuilderFlagsUseSingleQuotesForStringLiteralType) && !node.singleQuote {
					clone := factory.cloneNode(node)
					(clone /* as Mutable<typeof clone> */).singleQuote = true
					return clone
				}
				if isConditionalTypeNode(node) {
					checkType := visitNode(node.checkType, visitExistingNodeTreeSymbols, isTypeNode)
					disposeScope := onEnterNewScope(node)
					extendType := visitNode(node.extendsType, visitExistingNodeTreeSymbols, isTypeNode)
					trueType := visitNode(node.trueType, visitExistingNodeTreeSymbols, isTypeNode)
					disposeScope()
					falseType := visitNode(node.falseType, visitExistingNodeTreeSymbols, isTypeNode)
					return factory.updateConditionalTypeNode(node, checkType, extendType, trueType, falseType)
				}
				if isTypeOperatorNode(node) {
					if node.operator == SyntaxKindUniqueKeyword && node.type_.kind == SyntaxKindSymbolKeyword {
						if !canReuseTypeNode(context, node) {
							hadError = true
							return node
						}
					} else if node.operator == SyntaxKindKeyOfKeyword {
						result := tryVisitKeyOf(node)
						if !result {
							hadError = true
							return node
						}
						return result
					}
				}
				return visitEachChild(node, visitExistingNodeTreeSymbols)
				/* TODO(TS-TO-GO): function visitEachChild<T extends Node>(node: T, visitor: Visitor): T; */
				/* TODO(TS-TO-GO): function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor): T | undefined; */
				visitEachChild := func(node *T, visitor Visitor) *T {
					nonlocalNode := !context.enclosingFile || context.enclosingFile != getSourceFileOfNode(node)
					return visitEachChildWorker(node, visitor /*context*/, nil, __COND__(nonlocalNode, visitNodesWithoutCopyingPositions, nil))
				}
				visitNodesWithoutCopyingPositions := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
					result := visitNodes(nodes, visitor, test, start, count)
					if result {
						if result.pos != -1 || result.end != -1 {
							if result == nodes {
								result = factory.createNodeArray(nodes.slice(), nodes.hasTrailingComma)
							}
							setTextRangePosEnd(result, -1, -1)
						}
					}
					return result
				}
				getEffectiveDotDotDotForParameter := func(p ParameterDeclaration) *DotDotDotToken {
					return p.dotDotDotToken || (__COND__(p.type_ && isJSDocVariadicType(p.type_), factory.createToken(SyntaxKindDotDotDotToken), nil))
				}
				/** Note that `new:T` parameters are not handled, but should be before calling this function. */
				getNameForJSDocFunctionParameter := func(p ParameterDeclaration, index number) string {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case p.name && isIdentifier(p.name) && p.name.escapedText == "this":
						return "this"
					case getEffectiveDotDotDotForParameter(p):
						return `args`
					default:
						return __TEMPLATE__("arg", index)
					}
				}
				rewriteModuleSpecifier := func(parent ImportTypeNode, lit StringLiteral) StringLiteral {
					if context.bundled || context.enclosingFile != getSourceFileOfNode(lit) {
						name := lit.text
						nodeSymbol := getNodeLinks(node).resolvedSymbol
						var meaning /* TODO(TS-TO-GO) inferred type SymbolFlags.Value | SymbolFlags.Type */ any
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case parent.isTypeOf:
							meaning = SymbolFlagsValue
						default:
							meaning = SymbolFlagsType
						}
						parentSymbol := nodeSymbol && isSymbolAccessible(nodeSymbol, context.enclosingDeclaration, meaning /*shouldComputeAliasesToMakeVisible*/, false).accessibility == SymbolAccessibilityAccessible && lookupSymbolChain(nodeSymbol, context, meaning /*yieldModuleSymbol*/, true)[0]
						if parentSymbol && isExternalModuleSymbol(parentSymbol) {
							name = getSpecifierForModuleSymbol(parentSymbol, context)
						} else {
							targetFile := getExternalModuleFileFromDeclaration(parent)
							if targetFile {
								name = getSpecifierForModuleSymbol(targetFile.symbol, context)
							}
						}
						if name.includes("/node_modules/") {
							context.encounteredError = true
							if context.tracker.reportLikelyUnsafeImportRequiredError {
								context.tracker.reportLikelyUnsafeImportRequiredError(name)
							}
						}
						if name != lit.text {
							return setOriginalNode(factory.createStringLiteral(name), lit)
						}
					}
					return visitNode(lit, visitExistingNodeTreeSymbols, isStringLiteral)
				}
			}
		}
		symbolTableToDeclarationStatements := func(symbolTable SymbolTable, context NodeBuilderContext) []Statement {
			serializePropertySymbolForClass := makeSerializePropertySymbol(factory.createPropertyDeclaration, SyntaxKindMethodDeclaration /*useAccessors*/, true)
			serializePropertySymbolForInterfaceWorker := makeSerializePropertySymbol(func(mods *[]Modifier, name /* TODO(TS-TO-GO) inferred type string | PropertyName */ any, question *QuestionToken, type_ *TypeNode) PropertySignature {
				return factory.createPropertySignature(mods, name, question, type_)
			}, SyntaxKindMethodSignature /*useAccessors*/, false)
			// TODO: Use `setOriginalNode` on original declaration names where possible so these declarations see some kind of
			// declaration mapping
			// We save the enclosing declaration off here so it's not adjusted by well-meaning declaration
			// emit codepaths which want to apply more specific contexts (so we can still refer to the root real declaration
			// we're trying to emit from later on)
			enclosingDeclaration := context.enclosingDeclaration
			var results []Statement = []never{}
			visitedSymbols := NewSet[number]()
			var deferredPrivatesStack []Map[SymbolId, Symbol] = []never{}
			oldcontext := context
			context = map[any]any{ /* TODO(TS-TO-GO): was object literal */
				/* TODO(TS-TO-GO) Node SpreadAssignment: ...oldcontext */
				"usedSymbolNames":          NewSet(oldcontext.usedSymbolNames),
				"remappedSymbolNames":      NewMap(),
				"remappedSymbolReferences": NewMap(oldcontext.remappedSymbolReferences. /* TODO(TS-TO-GO): was ? */ entries()),
				"tracker":                  nil,
			}
			var tracker SymbolTracker = map[any]any{ /* TODO(TS-TO-GO): was object literal */
				/* TODO(TS-TO-GO) Node SpreadAssignment: ...oldcontext.tracker.inner */
				"trackSymbol": func(sym Symbol, decl Node, meaning SymbolFlags) bool {
					if context.remappedSymbolNames. /* TODO(TS-TO-GO): was ? */ has(getSymbolId(sym)) {
						return false
						// If the context has a remapped name for the symbol, it *should* mean it's been made visible
					}
					// If the context has a remapped name for the symbol, it *should* mean it's been made visible
					accessibleResult := isSymbolAccessible(sym, decl, meaning /*shouldComputeAliasesToMakeVisible*/, false)
					if accessibleResult.accessibility == SymbolAccessibilityAccessible {
						// Lookup the root symbol of the chain of refs we'll use to access it and serialize it
						chain := lookupSymbolChainWorker(sym, context, meaning)
						if !(sym.flags & SymbolFlagsProperty) {
							// Only include referenced privates in the same file. Weird JS aliases may expose privates
							// from other files - assume JS transforms will make those available via expected means
							root := chain[0]
							contextFile := getSourceFileOfNode(oldcontext.enclosingDeclaration)
							if some(root.declarations, func(d Declaration) bool {
								return getSourceFileOfNode(d) == contextFile
							}) {
								includePrivateSymbol(root)
							}
						}
					} else if oldcontext.tracker.inner. /* TODO(TS-TO-GO): was ? */ trackSymbol {
						return oldcontext.tracker.inner.trackSymbol(sym, decl, meaning)
					}
					return false
				},
			}
			context.tracker = NewSymbolTrackerImpl(context, tracker, oldcontext.tracker.moduleResolverHost)
			forEachEntry(symbolTable, func(symbol Symbol, name __String) {
				baseName := unescapeLeadingUnderscores(name)
				getInternalSymbolName(symbol, baseName)
				// Called to cache values into `usedSymbolNames` and `remappedSymbolNames`
			})
			addingDeclare := !context.bundled
			exportEquals := symbolTable.get(InternalSymbolNameExportEquals)
			if exportEquals && symbolTable.size > 1 && exportEquals.flags&(SymbolFlagsAlias|SymbolFlagsModule) {
				symbolTable = createSymbolTable()
				// Remove extraneous elements from root symbol table (they'll be mixed back in when the target of the `export=` is looked up)
				symbolTable.set(InternalSymbolNameExportEquals, exportEquals)
			}
			visitSymbolTable(symbolTable)
			return mergeRedundantStatements(results)
			isIdentifierAndNotUndefined := func(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is Identifier */ any {
				return !!node && node.kind == SyntaxKindIdentifier
			}
			getNamesOfDeclaration := func(statement Statement) []Identifier {
				if isVariableStatement(statement) {
					return filter(map_(statement.declarationList.declarations, getNameOfDeclaration), isIdentifierAndNotUndefined)
				}
				return filter([]*DeclarationName{getNameOfDeclaration(statement /* as DeclarationStatement */)}, isIdentifierAndNotUndefined)
			}
			flattenExportAssignedNamespace := func(statements []Statement) []Statement {
				exportAssignment := find(statements, isExportAssignment)
				nsIndex := findIndex(statements, isModuleDeclaration)
				var ns *ModuleDeclaration
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case nsIndex != -1:
					ns = statements[nsIndex] /* as ModuleDeclaration */
				default:
					ns = nil
				}
				if ns && exportAssignment && exportAssignment.isExportEquals && isIdentifier(exportAssignment.expression) && isIdentifier(ns.name) && idText(ns.name) == idText(exportAssignment.expression) && ns.body && isModuleBlock(ns.body) {
					// Pass 0: Correct situations where a module has both an `export = ns` and multiple top-level exports by stripping the export modifiers from
					//  the top-level exports and exporting them in the targeted ns, as can occur when a js file has both typedefs and `module.export` assignments
					excessExports := filter(statements, func(s Statement) bool {
						return !!(getEffectiveModifierFlags(s) & ModifierFlagsExport)
					})
					name := ns.name
					body := ns.body
					if length(excessExports) {
						ns = factory.updateModuleDeclaration(ns, ns.modifiers, ns.name /* TODO(TS-TO-GO) Node BinaryExpression: body = factory.updateModuleBlock( body, factory.createNodeArray([ ...ns.body.statements, factory.createExportDeclaration( /*modifiers* / undefined, /*isTypeOnly* / false, factory.createNamedExports(map(flatMap(excessExports, e => getNamesOfDeclaration(e)), id => factory.createExportSpecifier(/*isTypeOnly* / false, /*propertyName* / undefined, id))), /*moduleSpecifier* / undefined, ), ]), ) */, TODO)
						statements = []Statement{ /* TODO(TS-TO-GO) Node SpreadElement: ...statements.slice(0, nsIndex) */ ns /* TODO(TS-TO-GO) Node SpreadElement: ...statements.slice(nsIndex + 1) */}
					}
					// Pass 1: Flatten `export namespace _exports {} export = _exports;` so long as the `export=` only points at a single namespace declaration
					if !find(statements, func(s Statement) bool {
						return s != ns && nodeHasName(s, name)
					}) {
						results = []never{}
						// If the namespace contains no export assignments or declarations, and no declarations flagged with `export`, then _everything_ is exported -
						// to respect this as the top level, we need to add an `export` modifier to everything
						mixinExportFlag := !some(body.statements, func(s Statement) bool {
							return hasSyntacticModifier(s, ModifierFlagsExport) || isExportAssignment(s) || isExportDeclaration(s)
						})
						forEach(body.statements, func(s Statement) {
							addResult(s, __COND__(mixinExportFlag, ModifierFlagsExport, ModifierFlagsNone))
							// Recalculates the ambient (and export, if applicable from above) flag
						})
						statements = []Statement{ /* TODO(TS-TO-GO) Node SpreadElement: ...filter(statements, s => s !== ns && s !== exportAssignment) */ /* TODO(TS-TO-GO) Node SpreadElement: ...results */ }
					}
				}
				return statements
			}
			mergeExportDeclarations := func(statements []Statement) []Statement {
				// Pass 2: Combine all `export {}` declarations
				exports := filter(statements, func(d Statement) bool {
					return isExportDeclaration(d) && !d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause)
				}) /* as ExportDeclaration[] */
				if length(exports) > 1 {
					nonExports := filter(statements, func(d Statement) bool {
						return !isExportDeclaration(d) || !!d.moduleSpecifier || !d.exportClause
					})
					statements = []Statement{ /* TODO(TS-TO-GO) Node SpreadElement: ...nonExports */ factory.createExportDeclaration(nil, false, factory.createNamedExports(flatMap(exports, func(e ExportDeclaration) NodeArray[ExportSpecifier] {
						return cast(e.exportClause, isNamedExports).elements
					})), nil)}
				}
				// Pass 2b: Also combine all `export {} from "..."` declarations as needed
				reexports := filter(statements, func(d Statement) bool {
					return isExportDeclaration(d) && !!d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause)
				}) /* as ExportDeclaration[] */
				if length(reexports) > 1 {
					groups := group(reexports, func(decl ExportDeclaration) string {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isStringLiteral(decl.moduleSpecifier):
							return ">" + decl.moduleSpecifier.text
						default:
							return ">"
						}
					})
					if groups.length != reexports.length {
						for _, group := range groups {
							if group.length > 1 {
								// remove group members from statements and then merge group members and add back to statements
								statements = []Statement{ /* TODO(TS-TO-GO) Node SpreadElement: ...filter(statements, s => !group.includes(s as ExportDeclaration)) */ factory.createExportDeclaration(nil, false, factory.createNamedExports(flatMap(group, func(e ExportDeclaration) NodeArray[ExportSpecifier] {
									return cast(e.exportClause, isNamedExports).elements
								})), group[0].moduleSpecifier)}
							}
						}
					}
				}
				return statements
			}
			inlineExportModifiers := func(statements []Statement) []Statement {
				// Pass 3: Move all `export {}`'s to `export` modifiers where possible
				index := findIndex(statements, func(d Statement) bool {
					return isExportDeclaration(d) && !d.moduleSpecifier && !d.attributes && !!d.exportClause && isNamedExports(d.exportClause)
				})
				if index >= 0 {
					exportDecl := statements[index] /* as ExportDeclaration & { readonly exportClause: NamedExports; } */
					replacements := mapDefined(exportDecl.exportClause.elements, func(e ExportSpecifier) *ExportSpecifier {
						if !e.propertyName && e.name.kind != SyntaxKindStringLiteral {
							// export {name} - look thru `statements` for `name`, and if all results can take an `export` modifier, do so and filter it
							name := e.name
							indices := indicesOf(statements)
							associatedIndices := filter(indices, func(i number) bool {
								return nodeHasName(statements[i], name)
							})
							if length(associatedIndices) && every(associatedIndices, func(i number) bool {
								return canHaveExportModifier(statements[i])
							}) {
								for _, index := range associatedIndices {
									statements[index] = addExportModifier(statements[index] /* as Extract<HasModifiers, Statement> */)
								}
								return nil
							}
						}
						return e
					})
					if !length(replacements) {
						// all clauses removed, remove the export declaration
						orderedRemoveItemAt(statements, index)
					} else {
						// some items filtered, others not - update the export declaration
						statements[index] = factory.updateExportDeclaration(exportDecl, exportDecl.modifiers, exportDecl.isTypeOnly, factory.updateNamedExports(exportDecl.exportClause, replacements), exportDecl.moduleSpecifier, exportDecl.attributes)
					}
				}
				return statements
			}
			mergeRedundantStatements := func(statements []Statement) []Statement {
				statements = flattenExportAssignedNamespace(statements)
				statements = mergeExportDeclarations(statements)
				statements = inlineExportModifiers(statements)
				// Not a cleanup, but as a final step: If there is a mix of `export` and non-`export` declarations, but no `export =` or `export {}` add a `export {};` so
				// declaration privacy is respected.
				if enclosingDeclaration && ((isSourceFile(enclosingDeclaration) && isExternalOrCommonJsModule(enclosingDeclaration)) || isModuleDeclaration(enclosingDeclaration)) && (!some(statements, isExternalModuleIndicator) || (!hasScopeMarker(statements) && some(statements, needsScopeMarker))) {
					statements.push(createEmptyExports(factory))
				}
				return statements
			}
			addExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO(TS-TO-GO) inferred type ClassDeclaration | InterfaceDeclaration | FunctionDeclaration | ExportDeclaration | ModuleDeclaration | TypeAliasDeclaration | EnumDeclaration | ExportAssignment | ImportDeclaration | ImportEqualsDeclaration | VariableStatement */ any {
				flags := (getEffectiveModifierFlags(node) | ModifierFlagsExport) & ~ModifierFlagsAmbient
				return factory.replaceModifiers(node, flags)
			}
			removeExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO(TS-TO-GO) inferred type ClassDeclaration | InterfaceDeclaration | FunctionDeclaration | ExportDeclaration | ModuleDeclaration | TypeAliasDeclaration | EnumDeclaration | ExportAssignment | ImportDeclaration | ImportEqualsDeclaration | VariableStatement */ any {
				flags := getEffectiveModifierFlags(node) & ~ModifierFlagsExport
				return factory.replaceModifiers(node, flags)
			}
			visitSymbolTable := func(symbolTable SymbolTable, suppressNewPrivateContext bool, propertyAsAlias bool) {
				if !suppressNewPrivateContext {
					deferredPrivatesStack.push(NewMap())
				}
				symbolTable.forEach(func(symbol Symbol) {
					serializeSymbol(symbol /*isPrivate*/, false, !!propertyAsAlias)
				})
				if !suppressNewPrivateContext {
					// deferredPrivates will be filled up by visiting the symbol table
					// And will continue to iterate as elements are added while visited `deferredPrivates`
					// (As that's how a map iterator is defined to work)
					deferredPrivatesStack[deferredPrivatesStack.length-1].forEach(func(symbol Symbol) {
						serializeSymbol(symbol /*isPrivate*/, true, !!propertyAsAlias)
					})
					deferredPrivatesStack.pop()
				}
			}
			serializeSymbol := func(symbol Symbol, isPrivate bool, propertyAsAlias bool) {
				getPropertiesOfType(getTypeOfSymbol(symbol))
				// cache visited list based on merged symbol, since we want to use the unmerged top-level symbol, but
				// still skip reserializing it if we encounter the merged product later on
				visitedSym := getMergedSymbol(symbol)
				if visitedSymbols.has(getSymbolId(visitedSym)) {
					return
					// Already printed
				}
				visitedSymbols.add(getSymbolId(visitedSym))
				// Only actually serialize symbols within the correct enclosing declaration, otherwise do nothing with the out-of-context symbol
				skipMembershipCheck := !isPrivate
				// We only call this on exported symbols when we know they're in the correct scope
				if skipMembershipCheck || (!!length(symbol.declarations) && some(symbol.declarations, func(d Declaration) bool {
					return !!findAncestor(d, func(n Node) bool {
						return n == enclosingDeclaration
					})
				})) {
					scopeCleanup := cloneNodeBuilderContext(context)
					serializeSymbolWorker(symbol, isPrivate, propertyAsAlias)
					scopeCleanup()
				}
			}
			// Synthesize declarations for a symbol - might be an Interface, a Class, a Namespace, a Type, a Variable (const, let, or var), an Alias
			// or a merge of some number of those.
			// An interesting challenge is ensuring that when classes merge with namespaces and interfaces, is keeping
			// each symbol in only one of the representations
			// Also, synthesizing a default export of some kind
			// If it's an alias: emit `export default ref`
			// If it's a property: emit `export default _default` with a `_default` prop
			// If it's a class/interface/function: emit a class/interface/function with a `default` modifier
			// These forms can merge, eg (`export default 12; export default interface A {}`)
			serializeSymbolWorker := func(symbol Symbol, isPrivate bool, propertyAsAlias bool, escapedSymbolName __String /*  = symbol.escapedName */) {
				symbolName := unescapeLeadingUnderscores(escapedSymbolName)
				isDefault := escapedSymbolName == InternalSymbolNameDefault
				if isPrivate && !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) && isStringANonContextualKeyword(symbolName) && !isDefault {
					// Oh no. We cannot use this symbol's name as it's name... It's likely some jsdoc had an invalid name like `export` or `default` :(
					context.encounteredError = true
					// TODO: Issue error via symbol tracker?
					return
					// If we need to emit a private with a keyword name, we're done for, since something else will try to refer to it by that name
				}
				needsPostExportDefault := isDefault && !!(symbol.flags&SymbolFlagsExportDoesNotSupportDefaultModifier || (symbol.flags&SymbolFlagsFunction && length(getPropertiesOfType(getTypeOfSymbol(symbol))))) && !(symbol.flags & SymbolFlagsAlias)
				// An alias symbol should preclude needing to make an alias ourselves
				needsExportDeclaration := !needsPostExportDefault && !isPrivate && isStringANonContextualKeyword(symbolName) && !isDefault
				// `serializeVariableOrProperty` will handle adding the export declaration if it is run (since `getInternalSymbolName` will create the name mapping), so we need to ensuer we unset `needsExportDeclaration` if it is
				if needsPostExportDefault || needsExportDeclaration {
					isPrivate = true
				}
				modifierFlags := (__COND__(!isPrivate, ModifierFlagsExport, 0)) | (__COND__(isDefault && !needsPostExportDefault, ModifierFlagsDefault, 0))
				isConstMergedWithNS := symbol.flags&SymbolFlagsModule && symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsFunctionScopedVariable|SymbolFlagsProperty) && escapedSymbolName != InternalSymbolNameExportEquals
				isConstMergedWithNSPrintableAsSignatureMerge := isConstMergedWithNS && isTypeRepresentableAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol)
				if symbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod) || isConstMergedWithNSPrintableAsSignatureMerge {
					serializeAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
				}
				if symbol.flags & SymbolFlagsTypeAlias {
					serializeTypeAlias(symbol, symbolName, modifierFlags)
				}
				// Need to skip over export= symbols below - json source files get a single `Property` flagged
				// symbol of name `export=` which needs to be handled like an alias. It's not great, but it is what it is.
				if symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsFunctionScopedVariable|SymbolFlagsProperty|SymbolFlagsAccessor) && escapedSymbolName != InternalSymbolNameExportEquals && !(symbol.flags & SymbolFlagsPrototype) && !(symbol.flags & SymbolFlagsClass) && !(symbol.flags & SymbolFlagsMethod) && !isConstMergedWithNSPrintableAsSignatureMerge {
					if propertyAsAlias {
						createdExport := serializeMaybeAliasAssignment(symbol)
						if createdExport {
							needsExportDeclaration = false
							needsPostExportDefault = false
						}
					} else {
						type_ := getTypeOfSymbol(symbol)
						localName := getInternalSymbolName(symbol, symbolName)
						if type_.symbol && type_.symbol != symbol && type_.symbol.flags&SymbolFlagsFunction && some(type_.symbol.declarations, isFunctionExpressionOrArrowFunction) && (type_.symbol.members. /* TODO(TS-TO-GO): was ? */ size || type_.symbol.exports. /* TODO(TS-TO-GO): was ? */ size) {
							// assignment of a anonymous expando/class-like function, the func/ns/merge branch below won't trigger,
							// and the assignment form has to reference the unreachable anonymous type so will error.
							// Instead, serialize the type's symbol, but with the current symbol's name, rather than the anonymous one.
							if !context.remappedSymbolReferences {
								context.remappedSymbolReferences = NewMap()
							}
							context.remappedSymbolReferences.set(getSymbolId(type_.symbol), symbol)
							// save name remapping as local name for target symbol
							serializeSymbolWorker(type_.symbol, isPrivate, propertyAsAlias, escapedSymbolName)
							context.remappedSymbolReferences.delete(getSymbolId(type_.symbol))
						} else if !(symbol.flags & SymbolFlagsFunction) && isTypeRepresentableAsFunctionNamespaceMerge(type_, symbol) {
							// If the type looks like a function declaration + ns could represent it, and it's type is sourced locally, rewrite it into a function declaration + ns
							serializeAsFunctionNamespaceMerge(type_, symbol, localName, modifierFlags)
						} else {
							// A Class + Property merge is made for a `module.exports.Member = class {}`, and it doesn't serialize well as either a class _or_ a property symbol - in fact, _it behaves like an alias!_
							// `var` is `FunctionScopedVariable`, `const` and `let` are `BlockScopedVariable`, and `module.exports.thing =` is `Property`
							var flags * /* TODO(TS-TO-GO) inferred type NodeFlags.Let | NodeFlags.Const */ any
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case !(symbol.flags & SymbolFlagsBlockScopedVariable):
								// TODO(TS-TO-GO): converted from conditional expression
								switch {
								case symbol.parent. /* TODO(TS-TO-GO): was ? */ valueDeclaration && isSourceFile(symbol.parent. /* TODO(TS-TO-GO): was ? */ valueDeclaration):
									flags = NodeFlagsConst
								default:
									flags = nil
								}
							case isConstantVariable(symbol):
								flags = NodeFlagsConst
							default:
								flags = NodeFlagsLet
							}
							var name string
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case (needsPostExportDefault || !(symbol.flags & SymbolFlagsProperty)):
								name = localName
							default:
								name = getUnusedName(localName, symbol)
							}
							var textRange Node = symbol.declarations && find(symbol.declarations, func(d Declaration) bool {
								return isVariableDeclaration(d)
							})
							if textRange && isVariableDeclarationList(textRange.parent) && textRange.parent.declarations.length == 1 {
								textRange = textRange.parent.parent
							}
							propertyAccessRequire := symbol.declarations. /* TODO(TS-TO-GO): was ? */ find(isPropertyAccessExpression)
							if propertyAccessRequire && isBinaryExpression(propertyAccessRequire.parent) && isIdentifier(propertyAccessRequire.parent.right) && type_.symbol. /* TODO(TS-TO-GO): was ? */ valueDeclaration && isSourceFile(type_.symbol.valueDeclaration) {
								var alias *Identifier
								// TODO(TS-TO-GO): converted from conditional expression
								switch {
								case localName == propertyAccessRequire.parent.right.escapedText:
									alias = nil
								default:
									alias = propertyAccessRequire.parent.right
								}
								addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports([]ExportSpecifier{factory.createExportSpecifier(false, alias, localName)})), ModifierFlagsNone)
								context.tracker.trackSymbol(type_.symbol, context.enclosingDeclaration, SymbolFlagsValue)
							} else {
								statement := setTextRange(context, factory.createVariableStatement(nil, factory.createVariableDeclarationList([]VariableDeclaration{factory.createVariableDeclaration(name /*exclamationToken*/, nil, serializeTypeForDeclaration(context /*declaration*/, nil, type_, symbol))}, flags)), textRange)
								addResult(statement, __COND__(name != localName, modifierFlags&~ModifierFlagsExport, modifierFlags))
								if name != localName && !isPrivate {
									// We rename the variable declaration we generate for Property symbols since they may have a name which
									// conflicts with a local declaration. For example, given input:
									// ```
									// function g() {}
									// module.exports.g = g
									// ```
									// In such a situation, we have a local variable named `g`, and a separate exported variable named `g`.
									// Naively, we would emit
									// ```
									// function g() {}
									// export const g: typeof g;
									// ```
									// That's obviously incorrect - the `g` in the type annotation needs to refer to the local `g`, but
									// the export declaration shadows it.
									// To work around that, we instead write
									// ```
									// function g() {}
									// const g_1: typeof g;
									// export { g_1 as g };
									// ```
									// To create an export named `g` that does _not_ shadow the local `g`
									addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports([]ExportSpecifier{factory.createExportSpecifier(false, name, localName)})), ModifierFlagsNone)
									needsExportDeclaration = false
									needsPostExportDefault = false
								}
							}
						}
					}
				}
				if symbol.flags & SymbolFlagsEnum {
					serializeEnum(symbol, symbolName, modifierFlags)
				}
				if symbol.flags & SymbolFlagsClass {
					if symbol.flags&SymbolFlagsProperty && symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration.parent) && isClassExpression(symbol.valueDeclaration.parent.right) {
						// Looks like a `module.exports.Sub = class {}` - if we serialize `symbol` as a class, the result will have no members,
						// since the classiness is actually from the target of the effective alias the symbol is. yes. A BlockScopedVariable|Class|Property
						// _really_ acts like an Alias, and none of a BlockScopedVariable, Class, or Property. This is the travesty of JS binding today.
						serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
					} else {
						serializeAsClass(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
					}
				}
				if (symbol.flags&(SymbolFlagsValueModule|SymbolFlagsNamespaceModule) && (!isConstMergedWithNS || isTypeOnlyNamespace(symbol))) || isConstMergedWithNSPrintableAsSignatureMerge {
					serializeModule(symbol, symbolName, modifierFlags)
				}
				// The class meaning serialization should handle serializing all interface members
				if symbol.flags&SymbolFlagsInterface && !(symbol.flags & SymbolFlagsClass) {
					serializeInterface(symbol, symbolName, modifierFlags)
				}
				if symbol.flags & SymbolFlagsAlias {
					serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
				}
				if symbol.flags&SymbolFlagsProperty && symbol.escapedName == InternalSymbolNameExportEquals {
					serializeMaybeAliasAssignment(symbol)
				}
				if symbol.flags & SymbolFlagsExportStar {
					// synthesize export * from "moduleReference"
					// Straightforward - only one thing to do - make an export declaration
					if symbol.declarations {
						for _, node := range symbol.declarations {
							resolvedModule := resolveExternalModuleName(node, (node /* as ExportDeclaration */).moduleSpecifier)
							if !resolvedModule {
								continue
							}
							addResult(factory.createExportDeclaration(nil /*isTypeOnly*/, (node /* as ExportDeclaration */).isTypeOnly /*exportClause*/, nil, factory.createStringLiteral(getSpecifierForModuleSymbol(resolvedModule, context))), ModifierFlagsNone)
						}
					}
				}
				if needsPostExportDefault {
					addResult(factory.createExportAssignment(nil /*isExportEquals*/, false, factory.createIdentifier(getInternalSymbolName(symbol, symbolName))), ModifierFlagsNone)
				} else if needsExportDeclaration {
					addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports([]ExportSpecifier{factory.createExportSpecifier(false, getInternalSymbolName(symbol, symbolName), symbolName)})), ModifierFlagsNone)
				}
			}
			includePrivateSymbol := func(symbol Symbol) {
				if some(symbol.declarations, isPartOfParameterDeclaration) {
					return
				}
				Debug.assertIsDefined(deferredPrivatesStack[deferredPrivatesStack.length-1])
				getUnusedName(unescapeLeadingUnderscores(symbol.escapedName), symbol)
				// Blanket moving (import) aliases into the root private context should work, since imports are not valid within namespaces
				// (so they must have been in the root to begin with if they were real imports) cjs `require` aliases (an upcoming feature)
				// will throw a wrench in this, since those may have been nested, but we'll need to synthesize them in the outer scope
				// anyway, as that's the only place the import they translate to is valid. In such a case, we might need to use a unique name
				// for the moved import; which hopefully the above `getUnusedName` call should produce.
				isExternalImportAlias := !!(symbol.flags & SymbolFlagsAlias) && !some(symbol.declarations, func(d Declaration) bool {
					return !!findAncestor(d, isExportDeclaration) || isNamespaceExport(d) || (isImportEqualsDeclaration(d) && !isExternalModuleReference(d.moduleReference))
				})
				deferredPrivatesStack[__COND__(isExternalImportAlias, 0, (deferredPrivatesStack.length-1))].set(getSymbolId(symbol), symbol)
			}
			isExportingScope := func(enclosingDeclaration Node) bool {
				return ((isSourceFile(enclosingDeclaration) && (isExternalOrCommonJsModule(enclosingDeclaration) || isJsonSourceFile(enclosingDeclaration))) || (isAmbientModule(enclosingDeclaration) && !isGlobalScopeAugmentation(enclosingDeclaration)))
			}
			// Prepends a `declare` and/or `export` modifier if the context requires it, and then adds `node` to `result` and returns `node`
			addResult := func(node Statement, additionalModifierFlags ModifierFlags) {
				if canHaveModifiers(node) {
					var newModifierFlags ModifierFlags = ModifierFlagsNone
					enclosingDeclaration := context.enclosingDeclaration && (__COND__(isJSDocTypeAlias(context.enclosingDeclaration), getSourceFileOfNode(context.enclosingDeclaration), context.enclosingDeclaration))
					if additionalModifierFlags&ModifierFlagsExport && enclosingDeclaration && (isExportingScope(enclosingDeclaration) || isModuleDeclaration(enclosingDeclaration)) && canHaveExportModifier(node) {
						// Classes, namespaces, variables, functions, interfaces, and types should all be `export`ed in a module context if not private
						newModifierFlags |= ModifierFlagsExport
					}
					if addingDeclare && !(newModifierFlags & ModifierFlagsExport) && (!enclosingDeclaration || !(enclosingDeclaration.flags & NodeFlagsAmbient)) && (isEnumDeclaration(node) || isVariableStatement(node) || isFunctionDeclaration(node) || isClassDeclaration(node) || isModuleDeclaration(node)) {
						// Classes, namespaces, variables, enums, and functions all need `declare` modifiers to be valid in a declaration file top-level scope
						newModifierFlags |= ModifierFlagsAmbient
					}
					if (additionalModifierFlags & ModifierFlagsDefault) && (isClassDeclaration(node) || isInterfaceDeclaration(node) || isFunctionDeclaration(node)) {
						newModifierFlags |= ModifierFlagsDefault
					}
					if newModifierFlags {
						node = factory.replaceModifiers(node, newModifierFlags|getEffectiveModifierFlags(node))
					}
				}
				results.push(node)
			}
			serializeTypeAlias := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				aliasType := getDeclaredTypeOfTypeAlias(symbol)
				typeParams := getSymbolLinks(symbol).typeParameters
				typeParamDecls := map_(typeParams, func(p TypeParameter) TypeParameterDeclaration {
					return typeParameterToDeclaration(p, context)
				})
				jsdocAliasDecl := symbol.declarations. /* TODO(TS-TO-GO): was ? */ find(isJSDocTypeAlias)
				commentText := getTextOfJSDocComment(__COND__(jsdocAliasDecl, jsdocAliasDecl.comment || jsdocAliasDecl.parent.comment, nil))
				restoreFlags := saveRestoreFlags(context)
				context.flags |= NodeBuilderFlagsInTypeAlias
				oldEnclosingDecl := context.enclosingDeclaration
				context.enclosingDeclaration = jsdocAliasDecl
				typeNode := jsdocAliasDecl && jsdocAliasDecl.typeExpression && isJSDocTypeExpression(jsdocAliasDecl.typeExpression) && tryReuseExistingNonParameterTypeNode(context, jsdocAliasDecl.typeExpression.type_, aliasType /*host*/, nil) || typeToTypeNodeHelper(aliasType, context)
				addResult(setSyntheticLeadingComments(factory.createTypeAliasDeclaration(nil, getInternalSymbolName(symbol, symbolName), typeParamDecls, typeNode), __COND__(!commentText, []never{}, [] /* TODO(TS-TO-GO) inferred type { kind: SyntaxKind.MultiLineCommentTrivia; text: string; pos: -1; end: -1; hasTrailingNewLine: true; } */ any{map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"kind":               SyntaxKindMultiLineCommentTrivia,
					"text":               "*\n * " + commentText.replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\n/g */ TODO, "\n * ") + "\n ",
					"pos":                -1,
					"end":                -1,
					"hasTrailingNewLine": true,
				}})), modifierFlags)
				restoreFlags()
				context.enclosingDeclaration = oldEnclosingDecl
			}
			serializeInterface := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				interfaceType := getDeclaredTypeOfClassOrInterface(symbol)
				localParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				typeParamDecls := map_(localParams, func(p TypeParameter) TypeParameterDeclaration {
					return typeParameterToDeclaration(p, context)
				})
				baseTypes := getBaseTypes(interfaceType)
				var baseType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case length(baseTypes):
					baseType = getIntersectionType(baseTypes)
				default:
					baseType = nil
				}
				members := flatMap(getPropertiesOfType(interfaceType), func(p Symbol) [] /* TODO(TS-TO-GO) inferred type TypeElement | TypeElement */ any {
					return serializePropertySymbolForInterface(p, baseType)
				})
				callSignatures := serializeSignatures(SignatureKindCall, interfaceType, baseType, SyntaxKindCallSignature)                /* as CallSignatureDeclaration[] */
				constructSignatures := serializeSignatures(SignatureKindConstruct, interfaceType, baseType, SyntaxKindConstructSignature) /* as ConstructSignatureDeclaration[] */
				indexSignatures := serializeIndexSignatures(interfaceType, baseType)
				var heritageClauses *[]HeritageClause
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case !length(baseTypes):
					heritageClauses = nil
				default:
					heritageClauses = []HeritageClause{factory.createHeritageClause(SyntaxKindExtendsKeyword, mapDefined(baseTypes, func(b BaseType) *ExpressionWithTypeArguments {
						return trySerializeAsTypeReference(b, SymbolFlagsValue)
					}))}
				}
				addResult(factory.createInterfaceDeclaration(nil, getInternalSymbolName(symbol, symbolName), typeParamDecls, heritageClauses, []TypeElement{ /* TODO(TS-TO-GO) Node SpreadElement: ...indexSignatures */ /* TODO(TS-TO-GO) Node SpreadElement: ...constructSignatures */ /* TODO(TS-TO-GO) Node SpreadElement: ...callSignatures */ /* TODO(TS-TO-GO) Node SpreadElement: ...members */ }), modifierFlags)
			}
			getNamespaceMembersForSerialization := func(symbol Symbol) []Symbol {
				exports := arrayFrom(getExportsOfSymbol(symbol).values())
				merged := getMergedSymbol(symbol)
				if merged != symbol {
					membersSet := NewSet(exports)
					for _, exported := range getExportsOfSymbol(merged).values() {
						if !(getSymbolFlags(resolveSymbol(exported)) & SymbolFlagsValue) {
							membersSet.add(exported)
						}
					}
					exports = arrayFrom(membersSet)
				}
				return filter(exports, func(m Symbol) bool {
					return isNamespaceMember(m) && isIdentifierText(m.escapedName /* as string */, ScriptTargetESNext)
				})
			}
			isTypeOnlyNamespace := func(symbol Symbol) bool {
				return every(getNamespaceMembersForSerialization(symbol), func(m Symbol) bool {
					return !(getSymbolFlags(resolveSymbol(m)) & SymbolFlagsValue)
				})
			}
			serializeModule := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				members := getNamespaceMembersForSerialization(symbol)
				// Split NS members up by declaration - members whose parent symbol is the ns symbol vs those whose is not (but were added in later via merging)
				locationMap := arrayToMultiMap(members, func(m Symbol) /* TODO(TS-TO-GO) inferred type "real" | "merged" */ any {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case m.parent && m.parent == symbol:
						return "real"
					default:
						return "merged"
					}
				})
				realMembers := locationMap.get("real") || emptyArray
				mergedMembers := locationMap.get("merged") || emptyArray
				// TODO: `suppressNewPrivateContext` is questionable -we need to simply be emitting privates in whatever scope they were declared in, rather
				// than whatever scope we traverse to them in. That's a bit of a complex rewrite, since we're not _actually_ tracking privates at all in advance,
				// so we don't even have placeholders to fill in.
				if length(realMembers) {
					localName := getInternalSymbolName(symbol, symbolName)
					serializeAsNamespaceDeclaration(realMembers, localName, modifierFlags, !!(symbol.flags & (SymbolFlagsFunction | SymbolFlagsAssignment)))
				}
				if length(mergedMembers) {
					containingFile := getSourceFileOfNode(context.enclosingDeclaration)
					localName := getInternalSymbolName(symbol, symbolName)
					nsBody := factory.createModuleBlock([]ExportDeclaration{factory.createExportDeclaration(nil, false, factory.createNamedExports(mapDefined(filter(mergedMembers, func(n Symbol) bool {
						return n.escapedName != InternalSymbolNameExportEquals
					}), func(s Symbol) *ExportSpecifier {
						name := unescapeLeadingUnderscores(s.escapedName)
						localName := getInternalSymbolName(s, name)
						aliasDecl := s.declarations && getDeclarationOfAliasSymbol(s)
						if containingFile && (__COND__(aliasDecl, containingFile != getSourceFileOfNode(aliasDecl), !some(s.declarations, func(d Declaration) bool {
							return getSourceFileOfNode(d) == containingFile
						}))) {
							context.tracker. /* TODO(TS-TO-GO): was ? */ reportNonlocalAugmentation(containingFile, symbol, s)
							return nil
						}
						target := aliasDecl && getTargetOfAliasDeclaration(aliasDecl /*dontRecursivelyResolve*/, true)
						includePrivateSymbol(target || s)
						var targetName string
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case target:
							targetName = getInternalSymbolName(target, unescapeLeadingUnderscores(target.escapedName))
						default:
							targetName = localName
						}
						return factory.createExportSpecifier(false, __COND__(name == targetName, nil, targetName), name)
					})))})
					addResult(factory.createModuleDeclaration(nil, factory.createIdentifier(localName), nsBody, NodeFlagsNamespace), ModifierFlagsNone)
				}
			}
			serializeEnum := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				addResult(factory.createEnumDeclaration(factory.createModifiersFromModifierFlags(__COND__(isConstEnumSymbol(symbol), ModifierFlagsConst, 0)), getInternalSymbolName(symbol, symbolName), map_(filter(getPropertiesOfType(getTypeOfSymbol(symbol)), func(p Symbol) bool {
					return !!(p.flags & SymbolFlagsEnumMember)
				}), func(p Symbol) EnumMember {
					// TODO: Handle computed names
					// I hate that to get the initialized value we need to walk back to the declarations here; but there's no
					// other way to get the possible const value of an enum member that I'm aware of, as the value is cached
					// _on the declaration_, not on the declaration's symbol...
					var initializedValue * /* TODO(TS-TO-GO) inferred type string | number */ any
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case p.declarations && p.declarations[0] && isEnumMember(p.declarations[0]):
						initializedValue = getConstantValue(p.declarations[0])
					default:
						initializedValue = nil
					}
					return factory.createEnumMember(unescapeLeadingUnderscores(p.escapedName), __COND__(initializedValue == nil, nil, __COND__( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof initializedValue */ TODO == "string", factory.createStringLiteral(initializedValue), factory.createNumericLiteral(initializedValue))))
				})), modifierFlags)
			}
			serializeAsFunctionNamespaceMerge := func(type_ Type, symbol Symbol, localName string, modifierFlags ModifierFlags) {
				signatures := getSignaturesOfType(type_, SignatureKindCall)
				for _, sig := range signatures {
					// Each overload becomes a separate function declaration, in order
					decl := signatureToSignatureDeclarationHelper(sig, SyntaxKindFunctionDeclaration, context, map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"name": factory.createIdentifier(localName),
					}) /* as FunctionDeclaration */
					addResult(setTextRange(context, decl, getSignatureTextRangeLocation(sig)), modifierFlags)
				}
				// Module symbol emit will take care of module-y members, provided it has exports
				if !(symbol.flags&(SymbolFlagsValueModule|SymbolFlagsNamespaceModule) && !!symbol.exports && !!symbol.exports.size) {
					props := filter(getPropertiesOfType(type_), isNamespaceMember)
					serializeAsNamespaceDeclaration(props, localName, modifierFlags /*suppressNewPrivateContext*/, true)
				}
			}
			getSignatureTextRangeLocation := func(signature Signature) * /* TODO(TS-TO-GO) inferred type SignatureDeclaration | BinaryExpression | JSDocSignature | VariableDeclarationList | CatchClause */ any {
				if signature.declaration && signature.declaration.parent {
					if isBinaryExpression(signature.declaration.parent) && getAssignmentDeclarationKind(signature.declaration.parent) == AssignmentDeclarationKindProperty {
						return signature.declaration.parent
					}
					// for expressions assigned to `var`s, use the `var` as the text range
					if isVariableDeclaration(signature.declaration.parent) && signature.declaration.parent.parent {
						return signature.declaration.parent.parent
					}
				}
				return signature.declaration
			}
			serializeAsNamespaceDeclaration := func(props []Symbol, localName string, modifierFlags ModifierFlags, suppressNewPrivateContext bool) {
				if length(props) {
					localVsRemoteMap := arrayToMultiMap(props, func(p Symbol) /* TODO(TS-TO-GO) inferred type "local" | "remote" */ any {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case !length(p.declarations) || some(p.declarations, func(d Declaration) bool {
							return getSourceFileOfNode(d) == getSourceFileOfNode(context.enclosingDeclaration)
						}):
							return "local"
						default:
							return "remote"
						}
					})
					localProps := localVsRemoteMap.get("local") || emptyArray
					// handle remote props first - we need to make an `import` declaration that points at the module containing each remote
					// prop in the outermost scope (TODO: a namespace within a namespace would need to be appropriately handled by this)
					// Example:
					// import Foo_1 = require("./exporter");
					// export namespace ns {
					//     import Foo = Foo_1.Foo;
					//     export { Foo };
					//     export const c: number;
					// }
					// This is needed because in JS, statements like `const x = require("./f")` support both type and value lookup, even if they're
					// normally just value lookup (so it functions kinda like an alias even when it's not an alias)
					// _Usually_, we'll simply print the top-level as an alias instead of a `var` in such situations, however is is theoretically
					// possible to encounter a situation where a type has members from both the current file and other files - in those situations,
					// emit akin to the above would be needed.
					// Add a namespace
					// Create namespace as non-synthetic so it is usable as an enclosing declaration
					fakespace := parseNodeFactory.createModuleDeclaration(nil, factory.createIdentifier(localName), factory.createModuleBlock([]never{}), NodeFlagsNamespace)
					setParent(fakespace, enclosingDeclaration /* as SourceFile | NamespaceDeclaration */)
					fakespace.locals = createSymbolTable(props)
					fakespace.symbol = props[0].parent
					oldResults := results
					results = []never{}
					oldAddingDeclare := addingDeclare
					addingDeclare = false
					subcontext := map[any]any{ /* TODO(TS-TO-GO): was object literal */
						/* TODO(TS-TO-GO) Node SpreadAssignment: ...context */
						"enclosingDeclaration": fakespace,
					}
					oldContext := context
					context = subcontext
					// TODO: implement handling for the localVsRemoteMap.get("remote") - should be difficult to trigger (see comment above), as only interesting cross-file js merges should make this possible
					visitSymbolTable(createSymbolTable(localProps), suppressNewPrivateContext /*propertyAsAlias*/, true)
					context = oldContext
					addingDeclare = oldAddingDeclare
					declarations := results
					results = oldResults
					// replace namespace with synthetic version
					defaultReplaced := map_(declarations, func(d Statement) Statement {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isExportAssignment(d) && !d.isExportEquals && isIdentifier(d.expression):
							return factory.createExportDeclaration(nil, false, factory.createNamedExports([]ExportSpecifier{factory.createExportSpecifier(false, d.expression, factory.createIdentifier(InternalSymbolNameDefault))}))
						default:
							return d
						}
					})
					var exportModifierStripped []Statement
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case every(defaultReplaced, func(d Statement) bool {
						return hasSyntacticModifier(d, ModifierFlagsExport)
					}):
						exportModifierStripped = map_(defaultReplaced /* as Extract<HasModifiers, Statement>[] */, removeExportModifier)
					default:
						exportModifierStripped = defaultReplaced
					}
					fakespace = factory.updateModuleDeclaration(fakespace, fakespace.modifiers, fakespace.name, factory.createModuleBlock(exportModifierStripped))
					addResult(fakespace, modifierFlags)
					// namespaces can never be default exported
				}
			}
			isNamespaceMember := func(p Symbol) bool {
				return !!(p.flags & (SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsAlias)) || !(p.flags&SymbolFlagsPrototype || p.escapedName == "prototype" || p.valueDeclaration && isStatic(p.valueDeclaration) && isClassLike(p.valueDeclaration.parent))
			}
			sanitizeJSDocImplements := func(clauses []ExpressionWithTypeArguments) *[]ExpressionWithTypeArguments {
				result := mapDefined(clauses, func(e ExpressionWithTypeArguments) *ExpressionWithTypeArguments {
					oldEnclosing := context.enclosingDeclaration
					context.enclosingDeclaration = e
					expr := e.expression
					if isEntityNameExpression(expr) {
						if isIdentifier(expr) && idText(expr) == "" {
							return cleanup(nil)
							// Empty heritage clause, should be an error, but prefer emitting no heritage clauses to reemitting the empty one
						}
						var introducesError bool
						( /* TODO(TS-TO-GO) Node BinaryExpression: { introducesError, node: expr } = trackExistingEntityName(expr, context) */ TODO)
						if introducesError {
							return cleanup(nil)
						}
					}
					return cleanup(factory.createExpressionWithTypeArguments(expr, map_(e.typeArguments, func(a TypeNode) TypeNode {
						return tryReuseExistingNonParameterTypeNode(context, a, getTypeFromTypeNode(context, a)) || typeToTypeNodeHelper(getTypeFromTypeNode(context, a), context)
					})))
					cleanup := func(result T) T {
						context.enclosingDeclaration = oldEnclosing
						return result
					}
				})
				if result.length == clauses.length {
					return result
				}
				return nil
			}
			serializeAsClass := func(symbol Symbol, localName string, modifierFlags ModifierFlags) {
				originalDecl := symbol.declarations. /* TODO(TS-TO-GO): was ? */ find(isClassLike)
				oldEnclosing := context.enclosingDeclaration
				context.enclosingDeclaration = originalDecl || oldEnclosing
				localParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				typeParamDecls := map_(localParams, func(p TypeParameter) TypeParameterDeclaration {
					return typeParameterToDeclaration(p, context)
				})
				classType := getTypeWithThisArgument(getDeclaredTypeOfClassOrInterface(symbol)) /* as InterfaceType */
				baseTypes := getBaseTypes(classType)
				originalImplements := originalDecl && getEffectiveImplementsTypeNodes(originalDecl)
				implementsExpressions := originalImplements && sanitizeJSDocImplements(originalImplements) || mapDefined(getImplementsTypes(classType), serializeImplementedType)
				staticType := getTypeOfSymbol(symbol)
				isClass := !!staticType.symbol. /* TODO(TS-TO-GO): was ? */ valueDeclaration && isClassLike(staticType.symbol.valueDeclaration)
				var staticBaseType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isClass:
					staticBaseType = getBaseConstructorTypeOfClass(staticType /* as InterfaceType */)
				default:
					staticBaseType = anyType
				}
				heritageClauses := []HeritageClause{ /* TODO(TS-TO-GO) Node SpreadElement: ...!length(baseTypes) ? [] : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, map(baseTypes, b => serializeBaseType(b, staticBaseType, localName)))] */ /* TODO(TS-TO-GO) Node SpreadElement: ...!length(implementsExpressions) ? [] : [factory.createHeritageClause(SyntaxKind.ImplementsKeyword, implementsExpressions)] */ }
				symbolProps := getNonInheritedProperties(classType, baseTypes, getPropertiesOfType(classType))
				publicSymbolProps := filter(symbolProps, func(s Symbol) bool {
					// `valueDeclaration` could be undefined if inherited from
					// a union/intersection base type, but inherited properties
					// don't matter here.
					valueDecl := s.valueDeclaration
					return !!valueDecl && !(isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name))
				})
				hasPrivateIdentifier := some(symbolProps, func(s Symbol) bool {
					// `valueDeclaration` could be undefined if inherited from
					// a union/intersection base type, but inherited properties
					// don't matter here.
					valueDecl := s.valueDeclaration
					return !!valueDecl && isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name)
				})
				// Boil down all private properties into a single one.
				var privateProperties []PropertyDeclaration
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case hasPrivateIdentifier:
					privateProperties = []PropertyDeclaration{factory.createPropertyDeclaration(nil, factory.createPrivateIdentifier("#private"), nil, nil, nil)}
				default:
					privateProperties = emptyArray
				}
				publicProperties := flatMap(publicSymbolProps, func(p Symbol) [] /* TODO(TS-TO-GO) inferred type ClassElement | AccessorDeclaration | (ClassElement | AccessorDeclaration) */ any {
					return serializePropertySymbolForClass(p /*isStatic*/, false, baseTypes[0])
				})
				// Consider static members empty if symbol also has function or module meaning - function namespacey emit will handle statics
				staticMembers := flatMap(filter(getPropertiesOfType(staticType), func(p Symbol) bool {
					return !(p.flags & SymbolFlagsPrototype) && p.escapedName != "prototype" && !isNamespaceMember(p)
				}), func(p Symbol) [] /* TODO(TS-TO-GO) inferred type ClassElement | AccessorDeclaration | (ClassElement | AccessorDeclaration) */ any {
					return serializePropertySymbolForClass(p /*isStatic*/, true, staticBaseType)
				})
				// When we encounter an `X.prototype.y` assignment in a JS file, we bind `X` as a class regardless as to whether
				// the value is ever initialized with a class or function-like value. For cases where `X` could never be
				// created via `new`, we will inject a `private constructor()` declaration to indicate it is not createable.
				isNonConstructableClassLikeInJsFile := !isClass && !!symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && !some(getSignaturesOfType(staticType, SignatureKindConstruct))
				var constructors []ConstructorDeclaration
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isNonConstructableClassLikeInJsFile:
					constructors = []ConstructorDeclaration{factory.createConstructorDeclaration(factory.createModifiersFromModifierFlags(ModifierFlagsPrivate), []never{} /*body*/, nil)}
				default:
					constructors = serializeSignatures(SignatureKindConstruct, staticType, staticBaseType, SyntaxKindConstructor) /* as ConstructorDeclaration[] */
				}
				indexSignatures := serializeIndexSignatures(classType, baseTypes[0])
				context.enclosingDeclaration = oldEnclosing
				addResult(setTextRange(context, factory.createClassDeclaration(nil, localName, typeParamDecls, heritageClauses, []ClassElement{ /* TODO(TS-TO-GO) Node SpreadElement: ...indexSignatures */ /* TODO(TS-TO-GO) Node SpreadElement: ...staticMembers */ /* TODO(TS-TO-GO) Node SpreadElement: ...constructors */ /* TODO(TS-TO-GO) Node SpreadElement: ...publicProperties */ /* TODO(TS-TO-GO) Node SpreadElement: ...privateProperties */ }), symbol.declarations && filter(symbol.declarations, func(d Declaration) bool {
					return isClassDeclaration(d) || isClassExpression(d)
				})[0]), modifierFlags)
			}
			getSomeTargetNameFromDeclarations := func(declarations *[]Declaration) *string {
				return firstDefined(declarations, func(d Declaration) *string {
					if isImportSpecifier(d) || isExportSpecifier(d) {
						return moduleExportNameTextUnescaped(d.propertyName || d.name)
					}
					if isBinaryExpression(d) || isExportAssignment(d) {
						var expression Expression
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isExportAssignment(d):
							expression = d.expression
						default:
							expression = d.right
						}
						if isPropertyAccessExpression(expression) {
							return idText(expression.name)
						}
					}
					if isAliasSymbolDeclaration(d) {
						// This is... heuristic, at best. But it's probably better than always printing the name of the shorthand ambient module.
						name := getNameOfDeclaration(d)
						if name && isIdentifier(name) {
							return idText(name)
						}
					}
					return nil
				})
			}
			serializeAsAlias := func(symbol Symbol, localName string, modifierFlags ModifierFlags) undefined {
				// synthesize an alias, eg `export { symbolName as Name }`
				// need to mark the alias `symbol` points at
				// as something we need to serialize as a private declaration as well
				node := getDeclarationOfAliasSymbol(symbol)
				if !node {
					return Debug.fail()
				}
				target := getMergedSymbol(getTargetOfAliasDeclaration(node /*dontRecursivelyResolve*/, true))
				if !target {
					return
				}
				// If `target` refers to a shorthand module symbol, the name we're trying to pull out isn;t recoverable from the target symbol
				// In such a scenario, we must fall back to looking for an alias declaration on `symbol` and pulling the target name from that
				verbatimTargetName := isShorthandAmbientModuleSymbol(target) && getSomeTargetNameFromDeclarations(symbol.declarations) || unescapeLeadingUnderscores(target.escapedName)
				if verbatimTargetName == InternalSymbolNameExportEquals && allowSyntheticDefaultImports {
					// target refers to an `export=` symbol that was hoisted into a synthetic default - rename here to match
					verbatimTargetName = InternalSymbolNameDefault
				}
				targetName := getInternalSymbolName(target, verbatimTargetName)
				includePrivateSymbol(target)
				// the target may be within the same scope - attempt to serialize it first
				switch node.kind {
				case SyntaxKindBindingElement:
					if node.parent. /* TODO(TS-TO-GO): was ? */ parent. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindVariableDeclaration {
						// const { SomeClass } = require('./lib');
						specifier := getSpecifierForModuleSymbol(target.parent || target, context)
						// './lib'
						TODO_IDENTIFIER := node /* as BindingElement */
						addResult(factory.createImportDeclaration(nil, factory.createImportClause(false, nil, factory.createNamedImports([]ImportSpecifier{factory.createImportSpecifier(false, __COND__(propertyName && isIdentifier(propertyName), factory.createIdentifier(idText(propertyName)), nil), factory.createIdentifier(localName))})), factory.createStringLiteral(specifier), nil), ModifierFlagsNone)
						break
					}
					Debug.failBadSyntaxKind(node.parent. /* TODO(TS-TO-GO): was ? */ parent || node, "Unhandled binding element grandparent kind in declaration serialization")
					break
				case SyntaxKindShorthandPropertyAssignment:
					if node.parent. /* TODO(TS-TO-GO): was ? */ parent. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindBinaryExpression {
						// module.exports = { SomeClass }
						serializeExportSpecifier(unescapeLeadingUnderscores(symbol.escapedName), targetName)
					}
					break
				case SyntaxKindVariableDeclaration:
					if isPropertyAccessExpression((node /* as VariableDeclaration */).initializer) {
						// const x = require('y').z
						initializer := (node /* as VariableDeclaration */).initializer /* as PropertyAccessExpression */
						// require('y').z
						uniqueName := factory.createUniqueName(localName)
						// _x
						specifier := getSpecifierForModuleSymbol(target.parent || target, context)
						// import _x = require('y');
						addResult(factory.createImportEqualsDeclaration(nil, false, uniqueName, factory.createExternalModuleReference(factory.createStringLiteral(specifier))), ModifierFlagsNone)
						// import x = _x.z
						addResult(factory.createImportEqualsDeclaration(nil, false, factory.createIdentifier(localName), factory.createQualifiedName(uniqueName, initializer.name /* as Identifier */)), modifierFlags)
						break
					}
					fallthrough
				case SyntaxKindImportEqualsDeclaration:
					if target.escapedName == InternalSymbolNameExportEquals && some(target.declarations, func(d Declaration) bool {
						return isSourceFile(d) && isJsonSourceFile(d)
					}) {
						serializeMaybeAliasAssignment(symbol)
						break
					}
					isLocalImport := !(target.flags & SymbolFlagsValueModule) && !isVariableDeclaration(node)
					addResult(factory.createImportEqualsDeclaration(nil, false, factory.createIdentifier(localName), __COND__(isLocalImport, symbolToName(target, context, SymbolFlagsAll /*expectsIdentifier*/, false), factory.createExternalModuleReference(factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))))), __COND__(isLocalImport, modifierFlags, ModifierFlagsNone))
					break
				case SyntaxKindNamespaceExportDeclaration:
					addResult(factory.createNamespaceExportDeclaration(idText((node /* as NamespaceExportDeclaration */).name)), ModifierFlagsNone)
					break
				case SyntaxKindImportClause:
					generatedSpecifier := getSpecifierForModuleSymbol(target.parent || target, context)
					// generate specifier (even though we're reusing and existing one) for ambient module reference include side effects
					var specifier Expression
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case context.bundled:
						specifier = factory.createStringLiteral(generatedSpecifier)
					default:
						specifier = (node /* as ImportClause */).parent.moduleSpecifier
					}
					var attributes *ImportAttributes
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isImportDeclaration(node.parent):
						attributes = node.parent.attributes
					default:
						attributes = nil
					}
					isTypeOnly := isJSDocImportTag((node /* as ImportClause */).parent)
					addResult(factory.createImportDeclaration(nil, factory.createImportClause(isTypeOnly, factory.createIdentifier(localName) /*namedBindings*/, nil), specifier, attributes), ModifierFlagsNone)
					break
					fallthrough
				case SyntaxKindNamespaceImport:
					generatedSpecifier := getSpecifierForModuleSymbol(target.parent || target, context)
					// generate specifier (even though we're reusing and existing one) for ambient module reference include side effects
					var specifier Expression
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case context.bundled:
						specifier = factory.createStringLiteral(generatedSpecifier)
					default:
						specifier = (node /* as NamespaceImport */).parent.parent.moduleSpecifier
					}
					isTypeOnly := isJSDocImportTag((node /* as NamespaceImport */).parent.parent)
					addResult(factory.createImportDeclaration(nil, factory.createImportClause(isTypeOnly /*name*/, nil, factory.createNamespaceImport(factory.createIdentifier(localName))), specifier, (node /* as ImportClause */).parent.attributes), ModifierFlagsNone)
					break
					fallthrough
				case SyntaxKindNamespaceExport:
					addResult(factory.createExportDeclaration(nil, false, factory.createNamespaceExport(factory.createIdentifier(localName)), factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))), ModifierFlagsNone)
					break
				case SyntaxKindImportSpecifier:
					generatedSpecifier := getSpecifierForModuleSymbol(target.parent || target, context)
					// generate specifier (even though we're reusing and existing one) for ambient module reference include side effects
					var specifier Expression
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case context.bundled:
						specifier = factory.createStringLiteral(generatedSpecifier)
					default:
						specifier = (node /* as ImportSpecifier */).parent.parent.parent.moduleSpecifier
					}
					isTypeOnly := isJSDocImportTag((node /* as ImportSpecifier */).parent.parent.parent)
					addResult(factory.createImportDeclaration(nil, factory.createImportClause(isTypeOnly, nil, factory.createNamedImports([]ImportSpecifier{factory.createImportSpecifier(false, __COND__(localName != verbatimTargetName, factory.createIdentifier(verbatimTargetName), nil), factory.createIdentifier(localName))})), specifier, (node /* as ImportSpecifier */).parent.parent.parent.attributes), ModifierFlagsNone)
					break
					fallthrough
				case SyntaxKindExportSpecifier:
					specifier := (node.parent.parent /* as ExportDeclaration */).moduleSpecifier
					if specifier {
						propertyName := (node /* as ExportSpecifier */).propertyName
						if propertyName && moduleExportNameIsDefault(propertyName) {
							verbatimTargetName = InternalSymbolNameDefault
						}
					}
					serializeExportSpecifier(unescapeLeadingUnderscores(symbol.escapedName), __COND__(specifier, verbatimTargetName, targetName), __COND__(specifier && isStringLiteralLike(specifier), factory.createStringLiteral(specifier.text), nil))
					break
				case SyntaxKindExportAssignment:
					serializeMaybeAliasAssignment(symbol)
					break
				case SyntaxKindBinaryExpression:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindPropertyAccessExpression:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindElementAccessExpression:
					if symbol.escapedName == InternalSymbolNameDefault || symbol.escapedName == InternalSymbolNameExportEquals {
						serializeMaybeAliasAssignment(symbol)
					} else {
						serializeExportSpecifier(localName, targetName)
					}
					break
				default:
					return Debug.failBadSyntaxKind(node, "Unhandled alias declaration kind in symbol serializer!")
				}
			}
			serializeExportSpecifier := func(localName string, targetName string, specifier Expression) {
				addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports([]ExportSpecifier{factory.createExportSpecifier(false, __COND__(localName != targetName, targetName, nil), localName)}), specifier), ModifierFlagsNone)
			}
			/**
			 * Returns `true` if an export assignment or declaration was produced for the symbol
			 */
			serializeMaybeAliasAssignment := func(symbol Symbol) bool {
				if symbol.flags & SymbolFlagsPrototype {
					return false
				}
				name := unescapeLeadingUnderscores(symbol.escapedName)
				isExportEquals := name == InternalSymbolNameExportEquals
				isDefault := name == InternalSymbolNameDefault
				isExportAssignmentCompatibleSymbolName := isExportEquals || isDefault
				// synthesize export = ref
				// ref should refer to either be a locally scoped symbol which we need to emit, or
				// a reference to another namespace/module which we may need to emit an `import` statement for
				aliasDecl := symbol.declarations && getDeclarationOfAliasSymbol(symbol)
				// serialize what the alias points to, preserve the declaration's initializer
				target := aliasDecl && getTargetOfAliasDeclaration(aliasDecl /*dontRecursivelyResolve*/, true)
				// If the target resolves and resolves to a thing defined in this file, emit as an alias, otherwise emit as a const
				if target && length(target.declarations) && some(target.declarations, func(d Declaration) bool {
					return getSourceFileOfNode(d) == getSourceFileOfNode(enclosingDeclaration)
				}) {
					// In case `target` refers to a namespace member, look at the declaration and serialize the leftmost symbol in it
					// eg, `namespace A { export class B {} }; exports = A.B;`
					// Technically, this is all that's required in the case where the assignment is an entity name expression
					expr := aliasDecl && (__COND__((isExportAssignment(aliasDecl) || isBinaryExpression(aliasDecl)), getExportAssignmentExpression(aliasDecl), getPropertyAssignmentAliasLikeExpression(aliasDecl /* as ShorthandPropertyAssignment | PropertyAssignment | PropertyAccessExpression */)))
					var first *Identifier
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case expr && isEntityNameExpression(expr):
						first = getFirstNonModuleExportsIdentifier(expr)
					default:
						first = nil
					}
					referenced := first && resolveEntityName(first, SymbolFlagsAll /*ignoreErrors*/, true /*dontResolveAlias*/, true, enclosingDeclaration)
					if referenced || target {
						includePrivateSymbol(referenced || target)
					}
					// We disable the context's symbol tracker for the duration of this name serialization
					// as, by virtue of being here, the name is required to print something, and we don't want to
					// issue a visibility error on it. Only anonymous classes that an alias points at _would_ issue
					// a visibility error here (as they're not visible within any scope), but we want to hoist them
					// into the containing scope anyway, so we want to skip the visibility checks.
					prevDisableTrackSymbol := context.tracker.disableTrackSymbol
					context.tracker.disableTrackSymbol = true
					if isExportAssignmentCompatibleSymbolName {
						results.push(factory.createExportAssignment(nil, isExportEquals, symbolToExpression(target, context, SymbolFlagsAll)))
					} else {
						if first == expr && first {
							// serialize as `export {target as name}`
							serializeExportSpecifier(name, idText(first))
						} else if expr && isClassExpression(expr) {
							serializeExportSpecifier(name, getInternalSymbolName(target, symbolName(target)))
						} else {
							// serialize as `import _Ref = t.arg.et; export { _Ref as name }`
							varName := getUnusedName(name, symbol)
							addResult(factory.createImportEqualsDeclaration(nil, false, factory.createIdentifier(varName), symbolToName(target, context, SymbolFlagsAll /*expectsIdentifier*/, false)), ModifierFlagsNone)
							serializeExportSpecifier(name, varName)
						}
					}
					context.tracker.disableTrackSymbol = prevDisableTrackSymbol
					return true
				} else {
					// serialize as an anonymous property declaration
					varName := getUnusedName(name, symbol)
					// We have to use `getWidenedType` here since the object within a json file is unwidened within the file
					// (Unwidened types can only exist in expression contexts and should never be serialized)
					typeToSerialize := getWidenedType(getTypeOfSymbol(getMergedSymbol(symbol)))
					if isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, symbol) {
						// If there are no index signatures and `typeToSerialize` is an object type, emit as a namespace instead of a const
						serializeAsFunctionNamespaceMerge(typeToSerialize, symbol, varName, __COND__(isExportAssignmentCompatibleSymbolName, ModifierFlagsNone, ModifierFlagsExport))
					} else {
						var flags /* TODO(TS-TO-GO) inferred type NodeFlags.Let | NodeFlags.Const */ any
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case context.enclosingDeclaration. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindModuleDeclaration && (!(symbol.flags & SymbolFlagsAccessor) || symbol.flags&SymbolFlagsSetAccessor):
							flags = NodeFlagsLet
						default:
							flags = NodeFlagsConst
						}
						statement := factory.createVariableStatement(nil, factory.createVariableDeclarationList([]VariableDeclaration{factory.createVariableDeclaration(varName /*exclamationToken*/, nil, serializeTypeForDeclaration(context /*declaration*/, nil, typeToSerialize, symbol))}, flags))
						// Inlined JSON types exported with [module.]exports= will already emit an export=, so should use `declare`.
						// Otherwise, the type itself should be exported.
						addResult(statement, __COND__(target && target.flags&SymbolFlagsProperty && target.escapedName == InternalSymbolNameExportEquals, ModifierFlagsAmbient, __COND__(name == varName, ModifierFlagsExport, ModifierFlagsNone)))
					}
					if isExportAssignmentCompatibleSymbolName {
						results.push(factory.createExportAssignment(nil, isExportEquals, factory.createIdentifier(varName)))
						return true
					} else if name != varName {
						serializeExportSpecifier(name, varName)
						return true
					}
					return false
				}
			}
			isTypeRepresentableAsFunctionNamespaceMerge := func(typeToSerialize Type, hostSymbol Symbol) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
				// Only object types which are not constructable, or indexable, whose members all come from the
				// context source file, and whose property names are all valid identifiers and not late-bound, _and_
				// whose input is not type annotated (if the input symbol has an annotation we can reuse, we should prefer it)
				ctxSrc := getSourceFileOfNode(context.enclosingDeclaration)
				return getObjectFlags(typeToSerialize)&(ObjectFlagsAnonymous|ObjectFlagsMapped) && !some(typeToSerialize.symbol. /* TODO(TS-TO-GO): was ? */ declarations, isTypeNode) && !length(getIndexInfosOfType(typeToSerialize)) && !isClassInstanceSide(typeToSerialize) && !!(length(filter(getPropertiesOfType(typeToSerialize), isNamespaceMember)) || length(getSignaturesOfType(typeToSerialize, SignatureKindCall))) && !length(getSignaturesOfType(typeToSerialize, SignatureKindConstruct)) && !getDeclarationWithTypeAnnotation(hostSymbol, enclosingDeclaration) && !(typeToSerialize.symbol && some(typeToSerialize.symbol.declarations, func(d Declaration) bool {
					return getSourceFileOfNode(d) != ctxSrc
				})) && !some(getPropertiesOfType(typeToSerialize), func(p Symbol) bool {
					return isLateBoundName(p.escapedName)
				}) && !some(getPropertiesOfType(typeToSerialize), func(p Symbol) bool {
					return some(p.declarations, func(d Declaration) bool {
						return getSourceFileOfNode(d) != ctxSrc
					})
				}) && every(getPropertiesOfType(typeToSerialize), func(p Symbol) bool {
					if !isIdentifierText(symbolName(p), languageVersion) {
						return false
					}
					if !(p.flags & SymbolFlagsAccessor) {
						return true
					}
					return getNonMissingTypeOfSymbol(p) == getWriteTypeOfSymbol(p)
				})
			}
			/* TODO(TS-TO-GO): function makeSerializePropertySymbol<T extends Node>( createProperty: ( modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined, ) => T, methodKind: SignatureDeclaration["kind"], useAccessors: true, ): (p: Symbol, isStatic: boolean, baseType: Type | undefined) => T | AccessorDeclaration | (T | AccessorDeclaration)[]; */
			/* TODO(TS-TO-GO): function makeSerializePropertySymbol<T extends Node>( createProperty: ( modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined, ) => T, methodKind: SignatureDeclaration["kind"], useAccessors: false, ): (p: Symbol, isStatic: boolean, baseType: Type | undefined) => T | T[]; */
			makeSerializePropertySymbol := func(createProperty func(modifiers *[]Modifier, name /* TODO(TS-TO-GO) TypeNode UnionType: string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer Expression) T, methodKind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: SignatureDeclaration["kind"] */ any, useAccessors bool) func(p Symbol, isStatic bool, baseType Type) /* TODO(TS-TO-GO) TypeNode UnionType: T | AccessorDeclaration | (T | AccessorDeclaration)[] */ any {
				return func /* serializePropertySymbol */ (p Symbol, isStatic bool, baseType Type) /* TODO(TS-TO-GO) TypeNode UnionType: T | AccessorDeclaration | (T | AccessorDeclaration)[] */ any {
					modifierFlags := getDeclarationModifierFlagsFromSymbol(p)
					isPrivate := !!(modifierFlags & ModifierFlagsPrivate)
					if isStatic && (p.flags & (SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsAlias)) {
						// Only value-only-meaning symbols can be correctly encoded as class statics, type/namespace/alias meaning symbols
						// need to be merged namespace members
						return []never{}
					}
					if p.flags&SymbolFlagsPrototype || p.escapedName == "constructor" || (baseType && getPropertyOfType(baseType, p.escapedName) && isReadonlySymbol(getPropertyOfType(baseType, p.escapedName)) == isReadonlySymbol(p) && (p.flags&SymbolFlagsOptional) == (getPropertyOfType(baseType, p.escapedName).flags&SymbolFlagsOptional) && isTypeIdenticalTo(getTypeOfSymbol(p), getTypeOfPropertyOfType(baseType, p.escapedName))) {
						return []never{}
					}
					flag := (modifierFlags & ~ModifierFlagsAsync) | (__COND__(isStatic, ModifierFlagsStatic, 0))
					name := getPropertyNameNodeForSymbol(p, context)
					firstPropertyLikeDecl := p.declarations. /* TODO(TS-TO-GO): was ? */ find(or(isPropertyDeclaration, isAccessor, isVariableDeclaration, isPropertySignature, isBinaryExpression, isPropertyAccessExpression))
					if p.flags&SymbolFlagsAccessor && useAccessors {
						var result []AccessorDeclaration = []never{}
						if p.flags & SymbolFlagsSetAccessor {
							setter := p.declarations && forEach(p.declarations, func(d Declaration) * /* TODO(TS-TO-GO) inferred type SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | GetAccessorDeclaration */ any {
								if d.kind == SyntaxKindSetAccessor {
									return d /* as SetAccessorDeclaration */
								}
								if isCallExpression(d) && isBindableObjectDefinePropertyCall(d) {
									return forEach(d.arguments[2].properties, func(propDecl /* TODO(TS-TO-GO) inferred type SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | GetAccessorDeclaration */ any) * /* TODO(TS-TO-GO) inferred type SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | GetAccessorDeclaration */ any {
										id := getNameOfDeclaration(propDecl)
										if !!id && isIdentifier(id) && idText(id) == "set" {
											return propDecl
										}
									})
								}
							})
							Debug.assert(!!setter)
							var paramSymbol Symbol
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case isFunctionLikeDeclaration(setter):
								paramSymbol = getSignatureFromDeclaration(setter).parameters[0]
							default:
								paramSymbol = nil
							}
							result.push(setTextRange(context, factory.createSetAccessorDeclaration(factory.createModifiersFromModifierFlags(flag), name, []ParameterDeclaration{factory.createParameterDeclaration(nil, nil, __COND__(paramSymbol, parameterToParameterDeclarationName(paramSymbol, getEffectiveParameterDeclaration(paramSymbol), context), "value"), nil, __COND__(isPrivate, nil, serializeTypeForDeclaration(context /*declaration*/, nil, getWriteTypeOfSymbol(p), p)))}, nil), p.declarations. /* TODO(TS-TO-GO): was ? */ find(isSetAccessor) || firstPropertyLikeDecl))
						}
						if p.flags & SymbolFlagsGetAccessor {
							isPrivate := modifierFlags & ModifierFlagsPrivate
							result.push(setTextRange(context, factory.createGetAccessorDeclaration(factory.createModifiersFromModifierFlags(flag), name, []never{}, __COND__(isPrivate, nil, serializeTypeForDeclaration(context /*declaration*/, nil, getTypeOfSymbol(p), p)), nil), p.declarations. /* TODO(TS-TO-GO): was ? */ find(isGetAccessor) || firstPropertyLikeDecl))
						}
						return result
					} else if p.flags & (SymbolFlagsProperty | SymbolFlagsVariable | SymbolFlagsAccessor) {
						return setTextRange(context, createProperty(factory.createModifiersFromModifierFlags((__COND__(isReadonlySymbol(p), ModifierFlagsReadonly, 0))|flag), name, __COND__(p.flags&SymbolFlagsOptional, factory.createToken(SyntaxKindQuestionToken), nil), __COND__(isPrivate, nil, serializeTypeForDeclaration(context /*declaration*/, nil, getWriteTypeOfSymbol(p), p)), nil), p.declarations. /* TODO(TS-TO-GO): was ? */ find(or(isPropertyDeclaration, isVariableDeclaration)) || firstPropertyLikeDecl)
					}
					if p.flags & (SymbolFlagsMethod | SymbolFlagsFunction) {
						type_ := getTypeOfSymbol(p)
						signatures := getSignaturesOfType(type_, SignatureKindCall)
						if flag & ModifierFlagsPrivate {
							return setTextRange(context, createProperty(factory.createModifiersFromModifierFlags((__COND__(isReadonlySymbol(p), ModifierFlagsReadonly, 0))|flag), name, __COND__(p.flags&SymbolFlagsOptional, factory.createToken(SyntaxKindQuestionToken), nil), nil, nil), p.declarations. /* TODO(TS-TO-GO): was ? */ find(isFunctionLikeDeclaration) || signatures[0] && signatures[0].declaration || p.declarations && p.declarations[0])
						}
						results := []never{}
						for _, sig := range signatures {
							// Each overload becomes a separate method declaration, in order
							decl := signatureToSignatureDeclarationHelper(sig, methodKind, context, map[any]any{ /* TODO(TS-TO-GO): was object literal */
								"name":          name,
								"questionToken": __COND__(p.flags&SymbolFlagsOptional, factory.createToken(SyntaxKindQuestionToken), nil),
								"modifiers":     __COND__(flag, factory.createModifiersFromModifierFlags(flag), nil),
							})
							var location * /* TODO(TS-TO-GO) inferred type SignatureDeclaration | JSDocSignature | PrototypePropertyAssignment */ any
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case sig.declaration && isPrototypePropertyAssignment(sig.declaration.parent):
								location = sig.declaration.parent
							default:
								location = sig.declaration
							}
							results.push(setTextRange(context, decl, location))
						}
						return results /* as unknown */ /* as T[] */
					}
					// The `Constructor`'s symbol isn't in the class's properties lists, obviously, since it's a signature on the static
					return Debug.fail(__TEMPLATE__("Unhandled class member kind! ", (p /* as any */).__debugFlags || p.flags))
				}
			}
			serializePropertySymbolForInterface := func(p Symbol, baseType Type) [] /* TODO(TS-TO-GO) inferred type TypeElement | TypeElement */ any {
				return serializePropertySymbolForInterfaceWorker(p /*isStatic*/, false, baseType)
			}
			serializeSignatures := func(kind SignatureKind, input Type, baseType Type, outputKind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: SignatureDeclaration["kind"] */ any) [] /* TODO(TS-TO-GO) inferred type (SetAccessorDeclaration | MethodDeclaration | GetAccessorDeclaration | CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | FunctionDeclaration | ConstructorDeclaration | FunctionExpression | ArrowFunction) */ any {
				signatures := getSignaturesOfType(input, kind)
				if kind == SignatureKindConstruct {
					if !baseType && every(signatures, func(s Signature) bool {
						return length(s.parameters) == 0
					}) {
						return []never{}
						// No base type, every constructor is empty - elide the extraneous `constructor()`
					}
					if baseType {
						// If there is a base type, if every signature in the class is identical to a signature in the baseType, elide all the declarations
						baseSigs := getSignaturesOfType(baseType, SignatureKindConstruct)
						if !length(baseSigs) && every(signatures, func(s Signature) bool {
							return length(s.parameters) == 0
						}) {
							return []never{}
							// Base had no explicit signatures, if all our signatures are also implicit, return an empty list
						}
						if baseSigs.length == signatures.length {
							failed := false
							for i := 0; i < baseSigs.length; i++ {
								if !compareSignaturesIdentical(signatures[i], baseSigs[i] /*partialMatch*/, false /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, true, compareTypesIdentical) {
									failed = true
									break
								}
							}
							if !failed {
								return []never{}
								// Every signature was identical - elide constructor list as it is inherited
							}
						}
					}
					var privateProtected ModifierFlags = 0
					for _, s := range signatures {
						if s.declaration {
							privateProtected |= getSelectedEffectiveModifierFlags(s.declaration, ModifierFlagsPrivate|ModifierFlagsProtected)
						}
					}
					if privateProtected {
						return []ConstructorDeclaration{setTextRange(context, factory.createConstructorDeclaration(factory.createModifiersFromModifierFlags(privateProtected), []never{}, nil), signatures[0].declaration)}
					}
				}
				results := []never{}
				for _, sig := range signatures {
					// Each overload becomes a separate constructor declaration, in order
					decl := signatureToSignatureDeclarationHelper(sig, outputKind, context)
					results.push(setTextRange(context, decl, sig.declaration))
				}
				return results
			}
			serializeIndexSignatures := func(input Type, baseType Type) []IndexSignatureDeclaration {
				var results []IndexSignatureDeclaration = []never{}
				for _, info := range getIndexInfosOfType(input) {
					if baseType {
						baseInfo := getIndexInfoOfType(baseType, info.keyType)
						if baseInfo {
							if isTypeIdenticalTo(info.type_, baseInfo.type_) {
								continue
								// elide identical index signatures
							}
						}
					}
					results.push(indexInfoToIndexSignatureDeclarationHelper(info, context /*typeNode*/, nil))
				}
				return results
			}
			serializeBaseType := func(t Type, staticType Type, rootName string) ExpressionWithTypeArguments {
				ref := trySerializeAsTypeReference(t, SymbolFlagsValue)
				if ref {
					return ref
				}
				tempName := getUnusedName(__TEMPLATE__(rootName, "_base"))
				statement := factory.createVariableStatement(nil, factory.createVariableDeclarationList([]VariableDeclaration{factory.createVariableDeclaration(tempName /*exclamationToken*/, nil, typeToTypeNodeHelper(staticType, context))}, NodeFlagsConst))
				addResult(statement, ModifierFlagsNone)
				return factory.createExpressionWithTypeArguments(factory.createIdentifier(tempName) /*typeArguments*/, nil)
			}
			trySerializeAsTypeReference := func(t Type, flags SymbolFlags) *ExpressionWithTypeArguments {
				var typeArgs *[]TypeNode
				var reference Expression
				// We don't use `isValueSymbolAccessible` below. since that considers alternative containers (like modules)
				// which we can't write out in a syntactically valid way as an expression
				if (t /* as TypeReference */).target && isSymbolAccessibleByFlags((t /* as TypeReference */).target.symbol, enclosingDeclaration, flags) {
					typeArgs = map_(getTypeArguments(t /* as TypeReference */), func(t Type) TypeNode {
						return typeToTypeNodeHelper(t, context)
					})
					reference = symbolToExpression((t /* as TypeReference */).target.symbol, context, SymbolFlagsType)
				} else if t.symbol && isSymbolAccessibleByFlags(t.symbol, enclosingDeclaration, flags) {
					reference = symbolToExpression(t.symbol, context, SymbolFlagsType)
				}
				if reference {
					return factory.createExpressionWithTypeArguments(reference, typeArgs)
				}
			}
			serializeImplementedType := func(t Type) *ExpressionWithTypeArguments {
				ref := trySerializeAsTypeReference(t, SymbolFlagsType)
				if ref {
					return ref
				}
				if t.symbol {
					return factory.createExpressionWithTypeArguments(symbolToExpression(t.symbol, context, SymbolFlagsType) /*typeArguments*/, nil)
				}
			}
			getUnusedName := func(input string, symbol Symbol) string {
				var id *number
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case symbol:
					id = getSymbolId(symbol)
				default:
					id = nil
				}
				if id {
					if context.remappedSymbolNames.has(id) {
						return context.remappedSymbolNames.get(id)
					}
				}
				if symbol {
					input = getNameCandidateWorker(symbol, input)
				}
				i := 0
				original := input
				for context.usedSymbolNames. /* TODO(TS-TO-GO): was ? */ has(input) {
					i++
					input = __TEMPLATE__(original, "_", i)
				}
				context.usedSymbolNames. /* TODO(TS-TO-GO): was ? */ add(input)
				if id {
					context.remappedSymbolNames.set(id, input)
				}
				return input
			}
			getNameCandidateWorker := func(symbol Symbol, localName string) string {
				if localName == InternalSymbolNameDefault || localName == InternalSymbolNameClass || localName == InternalSymbolNameFunction {
					restoreFlags := saveRestoreFlags(context)
					context.flags |= NodeBuilderFlagsInInitialEntityName
					nameCandidate := getNameOfSymbolAsWritten(symbol, context)
					restoreFlags()
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case nameCandidate.length > 0 && isSingleOrDoubleQuote(nameCandidate.charCodeAt(0)):
						localName = stripQuotes(nameCandidate)
					default:
						localName = nameCandidate
					}
				}
				if localName == InternalSymbolNameDefault {
					localName = "_default"
				} else if localName == InternalSymbolNameExportEquals {
					localName = "_exports"
				}
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isIdentifierText(localName, languageVersion) && !isStringANonContextualKeyword(localName):
					localName = localName
				default:
					localName = "_" + localName.replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /[^a-z0-9]/gi */ TODO, "_")
				}
				return localName
			}
			getInternalSymbolName := func(symbol Symbol, localName string) string {
				id := getSymbolId(symbol)
				if context.remappedSymbolNames.has(id) {
					return context.remappedSymbolNames.get(id)
				}
				localName = getNameCandidateWorker(symbol, localName)
				// The result of this is going to be used as the symbol's name - lock it in, so `getUnusedName` will also pick it up
				context.remappedSymbolNames.set(id, localName)
				return localName
			}
		}
	}
	typePredicateToString := func(typePredicate TypePredicate, enclosingDeclaration Node, flags TypeFormatFlags /*  = TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter) string {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case writer:
			return typePredicateToStringWorker(writer).getText()
		default:
			return usingSingleLineStringWriter(typePredicateToStringWorker)
		}
		typePredicateToStringWorker := func(writer EmitTextWriter) EmitTextWriter {
			nodeBuilderFlags := toNodeBuilderFlags(flags) | NodeBuilderFlagsIgnoreErrors | NodeBuilderFlagsWriteTypeParametersInQualifiedName
			predicate := nodeBuilder.typePredicateToTypePredicateNode(typePredicate, enclosingDeclaration, nodeBuilderFlags)
			// TODO: GH#18217
			printer := createPrinterWithRemoveComments()
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			printer.writeNode(EmitHintUnspecified, predicate /*sourceFile*/, sourceFile, writer)
			return writer
		}
	}
	formatUnionTypes := func(types []Type) []Type {
		var result []Type = []never{}
		flags := 0 /* as TypeFlags */
		for i := 0; i < types.length; i++ {
			t := types[i]
			flags |= t.flags
			if !(t.flags & TypeFlagsNullable) {
				if t.flags & (TypeFlagsBooleanLiteral | TypeFlagsEnumLike) {
					var baseType Type
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case t.flags & TypeFlagsBooleanLiteral:
						baseType = booleanType
					default:
						baseType = getBaseTypeOfEnumLikeType(t /* as LiteralType */)
					}
					if baseType.flags & TypeFlagsUnion {
						count := (baseType /* as UnionType */).types.length
						if i+count <= types.length && getRegularTypeOfLiteralType(types[i+count-1]) == getRegularTypeOfLiteralType((baseType /* as UnionType */).types[count-1]) {
							result.push(baseType)
							i += count - 1
							continue
						}
					}
				}
				result.push(t)
			}
		}
		if flags & TypeFlagsNull {
			result.push(nullType)
		}
		if flags & TypeFlagsUndefined {
			result.push(undefinedType)
		}
		return result || types
	}
	visibilityToString := func(flags ModifierFlags) string {
		if flags == ModifierFlagsPrivate {
			return "private"
		}
		if flags == ModifierFlagsProtected {
			return "protected"
		}
		return "public"
	}
	getTypeAliasForTypeLiteral := func(type_ Type) Symbol {
		if type_.symbol && type_.symbol.flags&SymbolFlagsTypeLiteral && type_.symbol.declarations {
			node := walkUpParenthesizedTypes(type_.symbol.declarations[0].parent)
			if isTypeAliasDeclaration(node) {
				return getSymbolOfDeclaration(node)
			}
		}
		return nil
	}
	isTopLevelInExternalModuleAugmentation := func(node Node) bool {
		return node && node.parent && node.parent.kind == SyntaxKindModuleBlock && isExternalModuleAugmentation(node.parent.parent)
	}
	isDefaultBindingContext := func(location Node) bool {
		return location.kind == SyntaxKindSourceFile || isAmbientModule(location)
	}
	getNameOfSymbolFromNameType := func(symbol Symbol, context NodeBuilderContext) *string {
		nameType := getSymbolLinks(symbol).nameType
		if nameType {
			if nameType.flags & TypeFlagsStringOrNumberLiteral {
				name := "" + (nameType /* as StringLiteralType | NumberLiteralType */).value
				if !isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && !isNumericLiteralName(name) {
					return __TEMPLATE__("\"", escapeString(name, CharacterCodesdoubleQuote), "\"")
				}
				if isNumericLiteralName(name) && startsWith(name, "-") {
					return __TEMPLATE__("[", name, "]")
				}
				return name
			}
			if nameType.flags & TypeFlagsUniqueESSymbol {
				return __TEMPLATE__("[", getNameOfSymbolAsWritten((nameType /* as UniqueESSymbolType */).symbol, context), "]")
			}
		}
	}
	/**
	 * Gets a human-readable name for a symbol.
	 * Should *not* be used for the right-hand side of a `.` -- use `symbolName(symbol)` for that instead.
	 *
	 * Unlike `symbolName(symbol)`, this will include quotes if the name is from a string literal.
	 * It will also use a representation of a number as written instead of a decimal form, e.g. `0o11` instead of `9`.
	 */
	getNameOfSymbolAsWritten := func(symbol Symbol, context NodeBuilderContext) string {
		if context. /* TODO(TS-TO-GO): was ? */ remappedSymbolReferences. /* TODO(TS-TO-GO): was ? */ has(getSymbolId(symbol)) {
			symbol = context.remappedSymbolReferences.get(getSymbolId(symbol))
		}
		if context && symbol.escapedName == InternalSymbolNameDefault && !(context.flags & NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope) && (!(context.flags & NodeBuilderFlagsInInitialEntityName) || !symbol.declarations || (context.enclosingDeclaration && findAncestor(symbol.declarations[0], isDefaultBindingContext) != findAncestor(context.enclosingDeclaration, isDefaultBindingContext))) {
			return "default"
		}
		if symbol.declarations && symbol.declarations.length {
			declaration := firstDefined(symbol.declarations, func(d Declaration) Declaration {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case getNameOfDeclaration(d):
					return d
				default:
					return nil
				}
			})
			// Try using a declaration with a name, first
			name := declaration && getNameOfDeclaration(declaration)
			if declaration && name {
				if isCallExpression(declaration) && isBindableObjectDefinePropertyCall(declaration) {
					return symbolName(symbol)
				}
				if isComputedPropertyName(name) && !(getCheckFlags(symbol) & CheckFlagsLate) {
					nameType := getSymbolLinks(symbol).nameType
					if nameType && nameType.flags&TypeFlagsStringOrNumberLiteral {
						// Computed property name isn't late bound, but has a well-known name type - use name type to generate a symbol name
						result := getNameOfSymbolFromNameType(symbol, context)
						if result != nil {
							return result
						}
					}
				}
				return declarationNameToString(name)
			}
			if !declaration {
				declaration = symbol.declarations[0]
				// Declaration may be nameless, but we'll try anyway
			}
			if declaration.parent && declaration.parent.kind == SyntaxKindVariableDeclaration {
				return declarationNameToString((declaration.parent /* as VariableDeclaration */).name)
			}
			switch declaration.kind {
			case SyntaxKindClassExpression:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindFunctionExpression:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindArrowFunction:
				if context && !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) {
					context.encounteredError = true
				}
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case declaration.kind == SyntaxKindClassExpression:
					return "(Anonymous class)"
				default:
					return "(Anonymous function)"
				}
			}
		}
		name := getNameOfSymbolFromNameType(symbol, context)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case name != nil:
			return name
		default:
			return symbolName(symbol)
		}
	}
	isDeclarationVisible := func(node Node) bool {
		if node {
			links := getNodeLinks(node)
			if links.isVisible == nil {
				links.isVisible = !!determineIfDeclarationIsVisible()
			}
			return links.isVisible
		}
		return false
		determineIfDeclarationIsVisible := func() bool {
			switch node.kind {
			case SyntaxKindJSDocCallbackTag:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJSDocTypedefTag:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJSDocEnumTag:
				return !!(node.parent && node.parent.parent && node.parent.parent.parent && isSourceFile(node.parent.parent.parent))
			case SyntaxKindBindingElement:
				return isDeclarationVisible(node.parent.parent)
			case SyntaxKindVariableDeclaration:
				if isBindingPattern((node /* as VariableDeclaration */).name) && !((node /* as VariableDeclaration */).name /* as BindingPattern */).elements.length {
					// If the binding pattern is empty, this variable declaration is not visible
					return false
				}
				fallthrough
			case SyntaxKindModuleDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindClassDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindTypeAliasDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindFunctionDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindEnumDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindImportEqualsDeclaration:
				if isExternalModuleAugmentation(node) {
					return true
				}
				parent := getDeclarationContainer(node)
				if !(getCombinedModifierFlagsCached(node /* as Declaration */) & ModifierFlagsExport) && !(node.kind != SyntaxKindImportEqualsDeclaration && parent.kind != SyntaxKindSourceFile && parent.flags&NodeFlagsAmbient) {
					return isGlobalSourceFile(parent)
				}
				return isDeclarationVisible(parent)
			case SyntaxKindPropertyDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindPropertySignature:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindSetAccessor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindMethodSignature:
				if hasEffectiveModifier(node, ModifierFlagsPrivate|ModifierFlagsProtected) {
					// Private/protected properties/methods are not visible
					return false
				}
				fallthrough
			case SyntaxKindConstructor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindConstructSignature:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindCallSignature:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindIndexSignature:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindParameter:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindModuleBlock:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindFunctionType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindConstructorType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindTypeLiteral:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindTypeReference:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindArrayType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindTupleType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindUnionType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindIntersectionType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindParenthesizedType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindNamedTupleMember:
				return isDeclarationVisible(node.parent)
			case SyntaxKindImportClause:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindNamespaceImport:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindImportSpecifier:
				return false
			case SyntaxKindTypeParameter:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindSourceFile:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindNamespaceExportDeclaration:
				return true
			case SyntaxKindExportAssignment:
				return false
			default:
				return false
			}
		}
	}
	collectLinkedAliases := func(node ModuleExportName, setVisibility bool) *[]Node {
		var exportSymbol Symbol
		if node.kind != SyntaxKindStringLiteral && node.parent && node.parent.kind == SyntaxKindExportAssignment {
			exportSymbol = resolveName(node, node, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias /*nameNotFoundMessage*/, nil /*isUse*/, false)
		} else if node.parent.kind == SyntaxKindExportSpecifier {
			exportSymbol = getTargetOfExportSpecifier(node.parent /* as ExportSpecifier */, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias)
		}
		var result *[]Node
		var visited *Set[number]
		if exportSymbol {
			visited = NewSet()
			visited.add(getSymbolId(exportSymbol))
			buildVisibleNodeList(exportSymbol.declarations)
		}
		return result
		buildVisibleNodeList := func(declarations *[]Declaration) {
			forEach(declarations, func(declaration Declaration) {
				resultNode := getAnyImportSyntax(declaration) || declaration
				if setVisibility {
					getNodeLinks(declaration).isVisible = true
				} else {
					result = result || []never{}
					pushIfUnique(result, resultNode)
				}
				if isInternalModuleImportEqualsDeclaration(declaration) {
					// Add the referenced top container visible
					internalModuleReference := declaration.moduleReference /* as Identifier | QualifiedName */
					firstIdentifier := getFirstIdentifier(internalModuleReference)
					importSymbol := resolveName(declaration, firstIdentifier.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace /*nameNotFoundMessage*/, nil /*isUse*/, false)
					if importSymbol && visited {
						if tryAddToSet(visited, getSymbolId(importSymbol)) {
							buildVisibleNodeList(importSymbol.declarations)
						}
					}
				}
			})
		}
	}
	/**
	 * Push an entry on the type resolution stack. If an entry with the given target and the given property name
	 * is already on the stack, and no entries in between already have a type, then a circularity has occurred.
	 * In this case, the result values of the existing entry and all entries pushed after it are changed to false,
	 * and the value false is returned. Otherwise, the new entry is just pushed onto the stack, and true is returned.
	 * In order to see if the same query has already been done before, the target object and the propertyName both
	 * must match the one passed in.
	 *
	 * @param target The symbol, type, or signature whose type is being queried
	 * @param propertyName The property name that should be used to query the target for its type
	 */
	pushTypeResolution := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
		resolutionCycleStartIndex := findResolutionCycleStartIndex(target, propertyName)
		if resolutionCycleStartIndex >= 0 {
			// A cycle was found
			TODO_IDENTIFIER := resolutionTargets
			for i := resolutionCycleStartIndex; i < length; i++ {
				resolutionResults[i] = false
			}
			return false
		}
		resolutionTargets.push(target)
		resolutionResults.push(true)
		resolutionPropertyNames.push(propertyName)
		return true
	}
	findResolutionCycleStartIndex := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) number {
		for i := resolutionTargets.length - 1; i >= resolutionStart; i-- {
			if resolutionTargetHasProperty(resolutionTargets[i], resolutionPropertyNames[i]) {
				return -1
			}
			if resolutionTargets[i] == target && resolutionPropertyNames[i] == propertyName {
				return i
			}
		}
		return -1
	}
	resolutionTargetHasProperty := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
		switch propertyName {
		case TypeSystemPropertyNameType:
			return !!getSymbolLinks(target /* as Symbol */).type_
		case TypeSystemPropertyNameDeclaredType:
			return !!getSymbolLinks(target /* as Symbol */).declaredType
		case TypeSystemPropertyNameResolvedBaseConstructorType:
			return !!(target /* as InterfaceType */).resolvedBaseConstructorType
		case TypeSystemPropertyNameResolvedReturnType:
			return !!(target /* as Signature */).resolvedReturnType
		case TypeSystemPropertyNameImmediateBaseConstraint:
			return !!(target /* as Type */).immediateBaseConstraint
		case TypeSystemPropertyNameResolvedTypeArguments:
			return !!(target /* as TypeReference */).resolvedTypeArguments
		case TypeSystemPropertyNameResolvedBaseTypes:
			return !!(target /* as InterfaceType */).baseTypesResolved
		case TypeSystemPropertyNameWriteType:
			return !!getSymbolLinks(target /* as Symbol */).writeType
		case TypeSystemPropertyNameParameterInitializerContainsUndefined:
			return getNodeLinks(target /* as ParameterDeclaration */).parameterInitializerContainsUndefined != nil
		}
		return Debug.assertNever(propertyName)
	}
	/**
	 * Pop an entry from the type resolution stack and return its associated result value. The result value will
	 * be true if no circularities were detected, or false if a circularity was found.
	 */
	popTypeResolution := func() bool {
		resolutionTargets.pop()
		resolutionPropertyNames.pop()
		return resolutionResults.pop()
	}
	getDeclarationContainer := func(node Node) Node {
		return findAncestor(getRootDeclaration(node), func(node Node) bool {
			switch node.kind {
			case SyntaxKindVariableDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindVariableDeclarationList:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindImportSpecifier:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindNamedImports:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindNamespaceImport:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindImportClause:
				return false
			default:
				return true
			}
		}).parent
	}
	getTypeOfPrototypeProperty := func(prototype Symbol) Type {
		// TypeScript 1.0 spec (April 2014): 8.4
		// Every class automatically contains a static property member named 'prototype',
		// the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
		// It is an error to explicitly declare a static property member with the name 'prototype'.
		classType := getDeclaredTypeOfSymbol(getParentOfSymbol(prototype)) /* as InterfaceType */
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case classType.typeParameters:
			return createTypeReference(classType /* as GenericType */, map_(classType.typeParameters, func(_ TypeParameter) IntrinsicType {
				return anyType
			}))
		default:
			return classType
		}
	}
	// Return the type of the given property in the given type, or undefined if no such property exists
	getTypeOfPropertyOfType := func(type_ Type, name __String) Type {
		prop := getPropertyOfType(type_, name)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case prop:
			return getTypeOfSymbol(prop)
		default:
			return nil
		}
	}
	/**
	 * Return the type of the matching property or index signature in the given type, or undefined
	 * if no matching property or index signature exists. Add optionality to index signature types.
	 */
	getTypeOfPropertyOrIndexSignatureOfType := func(type_ Type, name __String) Type {
		var propType TODO
		return getTypeOfPropertyOfType(type_, name) || ( /* TODO(TS-TO-GO) Node BinaryExpression: propType = getApplicableIndexInfoForName(type, name)?.type */ TODO) && addOptionality(propType /*isProperty*/, true /*isOptional*/, true)
	}
	isTypeAny := func(type_ Type) *bool {
		return type_ && (type_.flags&TypeFlagsAny) != 0
	}
	isErrorType := func(type_ Type) bool {
		// The only 'any' types that have alias symbols are those manufactured by getTypeFromTypeAliasReference for
		// a reference to an unresolved symbol. We want those to behave like the errorType.
		return type_ == errorType || !!(type_.flags&TypeFlagsAny && type_.aliasSymbol)
	}
	// Return the type of a binding element parent. We check SymbolLinks first to see if a type has been
	// assigned by contextual typing.
	getTypeForBindingElementParent := func(node BindingElementGrandparent, checkMode CheckMode) Type {
		if checkMode != CheckModeNormal {
			return getTypeForVariableLikeDeclaration(node /*includeOptionality*/, false, checkMode)
		}
		symbol := getSymbolOfDeclaration(node)
		return symbol && getSymbolLinks(symbol).type_ || getTypeForVariableLikeDeclaration(node /*includeOptionality*/, false, checkMode)
	}
	getRestType := func(source Type, properties []PropertyName, symbol Symbol) Type {
		source = filterType(source, func(t Type) bool {
			return !(t.flags & TypeFlagsNullable)
		})
		if source.flags & TypeFlagsNever {
			return emptyObjectType
		}
		if source.flags & TypeFlagsUnion {
			return mapType(source, func(t Type) Type {
				return getRestType(t, properties, symbol)
			})
		}
		omitKeyType := getUnionType(map_(properties, getLiteralTypeFromPropertyName))
		var spreadableProperties []Symbol = []never{}
		var unspreadableToRestKeys []Type = []never{}
		for _, prop := range getPropertiesOfType(source) {
			literalTypeFromProperty := getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique)
			if !isTypeAssignableTo(literalTypeFromProperty, omitKeyType) && !(getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlagsPrivate | ModifierFlagsProtected)) && isSpreadableProperty(prop) {
				spreadableProperties.push(prop)
			} else {
				unspreadableToRestKeys.push(literalTypeFromProperty)
			}
		}
		if isGenericObjectType(source) || isGenericIndexType(omitKeyType) {
			if unspreadableToRestKeys.length {
				// If the type we're spreading from has properties that cannot
				// be spread into the rest type (e.g. getters, methods), ensure
				// they are explicitly omitted, as they would in the non-generic case.
				omitKeyType = getUnionType([]Type{omitKeyType /* TODO(TS-TO-GO) Node SpreadElement: ...unspreadableToRestKeys */})
			}
			if omitKeyType.flags & TypeFlagsNever {
				return source
			}
			omitTypeAlias := getGlobalOmitSymbol()
			if !omitTypeAlias {
				return errorType
			}
			return getTypeAliasInstantiation(omitTypeAlias, []Type{source, omitKeyType})
		}
		members := createSymbolTable()
		for _, prop := range spreadableProperties {
			members.set(prop.escapedName, getSpreadSymbol(prop /*readonly*/, false))
		}
		result := createAnonymousType(symbol, members, emptyArray, emptyArray, getIndexInfosOfType(source))
		result.objectFlags |= ObjectFlagsObjectRestType
		return result
	}
	isGenericTypeWithUndefinedConstraint := func(type_ Type) bool {
		return !!(type_.flags & TypeFlagsInstantiable) && maybeTypeOfKind(getBaseConstraintOfType(type_) || unknownType, TypeFlagsUndefined)
	}
	getNonUndefinedType := func(type_ Type) Type {
		var typeOrConstraint Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case someType(type_, isGenericTypeWithUndefinedConstraint):
			typeOrConstraint = mapType(type_, func(t Type) Type {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case t.flags & TypeFlagsInstantiable:
					return getBaseConstraintOrType(t)
				default:
					return t
				}
			})
		default:
			typeOrConstraint = type_
		}
		return getTypeWithFacts(typeOrConstraint, TypeFactsNEUndefined)
	}
	// Determine the control flow type associated with a destructuring declaration or assignment. The following
	// forms of destructuring are possible:
	//   let { x } = obj;  // BindingElement
	//   let [ x ] = obj;  // BindingElement
	//   { x } = obj;      // ShorthandPropertyAssignment
	//   { x: v } = obj;   // PropertyAssignment
	//   [ x ] = obj;      // Expression
	// We construct a synthetic element access expression corresponding to 'obj.x' such that the control
	// flow analyzer doesn't have to handle all the different syntactic forms.
	getFlowTypeOfDestructuring := func(node /* TODO(TS-TO-GO) TypeNode UnionType: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any, declaredType Type) Type {
		reference := getSyntheticElementAccess(node)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case reference:
			return getFlowTypeOfReference(reference, declaredType)
		default:
			return declaredType
		}
	}
	getSyntheticElementAccess := func(node /* TODO(TS-TO-GO) TypeNode UnionType: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) *ElementAccessExpression {
		parentAccess := getParentElementAccess(node)
		if parentAccess && canHaveFlowNode(parentAccess) && parentAccess.flowNode {
			propName := getDestructuringPropertyName(node)
			if propName {
				literal := setTextRangeWorker(parseNodeFactory.createStringLiteral(propName), node)
				var lhsExpr /* TODO(TS-TO-GO) inferred type Identifier | PropertyAccessExpression | ElementAccessExpression | FunctionExpression | ParenthesizedExpression | MetaProperty | ThisExpression | SuperExpression */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isLeftHandSideExpression(parentAccess):
					lhsExpr = parentAccess
				default:
					lhsExpr = parseNodeFactory.createParenthesizedExpression(parentAccess)
				}
				result := setTextRangeWorker(parseNodeFactory.createElementAccessExpression(lhsExpr, literal), node)
				setParent(literal, result)
				setParent(result, node)
				if lhsExpr != parentAccess {
					setParent(lhsExpr, result)
				}
				result.flowNode = parentAccess.flowNode
				return result
			}
		}
	}
	getParentElementAccess := func(node /* TODO(TS-TO-GO) TypeNode UnionType: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) Expression {
		ancestor := node.parent.parent
		switch ancestor.kind {
		case SyntaxKindBindingElement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertyAssignment:
			return getSyntheticElementAccess(ancestor /* as BindingElement | PropertyAssignment */)
		case SyntaxKindArrayLiteralExpression:
			return getSyntheticElementAccess(node.parent /* as Expression */)
		case SyntaxKindVariableDeclaration:
			return (ancestor /* as VariableDeclaration */).initializer
		case SyntaxKindBinaryExpression:
			return (ancestor /* as BinaryExpression */).right
		}
	}
	getDestructuringPropertyName := func(node /* TODO(TS-TO-GO) TypeNode UnionType: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) *string {
		parent := node.parent
		if node.kind == SyntaxKindBindingElement && parent.kind == SyntaxKindObjectBindingPattern {
			return getLiteralPropertyNameText((node /* as BindingElement */).propertyName || (node /* as BindingElement */).name /* as Identifier */)
		}
		if node.kind == SyntaxKindPropertyAssignment || node.kind == SyntaxKindShorthandPropertyAssignment {
			return getLiteralPropertyNameText((node /* as PropertyAssignment | ShorthandPropertyAssignment */).name)
		}
		return "" + ((parent /* as BindingPattern | ArrayLiteralExpression */).elements /* as NodeArray<Node> */).indexOf(node)
	}
	getLiteralPropertyNameText := func(name PropertyName) *string {
		type_ := getLiteralTypeFromPropertyName(name)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & (TypeFlagsStringLiteral | TypeFlagsNumberLiteral):
			return "" + (type_ /* as StringLiteralType | NumberLiteralType */).value
		default:
			return nil
		}
	}
	/** Return the inferred type for a binding element */
	getTypeForBindingElement := func(declaration BindingElement) Type {
		var checkMode /* TODO(TS-TO-GO) inferred type CheckMode.Normal | CheckMode.RestBindingElement */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case declaration.dotDotDotToken:
			checkMode = CheckModeRestBindingElement
		default:
			checkMode = CheckModeNormal
		}
		parentType := getTypeForBindingElementParent(declaration.parent.parent, checkMode)
		return parentType && getBindingElementTypeFromParentType(declaration, parentType /*noTupleBoundsCheck*/, false)
	}
	getBindingElementTypeFromParentType := func(declaration BindingElement, parentType Type, noTupleBoundsCheck bool) Type {
		// If an any type was inferred for parent, infer that for the binding element
		if isTypeAny(parentType) {
			return parentType
		}
		pattern := declaration.parent
		// Relax null check on ambient destructuring parameters, since the parameters have no implementation and are just documentation
		if strictNullChecks && declaration.flags&NodeFlagsAmbient && isPartOfParameterDeclaration(declaration) {
			parentType = getNonNullableType(parentType)
		} else if strictNullChecks && pattern.parent.initializer && !(hasTypeFacts(getTypeOfInitializer(pattern.parent.initializer), TypeFactsEQUndefined)) {
			parentType = getTypeWithFacts(parentType, TypeFactsNEUndefined)
		}
		accessFlags := AccessFlagsExpressionPosition | (__COND__(noTupleBoundsCheck || hasDefaultValue(declaration), AccessFlagsAllowMissing, 0))
		var type_ Type
		if pattern.kind == SyntaxKindObjectBindingPattern {
			if declaration.dotDotDotToken {
				parentType = getReducedType(parentType)
				if parentType.flags&TypeFlagsUnknown || !isValidSpreadType(parentType) {
					error(declaration, Diagnostics.Rest_types_may_only_be_created_from_object_types)
					return errorType
				}
				var literalMembers []PropertyName = []never{}
				for _, element := range pattern.elements {
					if !element.dotDotDotToken {
						literalMembers.push(element.propertyName || element.name /* as Identifier */)
					}
				}
				type_ = getRestType(parentType, literalMembers, declaration.symbol)
			} else {
				// Use explicitly specified property name ({ p: xxx } form), or otherwise the implied name ({ p } form)
				name := declaration.propertyName || declaration.name /* as Identifier */
				indexType := getLiteralTypeFromPropertyName(name)
				declaredType := getIndexedAccessType(parentType, indexType, accessFlags, name)
				type_ = getFlowTypeOfDestructuring(declaration, declaredType)
			}
		} else {
			// This elementType will be used if the specific property corresponding to this index is not
			// present (aka the tuple element property). This call also checks that the parentType is in
			// fact an iterable or array (depending on target language).
			elementType := checkIteratedTypeOrElementType(IterationUseDestructuring|(__COND__(declaration.dotDotDotToken, 0, IterationUsePossiblyOutOfBounds)), parentType, undefinedType, pattern)
			index := pattern.elements.indexOf(declaration)
			if declaration.dotDotDotToken {
				// If the parent is a tuple type, the rest element has a tuple type of the
				// remaining tuple element types. Otherwise, the rest element has an array type with same
				// element type as the parent type.
				baseConstraint := mapType(parentType, func(t Type) Type {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case t.flags & TypeFlagsInstantiableNonPrimitive:
						return getBaseConstraintOrType(t)
					default:
						return t
					}
				})
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case everyType(baseConstraint, isTupleType):
					type_ = mapType(baseConstraint, func(t Type) Type {
						return sliceTupleType(t /* as TupleTypeReference */, index)
					})
				default:
					type_ = createArrayType(elementType)
				}
			} else if isArrayLikeType(parentType) {
				indexType := getNumberLiteralType(index)
				declaredType := getIndexedAccessTypeOrUndefined(parentType, indexType, accessFlags, declaration.name) || errorType
				type_ = getFlowTypeOfDestructuring(declaration, declaredType)
			} else {
				type_ = elementType
			}
		}
		if !declaration.initializer {
			return type_
		}
		if getEffectiveTypeAnnotationNode(walkUpBindingElementsAndPatterns(declaration)) {
			// In strict null checking mode, if a default value of a non-undefined type is specified, remove
			// undefined from the final type.
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks && !(hasTypeFacts(checkDeclarationInitializer(declaration, CheckModeNormal), TypeFactsIsUndefined)):
				return getNonUndefinedType(type_)
			default:
				return type_
			}
		}
		return widenTypeInferredFromInitializer(declaration, getUnionType([]Type{getNonUndefinedType(type_), checkDeclarationInitializer(declaration, CheckModeNormal)}, UnionReductionSubtype))
	}
	getTypeForDeclarationFromJSDocComment := func(declaration Node) Type {
		jsdocType := getJSDocType(declaration)
		if jsdocType {
			return getTypeFromTypeNode(jsdocType)
		}
		return nil
	}
	isNullOrUndefined := func(node Expression) bool {
		expr := skipParentheses(node /*excludeJSDocTypeAssertions*/, true)
		return expr.kind == SyntaxKindNullKeyword || expr.kind == SyntaxKindIdentifier && getResolvedSymbol(expr /* as Identifier */) == undefinedSymbol
	}
	isEmptyArrayLiteral := func(node Expression) bool {
		expr := skipParentheses(node /*excludeJSDocTypeAssertions*/, true)
		return expr.kind == SyntaxKindArrayLiteralExpression && (expr /* as ArrayLiteralExpression */).elements.length == 0
	}
	addOptionality := func(type_ Type, isProperty bool /*  = false */, isOptional bool /*  = true */) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case strictNullChecks && isOptional:
			return getOptionalType(type_, isProperty)
		default:
			return type_
		}
	}
	// Return the inferred type for a variable, parameter, or property declaration
	getTypeForVariableLikeDeclaration := func(declaration /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, includeOptionality bool, checkMode CheckMode) Type {
		// A variable declared in a for..in statement is of type string, or of type keyof T when the
		// right hand expression is of a type parameter type.
		if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForInStatement {
			indexType := getIndexType(getNonNullableTypeIfNeeded(checkExpression(declaration.parent.parent.expression /*checkMode*/, checkMode)))
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case indexType.flags & (TypeFlagsTypeParameter | TypeFlagsIndex):
				return getExtractStringType(indexType)
			default:
				return stringType
			}
		}
		if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForOfStatement {
			// checkRightHandSideOfForOf will return undefined if the for-of expression type was
			// missing properties/signatures required to get its iteratedType (like
			// [Symbol.iterator] or next). This may be because we accessed properties from anyType,
			// or it may have led to an error inside getElementTypeOfIterable.
			forOfStatement := declaration.parent.parent
			return checkRightHandSideOfForOf(forOfStatement) || anyType
		}
		if isBindingPattern(declaration.parent) {
			return getTypeForBindingElement(declaration /* as BindingElement */)
		}
		isProperty := (isPropertyDeclaration(declaration) && !hasAccessorModifier(declaration)) || isPropertySignature(declaration) || isJSDocPropertyTag(declaration)
		isOptional := includeOptionality && isOptionalDeclaration(declaration)
		// Use type from type annotation if one is present
		declaredType := tryGetTypeFromEffectiveTypeNode(declaration)
		if isCatchClauseVariableDeclarationOrBindingElement(declaration) {
			if declaredType {
				// If the catch clause is explicitly annotated with any or unknown, accept it, otherwise error.
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isTypeAny(declaredType) || declaredType == unknownType:
					return declaredType
				default:
					return errorType
				}
			}
			// If the catch clause is not explicitly annotated, treat it as though it were explicitly
			// annotated with unknown or any, depending on useUnknownInCatchVariables.
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case useUnknownInCatchVariables:
				return unknownType
			default:
				return anyType
			}
		}
		if declaredType {
			return addOptionality(declaredType, isProperty, isOptional)
		}
		if (noImplicitAny || isInJSFile(declaration)) && isVariableDeclaration(declaration) && !isBindingPattern(declaration.name) && !(getCombinedModifierFlagsCached(declaration) & ModifierFlagsExport) && !(declaration.flags & NodeFlagsAmbient) {
			// If --noImplicitAny is on or the declaration is in a Javascript file,
			// use control flow tracked 'any' type for non-ambient, non-exported var or let variables with no
			// initializer or a 'null' or 'undefined' initializer.
			if !(getCombinedNodeFlagsCached(declaration) & NodeFlagsConstant) && (!declaration.initializer || isNullOrUndefined(declaration.initializer)) {
				return autoType
			}
			// Use control flow tracked 'any[]' type for non-ambient, non-exported variables with an empty array
			// literal initializer.
			if declaration.initializer && isEmptyArrayLiteral(declaration.initializer) {
				return autoArrayType
			}
		}
		if isParameter(declaration) {
			if !declaration.symbol {
				// parameters of function types defined in JSDoc in TS files don't have symbols
				return
			}
			func_ := declaration.parent /* as FunctionLikeDeclaration */
			// For a parameter of a set accessor, use the type of the get accessor if one is present
			if func_.kind == SyntaxKindSetAccessor && hasBindableName(func_) {
				getter := getDeclarationOfKind(getSymbolOfDeclaration(declaration.parent), SyntaxKindGetAccessor)
				if getter {
					getterSignature := getSignatureFromDeclaration(getter)
					thisParameter := getAccessorThisParameter(func_ /* as AccessorDeclaration */)
					if thisParameter && declaration == thisParameter {
						// Use the type from the *getter*
						Debug.assert(!thisParameter.type_)
						return getTypeOfSymbol(getterSignature.thisParameter)
					}
					return getReturnTypeOfSignature(getterSignature)
				}
			}
			parameterTypeOfTypeTag := getParameterTypeOfTypeTag(func_, declaration)
			if parameterTypeOfTypeTag {
				return parameterTypeOfTypeTag
			}
			// Use contextual parameter type if one is available
			var type_ Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case declaration.symbol.escapedName == InternalSymbolNameThis:
				type_ = getContextualThisParameterType(func_)
			default:
				type_ = getContextuallyTypedParameterType(declaration)
			}
			if type_ {
				return addOptionality(type_ /*isProperty*/, false, isOptional)
			}
		}
		// Use the type of the initializer expression if one is present and the declaration is
		// not a parameter of a contextually typed function
		if hasOnlyExpressionInitializer(declaration) && !!declaration.initializer {
			if isInJSFile(declaration) && !isParameter(declaration) {
				containerObjectType := getJSContainerObjectType(declaration, getSymbolOfDeclaration(declaration), getDeclaredExpandoInitializer(declaration))
				if containerObjectType {
					return containerObjectType
				}
			}
			type_ := widenTypeInferredFromInitializer(declaration, checkDeclarationInitializer(declaration, checkMode))
			return addOptionality(type_, isProperty, isOptional)
		}
		if isPropertyDeclaration(declaration) && (noImplicitAny || isInJSFile(declaration)) {
			// We have a property declaration with no type annotation or initializer, in noImplicitAny mode or a .js file.
			// Use control flow analysis of this.xxx assignments in the constructor or static block to determine the type of the property.
			if !hasStaticModifier(declaration) {
				constructor := findConstructorDeclaration(declaration.parent)
				var type_ Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case constructor:
					type_ = getFlowTypeInConstructor(declaration.symbol, constructor)
				case getEffectiveModifierFlags(declaration) & ModifierFlagsAmbient:
					type_ = getTypeOfPropertyInBaseClass(declaration.symbol)
				default:
					type_ = nil
				}
				return type_ && addOptionality(type_ /*isProperty*/, true, isOptional)
			} else {
				staticBlocks := filter(declaration.parent.members, isClassStaticBlockDeclaration)
				var type_ Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case staticBlocks.length:
					type_ = getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks)
				case getEffectiveModifierFlags(declaration) & ModifierFlagsAmbient:
					type_ = getTypeOfPropertyInBaseClass(declaration.symbol)
				default:
					type_ = nil
				}
				return type_ && addOptionality(type_ /*isProperty*/, true, isOptional)
			}
		}
		if isJsxAttribute(declaration) {
			// if JSX attribute doesn't have initializer, by default the attribute will have boolean value of true.
			// I.e <Elem attr /> is sugar for <Elem attr={true} />
			return trueType
		}
		// If the declaration specifies a binding pattern and is not a parameter of a contextually
		// typed function, use the type implied by the binding pattern
		if isBindingPattern(declaration.name) {
			return getTypeFromBindingPattern(declaration.name /*includePatternInType*/, false /*reportErrors*/, true)
		}
		// No type specified and nothing can be inferred
		return nil
	}
	isConstructorDeclaredProperty := func(symbol Symbol) bool {
		// A property is considered a constructor declared property when all declaration sites are this.xxx assignments,
		// when no declaration sites have JSDoc type annotations, and when at least one declaration site is in the body of
		// a class constructor.
		if symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration) {
			links := getSymbolLinks(symbol)
			if links.isConstructorDeclaredProperty == nil {
				links.isConstructorDeclaredProperty = false
				links.isConstructorDeclaredProperty = !!getDeclaringConstructor(symbol) && every(symbol.declarations, func(declaration Declaration) bool {
					return isBinaryExpression(declaration) && isPossiblyAliasedThisProperty(declaration) && (declaration.left.kind != SyntaxKindElementAccessExpression || isStringOrNumericLiteralLike((declaration.left /* as ElementAccessExpression */).argumentExpression)) && !getAnnotatedTypeForAssignmentDeclaration(nil, declaration, symbol, declaration)
				})
			}
			return links.isConstructorDeclaredProperty
		}
		return false
	}
	isAutoTypedProperty := func(symbol Symbol) *bool {
		// A property is auto-typed when its declaration has no type annotation or initializer and we're in
		// noImplicitAny mode or a .js file.
		declaration := symbol.valueDeclaration
		return declaration && isPropertyDeclaration(declaration) && !getEffectiveTypeAnnotationNode(declaration) && !declaration.initializer && (noImplicitAny || isInJSFile(declaration))
	}
	getDeclaringConstructor := func(symbol Symbol) *ConstructorDeclaration {
		if !symbol.declarations {
			return
		}
		for _, declaration := range symbol.declarations {
			container := getThisContainer(declaration /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
			if container && (container.kind == SyntaxKindConstructor || isJSConstructor(container)) {
				return container /* as ConstructorDeclaration */
			}
		}
	}
	/** Create a synthetic property access flow node after the last statement of the file */
	getFlowTypeFromCommonJSExport := func(symbol Symbol) Type {
		file := getSourceFileOfNode(symbol.declarations[0])
		accessName := unescapeLeadingUnderscores(symbol.escapedName)
		areAllModuleExports := symbol.declarations.every(func(d Declaration) bool {
			return isInJSFile(d) && isAccessExpression(d) && isModuleExportsAccessExpression(d.expression)
		})
		var reference PropertyAccessExpression
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case areAllModuleExports:
			reference = factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(factory.createIdentifier("module"), factory.createIdentifier("exports")), accessName)
		default:
			reference = factory.createPropertyAccessExpression(factory.createIdentifier("exports"), accessName)
		}
		if areAllModuleExports {
			setParent((reference.expression /* as PropertyAccessExpression */).expression, reference.expression)
		}
		setParent(reference.expression, reference)
		setParent(reference, file)
		reference.flowNode = file.endFlowNode
		return getFlowTypeOfReference(reference, autoType, undefinedType)
	}
	getFlowTypeInStaticBlocks := func(symbol Symbol, staticBlocks []ClassStaticBlockDeclaration) Type {
		var accessName /* TODO(TS-TO-GO) inferred type string | PrivateIdentifier */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case startsWith(symbol.escapedName /* as string */, "__#"):
			accessName = factory.createPrivateIdentifier((symbol.escapedName /* as string */).split("@")[1])
		default:
			accessName = unescapeLeadingUnderscores(symbol.escapedName)
		}
		for _, staticBlock := range staticBlocks {
			reference := factory.createPropertyAccessExpression(factory.createThis(), accessName)
			setParent(reference.expression, reference)
			setParent(reference, staticBlock)
			reference.flowNode = staticBlock.returnFlowNode
			flowType := getFlowTypeOfProperty(reference, symbol)
			if noImplicitAny && (flowType == autoType || flowType == autoArrayType) {
				error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType))
			}
			// We don't infer a type if assignments are only null or undefined.
			if everyType(flowType, isNullableType) {
				continue
			}
			return convertAutoToAny(flowType)
		}
	}
	getFlowTypeInConstructor := func(symbol Symbol, constructor ConstructorDeclaration) Type {
		var accessName /* TODO(TS-TO-GO) inferred type string | PrivateIdentifier */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case startsWith(symbol.escapedName /* as string */, "__#"):
			accessName = factory.createPrivateIdentifier((symbol.escapedName /* as string */).split("@")[1])
		default:
			accessName = unescapeLeadingUnderscores(symbol.escapedName)
		}
		reference := factory.createPropertyAccessExpression(factory.createThis(), accessName)
		setParent(reference.expression, reference)
		setParent(reference, constructor)
		reference.flowNode = constructor.returnFlowNode
		flowType := getFlowTypeOfProperty(reference, symbol)
		if noImplicitAny && (flowType == autoType || flowType == autoArrayType) {
			error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType))
		}
		// We don't infer a type if assignments are only null or undefined.
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case everyType(flowType, isNullableType):
			return nil
		default:
			return convertAutoToAny(flowType)
		}
	}
	getFlowTypeOfProperty := func(reference Node, prop Symbol) Type {
		initialType := prop. /* TODO(TS-TO-GO): was ? */ valueDeclaration && (!isAutoTypedProperty(prop) || getEffectiveModifierFlags(prop.valueDeclaration)&ModifierFlagsAmbient) && getTypeOfPropertyInBaseClass(prop) || undefinedType
		return getFlowTypeOfReference(reference, autoType, initialType)
	}
	getWidenedTypeForAssignmentDeclaration := func(symbol Symbol, resolvedSymbol Symbol) Type {
		// function/class/{} initializers are themselves containers, so they won't merge in the same way as other initializers
		container := getAssignedExpandoInitializer(symbol.valueDeclaration)
		if container {
			var tag *JSDocTypeTag
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isInJSFile(container):
				tag = getJSDocTypeTag(container)
			default:
				tag = nil
			}
			if tag && tag.typeExpression {
				return getTypeFromTypeNode(tag.typeExpression)
			}
			containerObjectType := symbol.valueDeclaration && getJSContainerObjectType(symbol.valueDeclaration, symbol, container)
			return containerObjectType || getWidenedLiteralType(checkExpressionCached(container))
		}
		var type_ TODO
		definedInConstructor := false
		definedInMethod := false
		// We use control flow analysis to determine the type of the property if the property qualifies as a constructor
		// declared property and the resulting control flow type isn't just undefined or null.
		if isConstructorDeclaredProperty(symbol) {
			type_ = getFlowTypeInConstructor(symbol, getDeclaringConstructor(symbol))
		}
		if !type_ {
			var types *[]Type
			if symbol.declarations {
				var jsdocType Type
				for _, declaration := range symbol.declarations {
					var expression * /* TODO(TS-TO-GO) inferred type BinaryExpression | CallExpression | AccessExpression */ any
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case (isBinaryExpression(declaration) || isCallExpression(declaration)):
						expression = declaration
					case isAccessExpression(declaration):
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isBinaryExpression(declaration.parent):
							expression = declaration.parent
						default:
							expression = declaration
						}
					default:
						expression = nil
					}
					if !expression {
						continue
						// Non-assignment declaration merged in (eg, an Identifier to mark the thing as a namespace) - skip over it and pull type info from elsewhere
					}
					var kind AssignmentDeclarationKind
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isAccessExpression(expression):
						kind = getAssignmentDeclarationPropertyAccessKind(expression)
					default:
						kind = getAssignmentDeclarationKind(expression)
					}
					if kind == AssignmentDeclarationKindThisProperty || isBinaryExpression(expression) && isPossiblyAliasedThisProperty(expression, kind) {
						if isDeclarationInConstructor(expression) {
							definedInConstructor = true
						} else {
							definedInMethod = true
						}
					}
					if !isCallExpression(expression) {
						jsdocType = getAnnotatedTypeForAssignmentDeclaration(jsdocType, expression, symbol, declaration)
					}
					if !jsdocType {
						(types || ( /* TODO(TS-TO-GO) Node BinaryExpression: types = [] */ TODO)).push(__COND__((isBinaryExpression(expression) || isCallExpression(expression)), getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind), neverType))
					}
				}
				type_ = jsdocType
			}
			if !type_ {
				if !length(types) {
					return errorType
					// No types from any declarations :(
				}
				var constructorTypes *[]Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case definedInConstructor && symbol.declarations:
					constructorTypes = getConstructorDefinedThisAssignmentTypes(types, symbol.declarations)
				default:
					constructorTypes = nil
				}
				// use only the constructor types unless they were only assigned null | undefined (including widening variants)
				if definedInMethod {
					propType := getTypeOfPropertyInBaseClass(symbol)
					if propType {
						(constructorTypes || ( /* TODO(TS-TO-GO) Node BinaryExpression: constructorTypes = [] */ TODO)).push(propType)
						definedInConstructor = true
					}
				}
				var sourceTypes *[]Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case some(constructorTypes, func(t Type) bool {
					return !!(t.flags & ~TypeFlagsNullable)
				}):
					sourceTypes = constructorTypes
				default:
					sourceTypes = types
				}
				// TODO: GH#18217
				type_ = getUnionType(sourceTypes)
			}
		}
		widened := getWidenedType(addOptionality(type_ /*isProperty*/, false, definedInMethod && !definedInConstructor))
		if symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && filterType(widened, func(t Type) bool {
			return !!(t.flags & ~TypeFlagsNullable)
		}) == neverType {
			reportImplicitAny(symbol.valueDeclaration, anyType)
			return anyType
		}
		return widened
	}
	getJSContainerObjectType := func(decl Node, symbol Symbol, init Expression) Type {
		if !isInJSFile(decl) || !init || !isObjectLiteralExpression(init) || init.properties.length {
			return nil
		}
		exports := createSymbolTable()
		for isBinaryExpression(decl) || isPropertyAccessExpression(decl) {
			s := getSymbolOfNode(decl)
			if s. /* TODO(TS-TO-GO): was ? */ exports. /* TODO(TS-TO-GO): was ? */ size {
				mergeSymbolTable(exports, s.exports)
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isBinaryExpression(decl):
				decl = decl.parent
			default:
				decl = decl.parent.parent
			}
		}
		s := getSymbolOfNode(decl)
		if s. /* TODO(TS-TO-GO): was ? */ exports. /* TODO(TS-TO-GO): was ? */ size {
			mergeSymbolTable(exports, s.exports)
		}
		type_ := createAnonymousType(symbol, exports, emptyArray, emptyArray, emptyArray)
		type_.objectFlags |= ObjectFlagsJSLiteral
		return type_
	}
	getAnnotatedTypeForAssignmentDeclaration := func(declaredType Type, expression Expression, symbol Symbol, declaration Declaration) Type {
		typeNode := getEffectiveTypeAnnotationNode(expression.parent)
		if typeNode {
			type_ := getWidenedType(getTypeFromTypeNode(typeNode))
			if !declaredType {
				return type_
			} else if !isErrorType(declaredType) && !isErrorType(type_) && !isTypeIdenticalTo(declaredType, type_) {
				errorNextVariableOrPropertyDeclarationMustHaveSameType(nil, declaredType, declaration, type_)
			}
		}
		if symbol.parent. /* TODO(TS-TO-GO): was ? */ valueDeclaration {
			possiblyAnnotatedSymbol := getFunctionExpressionParentSymbolOrSymbol(symbol.parent)
			if possiblyAnnotatedSymbol.valueDeclaration {
				typeNode := getEffectiveTypeAnnotationNode(possiblyAnnotatedSymbol.valueDeclaration)
				if typeNode {
					annotationSymbol := getPropertyOfType(getTypeFromTypeNode(typeNode), symbol.escapedName)
					if annotationSymbol {
						return getNonMissingTypeOfSymbol(annotationSymbol)
					}
				}
			}
		}
		return declaredType
	}
	/** If we don't have an explicit JSDoc type, get the type from the initializer. */
	getInitializerTypeFromAssignmentDeclaration := func(symbol Symbol, resolvedSymbol Symbol, expression /* TODO(TS-TO-GO) TypeNode UnionType: BinaryExpression | CallExpression */ any, kind AssignmentDeclarationKind) Type {
		if isCallExpression(expression) {
			if resolvedSymbol {
				return getTypeOfSymbol(resolvedSymbol)
				// This shouldn't happen except under some hopefully forbidden merges of export assignments and object define assignments
			}
			objectLitType := checkExpressionCached((expression /* as BindableObjectDefinePropertyCall */).arguments[2])
			valueType := getTypeOfPropertyOfType(objectLitType, "value" /* as __String */)
			if valueType {
				return valueType
			}
			getFunc := getTypeOfPropertyOfType(objectLitType, "get" /* as __String */)
			if getFunc {
				getSig := getSingleCallSignature(getFunc)
				if getSig {
					return getReturnTypeOfSignature(getSig)
				}
			}
			setFunc := getTypeOfPropertyOfType(objectLitType, "set" /* as __String */)
			if setFunc {
				setSig := getSingleCallSignature(setFunc)
				if setSig {
					return getTypeOfFirstParameterOfSignature(setSig)
				}
			}
			return anyType
		}
		if containsSameNamedThisProperty(expression.left, expression.right) {
			return anyType
		}
		isDirectExport := kind == AssignmentDeclarationKindExportsProperty && (isPropertyAccessExpression(expression.left) || isElementAccessExpression(expression.left)) && (isModuleExportsAccessExpression(expression.left.expression) || (isIdentifier(expression.left.expression) && isExportsIdentifier(expression.left.expression)))
		var type_ Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case resolvedSymbol:
			type_ = getTypeOfSymbol(resolvedSymbol)
		case isDirectExport:
			type_ = getRegularTypeOfLiteralType(checkExpressionCached(expression.right))
		default:
			type_ = getWidenedLiteralType(checkExpressionCached(expression.right))
		}
		if type_.flags&TypeFlagsObject && kind == AssignmentDeclarationKindModuleExports && symbol.escapedName == InternalSymbolNameExportEquals {
			exportedType := resolveStructuredTypeMembers(type_ /* as ObjectType */)
			members := createSymbolTable()
			copyEntries(exportedType.members, members)
			initialSize := members.size
			if resolvedSymbol && !resolvedSymbol.exports {
				resolvedSymbol.exports = createSymbolTable()
			}
			(resolvedSymbol || symbol).exports.forEach(func(s Symbol, name __String) {
				exportedMember := members.get(name)
				if exportedMember && exportedMember != s && !(s.flags & SymbolFlagsAlias) {
					if s.flags&SymbolFlagsValue && exportedMember.flags&SymbolFlagsValue {
						// If the member has an additional value-like declaration, union the types from the two declarations,
						// but issue an error if they occurred in two different files. The purpose is to support a JS file with
						// a pattern like:
						//
						// module.exports = { a: true };
						// module.exports.a = 3;
						//
						// but we may have a JS file with `module.exports = { a: true }` along with a TypeScript module augmentation
						// declaring an `export const a: number`. In that case, we issue a duplicate identifier error, because
						// it's unclear what that's supposed to mean, so it's probably a mistake.
						if s.valueDeclaration && exportedMember.valueDeclaration && getSourceFileOfNode(s.valueDeclaration) != getSourceFileOfNode(exportedMember.valueDeclaration) {
							unescapedName := unescapeLeadingUnderscores(s.escapedName)
							exportedMemberName := tryCast(exportedMember.valueDeclaration, isNamedDeclaration). /* TODO(TS-TO-GO): was ? */ name || exportedMember.valueDeclaration
							addRelatedInfo(error(s.valueDeclaration, Diagnostics.Duplicate_identifier_0, unescapedName), createDiagnosticForNode(exportedMemberName, Diagnostics._0_was_also_declared_here, unescapedName))
							addRelatedInfo(error(exportedMemberName, Diagnostics.Duplicate_identifier_0, unescapedName), createDiagnosticForNode(s.valueDeclaration, Diagnostics._0_was_also_declared_here, unescapedName))
						}
						union := createSymbol(s.flags|exportedMember.flags, name)
						union.links.type_ = getUnionType([]Type{getTypeOfSymbol(s), getTypeOfSymbol(exportedMember)})
						union.valueDeclaration = exportedMember.valueDeclaration
						union.declarations = concatenate(exportedMember.declarations, s.declarations)
						members.set(name, union)
					} else {
						members.set(name, mergeSymbol(s, exportedMember))
					}
				} else {
					members.set(name, s)
				}
			})
			result := createAnonymousType(__COND__(initialSize != members.size, nil, exportedType.symbol), members, exportedType.callSignatures, exportedType.constructSignatures, exportedType.indexInfos)
			if initialSize == members.size {
				if type_.aliasSymbol {
					result.aliasSymbol = type_.aliasSymbol
					result.aliasTypeArguments = type_.aliasTypeArguments
				}
				if getObjectFlags(type_) & ObjectFlagsReference {
					result.aliasSymbol = (type_ /* as TypeReference */).symbol
					args := getTypeArguments(type_ /* as TypeReference */)
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case length(args):
						result.aliasTypeArguments = args
					default:
						result.aliasTypeArguments = nil
					}
				}
			}
			result.objectFlags |= getPropagatingFlagsOfTypes([]Type{type_}) | getObjectFlags(type_)&(ObjectFlagsJSLiteral|ObjectFlagsArrayLiteral|ObjectFlagsObjectLiteral)
			if result.symbol && result.symbol.flags&SymbolFlagsClass && type_ == getDeclaredTypeOfClassOrInterface(result.symbol) {
				result.objectFlags |= ObjectFlagsIsClassInstanceClone
				// Propagate the knowledge that this type is equivalent to the symbol's class instance type
			}
			return result
		}
		if isEmptyArrayLiteralType(type_) {
			reportImplicitAny(expression, anyArrayType)
			return anyArrayType
		}
		return type_
	}
	containsSameNamedThisProperty := func(thisProperty Expression, expression Expression) *bool {
		return isPropertyAccessExpression(thisProperty) && thisProperty.expression.kind == SyntaxKindThisKeyword && forEachChildRecursively(expression, func(n Node) bool {
			return isMatchingReference(thisProperty, n)
		})
	}
	isDeclarationInConstructor := func(expression Expression) bool {
		thisContainer := getThisContainer(expression /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
		// Properties defined in a constructor (or base constructor, or javascript constructor function) don't get undefined added.
		// Function expressions that are assigned to the prototype count as methods.
		return thisContainer.kind == SyntaxKindConstructor || thisContainer.kind == SyntaxKindFunctionDeclaration || (thisContainer.kind == SyntaxKindFunctionExpression && !isPrototypePropertyAssignment(thisContainer.parent))
	}
	getConstructorDefinedThisAssignmentTypes := func(types []Type, declarations []Declaration) *[]Type {
		Debug.assert(types.length == declarations.length)
		return types.filter(func(_ Type, i number) *bool {
			declaration := declarations[i]
			var expression *BinaryExpression
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isBinaryExpression(declaration):
				expression = declaration
			case isBinaryExpression(declaration.parent):
				expression = declaration.parent
			default:
				expression = nil
			}
			return expression && isDeclarationInConstructor(expression)
		})
	}
	// Return the type implied by a binding pattern element. This is the type of the initializer of the element if
	// one is present. Otherwise, if the element is itself a binding pattern, it is the type implied by the binding
	// pattern. Otherwise, it is the type any.
	getTypeFromBindingElement := func(element BindingElement, includePatternInType bool, reportErrors bool) Type {
		if element.initializer {
			// The type implied by a binding pattern is independent of context, so we check the initializer with no
			// contextual type or, if the element itself is a binding pattern, with the type implied by that binding
			// pattern.
			var contextualType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isBindingPattern(element.name):
				contextualType = getTypeFromBindingPattern(element.name /*includePatternInType*/, true /*reportErrors*/, false)
			default:
				contextualType = unknownType
			}
			return addOptionality(widenTypeInferredFromInitializer(element, checkDeclarationInitializer(element, CheckModeNormal, contextualType)))
		}
		if isBindingPattern(element.name) {
			return getTypeFromBindingPattern(element.name, includePatternInType, reportErrors)
		}
		if reportErrors && !declarationBelongsToPrivateAmbientMember(element) {
			reportImplicitAny(element, anyType)
		}
		// When we're including the pattern in the type (an indication we're obtaining a contextual type), we
		// use a non-inferrable any type. Inference will never directly infer this type, but it is possible
		// to infer a type that contains it, e.g. for a binding pattern like [foo] or { foo }. In such cases,
		// widening of the binding pattern type substitutes a regular any for the non-inferrable any.
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case includePatternInType:
			return nonInferrableAnyType
		default:
			return anyType
		}
	}
	// Return the type implied by an object binding pattern
	getTypeFromObjectBindingPattern := func(pattern ObjectBindingPattern, includePatternInType bool, reportErrors bool) Type {
		members := createSymbolTable()
		var stringIndexInfo *IndexInfo
		objectFlags := ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
		forEach(pattern.elements, func(e BindingElement) {
			name := e.propertyName || e.name /* as Identifier */
			if e.dotDotDotToken {
				stringIndexInfo = createIndexInfo(stringType, anyType /*isReadonly*/, false)
				return
			}
			exprType := getLiteralTypeFromPropertyName(name)
			if !isTypeUsableAsPropertyName(exprType) {
				// do not include computed properties in the implied type
				objectFlags |= ObjectFlagsObjectLiteralPatternWithComputedProperties
				return
			}
			text := getPropertyNameFromType(exprType)
			flags := SymbolFlagsProperty | (__COND__(e.initializer, SymbolFlagsOptional, 0))
			symbol := createSymbol(flags, text)
			symbol.links.type_ = getTypeFromBindingElement(e, includePatternInType, reportErrors)
			symbol.links.bindingElement = e
			members.set(symbol.escapedName, symbol)
		})
		result := createAnonymousType(nil, members, emptyArray, emptyArray, __COND__(stringIndexInfo, []IndexInfo{stringIndexInfo}, emptyArray))
		result.objectFlags |= objectFlags
		if includePatternInType {
			result.pattern = pattern
			result.objectFlags |= ObjectFlagsContainsObjectOrArrayLiteral
		}
		return result
	}
	// Return the type implied by an array binding pattern
	getTypeFromArrayBindingPattern := func(pattern BindingPattern, includePatternInType bool, reportErrors bool) Type {
		elements := pattern.elements
		lastElement := lastOrUndefined(elements)
		var restElement *BindingElement
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case lastElement && lastElement.kind == SyntaxKindBindingElement && lastElement.dotDotDotToken:
			restElement = lastElement
		default:
			restElement = nil
		}
		if elements.length == 0 || elements.length == 1 && restElement {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case languageVersion >= ScriptTargetES2015:
				return createIterableType(anyType)
			default:
				return anyArrayType
			}
		}
		elementTypes := map_(elements, func(e /* TODO(TS-TO-GO) inferred type BindingElement | OmittedExpression */ any) Type {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isOmittedExpression(e):
				return anyType
			default:
				return getTypeFromBindingElement(e, includePatternInType, reportErrors)
			}
		})
		minLength := findLastIndex(elements, func(e /* TODO(TS-TO-GO) inferred type BindingElement | OmittedExpression */ any) bool {
			return !(e == restElement || isOmittedExpression(e) || hasDefaultValue(e))
		}, elements.length-1) + 1
		elementFlags := map_(elements, func(e /* TODO(TS-TO-GO) inferred type BindingElement | OmittedExpression */ any, i number) /* TODO(TS-TO-GO) inferred type ElementFlags.Required | ElementFlags.Optional | ElementFlags.Rest */ any {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case e == restElement:
				return ElementFlagsRest
			case i >= minLength:
				return ElementFlagsOptional
			default:
				return ElementFlagsRequired
			}
		})
		result := createTupleType(elementTypes, elementFlags) /* as TypeReference */
		if includePatternInType {
			result = cloneTypeReference(result)
			result.pattern = pattern
			result.objectFlags |= ObjectFlagsContainsObjectOrArrayLiteral
		}
		return result
	}
	// Return the type implied by a binding pattern. This is the type implied purely by the binding pattern itself
	// and without regard to its context (i.e. without regard any type annotation or initializer associated with the
	// declaration in which the binding pattern is contained). For example, the implied type of [x, y] is [any, any]
	// and the implied type of { x, y: z = 1 } is { x: any; y: number; }. The type implied by a binding pattern is
	// used as the contextual type of an initializer associated with the binding pattern. Also, for a destructuring
	// parameter with no type annotation or initializer, the type implied by the binding pattern becomes the type of
	// the parameter.
	getTypeFromBindingPattern := func(pattern BindingPattern, includePatternInType bool /*  = false */, reportErrors bool /*  = false */) Type {
		if includePatternInType {
			contextualBindingPatterns.push(pattern)
		}
		var result Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case pattern.kind == SyntaxKindObjectBindingPattern:
			result = getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors)
		default:
			result = getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors)
		}
		if includePatternInType {
			contextualBindingPatterns.pop()
		}
		return result
	}
	// Return the type associated with a variable, parameter, or property declaration. In the simple case this is the type
	// specified in a type annotation or inferred from an initializer. However, in the case of a destructuring declaration it
	// is a bit more involved. For example:
	//
	//   var [x, s = ""] = [1, "one"];
	//
	// Here, the array literal [1, "one"] is contextually typed by the type [any, string], which is the implied type of the
	// binding pattern [x, s = ""]. Because the contextual type is a tuple type, the resulting type of [1, "one"] is the
	// tuple type [number, string]. Thus, the type inferred for 'x' is number and the type inferred for 's' is string.
	getWidenedTypeForVariableLikeDeclaration := func(declaration /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, reportErrors bool) Type {
		return widenTypeForVariableLikeDeclaration(getTypeForVariableLikeDeclaration(declaration /*includeOptionality*/, true, CheckModeNormal), declaration, reportErrors)
	}
	getTypeFromImportAttributes := func(node ImportAttributes) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			symbol := createSymbol(SymbolFlagsObjectLiteral, InternalSymbolNameImportAttributes)
			members := createSymbolTable()
			forEach(node.elements, func(attr ImportAttribute) {
				member := createSymbol(SymbolFlagsProperty, getNameFromImportAttribute(attr))
				member.parent = symbol
				member.links.type_ = checkImportAttribute(attr)
				member.links.target = member
				members.set(member.escapedName, member)
			})
			type_ := createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
			type_.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsNonInferrableType
			links.resolvedType = type_
		}
		return links.resolvedType
	}
	isGlobalSymbolConstructor := func(node Node) *bool {
		symbol := getSymbolOfNode(node)
		globalSymbol := getGlobalESSymbolConstructorTypeSymbol(false)
		return globalSymbol && symbol && symbol == globalSymbol
	}
	widenTypeForVariableLikeDeclaration := func(type_ Type, declaration any, reportErrors bool) Type {
		if type_ {
			// TODO: If back compat with pre-3.0/4.0 libs isn't required, remove the following SymbolConstructor special case transforming `symbol` into `unique symbol`
			if type_.flags&TypeFlagsESSymbol && isGlobalSymbolConstructor(declaration.parent) {
				type_ = getESSymbolLikeTypeForNode(declaration)
			}
			if reportErrors {
				reportErrorsFromWidening(declaration, type_)
			}
			// always widen a 'unique symbol' type if the type was created for a different declaration.
			if type_.flags&TypeFlagsUniqueESSymbol && (isBindingElement(declaration) || !declaration.type_) && type_.symbol != getSymbolOfDeclaration(declaration) {
				type_ = esSymbolType
			}
			return getWidenedType(type_)
		}
		// Rest parameters default to type any[], other parameters default to type any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isParameter(declaration) && declaration.dotDotDotToken:
			type_ = anyArrayType
		default:
			type_ = anyType
		}
		// Report implicit any errors unless this is a private property within an ambient declaration
		if reportErrors {
			if !declarationBelongsToPrivateAmbientMember(declaration) {
				reportImplicitAny(declaration, type_)
			}
		}
		return type_
	}
	declarationBelongsToPrivateAmbientMember := func(declaration VariableLikeDeclaration) bool {
		root := getRootDeclaration(declaration)
		var memberDeclaration Node
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case root.kind == SyntaxKindParameter:
			memberDeclaration = root.parent
		default:
			memberDeclaration = root
		}
		return isPrivateWithinAmbient(memberDeclaration)
	}
	tryGetTypeFromEffectiveTypeNode := func(node Node) Type {
		typeNode := getEffectiveTypeAnnotationNode(node)
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
	}
	isParameterOfContextSensitiveSignature := func(symbol Symbol) bool {
		decl := symbol.valueDeclaration
		if !decl {
			return false
		}
		if isBindingElement(decl) {
			decl = walkUpBindingElementsAndPatterns(decl)
		}
		if isParameter(decl) {
			return isContextSensitiveFunctionOrObjectLiteralMethod(decl.parent)
		}
		return false
	}
	getTypeOfVariableOrParameterOrProperty := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			type_ := getTypeOfVariableOrParameterOrPropertyWorker(symbol)
			// For a contextually typed parameter it is possible that a type has already
			// been assigned (in assignTypeToParameterAndFixTypeParameters), and we want
			// to preserve this type. In fact, we need to _prefer_ that type, but it won't
			// be assigned until contextual typing is complete, so we need to defer in
			// cases where contextual typing may take place.
			if !links.type_ && !isParameterOfContextSensitiveSignature(symbol) {
				links.type_ = type_
			}
			return type_
		}
		return links.type_
	}
	getTypeOfVariableOrParameterOrPropertyWorker := func(symbol Symbol) Type {
		// Handle prototype property
		if symbol.flags & SymbolFlagsPrototype {
			return getTypeOfPrototypeProperty(symbol)
		}
		// CommonsJS require and module both have type any.
		if symbol == requireSymbol {
			return anyType
		}
		if symbol.flags&SymbolFlagsModuleExports && symbol.valueDeclaration {
			fileSymbol := getSymbolOfDeclaration(getSourceFileOfNode(symbol.valueDeclaration))
			result := createSymbol(fileSymbol.flags, "exports" /* as __String */)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case fileSymbol.declarations:
				result.declarations = fileSymbol.declarations.slice()
			default:
				result.declarations = []never{}
			}
			result.parent = symbol
			result.links.target = fileSymbol
			if fileSymbol.valueDeclaration {
				result.valueDeclaration = fileSymbol.valueDeclaration
			}
			if fileSymbol.members {
				result.members = NewMap(fileSymbol.members)
			}
			if fileSymbol.exports {
				result.exports = NewMap(fileSymbol.exports)
			}
			members := createSymbolTable()
			members.set("exports" /* as __String */, result)
			return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
		}
		Debug.assertIsDefined(symbol.valueDeclaration)
		declaration := symbol.valueDeclaration
		// Handle export default expressions
		if isSourceFile(declaration) && isJsonSourceFile(declaration) {
			if !declaration.statements.length {
				return emptyObjectType
			}
			return getWidenedType(getWidenedLiteralType(checkExpression(declaration.statements[0].expression)))
		}
		if isAccessor(declaration) {
			// Binding of certain patterns in JS code will occasionally mark symbols as both properties
			// and accessors. Here we dispatch to accessor resolution if needed.
			return getTypeOfAccessors(symbol)
		}
		// Handle variable, parameter or property
		if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
			// Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
			if symbol.flags&SymbolFlagsValueModule && !(symbol.flags & SymbolFlagsAssignment) {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			return reportCircularityError(symbol)
		}
		var type_ Type
		if declaration.kind == SyntaxKindExportAssignment {
			type_ = widenTypeForVariableLikeDeclaration(tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionCached((declaration /* as ExportAssignment */).expression), declaration)
		} else if isBinaryExpression(declaration) || (isInJSFile(declaration) && (isCallExpression(declaration) || (isPropertyAccessExpression(declaration) || isBindableStaticElementAccessExpression(declaration)) && isBinaryExpression(declaration.parent))) {
			type_ = getWidenedTypeForAssignmentDeclaration(symbol)
		} else if isPropertyAccessExpression(declaration) || isElementAccessExpression(declaration) || isIdentifier(declaration) || isStringLiteralLike(declaration) || isNumericLiteral(declaration) || isClassDeclaration(declaration) || isFunctionDeclaration(declaration) || (isMethodDeclaration(declaration) && !isObjectLiteralMethod(declaration)) || isMethodSignature(declaration) || isSourceFile(declaration) {
			// Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
			if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsEnum | SymbolFlagsValueModule) {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isBinaryExpression(declaration.parent):
				type_ = getWidenedTypeForAssignmentDeclaration(symbol)
			default:
				type_ = tryGetTypeFromEffectiveTypeNode(declaration) || anyType
			}
		} else if isPropertyAssignment(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkPropertyAssignment(declaration)
		} else if isJsxAttribute(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(declaration)
		} else if isShorthandPropertyAssignment(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(declaration.name, CheckModeNormal)
		} else if isObjectLiteralMethod(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(declaration, CheckModeNormal)
		} else if isParameter(declaration) || isPropertyDeclaration(declaration) || isPropertySignature(declaration) || isVariableDeclaration(declaration) || isBindingElement(declaration) || isJSDocPropertyLikeTag(declaration) {
			type_ = getWidenedTypeForVariableLikeDeclaration(declaration /*reportErrors*/, true)
		} else if isEnumDeclaration(declaration) {
			type_ = getTypeOfFuncClassEnumModule(symbol)
		} else if isEnumMember(declaration) {
			type_ = getTypeOfEnumMember(symbol)
		} else {
			return Debug.fail("Unhandled declaration kind! " + Debug.formatSyntaxKind(declaration.kind) + " for " + Debug.formatSymbol(symbol))
		}
		if !popTypeResolution() {
			// Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
			if symbol.flags&SymbolFlagsValueModule && !(symbol.flags & SymbolFlagsAssignment) {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			return reportCircularityError(symbol)
		}
		return type_
	}
	getAnnotatedAccessorTypeNode := func(accessor /* TODO(TS-TO-GO) TypeNode UnionType: AccessorDeclaration | PropertyDeclaration | undefined */ any) *TypeNode {
		if accessor {
			switch accessor.kind {
			case SyntaxKindGetAccessor:
				getterTypeAnnotation := getEffectiveReturnTypeNode(accessor)
				return getterTypeAnnotation
			case SyntaxKindSetAccessor:
				setterTypeAnnotation := getEffectiveSetAccessorTypeAnnotationNode(accessor)
				return setterTypeAnnotation
			case SyntaxKindPropertyDeclaration:
				Debug.assert(hasAccessorModifier(accessor))
				accessorTypeAnnotation := getEffectiveTypeAnnotationNode(accessor)
				return accessorTypeAnnotation
			}
		}
		return nil
	}
	getAnnotatedAccessorType := func(accessor /* TODO(TS-TO-GO) TypeNode UnionType: AccessorDeclaration | PropertyDeclaration | undefined */ any) Type {
		node := getAnnotatedAccessorTypeNode(accessor)
		return node && getTypeFromTypeNode(node)
	}
	getAnnotatedAccessorThisParameter := func(accessor AccessorDeclaration) Symbol {
		parameter := getAccessorThisParameter(accessor)
		return parameter && parameter.symbol
	}
	getThisTypeOfDeclaration := func(declaration SignatureDeclaration) Type {
		return getThisTypeOfSignature(getSignatureFromDeclaration(declaration))
	}
	getTypeOfAccessors := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
				return errorType
			}
			getter := getDeclarationOfKind(symbol, SyntaxKindGetAccessor)
			setter := getDeclarationOfKind(symbol, SyntaxKindSetAccessor)
			accessor := tryCast(getDeclarationOfKind(symbol, SyntaxKindPropertyDeclaration), isAutoAccessorPropertyDeclaration)
			// We try to resolve a getter type annotation, a setter type annotation, or a getter function
			// body return type inference, in that order.
			type_ := getter && isInJSFile(getter) && getTypeForDeclarationFromJSDocComment(getter) || getAnnotatedAccessorType(getter) || getAnnotatedAccessorType(setter) || getAnnotatedAccessorType(accessor) || getter && getter.body && getReturnTypeFromBody(getter) || accessor && accessor.initializer && getWidenedTypeForVariableLikeDeclaration(accessor /*reportErrors*/, true)
			if !type_ {
				if setter && !isPrivateWithinAmbient(setter) {
					errorOrSuggestion(noImplicitAny, setter, Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation, symbolToString(symbol))
				} else if getter && !isPrivateWithinAmbient(getter) {
					errorOrSuggestion(noImplicitAny, getter, Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation, symbolToString(symbol))
				} else if accessor && !isPrivateWithinAmbient(accessor) {
					errorOrSuggestion(noImplicitAny, accessor, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), "any")
				}
				type_ = anyType
			}
			if !popTypeResolution() {
				if getAnnotatedAccessorTypeNode(getter) {
					error(getter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				} else if getAnnotatedAccessorTypeNode(setter) {
					error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				} else if getAnnotatedAccessorTypeNode(accessor) {
					error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				} else if getter && noImplicitAny {
					error(getter, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, symbolToString(symbol))
				}
				type_ = anyType
			}
			/* TODO(TS-TO-GO) Node BinaryExpression: links.type ??= type */ TODO
		}
		return links.type_
	}
	getWriteTypeOfAccessors := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.writeType {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameWriteType) {
				return errorType
			}
			setter := /* TODO(TS-TO-GO) Node BinaryExpression: getDeclarationOfKind<AccessorDeclaration>(symbol, SyntaxKind.SetAccessor) ?? tryCast(getDeclarationOfKind<PropertyDeclaration>(symbol, SyntaxKind.PropertyDeclaration), isAutoAccessorPropertyDeclaration) */ TODO
			writeType := getAnnotatedAccessorType(setter)
			if !popTypeResolution() {
				if getAnnotatedAccessorTypeNode(setter) {
					error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				}
				writeType = anyType
			}
			// Absent an explicit setter type annotation we use the read type of the accessor.
			/* TODO(TS-TO-GO) Node BinaryExpression: links.writeType ??= writeType || getTypeOfAccessors(symbol) */
			TODO
		}
		return links.writeType
	}
	getBaseTypeVariableOfClass := func(symbol Symbol) Type {
		baseConstructorType := getBaseConstructorTypeOfClass(getDeclaredTypeOfClassOrInterface(symbol))
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case baseConstructorType.flags & TypeFlagsTypeVariable:
			return baseConstructorType
		case baseConstructorType.flags & TypeFlagsIntersection:
			return find((baseConstructorType /* as IntersectionType */).types, func(t Type) bool {
				return !!(t.flags & TypeFlagsTypeVariable)
			})
		default:
			return nil
		}
	}
	getTypeOfFuncClassEnumModule := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		originalLinks := links
		if !links.type_ {
			expando := symbol.valueDeclaration && getSymbolOfExpando(symbol.valueDeclaration /*allowDeclaration*/, false)
			if expando {
				merged := mergeJSSymbols(symbol, expando)
				if merged {
					// note:we overwrite links because we just cloned the symbol
					symbol = merged
					links = merged.links
				}
			}
			originalLinks.type_ = /* TODO(TS-TO-GO) Node BinaryExpression: links.type = getTypeOfFuncClassEnumModuleWorker(symbol) */ TODO
		}
		return links.type_
	}
	getTypeOfFuncClassEnumModuleWorker := func(symbol Symbol) Type {
		declaration := symbol.valueDeclaration
		if symbol.flags&SymbolFlagsModule && isShorthandAmbientModuleSymbol(symbol) {
			return anyType
		} else if declaration && (declaration.kind == SyntaxKindBinaryExpression || isAccessExpression(declaration) && declaration.parent.kind == SyntaxKindBinaryExpression) {
			return getWidenedTypeForAssignmentDeclaration(symbol)
		} else if symbol.flags&SymbolFlagsValueModule && declaration && isSourceFile(declaration) && declaration.commonJsModuleIndicator {
			resolvedModule := resolveExternalModuleSymbol(symbol)
			if resolvedModule != symbol {
				if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
					return errorType
				}
				exportEquals := getMergedSymbol(symbol.exports.get(InternalSymbolNameExportEquals))
				type_ := getWidenedTypeForAssignmentDeclaration(exportEquals, __COND__(exportEquals == resolvedModule, nil, resolvedModule))
				if !popTypeResolution() {
					return reportCircularityError(symbol)
				}
				return type_
			}
		}
		type_ := createObjectType(ObjectFlagsAnonymous, symbol)
		if symbol.flags & SymbolFlagsClass {
			baseTypeVariable := getBaseTypeVariableOfClass(symbol)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case baseTypeVariable:
				return getIntersectionType([]Type{type_, baseTypeVariable})
			default:
				return type_
			}
		} else {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks && symbol.flags&SymbolFlagsOptional:
				return getOptionalType(type_ /*isProperty*/, true)
			default:
				return type_
			}
		}
	}
	getTypeOfEnumMember := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.type_ || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.type = getDeclaredTypeOfEnumMember(symbol) */ TODO)
	}
	getTypeOfAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
				return errorType
			}
			targetSymbol := resolveAlias(symbol)
			exportSymbol := symbol.declarations && getTargetOfAliasDeclaration(getDeclarationOfAliasSymbol(symbol) /*dontRecursivelyResolve*/, true)
			declaredType := firstDefined(exportSymbol. /* TODO(TS-TO-GO): was ? */ declarations, func(d Declaration) Type {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isExportAssignment(d):
					return tryGetTypeFromEffectiveTypeNode(d)
				default:
					return nil
				}
			})
			// It only makes sense to get the type of a value symbol. If the result of resolving
			// the alias is not a value, then it has no type. To get the type associated with a
			// type symbol, call getDeclaredTypeOfSymbol.
			// This check is important because without it, a call to getTypeOfSymbol could end
			// up recursively calling getTypeOfAlias, causing a stack overflow.
			/* TODO(TS-TO-GO) Node BinaryExpression: links.type ??= exportSymbol?.declarations && isDuplicatedCommonJSExport(exportSymbol.declarations) && symbol.declarations!.length ? getFlowTypeFromCommonJSExport(exportSymbol) : isDuplicatedCommonJSExport(symbol.declarations) ? autoType : declaredType ? declaredType : getSymbolFlags(targetSymbol) & SymbolFlags.Value ? getTypeOfSymbol(targetSymbol) : errorType */
			TODO
			if !popTypeResolution() {
				reportCircularityError( /* TODO(TS-TO-GO) Node BinaryExpression: exportSymbol ?? symbol */ TODO)
				return /* TODO(TS-TO-GO) Node BinaryExpression: links.type ??= errorType */ TODO
			}
		}
		return links.type_
	}
	getTypeOfInstantiatedSymbol := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.type_ || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.type = instantiateType(getTypeOfSymbol(links.target!), links.mapper) */ TODO)
	}
	getWriteTypeOfInstantiatedSymbol := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.writeType || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.writeType = instantiateType(getWriteTypeOfSymbol(links.target!), links.mapper) */ TODO)
	}
	reportCircularityError := func(symbol Symbol) IntrinsicType {
		declaration := symbol.valueDeclaration
		// Check if variable has type annotation that circularly references the variable itself
		if declaration {
			if getEffectiveTypeAnnotationNode(declaration) {
				error(symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				return errorType
			}
			// Check if variable has initializer that circularly references the variable itself
			if noImplicitAny && (declaration.kind != SyntaxKindParameter || (declaration /* as HasInitializer */).initializer) {
				error(symbol.valueDeclaration, Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer, symbolToString(symbol))
			}
		} else if symbol.flags & SymbolFlagsAlias {
			node := getDeclarationOfAliasSymbol(symbol)
			if node {
				error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol))
			}
		}
		// Circularities could also result from parameters in function expressions that end up
		// having themselves as contextual types following type argument inference. In those cases
		// we have already reported an implicit any error so we don't report anything here.
		return anyType
	}
	getTypeOfSymbolWithDeferredType := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			Debug.assertIsDefined(links.deferralParent)
			Debug.assertIsDefined(links.deferralConstituents)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case links.deferralParent.flags & TypeFlagsUnion:
				links.type_ = getUnionType(links.deferralConstituents)
			default:
				links.type_ = getIntersectionType(links.deferralConstituents)
			}
		}
		return links.type_
	}
	getWriteTypeOfSymbolWithDeferredType := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.writeType && links.deferralWriteConstituents {
			Debug.assertIsDefined(links.deferralParent)
			Debug.assertIsDefined(links.deferralConstituents)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case links.deferralParent.flags & TypeFlagsUnion:
				links.writeType = getUnionType(links.deferralWriteConstituents)
			default:
				links.writeType = getIntersectionType(links.deferralWriteConstituents)
			}
		}
		return links.writeType
	}
	/**
	 * Distinct write types come only from set accessors, but synthetic union and intersection
	 * properties deriving from set accessors will either pre-compute or defer the union or
	 * intersection of the writeTypes of their constituents.
	 */
	getWriteTypeOfSymbol := func(symbol Symbol) Type {
		checkFlags := getCheckFlags(symbol)
		if symbol.flags & SymbolFlagsProperty {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case checkFlags & CheckFlagsSyntheticProperty:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case checkFlags & CheckFlagsDeferredType:
					return getWriteTypeOfSymbolWithDeferredType(symbol) || getTypeOfSymbolWithDeferredType(symbol)
				default:
					return (symbol /* as TransientSymbol */).links.writeType || (symbol /* as TransientSymbol */).links.type_
				}
			default:
				return removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlagsOptional))
			}
		}
		if symbol.flags & SymbolFlagsAccessor {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case checkFlags & CheckFlagsInstantiated:
				return getWriteTypeOfInstantiatedSymbol(symbol)
			default:
				return getWriteTypeOfAccessors(symbol)
			}
		}
		return getTypeOfSymbol(symbol)
	}
	getTypeOfSymbol := func(symbol Symbol) Type {
		checkFlags := getCheckFlags(symbol)
		if checkFlags & CheckFlagsDeferredType {
			return getTypeOfSymbolWithDeferredType(symbol)
		}
		if checkFlags & CheckFlagsInstantiated {
			return getTypeOfInstantiatedSymbol(symbol)
		}
		if checkFlags & CheckFlagsMapped {
			return getTypeOfMappedSymbol(symbol /* as MappedSymbol */)
		}
		if checkFlags & CheckFlagsReverseMapped {
			return getTypeOfReverseMappedSymbol(symbol /* as ReverseMappedSymbol */)
		}
		if symbol.flags & (SymbolFlagsVariable | SymbolFlagsProperty) {
			return getTypeOfVariableOrParameterOrProperty(symbol)
		}
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsEnum | SymbolFlagsValueModule) {
			return getTypeOfFuncClassEnumModule(symbol)
		}
		if symbol.flags & SymbolFlagsEnumMember {
			return getTypeOfEnumMember(symbol)
		}
		if symbol.flags & SymbolFlagsAccessor {
			return getTypeOfAccessors(symbol)
		}
		if symbol.flags & SymbolFlagsAlias {
			return getTypeOfAlias(symbol)
		}
		return errorType
	}
	getNonMissingTypeOfSymbol := func(symbol Symbol) Type {
		return removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlagsOptional))
	}
	isReferenceToSomeType := func(type_ Type, targets []Type) bool {
		if type_ == nil || (getObjectFlags(type_)&ObjectFlagsReference) == 0 {
			return false
		}
		for _, target := range targets {
			if (type_ /* as TypeReference */).target == target {
				return true
			}
		}
		return false
	}
	isReferenceToType := func(type_ Type, target Type) bool {
		return type_ != nil && target != nil && (getObjectFlags(type_)&ObjectFlagsReference) != 0 && (type_ /* as TypeReference */).target == target
	}
	getTargetType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getObjectFlags(type_) & ObjectFlagsReference:
			return (type_ /* as TypeReference */).target
		default:
			return type_
		}
	}
	// TODO: GH#18217 If `checkBase` is undefined, we should not call this because this will always return false.
	hasBaseType := func(type_ Type, checkBase Type) bool {
		return check(type_)
		check := func(type_ Type) bool {
			if getObjectFlags(type_) & (ObjectFlagsClassOrInterface | ObjectFlagsReference) {
				target := getTargetType(type_) /* as InterfaceType */
				return target == checkBase || some(getBaseTypes(target), check)
			} else if type_.flags & TypeFlagsIntersection {
				return some((type_ /* as IntersectionType */).types, check)
			}
			return false
		}
	}
	// Appends the type parameters given by a list of declarations to a set of type parameters and returns the resulting set.
	// The function allocates a new array if the input type parameter set is undefined, but otherwise it modifies the set
	// in-place and returns the same array.
	appendTypeParameters := func(typeParameters *[]TypeParameter, declarations []TypeParameterDeclaration) *[]TypeParameter {
		for _, declaration := range declarations {
			typeParameters = appendIfUnique(typeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(declaration)))
		}
		return typeParameters
	}
	// Return the outer type parameters of a node or undefined if the node has no outer type parameters.
	getOuterTypeParameters := func(node Node, includeThisTypes bool) *[]TypeParameter {
		for true {
			node = node.parent
			// TODO: GH#18217 Use SourceFile kind check instead
			if node && isBinaryExpression(node) {
				// prototype assignments get the outer type parameters of their constructor function
				assignmentKind := getAssignmentDeclarationKind(node)
				if assignmentKind == AssignmentDeclarationKindPrototype || assignmentKind == AssignmentDeclarationKindPrototypeProperty {
					symbol := getSymbolOfDeclaration(node.left /* as BindableStaticNameExpression | PropertyAssignment */)
					if symbol && symbol.parent && !findAncestor(symbol.parent.valueDeclaration, func(d Node) bool {
						return node == d
					}) {
						node = symbol.parent.valueDeclaration
					}
				}
			}
			if !node {
				return nil
			}
			kind := node.kind
			switch kind {
			case SyntaxKindClassDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindClassExpression:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindCallSignature:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindConstructSignature:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindMethodSignature:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindFunctionType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindConstructorType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJSDocFunctionType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindFunctionDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindFunctionExpression:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindArrowFunction:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindTypeAliasDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJSDocTemplateTag:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJSDocTypedefTag:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJSDocEnumTag:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJSDocCallbackTag:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindMappedType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindConditionalType:
				outerTypeParameters := getOuterTypeParameters(node, includeThisTypes)
				if (kind == SyntaxKindFunctionExpression || kind == SyntaxKindArrowFunction || isObjectLiteralMethod(node)) && isContextSensitive(node /* as Expression | MethodDeclaration */) {
					signature := firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node /* as FunctionLikeDeclaration */)), SignatureKindCall))
					if signature && signature.typeParameters {
						return []TypeParameter{ /* TODO(TS-TO-GO) Node SpreadElement: ...(outerTypeParameters || emptyArray) */ /* TODO(TS-TO-GO) Node SpreadElement: ...signature.typeParameters */ }
					}
				}
				if kind == SyntaxKindMappedType {
					return append(outerTypeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration((node /* as MappedTypeNode */).typeParameter)))
				} else if kind == SyntaxKindConditionalType {
					return concatenate(outerTypeParameters, getInferTypeParameters(node /* as ConditionalTypeNode */))
				}
				outerAndOwnTypeParameters := appendTypeParameters(outerTypeParameters, getEffectiveTypeParameterDeclarations(node /* as DeclarationWithTypeParameters */))
				thisType := includeThisTypes && (kind == SyntaxKindClassDeclaration || kind == SyntaxKindClassExpression || kind == SyntaxKindInterfaceDeclaration || isJSConstructor(node)) && getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node /* as ClassLikeDeclaration | InterfaceDeclaration */)).thisType
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case thisType:
					return append(outerAndOwnTypeParameters, thisType)
				default:
					return outerAndOwnTypeParameters
				}
				fallthrough
			case SyntaxKindJSDocParameterTag:
				paramSymbol := getParameterSymbolFromJSDoc(node /* as JSDocParameterTag */)
				if paramSymbol {
					node = paramSymbol.valueDeclaration
				}
				break
			case SyntaxKindJSDoc:
				outerTypeParameters := getOuterTypeParameters(node, includeThisTypes)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case (node /* as JSDoc */).tags:
					return appendTypeParameters(outerTypeParameters, flatMap((node /* as JSDoc */).tags, func(t JSDocTag) *NodeArray[TypeParameterDeclaration] {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isJSDocTemplateTag(t):
							return t.typeParameters
						default:
							return nil
						}
					}))
				default:
					return outerTypeParameters
				}
			}
		}
	}
	// The outer type parameters are those defined by enclosing generic classes, methods, or functions.
	getOuterTypeParametersOfClassOrInterface := func(symbol Symbol) *[]TypeParameter {
		var declaration Declaration
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case (symbol.flags&SymbolFlagsClass || symbol.flags&SymbolFlagsFunction):
			declaration = symbol.valueDeclaration
		default:
			declaration = symbol.declarations. /* TODO(TS-TO-GO): was ? */ find(func(decl Declaration) bool {
				if decl.kind == SyntaxKindInterfaceDeclaration {
					return true
				}
				if decl.kind != SyntaxKindVariableDeclaration {
					return false
				}
				initializer := (decl /* as VariableDeclaration */).initializer
				return !!initializer && (initializer.kind == SyntaxKindFunctionExpression || initializer.kind == SyntaxKindArrowFunction)
			})
		}
		Debug.assert(!!declaration, "Class was missing valueDeclaration -OR- non-class had no interface declarations")
		return getOuterTypeParameters(declaration)
	}
	// The local type parameters are the combined set of type parameters from all declarations of the class,
	// interface, or type alias.
	getLocalTypeParametersOfClassOrInterfaceOrTypeAlias := func(symbol Symbol) *[]TypeParameter {
		if !symbol.declarations {
			return
		}
		var result *[]TypeParameter
		for _, node := range symbol.declarations {
			if node.kind == SyntaxKindInterfaceDeclaration || node.kind == SyntaxKindClassDeclaration || node.kind == SyntaxKindClassExpression || isJSConstructor(node) || isTypeAlias(node) {
				declaration := node /* as InterfaceDeclaration | TypeAliasDeclaration | JSDocTypedefTag | JSDocCallbackTag */
				result = appendTypeParameters(result, getEffectiveTypeParameterDeclarations(declaration))
			}
		}
		return result
	}
	// The full set of type parameters for a generic class or interface type consists of its outer type parameters plus
	// its locally declared type parameters.
	getTypeParametersOfClassOrInterface := func(symbol Symbol) *[]TypeParameter {
		return concatenate(getOuterTypeParametersOfClassOrInterface(symbol), getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol))
	}
	// A type is a mixin constructor if it has a single construct signature taking no type parameters and a single
	// rest parameter of type any[].
	isMixinConstructorType := func(type_ Type) bool {
		signatures := getSignaturesOfType(type_, SignatureKindConstruct)
		if signatures.length == 1 {
			s := signatures[0]
			if !s.typeParameters && s.parameters.length == 1 && signatureHasRestParameter(s) {
				paramType := getTypeOfParameter(s.parameters[0])
				return isTypeAny(paramType) || getElementTypeOfArrayType(paramType) == anyType
			}
		}
		return false
	}
	isConstructorType := func(type_ Type) bool {
		if getSignaturesOfType(type_, SignatureKindConstruct).length > 0 {
			return true
		}
		if type_.flags & TypeFlagsTypeVariable {
			constraint := getBaseConstraintOfType(type_)
			return !!constraint && isMixinConstructorType(constraint)
		}
		return false
	}
	getBaseTypeNodeOfClass := func(type_ InterfaceType) *ExpressionWithTypeArguments {
		decl := getClassLikeDeclarationOfSymbol(type_.symbol)
		return decl && getEffectiveBaseTypeNode(decl)
	}
	getConstructorsForTypeArguments := func(type_ Type, typeArgumentNodes *[]TypeNode, location Node) []Signature {
		typeArgCount := length(typeArgumentNodes)
		isJavascript := isInJSFile(location)
		return filter(getSignaturesOfType(type_, SignatureKindConstruct), func(sig Signature) bool {
			return (isJavascript || typeArgCount >= getMinTypeArgumentCount(sig.typeParameters)) && typeArgCount <= length(sig.typeParameters)
		})
	}
	getInstantiatedConstructorsForTypeArguments := func(type_ Type, typeArgumentNodes *[]TypeNode, location Node) []Signature {
		signatures := getConstructorsForTypeArguments(type_, typeArgumentNodes, location)
		typeArguments := map_(typeArgumentNodes, getTypeFromTypeNode)
		return sameMap(signatures, func(sig Signature) Signature {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case some(sig.typeParameters):
				return getSignatureInstantiation(sig, typeArguments, isInJSFile(location))
			default:
				return sig
			}
		})
	}
	/**
	 * The base constructor of a class can resolve to
	 * * undefinedType if the class has no extends clause,
	 * * errorType if an error occurred during resolution of the extends expression,
	 * * nullType if the extends expression is the null value,
	 * * anyType if the extends expression has type any, or
	 * * an object type with at least one construct signature.
	 */
	getBaseConstructorTypeOfClass := func(type_ InterfaceType) Type {
		if !type_.resolvedBaseConstructorType {
			decl := getClassLikeDeclarationOfSymbol(type_.symbol)
			extended := decl && getEffectiveBaseTypeNode(decl)
			baseTypeNode := getBaseTypeNodeOfClass(type_)
			if !baseTypeNode {
				type_.resolvedBaseConstructorType = undefinedType
				return type_.resolvedBaseConstructorType
			}
			if !pushTypeResolution(type_, TypeSystemPropertyNameResolvedBaseConstructorType) {
				return errorType
			}
			baseConstructorType := checkExpression(baseTypeNode.expression)
			if extended && baseTypeNode != extended {
				Debug.assert(!extended.typeArguments)
				// Because this is in a JS file, and baseTypeNode is in an @extends tag
				checkExpression(extended.expression)
			}
			if baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection) {
				// Resolving the members of a class requires us to resolve the base class of that class.
				// We force resolution here such that we catch circularities now.
				resolveStructuredTypeMembers(baseConstructorType /* as ObjectType */)
			}
			if !popTypeResolution() {
				error(type_.symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type_.symbol))
				return /* TODO(TS-TO-GO) Node BinaryExpression: type.resolvedBaseConstructorType ??= errorType */ TODO
			}
			if !(baseConstructorType.flags & TypeFlagsAny) && baseConstructorType != nullWideningType && !isConstructorType(baseConstructorType) {
				err := error(baseTypeNode.expression, Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType))
				if baseConstructorType.flags & TypeFlagsTypeParameter {
					constraint := getConstraintFromTypeParameter(baseConstructorType)
					var ctorReturn Type = unknownType
					if constraint {
						ctorSig := getSignaturesOfType(constraint, SignatureKindConstruct)
						if ctorSig[0] {
							ctorReturn = getReturnTypeOfSignature(ctorSig[0])
						}
					}
					if baseConstructorType.symbol.declarations {
						addRelatedInfo(err, createDiagnosticForNode(baseConstructorType.symbol.declarations[0], Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1, symbolToString(baseConstructorType.symbol), typeToString(ctorReturn)))
					}
				}
				return /* TODO(TS-TO-GO) Node BinaryExpression: type.resolvedBaseConstructorType ??= errorType */ TODO
			}
			/* TODO(TS-TO-GO) Node BinaryExpression: type.resolvedBaseConstructorType ??= baseConstructorType */ TODO
		}
		return type_.resolvedBaseConstructorType
	}
	getImplementsTypes := func(type_ InterfaceType) []BaseType {
		var resolvedImplementsTypes []BaseType = emptyArray
		if type_.symbol.declarations {
			for _, declaration := range type_.symbol.declarations {
				implementsTypeNodes := getEffectiveImplementsTypeNodes(declaration /* as ClassLikeDeclaration */)
				if !implementsTypeNodes {
					continue
				}
				for _, node := range implementsTypeNodes {
					implementsType := getTypeFromTypeNode(node)
					if !isErrorType(implementsType) {
						if resolvedImplementsTypes == emptyArray {
							resolvedImplementsTypes = []ObjectType{implementsType /* as ObjectType */}
						} else {
							resolvedImplementsTypes.push(implementsType)
						}
					}
				}
			}
		}
		return resolvedImplementsTypes
	}
	reportCircularBaseType := func(node Node, type_ Type) {
		error(node, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type_ /*enclosingDeclaration*/, nil, TypeFormatFlagsWriteArrayAsGenericType))
	}
	getBaseTypes := func(type_ InterfaceType) []BaseType {
		if !type_.baseTypesResolved {
			if pushTypeResolution(type_, TypeSystemPropertyNameResolvedBaseTypes) {
				if type_.objectFlags & ObjectFlagsTuple {
					type_.resolvedBaseTypes = []ObjectType{getTupleBaseType(type_ /* as TupleType */)}
				} else if type_.symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
					if type_.symbol.flags & SymbolFlagsClass {
						resolveBaseTypesOfClass(type_)
					}
					if type_.symbol.flags & SymbolFlagsInterface {
						resolveBaseTypesOfInterface(type_)
					}
				} else {
					Debug.fail("type must be class or interface")
				}
				if !popTypeResolution() && type_.symbol.declarations {
					for _, declaration := range type_.symbol.declarations {
						if declaration.kind == SyntaxKindClassDeclaration || declaration.kind == SyntaxKindInterfaceDeclaration {
							reportCircularBaseType(declaration, type_)
						}
					}
				}
			}
			type_.baseTypesResolved = true
		}
		return type_.resolvedBaseTypes
	}
	getTupleBaseType := func(type_ TupleType) ObjectType {
		elementTypes := sameMap(type_.typeParameters, func(t TypeParameter, i number) Type {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case type_.elementFlags[i] & ElementFlagsVariadic:
				return getIndexedAccessType(t, numberType)
			default:
				return t
			}
		})
		return createArrayType(getUnionType(elementTypes || emptyArray), type_.readonly)
	}
	resolveBaseTypesOfClass := func(type_ InterfaceType) []BaseType {
		type_.resolvedBaseTypes = resolvingEmptyArray
		baseConstructorType := getApparentType(getBaseConstructorTypeOfClass(type_))
		if !(baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsAny)) {
			type_.resolvedBaseTypes = emptyArray
			return type_.resolvedBaseTypes
		}
		baseTypeNode := getBaseTypeNodeOfClass(type_)
		var baseType Type
		var originalBaseType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case baseConstructorType.symbol:
			originalBaseType = getDeclaredTypeOfSymbol(baseConstructorType.symbol)
		default:
			originalBaseType = nil
		}
		if baseConstructorType.symbol && baseConstructorType.symbol.flags&SymbolFlagsClass && areAllOuterTypeParametersApplied(originalBaseType) {
			// When base constructor type is a class with no captured type arguments we know that the constructors all have the same type parameters as the
			// class and all return the instance type of the class. There is no need for further checks and we can apply the
			// type arguments in the same manner as a type reference to get the same error reporting experience.
			baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol)
		} else if baseConstructorType.flags & TypeFlagsAny {
			baseType = baseConstructorType
		} else {
			// The class derives from a "class-like" constructor function, check that we have at least one construct signature
			// with a matching number of type parameters and use the return type of the first instantiated signature. Elsewhere
			// we check that all instantiated signatures return the same type.
			constructors := getInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.typeArguments, baseTypeNode)
			if !constructors.length {
				error(baseTypeNode.expression, Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments)
				type_.resolvedBaseTypes = emptyArray
				return type_.resolvedBaseTypes
			}
			baseType = getReturnTypeOfSignature(constructors[0])
		}
		if isErrorType(baseType) {
			type_.resolvedBaseTypes = emptyArray
			return type_.resolvedBaseTypes
		}
		reducedBaseType := getReducedType(baseType)
		if !isValidBaseType(reducedBaseType) {
			elaboration := elaborateNeverIntersection(nil, baseType)
			diagnostic := chainDiagnosticMessages(elaboration, Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members, typeToString(reducedBaseType))
			diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(baseTypeNode.expression), baseTypeNode.expression, diagnostic))
			type_.resolvedBaseTypes = emptyArray
			return type_.resolvedBaseTypes
		}
		if type_ == reducedBaseType || hasBaseType(reducedBaseType, type_) {
			error(type_.symbol.valueDeclaration, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type_ /*enclosingDeclaration*/, nil, TypeFormatFlagsWriteArrayAsGenericType))
			type_.resolvedBaseTypes = emptyArray
			return type_.resolvedBaseTypes
		}
		if type_.resolvedBaseTypes == resolvingEmptyArray {
			// Circular reference, likely through instantiation of default parameters
			// (otherwise there'd be an error from hasBaseType) - this is fine, but `.members` should be reset
			// as `getIndexedAccessType` via `instantiateType` via `getTypeFromClassOrInterfaceReference` forces a
			// partial instantiation of the members without the base types fully resolved
			type_.members = nil
		}
		type_.resolvedBaseTypes = []BaseType{reducedBaseType}
		return type_.resolvedBaseTypes
	}
	areAllOuterTypeParametersApplied := func(type_ Type) bool {
		// An unapplied type parameter has its symbol still the same as the matching argument symbol.
		// Since parameters are applied outer-to-inner, only the last outer parameter needs to be checked.
		outerTypeParameters := (type_ /* as InterfaceType */).outerTypeParameters
		if outerTypeParameters {
			last := outerTypeParameters.length - 1
			typeArguments := getTypeArguments(type_ /* as TypeReference */)
			return outerTypeParameters[last].symbol != typeArguments[last].symbol
		}
		return true
	}
	// A valid base type is `any`, an object type or intersection of object types.
	isValidBaseType := func(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is BaseType */ any {
		if type_.flags & TypeFlagsTypeParameter {
			constraint := getBaseConstraintOfType(type_)
			if constraint {
				return isValidBaseType(constraint)
			}
		}
		// TODO: Given that we allow type parmeters here now, is this `!isGenericMappedType(type)` check really needed?
		// There's no reason a `T` should be allowed while a `Readonly<T>` should not.
		return !!(type_.flags&(TypeFlagsObject|TypeFlagsNonPrimitive|TypeFlagsAny) && !isGenericMappedType(type_) || type_.flags&TypeFlagsIntersection && every((type_ /* as IntersectionType */).types, isValidBaseType))
	}
	resolveBaseTypesOfInterface := func(type_ InterfaceType) {
		type_.resolvedBaseTypes = type_.resolvedBaseTypes || emptyArray
		if type_.symbol.declarations {
			for _, declaration := range type_.symbol.declarations {
				if declaration.kind == SyntaxKindInterfaceDeclaration && getInterfaceBaseTypeNodes(declaration /* as InterfaceDeclaration */) {
					for _, node := range getInterfaceBaseTypeNodes(declaration /* as InterfaceDeclaration */) {
						baseType := getReducedType(getTypeFromTypeNode(node))
						if !isErrorType(baseType) {
							if isValidBaseType(baseType) {
								if type_ != baseType && !hasBaseType(baseType, type_) {
									if type_.resolvedBaseTypes == emptyArray {
										type_.resolvedBaseTypes = []ObjectType{baseType /* as ObjectType */}
									} else {
										type_.resolvedBaseTypes.push(baseType)
									}
								} else {
									reportCircularBaseType(declaration, type_)
								}
							} else {
								error(node, Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members)
							}
						}
					}
				}
			}
		}
	}
	/**
	 * Returns true if the interface given by the symbol is free of "this" references.
	 *
	 * Specifically, the result is true if the interface itself contains no references
	 * to "this" in its body, if all base types are interfaces,
	 * and if none of the base interfaces have a "this" type.
	 */
	isThislessInterface := func(symbol Symbol) bool {
		if !symbol.declarations {
			return true
		}
		for _, declaration := range symbol.declarations {
			if declaration.kind == SyntaxKindInterfaceDeclaration {
				if declaration.flags & NodeFlagsContainsThis {
					return false
				}
				baseTypeNodes := getInterfaceBaseTypeNodes(declaration /* as InterfaceDeclaration */)
				if baseTypeNodes {
					for _, node := range baseTypeNodes {
						if isEntityNameExpression(node.expression) {
							baseSymbol := resolveEntityName(node.expression, SymbolFlagsType /*ignoreErrors*/, true)
							if !baseSymbol || !(baseSymbol.flags & SymbolFlagsInterface) || getDeclaredTypeOfClassOrInterface(baseSymbol).thisType {
								return false
							}
						}
					}
				}
			}
		}
		return true
	}
	getDeclaredTypeOfClassOrInterface := func(symbol Symbol) InterfaceType {
		links := getSymbolLinks(symbol)
		originalLinks := links
		if !links.declaredType {
			var kind /* TODO(TS-TO-GO) inferred type ObjectFlags.Class | ObjectFlags.Interface */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case symbol.flags & SymbolFlagsClass:
				kind = ObjectFlagsClass
			default:
				kind = ObjectFlagsInterface
			}
			merged := mergeJSSymbols(symbol, symbol.valueDeclaration && getAssignedClassSymbol(symbol.valueDeclaration))
			if merged {
				// note:we overwrite links because we just cloned the symbol
				symbol = merged
				links = merged.links
			}
			type_ := /* TODO(TS-TO-GO) Node BinaryExpression: originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol) as InterfaceType */ TODO
			outerTypeParameters := getOuterTypeParametersOfClassOrInterface(symbol)
			localTypeParameters := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
			// A class or interface is generic if it has type parameters or a "this" type. We always give classes a "this" type
			// because it is not feasible to analyze all members to determine if the "this" type escapes the class (in particular,
			// property types inferred from initializers and method return types inferred from return statements are very hard
			// to exhaustively analyze). We give interfaces a "this" type if we can't definitely determine that they are free of
			// "this" references.
			if outerTypeParameters || localTypeParameters || kind == ObjectFlagsClass || !isThislessInterface(symbol) {
				type_.objectFlags |= ObjectFlagsReference
				type_.typeParameters = concatenate(outerTypeParameters, localTypeParameters)
				type_.outerTypeParameters = outerTypeParameters
				type_.localTypeParameters = localTypeParameters
				(type_ /* as GenericType */).instantiations = NewMap[string, TypeReference]()
				(type_ /* as GenericType */).instantiations.set(getTypeListId(type_.typeParameters), type_ /* as GenericType */)
				(type_ /* as GenericType */).target = type_ /* as GenericType */
				(type_ /* as GenericType */).resolvedTypeArguments = type_.typeParameters
				type_.thisType = createTypeParameter(symbol)
				type_.thisType.isThisType = true
				type_.thisType.constraint = type_
			}
		}
		return links.declaredType /* as InterfaceType */
	}
	getDeclaredTypeOfTypeAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.declaredType {
			// Note that we use the links object as the target here because the symbol object is used as the unique
			// identity for resolution of the 'type' property in SymbolLinks.
			if !pushTypeResolution(symbol, TypeSystemPropertyNameDeclaredType) {
				return errorType
			}
			declaration := Debug.checkDefined(symbol.declarations. /* TODO(TS-TO-GO): was ? */ find(isTypeAlias), "Type alias symbol with no valid declaration found")
			var typeNode *TypeNode
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isJSDocTypeAlias(declaration):
				typeNode = declaration.typeExpression
			default:
				typeNode = declaration.type_
			}
			// If typeNode is missing, we will error in checkJSDocTypedefTag.
			var type_ Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case typeNode:
				type_ = getTypeFromTypeNode(typeNode)
			default:
				type_ = errorType
			}
			if popTypeResolution() {
				typeParameters := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				if typeParameters {
					// Initialize the instantiation cache for generic type aliases. The declared type corresponds to
					// an instantiation of the type alias with the type parameters supplied as type arguments.
					links.typeParameters = typeParameters
					links.instantiations = NewMap[string, Type]()
					links.instantiations.set(getTypeListId(typeParameters), type_)
				}
				if type_ == intrinsicMarkerType && symbol.escapedName == "BuiltinIteratorReturn" {
					type_ = getBuiltinIteratorReturnType()
				}
			} else {
				type_ = errorType
				if declaration.kind == SyntaxKindJSDocEnumTag {
					error(declaration.typeExpression.type_, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol))
				} else {
					error(__COND__(isNamedDeclaration(declaration), declaration.name || declaration, declaration), Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol))
				}
			}
			/* TODO(TS-TO-GO) Node BinaryExpression: links.declaredType ??= type */ TODO
		}
		return links.declaredType
	}
	getBaseTypeOfEnumLikeType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags&TypeFlagsEnumLike && type_.symbol.flags&SymbolFlagsEnumMember:
			return getDeclaredTypeOfSymbol(getParentOfSymbol(type_.symbol))
		default:
			return type_
		}
	}
	getDeclaredTypeOfEnum := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.declaredType {
			var memberTypeList []Type = []never{}
			if symbol.declarations {
				for _, declaration := range symbol.declarations {
					if declaration.kind == SyntaxKindEnumDeclaration {
						for _, member := range (declaration /* as EnumDeclaration */).members {
							if hasBindableName(member) {
								memberSymbol := getSymbolOfDeclaration(member)
								value := getEnumMemberValue(member).value
								memberType := getFreshTypeOfLiteralType(__COND__(value != nil, getEnumLiteralType(value, getSymbolId(symbol), memberSymbol), createComputedEnumType(memberSymbol)))
								getSymbolLinks(memberSymbol).declaredType = memberType
								memberTypeList.push(getRegularTypeOfLiteralType(memberType))
							}
						}
					}
				}
			}
			var enumType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case memberTypeList.length:
				enumType = getUnionType(memberTypeList, UnionReductionLiteral, symbol /*aliasTypeArguments*/, nil)
			default:
				enumType = createComputedEnumType(symbol)
			}
			if enumType.flags & TypeFlagsUnion {
				enumType.flags |= TypeFlagsEnumLiteral
				enumType.symbol = symbol
			}
			links.declaredType = enumType
		}
		return links.declaredType
	}
	createComputedEnumType := func(symbol Symbol) EnumType {
		regularType := createTypeWithSymbol(TypeFlagsEnum, symbol) /* as EnumType */
		freshType := createTypeWithSymbol(TypeFlagsEnum, symbol)   /* as EnumType */
		regularType.regularType = regularType
		regularType.freshType = freshType
		freshType.regularType = regularType
		freshType.freshType = freshType
		return regularType
	}
	getDeclaredTypeOfEnumMember := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.declaredType {
			enumType := getDeclaredTypeOfEnum(getParentOfSymbol(symbol))
			if !links.declaredType {
				links.declaredType = enumType
			}
		}
		return links.declaredType
	}
	getDeclaredTypeOfTypeParameter := func(symbol Symbol) TypeParameter {
		links := getSymbolLinks(symbol)
		return links.declaredType || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.declaredType = createTypeParameter(symbol) */ TODO)
	}
	getDeclaredTypeOfAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.declaredType || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol)) */ TODO)
	}
	getDeclaredTypeOfSymbol := func(symbol Symbol) Type {
		return tryGetDeclaredTypeOfSymbol(symbol) || errorType
	}
	tryGetDeclaredTypeOfSymbol := func(symbol Symbol) Type {
		if symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
			return getDeclaredTypeOfClassOrInterface(symbol)
		}
		if symbol.flags & SymbolFlagsTypeAlias {
			return getDeclaredTypeOfTypeAlias(symbol)
		}
		if symbol.flags & SymbolFlagsTypeParameter {
			return getDeclaredTypeOfTypeParameter(symbol)
		}
		if symbol.flags & SymbolFlagsEnum {
			return getDeclaredTypeOfEnum(symbol)
		}
		if symbol.flags & SymbolFlagsEnumMember {
			return getDeclaredTypeOfEnumMember(symbol)
		}
		if symbol.flags & SymbolFlagsAlias {
			return getDeclaredTypeOfAlias(symbol)
		}
		return nil
	}
	/**
	 * A type is free of this references if it's the any, string, number, boolean, symbol, or void keyword, a string
	 * literal type, an array with an element type that is free of this references, or a type reference that is
	 * free of this references.
	 */
	isThislessType := func(node TypeNode) bool {
		switch node.kind {
		case SyntaxKindAnyKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindUnknownKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindStringKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNumberKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBigIntKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBooleanKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindSymbolKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindObjectKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindVoidKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindUndefinedKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNeverKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindLiteralType:
			return true
		case SyntaxKindArrayType:
			return isThislessType((node /* as ArrayTypeNode */).elementType)
		case SyntaxKindTypeReference:
			return !(node /* as TypeReferenceNode */).typeArguments || (node /* as TypeReferenceNode */).typeArguments.every(isThislessType)
		}
		return false
	}
	/** A type parameter is thisless if its constraint is thisless, or if it has no constraint. */
	isThislessTypeParameter := func(node TypeParameterDeclaration) bool {
		constraint := getEffectiveConstraintOfTypeParameter(node)
		return !constraint || isThislessType(constraint)
	}
	/**
	 * A variable-like declaration is free of this references if it has a type annotation
	 * that is thisless, or if it has no type annotation and no initializer (and is thus of type any).
	 */
	isThislessVariableLikeDeclaration := func(node VariableLikeDeclaration) bool {
		typeNode := getEffectiveTypeAnnotationNode(node)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case typeNode:
			return isThislessType(typeNode)
		default:
			return !hasInitializer(node)
		}
	}
	/**
	 * A function-like declaration is considered free of `this` references if it has a return type
	 * annotation that is free of this references and if each parameter is thisless and if
	 * each type parameter (if present) is thisless.
	 */
	isThislessFunctionLikeDeclaration := func(node FunctionLikeDeclaration) bool {
		returnType := getEffectiveReturnTypeNode(node)
		typeParameters := getEffectiveTypeParameterDeclarations(node)
		return (node.kind == SyntaxKindConstructor || (!!returnType && isThislessType(returnType))) && node.parameters.every(isThislessVariableLikeDeclaration) && typeParameters.every(isThislessTypeParameter)
	}
	/**
	 * Returns true if the class or interface member given by the symbol is free of "this" references. The
	 * function may return false for symbols that are actually free of "this" references because it is not
	 * feasible to perform a complete analysis in all cases. In particular, property members with types
	 * inferred from their initializers and function members with inferred return types are conservatively
	 * assumed not to be free of "this" references.
	 */
	isThisless := func(symbol Symbol) bool {
		if symbol.declarations && symbol.declarations.length == 1 {
			declaration := symbol.declarations[0]
			if declaration {
				switch declaration.kind {
				case SyntaxKindPropertyDeclaration:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindPropertySignature:
					return isThislessVariableLikeDeclaration(declaration /* as VariableLikeDeclaration */)
				case SyntaxKindMethodDeclaration:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindMethodSignature:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindConstructor:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindGetAccessor:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindSetAccessor:
					return isThislessFunctionLikeDeclaration(declaration /* as FunctionLikeDeclaration | AccessorDeclaration */)
				}
			}
		}
		return false
	}
	// The mappingThisOnly flag indicates that the only type parameter being mapped is "this". When the flag is true,
	// we check symbols to see if we can quickly conclude they are free of "this" references, thus needing no instantiation.
	createInstantiatedSymbolTable := func(symbols []Symbol, mapper TypeMapper, mappingThisOnly bool) SymbolTable {
		result := createSymbolTable()
		for _, symbol := range symbols {
			result.set(symbol.escapedName, __COND__(mappingThisOnly && isThisless(symbol), symbol, instantiateSymbol(symbol, mapper)))
		}
		return result
	}
	addInheritedMembers := func(symbols SymbolTable, baseSymbols []Symbol) {
		for _, base := range baseSymbols {
			if isStaticPrivateIdentifierProperty(base) {
				continue
			}
			derived := symbols.get(base.escapedName)
			if !derived || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration) && !isConstructorDeclaredProperty(derived) && !getContainingClassStaticBlock(derived.valueDeclaration) {
				symbols.set(base.escapedName, base)
				symbols.set(base.escapedName, base)
			}
		}
	}
	isStaticPrivateIdentifierProperty := func(s Symbol) bool {
		return !!s.valueDeclaration && isPrivateIdentifierClassElementDeclaration(s.valueDeclaration) && isStatic(s.valueDeclaration)
	}
	resolveDeclaredMembers := func(type_ InterfaceType) InterfaceTypeWithDeclaredMembers {
		if !(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredProperties {
			symbol := type_.symbol
			members := getMembersOfSymbol(symbol)
			(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredProperties = getNamedMembers(members)
			// Start with signatures at empty array in case of recursive types
			(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredCallSignatures = emptyArray
			(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredConstructSignatures = emptyArray
			(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredIndexInfos = emptyArray
			(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredCallSignatures = getSignaturesOfSymbol(members.get(InternalSymbolNameCall))
			(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredConstructSignatures = getSignaturesOfSymbol(members.get(InternalSymbolNameNew))
			(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredIndexInfos = getIndexInfosOfSymbol(symbol)
		}
		return type_ /* as InterfaceTypeWithDeclaredMembers */
	}
	/**
	 * Indicates whether a declaration name is definitely late-bindable.
	 * A declaration name is only late-bindable if:
	 * - It is a `ComputedPropertyName`.
	 * - Its expression is an `Identifier` or either a `PropertyAccessExpression` an
	 * `ElementAccessExpression` consisting only of these same three types of nodes.
	 * - The type of its expression is a string or numeric literal type, or is a `unique symbol` type.
	 */
	isLateBindableName := func(node DeclarationName) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is LateBoundName */ any {
		if !isComputedPropertyName(node) && !isElementAccessExpression(node) {
			return false
		}
		var expr Expression
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isComputedPropertyName(node):
			expr = node.expression
		default:
			expr = node.argumentExpression
		}
		return isEntityNameExpression(expr) && isTypeUsableAsPropertyName(__COND__(isComputedPropertyName(node), checkComputedPropertyName(node), checkExpressionCached(expr)))
	}
	isLateBoundName := func(name __String) bool {
		return (name /* as string */).charCodeAt(0) == CharacterCodes_ && (name /* as string */).charCodeAt(1) == CharacterCodes_ && (name /* as string */).charCodeAt(2) == CharacterCodesat
	}
	/**
	 * Indicates whether a declaration has a late-bindable dynamic name.
	 */
	hasLateBindableName := func(node Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ any {
		name := getNameOfDeclaration(node)
		return !!name && isLateBindableName(name)
	}
	/**
	 * Indicates whether a declaration has an early-bound name or a dynamic name that can be late-bound.
	 */
	hasBindableName := func(node Declaration) bool {
		return !hasDynamicName(node) || hasLateBindableName(node)
	}
	/**
	 * Indicates whether a declaration name is a dynamic name that cannot be late-bound.
	 */
	isNonBindableDynamicName := func(node DeclarationName) bool {
		return isDynamicName(node) && !isLateBindableName(node)
	}
	/**
	 * Adds a declaration to a late-bound dynamic member. This performs the same function for
	 * late-bound members that `addDeclarationToSymbol` in binder.ts performs for early-bound
	 * members.
	 */
	addDeclarationToLateBoundSymbol := func(symbol Symbol, member /* TODO(TS-TO-GO) TypeNode UnionType: LateBoundDeclaration | BinaryExpression */ any, symbolFlags SymbolFlags) {
		Debug.assert(!!(getCheckFlags(symbol) & CheckFlagsLate), "Expected a late-bound symbol.")
		symbol.flags |= symbolFlags
		getSymbolLinks(member.symbol).lateSymbol = symbol
		if !symbol.declarations {
			symbol.declarations = [] /* TODO(TS-TO-GO) inferred type BinaryExpression | LateBoundDeclaration */ any{member}
		} else if !member.symbol.isReplaceableByMethod {
			symbol.declarations.push(member)
		}
		if symbolFlags & SymbolFlagsValue {
			if !symbol.valueDeclaration || symbol.valueDeclaration.kind != member.kind {
				symbol.valueDeclaration = member
			}
		}
	}
	/**
	 * Performs late-binding of a dynamic member. This performs the same function for
	 * late-bound members that `declareSymbol` in binder.ts performs for early-bound
	 * members.
	 *
	 * If a symbol is a dynamic name from a computed property, we perform an additional "late"
	 * binding phase to attempt to resolve the name for the symbol from the type of the computed
	 * property's expression. If the type of the expression is a string-literal, numeric-literal,
	 * or unique symbol type, we can use that type as the name of the symbol.
	 *
	 * For example, given:
	 *
	 *   const x = Symbol();
	 *
	 *   interface I {
	 *     [x]: number;
	 *   }
	 *
	 * The binder gives the property `[x]: number` a special symbol with the name "__computed".
	 * In the late-binding phase we can type-check the expression `x` and see that it has a
	 * unique symbol type which we can then use as the name of the member. This allows users
	 * to define custom symbols that can be used in the members of an object type.
	 *
	 * @param parent The containing symbol for the member.
	 * @param earlySymbols The early-bound symbols of the parent.
	 * @param lateSymbols The late-bound symbols of the parent.
	 * @param decl The member to bind.
	 */
	lateBindMember := func(parent Symbol, earlySymbols *SymbolTable, lateSymbols Map[__String, TransientSymbol], decl /* TODO(TS-TO-GO) TypeNode UnionType: LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ any) Symbol {
		Debug.assert(!!decl.symbol, "The member is expected to have a symbol.")
		links := getNodeLinks(decl)
		if !links.resolvedSymbol {
			// In the event we attempt to resolve the late-bound name of this member recursively,
			// fall back to the early-bound name of this member.
			links.resolvedSymbol = decl.symbol
			var declName /* TODO(TS-TO-GO) inferred type LateBoundElementAccessExpression | LateBoundName */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isBinaryExpression(decl):
				declName = decl.left
			default:
				declName = decl.name
			}
			var type_ Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isElementAccessExpression(declName):
				type_ = checkExpressionCached(declName.argumentExpression)
			default:
				type_ = checkComputedPropertyName(declName)
			}
			if isTypeUsableAsPropertyName(type_) {
				memberName := getPropertyNameFromType(type_)
				symbolFlags := decl.symbol.flags
				// Get or add a late-bound symbol for the member. This allows us to merge late-bound accessor declarations.
				lateSymbol := lateSymbols.get(memberName)
				if !lateSymbol {
					lateSymbols.set(memberName /* TODO(TS-TO-GO) Node BinaryExpression: lateSymbol = createSymbol(SymbolFlags.None, memberName, CheckFlags.Late) */, TODO)
				}
				// Report an error if there's a symbol declaration with the same name and conflicting flags.
				earlySymbol := earlySymbols && earlySymbols.get(memberName)
				// Duplicate property declarations of classes are checked in checkClassForDuplicateDeclarations.
				if !(parent.flags & SymbolFlagsClass) && lateSymbol.flags&getExcludedSymbolFlags(symbolFlags) {
					// If we have an existing early-bound member, combine its declarations so that we can
					// report an error at each declaration.
					var declarations *[]Declaration
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case earlySymbol:
						declarations = concatenate(earlySymbol.declarations, lateSymbol.declarations)
					default:
						declarations = lateSymbol.declarations
					}
					name := !(type_.flags&TypeFlagsUniqueESSymbol) && unescapeLeadingUnderscores(memberName) || declarationNameToString(declName)
					forEach(declarations, func(declaration Declaration) Diagnostic {
						return error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Property_0_was_also_declared_here, name)
					})
					error(declName || decl, Diagnostics.Duplicate_property_0, name)
					lateSymbol = createSymbol(SymbolFlagsNone, memberName, CheckFlagsLate)
				}
				lateSymbol.links.nameType = type_
				addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags)
				if lateSymbol.parent {
					Debug.assert(lateSymbol.parent == parent, "Existing symbol parent should match new one")
				} else {
					lateSymbol.parent = parent
				}
				links.resolvedSymbol = lateSymbol
				return links.resolvedSymbol
			}
		}
		return links.resolvedSymbol
	}
	getResolvedMembersOrExportsOfSymbol := func(symbol Symbol, resolutionKind MembersOrExportsResolutionKind) Map[__String, Symbol] {
		links := getSymbolLinks(symbol)
		if !links[resolutionKind] {
			isStatic := resolutionKind == MembersOrExportsResolutionKindresolvedExports
			var earlySymbols *SymbolTable
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !isStatic:
				earlySymbols = symbol.members
			case symbol.flags & SymbolFlagsModule:
				earlySymbols = getExportsOfModuleWorker(symbol).exports
			default:
				earlySymbols = symbol.exports
			}
			// In the event we recursively resolve the members/exports of the symbol, we
			// set the initial value of resolvedMembers/resolvedExports to the early-bound
			// members/exports of the symbol.
			links[resolutionKind] = earlySymbols || emptySymbols
			// fill in any as-yet-unresolved late-bound members.
			lateSymbols := createSymbolTable() /* as Map<__String, TransientSymbol> */
			for _, decl := range symbol.declarations || emptyArray {
				members := getMembersOfDeclaration(decl)
				if members {
					for _, member := range members {
						if isStatic == hasStaticModifier(member) {
							if hasLateBindableName(member) {
								lateBindMember(symbol, earlySymbols, lateSymbols, member)
							}
						}
					}
				}
			}
			assignments := getFunctionExpressionParentSymbolOrSymbol(symbol).assignmentDeclarationMembers
			if assignments {
				decls := arrayFrom(assignments.values())
				for _, member := range decls {
					assignmentKind := getAssignmentDeclarationKind(member /* as BinaryExpression | CallExpression */)
					isInstanceMember := assignmentKind == AssignmentDeclarationKindPrototypeProperty || isBinaryExpression(member) && isPossiblyAliasedThisProperty(member, assignmentKind) || assignmentKind == AssignmentDeclarationKindObjectDefinePrototypeProperty || assignmentKind == AssignmentDeclarationKindPrototype
					// A straight `Prototype` assignment probably can never have a computed name
					if isStatic == !isInstanceMember {
						if hasLateBindableName(member) {
							lateBindMember(symbol, earlySymbols, lateSymbols, member)
						}
					}
				}
			}
			resolved := combineSymbolTables(earlySymbols, lateSymbols)
			if symbol.flags&SymbolFlagsTransient && links.cjsExportMerged && symbol.declarations {
				for _, decl := range symbol.declarations {
					original := getSymbolLinks(decl.symbol)[resolutionKind]
					if !resolved {
						resolved = original
						continue
					}
					if !original {
						continue
					}
					original.forEach(func(s Symbol, name __String) {
						existing := resolved.get(name)
						if !existing {
							resolved.set(name, s)
						} else if existing == s {
							return
						} else {
							resolved.set(name, mergeSymbol(existing, s))
						}
					})
				}
			}
			links[resolutionKind] = resolved || emptySymbols
		}
		return links[resolutionKind]
	}
	/**
	 * Gets a SymbolTable containing both the early- and late-bound members of a symbol.
	 *
	 * For a description of late-binding, see `lateBindMember`.
	 */
	getMembersOfSymbol := func(symbol Symbol) SymbolTable {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol.flags & SymbolFlagsLateBindingContainer:
			return getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKindresolvedMembers)
		default:
			return symbol.members || emptySymbols
		}
	}
	/**
	 * If a symbol is the dynamic name of the member of an object type, get the late-bound
	 * symbol of the member.
	 *
	 * For a description of late-binding, see `lateBindMember`.
	 */
	getLateBoundSymbol := func(symbol Symbol) Symbol {
		if symbol.flags&SymbolFlagsClassMember && symbol.escapedName == InternalSymbolNameComputed {
			links := getSymbolLinks(symbol)
			if !links.lateSymbol && some(symbol.declarations, hasLateBindableName) {
				// force late binding of members/exports. This will set the late-bound symbol
				parent := getMergedSymbol(symbol.parent)
				if some(symbol.declarations, hasStaticModifier) {
					getExportsOfSymbol(parent)
				} else {
					getMembersOfSymbol(parent)
				}
			}
			return links.lateSymbol || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.lateSymbol = symbol */ TODO)
		}
		return symbol
	}
	getTypeWithThisArgument := func(type_ Type, thisArgument Type, needApparentType bool) Type {
		if getObjectFlags(type_) & ObjectFlagsReference {
			target := (type_ /* as TypeReference */).target
			typeArguments := getTypeArguments(type_ /* as TypeReference */)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case length(target.typeParameters) == length(typeArguments):
				return createTypeReference(target, concatenate(typeArguments, []Type{thisArgument || target.thisType}))
			default:
				return type_
			}
		} else if type_.flags & TypeFlagsIntersection {
			types := sameMap((type_ /* as IntersectionType */).types, func(t Type) Type {
				return getTypeWithThisArgument(t, thisArgument, needApparentType)
			})
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case types != (type_ /* as IntersectionType */).types:
				return getIntersectionType(types)
			default:
				return type_
			}
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case needApparentType:
			return getApparentType(type_)
		default:
			return type_
		}
	}
	resolveObjectTypeMembers := func(type_ ObjectType, source InterfaceTypeWithDeclaredMembers, typeParameters []TypeParameter, typeArguments []Type) {
		var mapper *TypeMapper
		var members SymbolTable
		var callSignatures []Signature
		var constructSignatures []Signature
		var indexInfos []IndexInfo
		if rangeEquals(typeParameters, typeArguments, 0, typeParameters.length) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case source.symbol:
				members = getMembersOfSymbol(source.symbol)
			default:
				members = createSymbolTable(source.declaredProperties)
			}
			callSignatures = source.declaredCallSignatures
			constructSignatures = source.declaredConstructSignatures
			indexInfos = source.declaredIndexInfos
		} else {
			mapper = createTypeMapper(typeParameters, typeArguments)
			members = createInstantiatedSymbolTable(source.declaredProperties, mapper /*mappingThisOnly*/, typeParameters.length == 1)
			callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper)
			constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper)
			indexInfos = instantiateIndexInfos(source.declaredIndexInfos, mapper)
		}
		baseTypes := getBaseTypes(source)
		if baseTypes.length {
			if source.symbol && members == getMembersOfSymbol(source.symbol) {
				symbolTable := createSymbolTable(source.declaredProperties)
				// copy index signature symbol as well (for quickinfo)
				sourceIndex := getIndexSymbol(source.symbol)
				if sourceIndex {
					symbolTable.set(InternalSymbolNameIndex, sourceIndex)
				}
				members = symbolTable
			}
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			thisArgument := lastOrUndefined(typeArguments)
			for _, baseType := range baseTypes {
				var instantiatedBaseType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case thisArgument:
					instantiatedBaseType = getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument)
				default:
					instantiatedBaseType = baseType
				}
				addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType))
				callSignatures = concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKindCall))
				constructSignatures = concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKindConstruct))
				var inheritedIndexInfos []IndexInfo
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case instantiatedBaseType != anyType:
					inheritedIndexInfos = getIndexInfosOfType(instantiatedBaseType)
				default:
					inheritedIndexInfos = []IndexInfo{createIndexInfo(stringType, anyType /*isReadonly*/, false)}
				}
				indexInfos = concatenate(indexInfos, filter(inheritedIndexInfos, func(info IndexInfo) bool {
					return !findIndexInfo(indexInfos, info.keyType)
				}))
			}
		}
		setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
	}
	resolveClassOrInterfaceMembers := func(type_ InterfaceType) {
		resolveObjectTypeMembers(type_, resolveDeclaredMembers(type_), emptyArray, emptyArray)
	}
	resolveTypeReferenceMembers := func(type_ TypeReference) {
		source := resolveDeclaredMembers(type_.target)
		typeParameters := concatenate(source.typeParameters, []TypeParameter{source.thisType})
		typeArguments := getTypeArguments(type_)
		var paddedTypeArguments []Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case typeArguments.length == typeParameters.length:
			paddedTypeArguments = typeArguments
		default:
			paddedTypeArguments = concatenate(typeArguments, []TypeReference{type_})
		}
		resolveObjectTypeMembers(type_, source, typeParameters, paddedTypeArguments)
	}
	createSignature := func(declaration /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature | undefined */ any, typeParameters *[]TypeParameter, thisParameter Symbol, parameters []Symbol, resolvedReturnType Type, resolvedTypePredicate *TypePredicate, minArgumentCount number, flags SignatureFlags) Signature {
		sig := NewSignature(checker, flags)
		sig.declaration = declaration
		sig.typeParameters = typeParameters
		sig.parameters = parameters
		sig.thisParameter = thisParameter
		sig.resolvedReturnType = resolvedReturnType
		sig.resolvedTypePredicate = resolvedTypePredicate
		sig.minArgumentCount = minArgumentCount
		sig.resolvedMinArgumentCount = nil
		sig.target = nil
		sig.mapper = nil
		sig.compositeSignatures = nil
		sig.compositeKind = nil
		return sig
	}
	cloneSignature := func(sig Signature) Signature {
		result := createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters /*resolvedReturnType*/, nil /*resolvedTypePredicate*/, nil, sig.minArgumentCount, sig.flags&SignatureFlagsPropagatingFlags)
		result.target = sig.target
		result.mapper = sig.mapper
		result.compositeSignatures = sig.compositeSignatures
		result.compositeKind = sig.compositeKind
		return result
	}
	createUnionSignature := func(signature Signature, unionSignatures []Signature) Signature {
		result := cloneSignature(signature)
		result.compositeSignatures = unionSignatures
		result.compositeKind = TypeFlagsUnion
		result.target = nil
		result.mapper = nil
		return result
	}
	getOptionalCallSignature := func(signature Signature, callChainFlags SignatureFlags) Signature {
		if (signature.flags & SignatureFlagsCallChainFlags) == callChainFlags {
			return signature
		}
		if !signature.optionalCallSignatureCache {
			signature.optionalCallSignatureCache = map[any]any{ /* TODO(TS-TO-GO): was object literal */
			}
		}
		var key /* TODO(TS-TO-GO) inferred type "inner" | "outer" */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case callChainFlags == SignatureFlagsIsInnerCallChain:
			key = "inner"
		default:
			key = "outer"
		}
		return signature.optionalCallSignatureCache[key] || ( /* TODO(TS-TO-GO) Node BinaryExpression: signature.optionalCallSignatureCache[key] = createOptionalCallSignature(signature, callChainFlags) */ TODO)
	}
	createOptionalCallSignature := func(signature Signature, callChainFlags SignatureFlags) Signature {
		Debug.assert(callChainFlags == SignatureFlagsIsInnerCallChain || callChainFlags == SignatureFlagsIsOuterCallChain, "An optional call signature can either be for an inner call chain or an outer call chain, but not both.")
		result := cloneSignature(signature)
		result.flags |= callChainFlags
		return result
	}
	getExpandedParameters := func(sig Signature, skipUnionExpanding bool) [][]Symbol {
		if signatureHasRestParameter(sig) {
			restIndex := sig.parameters.length - 1
			restSymbol := sig.parameters[restIndex]
			restType := getTypeOfSymbol(restSymbol)
			if isTupleType(restType) {
				return [][]Symbol{expandSignatureParametersWithTupleMembers(restType, restIndex, restSymbol)}
			} else if !skipUnionExpanding && restType.flags&TypeFlagsUnion && every((restType /* as UnionType */).types, isTupleType) {
				return map_((restType /* as UnionType */).types, func(t Type) []Symbol {
					return expandSignatureParametersWithTupleMembers(t /* as TupleTypeReference */, restIndex, restSymbol)
				})
			}
		}
		return [][]Symbol{sig.parameters}
		expandSignatureParametersWithTupleMembers := func(restType TupleTypeReference, restIndex number, restSymbol Symbol) []Symbol {
			elementTypes := getTypeArguments(restType)
			associatedNames := getUniqAssociatedNamesFromTupleType(restType, restSymbol)
			restParams := map_(elementTypes, func(t Type, i number) TransientSymbol {
				// Lookup the label from the individual tuple passed in before falling back to the signature `rest` parameter name
				var name /* TODO(TS-TO-GO) inferred type (string & { __escapedIdentifier: void; }) | (void & { __escapedIdentifier: void; }) | InternalSymbolName */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case associatedNames && associatedNames[i]:
					name = associatedNames[i]
				default:
					name = getParameterNameAtPosition(sig, restIndex+i, restType)
				}
				flags := restType.target.elementFlags[i]
				var checkFlags /* TODO(TS-TO-GO) inferred type 0 | CheckFlags.OptionalParameter | CheckFlags.RestParameter */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case flags & ElementFlagsVariable:
					checkFlags = CheckFlagsRestParameter
				case flags & ElementFlagsOptional:
					checkFlags = CheckFlagsOptionalParameter
				default:
					checkFlags = 0
				}
				symbol := createSymbol(SymbolFlagsFunctionScopedVariable, name, checkFlags)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case flags & ElementFlagsRest:
					symbol.links.type_ = createArrayType(t)
				default:
					symbol.links.type_ = t
				}
				return symbol
			})
			return concatenate(sig.parameters.slice(0, restIndex), restParams)
		}
		getUniqAssociatedNamesFromTupleType := func(type_ TupleTypeReference, restSymbol Symbol) *[]__String {
			names := map_(type_.target.labeledElementDeclarations, func(labeledElement * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | NamedTupleMember */ any, i number) __String {
				return getTupleElementLabel(labeledElement, i, type_.target.elementFlags[i], restSymbol)
			})
			if names {
				var duplicates []number = []never{}
				uniqueNames := NewSet[__String]()
				for i := 0; i < names.length; i++ {
					name := names[i]
					if !tryAddToSet(uniqueNames, name) {
						duplicates.push(i)
					}
				}
				counters := NewMap[__String, number]()
				for _, i := range duplicates {
					counter := /* TODO(TS-TO-GO) Node BinaryExpression: counters.get(names[i]) ?? 1 */ TODO
					var name __String
					for !tryAddToSet(uniqueNames /* TODO(TS-TO-GO) Node BinaryExpression: name = `${names[i]}_${counter}` as __String */, TODO) {
						counter++
					}
					names[i] = name
					counters.set(names[i], counter+1)
				}
			}
			return names
		}
	}
	getDefaultConstructSignatures := func(classType InterfaceType) []Signature {
		baseConstructorType := getBaseConstructorTypeOfClass(classType)
		baseSignatures := getSignaturesOfType(baseConstructorType, SignatureKindConstruct)
		declaration := getClassLikeDeclarationOfSymbol(classType.symbol)
		isAbstract := !!declaration && hasSyntacticModifier(declaration, ModifierFlagsAbstract)
		if baseSignatures.length == 0 {
			return []Signature{createSignature(nil, classType.localTypeParameters /*thisParameter*/, nil, emptyArray, classType /*resolvedTypePredicate*/, nil, 0, __COND__(isAbstract, SignatureFlagsAbstract, SignatureFlagsNone))}
		}
		baseTypeNode := getBaseTypeNodeOfClass(classType)
		isJavaScript := isInJSFile(baseTypeNode)
		typeArguments := typeArgumentsFromTypeReferenceNode(baseTypeNode)
		typeArgCount := length(typeArguments)
		var result []Signature = []never{}
		for _, baseSig := range baseSignatures {
			minTypeArgumentCount := getMinTypeArgumentCount(baseSig.typeParameters)
			typeParamCount := length(baseSig.typeParameters)
			if isJavaScript || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount {
				var sig Signature
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case typeParamCount:
					sig = createSignatureInstantiation(baseSig, fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript))
				default:
					sig = cloneSignature(baseSig)
				}
				sig.typeParameters = classType.localTypeParameters
				sig.resolvedReturnType = classType
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isAbstract:
					sig.flags = sig.flags | SignatureFlagsAbstract
				default:
					sig.flags = sig.flags & ~SignatureFlagsAbstract
				}
				result.push(sig)
			}
		}
		return result
	}
	findMatchingSignature := func(signatureList []Signature, signature Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool) *Signature {
		for _, s := range signatureList {
			if compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes, __COND__(partialMatch, compareTypesSubtypeOf, compareTypesIdentical)) {
				return s
			}
		}
	}
	findMatchingSignatures := func(signatureLists [][]Signature, signature Signature, listIndex number) *[]Signature {
		if signature.typeParameters {
			// We require an exact match for generic signatures, so we only return signatures from the first
			// signature list and only if they have exact matches in the other signature lists.
			if listIndex > 0 {
				return nil
			}
			for i := 1; i < signatureLists.length; i++ {
				if !findMatchingSignature(signatureLists[i], signature /*partialMatch*/, false /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, false) {
					return nil
				}
			}
			return []Signature{signature}
		}
		var result *[]Signature
		for i := 0; i < signatureLists.length; i++ {
			// Allow matching non-generic signatures to have excess parameters (as a fallback if exact parameter match is not found) and different return types.
			// Prefer matching this types if possible.
			var match *Signature
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case i == listIndex:
				match = signature
			default:
				match = findMatchingSignature(signatureLists[i], signature /*partialMatch*/, false /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, true) || findMatchingSignature(signatureLists[i], signature /*partialMatch*/, true /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, true)
			}
			if !match {
				return nil
			}
			result = appendIfUnique(result, match)
		}
		return result
	}
	// The signatures of a union type are those signatures that are present in each of the constituent types.
	// Generic signatures must match exactly, but non-generic signatures are allowed to have extra optional
	// parameters and may differ in return types. When signatures differ in return types, the resulting return
	// type is the union of the constituent return types.
	getUnionSignatures := func(signatureLists [][]Signature) []Signature {
		var result *[]Signature
		var indexWithLengthOverOne *number
		for i := 0; i < signatureLists.length; i++ {
			if signatureLists[i].length == 0 {
				return emptyArray
			}
			if signatureLists[i].length > 1 {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case indexWithLengthOverOne == nil:
					indexWithLengthOverOne = i
				default:
					indexWithLengthOverOne = -1
				}
				// -1 is a signal there are multiple overload sets
			}
			for _, signature := range signatureLists[i] {
				// Only process signatures with parameter lists that aren't already in the result list
				if !result || !findMatchingSignature(result, signature /*partialMatch*/, false /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, true) {
					unionSignatures := findMatchingSignatures(signatureLists, signature, i)
					if unionSignatures {
						s := signature
						// Union the result types when more than one signature matches
						if unionSignatures.length > 1 {
							thisParameter := signature.thisParameter
							firstThisParameterOfUnionSignatures := forEach(unionSignatures, func(sig Signature) Symbol {
								return sig.thisParameter
							})
							if firstThisParameterOfUnionSignatures {
								thisType := getIntersectionType(mapDefined(unionSignatures, func(sig Signature) Type {
									return sig.thisParameter && getTypeOfSymbol(sig.thisParameter)
								}))
								thisParameter = createSymbolWithType(firstThisParameterOfUnionSignatures, thisType)
							}
							s = createUnionSignature(signature, unionSignatures)
							s.thisParameter = thisParameter
						}
						(result || ( /* TODO(TS-TO-GO) Node BinaryExpression: result = [] */ TODO)).push(s)
					}
				}
			}
		}
		if !length(result) && indexWithLengthOverOne != -1 {
			// No sufficiently similar signature existed to subsume all the other signatures in the union - time to see if we can make a single
			// signature that handles all over them. We only do this when there are overloads in only one constituent.
			// (Overloads are conditional in nature and having overloads in multiple constituents would necessitate making a power set of
			// signatures from the type, whose ordering would be non-obvious)
			masterList := signatureLists[__COND__(indexWithLengthOverOne != nil, indexWithLengthOverOne, 0)]
			var results *[]Signature = masterList.slice()
			for _, signatures := range signatureLists {
				if signatures != masterList {
					signature := signatures[0]
					Debug.assert(!!signature, "getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass")
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case !!signature.typeParameters && some(results, func(s Signature) bool {
						return !!s.typeParameters && !compareTypeParametersIdentical(signature.typeParameters, s.typeParameters)
					}):
						results = nil
					default:
						results = map_(results, func(sig Signature) Signature {
							return combineSignaturesOfUnionMembers(sig, signature)
						})
					}
					if !results {
						break
					}
				}
			}
			result = results
		}
		return result || emptyArray
	}
	compareTypeParametersIdentical := func(sourceParams *[]TypeParameter, targetParams *[]TypeParameter) bool {
		if length(sourceParams) != length(targetParams) {
			return false
		}
		if !sourceParams || !targetParams {
			return true
		}
		mapper := createTypeMapper(targetParams, sourceParams)
		for i := 0; i < sourceParams.length; i++ {
			source := sourceParams[i]
			target := targetParams[i]
			if source == target {
				continue
			}
			// We instantiate the target type parameter constraints into the source types so we can recognize `<T, U extends T>` as the same as `<A, B extends A>`
			if !isTypeIdenticalTo(getConstraintFromTypeParameter(source) || unknownType, instantiateType(getConstraintFromTypeParameter(target) || unknownType, mapper)) {
				return false
			}
			// We don't compare defaults - we just use the type parameter defaults from the first signature that seems to match.
			// It might make sense to combine these defaults in the future, but doing so intelligently requires knowing
			// if the parameter is used covariantly or contravariantly (so we intersect if it's used like a parameter or union if used like a return type)
			// and, since it's just an inference _default_, just picking one arbitrarily works OK.
		}
		return true
	}
	combineUnionThisParam := func(left Symbol, right Symbol, mapper *TypeMapper) Symbol {
		if !left || !right {
			return left || right
		}
		// A signature `this` type might be a read or a write position... It's very possible that it should be invariant
		// and we should refuse to merge signatures if there are `this` types and they do not match. However, so as to be
		// permissive when calling, for now, we'll intersect the `this` types just like we do for param types in union signatures.
		thisType := getIntersectionType([]Type{getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)})
		return createSymbolWithType(left, thisType)
	}
	combineUnionParameters := func(left Signature, right Signature, mapper *TypeMapper) []Symbol {
		leftCount := getParameterCount(left)
		rightCount := getParameterCount(right)
		var longest Signature
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case leftCount >= rightCount:
			longest = left
		default:
			longest = right
		}
		var shorter Signature
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case longest == left:
			shorter = right
		default:
			shorter = left
		}
		var longestCount number
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case longest == left:
			longestCount = leftCount
		default:
			longestCount = rightCount
		}
		eitherHasEffectiveRest := hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right)
		needsExtraRestElement := eitherHasEffectiveRest && !hasEffectiveRestParameter(longest)
		params := NewArray[Symbol](longestCount + (__COND__(needsExtraRestElement, 1, 0)))
		for i := 0; i < longestCount; i++ {
			longestParamType := tryGetTypeAtPosition(longest, i)
			if longest == right {
				longestParamType = instantiateType(longestParamType, mapper)
			}
			shorterParamType := tryGetTypeAtPosition(shorter, i) || unknownType
			if shorter == right {
				shorterParamType = instantiateType(shorterParamType, mapper)
			}
			unionParamType := getIntersectionType([]Type{longestParamType, shorterParamType})
			isRestParam := eitherHasEffectiveRest && !needsExtraRestElement && i == (longestCount-1)
			isOptional := i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter)
			var leftName *__String
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case i >= leftCount:
				leftName = nil
			default:
				leftName = getParameterNameAtPosition(left, i)
			}
			var rightName *__String
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case i >= rightCount:
				rightName = nil
			default:
				rightName = getParameterNameAtPosition(right, i)
			}
			var paramName *__String
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case leftName == rightName:
				paramName = leftName
			case !leftName:
				paramName = rightName
			case !rightName:
				paramName = leftName
			default:
				paramName = nil
			}
			paramSymbol := createSymbol(SymbolFlagsFunctionScopedVariable|(__COND__(isOptional && !isRestParam, SymbolFlagsOptional, 0)), paramName || __TEMPLATE__("arg", i) /* as __String */, __COND__(isRestParam, CheckFlagsRestParameter, __COND__(isOptional, CheckFlagsOptionalParameter, 0)))
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isRestParam:
				paramSymbol.links.type_ = createArrayType(unionParamType)
			default:
				paramSymbol.links.type_ = unionParamType
			}
			params[i] = paramSymbol
		}
		if needsExtraRestElement {
			restParamSymbol := createSymbol(SymbolFlagsFunctionScopedVariable, "args" /* as __String */, CheckFlagsRestParameter)
			restParamSymbol.links.type_ = createArrayType(getTypeAtPosition(shorter, longestCount))
			if shorter == right {
				restParamSymbol.links.type_ = instantiateType(restParamSymbol.links.type_, mapper)
			}
			params[longestCount] = restParamSymbol
		}
		return params
	}
	combineSignaturesOfUnionMembers := func(left Signature, right Signature) Signature {
		typeParams := left.typeParameters || right.typeParameters
		var paramMapper *TypeMapper
		if left.typeParameters && right.typeParameters {
			paramMapper = createTypeMapper(right.typeParameters, left.typeParameters)
			// We just use the type parameter defaults from the first signature
		}
		declaration := left.declaration
		params := combineUnionParameters(left, right, paramMapper)
		thisParam := combineUnionThisParam(left.thisParameter, right.thisParameter, paramMapper)
		minArgCount := Math.max(left.minArgumentCount, right.minArgumentCount)
		result := createSignature(declaration, typeParams, thisParam, params, nil, nil, minArgCount, (left.flags|right.flags)&SignatureFlagsPropagatingFlags)
		result.compositeKind = TypeFlagsUnion
		result.compositeSignatures = concatenate(left.compositeKind != TypeFlagsIntersection && left.compositeSignatures || []Signature{left}, []Signature{right})
		if paramMapper {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case left.compositeKind != TypeFlagsIntersection && left.mapper && left.compositeSignatures:
				result.mapper = combineTypeMappers(left.mapper, paramMapper)
			default:
				result.mapper = paramMapper
			}
		} else if left.compositeKind != TypeFlagsIntersection && left.mapper && left.compositeSignatures {
			result.mapper = left.mapper
		}
		return result
	}
	getUnionIndexInfos := func(types []Type) []IndexInfo {
		sourceInfos := getIndexInfosOfType(types[0])
		if sourceInfos {
			result := []never{}
			for _, info := range sourceInfos {
				indexType := info.keyType
				if every(types, func(t Type) bool {
					return !!getIndexInfoOfType(t, indexType)
				}) {
					result.push(createIndexInfo(indexType, getUnionType(map_(types, func(t Type) Type {
						return getIndexTypeOfType(t, indexType)
					})), some(types, func(t Type) bool {
						return getIndexInfoOfType(t, indexType).isReadonly
					})))
				}
			}
			return result
		}
		return emptyArray
	}
	resolveUnionTypeMembers := func(type_ UnionType) {
		// The members and properties collections are empty for union types. To get all properties of a union
		// type use getPropertiesOfType (only the language service uses this).
		callSignatures := getUnionSignatures(map_(type_.types, func(t Type) []Signature {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case t == globalFunctionType:
				return []Signature{unknownSignature}
			default:
				return getSignaturesOfType(t, SignatureKindCall)
			}
		}))
		constructSignatures := getUnionSignatures(map_(type_.types, func(t Type) []Signature {
			return getSignaturesOfType(t, SignatureKindConstruct)
		}))
		indexInfos := getUnionIndexInfos(type_.types)
		setStructuredTypeMembers(type_, emptySymbols, callSignatures, constructSignatures, indexInfos)
	}
	/* TODO(TS-TO-GO): function intersectTypes(type1: Type, type2: Type): Type; */
	/* TODO(TS-TO-GO): function intersectTypes(type1: Type | undefined, type2: Type | undefined): Type | undefined; */
	intersectTypes := func(type1 Type, type2 Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case !type1:
			return type2
		case !type2:
			return type1
		default:
			return getIntersectionType([]Type{type1, type2})
		}
	}
	findMixins := func(types []Type) []bool {
		constructorTypeCount := countWhere(types, func(t Type) bool {
			return getSignaturesOfType(t, SignatureKindConstruct).length > 0
		})
		mixinFlags := map_(types, isMixinConstructorType)
		if constructorTypeCount > 0 && constructorTypeCount == countWhere(mixinFlags, func(b bool) bool {
			return b
		}) {
			firstMixinIndex := mixinFlags.indexOf(true)
			mixinFlags[firstMixinIndex] = false
		}
		return mixinFlags
	}
	includeMixinType := func(type_ Type, types []Type, mixinFlags []bool, index number) Type {
		var mixedTypes []Type = []never{}
		for i := 0; i < types.length; i++ {
			if i == index {
				mixedTypes.push(type_)
			} else if mixinFlags[i] {
				mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], SignatureKindConstruct)[0]))
			}
		}
		return getIntersectionType(mixedTypes)
	}
	resolveIntersectionTypeMembers := func(type_ IntersectionType) {
		// The members and properties collections are empty for intersection types. To get all properties of an
		// intersection type use getPropertiesOfType (only the language service uses this).
		var callSignatures *[]Signature
		var constructSignatures *[]Signature
		var indexInfos *[]IndexInfo
		types := type_.types
		mixinFlags := findMixins(types)
		mixinCount := countWhere(mixinFlags, func(b bool) bool {
			return b
		})
		for i := 0; i < types.length; i++ {
			t := type_.types[i]
			// When an intersection type contains mixin constructor types, the construct signatures from
			// those types are discarded and their return types are mixed into the return types of all
			// other construct signatures in the intersection type. For example, the intersection type
			// '{ new(...args: any[]) => A } & { new(s: string) => B }' has a single construct signature
			// 'new(s: string) => A & B'.
			if !mixinFlags[i] {
				signatures := getSignaturesOfType(t, SignatureKindConstruct)
				if signatures.length && mixinCount > 0 {
					signatures = map_(signatures, func(s Signature) Signature {
						clone := cloneSignature(s)
						clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i)
						return clone
					})
				}
				constructSignatures = appendSignatures(constructSignatures, signatures)
			}
			callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, SignatureKindCall))
			indexInfos = reduceLeft(getIndexInfosOfType(t), func(infos *[]IndexInfo, newInfo IndexInfo) []IndexInfo {
				return appendIndexInfo(infos, newInfo /*union*/, false)
			}, indexInfos)
		}
		setStructuredTypeMembers(type_, emptySymbols, callSignatures || emptyArray, constructSignatures || emptyArray, indexInfos || emptyArray)
	}
	appendSignatures := func(signatures *[]Signature, newSignatures []Signature) *[]Signature {
		for _, sig := range newSignatures {
			if !signatures || every(signatures, func(s Signature) bool {
				return !compareSignaturesIdentical(s, sig /*partialMatch*/, false /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, false, compareTypesIdentical)
			}) {
				signatures = append(signatures, sig)
			}
		}
		return signatures
	}
	appendIndexInfo := func(indexInfos *[]IndexInfo, newInfo IndexInfo, union bool) []IndexInfo {
		if indexInfos {
			for i := 0; i < indexInfos.length; i++ {
				info := indexInfos[i]
				if info.keyType == newInfo.keyType {
					indexInfos[i] = createIndexInfo(info.keyType, __COND__(union, getUnionType([]Type{info.type_, newInfo.type_}), getIntersectionType([]Type{info.type_, newInfo.type_})), __COND__(union, info.isReadonly || newInfo.isReadonly, info.isReadonly && newInfo.isReadonly))
					return indexInfos
				}
			}
		}
		return append(indexInfos, newInfo)
	}
	/**
	 * Converts an AnonymousType to a ResolvedType.
	 */
	resolveAnonymousTypeMembers := func(type_ AnonymousType) {
		if type_.target {
			setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
			members := createInstantiatedSymbolTable(getPropertiesOfObjectType(type_.target), type_.mapper /*mappingThisOnly*/, false)
			callSignatures := instantiateSignatures(getSignaturesOfType(type_.target, SignatureKindCall), type_.mapper)
			constructSignatures := instantiateSignatures(getSignaturesOfType(type_.target, SignatureKindConstruct), type_.mapper)
			indexInfos := instantiateIndexInfos(getIndexInfosOfType(type_.target), type_.mapper)
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			return
		}
		symbol := getMergedSymbol(type_.symbol)
		if symbol.flags & SymbolFlagsTypeLiteral {
			setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
			members := getMembersOfSymbol(symbol)
			callSignatures := getSignaturesOfSymbol(members.get(InternalSymbolNameCall))
			constructSignatures := getSignaturesOfSymbol(members.get(InternalSymbolNameNew))
			indexInfos := getIndexInfosOfSymbol(symbol)
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			return
		}
		// Combinations of function, class, enum and module
		members := getExportsOfSymbol(symbol)
		var indexInfos *[]IndexInfo
		if symbol == globalThisSymbol {
			varsOnly := NewMap[__String, Symbol]()
			members.forEach(func(p Symbol) {
				if !(p.flags & SymbolFlagsBlockScoped) && !(p.flags&SymbolFlagsValueModule && p.declarations. /* TODO(TS-TO-GO): was ? */ length && every(p.declarations, isAmbientModule)) {
					varsOnly.set(p.escapedName, p)
				}
			})
			members = varsOnly
		}
		var baseConstructorIndexInfo *IndexInfo
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, emptyArray)
		if symbol.flags & SymbolFlagsClass {
			classType := getDeclaredTypeOfClassOrInterface(symbol)
			baseConstructorType := getBaseConstructorTypeOfClass(classType)
			if baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsTypeVariable) {
				members = createSymbolTable(getNamedOrIndexSignatureMembers(members))
				addInheritedMembers(members, getPropertiesOfType(baseConstructorType))
			} else if baseConstructorType == anyType {
				baseConstructorIndexInfo = createIndexInfo(stringType, anyType /*isReadonly*/, false)
			}
		}
		indexSymbol := getIndexSymbolFromSymbolTable(members)
		if indexSymbol {
			indexInfos = getIndexInfosOfIndexSymbol(indexSymbol)
		} else {
			if baseConstructorIndexInfo {
				indexInfos = append(indexInfos, baseConstructorIndexInfo)
			}
			if symbol.flags&SymbolFlagsEnum && (getDeclaredTypeOfSymbol(symbol).flags&TypeFlagsEnum || some(type_.properties, func(prop Symbol) bool {
				return !!(getTypeOfSymbol(prop).flags & TypeFlagsNumberLike)
			})) {
				indexInfos = append(indexInfos, enumNumberIndexInfo)
			}
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos || emptyArray)
		// We resolve the members before computing the signatures because a signature may use
		// typeof with a qualified name expression that circularly references the type we are
		// in the process of resolving (see issue #6072). The temporarily empty signature list
		// will never be observed because a qualified name can't reference signatures.
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod) {
			type_.callSignatures = getSignaturesOfSymbol(symbol)
		}
		// And likewise for construct signatures for classes
		if symbol.flags & SymbolFlagsClass {
			classType := getDeclaredTypeOfClassOrInterface(symbol)
			var constructSignatures []Signature
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case symbol.members:
				constructSignatures = getSignaturesOfSymbol(symbol.members.get(InternalSymbolNameConstructor))
			default:
				constructSignatures = emptyArray
			}
			if symbol.flags & SymbolFlagsFunction {
				constructSignatures = addRange(constructSignatures.slice(), mapDefined(type_.callSignatures, func(sig Signature) *Signature {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isJSConstructor(sig.declaration):
						return createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType /*resolvedTypePredicate*/, nil, sig.minArgumentCount, sig.flags&SignatureFlagsPropagatingFlags)
					default:
						return nil
					}
				}))
			}
			if !constructSignatures.length {
				constructSignatures = getDefaultConstructSignatures(classType)
			}
			type_.constructSignatures = constructSignatures
		}
	}
	type ReplaceableIndexedAccessType /* TODO(TS-TO-GO) TypeNode IntersectionType: IndexedAccessType & { objectType: TypeParameter; indexType: TypeParameter; } */ any
	replaceIndexedAccess := func(instantiable Type, type_ ReplaceableIndexedAccessType, replacement Type) Type {
		// map type.indexType to 0
		// map type.objectType to `[TReplacement]`
		// thus making the indexed access `[TReplacement][0]` or `TReplacement`
		return instantiateType(instantiable, createTypeMapper([] /* TODO(TS-TO-GO) inferred type Type & TypeParameter */ any{type_.indexType, type_.objectType}, []Type{getNumberLiteralType(0), createTupleType([]Type{replacement})}))
	}
	// If the original mapped type had an intersection constraint we extract its components,
	// and we make an attempt to do so even if the intersection has been reduced to a union.
	// This entire process allows us to possibly retrieve the filtering type literals.
	// e.g. { [K in keyof U & ("a" | "b") ] } -> "a" | "b"
	getLimitedConstraint := func(type_ ReverseMappedType) Type {
		constraint := getConstraintTypeFromMappedType(type_.mappedType)
		if !(constraint.flags&TypeFlagsUnion || constraint.flags&TypeFlagsIntersection) {
			return
		}
		var origin Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case (constraint.flags & TypeFlagsUnion):
			origin = (constraint /* as UnionType */).origin
		default:
			origin = (constraint /* as IntersectionType */)
		}
		if !origin || !(origin.flags & TypeFlagsIntersection) {
			return
		}
		limitedConstraint := getIntersectionType((origin /* as IntersectionType */).types.filter(func(t Type) bool {
			return t != type_.constraintType
		}))
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case limitedConstraint != neverType:
			return limitedConstraint
		default:
			return nil
		}
	}
	resolveReverseMappedTypeMembers := func(type_ ReverseMappedType) {
		indexInfo := getIndexInfoOfType(type_.source, stringType)
		modifiers := getMappedTypeModifiers(type_.mappedType)
		var readonlyMask bool
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case modifiers & MappedTypeModifiersIncludeReadonly:
			readonlyMask = false
		default:
			readonlyMask = true
		}
		var optionalMask /* TODO(TS-TO-GO) inferred type 0 | SymbolFlags.Optional */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case modifiers & MappedTypeModifiersIncludeOptional:
			optionalMask = 0
		default:
			optionalMask = SymbolFlagsOptional
		}
		var indexInfos []IndexInfo
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case indexInfo:
			indexInfos = []IndexInfo{createIndexInfo(stringType, inferReverseMappedType(indexInfo.type_, type_.mappedType, type_.constraintType) || unknownType, readonlyMask && indexInfo.isReadonly)}
		default:
			indexInfos = emptyArray
		}
		members := createSymbolTable()
		limitedConstraint := getLimitedConstraint(type_)
		for _, prop := range getPropertiesOfType(type_.source) {
			// In case of a reverse mapped type with an intersection constraint, if we were able to
			// extract the filtering type literals we skip those properties that are not assignable to them,
			// because the extra properties wouldn't get through the application of the mapped type anyway
			if limitedConstraint {
				propertyNameType := getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique)
				if !isTypeAssignableTo(propertyNameType, limitedConstraint) {
					continue
				}
			}
			checkFlags := CheckFlagsReverseMapped | (__COND__(readonlyMask && isReadonlySymbol(prop), CheckFlagsReadonly, 0))
			inferredProp := createSymbol(SymbolFlagsProperty|prop.flags&optionalMask, prop.escapedName, checkFlags) /* as ReverseMappedSymbol */
			inferredProp.declarations = prop.declarations
			inferredProp.links.nameType = getSymbolLinks(prop).nameType
			inferredProp.links.propertyType = getTypeOfSymbol(prop)
			if type_.constraintType.type_.flags&TypeFlagsIndexedAccess && (type_.constraintType.type_ /* as IndexedAccessType */).objectType.flags&TypeFlagsTypeParameter && (type_.constraintType.type_ /* as IndexedAccessType */).indexType.flags&TypeFlagsTypeParameter {
				// A reverse mapping of `{[K in keyof T[K_1]]: T[K_1]}` is the same as that of `{[K in keyof T]: T}`, since all we care about is
				// inferring to the "type parameter" (or indexed access) shared by the constraint and template. So, to reduce the number of
				// type identities produced, we simplify such indexed access occurences
				newTypeParam := (type_.constraintType.type_ /* as IndexedAccessType */).objectType
				newMappedType := replaceIndexedAccess(type_.mappedType, type_.constraintType.type_ /* as ReplaceableIndexedAccessType */, newTypeParam)
				inferredProp.links.mappedType = newMappedType                  /* as MappedType */
				inferredProp.links.constraintType = getIndexType(newTypeParam) /* as IndexType */
			} else {
				inferredProp.links.mappedType = type_.mappedType
				inferredProp.links.constraintType = type_.constraintType
			}
			members.set(prop.escapedName, inferredProp)
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos)
	}
	// Return the lower bound of the key type in a mapped type. Intuitively, the lower
	// bound includes those keys that are known to always be present, for example because
	// because of constraints on type parameters (e.g. 'keyof T' for a constrained T).
	getLowerBoundOfKeyType := func(type_ Type) Type {
		if type_.flags & TypeFlagsIndex {
			t := getApparentType((type_ /* as IndexType */).type_)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isGenericTupleType(t):
				return getKnownKeysOfTupleType(t)
			default:
				return getIndexType(t)
			}
		}
		if type_.flags & TypeFlagsConditional {
			if (type_ /* as ConditionalType */).root.isDistributive {
				checkType := (type_ /* as ConditionalType */).checkType
				constraint := getLowerBoundOfKeyType(checkType)
				if constraint != checkType {
					return getConditionalTypeInstantiation(type_ /* as ConditionalType */, prependTypeMapping((type_ /* as ConditionalType */).root.checkType, constraint, (type_ /* as ConditionalType */).mapper) /*forConstraint*/, false)
				}
			}
			return type_
		}
		if type_.flags & TypeFlagsUnion {
			return mapType(type_ /* as UnionType */, getLowerBoundOfKeyType /*noReductions*/, true)
		}
		if type_.flags & TypeFlagsIntersection {
			// Similarly to getTypeFromIntersectionTypeNode, we preserve the special string & {}, number & {},
			// and bigint & {} intersections that are used to prevent subtype reduction in union types.
			types := (type_ /* as IntersectionType */).types
			if types.length == 2 && !!(types[0].flags & (TypeFlagsString | TypeFlagsNumber | TypeFlagsBigInt)) && types[1] == emptyTypeLiteralType {
				return type_
			}
			return getIntersectionType(sameMap((type_ /* as UnionType */).types, getLowerBoundOfKeyType))
		}
		return type_
	}
	getIsLateCheckFlag := func(s Symbol) CheckFlags {
		return getCheckFlags(s) & CheckFlagsLate
	}
	forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType := func(type_ Type, include TypeFlags, stringsOnly bool, cb func(keyType Type)) {
		for _, prop := range getPropertiesOfType(type_) {
			cb(getLiteralTypeFromProperty(prop, include))
		}
		if type_.flags & TypeFlagsAny {
			cb(stringType)
		} else {
			for _, info := range getIndexInfosOfType(type_) {
				if !stringsOnly || info.keyType.flags&(TypeFlagsString|TypeFlagsTemplateLiteral) {
					cb(info.keyType)
				}
			}
		}
	}
	/** Resolve the members of a mapped type { [P in K]: T } */
	resolveMappedTypeMembers := func(type_ MappedType) {
		var members SymbolTable = createSymbolTable()
		var indexInfos *[]IndexInfo
		// Resolve upfront such that recursive references see an empty object type.
		setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
		// In { [P in K]: T }, we refer to P as the type parameter type, K as the constraint type,
		// and T as the template type.
		typeParameter := getTypeParameterFromMappedType(type_)
		constraintType := getConstraintTypeFromMappedType(type_)
		mappedType := (type_.target /* as MappedType */) || type_
		nameType := getNameTypeFromMappedType(mappedType)
		shouldLinkPropDeclarations := getMappedTypeNameTypeKind(mappedType) != MappedTypeNameTypeKindRemapping
		templateType := getTemplateTypeFromMappedType(mappedType)
		modifiersType := getApparentType(getModifiersTypeFromMappedType(type_))
		// The 'T' in 'keyof T'
		templateModifiers := getMappedTypeModifiers(type_)
		include := TypeFlagsStringOrNumberLiteralOrUnique
		if isMappedTypeWithKeyofConstraintDeclaration(type_) {
			// We have a { [P in keyof T]: X }
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, include /*stringsOnly*/, false, addMemberForKeyType)
		} else {
			forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType)
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos || emptyArray)
		addMemberForKeyType := func(keyType Type) {
			var propNameType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case nameType:
				propNameType = instantiateType(nameType, appendTypeMapping(type_.mapper, typeParameter, keyType))
			default:
				propNameType = keyType
			}
			forEachType(propNameType, func(t Type) {
				return addMemberForKeyTypeWorker(keyType, t)
			})
		}
		addMemberForKeyTypeWorker := func(keyType Type, propNameType Type) {
			// If the current iteration type constituent is a string literal type, create a property.
			// Otherwise, for type string create a string index signature.
			if isTypeUsableAsPropertyName(propNameType) {
				propName := getPropertyNameFromType(propNameType)
				// String enum members from separate enums with identical values
				// are distinct types with the same property name. Make the resulting
				// property symbol's name type be the union of those enum member types.
				existingProp := members.get(propName) /* as MappedSymbol | undefined */
				if existingProp {
					existingProp.links.nameType = getUnionType([]Type{existingProp.links.nameType, propNameType})
					existingProp.links.keyType = getUnionType([]Type{existingProp.links.keyType, keyType})
				} else {
					var modifiersProp Symbol
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isTypeUsableAsPropertyName(keyType):
						modifiersProp = getPropertyOfType(modifiersType, getPropertyNameFromType(keyType))
					default:
						modifiersProp = nil
					}
					isOptional := !!(templateModifiers&MappedTypeModifiersIncludeOptional || !(templateModifiers&MappedTypeModifiersExcludeOptional) && modifiersProp && modifiersProp.flags&SymbolFlagsOptional)
					isReadonly := !!(templateModifiers&MappedTypeModifiersIncludeReadonly || !(templateModifiers&MappedTypeModifiersExcludeReadonly) && modifiersProp && isReadonlySymbol(modifiersProp))
					stripOptional := strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags&SymbolFlagsOptional
					var lateFlag CheckFlags
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case modifiersProp:
						lateFlag = getIsLateCheckFlag(modifiersProp)
					default:
						lateFlag = 0
					}
					prop := createSymbol(SymbolFlagsProperty|(__COND__(isOptional, SymbolFlagsOptional, 0)), propName, lateFlag|CheckFlagsMapped|(__COND__(isReadonly, CheckFlagsReadonly, 0))|(__COND__(stripOptional, CheckFlagsStripOptional, 0))) /* as MappedSymbol */
					prop.links.mappedType = type_
					prop.links.nameType = propNameType
					prop.links.keyType = keyType
					if modifiersProp {
						prop.links.syntheticOrigin = modifiersProp
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case shouldLinkPropDeclarations:
							prop.declarations = modifiersProp.declarations
						default:
							prop.declarations = nil
						}
					}
					members.set(propName, prop)
				}
			} else if isValidIndexKeyType(propNameType) || propNameType.flags&(TypeFlagsAny|TypeFlagsEnum) {
				var indexKeyType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case propNameType.flags & (TypeFlagsAny | TypeFlagsString):
					indexKeyType = stringType
				case propNameType.flags & (TypeFlagsNumber | TypeFlagsEnum):
					indexKeyType = numberType
				default:
					indexKeyType = propNameType
				}
				propType := instantiateType(templateType, appendTypeMapping(type_.mapper, typeParameter, keyType))
				modifiersIndexInfo := getApplicableIndexInfo(modifiersType, propNameType)
				isReadonly := !!(templateModifiers&MappedTypeModifiersIncludeReadonly || !(templateModifiers&MappedTypeModifiersExcludeReadonly) && modifiersIndexInfo. /* TODO(TS-TO-GO): was ? */ isReadonly)
				indexInfo := createIndexInfo(indexKeyType, propType, isReadonly)
				indexInfos = appendIndexInfo(indexInfos, indexInfo /*union*/, true)
			}
		}
	}
	getTypeOfMappedSymbol := func(symbol MappedSymbol) Type {
		if !symbol.links.type_ {
			mappedType := symbol.links.mappedType
			if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
				mappedType.containsError = true
				return errorType
			}
			templateType := getTemplateTypeFromMappedType(mappedType.target /* as MappedType */ || mappedType)
			mapper := appendTypeMapping(mappedType.mapper, getTypeParameterFromMappedType(mappedType), symbol.links.keyType)
			propType := instantiateType(templateType, mapper)
			// When creating an optional property in strictNullChecks mode, if 'undefined' isn't assignable to the
			// type, we include 'undefined' in the type. Similarly, when creating a non-optional property in strictNullChecks
			// mode, if the underlying property is optional we remove 'undefined' from the type.
			var type_ Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks && symbol.flags&SymbolFlagsOptional && !maybeTypeOfKind(propType, TypeFlagsUndefined|TypeFlagsVoid):
				type_ = getOptionalType(propType /*isProperty*/, true)
			case symbol.links.checkFlags & CheckFlagsStripOptional:
				type_ = removeMissingOrUndefinedType(propType)
			default:
				type_ = propType
			}
			if !popTypeResolution() {
				error(currentNode, Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1, symbolToString(symbol), typeToString(mappedType))
				type_ = errorType
			}
			/* TODO(TS-TO-GO) Node BinaryExpression: symbol.links.type ??= type */ TODO
		}
		return symbol.links.type_
	}
	getTypeParameterFromMappedType := func(type_ MappedType) TypeParameter {
		return type_.typeParameter || ( /* TODO(TS-TO-GO) Node BinaryExpression: type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(type.declaration.typeParameter)) */ TODO)
	}
	getConstraintTypeFromMappedType := func(type_ MappedType) Type {
		return type_.constraintType || ( /* TODO(TS-TO-GO) Node BinaryExpression: type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType */ TODO)
	}
	getNameTypeFromMappedType := func(type_ MappedType) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.declaration.nameType:
			return type_.nameType || ( /* TODO(TS-TO-GO) Node BinaryExpression: type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper) */ TODO)
		default:
			return nil
		}
	}
	getTemplateTypeFromMappedType := func(type_ MappedType) Type {
		return type_.templateType || ( /* TODO(TS-TO-GO) Node BinaryExpression: type.templateType = type.declaration.type ? instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), /*isProperty* / true, !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional)), type.mapper) : errorType */ TODO)
	}
	getConstraintDeclarationForMappedType := func(type_ MappedType) *TypeNode {
		return getEffectiveConstraintOfTypeParameter(type_.declaration.typeParameter)
	}
	isMappedTypeWithKeyofConstraintDeclaration := func(type_ MappedType) bool {
		constraintDeclaration := getConstraintDeclarationForMappedType(type_)
		// TODO: GH#18217
		return constraintDeclaration.kind == SyntaxKindTypeOperator && (constraintDeclaration /* as TypeOperatorNode */).operator == SyntaxKindKeyOfKeyword
	}
	getModifiersTypeFromMappedType := func(type_ MappedType) Type {
		if !type_.modifiersType {
			if isMappedTypeWithKeyofConstraintDeclaration(type_) {
				// If the constraint declaration is a 'keyof T' node, the modifiers type is T. We check
				// AST nodes here because, when T is a non-generic type, the logic below eagerly resolves
				// 'keyof T' to a literal union type and we can't recover T from that type.
				type_.modifiersType = instantiateType(getTypeFromTypeNode((getConstraintDeclarationForMappedType(type_) /* as TypeOperatorNode */).type_), type_.mapper)
			} else {
				// Otherwise, get the declared constraint type, and if the constraint type is a type parameter,
				// get the constraint of that type parameter. If the resulting type is an indexed type 'keyof T',
				// the modifiers type is T. Otherwise, the modifiers type is unknown.
				declaredType := getTypeFromMappedTypeNode(type_.declaration) /* as MappedType */
				constraint := getConstraintTypeFromMappedType(declaredType)
				var extendedConstraint Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case constraint && constraint.flags&TypeFlagsTypeParameter:
					extendedConstraint = getConstraintOfTypeParameter(constraint /* as TypeParameter */)
				default:
					extendedConstraint = constraint
				}
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case extendedConstraint && extendedConstraint.flags&TypeFlagsIndex:
					type_.modifiersType = instantiateType((extendedConstraint /* as IndexType */).type_, type_.mapper)
				default:
					type_.modifiersType = unknownType
				}
			}
		}
		return type_.modifiersType
	}
	getMappedTypeModifiers := func(type_ MappedType) MappedTypeModifiers {
		declaration := type_.declaration
		return (__COND__(declaration.readonlyToken, __COND__(declaration.readonlyToken.kind == SyntaxKindMinusToken, MappedTypeModifiersExcludeReadonly, MappedTypeModifiersIncludeReadonly), 0)) | (__COND__(declaration.questionToken, __COND__(declaration.questionToken.kind == SyntaxKindMinusToken, MappedTypeModifiersExcludeOptional, MappedTypeModifiersIncludeOptional), 0))
	}
	// Return -1, 0, or 1, where -1 means optionality is stripped (i.e. -?), 0 means optionality is unchanged, and 1 means
	// optionality is added (i.e. +?).
	getMappedTypeOptionality := func(type_ MappedType) number {
		modifiers := getMappedTypeModifiers(type_)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case modifiers & MappedTypeModifiersExcludeOptional:
			return -1
		case modifiers & MappedTypeModifiersIncludeOptional:
			return 1
		default:
			return 0
		}
	}
	// Return -1, 0, or 1, for stripped, unchanged, or added optionality respectively. When a homomorphic mapped type doesn't
	// modify optionality, recursively consult the optionality of the type being mapped over to see if it strips or adds optionality.
	// For intersections, return -1 or 1 when all constituents strip or add optionality, otherwise return 0.
	getCombinedMappedTypeOptionality := func(type_ Type) number {
		if getObjectFlags(type_) & ObjectFlagsMapped {
			return getMappedTypeOptionality(type_ /* as MappedType */) || getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(type_ /* as MappedType */))
		}
		if type_.flags & TypeFlagsIntersection {
			optionality := getCombinedMappedTypeOptionality((type_ /* as IntersectionType */).types[0])
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case every((type_ /* as IntersectionType */).types, func(t Type, i number) bool {
				return i == 0 || getCombinedMappedTypeOptionality(t) == optionality
			}):
				return optionality
			default:
				return 0
			}
		}
		return 0
	}
	isPartialMappedType := func(type_ Type) bool {
		return !!(getObjectFlags(type_)&ObjectFlagsMapped && getMappedTypeModifiers(type_ /* as MappedType */)&MappedTypeModifiersIncludeOptional)
	}
	isGenericMappedType := func(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is MappedType */ any {
		if getObjectFlags(type_) & ObjectFlagsMapped {
			constraint := getConstraintTypeFromMappedType(type_ /* as MappedType */)
			if isGenericIndexType(constraint) {
				return true
			}
			// A mapped type is generic if the 'as' clause references generic types other than the iteration type.
			// To determine this, we substitute the constraint type (that we now know isn't generic) for the iteration
			// type and check whether the resulting type is generic.
			nameType := getNameTypeFromMappedType(type_ /* as MappedType */)
			if nameType && isGenericIndexType(instantiateType(nameType, makeUnaryTypeMapper(getTypeParameterFromMappedType(type_ /* as MappedType */), constraint))) {
				return true
			}
		}
		return false
	}
	getMappedTypeNameTypeKind := func(type_ MappedType) MappedTypeNameTypeKind {
		nameType := getNameTypeFromMappedType(type_)
		if !nameType {
			return MappedTypeNameTypeKindNone
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isTypeAssignableTo(nameType, getTypeParameterFromMappedType(type_)):
			return MappedTypeNameTypeKindFiltering
		default:
			return MappedTypeNameTypeKindRemapping
		}
	}
	resolveStructuredTypeMembers := func(type_ StructuredType) ResolvedType {
		if !(type_ /* as ResolvedType */).members {
			if type_.flags & TypeFlagsObject {
				if (type_ /* as ObjectType */).objectFlags & ObjectFlagsReference {
					resolveTypeReferenceMembers(type_ /* as TypeReference */)
				} else if (type_ /* as ObjectType */).objectFlags & ObjectFlagsClassOrInterface {
					resolveClassOrInterfaceMembers(type_ /* as InterfaceType */)
				} else if (type_ /* as ReverseMappedType */).objectFlags & ObjectFlagsReverseMapped {
					resolveReverseMappedTypeMembers(type_ /* as ReverseMappedType */)
				} else if (type_ /* as ObjectType */).objectFlags & ObjectFlagsAnonymous {
					resolveAnonymousTypeMembers(type_ /* as AnonymousType */)
				} else if (type_ /* as MappedType */).objectFlags & ObjectFlagsMapped {
					resolveMappedTypeMembers(type_ /* as MappedType */)
				} else {
					Debug.fail("Unhandled object type " + Debug.formatObjectFlags(type_.objectFlags))
				}
			} else if type_.flags & TypeFlagsUnion {
				resolveUnionTypeMembers(type_ /* as UnionType */)
			} else if type_.flags & TypeFlagsIntersection {
				resolveIntersectionTypeMembers(type_ /* as IntersectionType */)
			} else {
				Debug.fail("Unhandled type " + Debug.formatTypeFlags(type_.flags))
			}
		}
		return type_ /* as ResolvedType */
	}
	/** Return properties of an object type or an empty array for other types */
	getPropertiesOfObjectType := func(type_ Type) []Symbol {
		if type_.flags & TypeFlagsObject {
			return resolveStructuredTypeMembers(type_ /* as ObjectType */).properties
		}
		return emptyArray
	}
	/** If the given type is an object type and that type has a property by the given name,
	 * return the symbol for that property. Otherwise return undefined.
	 */
	getPropertyOfObjectType := func(type_ Type, name __String) Symbol {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_ /* as ObjectType */)
			symbol := resolved.members.get(name)
			if symbol && symbolIsValue(symbol) {
				return symbol
			}
		}
	}
	getPropertiesOfUnionOrIntersectionType := func(type_ UnionOrIntersectionType) []Symbol {
		if !type_.resolvedProperties {
			members := createSymbolTable()
			for _, current := range type_.types {
				for _, prop := range getPropertiesOfType(current) {
					if !members.has(prop.escapedName) {
						combinedProp := getPropertyOfUnionOrIntersectionType(type_, prop.escapedName /*skipObjectFunctionPropertyAugment*/, !!(type_.flags & TypeFlagsIntersection))
						if combinedProp {
							members.set(prop.escapedName, combinedProp)
						}
					}
				}
				// The properties of a union type are those that are present in all constituent types, so
				// we only need to check the properties of the first type without index signature
				if type_.flags&TypeFlagsUnion && getIndexInfosOfType(current).length == 0 {
					break
				}
			}
			type_.resolvedProperties = getNamedMembers(members)
		}
		return type_.resolvedProperties
	}
	getPropertiesOfType := func(type_ Type) []Symbol {
		type_ = getReducedApparentType(type_)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnionOrIntersection:
			return getPropertiesOfUnionOrIntersectionType(type_ /* as UnionType */)
		default:
			return getPropertiesOfObjectType(type_)
		}
	}
	forEachPropertyOfType := func(type_ Type, action func(symbol Symbol, escapedName __String)) {
		type_ = getReducedApparentType(type_)
		if type_.flags & TypeFlagsStructuredType {
			resolveStructuredTypeMembers(type_ /* as StructuredType */).members.forEach(func(symbol Symbol, escapedName __String) {
				if isNamedMember(symbol, escapedName) {
					action(symbol, escapedName)
				}
			})
		}
	}
	isTypeInvalidDueToUnionDiscriminant := func(contextualType Type, obj /* TODO(TS-TO-GO) TypeNode UnionType: ObjectLiteralExpression | JsxAttributes */ any) bool {
		list := obj.properties /* as NodeArray<ObjectLiteralElementLike | JsxAttributeLike> */
		return list.some(func(property /* TODO(TS-TO-GO) inferred type ObjectLiteralElementLike | JsxAttributeLike */ any) bool {
			nameType := property.name && (__COND__(isJsxNamespacedName(property.name), getStringLiteralType(getTextOfJsxAttributeName(property.name)), getLiteralTypeFromPropertyName(property.name)))
			var name *__String
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case nameType && isTypeUsableAsPropertyName(nameType):
				name = getPropertyNameFromType(nameType)
			default:
				name = nil
			}
			var expected Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case name == nil:
				expected = nil
			default:
				expected = getTypeOfPropertyOfType(contextualType, name)
			}
			return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected)
		})
	}
	getAllPossiblePropertiesOfTypes := func(types []Type) []Symbol {
		unionType := getUnionType(types)
		if !(unionType.flags & TypeFlagsUnion) {
			return getAugmentedPropertiesOfType(unionType)
		}
		props := createSymbolTable()
		for _, memberType := range types {
			for _, TODO_IDENTIFIER := range getAugmentedPropertiesOfType(memberType) {
				if !props.has(escapedName) {
					prop := createUnionOrIntersectionProperty(unionType /* as UnionType */, escapedName)
					// May be undefined if the property is private
					if prop {
						props.set(escapedName, prop)
					}
				}
			}
		}
		return arrayFrom(props.values())
	}
	getConstraintOfType := func(type_ /* TODO(TS-TO-GO) TypeNode UnionType: InstantiableType | UnionOrIntersectionType */ any) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsTypeParameter:
			return getConstraintOfTypeParameter(type_ /* as TypeParameter */)
		case type_.flags & TypeFlagsIndexedAccess:
			return getConstraintOfIndexedAccess(type_ /* as IndexedAccessType */)
		case type_.flags & TypeFlagsConditional:
			return getConstraintOfConditionalType(type_ /* as ConditionalType */)
		default:
			return getBaseConstraintOfType(type_)
		}
	}
	getConstraintOfTypeParameter := func(typeParameter TypeParameter) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case hasNonCircularBaseConstraint(typeParameter):
			return getConstraintFromTypeParameter(typeParameter)
		default:
			return nil
		}
	}
	isConstMappedType := func(type_ MappedType, depth number) bool {
		typeVariable := getHomomorphicTypeVariable(type_)
		return !!typeVariable && isConstTypeVariable(typeVariable, depth)
	}
	isConstTypeVariable := func(type_ Type, depth number /*  = 0 */) bool {
		return depth < 5 && !!(type_ && (type_.flags&TypeFlagsTypeParameter && some((type_ /* as TypeParameter */).symbol. /* TODO(TS-TO-GO): was ? */ declarations, func(d Declaration) bool {
			return hasSyntacticModifier(d, ModifierFlagsConst)
		}) || type_.flags&TypeFlagsUnionOrIntersection && some((type_ /* as UnionOrIntersectionType */).types, func(t Type) bool {
			return isConstTypeVariable(t, depth)
		}) || type_.flags&TypeFlagsIndexedAccess && isConstTypeVariable((type_ /* as IndexedAccessType */).objectType, depth+1) || type_.flags&TypeFlagsConditional && isConstTypeVariable(getConstraintOfConditionalType(type_ /* as ConditionalType */), depth+1) || type_.flags&TypeFlagsSubstitution && isConstTypeVariable((type_ /* as SubstitutionType */).baseType, depth) || getObjectFlags(type_)&ObjectFlagsMapped && isConstMappedType(type_ /* as MappedType */, depth) || isGenericTupleType(type_) && findIndex(getElementTypes(type_), func(t Type, i number) bool {
			return !!(type_.target.elementFlags[i] & ElementFlagsVariadic) && isConstTypeVariable(t, depth)
		}) >= 0))
	}
	getConstraintOfIndexedAccess := func(type_ IndexedAccessType) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case hasNonCircularBaseConstraint(type_):
			return getConstraintFromIndexedAccess(type_)
		default:
			return nil
		}
	}
	getSimplifiedTypeOrConstraint := func(type_ Type) Type {
		simplified := getSimplifiedType(type_ /*writing*/, false)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case simplified != type_:
			return simplified
		default:
			return getConstraintOfType(type_)
		}
	}
	getConstraintFromIndexedAccess := func(type_ IndexedAccessType) Type {
		if isMappedTypeGenericIndexedAccess(type_) {
			// For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
			// we substitute an instantiation of E where P is replaced with X.
			return substituteIndexedMappedType(type_.objectType /* as MappedType */, type_.indexType)
		}
		indexConstraint := getSimplifiedTypeOrConstraint(type_.indexType)
		if indexConstraint && indexConstraint != type_.indexType {
			indexedAccess := getIndexedAccessTypeOrUndefined(type_.objectType, indexConstraint, type_.accessFlags)
			if indexedAccess {
				return indexedAccess
			}
		}
		objectConstraint := getSimplifiedTypeOrConstraint(type_.objectType)
		if objectConstraint && objectConstraint != type_.objectType {
			return getIndexedAccessTypeOrUndefined(objectConstraint, type_.indexType, type_.accessFlags)
		}
		return nil
	}
	getDefaultConstraintOfConditionalType := func(type_ ConditionalType) Type {
		if !type_.resolvedDefaultConstraint {
			// An `any` branch of a conditional type would normally be viral - specifically, without special handling here,
			// a conditional type with a single branch of type `any` would be assignable to anything, since it's constraint would simplify to
			// just `any`. This result is _usually_ unwanted - so instead here we elide an `any` branch from the constraint type,
			// in effect treating `any` like `never` rather than `unknown` in this location.
			trueConstraint := getInferredTrueTypeFromConditionalType(type_)
			falseConstraint := getFalseTypeFromConditionalType(type_)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isTypeAny(trueConstraint):
				type_.resolvedDefaultConstraint = falseConstraint
			case isTypeAny(falseConstraint):
				type_.resolvedDefaultConstraint = trueConstraint
			default:
				type_.resolvedDefaultConstraint = getUnionType([]Type{trueConstraint, falseConstraint})
			}
		}
		return type_.resolvedDefaultConstraint
	}
	getConstraintOfDistributiveConditionalType := func(type_ ConditionalType) Type {
		if type_.resolvedConstraintOfDistributive != nil {
			return type_.resolvedConstraintOfDistributive || nil
		}
		// Check if we have a conditional type of the form 'T extends U ? X : Y', where T is a constrained
		// type parameter. If so, create an instantiation of the conditional type where T is replaced
		// with its constraint. We do this because if the constraint is a union type it will be distributed
		// over the conditional type and possibly reduced. For example, 'T extends undefined ? never : T'
		// removes 'undefined' from T.
		// We skip returning a distributive constraint for a restrictive instantiation of a conditional type
		// as the constraint for all type params (check type included) have been replace with `unknown`, which
		// is going to produce even more false positive/negative results than the distribute constraint already does.
		// Please note: the distributive constraint is a kludge for emulating what a negated type could to do filter
		// a union - once negated types exist and are applied to the conditional false branch, this "constraint"
		// likely doesn't need to exist.
		if type_.root.isDistributive && type_.restrictiveInstantiation != type_ {
			simplified := getSimplifiedType(type_.checkType /*writing*/, false)
			var constraint Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case simplified == type_.checkType:
				constraint = getConstraintOfType(simplified)
			default:
				constraint = simplified
			}
			if constraint && constraint != type_.checkType {
				instantiated := getConditionalTypeInstantiation(type_, prependTypeMapping(type_.root.checkType, constraint, type_.mapper) /*forConstraint*/, true)
				if !(instantiated.flags & TypeFlagsNever) {
					type_.resolvedConstraintOfDistributive = instantiated
					return instantiated
				}
			}
		}
		type_.resolvedConstraintOfDistributive = false
		return nil
	}
	getConstraintFromConditionalType := func(type_ ConditionalType) Type {
		return getConstraintOfDistributiveConditionalType(type_) || getDefaultConstraintOfConditionalType(type_)
	}
	getConstraintOfConditionalType := func(type_ ConditionalType) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case hasNonCircularBaseConstraint(type_):
			return getConstraintFromConditionalType(type_)
		default:
			return nil
		}
	}
	getEffectiveConstraintOfIntersection := func(types []Type, targetIsUnion bool) Type {
		var constraints *[]Type
		hasDisjointDomainType := false
		for _, t := range types {
			if t.flags & TypeFlagsInstantiable {
				// We keep following constraints as long as we have an instantiable type that is known
				// not to be circular or infinite (hence we stop on index access types).
				constraint := getConstraintOfType(t)
				for constraint && constraint.flags&(TypeFlagsTypeParameter|TypeFlagsIndex|TypeFlagsConditional) {
					constraint = getConstraintOfType(constraint)
				}
				if constraint {
					constraints = append(constraints, constraint)
					if targetIsUnion {
						constraints = append(constraints, t)
					}
				}
			} else if t.flags&TypeFlagsDisjointDomains || isEmptyAnonymousObjectType(t) {
				hasDisjointDomainType = true
			}
		}
		// If the target is a union type or if we are intersecting with types belonging to one of the
		// disjoint domains, we may end up producing a constraint that hasn't been examined before.
		if constraints && (targetIsUnion || hasDisjointDomainType) {
			if hasDisjointDomainType {
				// We add any types belong to one of the disjoint domains because they might cause the final
				// intersection operation to reduce the union constraints.
				for _, t := range types {
					if t.flags&TypeFlagsDisjointDomains || isEmptyAnonymousObjectType(t) {
						constraints = append(constraints, t)
					}
				}
			}
			// The source types were normalized; ensure the result is normalized too.
			return getNormalizedType(getIntersectionType(constraints, IntersectionFlagsNoConstraintReduction) /*writing*/, false)
		}
		return nil
	}
	getBaseConstraintOfType := func(type_ Type) Type {
		if type_.flags&(TypeFlagsInstantiableNonPrimitive|TypeFlagsUnionOrIntersection|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || isGenericTupleType(type_) {
			constraint := getResolvedBaseConstraint(type_ /* as InstantiableType | UnionOrIntersectionType */)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case constraint != noConstraintType && constraint != circularConstraintType:
				return constraint
			default:
				return nil
			}
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsIndex:
			return stringNumberSymbolType
		default:
			return nil
		}
	}
	/**
	 * This is similar to `getBaseConstraintOfType` except it returns the input type if there's no base constraint, instead of `undefined`
	 * It also doesn't map indexes to `string`, as where this is used this would be unneeded (and likely undesirable)
	 */
	getBaseConstraintOrType := func(type_ Type) Type {
		return getBaseConstraintOfType(type_) || type_
	}
	hasNonCircularBaseConstraint := func(type_ InstantiableType) bool {
		return getResolvedBaseConstraint(type_) != circularConstraintType
	}
	/**
	 * Return the resolved base constraint of a type variable. The noConstraintType singleton is returned if the
	 * type variable has no constraint, and the circularConstraintType singleton is returned if the constraint
	 * circularly references the type variable.
	 */
	getResolvedBaseConstraint := func(type_ /* TODO(TS-TO-GO) TypeNode UnionType: InstantiableType | UnionOrIntersectionType */ any) Type {
		if type_.resolvedBaseConstraint {
			return type_.resolvedBaseConstraint
		}
		var stack []any = []never{}
		type_.resolvedBaseConstraint = getImmediateBaseConstraint(type_)
		return type_.resolvedBaseConstraint
		getImmediateBaseConstraint := func(t Type) Type {
			if !t.immediateBaseConstraint {
				if !pushTypeResolution(t, TypeSystemPropertyNameImmediateBaseConstraint) {
					return circularConstraintType
				}
				var result TODO
				// We always explore at least 10 levels of nested constraints. Thereafter, we continue to explore
				// up to 50 levels of nested constraints provided there are no "deeply nested" types on the stack
				// (i.e. no types for which five instantiations have been recorded on the stack). If we reach 50
				// levels of nesting, we are presumably exploring a repeating pattern with a long cycle that hasn't
				// yet triggered the deeply nested limiter. We have no test cases that actually get to 50 levels of
				// nesting, so it is effectively just a safety stop.
				identity := getRecursionIdentity(t)
				if stack.length < 10 || stack.length < 50 && !contains(stack, identity) {
					stack.push(identity)
					result = computeBaseConstraint(getSimplifiedType(t /*writing*/, false))
					stack.pop()
				}
				if !popTypeResolution() {
					if t.flags & TypeFlagsTypeParameter {
						errorNode := getConstraintDeclaration(t /* as TypeParameter */)
						if errorNode {
							diagnostic := error(errorNode, Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(t))
							if currentNode && !isNodeDescendantOf(errorNode, currentNode) && !isNodeDescendantOf(currentNode, errorNode) {
								addRelatedInfo(diagnostic, createDiagnosticForNode(currentNode, Diagnostics.Circularity_originates_in_type_at_this_location))
							}
						}
					}
					result = circularConstraintType
				}
				/* TODO(TS-TO-GO) Node BinaryExpression: t.immediateBaseConstraint ??= result || noConstraintType */ TODO
			}
			return t.immediateBaseConstraint
		}
		getBaseConstraint := func(t Type) Type {
			c := getImmediateBaseConstraint(t)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case c != noConstraintType && c != circularConstraintType:
				return c
			default:
				return nil
			}
		}
		computeBaseConstraint := func(t Type) Type {
			if t.flags & TypeFlagsTypeParameter {
				constraint := getConstraintFromTypeParameter(t /* as TypeParameter */)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case (t /* as TypeParameter */).isThisType || !constraint:
					return constraint
				default:
					return getBaseConstraint(constraint)
				}
			}
			if t.flags & TypeFlagsUnionOrIntersection {
				types := (t /* as UnionOrIntersectionType */).types
				var baseTypes []Type = []never{}
				different := false
				for _, type_ := range types {
					baseType := getBaseConstraint(type_)
					if baseType {
						if baseType != type_ {
							different = true
						}
						baseTypes.push(baseType)
					} else {
						different = true
					}
				}
				if !different {
					return t
				}
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case t.flags&TypeFlagsUnion && baseTypes.length == types.length:
					return getUnionType(baseTypes)
				case t.flags&TypeFlagsIntersection && baseTypes.length:
					return getIntersectionType(baseTypes)
				default:
					return nil
				}
			}
			if t.flags & TypeFlagsIndex {
				return stringNumberSymbolType
			}
			if t.flags & TypeFlagsTemplateLiteral {
				types := (t /* as TemplateLiteralType */).types
				constraints := mapDefined(types, getBaseConstraint)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case constraints.length == types.length:
					return getTemplateLiteralType((t /* as TemplateLiteralType */).texts, constraints)
				default:
					return stringType
				}
			}
			if t.flags & TypeFlagsStringMapping {
				constraint := getBaseConstraint((t /* as StringMappingType */).type_)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case constraint && constraint != (t /* as StringMappingType */).type_:
					return getStringMappingType((t /* as StringMappingType */).symbol, constraint)
				default:
					return stringType
				}
			}
			if t.flags & TypeFlagsIndexedAccess {
				if isMappedTypeGenericIndexedAccess(t) {
					// For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
					// we substitute an instantiation of E where P is replaced with X.
					return getBaseConstraint(substituteIndexedMappedType((t /* as IndexedAccessType */).objectType /* as MappedType */, (t /* as IndexedAccessType */).indexType))
				}
				baseObjectType := getBaseConstraint((t /* as IndexedAccessType */).objectType)
				baseIndexType := getBaseConstraint((t /* as IndexedAccessType */).indexType)
				baseIndexedAccess := baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, (t /* as IndexedAccessType */).accessFlags)
				return baseIndexedAccess && getBaseConstraint(baseIndexedAccess)
			}
			if t.flags & TypeFlagsConditional {
				constraint := getConstraintFromConditionalType(t /* as ConditionalType */)
				return constraint && getBaseConstraint(constraint)
			}
			if t.flags & TypeFlagsSubstitution {
				return getBaseConstraint(getSubstitutionIntersection(t /* as SubstitutionType */))
			}
			if isGenericTupleType(t) {
				// We substitute constraints for variadic elements only when the constraints are array types or
				// non-variadic tuple types as we want to avoid further (possibly unbounded) recursion.
				newElements := map_(getElementTypes(t), func(v Type, i number) Type {
					constraint := v.flags&TypeFlagsTypeParameter && t.target.elementFlags[i]&ElementFlagsVariadic && getBaseConstraint(v) || v
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case constraint != v && everyType(constraint, func(c Type) bool {
						return isArrayOrTupleType(c) && !isGenericTupleType(c)
					}):
						return constraint
					default:
						return v
					}
				})
				return createTupleType(newElements, t.target.elementFlags, t.target.readonly, t.target.labeledElementDeclarations)
			}
			return t
		}
	}
	getApparentTypeOfIntersectionType := func(type_ IntersectionType, thisArgument Type) Type {
		if type_ == thisArgument {
			return type_.resolvedApparentType || ( /* TODO(TS-TO-GO) Node BinaryExpression: type.resolvedApparentType = getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true) */ TODO)
		}
		key := __TEMPLATE__("I", getTypeId(type_), ",", getTypeId(thisArgument))
		return /* TODO(TS-TO-GO) Node BinaryExpression: getCachedType(key) ?? setCachedType(key, getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true)) */ TODO
	}
	getResolvedTypeParameterDefault := func(typeParameter TypeParameter) Type {
		if !typeParameter.default_ {
			if typeParameter.target {
				targetDefault := getResolvedTypeParameterDefault(typeParameter.target)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case targetDefault:
					typeParameter.default_ = instantiateType(targetDefault, typeParameter.mapper)
				default:
					typeParameter.default_ = noConstraintType
				}
			} else {
				// To block recursion, set the initial value to the resolvingDefaultType.
				typeParameter.default_ = resolvingDefaultType
				defaultDeclaration := typeParameter.symbol && forEach(typeParameter.symbol.declarations, func(decl Declaration) * /* TODO(TS-TO-GO) inferred type false | TypeNode */ any {
					return isTypeParameterDeclaration(decl) && decl.default_
				})
				var defaultType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case defaultDeclaration:
					defaultType = getTypeFromTypeNode(defaultDeclaration)
				default:
					defaultType = noConstraintType
				}
				if typeParameter.default_ == resolvingDefaultType {
					// If we have not been called recursively, set the correct default type.
					typeParameter.default_ = defaultType
				}
			}
		} else if typeParameter.default_ == resolvingDefaultType {
			// If we are called recursively for this type parameter, mark the default as circular.
			typeParameter.default_ = circularConstraintType
		}
		return typeParameter.default_
	}
	/**
	 * Gets the default type for a type parameter.
	 *
	 * If the type parameter is the result of an instantiation, this gets the instantiated
	 * default type of its target. If the type parameter has no default type or the default is
	 * circular, `undefined` is returned.
	 */
	getDefaultFromTypeParameter := func(typeParameter TypeParameter) Type {
		defaultType := getResolvedTypeParameterDefault(typeParameter)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case defaultType != noConstraintType && defaultType != circularConstraintType:
			return defaultType
		default:
			return nil
		}
	}
	hasNonCircularTypeParameterDefault := func(typeParameter TypeParameter) bool {
		return getResolvedTypeParameterDefault(typeParameter) != circularConstraintType
	}
	/**
	 * Indicates whether the declaration of a typeParameter has a default type.
	 */
	hasTypeParameterDefault := func(typeParameter TypeParameter) bool {
		return !!(typeParameter.symbol && forEach(typeParameter.symbol.declarations, func(decl Declaration) * /* TODO(TS-TO-GO) inferred type false | TypeNode */ any {
			return isTypeParameterDeclaration(decl) && decl.default_
		}))
	}
	getApparentTypeOfMappedType := func(type_ MappedType) Type {
		return type_.resolvedApparentType || ( /* TODO(TS-TO-GO) Node BinaryExpression: type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type) */ TODO)
	}
	getResolvedApparentTypeOfMappedType := func(type_ MappedType) Type {
		target := ( /* TODO(TS-TO-GO) Node BinaryExpression: type.target ?? type */ TODO) /* as MappedType */
		typeVariable := getHomomorphicTypeVariable(target)
		if typeVariable && !target.declaration.nameType {
			// We have a homomorphic mapped type or an instantiation of a homomorphic mapped type, i.e. a type
			// of the form { [P in keyof T]: X }. Obtain the modifiers type (the T of the keyof T), and if it is
			// another generic mapped type, recursively obtain its apparent type. Otherwise, obtain its base
			// constraint. Then, if every constituent of the base constraint is an array or tuple type, apply
			// this mapped type to the base constraint. It is safe to recurse when the modifiers type is a
			// mapped type because we protect again circular constraints in getTypeFromMappedTypeNode.
			modifiersType := getModifiersTypeFromMappedType(type_)
			var baseConstraint Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isGenericMappedType(modifiersType):
				baseConstraint = getApparentTypeOfMappedType(modifiersType)
			default:
				baseConstraint = getBaseConstraintOfType(modifiersType)
			}
			if baseConstraint && everyType(baseConstraint, func(t Type) bool {
				return isArrayOrTupleType(t) || isArrayOrTupleOrIntersection(t)
			}) {
				return instantiateType(target, prependTypeMapping(typeVariable, baseConstraint, type_.mapper))
			}
		}
		return type_
	}
	isArrayOrTupleOrIntersection := func(type_ Type) bool {
		return !!(type_.flags & TypeFlagsIntersection) && every((type_ /* as IntersectionType */).types, isArrayOrTupleType)
	}
	isMappedTypeGenericIndexedAccess := func(type_ Type) bool {
		var objectType TODO
		return !!(type_.flags&TypeFlagsIndexedAccess && getObjectFlags( /* TODO(TS-TO-GO) Node BinaryExpression: objectType = (type as IndexedAccessType).objectType */ TODO)&ObjectFlagsMapped && !isGenericMappedType(objectType) && isGenericIndexType((type_ /* as IndexedAccessType */).indexType) && !(getMappedTypeModifiers(objectType /* as MappedType */) & MappedTypeModifiersExcludeOptional) && !(objectType /* as MappedType */).declaration.nameType)
	}
	/**
	 * For a type parameter, return the base constraint of the type parameter. For the string, number,
	 * boolean, and symbol primitive types, return the corresponding object types. Otherwise return the
	 * type itself.
	 */
	getApparentType := func(type_ Type) Type {
		var t Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsInstantiable:
			t = getBaseConstraintOfType(type_) || unknownType
		default:
			t = type_
		}
		objectFlags := getObjectFlags(t)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case objectFlags & ObjectFlagsMapped:
			return getApparentTypeOfMappedType(t /* as MappedType */)
		case objectFlags&ObjectFlagsReference && t != type_:
			return getTypeWithThisArgument(t, type_)
		case t.flags & TypeFlagsIntersection:
			return getApparentTypeOfIntersectionType(t /* as IntersectionType */, type_)
		case t.flags & TypeFlagsStringLike:
			return globalStringType
		case t.flags & TypeFlagsNumberLike:
			return globalNumberType
		case t.flags & TypeFlagsBigIntLike:
			return getGlobalBigIntType()
		case t.flags & TypeFlagsBooleanLike:
			return globalBooleanType
		case t.flags & TypeFlagsESSymbolLike:
			return getGlobalESSymbolType()
		case t.flags & TypeFlagsNonPrimitive:
			return emptyObjectType
		case t.flags & TypeFlagsIndex:
			return stringNumberSymbolType
		case t.flags&TypeFlagsUnknown && !strictNullChecks:
			return emptyObjectType
		default:
			return t
		}
	}
	getReducedApparentType := func(type_ Type) Type {
		// Since getApparentType may return a non-reduced union or intersection type, we need to perform
		// type reduction both before and after obtaining the apparent type. For example, given a type parameter
		// 'T extends A | B', the type 'T & X' becomes 'A & X | B & X' after obtaining the apparent type, and
		// that type may need further reduction to remove empty intersections.
		return getReducedType(getApparentType(getReducedType(type_)))
	}
	createUnionOrIntersectionProperty := func(containingType UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) Symbol {
		var singleProp Symbol
		var propSet *Map[SymbolId, Symbol]
		var indexTypes *[]Type
		isUnion := containingType.flags & TypeFlagsUnion
		// Flags we want to propagate to the result if they exist in all source symbols
		var optionalFlag *SymbolFlags
		syntheticFlag := CheckFlagsSyntheticMethod
		var checkFlags number
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isUnion:
			checkFlags = 0
		default:
			checkFlags = CheckFlagsReadonly
		}
		mergedInstantiations := false
		for _, current := range containingType.types {
			type_ := getApparentType(current)
			if !(isErrorType(type_) || type_.flags&TypeFlagsNever) {
				prop := getPropertyOfType(type_, name, skipObjectFunctionPropertyAugment)
				var modifiers /* TODO(TS-TO-GO) inferred type 0 | ModifierFlags */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case prop:
					modifiers = getDeclarationModifierFlagsFromSymbol(prop)
				default:
					modifiers = 0
				}
				if prop {
					if prop.flags & SymbolFlagsClassMember {
						/* TODO(TS-TO-GO) Node BinaryExpression: optionalFlag ??= isUnion ? SymbolFlags.None : SymbolFlags.Optional */ TODO
						if isUnion {
							optionalFlag |= prop.flags & SymbolFlagsOptional
						} else {
							optionalFlag &= prop.flags
						}
					}
					if !singleProp {
						singleProp = prop
					} else if prop != singleProp {
						isInstantiation := (getTargetSymbol(prop) || prop) == (getTargetSymbol(singleProp) || singleProp)
						// If the symbols are instances of one another with identical types - consider the symbols
						// equivalent and just use the first one, which thus allows us to avoid eliding private
						// members when intersecting a (this-)instantiations of a class with its raw base or another instance
						if isInstantiation && compareProperties(singleProp, prop, func(a Type, b Type) /* TODO(TS-TO-GO) inferred type Ternary.False | Ternary.True */ any {
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case a == b:
								return TernaryTrue
							default:
								return TernaryFalse
							}
						}) == TernaryTrue {
							// If we merged instantiations of a generic type, we replicate the symbol parent resetting behavior we used
							// to do when we recorded multiple distinct symbols so that we still get, eg, `Array<T>.length` printed
							// back and not `Array<string>.length` when we're looking at a `.length` access on a `string[] | number[]`
							mergedInstantiations = !!singleProp.parent && !!length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent))
						} else {
							if !propSet {
								propSet = NewMap[SymbolId, Symbol]()
								propSet.set(getSymbolId(singleProp), singleProp)
							}
							id := getSymbolId(prop)
							if !propSet.has(id) {
								propSet.set(id, prop)
							}
						}
					}
					if isUnion && isReadonlySymbol(prop) {
						checkFlags |= CheckFlagsReadonly
					} else if !isUnion && !isReadonlySymbol(prop) {
						checkFlags &= ~CheckFlagsReadonly
					}
					checkFlags |= (__COND__(!(modifiers & ModifierFlagsNonPublicAccessibilityModifier), CheckFlagsContainsPublic, 0)) | (__COND__(modifiers&ModifierFlagsProtected, CheckFlagsContainsProtected, 0)) | (__COND__(modifiers&ModifierFlagsPrivate, CheckFlagsContainsPrivate, 0)) | (__COND__(modifiers&ModifierFlagsStatic, CheckFlagsContainsStatic, 0))
					if !isPrototypeProperty(prop) {
						syntheticFlag = CheckFlagsSyntheticProperty
					}
				} else if isUnion {
					indexInfo := !isLateBoundName(name) && getApplicableIndexInfoForName(type_, name)
					if indexInfo {
						checkFlags |= CheckFlagsWritePartial | (__COND__(indexInfo.isReadonly, CheckFlagsReadonly, 0))
						indexTypes = append(indexTypes, __COND__(isTupleType(type_), getRestTypeOfTupleType(type_) || undefinedType, indexInfo.type_))
					} else if isObjectLiteralType(type_) && !(getObjectFlags(type_) & ObjectFlagsContainsSpread) {
						checkFlags |= CheckFlagsWritePartial
						indexTypes = append(indexTypes, undefinedType)
					} else {
						checkFlags |= CheckFlagsReadPartial
					}
				}
			}
		}
		if !singleProp || isUnion && (propSet || checkFlags&CheckFlagsPartial) && checkFlags&(CheckFlagsContainsPrivate|CheckFlagsContainsProtected) && !(propSet && getCommonDeclarationsOfSymbols(propSet.values())) {
			// No property was found, or, in a union, a property has a private or protected declaration in one
			// constituent, but is missing or has a different declaration in another constituent.
			return nil
		}
		if !propSet && !(checkFlags & CheckFlagsReadPartial) && !indexTypes {
			if mergedInstantiations {
				// No symbol from a union/intersection should have a `.parent` set (since unions/intersections don't act as symbol parents)
				// Unless that parent is "reconstituted" from the "first value declaration" on the symbol (which is likely different than its instantiated parent!)
				// They also have a `.containingType` set, which affects some services endpoints behavior, like `getRootSymbol`
				links := tryCast(singleProp, isTransientSymbol). /* TODO(TS-TO-GO): was ? */ links
				clone := createSymbolWithType(singleProp, links. /* TODO(TS-TO-GO): was ? */ type_)
				clone.parent = singleProp.valueDeclaration. /* TODO(TS-TO-GO): was ? */ symbol. /* TODO(TS-TO-GO): was ? */ parent
				clone.links.containingType = containingType
				clone.links.mapper = links. /* TODO(TS-TO-GO): was ? */ mapper
				clone.links.writeType = getWriteTypeOfSymbol(singleProp)
				return clone
			} else {
				return singleProp
			}
		}
		var props []Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case propSet:
			props = arrayFrom(propSet.values())
		default:
			props = []Symbol{singleProp}
		}
		var declarations *[]Declaration
		var firstType Type
		var nameType Type
		var propTypes []Type = []never{}
		var writeTypes *[]Type
		var firstValueDeclaration Declaration
		hasNonUniformValueDeclaration := false
		for _, prop := range props {
			if !firstValueDeclaration {
				firstValueDeclaration = prop.valueDeclaration
			} else if prop.valueDeclaration && prop.valueDeclaration != firstValueDeclaration {
				hasNonUniformValueDeclaration = true
			}
			declarations = addRange(declarations, prop.declarations)
			type_ := getTypeOfSymbol(prop)
			if !firstType {
				firstType = type_
				nameType = getSymbolLinks(prop).nameType
			}
			writeType := getWriteTypeOfSymbol(prop)
			if writeTypes || writeType != type_ {
				writeTypes = append(__COND__(!writeTypes, propTypes.slice(), writeTypes), writeType)
			}
			if type_ != firstType {
				checkFlags |= CheckFlagsHasNonUniformType
			}
			if isLiteralType(type_) || isPatternLiteralType(type_) {
				checkFlags |= CheckFlagsHasLiteralType
			}
			if type_.flags&TypeFlagsNever && type_ != uniqueLiteralType {
				checkFlags |= CheckFlagsHasNeverType
			}
			propTypes.push(type_)
		}
		addRange(propTypes, indexTypes)
		result := createSymbol(SymbolFlagsProperty|( /* TODO(TS-TO-GO) Node BinaryExpression: optionalFlag ?? 0 */ TODO), name, syntheticFlag|checkFlags)
		result.links.containingType = containingType
		if !hasNonUniformValueDeclaration && firstValueDeclaration {
			result.valueDeclaration = firstValueDeclaration
			// Inherit information about parent type.
			if firstValueDeclaration.symbol.parent {
				result.parent = firstValueDeclaration.symbol.parent
			}
		}
		result.declarations = declarations
		result.links.nameType = nameType
		if propTypes.length > 2 {
			// When `propTypes` has the potential to explode in size when normalized, defer normalization until absolutely needed
			result.links.checkFlags |= CheckFlagsDeferredType
			result.links.deferralParent = containingType
			result.links.deferralConstituents = propTypes
			result.links.deferralWriteConstituents = writeTypes
		} else {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isUnion:
				result.links.type_ = getUnionType(propTypes)
			default:
				result.links.type_ = getIntersectionType(propTypes)
			}
			if writeTypes {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isUnion:
					result.links.writeType = getUnionType(writeTypes)
				default:
					result.links.writeType = getIntersectionType(writeTypes)
				}
			}
		}
		return result
	}
	// Return the symbol for a given property in a union or intersection type, or undefined if the property
	// does not exist in any constituent type. Note that the returned property may only be present in some
	// constituents, in which case the isPartial flag is set when the containing type is union type. We need
	// these partial properties when identifying discriminant properties, but otherwise they are filtered out
	// and do not appear to be present in the union type.
	getUnionOrIntersectionProperty := func(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) Symbol {
		var property Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case skipObjectFunctionPropertyAugment:
			property = type_.propertyCacheWithoutObjectFunctionPropertyAugment. /* TODO(TS-TO-GO): was ? */ get(name)
		default:
			property = type_.propertyCache. /* TODO(TS-TO-GO): was ? */ get(name)
		}
		if !property {
			property = createUnionOrIntersectionProperty(type_, name, skipObjectFunctionPropertyAugment)
			if property {
				var properties SymbolTable
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case skipObjectFunctionPropertyAugment:
					properties = /* TODO(TS-TO-GO) Node BinaryExpression: type.propertyCacheWithoutObjectFunctionPropertyAugment ||= createSymbolTable() */ TODO
				default:
					properties = /* TODO(TS-TO-GO) Node BinaryExpression: type.propertyCache ||= createSymbolTable() */ TODO
				}
				properties.set(name, property)
				// Propagate an entry from the non-augmented cache to the augmented cache unless the property is partial.
				if skipObjectFunctionPropertyAugment && !(getCheckFlags(property) & CheckFlagsPartial) && !type_.propertyCache. /* TODO(TS-TO-GO): was ? */ get(name) {
					properties := /* TODO(TS-TO-GO) Node BinaryExpression: type.propertyCache ||= createSymbolTable() */ TODO
					properties.set(name, property)
				}
			}
		}
		return property
	}
	getCommonDeclarationsOfSymbols := func(symbols Iterable[Symbol]) *Set[Node] {
		var commonDeclarations *Set[Node]
		for _, symbol := range symbols {
			if !symbol.declarations {
				return nil
			}
			if !commonDeclarations {
				commonDeclarations = NewSet(symbol.declarations)
				continue
			}
			commonDeclarations.forEach(func(declaration Node) {
				if !contains(symbol.declarations, declaration) {
					commonDeclarations.delete(declaration)
				}
			})
			if commonDeclarations.size == 0 {
				return nil
			}
		}
		return commonDeclarations
	}
	getPropertyOfUnionOrIntersectionType := func(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) Symbol {
		property := getUnionOrIntersectionProperty(type_, name, skipObjectFunctionPropertyAugment)
		// We need to filter out partial properties in union types
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case property && !(getCheckFlags(property) & CheckFlagsReadPartial):
			return property
		default:
			return nil
		}
	}
	/**
	 * Return the reduced form of the given type. For a union type, it is a union of the normalized constituent types.
	 * For an intersection of types containing one or more mututally exclusive discriminant properties, it is 'never'.
	 * For all other types, it is simply the type itself. Discriminant properties are considered mutually exclusive when
	 * no constituent property has type 'never', but the intersection of the constituent property types is 'never'.
	 */
	getReducedType := func(type_ Type) Type {
		if type_.flags&TypeFlagsUnion && (type_ /* as UnionType */).objectFlags&ObjectFlagsContainsIntersections {
			return (type_ /* as UnionType */).resolvedReducedType || ( /* TODO(TS-TO-GO) Node BinaryExpression: (type as UnionType).resolvedReducedType = getReducedUnionType(type as UnionType) */ TODO)
		} else if type_.flags & TypeFlagsIntersection {
			if !((type_ /* as IntersectionType */).objectFlags & ObjectFlagsIsNeverIntersectionComputed) {
				(type_ /* as IntersectionType */).objectFlags |= ObjectFlagsIsNeverIntersectionComputed | (__COND__(some(getPropertiesOfUnionOrIntersectionType(type_ /* as IntersectionType */), isNeverReducedProperty), ObjectFlagsIsNeverIntersection, 0))
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (type_ /* as IntersectionType */).objectFlags & ObjectFlagsIsNeverIntersection:
				return neverType
			default:
				return type_
			}
		}
		return type_
	}
	getReducedUnionType := func(unionType UnionType) Type {
		reducedTypes := sameMap(unionType.types, getReducedType)
		if reducedTypes == unionType.types {
			return unionType
		}
		reduced := getUnionType(reducedTypes)
		if reduced.flags & TypeFlagsUnion {
			(reduced /* as UnionType */).resolvedReducedType = reduced
		}
		return reduced
	}
	isNeverReducedProperty := func(prop Symbol) bool {
		return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop)
	}
	isDiscriminantWithNeverType := func(prop Symbol) bool {
		// Return true for a synthetic non-optional property with non-uniform types, where at least one is
		// a literal type and none is never, that reduces to never.
		return !(prop.flags & SymbolFlagsOptional) && (getCheckFlags(prop)&(CheckFlagsDiscriminant|CheckFlagsHasNeverType)) == CheckFlagsDiscriminant && !!(getTypeOfSymbol(prop).flags & TypeFlagsNever)
	}
	isConflictingPrivateProperty := func(prop Symbol) bool {
		// Return true for a synthetic property with multiple declarations, at least one of which is private.
		return !prop.valueDeclaration && !!(getCheckFlags(prop) & CheckFlagsContainsPrivate)
	}
	/**
	 * A union type which is reducible upon instantiation (meaning some members are removed under certain instantiations)
	 * must be kept generic, as that instantiation information needs to flow through the type system. By replacing all
	 * type parameters in the union with a special never type that is treated as a literal in `getReducedType`, we can cause
	 * the `getReducedType` logic to reduce the resulting type if possible (since only intersections with conflicting
	 * literal-typed properties are reducible).
	 */
	isGenericReducibleType := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsUnion && (type_ /* as UnionType */).objectFlags&ObjectFlagsContainsIntersections && some((type_ /* as UnionType */).types, isGenericReducibleType) || type_.flags&TypeFlagsIntersection && isReducibleIntersection(type_ /* as IntersectionType */))
	}
	isReducibleIntersection := func(type_ IntersectionType) bool {
		uniqueFilled := type_.uniqueLiteralFilledInstantiation || ( /* TODO(TS-TO-GO) Node BinaryExpression: type.uniqueLiteralFilledInstantiation = instantiateType(type, uniqueLiteralMapper) */ TODO)
		return getReducedType(uniqueFilled) != uniqueFilled
	}
	elaborateNeverIntersection := func(errorInfo *DiagnosticMessageChain, type_ Type) *DiagnosticMessageChain {
		if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsNeverIntersection {
			neverProp := find(getPropertiesOfUnionOrIntersectionType(type_ /* as IntersectionType */), isDiscriminantWithNeverType)
			if neverProp {
				return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents, typeToString(type_ /*enclosingDeclaration*/, nil, TypeFormatFlagsNoTypeReduction), symbolToString(neverProp))
			}
			privateProp := find(getPropertiesOfUnionOrIntersectionType(type_ /* as IntersectionType */), isConflictingPrivateProperty)
			if privateProp {
				return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some, typeToString(type_ /*enclosingDeclaration*/, nil, TypeFormatFlagsNoTypeReduction), symbolToString(privateProp))
			}
		}
		return errorInfo
	}
	/**
	 * Return the symbol for the property with the given name in the given type. Creates synthetic union properties when
	 * necessary, maps primitive types and type parameters are to their apparent types, and augments with properties from
	 * Object and Function as appropriate.
	 *
	 * @param type a type to look up property from
	 * @param name a name of property to look up in a given type
	 */
	getPropertyOfType := func(type_ Type, name __String, skipObjectFunctionPropertyAugment bool, includeTypeOnlyMembers bool) Symbol {
		type_ = getReducedApparentType(type_)
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_ /* as ObjectType */)
			symbol := resolved.members.get(name)
			if symbol && !includeTypeOnlyMembers && type_.symbol. /* TODO(TS-TO-GO): was ? */ flags&SymbolFlagsValueModule && getSymbolLinks(type_.symbol).typeOnlyExportStarMap. /* TODO(TS-TO-GO): was ? */ has(name) {
				// If this is the type of a module, `resolved.members.get(name)` might have effectively skipped over
				// an `export type * from './foo'`, leaving `symbolIsValue` unable to see that the symbol is being
				// viewed through a type-only export.
				return nil
			}
			if symbol && symbolIsValue(symbol, includeTypeOnlyMembers) {
				return symbol
			}
			if skipObjectFunctionPropertyAugment {
				return nil
			}
			var functionType *ObjectType
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case resolved == anyFunctionType:
				functionType = globalFunctionType
			case resolved.callSignatures.length:
				functionType = globalCallableFunctionType
			case resolved.constructSignatures.length:
				functionType = globalNewableFunctionType
			default:
				functionType = nil
			}
			if functionType {
				symbol := getPropertyOfObjectType(functionType, name)
				if symbol {
					return symbol
				}
			}
			return getPropertyOfObjectType(globalObjectType, name)
		}
		if type_.flags & TypeFlagsIntersection {
			prop := getPropertyOfUnionOrIntersectionType(type_ /* as UnionOrIntersectionType */, name /*skipObjectFunctionPropertyAugment*/, true)
			if prop {
				return prop
			}
			if !skipObjectFunctionPropertyAugment {
				return getPropertyOfUnionOrIntersectionType(type_ /* as UnionOrIntersectionType */, name, skipObjectFunctionPropertyAugment)
			}
			return nil
		}
		if type_.flags & TypeFlagsUnion {
			return getPropertyOfUnionOrIntersectionType(type_ /* as UnionOrIntersectionType */, name, skipObjectFunctionPropertyAugment)
		}
		return nil
	}
	getSignaturesOfStructuredType := func(type_ Type, kind SignatureKind) []Signature {
		if type_.flags & TypeFlagsStructuredType {
			resolved := resolveStructuredTypeMembers(type_ /* as ObjectType */)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case kind == SignatureKindCall:
				return resolved.callSignatures
			default:
				return resolved.constructSignatures
			}
		}
		return emptyArray
	}
	/**
	 * Return the signatures of the given kind in the given type. Creates synthetic union signatures when necessary and
	 * maps primitive types and type parameters are to their apparent types.
	 */
	getSignaturesOfType := func(type_ Type, kind SignatureKind) []Signature {
		result := getSignaturesOfStructuredType(getReducedApparentType(type_), kind)
		if kind == SignatureKindCall && !length(result) && type_.flags&TypeFlagsUnion {
			if (type_ /* as UnionType */).arrayFallbackSignatures {
				return (type_ /* as UnionType */).arrayFallbackSignatures
			}
			// If the union is all different instantiations of a member of the global array type...
			var memberName __String
			if everyType(type_, func(t Type) bool {
				return !!t.symbol. /* TODO(TS-TO-GO): was ? */ parent && isArrayOrTupleSymbol(t.symbol.parent) && (__COND__(!memberName, ( /* TODO(TS-TO-GO) Node BinaryExpression: memberName = t.symbol.escapedName, true */ TODO), memberName == t.symbol.escapedName))
			}) {
				// Transform the type from `(A[] | B[])["member"]` to `(A | B)[]["member"]` (since we pretend array is covariant anyway)
				arrayArg := mapType(type_, func(t Type) Type {
					return getMappedType((__COND__(isReadonlyArraySymbol(t.symbol.parent), globalReadonlyArrayType, globalArrayType)).typeParameters[0], (t /* as AnonymousType */).mapper)
				})
				arrayType := createArrayType(arrayArg, someType(type_, func(t Type) bool {
					return isReadonlyArraySymbol(t.symbol.parent)
				}))
				(type_ /* as UnionType */).arrayFallbackSignatures = getSignaturesOfType(getTypeOfPropertyOfType(arrayType, memberName), kind)
				return (type_ /* as UnionType */).arrayFallbackSignatures
			}
			(type_ /* as UnionType */).arrayFallbackSignatures = result
		}
		return result
	}
	isArrayOrTupleSymbol := func(symbol Symbol) bool {
		if !symbol || !globalArrayType.symbol || !globalReadonlyArrayType.symbol {
			return false
		}
		return !!getSymbolIfSameReference(symbol, globalArrayType.symbol) || !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol)
	}
	isReadonlyArraySymbol := func(symbol Symbol) bool {
		if !symbol || !globalReadonlyArrayType.symbol {
			return false
		}
		return !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol)
	}
	findIndexInfo := func(indexInfos []IndexInfo, keyType Type) *IndexInfo {
		return find(indexInfos, func(info IndexInfo) bool {
			return info.keyType == keyType
		})
	}
	findApplicableIndexInfo := func(indexInfos []IndexInfo, keyType Type) *IndexInfo {
		// Index signatures for type 'string' are considered only when no other index signatures apply.
		var stringIndexInfo *IndexInfo
		var applicableInfo *IndexInfo
		var applicableInfos *[]IndexInfo
		for _, info := range indexInfos {
			if info.keyType == stringType {
				stringIndexInfo = info
			} else if isApplicableIndexType(keyType, info.keyType) {
				if !applicableInfo {
					applicableInfo = info
				} else {
					(applicableInfos || ( /* TODO(TS-TO-GO) Node BinaryExpression: applicableInfos = [applicableInfo] */ TODO)).push(info)
				}
			}
		}
		// When more than one index signature is applicable we create a synthetic IndexInfo. Instead of computing
		// the intersected key type, we just use unknownType for the key type as nothing actually depends on the
		// keyType property of the returned IndexInfo.
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case applicableInfos:
			return createIndexInfo(unknownType, getIntersectionType(map_(applicableInfos, func(info IndexInfo) Type {
				return info.type_
			})), reduceLeft(applicableInfos, func(isReadonly bool, info IndexInfo) bool {
				return isReadonly && info.isReadonly
			}, /*initial*/ true))
		case applicableInfo:
			return applicableInfo
		case stringIndexInfo && isApplicableIndexType(keyType, stringType):
			return stringIndexInfo
		default:
			return nil
		}
	}
	isApplicableIndexType := func(source Type, target Type) bool {
		// A 'string' index signature applies to types assignable to 'string' or 'number', and a 'number' index
		// signature applies to types assignable to 'number', `${number}` and numeric string literal types.
		return isTypeAssignableTo(source, target) || target == stringType && isTypeAssignableTo(source, numberType) || target == numberType && (source == numericStringType || !!(source.flags&TypeFlagsStringLiteral) && isNumericLiteralName((source /* as StringLiteralType */).value))
	}
	getIndexInfosOfStructuredType := func(type_ Type) []IndexInfo {
		if type_.flags & TypeFlagsStructuredType {
			resolved := resolveStructuredTypeMembers(type_ /* as ObjectType */)
			return resolved.indexInfos
		}
		return emptyArray
	}
	getIndexInfosOfType := func(type_ Type) []IndexInfo {
		return getIndexInfosOfStructuredType(getReducedApparentType(type_))
	}
	// Return the indexing info of the given kind in the given type. Creates synthetic union index types when necessary and
	// maps primitive types and type parameters are to their apparent types.
	getIndexInfoOfType := func(type_ Type, keyType Type) *IndexInfo {
		return findIndexInfo(getIndexInfosOfType(type_), keyType)
	}
	// Return the index type of the given kind in the given type. Creates synthetic union index types when necessary and
	// maps primitive types and type parameters are to their apparent types.
	getIndexTypeOfType := func(type_ Type, keyType Type) Type {
		return getIndexInfoOfType(type_, keyType). /* TODO(TS-TO-GO): was ? */ type_
	}
	getApplicableIndexInfos := func(type_ Type, keyType Type) []IndexInfo {
		return getIndexInfosOfType(type_).filter(func(info IndexInfo) bool {
			return isApplicableIndexType(keyType, info.keyType)
		})
	}
	getApplicableIndexInfo := func(type_ Type, keyType Type) *IndexInfo {
		return findApplicableIndexInfo(getIndexInfosOfType(type_), keyType)
	}
	getApplicableIndexInfoForName := func(type_ Type, name __String) *IndexInfo {
		return getApplicableIndexInfo(type_, __COND__(isLateBoundName(name), esSymbolType, getStringLiteralType(unescapeLeadingUnderscores(name))))
	}
	// Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
	// type checking functions).
	getTypeParametersFromDeclaration := func(declaration DeclarationWithTypeParameters) *[]TypeParameter {
		var result *[]TypeParameter
		for _, node := range getEffectiveTypeParameterDeclarations(declaration) {
			result = appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol))
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case result. /* TODO(TS-TO-GO): was ? */ length:
			return result
		case isFunctionDeclaration(declaration):
			return getSignatureOfTypeTag(declaration). /* TODO(TS-TO-GO): was ? */ typeParameters
		default:
			return nil
		}
	}
	symbolsToArray := func(symbols SymbolTable) []Symbol {
		var result []Symbol = []never{}
		symbols.forEach(func(symbol Symbol, id __String) {
			if !isReservedMemberName(id) {
				result.push(symbol)
			}
		})
		return result
	}
	tryFindAmbientModule := func(moduleName string, withAugmentations bool) Symbol {
		if isExternalModuleNameRelative(moduleName) {
			return nil
		}
		symbol := getSymbol(globals, '"'+moduleName+'"' /* as __String */, SymbolFlagsValueModule)
		// merged symbol is module declaration symbol combined with all augmentations
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol && withAugmentations:
			return getMergedSymbol(symbol)
		default:
			return symbol
		}
	}
	hasEffectiveQuestionToken := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) bool {
		return hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isParameter(node) && isJSDocOptionalParameter(node)
	}
	isOptionalParameter := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) bool {
		if hasEffectiveQuestionToken(node) {
			return true
		}
		if !isParameter(node) {
			return false
		}
		if node.initializer {
			signature := getSignatureFromDeclaration(node.parent)
			parameterIndex := node.parent.parameters.indexOf(node)
			Debug.assert(parameterIndex >= 0)
			// Only consider syntactic or instantiated parameters as optional, not `void` parameters as this function is used
			// in grammar checks and checking for `void` too early results in parameter types widening too early
			// and causes some noImplicitAny errors to be lost.
			return parameterIndex >= getMinArgumentCount(signature, MinArgumentCountFlagsStrongArityForUntypedJS|MinArgumentCountFlagsVoidIsNonOptional)
		}
		iife := getImmediatelyInvokedFunctionExpression(node.parent)
		if iife {
			return !node.type_ && !node.dotDotDotToken && node.parent.parameters.indexOf(node) >= getEffectiveCallArguments(iife).length
		}
		return false
	}
	isOptionalPropertyDeclaration := func(node Declaration) * /* TODO(TS-TO-GO) inferred type false | QuestionToken */ any {
		return isPropertyDeclaration(node) && !hasAccessorModifier(node) && node.questionToken
	}
	createTypePredicate := func(kind TypePredicateKind, parameterName *string, parameterIndex *number, type_ Type) TypePredicate {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"kind":           kind,
			"parameterName":  parameterName,
			"parameterIndex": parameterIndex,
			"type_":          type_,
		} /* as TypePredicate */
	}
	/**
	 * Gets the minimum number of type arguments needed to satisfy all non-optional type
	 * parameters.
	 */
	getMinTypeArgumentCount := func(typeParameters *[]TypeParameter) number {
		minTypeArgumentCount := 0
		if typeParameters {
			for i := 0; i < typeParameters.length; i++ {
				if !hasTypeParameterDefault(typeParameters[i]) {
					minTypeArgumentCount = i + 1
				}
			}
		}
		return minTypeArgumentCount
	}
	/**
	 * Fill in default types for unsupplied type arguments. If `typeArguments` is undefined
	 * when a default type is supplied, a new array will be created and returned.
	 *
	 * @param typeArguments The supplied type arguments.
	 * @param typeParameters The requested type parameters.
	 * @param minTypeArgumentCount The minimum number of required type arguments.
	 */
	/* TODO(TS-TO-GO): function fillMissingTypeArguments(typeArguments: readonly Type[], typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean): Type[]; */
	/* TODO(TS-TO-GO): function fillMissingTypeArguments(typeArguments: readonly Type[] | undefined, typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean): Type[] | undefined; */
	fillMissingTypeArguments := func(typeArguments *[]Type, typeParameters *[]TypeParameter, minTypeArgumentCount number, isJavaScriptImplicitAny bool) *[]Type {
		numTypeParameters := length(typeParameters)
		if !numTypeParameters {
			return []never{}
		}
		numTypeArguments := length(typeArguments)
		if isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters) {
			var result []Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case typeArguments:
				result = typeArguments.slice()
			default:
				result = []never{}
			}
			// Map invalid forward references in default types to the error type
			for i := numTypeArguments; i < numTypeParameters; i++ {
				result[i] = errorType
			}
			baseDefaultType := getDefaultTypeArgumentType(isJavaScriptImplicitAny)
			for i := numTypeArguments; i < numTypeParameters; i++ {
				defaultType := getDefaultFromTypeParameter(typeParameters[i])
				if isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType)) {
					defaultType = anyType
				}
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case defaultType:
					result[i] = instantiateType(defaultType, createTypeMapper(typeParameters, result))
				default:
					result[i] = baseDefaultType
				}
			}
			result.length = typeParameters.length
			return result
		}
		return typeArguments && typeArguments.slice()
	}
	getSignatureFromDeclaration := func(declaration /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any) Signature {
		links := getNodeLinks(declaration)
		if !links.resolvedSignature {
			var parameters []Symbol = []never{}
			flags := SignatureFlagsNone
			minArgumentCount := 0
			var thisParameter Symbol
			var thisTag *JSDocThisTag
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isInJSFile(declaration):
				thisTag = getJSDocThisTag(declaration)
			default:
				thisTag = nil
			}
			hasThisParameter := false
			iife := getImmediatelyInvokedFunctionExpression(declaration)
			isJSConstructSignature := isJSDocConstructSignature(declaration)
			isUntypedSignatureInJSFile := !iife && isInJSFile(declaration) && isValueSignatureDeclaration(declaration) && !hasJSDocParameterTags(declaration) && !getJSDocType(declaration)
			if isUntypedSignatureInJSFile {
				flags |= SignatureFlagsIsUntypedSignatureInJSFile
			}
			// If this is a JSDoc construct signature, then skip the first parameter in the
			// parameter list.  The first parameter represents the return type of the construct
			// signature.
			for i := __COND__(isJSConstructSignature, 1, 0); i < declaration.parameters.length; i++ {
				param := declaration.parameters[i]
				if isInJSFile(param) && isJSDocThisTag(param) {
					thisTag = param
					continue
				}
				paramSymbol := param.symbol
				var type_ *TypeNode
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isJSDocParameterTag(param):
					type_ = (param.typeExpression && param.typeExpression.type_)
				default:
					type_ = param.type_
				}
				// Include parameter symbol instead of property symbol in the signature
				if paramSymbol && !!(paramSymbol.flags & SymbolFlagsProperty) && !isBindingPattern(param.name) {
					resolvedSymbol := resolveName(param, paramSymbol.escapedName, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, false)
					paramSymbol = resolvedSymbol
				}
				if i == 0 && paramSymbol.escapedName == InternalSymbolNameThis {
					hasThisParameter = true
					thisParameter = param.symbol
				} else {
					parameters.push(paramSymbol)
				}
				if type_ && type_.kind == SyntaxKindLiteralType {
					flags |= SignatureFlagsHasLiteralTypes
				}
				// Record a new minimum argument count if this is not an optional parameter
				isOptionalParameter := hasEffectiveQuestionToken(param) || isParameter(param) && param.initializer || isRestParameter(param) || iife && parameters.length > iife.arguments.length && !type_
				if !isOptionalParameter {
					minArgumentCount = parameters.length
				}
			}
			// If only one accessor includes a this-type annotation, the other behaves as if it had the same type annotation
			if (declaration.kind == SyntaxKindGetAccessor || declaration.kind == SyntaxKindSetAccessor) && hasBindableName(declaration) && (!hasThisParameter || !thisParameter) {
				var otherKind /* TODO(TS-TO-GO) inferred type SyntaxKind.GetAccessor | SyntaxKind.SetAccessor */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case declaration.kind == SyntaxKindGetAccessor:
					otherKind = SyntaxKindSetAccessor
				default:
					otherKind = SyntaxKindGetAccessor
				}
				other := getDeclarationOfKind(getSymbolOfDeclaration(declaration), otherKind)
				if other {
					thisParameter = getAnnotatedAccessorThisParameter(other)
				}
			}
			if thisTag && thisTag.typeExpression {
				thisParameter = createSymbolWithType(createSymbol(SymbolFlagsFunctionScopedVariable, InternalSymbolNameThis), getTypeFromTypeNode(thisTag.typeExpression))
			}
			var hostDeclaration Node
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isJSDocSignature(declaration):
				hostDeclaration = getEffectiveJSDocHost(declaration)
			default:
				hostDeclaration = declaration
			}
			var classType *InterfaceType
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case hostDeclaration && isConstructorDeclaration(hostDeclaration):
				classType = getDeclaredTypeOfClassOrInterface(getMergedSymbol((hostDeclaration.parent /* as ClassDeclaration */).symbol))
			default:
				classType = nil
			}
			var typeParameters *[]TypeParameter
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case classType:
				typeParameters = classType.localTypeParameters
			default:
				typeParameters = getTypeParametersFromDeclaration(declaration)
			}
			if hasRestParameter(declaration) || isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters) {
				flags |= SignatureFlagsHasRestParameter
			}
			if isConstructorTypeNode(declaration) && hasSyntacticModifier(declaration, ModifierFlagsAbstract) || isConstructorDeclaration(declaration) && hasSyntacticModifier(declaration.parent, ModifierFlagsAbstract) {
				flags |= SignatureFlagsAbstract
			}
			links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters /*resolvedReturnType*/, nil /*resolvedTypePredicate*/, nil, minArgumentCount, flags)
		}
		return links.resolvedSignature
	}
	/**
	 * A JS function gets a synthetic rest parameter if it references `arguments` AND:
	 * 1. It has no parameters but at least one `@param` with a type that starts with `...`
	 * OR
	 * 2. It has at least one parameter, and the last parameter has a matching `@param` with a type that starts with `...`
	 */
	maybeAddJsSyntheticRestParameter := func(declaration /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any, parameters []Symbol) bool {
		if isJSDocSignature(declaration) || !containsArgumentsReference(declaration) {
			return false
		}
		lastParam := lastOrUndefined(declaration.parameters)
		var lastParamTags []JSDocParameterTag
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case lastParam:
			lastParamTags = getJSDocParameterTags(lastParam)
		default:
			lastParamTags = getJSDocTags(declaration).filter(isJSDocParameterTag)
		}
		lastParamVariadicType := firstDefined(lastParamTags, func(p JSDocParameterTag) *JSDocVariadicType {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case p.typeExpression && isJSDocVariadicType(p.typeExpression.type_):
				return p.typeExpression.type_
			default:
				return nil
			}
		})
		syntheticArgsSymbol := createSymbol(SymbolFlagsVariable, "args" /* as __String */, CheckFlagsRestParameter)
		if lastParamVariadicType {
			// Parameter has effective annotation, lock in type
			syntheticArgsSymbol.links.type_ = createArrayType(getTypeFromTypeNode(lastParamVariadicType.type_))
		} else {
			// Parameter has no annotation
			// By using a `DeferredType` symbol, we allow the type of this rest arg to be overriden by contextual type assignment so long as its type hasn't been
			// cached by `getTypeOfSymbol` yet.
			syntheticArgsSymbol.links.checkFlags |= CheckFlagsDeferredType
			syntheticArgsSymbol.links.deferralParent = neverType
			syntheticArgsSymbol.links.deferralConstituents = []Type{anyArrayType}
			syntheticArgsSymbol.links.deferralWriteConstituents = []Type{anyArrayType}
		}
		if lastParamVariadicType {
			// Replace the last parameter with a rest parameter.
			parameters.pop()
		}
		parameters.push(syntheticArgsSymbol)
		return true
	}
	getSignatureOfTypeTag := func(node /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any) *Signature {
		// should be attached to a function declaration or expression
		if !(isInJSFile(node) && isFunctionLikeDeclaration(node)) {
			return nil
		}
		typeTag := getJSDocTypeTag(node)
		return typeTag. /* TODO(TS-TO-GO): was ? */ typeExpression && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression))
	}
	getParameterTypeOfTypeTag := func(func_ FunctionLikeDeclaration, parameter ParameterDeclaration) Type {
		signature := getSignatureOfTypeTag(func_)
		if !signature {
			return nil
		}
		pos := func_.parameters.indexOf(parameter)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case parameter.dotDotDotToken:
			return getRestTypeAtPosition(signature, pos)
		default:
			return getTypeAtPosition(signature, pos)
		}
	}
	getReturnTypeOfTypeTag := func(node /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any) Type {
		signature := getSignatureOfTypeTag(node)
		return signature && getReturnTypeOfSignature(signature)
	}
	containsArgumentsReference := func(declaration SignatureDeclaration) bool {
		links := getNodeLinks(declaration)
		if links.containsArgumentsReference == nil {
			if links.flags & NodeCheckFlagsCaptureArguments {
				links.containsArgumentsReference = true
			} else {
				links.containsArgumentsReference = traverse((declaration /* as FunctionLikeDeclaration */).body)
			}
		}
		return links.containsArgumentsReference
		traverse := func(node Node) bool {
			if !node {
				return false
			}
			switch node.kind {
			case SyntaxKindIdentifier:
				return (node /* as Identifier */).escapedText == argumentsSymbol.escapedName && getReferencedValueSymbol(node /* as Identifier */) == argumentsSymbol
			case SyntaxKindPropertyDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindSetAccessor:
				return (node /* as NamedDeclaration */).name.kind == SyntaxKindComputedPropertyName && traverse((node /* as NamedDeclaration */).name)
			case SyntaxKindPropertyAccessExpression:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindElementAccessExpression:
				return traverse((node /* as PropertyAccessExpression | ElementAccessExpression */).expression)
			case SyntaxKindPropertyAssignment:
				return traverse((node /* as PropertyAssignment */).initializer)
			default:
				return !nodeStartsNewLexicalEnvironment(node) && !isPartOfTypeNode(node) && !!forEachChild(node, traverse)
			}
		}
	}
	getSignaturesOfSymbol := func(symbol Symbol) []Signature {
		if !symbol || !symbol.declarations {
			return emptyArray
		}
		var result []Signature = []never{}
		for i := 0; i < symbol.declarations.length; i++ {
			decl := symbol.declarations[i]
			if !isFunctionLike(decl) {
				continue
			}
			// Don't include signature if node is the implementation of an overloaded function. A node is considered
			// an implementation node if it has a body and the previous node is of the same kind and immediately
			// precedes the implementation node (i.e. has the same parent and ends where the implementation starts).
			if i > 0 && (decl /* as FunctionLikeDeclaration */).body {
				previous := symbol.declarations[i-1]
				if decl.parent == previous.parent && decl.kind == previous.kind && decl.pos == previous.end {
					continue
				}
			}
			if isInJSFile(decl) && decl.jsDoc {
				tags := getJSDocOverloadTags(decl)
				if length(tags) {
					for _, tag := range tags {
						jsDocSignature := tag.typeExpression
						if jsDocSignature.type_ == nil && !isConstructorDeclaration(decl) {
							reportImplicitAny(jsDocSignature, anyType)
						}
						result.push(getSignatureFromDeclaration(jsDocSignature))
					}
					continue
				}
			}
			// If this is a function or method declaration, get the signature from the @type tag for the sake of optional parameters.
			// Exclude contextually-typed kinds because we already apply the @type tag to the context, plus applying it here to the initializer would supress checks that the two are compatible.
			result.push((!isFunctionExpressionOrArrowFunction(decl) && !isObjectLiteralMethod(decl) && getSignatureOfTypeTag(decl)) || getSignatureFromDeclaration(decl))
		}
		return result
	}
	resolveExternalModuleTypeByLiteral := func(name StringLiteral) Type {
		moduleSym := resolveExternalModuleName(name, name)
		if moduleSym {
			resolvedModuleSymbol := resolveExternalModuleSymbol(moduleSym)
			if resolvedModuleSymbol {
				return getTypeOfSymbol(resolvedModuleSymbol)
			}
		}
		return anyType
	}
	getThisTypeOfSignature := func(signature Signature) Type {
		if signature.thisParameter {
			return getTypeOfSymbol(signature.thisParameter)
		}
	}
	getTypePredicateOfSignature := func(signature Signature) *TypePredicate {
		if !signature.resolvedTypePredicate {
			if signature.target {
				targetTypePredicate := getTypePredicateOfSignature(signature.target)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case targetTypePredicate:
					signature.resolvedTypePredicate = instantiateTypePredicate(targetTypePredicate, signature.mapper)
				default:
					signature.resolvedTypePredicate = noTypePredicate
				}
			} else if signature.compositeSignatures {
				signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate
			} else {
				type_ := signature.declaration && getEffectiveReturnTypeNode(signature.declaration)
				var jsdocPredicate *TypePredicate
				if !type_ {
					jsdocSignature := getSignatureOfTypeTag(signature.declaration)
					if jsdocSignature && signature != jsdocSignature {
						jsdocPredicate = getTypePredicateOfSignature(jsdocSignature)
					}
				}
				if type_ || jsdocPredicate {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case type_ && isTypePredicateNode(type_):
						signature.resolvedTypePredicate = createTypePredicateFromTypePredicateNode(type_, signature)
					default:
						signature.resolvedTypePredicate = jsdocPredicate || noTypePredicate
					}
				} else if signature.declaration && isFunctionLikeDeclaration(signature.declaration) && (!signature.resolvedReturnType || signature.resolvedReturnType.flags&TypeFlagsBoolean) && getParameterCount(signature) > 0 {
					TODO_IDENTIFIER := signature
					signature.resolvedTypePredicate = noTypePredicate
					// avoid infinite loop
					signature.resolvedTypePredicate = getTypePredicateFromBody(declaration) || noTypePredicate
				} else {
					signature.resolvedTypePredicate = noTypePredicate
				}
			}
			Debug.assert(!!signature.resolvedTypePredicate)
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case signature.resolvedTypePredicate == noTypePredicate:
			return nil
		default:
			return signature.resolvedTypePredicate
		}
	}
	createTypePredicateFromTypePredicateNode := func(node TypePredicateNode, signature Signature) TypePredicate {
		parameterName := node.parameterName
		type_ := node.type_ && getTypeFromTypeNode(node.type_)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case parameterName.kind == SyntaxKindThisType:
			return createTypePredicate(__COND__(node.assertsModifier, TypePredicateKindAssertsThis, TypePredicateKindThis) /*parameterName*/, nil /*parameterIndex*/, nil, type_)
		default:
			return createTypePredicate(__COND__(node.assertsModifier, TypePredicateKindAssertsIdentifier, TypePredicateKindIdentifier), parameterName.escapedText /* as string */, findIndex(signature.parameters, func(p Symbol) bool {
				return p.escapedName == parameterName.escapedText
			}), type_)
		}
	}
	getUnionOrIntersectionType := func(types []Type, kind *TypeFlags, unionReduction UnionReduction) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case kind != TypeFlagsIntersection:
			return getUnionType(types, unionReduction)
		default:
			return getIntersectionType(types)
		}
	}
	getReturnTypeOfSignature := func(signature Signature) Type {
		if !signature.resolvedReturnType {
			if !pushTypeResolution(signature, TypeSystemPropertyNameResolvedReturnType) {
				return errorType
			}
			var type_ Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case signature.target:
				type_ = instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper)
			case signature.compositeSignatures:
				type_ = instantiateType(getUnionOrIntersectionType(map_(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, UnionReductionSubtype), signature.mapper)
			default:
				type_ = getReturnTypeFromAnnotation(signature.declaration) || (__COND__(nodeIsMissing((signature.declaration /* as FunctionLikeDeclaration */).body), anyType, getReturnTypeFromBody(signature.declaration /* as FunctionLikeDeclaration */)))
			}
			if signature.flags & SignatureFlagsIsInnerCallChain {
				type_ = addOptionalTypeMarker(type_)
			} else if signature.flags & SignatureFlagsIsOuterCallChain {
				type_ = getOptionalType(type_)
			}
			if !popTypeResolution() {
				if signature.declaration {
					typeNode := getEffectiveReturnTypeNode(signature.declaration)
					if typeNode {
						error(typeNode, Diagnostics.Return_type_annotation_circularly_references_itself)
					} else if noImplicitAny {
						declaration := signature.declaration /* as Declaration */
						name := getNameOfDeclaration(declaration)
						if name {
							error(name, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, declarationNameToString(name))
						} else {
							error(declaration, Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions)
						}
					}
				}
				type_ = anyType
			}
			/* TODO(TS-TO-GO) Node BinaryExpression: signature.resolvedReturnType ??= type */ TODO
		}
		return signature.resolvedReturnType
	}
	getReturnTypeFromAnnotation := func(declaration /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any) Type {
		if declaration.kind == SyntaxKindConstructor {
			return getDeclaredTypeOfClassOrInterface(getMergedSymbol((declaration.parent /* as ClassDeclaration */).symbol))
		}
		typeNode := getEffectiveReturnTypeNode(declaration)
		if isJSDocSignature(declaration) {
			root := getJSDocRoot(declaration)
			if root && isConstructorDeclaration(root.parent) && !typeNode {
				return getDeclaredTypeOfClassOrInterface(getMergedSymbol((root.parent.parent /* as ClassDeclaration */).symbol))
			}
		}
		if isJSDocConstructSignature(declaration) {
			return getTypeFromTypeNode((declaration.parameters[0] /* as ParameterDeclaration */).type_)
			// TODO: GH#18217
		}
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
		if declaration.kind == SyntaxKindGetAccessor && hasBindableName(declaration) {
			jsDocType := isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration)
			if jsDocType {
				return jsDocType
			}
			setter := getDeclarationOfKind(getSymbolOfDeclaration(declaration), SyntaxKindSetAccessor)
			setterType := getAnnotatedAccessorType(setter)
			if setterType {
				return setterType
			}
		}
		return getReturnTypeOfTypeTag(declaration)
	}
	isResolvingReturnTypeOfSignature := func(signature Signature) bool {
		return signature.compositeSignatures && some(signature.compositeSignatures, isResolvingReturnTypeOfSignature) || !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, TypeSystemPropertyNameResolvedReturnType) >= 0
	}
	getRestTypeOfSignature := func(signature Signature) Type {
		return tryGetRestTypeOfSignature(signature) || anyType
	}
	tryGetRestTypeOfSignature := func(signature Signature) Type {
		if signatureHasRestParameter(signature) {
			sigRestType := getTypeOfSymbol(signature.parameters[signature.parameters.length-1])
			var restType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isTupleType(sigRestType):
				restType = getRestTypeOfTupleType(sigRestType)
			default:
				restType = sigRestType
			}
			return restType && getIndexTypeOfType(restType, numberType)
		}
		return nil
	}
	getSignatureInstantiation := func(signature Signature, typeArguments *[]Type, isJavascript bool, inferredTypeParameters []TypeParameter) Signature {
		instantiatedSignature := getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript))
		if inferredTypeParameters {
			returnSignature := getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature))
			if returnSignature {
				newReturnSignature := cloneSignature(returnSignature)
				newReturnSignature.typeParameters = inferredTypeParameters
				newInstantiatedSignature := cloneSignature(instantiatedSignature)
				newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature)
				return newInstantiatedSignature
			}
		}
		return instantiatedSignature
	}
	getSignatureInstantiationWithoutFillingInTypeArguments := func(signature Signature, typeArguments *[]Type) Signature {
		instantiations := signature.instantiations || ( /* TODO(TS-TO-GO) Node BinaryExpression: signature.instantiations = new Map<string, Signature>() */ TODO)
		id := getTypeListId(typeArguments)
		instantiation := instantiations.get(id)
		if !instantiation {
			instantiations.set(id /* TODO(TS-TO-GO) Node BinaryExpression: instantiation = createSignatureInstantiation(signature, typeArguments) */, TODO)
		}
		return instantiation
	}
	createSignatureInstantiation := func(signature Signature, typeArguments *[]Type) Signature {
		return instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments) /*eraseTypeParameters*/, true)
	}
	getTypeParametersForMapper := func(signature Signature) *[]Type {
		return sameMap(signature.typeParameters, func(tp TypeParameter) Type {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case tp.mapper:
				return instantiateType(tp, tp.mapper)
			default:
				return tp
			}
		})
	}
	createSignatureTypeMapper := func(signature Signature, typeArguments *[]Type) TypeMapper {
		return createTypeMapper(getTypeParametersForMapper(signature), typeArguments)
	}
	getErasedSignature := func(signature Signature) Signature {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case signature.typeParameters:
			return signature.erasedSignatureCache || ( /* TODO(TS-TO-GO) Node BinaryExpression: signature.erasedSignatureCache = createErasedSignature(signature) */ TODO)
		default:
			return signature
		}
	}
	createErasedSignature := func(signature Signature) Signature {
		// Create an instantiation of the signature where all type arguments are the any type.
		return instantiateSignature(signature, createTypeEraser(signature.typeParameters) /*eraseTypeParameters*/, true)
	}
	getCanonicalSignature := func(signature Signature) Signature {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case signature.typeParameters:
			return signature.canonicalSignatureCache || ( /* TODO(TS-TO-GO) Node BinaryExpression: signature.canonicalSignatureCache = createCanonicalSignature(signature) */ TODO)
		default:
			return signature
		}
	}
	createCanonicalSignature := func(signature Signature) Signature {
		// Create an instantiation of the signature where each unconstrained type parameter is replaced with
		// its original. When a generic class or interface is instantiated, each generic method in the class or
		// interface is instantiated with a fresh set of cloned type parameters (which we need to handle scenarios
		// where different generations of the same type parameter are in scope). This leads to a lot of new type
		// identities, and potentially a lot of work comparing those identities, so here we create an instantiation
		// that uses the original type identities for all unconstrained type parameters.
		return getSignatureInstantiation(signature, map_(signature.typeParameters, func(tp TypeParameter) TypeParameter {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case tp.target && !getConstraintOfTypeParameter(tp.target):
				return tp.target
			default:
				return tp
			}
		}), isInJSFile(signature.declaration))
	}
	getImplementationSignature := func(signature Signature) Signature {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case signature.typeParameters:
			return /* TODO(TS-TO-GO) Node BinaryExpression: signature.implementationSignatureCache ||= createImplementationSignature(signature) */ TODO
		default:
			return signature
		}
	}
	createImplementationSignature := func(signature Signature) Signature {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case signature.typeParameters:
			return instantiateSignature(signature, createTypeMapper([]never{}, []never{}))
		default:
			return signature
		}
	}
	getBaseSignature := func(signature Signature) Signature {
		typeParameters := signature.typeParameters
		if typeParameters {
			if signature.baseSignatureCache {
				return signature.baseSignatureCache
			}
			typeEraser := createTypeEraser(typeParameters)
			baseConstraintMapper := createTypeMapper(typeParameters, map_(typeParameters, func(tp TypeParameter) Type {
				return getConstraintOfTypeParameter(tp) || unknownType
			}))
			var baseConstraints []Type = map_(typeParameters, func(tp TypeParameter) Type {
				return instantiateType(tp, baseConstraintMapper) || unknownType
			})
			// Run N type params thru the immediate constraint mapper up to N times
			// This way any noncircular interdependent type parameters are definitely resolved to their external dependencies
			for i := 0; i < typeParameters.length-1; i++ {
				baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper)
			}
			// and then apply a type eraser to remove any remaining circularly dependent type parameters
			baseConstraints = instantiateTypes(baseConstraints, typeEraser)
			signature.baseSignatureCache = instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints) /*eraseTypeParameters*/, true)
			return signature.baseSignatureCache
		}
		return signature
	}
	getOrCreateTypeFromSignature := func(signature Signature, outerTypeParameters []TypeParameter) ObjectType {
		// There are two ways to declare a construct signature, one is by declaring a class constructor
		// using the constructor keyword, and the other is declaring a bare construct signature in an
		// object type literal or interface (using the new keyword). Each way of declaring a constructor
		// will result in a different declaration kind.
		if !signature.isolatedSignatureType {
			kind := signature.declaration. /* TODO(TS-TO-GO): was ? */ kind
			// If declaration is undefined, it is likely to be the signature of the default constructor.
			isConstructor := kind == nil || kind == SyntaxKindConstructor || kind == SyntaxKindConstructSignature || kind == SyntaxKindConstructorType
			// The type must have a symbol with a `Function` flag and a declaration in order to be correctly flagged as possibly containing
			// type variables by `couldContainTypeVariables`
			type_ := createObjectType(ObjectFlagsAnonymous|ObjectFlagsSingleSignatureType, createSymbol(SymbolFlagsFunction, InternalSymbolNameFunction)) /* as SingleSignatureType */
			if signature.declaration && !nodeIsSynthesized(signature.declaration) {
				type_.symbol.declarations = [] /* TODO(TS-TO-GO) inferred type SignatureDeclaration | JSDocSignature */ any{signature.declaration}
				type_.symbol.valueDeclaration = signature.declaration
			}
			/* TODO(TS-TO-GO) Node BinaryExpression: outerTypeParameters ||= signature.declaration && getOuterTypeParameters(signature.declaration, /*includeThisTypes* / true) */ TODO
			type_.outerTypeParameters = outerTypeParameters
			type_.members = emptySymbols
			type_.properties = emptyArray
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !isConstructor:
				type_.callSignatures = []Signature{signature}
			default:
				type_.callSignatures = emptyArray
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isConstructor:
				type_.constructSignatures = []Signature{signature}
			default:
				type_.constructSignatures = emptyArray
			}
			type_.indexInfos = emptyArray
			signature.isolatedSignatureType = type_
		}
		return signature.isolatedSignatureType
	}
	getIndexSymbol := func(symbol Symbol) Symbol {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol.members:
			return getIndexSymbolFromSymbolTable(symbol.members)
		default:
			return nil
		}
	}
	getIndexSymbolFromSymbolTable := func(symbolTable SymbolTable) Symbol {
		return symbolTable.get(InternalSymbolNameIndex)
	}
	createIndexInfo := func(keyType Type, type_ Type, isReadonly bool, declaration IndexSignatureDeclaration) IndexInfo {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"keyType":     keyType,
			"type_":       type_,
			"isReadonly":  isReadonly,
			"declaration": declaration,
		}
	}
	getIndexInfosOfSymbol := func(symbol Symbol) []IndexInfo {
		indexSymbol := getIndexSymbol(symbol)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case indexSymbol:
			return getIndexInfosOfIndexSymbol(indexSymbol)
		default:
			return emptyArray
		}
	}
	getIndexInfosOfIndexSymbol := func(indexSymbol Symbol) []IndexInfo {
		if indexSymbol.declarations {
			var indexInfos []IndexInfo = []never{}
			for _, declaration := range indexSymbol.declarations /* as IndexSignatureDeclaration[] */ {
				if declaration.parameters.length == 1 {
					parameter := declaration.parameters[0]
					if parameter.type_ {
						forEachType(getTypeFromTypeNode(parameter.type_), func(keyType Type) {
							if isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos, keyType) {
								indexInfos.push(createIndexInfo(keyType, __COND__(declaration.type_, getTypeFromTypeNode(declaration.type_), anyType), hasEffectiveModifier(declaration, ModifierFlagsReadonly), declaration))
							}
						})
					}
				}
			}
			return indexInfos
		}
		return emptyArray
	}
	isValidIndexKeyType := func(type_ Type) bool {
		return !!(type_.flags & (TypeFlagsString | TypeFlagsNumber | TypeFlagsESSymbol)) || isPatternLiteralType(type_) || !!(type_.flags&TypeFlagsIntersection) && !isGenericType(type_) && some((type_ /* as IntersectionType */).types, isValidIndexKeyType)
	}
	getConstraintDeclaration := func(type_ TypeParameter) *TypeNode {
		return mapDefined(filter(type_.symbol && type_.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0]
	}
	getInferredTypeParameterConstraint := func(typeParameter TypeParameter, omitTypeReferences bool) Type {
		var inferences *[]Type
		if typeParameter.symbol. /* TODO(TS-TO-GO): was ? */ declarations {
			for _, declaration := range typeParameter.symbol.declarations {
				if declaration.parent.kind == SyntaxKindInferType {
					// When an 'infer T' declaration is immediately contained in a type reference node
					// (such as 'Foo<infer T>'), T's constraint is inferred from the constraint of the
					// corresponding type parameter in 'Foo'. When multiple 'infer T' declarations are
					// present, we form an intersection of the inferred constraint types.
					TODO_IDENTIFIER := walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent)
					if grandParent.kind == SyntaxKindTypeReference && !omitTypeReferences {
						typeReference := grandParent /* as TypeReferenceNode */
						typeParameters := getTypeParametersForTypeReferenceOrImport(typeReference)
						if typeParameters {
							index := typeReference.typeArguments.indexOf(childTypeParameter /* as TypeNode */)
							if index < typeParameters.length {
								declaredConstraint := getConstraintOfTypeParameter(typeParameters[index])
								if declaredConstraint {
									// Type parameter constraints can reference other type parameters so
									// constraints need to be instantiated. If instantiation produces the
									// type parameter itself, we discard that inference. For example, in
									//   type Foo<T extends string, U extends T> = [T, U];
									//   type Bar<T> = T extends Foo<infer X, infer X> ? Foo<X, X> : T;
									// the instantiated constraint for U is X, so we discard that inference.
									mapper := makeDeferredTypeMapper(typeParameters, typeParameters.map_(func(_ TypeParameter, index number) /* TODO(TS-TO-GO) inferred type () => Type */ any {
										return func() Type {
											return getEffectiveTypeArgumentAtIndex(typeReference, typeParameters, index)
										}
									}))
									constraint := instantiateType(declaredConstraint, mapper)
									if constraint != typeParameter {
										inferences = append(inferences, constraint)
									}
								}
							}
						}
					} else if grandParent.kind == SyntaxKindParameter && (grandParent /* as ParameterDeclaration */).dotDotDotToken || grandParent.kind == SyntaxKindRestType || grandParent.kind == SyntaxKindNamedTupleMember && (grandParent /* as NamedTupleMember */).dotDotDotToken {
						inferences = append(inferences, createArrayType(unknownType))
					} else if grandParent.kind == SyntaxKindTemplateLiteralTypeSpan {
						inferences = append(inferences, stringType)
					} else if grandParent.kind == SyntaxKindTypeParameter && grandParent.parent.kind == SyntaxKindMappedType {
						inferences = append(inferences, stringNumberSymbolType)
					} else if grandParent.kind == SyntaxKindMappedType && (grandParent /* as MappedTypeNode */).type_ && skipParentheses((grandParent /* as MappedTypeNode */).type_) == declaration.parent && grandParent.parent.kind == SyntaxKindConditionalType && (grandParent.parent /* as ConditionalTypeNode */).extendsType == grandParent && (grandParent.parent /* as ConditionalTypeNode */).checkType.kind == SyntaxKindMappedType && ((grandParent.parent /* as ConditionalTypeNode */).checkType /* as MappedTypeNode */).type_ {
						checkMappedType := (grandParent.parent /* as ConditionalTypeNode */).checkType /* as MappedTypeNode */
						nodeType := getTypeFromTypeNode(checkMappedType.type_)
						inferences = append(inferences, instantiateType(nodeType, makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(checkMappedType.typeParameter)), __COND__(checkMappedType.typeParameter.constraint, getTypeFromTypeNode(checkMappedType.typeParameter.constraint), stringNumberSymbolType))))
					}
				}
			}
		}
		return inferences && getIntersectionType(inferences)
	}
	/** This is a worker function. Use getConstraintOfTypeParameter which guards against circular constraints. */
	getConstraintFromTypeParameter := func(typeParameter TypeParameter) Type {
		if !typeParameter.constraint {
			if typeParameter.target {
				targetConstraint := getConstraintOfTypeParameter(typeParameter.target)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case targetConstraint:
					typeParameter.constraint = instantiateType(targetConstraint, typeParameter.mapper)
				default:
					typeParameter.constraint = noConstraintType
				}
			} else {
				constraintDeclaration := getConstraintDeclaration(typeParameter)
				if !constraintDeclaration {
					typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType
				} else {
					type_ := getTypeFromTypeNode(constraintDeclaration)
					if type_.flags&TypeFlagsAny && !isErrorType(type_) {
						// use stringNumberSymbolType as the base constraint for mapped type key constraints (unknown isn;t assignable to that, but `any` was),
						// use unknown otherwise
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case constraintDeclaration.parent.parent.kind == SyntaxKindMappedType:
							type_ = stringNumberSymbolType
						default:
							type_ = unknownType
						}
					}
					typeParameter.constraint = type_
				}
			}
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case typeParameter.constraint == noConstraintType:
			return nil
		default:
			return typeParameter.constraint
		}
	}
	getParentSymbolOfTypeParameter := func(typeParameter TypeParameter) Symbol {
		tp := getDeclarationOfKind(typeParameter.symbol, SyntaxKindTypeParameter)
		var host * /* TODO(TS-TO-GO) inferred type ClassDeclaration | ClassExpression | InterfaceDeclaration | SignatureDeclaration | TypeAliasDeclaration | InferTypeNode | JSDocCallbackTag | JSDocEnumTag | JSDocTypedefTag */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isJSDocTemplateTag(tp.parent):
			host = getEffectiveContainerForJSDocTemplateTag(tp.parent)
		default:
			host = tp.parent
		}
		return host && getSymbolOfNode(host)
	}
	getTypeListId := func(types *[]Type) string {
		result := ""
		if types {
			length := types.length
			i := 0
			for i < length {
				startId := types[i].id
				count := 1
				for i+count < length && types[i+count].id == startId+count {
					count++
				}
				if result.length {
					result += ","
				}
				result += startId
				if count > 1 {
					result += ":" + count
				}
				i += count
			}
		}
		return result
	}
	getAliasId := func(aliasSymbol Symbol, aliasTypeArguments *[]Type) string {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case aliasSymbol:
			return __TEMPLATE__("@", getSymbolId(aliasSymbol)) + (__COND__(aliasTypeArguments, __TEMPLATE__(":", getTypeListId(aliasTypeArguments)), ""))
		default:
			return ""
		}
	}
	// This function is used to propagate certain flags when creating new object type references and union types.
	// It is only necessary to do so if a constituent type might be the undefined type, the null type, the type
	// of an object literal or a non-inferrable type. This is because there are operations in the type checker
	// that care about the presence of such types at arbitrary depth in a containing type.
	getPropagatingFlagsOfTypes := func(types []Type, excludeKinds TypeFlags) ObjectFlags {
		var result ObjectFlags = 0
		for _, type_ := range types {
			if excludeKinds == nil || !(type_.flags & excludeKinds) {
				result |= getObjectFlags(type_)
			}
		}
		return result & ObjectFlagsPropagatingFlags
	}
	tryCreateTypeReference := func(target GenericType, typeArguments *[]Type) Type {
		if some(typeArguments) && target == emptyGenericType {
			return unknownType
		}
		return createTypeReference(target, typeArguments)
	}
	createTypeReference := func(target GenericType, typeArguments *[]Type) TypeReference {
		id := getTypeListId(typeArguments)
		type_ := target.instantiations.get(id)
		if !type_ {
			type_ = createObjectType(ObjectFlagsReference, target.symbol) /* as TypeReference */
			target.instantiations.set(id, type_)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case typeArguments:
				type_.objectFlags |= getPropagatingFlagsOfTypes(typeArguments)
			default:
				type_.objectFlags |= 0
			}
			type_.target = target
			type_.resolvedTypeArguments = typeArguments
		}
		return type_
	}
	cloneTypeReference := func(source TypeReference) TypeReference {
		type_ := createTypeWithSymbol(source.flags, source.symbol) /* as TypeReference */
		type_.objectFlags = source.objectFlags
		type_.target = source.target
		type_.resolvedTypeArguments = source.resolvedTypeArguments
		return type_
	}
	createDeferredTypeReference := func(target GenericType, node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) DeferredTypeReference {
		if !aliasSymbol {
			aliasSymbol = getAliasSymbolForTypeNode(node)
			localAliasTypeArguments := getTypeArgumentsForAliasSymbol(aliasSymbol)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case mapper:
				aliasTypeArguments = instantiateTypes(localAliasTypeArguments, mapper)
			default:
				aliasTypeArguments = localAliasTypeArguments
			}
		}
		type_ := createObjectType(ObjectFlagsReference, target.symbol) /* as DeferredTypeReference */
		type_.target = target
		type_.node = node
		type_.mapper = mapper
		type_.aliasSymbol = aliasSymbol
		type_.aliasTypeArguments = aliasTypeArguments
		return type_
	}
	getTypeArguments := func(type_ TypeReference) []Type {
		if !type_.resolvedTypeArguments {
			if !pushTypeResolution(type_, TypeSystemPropertyNameResolvedTypeArguments) {
				return concatenate(type_.target.outerTypeParameters, type_.target.localTypeParameters. /* TODO(TS-TO-GO): was ? */ map_(func() IntrinsicType {
					return errorType
				})) || emptyArray
			}
			node := type_.node
			var typeArguments []Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !node:
				typeArguments = emptyArray
			case node.kind == SyntaxKindTypeReference:
				typeArguments = concatenate(type_.target.outerTypeParameters, getEffectiveTypeArguments(node, type_.target.localTypeParameters))
			case node.kind == SyntaxKindArrayType:
				typeArguments = []Type{getTypeFromTypeNode(node.elementType)}
			default:
				typeArguments = map_(node.elements, getTypeFromTypeNode)
			}
			if popTypeResolution() {
				/* TODO(TS-TO-GO) Node BinaryExpression: type.resolvedTypeArguments ??= type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments */ TODO
			} else {
				/* TODO(TS-TO-GO) Node BinaryExpression: type.resolvedTypeArguments ??= concatenate(type.target.outerTypeParameters, type.target.localTypeParameters?.map(() => errorType) || emptyArray) */ TODO
				error(type_.node || currentNode, __COND__(type_.target.symbol, Diagnostics.Type_arguments_for_0_circularly_reference_themselves, Diagnostics.Tuple_type_arguments_circularly_reference_themselves), type_.target.symbol && symbolToString(type_.target.symbol))
			}
		}
		return type_.resolvedTypeArguments
	}
	getTypeReferenceArity := func(type_ TypeReference) number {
		return length(type_.target.typeParameters)
	}
	/**
	 * Get type from type-reference that reference to class or interface
	 */
	getTypeFromClassOrInterfaceReference := func(node NodeWithTypeArguments, symbol Symbol) Type {
		type_ := getDeclaredTypeOfSymbol(getMergedSymbol(symbol)) /* as InterfaceType */
		typeParameters := type_.localTypeParameters
		if typeParameters {
			numTypeArguments := length(node.typeArguments)
			minTypeArgumentCount := getMinTypeArgumentCount(typeParameters)
			isJs := isInJSFile(node)
			isJsImplicitAny := !noImplicitAny && isJs
			if !isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
				missingAugmentsTag := isJs && isExpressionWithTypeArguments(node) && !isJSDocAugmentsTag(node.parent)
				var diag DiagnosticMessage
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case minTypeArgumentCount == typeParameters.length:
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case missingAugmentsTag:
						diag = Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag
					default:
						diag = Diagnostics.Generic_type_0_requires_1_type_argument_s
					}
				case missingAugmentsTag:
					diag = Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag
				default:
					diag = Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments
				}
				typeStr := typeToString(type_ /*enclosingDeclaration*/, nil, TypeFormatFlagsWriteArrayAsGenericType)
				error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length)
				if !isJs {
					// TODO: Adopt same permissive behavior in TS as in JS to reduce follow-on editing experience failures (requires editing fillMissingTypeArguments)
					return errorType
				}
			}
			if node.kind == SyntaxKindTypeReference && isDeferredTypeReferenceNode(node /* as TypeReferenceNode */, length(node.typeArguments) != typeParameters.length) {
				return createDeferredTypeReference(type_ /* as GenericType */, node /* as TypeReferenceNode */ /*mapper*/, nil)
			}
			// In a type reference, the outer type parameters of the referenced class or interface are automatically
			// supplied as type arguments and the type reference only specifies arguments for the local type parameters
			// of the class or interface.
			typeArguments := concatenate(type_.outerTypeParameters, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs))
			return createTypeReference(type_ /* as GenericType */, typeArguments)
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case checkNoTypeArguments(node, symbol):
			return type_
		default:
			return errorType
		}
	}
	getTypeAliasInstantiation := func(symbol Symbol, typeArguments *[]Type, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		type_ := getDeclaredTypeOfSymbol(symbol)
		if type_ == intrinsicMarkerType {
			typeKind := intrinsicTypeKinds.get(symbol.escapedName /* as string */)
			if typeKind != nil && typeArguments && typeArguments.length == 1 {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case typeKind == IntrinsicTypeKindNoInfer:
					return getNoInferType(typeArguments[0])
				default:
					return getStringMappingType(symbol, typeArguments[0])
				}
			}
		}
		links := getSymbolLinks(symbol)
		typeParameters := links.typeParameters
		id := getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments)
		instantiation := links.instantiations.get(id)
		if !instantiation {
			links.instantiations.set(id /* TODO(TS-TO-GO) Node BinaryExpression: instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments) */, TODO)
		}
		return instantiation
	}
	/**
	 * Get type from reference to type alias. When a type alias is generic, the declared type of the type alias may include
	 * references to the type parameters of the alias. We replace those with the actual type arguments by instantiating the
	 * declared type. Instantiations are cached using the type identities of the type arguments as the key.
	 */
	getTypeFromTypeAliasReference := func(node NodeWithTypeArguments, symbol Symbol) Type {
		if getCheckFlags(symbol) & CheckFlagsUnresolved {
			typeArguments := typeArgumentsFromTypeReferenceNode(node)
			id := getAliasId(symbol, typeArguments)
			errorType := errorTypes.get(id)
			if !errorType {
				errorType = createIntrinsicType(TypeFlagsAny, "error" /*objectFlags*/, nil, __TEMPLATE__("alias ", id))
				errorType.aliasSymbol = symbol
				errorType.aliasTypeArguments = typeArguments
				errorTypes.set(id, errorType)
			}
			return errorType
		}
		type_ := getDeclaredTypeOfSymbol(symbol)
		typeParameters := getSymbolLinks(symbol).typeParameters
		if typeParameters {
			numTypeArguments := length(node.typeArguments)
			minTypeArgumentCount := getMinTypeArgumentCount(typeParameters)
			if numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length {
				error(node, __COND__(minTypeArgumentCount == typeParameters.length, Diagnostics.Generic_type_0_requires_1_type_argument_s, Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments), symbolToString(symbol), minTypeArgumentCount, typeParameters.length)
				return errorType
			}
			// We refrain from associating a local type alias with an instantiation of a top-level type alias
			// because the local alias may end up being referenced in an inferred return type where it is not
			// accessible--which in turn may lead to a large structural expansion of the type when generating
			// a .d.ts file. See #43622 for an example.
			aliasSymbol := getAliasSymbolForTypeNode(node)
			var newAliasSymbol Symbol
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(aliasSymbol)):
				newAliasSymbol = aliasSymbol
			default:
				newAliasSymbol = nil
			}
			var aliasTypeArguments *[]Type
			if newAliasSymbol {
				aliasTypeArguments = getTypeArgumentsForAliasSymbol(newAliasSymbol)
			} else if isTypeReferenceType(node) {
				aliasSymbol := resolveTypeReferenceName(node, SymbolFlagsAlias /*ignoreErrors*/, true)
				// refers to an alias import/export/reexport - by making sure we use the target as an aliasSymbol,
				// we ensure the exported symbol is used to refer to the type when it's reserialized later
				if aliasSymbol && aliasSymbol != unknownSymbol {
					resolved := resolveAlias(aliasSymbol)
					if resolved && resolved.flags&SymbolFlagsTypeAlias {
						newAliasSymbol = resolved
						aliasTypeArguments = typeArgumentsFromTypeReferenceNode(node) || (__COND__(typeParameters, []never{}, nil))
					}
				}
			}
			return getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, aliasTypeArguments)
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case checkNoTypeArguments(node, symbol):
			return type_
		default:
			return errorType
		}
	}
	isLocalTypeAlias := func(symbol Symbol) bool {
		declaration := symbol.declarations. /* TODO(TS-TO-GO): was ? */ find(isTypeAlias)
		return !!(declaration && getContainingFunction(declaration))
	}
	getTypeReferenceName := func(node TypeReferenceType) *EntityNameOrEntityNameExpression {
		switch node.kind {
		case SyntaxKindTypeReference:
			return node.typeName
		case SyntaxKindExpressionWithTypeArguments:
			expr := node.expression
			if isEntityNameExpression(expr) {
				return expr
			}
		}
		return nil
	}
	getSymbolPath := func(symbol Symbol) string {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol.parent:
			return __TEMPLATE__(getSymbolPath(symbol.parent), ".", symbol.escapedName)
		default:
			return symbol.escapedName /* as string */
		}
	}
	getUnresolvedSymbolForEntityName := func(name EntityNameOrEntityNameExpression) TransientSymbol {
		var identifier Identifier
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case name.kind == SyntaxKindQualifiedName:
			identifier = name.right
		case name.kind == SyntaxKindPropertyAccessExpression:
			identifier = name.name
		default:
			identifier = name
		}
		text := identifier.escapedText
		if text {
			var parentSymbol *TransientSymbol
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case name.kind == SyntaxKindQualifiedName:
				parentSymbol = getUnresolvedSymbolForEntityName(name.left)
			case name.kind == SyntaxKindPropertyAccessExpression:
				parentSymbol = getUnresolvedSymbolForEntityName(name.expression)
			default:
				parentSymbol = nil
			}
			var path string
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case parentSymbol:
				path = __TEMPLATE__(getSymbolPath(parentSymbol), ".", text)
			default:
				path = text /* as string */
			}
			result := unresolvedSymbols.get(path)
			if !result {
				unresolvedSymbols.set(path /* TODO(TS-TO-GO) Node BinaryExpression: result = createSymbol(SymbolFlags.TypeAlias, text, CheckFlags.Unresolved) */, TODO)
				result.parent = parentSymbol
				result.links.declaredType = unresolvedType
			}
			return result
		}
		return unknownSymbol
	}
	resolveTypeReferenceName := func(typeReference TypeReferenceType, meaning SymbolFlags, ignoreErrors bool) Symbol {
		name := getTypeReferenceName(typeReference)
		if !name {
			return unknownSymbol
		}
		symbol := resolveEntityName(name, meaning, ignoreErrors)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol && symbol != unknownSymbol:
			return symbol
		case ignoreErrors:
			return unknownSymbol
		default:
			return getUnresolvedSymbolForEntityName(name)
		}
	}
	getTypeReferenceType := func(node NodeWithTypeArguments, symbol Symbol) Type {
		if symbol == unknownSymbol {
			return errorType
		}
		symbol = getExpandoSymbol(symbol) || symbol
		if symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
			return getTypeFromClassOrInterfaceReference(node, symbol)
		}
		if symbol.flags & SymbolFlagsTypeAlias {
			return getTypeFromTypeAliasReference(node, symbol)
		}
		// Get type from reference to named type that cannot be generic (enum or type parameter)
		res := tryGetDeclaredTypeOfSymbol(symbol)
		if res {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case checkNoTypeArguments(node, symbol):
				return getRegularTypeOfLiteralType(res)
			default:
				return errorType
			}
		}
		if symbol.flags&SymbolFlagsValue && isJSDocTypeReference(node) {
			jsdocType := getTypeFromJSDocValueReference(node, symbol)
			if jsdocType {
				return jsdocType
			} else {
				// Resolve the type reference as a Type for the purpose of reporting errors.
				resolveTypeReferenceName(node, SymbolFlagsType)
				return getTypeOfSymbol(symbol)
			}
		}
		return errorType
	}
	/**
	 * A JSdoc TypeReference may be to a value, but resolve it as a type anyway.
	 * Example: import('./b').ConstructorFunction
	 */
	getTypeFromJSDocValueReference := func(node NodeWithTypeArguments, symbol Symbol) Type {
		links := getNodeLinks(node)
		if !links.resolvedJSDocType {
			valueType := getTypeOfSymbol(symbol)
			typeType := valueType
			if symbol.valueDeclaration {
				isImportTypeWithQualifier := node.kind == SyntaxKindImportType && (node /* as ImportTypeNode */).qualifier
				// valueType might not have a symbol, eg, {import('./b').STRING_LITERAL}
				if valueType.symbol && valueType.symbol != symbol && isImportTypeWithQualifier {
					typeType = getTypeReferenceType(node, valueType.symbol)
				}
			}
			links.resolvedJSDocType = typeType
		}
		return links.resolvedJSDocType
	}
	getNoInferType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isNoInferTargetType(type_):
			return getOrCreateSubstitutionType(type_, unknownType)
		default:
			return type_
		}
	}
	isNoInferTargetType := func(type_ Type) bool {
		// This is effectively a more conservative and predictable form of couldContainTypeVariables. We want to
		// preserve NoInfer<T> only for types that could contain type variables, but we don't want to exhaustively
		// examine all object type members.
		return !!(type_.flags&TypeFlagsUnionOrIntersection && some((type_ /* as UnionOrIntersectionType */).types, isNoInferTargetType) || type_.flags&TypeFlagsSubstitution && !isNoInferType(type_) && isNoInferTargetType((type_ /* as SubstitutionType */).baseType) || type_.flags&TypeFlagsObject && !isEmptyAnonymousObjectType(type_) || type_.flags&(TypeFlagsInstantiable&~TypeFlagsSubstitution) && !isPatternLiteralType(type_))
	}
	isNoInferType := func(type_ Type) bool {
		// A NoInfer<T> type is represented as a substitution type with a TypeFlags.Unknown constraint.
		return !!(type_.flags&TypeFlagsSubstitution && (type_ /* as SubstitutionType */).constraint.flags&TypeFlagsUnknown)
	}
	getSubstitutionType := func(baseType Type, constraint Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case constraint.flags&TypeFlagsAnyOrUnknown || constraint == baseType || baseType.flags&TypeFlagsAny:
			return baseType
		default:
			return getOrCreateSubstitutionType(baseType, constraint)
		}
	}
	getOrCreateSubstitutionType := func(baseType Type, constraint Type) SubstitutionType {
		id := __TEMPLATE__(getTypeId(baseType), ">", getTypeId(constraint))
		cached := substitutionTypes.get(id)
		if cached {
			return cached
		}
		result := createType(TypeFlagsSubstitution) /* as SubstitutionType */
		result.baseType = baseType
		result.constraint = constraint
		substitutionTypes.set(id, result)
		return result
	}
	getSubstitutionIntersection := func(substitutionType SubstitutionType) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isNoInferType(substitutionType):
			return substitutionType.baseType
		default:
			return getIntersectionType([]Type{substitutionType.constraint, substitutionType.baseType})
		}
	}
	isUnaryTupleTypeNode := func(node TypeNode) bool {
		return node.kind == SyntaxKindTupleType && (node /* as TupleTypeNode */).elements.length == 1
	}
	getImpliedConstraint := func(type_ Type, checkNode TypeNode, extendsNode TypeNode) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode):
			return getImpliedConstraint(type_, (checkNode /* as TupleTypeNode */).elements[0], (extendsNode /* as TupleTypeNode */).elements[0])
		case getActualTypeVariable(getTypeFromTypeNode(checkNode)) == getActualTypeVariable(type_):
			return getTypeFromTypeNode(extendsNode)
		default:
			return nil
		}
	}
	getConditionalFlowTypeOfType := func(type_ Type, node Node) Type {
		var constraints *[]Type
		covariant := true
		for node && !isStatement(node) && node.kind != SyntaxKindJSDoc {
			parent := node.parent
			// only consider variance flipped by parameter locations - `keyof` types would usually be considered variance inverting, but
			// often get used in indexed accesses where they behave sortof invariantly, but our checking is lax
			if parent.kind == SyntaxKindParameter {
				covariant = !covariant
			}
			// Always substitute on type parameters, regardless of variance, since even
			// in contravariant positions, they may rely on substituted constraints to be valid
			if (covariant || type_.flags&TypeFlagsTypeVariable) && parent.kind == SyntaxKindConditionalType && node == (parent /* as ConditionalTypeNode */).trueType {
				constraint := getImpliedConstraint(type_, (parent /* as ConditionalTypeNode */).checkType, (parent /* as ConditionalTypeNode */).extendsType)
				if constraint {
					constraints = append(constraints, constraint)
				}
			} else if type_.flags&TypeFlagsTypeParameter && parent.kind == SyntaxKindMappedType && !(parent /* as MappedTypeNode */).nameType && node == (parent /* as MappedTypeNode */).type_ {
				mappedType := getTypeFromTypeNode(parent /* as TypeNode */) /* as MappedType */
				if getTypeParameterFromMappedType(mappedType) == getActualTypeVariable(type_) {
					typeParameter := getHomomorphicTypeVariable(mappedType)
					if typeParameter {
						constraint := getConstraintOfTypeParameter(typeParameter)
						if constraint && everyType(constraint, isArrayOrTupleType) {
							constraints = append(constraints, getUnionType([]Type{numberType, numericStringType}))
						}
					}
				}
			}
			node = parent
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case constraints:
			return getSubstitutionType(type_, getIntersectionType(constraints))
		default:
			return type_
		}
	}
	isJSDocTypeReference := func(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is TypeReferenceNode */ any {
		return !!(node.flags & NodeFlagsJSDoc) && (node.kind == SyntaxKindTypeReference || node.kind == SyntaxKindImportType)
	}
	checkNoTypeArguments := func(node NodeWithTypeArguments, symbol Symbol) bool {
		if node.typeArguments {
			error(node, Diagnostics.Type_0_is_not_generic, __COND__(symbol, symbolToString(symbol), __COND__((node /* as TypeReferenceNode */).typeName, declarationNameToString((node /* as TypeReferenceNode */).typeName), anon)))
			return false
		}
		return true
	}
	getIntendedTypeFromJSDocTypeReference := func(node TypeReferenceNode) Type {
		if isIdentifier(node.typeName) {
			typeArgs := node.typeArguments
			switch node.typeName.escapedText {
			case "String":
				checkNoTypeArguments(node)
				return stringType
			case "Number":
				checkNoTypeArguments(node)
				return numberType
			case "Boolean":
				checkNoTypeArguments(node)
				return booleanType
			case "Void":
				checkNoTypeArguments(node)
				return voidType
			case "Undefined":
				checkNoTypeArguments(node)
				return undefinedType
			case "Null":
				checkNoTypeArguments(node)
				return nullType
			case "Function":
				fallthrough // TODO(TS-TO-GO): merge cases
			case "function":
				checkNoTypeArguments(node)
				return globalFunctionType
			case "array":
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case (!typeArgs || !typeArgs.length) && !noImplicitAny:
					return anyArrayType
				default:
					return nil
				}
			case "promise":
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case (!typeArgs || !typeArgs.length) && !noImplicitAny:
					return createPromiseType(anyType)
				default:
					return nil
				}
			case "Object":
				if typeArgs && typeArgs.length == 2 {
					if isJSDocIndexSignature(node) {
						indexed := getTypeFromTypeNode(typeArgs[0])
						target := getTypeFromTypeNode(typeArgs[1])
						var indexInfo []IndexInfo
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case indexed == stringType || indexed == numberType:
							indexInfo = []IndexInfo{createIndexInfo(indexed, target /*isReadonly*/, false)}
						default:
							indexInfo = emptyArray
						}
						return createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, indexInfo)
					}
					return anyType
				}
				checkNoTypeArguments(node)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case !noImplicitAny:
					return anyType
				default:
					return nil
				}
			}
		}
	}
	getTypeFromJSDocNullableTypeNode := func(node JSDocNullableType) Type {
		type_ := getTypeFromTypeNode(node.type_)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case strictNullChecks:
			return getNullableType(type_, TypeFlagsNull)
		default:
			return type_
		}
	}
	getTypeFromTypeReference := func(node TypeReferenceType) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			// handle LS queries on the `const` in `x as const` by resolving to the type of `x`
			if isConstTypeReference(node) && isAssertionExpression(node.parent) {
				links.resolvedSymbol = unknownSymbol
				links.resolvedType = checkExpressionCached(node.parent.expression)
				return links.resolvedType
			}
			var symbol Symbol
			var type_ Type
			meaning := SymbolFlagsType
			if isJSDocTypeReference(node) {
				type_ = getIntendedTypeFromJSDocTypeReference(node)
				if !type_ {
					symbol = resolveTypeReferenceName(node, meaning /*ignoreErrors*/, true)
					if symbol == unknownSymbol {
						symbol = resolveTypeReferenceName(node, meaning|SymbolFlagsValue)
					} else {
						resolveTypeReferenceName(node, meaning)
						// Resolve again to mark errors, if any
					}
					type_ = getTypeReferenceType(node, symbol)
				}
			}
			if !type_ {
				symbol = resolveTypeReferenceName(node, meaning)
				type_ = getTypeReferenceType(node, symbol)
			}
			// Cache both the resolved symbol and the resolved type. The resolved symbol is needed when we check the
			// type reference in checkTypeReferenceNode.
			links.resolvedSymbol = symbol
			links.resolvedType = type_
		}
		return links.resolvedType
	}
	typeArgumentsFromTypeReferenceNode := func(node NodeWithTypeArguments) *[]Type {
		return map_(node.typeArguments, getTypeFromTypeNode)
	}
	getTypeFromTypeQueryNode := func(node TypeQueryNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			// TypeScript 1.0 spec (April 2014): 3.6.3
			// The expression is processed as an identifier expression (section 4.3)
			// or property access expression(section 4.10),
			// the widened type(section 3.9) of which becomes the result.
			type_ := checkExpressionWithTypeArguments(node)
			links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(type_))
		}
		return links.resolvedType
	}
	getTypeOfGlobalSymbol := func(symbol Symbol, arity number) ObjectType {
		getTypeDeclaration := func(symbol Symbol) Declaration {
			declarations := symbol.declarations
			if declarations {
				for _, declaration := range declarations {
					switch declaration.kind {
					case SyntaxKindClassDeclaration:
						fallthrough // TODO(TS-TO-GO): merge cases
					case SyntaxKindInterfaceDeclaration:
						fallthrough // TODO(TS-TO-GO): merge cases
					case SyntaxKindEnumDeclaration:
						return declaration
					}
				}
			}
		}
		if !symbol {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case arity:
				return emptyGenericType
			default:
				return emptyObjectType
			}
		}
		type_ := getDeclaredTypeOfSymbol(symbol)
		if !(type_.flags & TypeFlagsObject) {
			error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_be_a_class_or_interface_type, symbolName(symbol))
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case arity:
				return emptyGenericType
			default:
				return emptyObjectType
			}
		}
		if length((type_ /* as InterfaceType */).typeParameters) != arity {
			error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case arity:
				return emptyGenericType
			default:
				return emptyObjectType
			}
		}
		return type_ /* as ObjectType */
	}
	getGlobalValueSymbol := func(name __String, reportErrors bool) Symbol {
		return getGlobalSymbol(name, SymbolFlagsValue, __COND__(reportErrors, Diagnostics.Cannot_find_global_value_0, nil))
	}
	getGlobalTypeSymbol := func(name __String, reportErrors bool) Symbol {
		return getGlobalSymbol(name, SymbolFlagsType, __COND__(reportErrors, Diagnostics.Cannot_find_global_type_0, nil))
	}
	getGlobalTypeAliasSymbol := func(name __String, arity number, reportErrors bool) Symbol {
		symbol := getGlobalSymbol(name, SymbolFlagsType, __COND__(reportErrors, Diagnostics.Cannot_find_global_type_0, nil))
		if symbol {
			// Resolve the declared type of the symbol. This resolves type parameters for the type
			// alias so that we can check arity.
			getDeclaredTypeOfSymbol(symbol)
			if length(getSymbolLinks(symbol).typeParameters) != arity {
				decl := symbol.declarations && find(symbol.declarations, isTypeAliasDeclaration)
				error(decl, Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity)
				return nil
			}
		}
		return symbol
	}
	getGlobalSymbol := func(name __String, meaning SymbolFlags, diagnostic *DiagnosticMessage) Symbol {
		// Don't track references for global symbols anyway, so value if `isReference` is arbitrary
		return resolveName(nil, name, meaning, diagnostic /*isUse*/, false /*excludeGlobals*/, false)
	}
	/* TODO(TS-TO-GO): function getGlobalType(name: __String, arity: 0, reportErrors: true): ObjectType; */
	/* TODO(TS-TO-GO): function getGlobalType(name: __String, arity: 0, reportErrors: boolean): ObjectType | undefined; */
	/* TODO(TS-TO-GO): function getGlobalType(name: __String, arity: number, reportErrors: true): GenericType; */
	/* TODO(TS-TO-GO): function getGlobalType(name: __String, arity: number, reportErrors: boolean): GenericType | undefined; */
	getGlobalType := func(name __String, arity number, reportErrors bool) *ObjectType {
		symbol := getGlobalTypeSymbol(name, reportErrors)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol || reportErrors:
			return getTypeOfGlobalSymbol(symbol, arity)
		default:
			return nil
		}
	}
	/* TODO(TS-TO-GO): function getGlobalBuiltinTypes(typeNames: readonly string[], arity: 0): ObjectType[]; */
	/* TODO(TS-TO-GO): function getGlobalBuiltinTypes(typeNames: readonly string[], arity: number): GenericType[]; */
	getGlobalBuiltinTypes := func(typeNames []string, arity number) []Type {
		var types *[]Type
		for _, typeName := range typeNames {
			types = append(types, getGlobalType(typeName /* as __String */, arity /*reportErrors*/, false))
		}
		return /* TODO(TS-TO-GO) Node BinaryExpression: types ?? emptyArray */ TODO
	}
	getGlobalTypedPropertyDescriptorType := func() GenericType {
		// We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
		return /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalTypedPropertyDescriptorType ||= getGlobalType("TypedPropertyDescriptor" as __String, /*arity* / 1, /*reportErrors* / true) || emptyGenericType */ TODO
	}
	getGlobalTemplateStringsArrayType := func() ObjectType {
		// We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
		return /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalTemplateStringsArrayType ||= getGlobalType("TemplateStringsArray" as __String, /*arity* / 0, /*reportErrors* / true) || emptyObjectType */ TODO
	}
	getGlobalImportMetaType := func() ObjectType {
		// We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
		return /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalImportMetaType ||= getGlobalType("ImportMeta" as __String, /*arity* / 0, /*reportErrors* / true) || emptyObjectType */ TODO
	}
	getGlobalImportMetaExpressionType := func() ObjectType {
		if !deferredGlobalImportMetaExpressionType {
			// Create a synthetic type `ImportMetaExpression { meta: MetaProperty }`
			symbol := createSymbol(SymbolFlagsNone, "ImportMetaExpression" /* as __String */)
			importMetaType := getGlobalImportMetaType()
			metaPropertySymbol := createSymbol(SymbolFlagsProperty, "meta" /* as __String */, CheckFlagsReadonly)
			metaPropertySymbol.parent = symbol
			metaPropertySymbol.links.type_ = importMetaType
			members := createSymbolTable([]TransientSymbol{metaPropertySymbol})
			symbol.members = members
			deferredGlobalImportMetaExpressionType = createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
		}
		return deferredGlobalImportMetaExpressionType
	}
	getGlobalImportCallOptionsType := func(reportErrors bool) ObjectType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalImportCallOptionsType ||= getGlobalType("ImportCallOptions" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalImportAttributesType := func(reportErrors bool) ObjectType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalImportAttributesType ||= getGlobalType("ImportAttributes" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalESSymbolConstructorSymbol := func(reportErrors bool) Symbol {
		return /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalESSymbolConstructorSymbol ||= getGlobalValueSymbol("Symbol" as __String, reportErrors) */ TODO
	}
	getGlobalESSymbolConstructorTypeSymbol := func(reportErrors bool) Symbol {
		return /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalESSymbolConstructorTypeSymbol ||= getGlobalTypeSymbol("SymbolConstructor" as __String, reportErrors) */ TODO
	}
	getGlobalESSymbolType := func() ObjectType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalESSymbolType ||= getGlobalType("Symbol" as __String, /*arity* / 0, /*reportErrors* / false) */ TODO) || emptyObjectType
	}
	getGlobalPromiseType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalPromiseType ||= getGlobalType("Promise" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalPromiseLikeType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalPromiseLikeType ||= getGlobalType("PromiseLike" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalPromiseConstructorSymbol := func(reportErrors bool) Symbol {
		return /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalPromiseConstructorSymbol ||= getGlobalValueSymbol("Promise" as __String, reportErrors) */ TODO
	}
	getGlobalPromiseConstructorLikeType := func(reportErrors bool) ObjectType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalPromiseConstructorLikeType ||= getGlobalType("PromiseConstructorLike" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalAsyncIterableType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalAsyncIterableType ||= getGlobalType("AsyncIterable" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalAsyncIteratorType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalAsyncIteratorType ||= getGlobalType("AsyncIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalAsyncIterableIteratorType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalAsyncIterableIteratorType ||= getGlobalType("AsyncIterableIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalBuiltinAsyncIteratorTypes := func() []GenericType {
		// NOTE: This list does not include all built-in async iterator types, only those that are likely to be encountered frequently.
		return /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalBuiltinAsyncIteratorTypes ??= getGlobalBuiltinTypes(["ReadableStreamAsyncIterator"], 1) */ TODO
	}
	getGlobalAsyncIteratorObjectType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalAsyncIteratorObjectType ||= getGlobalType("AsyncIteratorObject" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalAsyncGeneratorType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalAsyncGeneratorType ||= getGlobalType("AsyncGenerator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIterableType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalIterableType ||= getGlobalType("Iterable" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIteratorType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalIteratorType ||= getGlobalType("Iterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIterableIteratorType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalIterableIteratorType ||= getGlobalType("IterableIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getBuiltinIteratorReturnType := func() IntrinsicType {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case strictBuiltinIteratorReturn:
			return undefinedType
		default:
			return anyType
		}
	}
	getGlobalBuiltinIteratorTypes := func() []GenericType {
		// NOTE: This list does not include all built-in iterator types, only those that are likely to be encountered frequently.
		return /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalBuiltinIteratorTypes ??= getGlobalBuiltinTypes(["ArrayIterator", "MapIterator", "SetIterator", "StringIterator"], 1) */ TODO
	}
	getGlobalIteratorObjectType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalIteratorObjectType ||= getGlobalType("IteratorObject" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalGeneratorType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalGeneratorType ||= getGlobalType("Generator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIteratorYieldResultType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalIteratorYieldResultType ||= getGlobalType("IteratorYieldResult" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIteratorReturnResultType := func(reportErrors bool) GenericType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalIteratorReturnResultType ||= getGlobalType("IteratorReturnResult" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalDisposableType := func(reportErrors bool) ObjectType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalDisposableType ||= getGlobalType("Disposable" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalAsyncDisposableType := func(reportErrors bool) ObjectType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalAsyncDisposableType ||= getGlobalType("AsyncDisposable" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalTypeOrUndefined := func(name __String, arity number /*  = 0 */) *ObjectType {
		symbol := getGlobalSymbol(name, SymbolFlagsType /*diagnostic*/, nil)
		return symbol && getTypeOfGlobalSymbol(symbol, arity) /* as GenericType */
	}
	getGlobalExtractSymbol := func() Symbol {
		// We always report an error, so cache a result in the event we could not resolve the symbol to prevent reporting it multiple times
		/* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalExtractSymbol ||= getGlobalTypeAliasSymbol("Extract" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol */
		TODO
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case deferredGlobalExtractSymbol == unknownSymbol:
			return nil
		default:
			return deferredGlobalExtractSymbol
		}
	}
	getGlobalOmitSymbol := func() Symbol {
		// We always report an error, so cache a result in the event we could not resolve the symbol to prevent reporting it multiple times
		/* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalOmitSymbol ||= getGlobalTypeAliasSymbol("Omit" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol */
		TODO
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case deferredGlobalOmitSymbol == unknownSymbol:
			return nil
		default:
			return deferredGlobalOmitSymbol
		}
	}
	getGlobalAwaitedSymbol := func(reportErrors bool) Symbol {
		// Only cache `unknownSymbol` if we are reporting errors so that we don't report the error more than once.
		/* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalAwaitedSymbol ||= getGlobalTypeAliasSymbol("Awaited" as __String, /*arity* / 1, reportErrors) || (reportErrors ? unknownSymbol : undefined) */
		TODO
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case deferredGlobalAwaitedSymbol == unknownSymbol:
			return nil
		default:
			return deferredGlobalAwaitedSymbol
		}
	}
	getGlobalBigIntType := func() ObjectType {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalBigIntType ||= getGlobalType("BigInt" as __String, /*arity* / 0, /*reportErrors* / false) */ TODO) || emptyObjectType
	}
	getGlobalClassDecoratorContextType := func(reportErrors bool) GenericType {
		return /* TODO(TS-TO-GO) Node BinaryExpression: (deferredGlobalClassDecoratorContextType ??= getGlobalType("ClassDecoratorContext" as __String, /*arity* / 1, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassMethodDecoratorContextType := func(reportErrors bool) GenericType {
		return /* TODO(TS-TO-GO) Node BinaryExpression: (deferredGlobalClassMethodDecoratorContextType ??= getGlobalType("ClassMethodDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassGetterDecoratorContextType := func(reportErrors bool) GenericType {
		return /* TODO(TS-TO-GO) Node BinaryExpression: (deferredGlobalClassGetterDecoratorContextType ??= getGlobalType("ClassGetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassSetterDecoratorContextType := func(reportErrors bool) GenericType {
		return /* TODO(TS-TO-GO) Node BinaryExpression: (deferredGlobalClassSetterDecoratorContextType ??= getGlobalType("ClassSetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorContextType := func(reportErrors bool) GenericType {
		return /* TODO(TS-TO-GO) Node BinaryExpression: (deferredGlobalClassAccessorDecoratorContextType ??= getGlobalType("ClassAccessorDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorTargetType := func(reportErrors bool) GenericType {
		return /* TODO(TS-TO-GO) Node BinaryExpression: (deferredGlobalClassAccessorDecoratorTargetType ??= getGlobalType("ClassAccessorDecoratorTarget" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorResultType := func(reportErrors bool) GenericType {
		return /* TODO(TS-TO-GO) Node BinaryExpression: (deferredGlobalClassAccessorDecoratorResultType ??= getGlobalType("ClassAccessorDecoratorResult" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassFieldDecoratorContextType := func(reportErrors bool) GenericType {
		return /* TODO(TS-TO-GO) Node BinaryExpression: (deferredGlobalClassFieldDecoratorContextType ??= getGlobalType("ClassFieldDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalNaNSymbol := func() Symbol {
		return ( /* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalNaNSymbol ||= getGlobalValueSymbol("NaN" as __String, /*reportErrors* / false) */ TODO)
	}
	getGlobalRecordSymbol := func() Symbol {
		/* TODO(TS-TO-GO) Node BinaryExpression: deferredGlobalRecordSymbol ||= getGlobalTypeAliasSymbol("Record" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol */ TODO
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case deferredGlobalRecordSymbol == unknownSymbol:
			return nil
		default:
			return deferredGlobalRecordSymbol
		}
	}
	/**
	 * Instantiates a global type that is generic with some element type, and returns that instantiation.
	 */
	createTypeFromGenericGlobalType := func(genericGlobalType GenericType, typeArguments []Type) ObjectType {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case genericGlobalType != emptyGenericType:
			return createTypeReference(genericGlobalType, typeArguments)
		default:
			return emptyObjectType
		}
	}
	createTypedPropertyDescriptorType := func(propertyType Type) Type {
		return createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType(), []Type{propertyType})
	}
	createIterableType := func(iteratedType Type) Type {
		return createTypeFromGenericGlobalType(getGlobalIterableType(true), []Type{iteratedType, voidType, undefinedType})
	}
	createArrayType := func(elementType Type, readonly bool) ObjectType {
		return createTypeFromGenericGlobalType(__COND__(readonly, globalReadonlyArrayType, globalArrayType), []Type{elementType})
	}
	getTupleElementFlags := func(node TypeNode) /* TODO(TS-TO-GO) inferred type ElementFlags.Required | ElementFlags.Optional | ElementFlags.Rest | ElementFlags.Variadic */ any {
		switch node.kind {
		case SyntaxKindOptionalType:
			return ElementFlagsOptional
		case SyntaxKindRestType:
			return getRestTypeElementFlags(node /* as RestTypeNode */)
		case SyntaxKindNamedTupleMember:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (node /* as NamedTupleMember */).questionToken:
				return ElementFlagsOptional
			case (node /* as NamedTupleMember */).dotDotDotToken:
				return getRestTypeElementFlags(node /* as NamedTupleMember */)
			default:
				return ElementFlagsRequired
			}
		default:
			return ElementFlagsRequired
		}
	}
	getRestTypeElementFlags := func(node /* TODO(TS-TO-GO) TypeNode UnionType: RestTypeNode | NamedTupleMember */ any) /* TODO(TS-TO-GO) inferred type ElementFlags.Rest | ElementFlags.Variadic */ any {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getArrayElementTypeNode(node.type_):
			return ElementFlagsRest
		default:
			return ElementFlagsVariadic
		}
	}
	getArrayOrTupleTargetType := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ArrayTypeNode | TupleTypeNode */ any) GenericType {
		readonly := isReadonlyTypeOperator(node.parent)
		elementType := getArrayElementTypeNode(node)
		if elementType {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case readonly:
				return globalReadonlyArrayType
			default:
				return globalArrayType
			}
		}
		elementFlags := map_((node /* as TupleTypeNode */).elements, getTupleElementFlags)
		return getTupleTargetType(elementFlags, readonly, map_((node /* as TupleTypeNode */).elements, memberIfLabeledElementDeclaration))
	}
	memberIfLabeledElementDeclaration := func(member Node) /* TODO(TS-TO-GO) TypeNode UnionType: NamedTupleMember | ParameterDeclaration | undefined */ any {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isNamedTupleMember(member) || isParameter(member):
			return member
		default:
			return nil
		}
	}
	// Return true if the given type reference node is directly aliased or if it needs to be deferred
	// because it is possibly contained in a circular chain of eagerly resolved types.
	isDeferredTypeReferenceNode := func(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, hasDefaultTypeArguments bool) bool {
		return !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && (__COND__(node.kind == SyntaxKindArrayType, mayResolveTypeAlias(node.elementType), __COND__(node.kind == SyntaxKindTupleType, some(node.elements, mayResolveTypeAlias), hasDefaultTypeArguments || some(node.typeArguments, mayResolveTypeAlias))))
	}
	// Return true when the given node is transitively contained in type constructs that eagerly
	// resolve their constituent types. We include SyntaxKind.TypeReference because type arguments
	// of type aliases are eagerly resolved.
	isResolvedByTypeAlias := func(node Node) bool {
		parent := node.parent
		switch parent.kind {
		case SyntaxKindParenthesizedType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNamedTupleMember:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTypeReference:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindUnionType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindIntersectionType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindIndexedAccessType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindConditionalType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTypeOperator:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrayType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTupleType:
			return isResolvedByTypeAlias(parent)
		case SyntaxKindTypeAliasDeclaration:
			return true
		}
		return false
	}
	// Return true if resolving the given node (i.e. getTypeFromTypeNode) possibly causes resolution
	// of a type alias.
	mayResolveTypeAlias := func(node Node) bool {
		switch node.kind {
		case SyntaxKindTypeReference:
			return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(node /* as TypeReferenceNode */, SymbolFlagsType).flags & SymbolFlagsTypeAlias)
		case SyntaxKindTypeQuery:
			return true
		case SyntaxKindTypeOperator:
			return (node /* as TypeOperatorNode */).operator != SyntaxKindUniqueKeyword && mayResolveTypeAlias((node /* as TypeOperatorNode */).type_)
		case SyntaxKindParenthesizedType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindOptionalType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNamedTupleMember:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocOptionalType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocNullableType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocNonNullableType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocTypeExpression:
			return mayResolveTypeAlias((node /* as ParenthesizedTypeNode | OptionalTypeNode | JSDocTypeReferencingNode | NamedTupleMember */).type_)
		case SyntaxKindRestType:
			return (node /* as RestTypeNode */).type_.kind != SyntaxKindArrayType || mayResolveTypeAlias(((node /* as RestTypeNode */).type_ /* as ArrayTypeNode */).elementType)
		case SyntaxKindUnionType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindIntersectionType:
			return some((node /* as UnionOrIntersectionTypeNode */).types, mayResolveTypeAlias)
		case SyntaxKindIndexedAccessType:
			return mayResolveTypeAlias((node /* as IndexedAccessTypeNode */).objectType) || mayResolveTypeAlias((node /* as IndexedAccessTypeNode */).indexType)
		case SyntaxKindConditionalType:
			return mayResolveTypeAlias((node /* as ConditionalTypeNode */).checkType) || mayResolveTypeAlias((node /* as ConditionalTypeNode */).extendsType) || mayResolveTypeAlias((node /* as ConditionalTypeNode */).trueType) || mayResolveTypeAlias((node /* as ConditionalTypeNode */).falseType)
		}
		return false
	}
	getTypeFromArrayOrTupleTypeNode := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ArrayTypeNode | TupleTypeNode */ any) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			target := getArrayOrTupleTargetType(node)
			if target == emptyGenericType {
				links.resolvedType = emptyObjectType
			} else if !(node.kind == SyntaxKindTupleType && some(node.elements, func(e /* TODO(TS-TO-GO) inferred type TypeNode | NamedTupleMember */ any) bool {
				return !!(getTupleElementFlags(e) & ElementFlagsVariadic)
			})) && isDeferredTypeReferenceNode(node) {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case node.kind == SyntaxKindTupleType && node.elements.length == 0:
					links.resolvedType = target
				default:
					links.resolvedType = createDeferredTypeReference(target, node /*mapper*/, nil)
				}
			} else {
				var elementTypes []Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case node.kind == SyntaxKindArrayType:
					elementTypes = []Type{getTypeFromTypeNode(node.elementType)}
				default:
					elementTypes = map_(node.elements, getTypeFromTypeNode)
				}
				links.resolvedType = createNormalizedTypeReference(target, elementTypes)
			}
		}
		return links.resolvedType
	}
	isReadonlyTypeOperator := func(node Node) bool {
		return isTypeOperatorNode(node) && node.operator == SyntaxKindReadonlyKeyword
	}
	createTupleType := func(elementTypes []Type, elementFlags []ElementFlags, readonly bool /*  = false */, namedMemberDeclarations [] /* TODO(TS-TO-GO) TypeNode UnionType: NamedTupleMember | ParameterDeclaration | undefined */ any /*  = [] */) Type {
		tupleTarget := getTupleTargetType(elementFlags || map_(elementTypes, func(_ Type) /* TODO(TS-TO-GO) inferred type ElementFlags.Required */ any {
			return ElementFlagsRequired
		}), readonly, namedMemberDeclarations)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case tupleTarget == emptyGenericType:
			return emptyObjectType
		case elementTypes.length:
			return createNormalizedTypeReference(tupleTarget, elementTypes)
		default:
			return tupleTarget
		}
	}
	getTupleTargetType := func(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations [] /* TODO(TS-TO-GO) TypeNode UnionType: NamedTupleMember | ParameterDeclaration | undefined */ any) GenericType {
		if elementFlags.length == 1 && elementFlags[0]&ElementFlagsRest {
			// [...X[]] is equivalent to just X[]
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case readonly:
				return globalReadonlyArrayType
			default:
				return globalArrayType
			}
		}
		key := map_(elementFlags, func(f ElementFlags) /* TODO(TS-TO-GO) inferred type "*" | "?" | "#" | "." */ any {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case f & ElementFlagsRequired:
				return "#"
			case f & ElementFlagsOptional:
				return "?"
			case f & ElementFlagsRest:
				return "."
			default:
				return "*"
			}
		}).join() + (__COND__(readonly, "R", "")) + (__COND__(some(namedMemberDeclarations, func(node * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | NamedTupleMember */ any) bool {
			return !!node
		}), ","+map_(namedMemberDeclarations, func(node * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | NamedTupleMember */ any) /* TODO(TS-TO-GO) inferred type number | "_" */ any {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node:
				return getNodeId(node)
			default:
				return "_"
			}
		}).join(","), ""))
		type_ := tupleTypes.get(key)
		if !type_ {
			tupleTypes.set(key /* TODO(TS-TO-GO) Node BinaryExpression: type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations) */, TODO)
		}
		return type_
	}
	// We represent tuple types as type references to synthesized generic interface types created by
	// this function. The types are of the form:
	//
	//   interface Tuple<T0, T1, T2, ...> extends Array<T0 | T1 | T2 | ...> { 0: T0, 1: T1, 2: T2, ... }
	//
	// Note that the generic type created by this function has no symbol associated with it. The same
	// is true for each of the synthesized type parameters.
	createTupleTargetType := func(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations [] /* TODO(TS-TO-GO) TypeNode UnionType: NamedTupleMember | ParameterDeclaration | undefined */ any) TupleType {
		arity := elementFlags.length
		minLength := countWhere(elementFlags, func(f ElementFlags) bool {
			return !!(f & (ElementFlagsRequired | ElementFlagsVariadic))
		})
		var typeParameters *[]TypeParameter
		var properties []Symbol = []never{}
		combinedFlags := 0 /* as ElementFlags */
		if arity {
			typeParameters = NewArray(arity)
			for i := 0; i < arity; i++ {
				typeParameter := /* TODO(TS-TO-GO) Node BinaryExpression: typeParameters[i] = createTypeParameter() */ TODO
				flags := elementFlags[i]
				combinedFlags |= flags
				if !(combinedFlags & ElementFlagsVariable) {
					property := createSymbol(SymbolFlagsProperty|(__COND__(flags&ElementFlagsOptional, SymbolFlagsOptional, 0)), ""+i /* as __String */, __COND__(readonly, CheckFlagsReadonly, 0))
					property.links.tupleLabelDeclaration = namedMemberDeclarations[i]
					property.links.type_ = typeParameter
					properties.push(property)
				}
			}
		}
		fixedLength := properties.length
		lengthSymbol := createSymbol(SymbolFlagsProperty, "length" /* as __String */, __COND__(readonly, CheckFlagsReadonly, 0))
		if combinedFlags & ElementFlagsVariable {
			lengthSymbol.links.type_ = numberType
		} else {
			literalTypes := []never{}
			for i := minLength; i <= arity; i++ {
				literalTypes.push(getNumberLiteralType(i))
			}
			lengthSymbol.links.type_ = getUnionType(literalTypes)
		}
		properties.push(lengthSymbol)
		type_ := createObjectType(ObjectFlagsTuple | ObjectFlagsReference) /* as TupleType & InterfaceTypeWithDeclaredMembers */
		type_.typeParameters = typeParameters
		type_.outerTypeParameters = nil
		type_.localTypeParameters = typeParameters
		type_.instantiations = NewMap[string, TypeReference]()
		type_.instantiations.set(getTypeListId(type_.typeParameters), type_ /* as GenericType */)
		type_.target = type_ /* as GenericType */
		type_.resolvedTypeArguments = type_.typeParameters
		type_.thisType = createTypeParameter()
		type_.thisType.isThisType = true
		type_.thisType.constraint = type_
		type_.declaredProperties = properties
		type_.declaredCallSignatures = emptyArray
		type_.declaredConstructSignatures = emptyArray
		type_.declaredIndexInfos = emptyArray
		type_.elementFlags = elementFlags
		type_.minLength = minLength
		type_.fixedLength = fixedLength
		type_.hasRestElement = !!(combinedFlags & ElementFlagsVariable)
		type_.combinedFlags = combinedFlags
		type_.readonly = readonly
		type_.labeledElementDeclarations = namedMemberDeclarations
		return type_
	}
	createNormalizedTypeReference := func(target GenericType, typeArguments *[]Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case target.objectFlags & ObjectFlagsTuple:
			return createNormalizedTupleType(target /* as TupleType */, typeArguments)
		default:
			return createTypeReference(target, typeArguments)
		}
	}
	createNormalizedTupleType := func(target TupleType, elementTypes []Type) Type {
		if !(target.combinedFlags & ElementFlagsNonRequired) {
			// No need to normalize when we only have regular required elements
			return createTypeReference(target, elementTypes)
		}
		if target.combinedFlags & ElementFlagsVariadic {
			// Transform [A, ...(X | Y | Z)] into [A, ...X] | [A, ...Y] | [A, ...Z]
			unionIndex := findIndex(elementTypes, func(t Type, i number) bool {
				return !!(target.elementFlags[i]&ElementFlagsVariadic && t.flags&(TypeFlagsNever|TypeFlagsUnion))
			})
			if unionIndex >= 0 {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case checkCrossProductUnion(map_(elementTypes, func(t Type, i number) Type {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case target.elementFlags[i] & ElementFlagsVariadic:
						return t
					default:
						return unknownType
					}
				})):
					return mapType(elementTypes[unionIndex], func(t Type) Type {
						return createNormalizedTupleType(target, replaceElement(elementTypes, unionIndex, t))
					})
				default:
					return errorType
				}
			}
		}
		// We have optional, rest, or variadic elements that may need normalizing. Normalization ensures that all variadic
		// elements are generic and that the tuple type has one of the following layouts, disregarding variadic elements:
		// (1) Zero or more required elements, followed by zero or more optional elements, followed by zero or one rest element.
		// (2) Zero or more required elements, followed by a rest element, followed by zero or more required elements.
		// In either layout, zero or more generic variadic elements may be present at any location.
		var expandedTypes []Type = []never{}
		var expandedFlags []ElementFlags = []never{}
		var expandedDeclarations [] /* TODO(TS-TO-GO) TypeNode UnionType: NamedTupleMember | ParameterDeclaration | undefined */ any = []never{}
		lastRequiredIndex := -1
		firstRestIndex := -1
		lastOptionalOrRestIndex := -1
		for i := 0; i < elementTypes.length; i++ {
			type_ := elementTypes[i]
			flags := target.elementFlags[i]
			if flags & ElementFlagsVariadic {
				if type_.flags & TypeFlagsAny {
					addElement(type_, ElementFlagsRest, target.labeledElementDeclarations[i])
				} else if type_.flags&TypeFlagsInstantiableNonPrimitive || isGenericMappedType(type_) {
					// Generic variadic elements stay as they are.
					addElement(type_, ElementFlagsVariadic, target.labeledElementDeclarations[i])
				} else if isTupleType(type_) {
					elements := getElementTypes(type_)
					if elements.length+expandedTypes.length >= 10_000 {
						error(currentNode, __COND__(isPartOfTypeNode(currentNode), Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent, Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent))
						return errorType
					}
					// Spread variadic elements with tuple types into the resulting tuple.
					forEach(elements, func(t Type, n number) {
						return addElement(t, type_.target.elementFlags[n], type_.target.labeledElementDeclarations[n])
					})
				} else {
					// Treat everything else as an array type and create a rest element.
					addElement(isArrayLikeType(type_) && getIndexTypeOfType(type_, numberType) || errorType, ElementFlagsRest, target.labeledElementDeclarations[i])
				}
			} else {
				// Copy other element kinds with no change.
				addElement(type_, flags, target.labeledElementDeclarations[i])
			}
		}
		// Turn optional elements preceding the last required element into required elements
		for i := 0; i < lastRequiredIndex; i++ {
			if expandedFlags[i] & ElementFlagsOptional {
				expandedFlags[i] = ElementFlagsRequired
			}
		}
		if firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex {
			// Turn elements between first rest and last optional/rest into a single rest element
			expandedTypes[firstRestIndex] = getUnionType(sameMap(expandedTypes.slice(firstRestIndex, lastOptionalOrRestIndex+1), func(t Type, i number) Type {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case expandedFlags[firstRestIndex+i] & ElementFlagsVariadic:
					return getIndexedAccessType(t, numberType)
				default:
					return t
				}
			}))
			expandedTypes.splice(firstRestIndex+1, lastOptionalOrRestIndex-firstRestIndex)
			expandedFlags.splice(firstRestIndex+1, lastOptionalOrRestIndex-firstRestIndex)
			expandedDeclarations.splice(firstRestIndex+1, lastOptionalOrRestIndex-firstRestIndex)
		}
		tupleTarget := getTupleTargetType(expandedFlags, target.readonly, expandedDeclarations)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case tupleTarget == emptyGenericType:
			return emptyObjectType
		case expandedFlags.length:
			return createTypeReference(tupleTarget, expandedTypes)
		default:
			return tupleTarget
		}
		addElement := func(type_ Type, flags ElementFlags, declaration /* TODO(TS-TO-GO) TypeNode UnionType: NamedTupleMember | ParameterDeclaration | undefined */ any) {
			if flags & ElementFlagsRequired {
				lastRequiredIndex = expandedFlags.length
			}
			if flags&ElementFlagsRest && firstRestIndex < 0 {
				firstRestIndex = expandedFlags.length
			}
			if flags & (ElementFlagsOptional | ElementFlagsRest) {
				lastOptionalOrRestIndex = expandedFlags.length
			}
			expandedTypes.push(__COND__(flags&ElementFlagsOptional, addOptionality(type_ /*isProperty*/, true), type_))
			expandedFlags.push(flags)
			expandedDeclarations.push(declaration)
		}
	}
	sliceTupleType := func(type_ TupleTypeReference, index number, endSkipCount number /*  = 0 */) Type {
		target := type_.target
		endIndex := getTypeReferenceArity(type_) - endSkipCount
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case index > target.fixedLength:
			return getRestArrayTypeOfTupleType(type_) || createTupleType(emptyArray)
		default:
			return createTupleType(getTypeArguments(type_).slice(index, endIndex), target.elementFlags.slice(index, endIndex) /*readonly*/, false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex))
		}
	}
	getKnownKeysOfTupleType := func(type_ TupleTypeReference) Type {
		return getUnionType(append(arrayOf(type_.target.fixedLength, func(i number) StringLiteralType {
			return getStringLiteralType("" + i)
		}), getIndexType(__COND__(type_.target.readonly, globalReadonlyArrayType, globalArrayType))))
	}
	// Return count of starting consecutive tuple elements of the given kind(s)
	getStartElementCount := func(type_ TupleType, flags ElementFlags) number {
		index := findIndex(type_.elementFlags, func(f ElementFlags) bool {
			return !(f & flags)
		})
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case index >= 0:
			return index
		default:
			return type_.elementFlags.length
		}
	}
	// Return count of ending consecutive tuple elements of the given kind(s)
	getEndElementCount := func(type_ TupleType, flags ElementFlags) number {
		return type_.elementFlags.length - findLastIndex(type_.elementFlags, func(f ElementFlags) bool {
			return !(f & flags)
		}) - 1
	}
	getTotalFixedElementCount := func(type_ TupleType) number {
		return type_.fixedLength + getEndElementCount(type_, ElementFlagsFixed)
	}
	getElementTypes := func(type_ TupleTypeReference) []Type {
		typeArguments := getTypeArguments(type_)
		arity := getTypeReferenceArity(type_)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case typeArguments.length == arity:
			return typeArguments
		default:
			return typeArguments.slice(0, arity)
		}
	}
	getTypeFromOptionalTypeNode := func(node OptionalTypeNode) Type {
		return addOptionality(getTypeFromTypeNode(node.type_) /*isProperty*/, true)
	}
	getTypeId := func(type_ Type) TypeId {
		return type_.id
	}
	containsType := func(types []Type, type_ Type) bool {
		return binarySearch(types, type_, getTypeId, compareValues) >= 0
	}
	insertType := func(types []Type, type_ Type) bool {
		index := binarySearch(types, type_, getTypeId, compareValues)
		if index < 0 {
			types.splice(~index, 0, type_)
			return true
		}
		return false
	}
	addTypeToUnion := func(typeSet []Type, includes TypeFlags, type_ Type) TypeFlags {
		flags := type_.flags
		// We ignore 'never' types in unions
		if !(flags & TypeFlagsNever) {
			includes |= flags & TypeFlagsIncludesMask
			if flags & TypeFlagsInstantiable {
				includes |= TypeFlagsIncludesInstantiable
			}
			if flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
				includes |= TypeFlagsIncludesConstrainedTypeVariable
			}
			if type_ == wildcardType {
				includes |= TypeFlagsIncludesWildcard
			}
			if isErrorType(type_) {
				includes |= TypeFlagsIncludesError
			}
			if !strictNullChecks && flags&TypeFlagsNullable {
				if !(getObjectFlags(type_) & ObjectFlagsContainsWideningType) {
					includes |= TypeFlagsIncludesNonWideningType
				}
			} else {
				len := typeSet.length
				var index number
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case len && type_.id > typeSet[len-1].id:
					index = ~len
				default:
					index = binarySearch(typeSet, type_, getTypeId, compareValues)
				}
				if index < 0 {
					typeSet.splice(~index, 0, type_)
				}
			}
		}
		return includes
	}
	// Add the given types to the given type set. Order is preserved, duplicates are removed,
	// and nested types of the given kind are flattened into the set.
	addTypesToUnion := func(typeSet []Type, includes TypeFlags, types []Type) TypeFlags {
		var lastType Type
		for _, type_ := range types {
			// We skip the type if it is the same as the last type we processed. This simple test particularly
			// saves a lot of work for large lists of the same union type, such as when resolving `Record<A, B>[A]`,
			// where A and B are large union types.
			if type_ != lastType {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case type_.flags & TypeFlagsUnion:
					includes = addTypesToUnion(typeSet, includes|(__COND__(isNamedUnionType(type_), TypeFlagsUnion, 0)), (type_ /* as UnionType */).types)
				default:
					includes = addTypeToUnion(typeSet, includes, type_)
				}
				lastType = type_
			}
		}
		return includes
	}
	removeSubtypes := func(types []Type, hasObjectTypes bool) *[]Type {
		// [] and [T] immediately reduce to [] and [T] respectively
		if types.length < 2 {
			return types
		}
		id := getTypeListId(types)
		match := subtypeReductionCache.get(id)
		if match {
			return match
		}
		// We assume that redundant primitive types have already been removed from the types array and that there
		// are no any and unknown types in the array. Thus, the only possible supertypes for primitive types are empty
		// object types, and if none of those are present we can exclude primitive types from the subtype check.
		hasEmptyObject := hasObjectTypes && some(types, func(t Type) bool {
			return !!(t.flags & TypeFlagsObject) && !isGenericMappedType(t) && isEmptyResolvedType(resolveStructuredTypeMembers(t /* as ObjectType */))
		})
		len := types.length
		i := len
		count := 0
		for i > 0 {
			i--
			source := types[i]
			if hasEmptyObject || source.flags&TypeFlagsStructuredOrInstantiable {
				// A type parameter with a union constraint may be a subtype of some union, but not a subtype of the
				// individual constituents of that union. For example, `T extends A | B` is a subtype of `A | B`, but not
				// a subtype of just `A` or just `B`. When we encounter such a type parameter, we therefore check if the
				// type parameter is a subtype of a union of all the other types.
				if source.flags&TypeFlagsTypeParameter && getBaseConstraintOrType(source).flags&TypeFlagsUnion {
					if isTypeRelatedTo(source, getUnionType(map_(types, func(t Type) Type {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case t == source:
							return neverType
						default:
							return t
						}
					})), strictSubtypeRelation) {
						orderedRemoveItemAt(types, i)
					}
					continue
				}
				// Find the first property with a unit type, if any. When constituents have a property by the same name
				// but of a different unit type, we can quickly disqualify them from subtype checks. This helps subtype
				// reduction of large discriminated union types.
				var keyProperty Symbol
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case source.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsInstantiableNonPrimitive):
					keyProperty = find(getPropertiesOfType(source), func(p Symbol) bool {
						return isUnitType(getTypeOfSymbol(p))
					})
				default:
					keyProperty = nil
				}
				keyPropertyType := keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty))
				for _, target := range types {
					if source != target {
						if count == 100000 {
							// After 100000 subtype checks we estimate the remaining amount of work by assuming the
							// same ratio of checks per element. If the estimated number of remaining type checks is
							// greater than 1M we deem the union type too complex to represent. This for example
							// caps union types at 1000 unique object types.
							estimatedCount := (count / (len - i)) * len
							if estimatedCount > 1000000 {
								tracing. /* TODO(TS-TO-GO): was ? */ instant(tracing.Phase.CheckTypes, "removeSubtypes_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
									"typeIds": types.map_(func(t Type) number {
										return t.id
									}),
								})
								error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent)
								return nil
							}
						}
						count++
						if keyProperty && target.flags&(TypeFlagsObject|TypeFlagsIntersection|TypeFlagsInstantiableNonPrimitive) {
							t := getTypeOfPropertyOfType(target, keyProperty.escapedName)
							if t && isUnitType(t) && getRegularTypeOfLiteralType(t) != keyPropertyType {
								continue
							}
						}
						if isTypeRelatedTo(source, target, strictSubtypeRelation) && (!(getObjectFlags(getTargetType(source)) & ObjectFlagsClass) || !(getObjectFlags(getTargetType(target)) & ObjectFlagsClass) || isTypeDerivedFrom(source, target)) {
							orderedRemoveItemAt(types, i)
							break
						}
					}
				}
			}
		}
		subtypeReductionCache.set(id, types)
		return types
	}
	removeRedundantLiteralTypes := func(types []Type, includes TypeFlags, reduceVoidUndefined bool) {
		i := types.length
		for i > 0 {
			i--
			t := types[i]
			flags := t.flags
			remove := flags&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && includes&TypeFlagsString || flags&TypeFlagsNumberLiteral && includes&TypeFlagsNumber || flags&TypeFlagsBigIntLiteral && includes&TypeFlagsBigInt || flags&TypeFlagsUniqueESSymbol && includes&TypeFlagsESSymbol || reduceVoidUndefined && flags&TypeFlagsUndefined && includes&TypeFlagsVoid || isFreshLiteralType(t) && containsType(types, (t /* as LiteralType */).regularType)
			if remove {
				orderedRemoveItemAt(types, i)
			}
		}
	}
	removeStringLiteralsMatchedByTemplateLiterals := func(types []Type) {
		templates := filter(types, isPatternLiteralType) /* as (TemplateLiteralType | StringMappingType)[] */
		if templates.length {
			i := types.length
			for i > 0 {
				i--
				t := types[i]
				if t.flags&TypeFlagsStringLiteral && some(templates, func(template /* TODO(TS-TO-GO) inferred type TemplateLiteralType | StringMappingType */ any) bool {
					return isTypeMatchedByTemplateLiteralOrStringMapping(t, template)
				}) {
					orderedRemoveItemAt(types, i)
				}
			}
		}
	}
	isTypeMatchedByTemplateLiteralOrStringMapping := func(type_ Type, template /* TODO(TS-TO-GO) TypeNode UnionType: TemplateLiteralType | StringMappingType */ any) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case template.flags & TypeFlagsTemplateLiteral:
			return isTypeMatchedByTemplateLiteralType(type_, template /* as TemplateLiteralType */)
		default:
			return isMemberOfStringMapping(type_, template)
		}
	}
	removeConstrainedTypeVariables := func(types []Type) {
		var typeVariables []TypeVariable = []never{}
		// First collect a list of the type variables occurring in constraining intersections.
		for _, type_ := range types {
			if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
				var index /* TODO(TS-TO-GO) inferred type 0 | 1 */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case (type_ /* as IntersectionType */).types[0].flags & TypeFlagsTypeVariable:
					index = 0
				default:
					index = 1
				}
				pushIfUnique(typeVariables, (type_ /* as IntersectionType */).types[index])
			}
		}
		// For each type variable, check if the constraining intersections for that type variable fully
		// cover the constraint of the type variable; if so, remove the constraining intersections and
		// substitute the type variable.
		for _, typeVariable := range typeVariables {
			var primitives []Type = []never{}
			// First collect the primitive types from the constraining intersections.
			for _, type_ := range types {
				if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
					var index /* TODO(TS-TO-GO) inferred type 0 | 1 */ any
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case (type_ /* as IntersectionType */).types[0].flags & TypeFlagsTypeVariable:
						index = 0
					default:
						index = 1
					}
					if (type_ /* as IntersectionType */).types[index] == typeVariable {
						insertType(primitives, (type_ /* as IntersectionType */).types[1-index])
					}
				}
			}
			// If every constituent in the type variable's constraint is covered by an intersection of the type
			// variable and that constituent, remove those intersections and substitute the type variable.
			constraint := getBaseConstraintOfType(typeVariable)
			if everyType(constraint, func(t Type) bool {
				return containsType(primitives, t)
			}) {
				i := types.length
				for i > 0 {
					i--
					type_ := types[i]
					if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
						var index /* TODO(TS-TO-GO) inferred type 0 | 1 */ any
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case (type_ /* as IntersectionType */).types[0].flags & TypeFlagsTypeVariable:
							index = 0
						default:
							index = 1
						}
						if (type_ /* as IntersectionType */).types[index] == typeVariable && containsType(primitives, (type_ /* as IntersectionType */).types[1-index]) {
							orderedRemoveItemAt(types, i)
						}
					}
				}
				insertType(types, typeVariable)
			}
		}
	}
	isNamedUnionType := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsUnion && (type_.aliasSymbol || (type_ /* as UnionType */).origin))
	}
	addNamedUnions := func(namedUnions []Type, types []Type) {
		for _, t := range types {
			if t.flags & TypeFlagsUnion {
				origin := (t /* as UnionType */).origin
				if t.aliasSymbol || origin && !(origin.flags&TypeFlagsUnion) {
					pushIfUnique(namedUnions, t)
				} else if origin && origin.flags&TypeFlagsUnion {
					addNamedUnions(namedUnions, (origin /* as UnionType */).types)
				}
			}
		}
	}
	createOriginUnionOrIntersectionType := func(flags TypeFlags, types []Type) UnionOrIntersectionType {
		result := createOriginType(flags) /* as UnionOrIntersectionType */
		result.types = types
		return result
	}
	// We sort and deduplicate the constituent types based on object identity. If the subtypeReduction
	// flag is specified we also reduce the constituent type set to only include types that aren't subtypes
	// of other types. Subtype reduction is expensive for large union types and is possible only when union
	// types are known not to circularly reference themselves (as is the case with union types created by
	// expression constructs such as array literals and the || and ?: operators). Named types can
	// circularly reference themselves and therefore cannot be subtype reduced during their declaration.
	// For example, "type Item = string | (() => Item" is a named type that circularly references itself.
	getUnionType := func(types []Type, unionReduction UnionReduction /*  = UnionReduction.Literal */, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
		if types.length == 0 {
			return neverType
		}
		if types.length == 1 {
			return types[0]
		}
		// We optimize for the common case of unioning a union type with some other type (such as `undefined`).
		if types.length == 2 && !origin && (types[0].flags&TypeFlagsUnion || types[1].flags&TypeFlagsUnion) {
			var infix /* TODO(TS-TO-GO) inferred type "N" | "S" | "L" */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case unionReduction == UnionReductionNone:
				infix = "N"
			case unionReduction == UnionReductionSubtype:
				infix = "S"
			default:
				infix = "L"
			}
			var index /* TODO(TS-TO-GO) inferred type 0 | 1 */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case types[0].id < types[1].id:
				index = 0
			default:
				index = 1
			}
			id := types[index].id + infix + types[1-index].id + getAliasId(aliasSymbol, aliasTypeArguments)
			type_ := unionOfUnionTypes.get(id)
			if !type_ {
				type_ = getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments /*origin*/, nil)
				unionOfUnionTypes.set(id, type_)
			}
			return type_
		}
		return getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, origin)
	}
	getUnionTypeWorker := func(types []Type, unionReduction UnionReduction, aliasSymbol Symbol, aliasTypeArguments *[]Type, origin Type) Type {
		var typeSet *[]Type = []never{}
		includes := addTypesToUnion(typeSet, 0 /* as TypeFlags */, types)
		if unionReduction != UnionReductionNone {
			if includes & TypeFlagsAnyOrUnknown {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case includes & TypeFlagsAny:
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case includes & TypeFlagsIncludesWildcard:
						return wildcardType
					case includes & TypeFlagsIncludesError:
						return errorType
					default:
						return anyType
					}
				default:
					return unknownType
				}
			}
			if includes & TypeFlagsUndefined {
				// If type set contains both undefinedType and missingType, remove missingType
				if typeSet.length >= 2 && typeSet[0] == undefinedType && typeSet[1] == missingType {
					orderedRemoveItemAt(typeSet, 1)
				}
			}
			if includes&(TypeFlagsEnum|TypeFlagsLiteral|TypeFlagsUniqueESSymbol|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || includes&TypeFlagsVoid && includes&TypeFlagsUndefined {
				removeRedundantLiteralTypes(typeSet, includes, !!(unionReduction & UnionReductionSubtype))
			}
			if includes&TypeFlagsStringLiteral && includes&(TypeFlagsTemplateLiteral|TypeFlagsStringMapping) {
				removeStringLiteralsMatchedByTemplateLiterals(typeSet)
			}
			if includes & TypeFlagsIncludesConstrainedTypeVariable {
				removeConstrainedTypeVariables(typeSet)
			}
			if unionReduction == UnionReductionSubtype {
				typeSet = removeSubtypes(typeSet, !!(includes & TypeFlagsObject))
				if !typeSet {
					return errorType
				}
			}
			if typeSet.length == 0 {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case includes & TypeFlagsNull:
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case includes & TypeFlagsIncludesNonWideningType:
						return nullType
					default:
						return nullWideningType
					}
				case includes & TypeFlagsUndefined:
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case includes & TypeFlagsIncludesNonWideningType:
						return undefinedType
					default:
						return undefinedWideningType
					}
				default:
					return neverType
				}
			}
		}
		if !origin && includes&TypeFlagsUnion {
			var namedUnions []Type = []never{}
			addNamedUnions(namedUnions, types)
			var reducedTypes []Type = []never{}
			for _, t := range typeSet {
				if !some(namedUnions, func(union Type) bool {
					return containsType((union /* as UnionType */).types, t)
				}) {
					reducedTypes.push(t)
				}
			}
			if !aliasSymbol && namedUnions.length == 1 && reducedTypes.length == 0 {
				return namedUnions[0]
			}
			// We create a denormalized origin type only when the union was created from one or more named unions
			// (unions with alias symbols or origins) and when there is no overlap between those named unions.
			namedTypesCount := reduceLeft(namedUnions, func(sum number, union Type) number {
				return sum + (union /* as UnionType */).types.length
			}, 0)
			if namedTypesCount+reducedTypes.length == typeSet.length {
				for _, t := range namedUnions {
					insertType(reducedTypes, t)
				}
				origin = createOriginUnionOrIntersectionType(TypeFlagsUnion, reducedTypes)
			}
		}
		objectFlags := (__COND__(includes&TypeFlagsNotPrimitiveUnion, 0, ObjectFlagsPrimitiveUnion)) | (__COND__(includes&TypeFlagsIntersection, ObjectFlagsContainsIntersections, 0))
		return getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin)
	}
	getUnionOrIntersectionTypePredicate := func(signatures []Signature, kind *TypeFlags) *TypePredicate {
		var last *TypePredicate
		var types []Type = []never{}
		for _, sig := range signatures {
			pred := getTypePredicateOfSignature(sig)
			if pred {
				// Constituent type predicates must all have matching kinds. We don't create composite type predicates for assertions.
				if pred.kind != TypePredicateKindThis && pred.kind != TypePredicateKindIdentifier || last && !typePredicateKindsMatch(last, pred) {
					return nil
				}
				last = pred
				types.push(pred.type_)
			} else {
				// In composite union signatures we permit and ignore signatures with a return type `false`.
				var returnType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case kind != TypeFlagsIntersection:
					returnType = getReturnTypeOfSignature(sig)
				default:
					returnType = nil
				}
				if returnType != falseType && returnType != regularFalseType {
					return nil
				}
			}
		}
		if !last {
			return nil
		}
		compositeType := getUnionOrIntersectionType(types, kind)
		return createTypePredicate(last.kind, last.parameterName, last.parameterIndex, compositeType)
	}
	typePredicateKindsMatch := func(a TypePredicate, b TypePredicate) bool {
		return a.kind == b.kind && a.parameterIndex == b.parameterIndex
	}
	// This function assumes the constituent type list is sorted and deduplicated.
	getUnionTypeFromSortedList := func(types []Type, precomputedObjectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
		if types.length == 0 {
			return neverType
		}
		if types.length == 1 {
			return types[0]
		}
		var typeKey string
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case !origin:
			typeKey = getTypeListId(types)
		case origin.flags & TypeFlagsUnion:
			typeKey = __TEMPLATE__("|", getTypeListId((origin /* as UnionType */).types))
		case origin.flags & TypeFlagsIntersection:
			typeKey = __TEMPLATE__("&", getTypeListId((origin /* as IntersectionType */).types))
		default:
			typeKey = __TEMPLATE__("#", (origin /* as IndexType */).type_.id, "|", getTypeListId(types))
		}
		// origin type id alone is insufficient, as `keyof x` may resolve to multiple WIP values while `x` is still resolving
		id := typeKey + getAliasId(aliasSymbol, aliasTypeArguments)
		type_ := unionTypes.get(id)
		if !type_ {
			type_ = createType(TypeFlagsUnion) /* as UnionType */
			type_.objectFlags = precomputedObjectFlags | getPropagatingFlagsOfTypes(types /*excludeKinds*/, TypeFlagsNullable)
			type_.types = types
			type_.origin = origin
			type_.aliasSymbol = aliasSymbol
			type_.aliasTypeArguments = aliasTypeArguments
			if types.length == 2 && types[0].flags&TypeFlagsBooleanLiteral && types[1].flags&TypeFlagsBooleanLiteral {
				type_.flags |= TypeFlagsBoolean
				(type_ /* as UnionType & IntrinsicType */).intrinsicName = "boolean"
			}
			unionTypes.set(id, type_)
		}
		return type_
	}
	getTypeFromUnionTypeNode := func(node UnionTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			links.resolvedType = getUnionType(map_(node.types, getTypeFromTypeNode), UnionReductionLiteral, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol))
		}
		return links.resolvedType
	}
	addTypeToIntersection := func(typeSet Map[string, Type], includes TypeFlags, type_ Type) TypeFlags {
		flags := type_.flags
		if flags & TypeFlagsIntersection {
			return addTypesToIntersection(typeSet, includes, (type_ /* as IntersectionType */).types)
		}
		if isEmptyAnonymousObjectType(type_) {
			if !(includes & TypeFlagsIncludesEmptyObject) {
				includes |= TypeFlagsIncludesEmptyObject
				typeSet.set(type_.id.toString(), type_)
			}
		} else {
			if flags & TypeFlagsAnyOrUnknown {
				if type_ == wildcardType {
					includes |= TypeFlagsIncludesWildcard
				}
				if isErrorType(type_) {
					includes |= TypeFlagsIncludesError
				}
			} else if strictNullChecks || !(flags & TypeFlagsNullable) {
				if type_ == missingType {
					includes |= TypeFlagsIncludesMissingType
					type_ = undefinedType
				}
				if !typeSet.has(type_.id.toString()) {
					if type_.flags&TypeFlagsUnit && includes&TypeFlagsUnit {
						// We have seen two distinct unit types which means we should reduce to an
						// empty intersection. Adding TypeFlags.NonPrimitive causes that to happen.
						includes |= TypeFlagsNonPrimitive
					}
					typeSet.set(type_.id.toString(), type_)
				}
			}
			includes |= flags & TypeFlagsIncludesMask
		}
		return includes
	}
	// Add the given types to the given type set. Order is preserved, freshness is removed from literal
	// types, duplicates are removed, and nested types of the given kind are flattened into the set.
	addTypesToIntersection := func(typeSet Map[string, Type], includes TypeFlags, types []Type) TypeFlags {
		for _, type_ := range types {
			includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type_))
		}
		return includes
	}
	removeRedundantSupertypes := func(types []Type, includes TypeFlags) {
		i := types.length
		for i > 0 {
			i--
			t := types[i]
			remove := t.flags&TypeFlagsString && includes&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || t.flags&TypeFlagsNumber && includes&TypeFlagsNumberLiteral || t.flags&TypeFlagsBigInt && includes&TypeFlagsBigIntLiteral || t.flags&TypeFlagsESSymbol && includes&TypeFlagsUniqueESSymbol || t.flags&TypeFlagsVoid && includes&TypeFlagsUndefined || isEmptyAnonymousObjectType(t) && includes&TypeFlagsDefinitelyNonNullable
			if remove {
				orderedRemoveItemAt(types, i)
			}
		}
	}
	// Check that the given type has a match in every union. A given type is matched by
	// an identical type, and a literal type is additionally matched by its corresponding
	// primitive type, and missingType is matched by undefinedType (and vice versa).
	eachUnionContains := func(unionTypes []UnionType, type_ Type) bool {
		for _, u := range unionTypes {
			if !containsType(u.types, type_) {
				if type_ == missingType {
					return containsType(u.types, undefinedType)
				}
				if type_ == undefinedType {
					return containsType(u.types, missingType)
				}
				var primitive *IntrinsicType
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case type_.flags & TypeFlagsStringLiteral:
					primitive = stringType
				case type_.flags & (TypeFlagsEnum | TypeFlagsNumberLiteral):
					primitive = numberType
				case type_.flags & TypeFlagsBigIntLiteral:
					primitive = bigintType
				case type_.flags & TypeFlagsUniqueESSymbol:
					primitive = esSymbolType
				default:
					primitive = nil
				}
				if !primitive || !containsType(u.types, primitive) {
					return false
				}
			}
		}
		return true
	}
	/**
	 * Returns true if the intersection of the template literals and string literals is the empty set,
	 * for example `get${string}` & "setX", and should reduce to never.
	 */
	extractRedundantTemplateLiterals := func(types []Type) bool {
		i := types.length
		literals := filter(types, func(t Type) bool {
			return !!(t.flags & TypeFlagsStringLiteral)
		})
		for i > 0 {
			i--
			t := types[i]
			if !(t.flags & (TypeFlagsTemplateLiteral | TypeFlagsStringMapping)) {
				continue
			}
			for _, t2 := range literals {
				if isTypeSubtypeOf(t2, t) {
					// For example, `get${T}` & "getX" is just "getX", and Lowercase<string> & "foo" is just "foo"
					orderedRemoveItemAt(types, i)
					break
				} else if isPatternLiteralType(t) {
					return true
				}
			}
		}
		return false
	}
	removeFromEach := func(types []Type, flag TypeFlags) {
		for i := 0; i < types.length; i++ {
			types[i] = filterType(types[i], func(t Type) bool {
				return !(t.flags & flag)
			})
		}
	}
	// If the given list of types contains more than one union of primitive types, replace the
	// first with a union containing an intersection of those primitive types, then remove the
	// other unions and return true. Otherwise, do nothing and return false.
	intersectUnionsOfPrimitiveTypes := func(types []Type) bool {
		var unionTypes *[]UnionType
		index := findIndex(types, func(t Type) bool {
			return !!(getObjectFlags(t) & ObjectFlagsPrimitiveUnion)
		})
		if index < 0 {
			return false
		}
		i := index + 1
		// Remove all but the first union of primitive types and collect them in
		// the unionTypes array.
		for i < types.length {
			t := types[i]
			if getObjectFlags(t) & ObjectFlagsPrimitiveUnion {
				(unionTypes || ( /* TODO(TS-TO-GO) Node BinaryExpression: unionTypes = [types[index] as UnionType] */ TODO)).push(t /* as UnionType */)
				orderedRemoveItemAt(types, i)
			} else {
				i++
			}
		}
		// Return false if there was only one union of primitive types
		if !unionTypes {
			return false
		}
		// We have more than one union of primitive types, now intersect them. For each
		// type in each union we check if the type is matched in every union and if so
		// we include it in the result.
		var checked []Type = []never{}
		var result []Type = []never{}
		for _, u := range unionTypes {
			for _, t := range u.types {
				if insertType(checked, t) {
					if eachUnionContains(unionTypes, t) {
						// undefinedType/missingType should always come sorted first so we leverage that here
						if t == undefinedType && result.length && result[0] == missingType {
							continue
						}
						if t == missingType && result.length && result[0] == undefinedType {
							result[0] = missingType
							continue
						}
						insertType(result, t)
					}
				}
			}
		}
		// Finally replace the first union with the result
		types[index] = getUnionTypeFromSortedList(result, ObjectFlagsPrimitiveUnion)
		return true
	}
	createIntersectionType := func(types []Type, objectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type) IntersectionType {
		result := createType(TypeFlagsIntersection) /* as IntersectionType */
		result.objectFlags = objectFlags | getPropagatingFlagsOfTypes(types /*excludeKinds*/, TypeFlagsNullable)
		result.types = types
		result.aliasSymbol = aliasSymbol
		result.aliasTypeArguments = aliasTypeArguments
		return result
	}
	// We normalize combinations of intersection and union types based on the distributive property of the '&'
	// operator. Specifically, because X & (A | B) is equivalent to X & A | X & B, we can transform intersection
	// types with union type constituents into equivalent union types with intersection type constituents and
	// effectively ensure that union types are always at the top level in type representations.
	//
	// We do not perform structural deduplication on intersection types. Intersection types are created only by the &
	// type operator and we can't reduce those because we want to support recursive intersection types. For example,
	// a type alias of the form "type List<T> = T & { next: List<T> }" cannot be reduced during its declaration.
	// Also, unlike union types, the order of the constituent types is preserved in order that overload resolution
	// for intersections of types with signatures can be deterministic.
	getIntersectionType := func(types []Type, flags IntersectionFlags /*  = IntersectionFlags.None */, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		typeMembershipMap := NewMap[string, Type]()
		includes := addTypesToIntersection(typeMembershipMap, 0 /* as TypeFlags */, types)
		var typeSet []Type = arrayFrom(typeMembershipMap.values())
		objectFlags := ObjectFlagsNone
		// An intersection type is considered empty if it contains
		// the type never, or
		// more than one unit type or,
		// an object type and a nullable type (null or undefined), or
		// a string-like type and a type known to be non-string-like, or
		// a number-like type and a type known to be non-number-like, or
		// a symbol-like type and a type known to be non-symbol-like, or
		// a void-like type and a type known to be non-void-like, or
		// a non-primitive type and a type known to be primitive.
		if includes & TypeFlagsNever {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case contains(typeSet, silentNeverType):
				return silentNeverType
			default:
				return neverType
			}
		}
		if strictNullChecks && includes&TypeFlagsNullable && includes&(TypeFlagsObject|TypeFlagsNonPrimitive|TypeFlagsIncludesEmptyObject) || includes&TypeFlagsNonPrimitive && includes&(TypeFlagsDisjointDomains&~TypeFlagsNonPrimitive) || includes&TypeFlagsStringLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsStringLike) || includes&TypeFlagsNumberLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsNumberLike) || includes&TypeFlagsBigIntLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsBigIntLike) || includes&TypeFlagsESSymbolLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsESSymbolLike) || includes&TypeFlagsVoidLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsVoidLike) {
			return neverType
		}
		if includes&(TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && includes&TypeFlagsStringLiteral && extractRedundantTemplateLiterals(typeSet) {
			return neverType
		}
		if includes & TypeFlagsAny {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case includes & TypeFlagsIncludesWildcard:
				return wildcardType
			case includes & TypeFlagsIncludesError:
				return errorType
			default:
				return anyType
			}
		}
		if !strictNullChecks && includes&TypeFlagsNullable {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case includes & TypeFlagsIncludesEmptyObject:
				return neverType
			case includes & TypeFlagsUndefined:
				return undefinedType
			default:
				return nullType
			}
		}
		if includes&TypeFlagsString && includes&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || includes&TypeFlagsNumber && includes&TypeFlagsNumberLiteral || includes&TypeFlagsBigInt && includes&TypeFlagsBigIntLiteral || includes&TypeFlagsESSymbol && includes&TypeFlagsUniqueESSymbol || includes&TypeFlagsVoid && includes&TypeFlagsUndefined || includes&TypeFlagsIncludesEmptyObject && includes&TypeFlagsDefinitelyNonNullable {
			if !(flags & IntersectionFlagsNoSupertypeReduction) {
				removeRedundantSupertypes(typeSet, includes)
			}
		}
		if includes & TypeFlagsIncludesMissingType {
			typeSet[typeSet.indexOf(undefinedType)] = missingType
		}
		if typeSet.length == 0 {
			return unknownType
		}
		if typeSet.length == 1 {
			return typeSet[0]
		}
		if typeSet.length == 2 && !(flags & IntersectionFlagsNoConstraintReduction) {
			var typeVarIndex /* TODO(TS-TO-GO) inferred type 0 | 1 */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case typeSet[0].flags & TypeFlagsTypeVariable:
				typeVarIndex = 0
			default:
				typeVarIndex = 1
			}
			typeVariable := typeSet[typeVarIndex]
			primitiveType := typeSet[1-typeVarIndex]
			if typeVariable.flags&TypeFlagsTypeVariable && (primitiveType.flags&(TypeFlagsPrimitive|TypeFlagsNonPrimitive) && !isGenericStringLikeType(primitiveType) || includes&TypeFlagsIncludesEmptyObject) {
				// We have an intersection T & P or P & T, where T is a type variable and P is a primitive type, the object type, or {}.
				constraint := getBaseConstraintOfType(typeVariable)
				// Check that T's constraint is similarly composed of primitive types, the object type, or {}.
				if constraint && everyType(constraint, func(t Type) bool {
					return !!(t.flags & (TypeFlagsPrimitive | TypeFlagsNonPrimitive)) || isEmptyAnonymousObjectType(t)
				}) {
					// If T's constraint is a subtype of P, simply return T. For example, given `T extends "a" | "b"`,
					// the intersection `T & string` reduces to just T.
					if isTypeStrictSubtypeOf(constraint, primitiveType) {
						return typeVariable
					}
					if !(constraint.flags&TypeFlagsUnion && someType(constraint, func(c Type) bool {
						return isTypeStrictSubtypeOf(c, primitiveType)
					})) {
						// No constituent of T's constraint is a subtype of P. If P is also not a subtype of T's constraint,
						// then the constraint and P are unrelated, and the intersection reduces to never. For example, given
						// `T extends "a" | "b"`, the intersection `T & number` reduces to never.
						if !isTypeStrictSubtypeOf(primitiveType, constraint) {
							return neverType
						}
					}
					// Some constituent of T's constraint is a subtype of P, or P is a subtype of T's constraint. Thus,
					// the intersection further constrains the type variable. For example, given `T extends string | number`,
					// the intersection `T & "a"` is marked as a constrained type variable. Likewise, given `T extends "a" | 1`,
					// the intersection `T & number` is marked as a constrained type variable.
					objectFlags = ObjectFlagsIsConstrainedTypeVariable
				}
			}
		}
		id := getTypeListId(typeSet) + (__COND__(flags&IntersectionFlagsNoConstraintReduction, "*", getAliasId(aliasSymbol, aliasTypeArguments)))
		result := intersectionTypes.get(id)
		if !result {
			if includes & TypeFlagsUnion {
				if intersectUnionsOfPrimitiveTypes(typeSet) {
					// When the intersection creates a reduced set (which might mean that *all* union types have
					// disappeared), we restart the operation to get a new set of combined flags. Once we have
					// reduced we'll never reduce again, so this occurs at most once.
					result = getIntersectionType(typeSet, flags, aliasSymbol, aliasTypeArguments)
				} else if every(typeSet, func(t Type) bool {
					return !!(t.flags&TypeFlagsUnion && (t /* as UnionType */).types[0].flags&TypeFlagsUndefined)
				}) {
					var containedUndefinedType IntrinsicType
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case some(typeSet, containsMissingType):
						containedUndefinedType = missingType
					default:
						containedUndefinedType = undefinedType
					}
					removeFromEach(typeSet, TypeFlagsUndefined)
					result = getUnionType([]Type{getIntersectionType(typeSet, flags), containedUndefinedType}, UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
				} else if every(typeSet, func(t Type) bool {
					return !!(t.flags&TypeFlagsUnion && ((t /* as UnionType */).types[0].flags&TypeFlagsNull || (t /* as UnionType */).types[1].flags&TypeFlagsNull))
				}) {
					removeFromEach(typeSet, TypeFlagsNull)
					result = getUnionType([]Type{getIntersectionType(typeSet, flags), nullType}, UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
				} else if typeSet.length >= 3 && types.length > 2 {
					// When we have three or more constituents, more than two inputs (to head off infinite reexpansion), some of which are unions, we employ a "divide and conquer" strategy
					// where A & B & C & D is processed as (A & B) & (C & D). Since intersections of unions often produce far smaller
					// unions of intersections than the full cartesian product (due to some intersections becoming `never`), this can
					// dramatically reduce the overall work.
					middle := Math.floor(typeSet.length / 2)
					result = getIntersectionType([]Type{getIntersectionType(typeSet.slice(0, middle), flags), getIntersectionType(typeSet.slice(middle), flags)}, flags, aliasSymbol, aliasTypeArguments)
				} else {
					// We are attempting to construct a type of the form X & (A | B) & (C | D). Transform this into a type of
					// the form X & A & C | X & A & D | X & B & C | X & B & D. If the estimated size of the resulting union type
					// exceeds 100000 constituents, report an error.
					if !checkCrossProductUnion(typeSet) {
						return errorType
					}
					constituents := getCrossProductIntersections(typeSet, flags)
					// We attach a denormalized origin type when at least one constituent of the cross-product union is an
					// intersection (i.e. when the intersection didn't just reduce one or more unions to smaller unions) and
					// the denormalized origin has fewer constituents than the union itself.
					var origin *UnionOrIntersectionType
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case some(constituents, func(t Type) bool {
						return !!(t.flags & TypeFlagsIntersection)
					}) && getConstituentCountOfTypes(constituents) > getConstituentCountOfTypes(typeSet):
						origin = createOriginUnionOrIntersectionType(TypeFlagsIntersection, typeSet)
					default:
						origin = nil
					}
					result = getUnionType(constituents, UnionReductionLiteral, aliasSymbol, aliasTypeArguments, origin)
				}
			} else {
				result = createIntersectionType(typeSet, objectFlags, aliasSymbol, aliasTypeArguments)
			}
			intersectionTypes.set(id, result)
		}
		return result
	}
	getCrossProductUnionSize := func(types []Type) number {
		return reduceLeft(types, func(n number, t Type) number {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case t.flags & TypeFlagsUnion:
				return n * (t /* as UnionType */).types.length
			case t.flags & TypeFlagsNever:
				return 0
			default:
				return n
			}
		}, 1)
	}
	checkCrossProductUnion := func(types []Type) bool {
		size := getCrossProductUnionSize(types)
		if size >= 100000 {
			tracing. /* TODO(TS-TO-GO): was ? */ instant(tracing.Phase.CheckTypes, "checkCrossProductUnion_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"typeIds": types.map_(func(t Type) number {
					return t.id
				}),
				"size": size,
			})
			error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent)
			return false
		}
		return true
	}
	getCrossProductIntersections := func(types []Type, flags IntersectionFlags) []Type {
		count := getCrossProductUnionSize(types)
		var intersections []Type = []never{}
		for i := 0; i < count; i++ {
			constituents := types.slice()
			n := i
			for j := types.length - 1; j >= 0; j-- {
				if types[j].flags & TypeFlagsUnion {
					sourceTypes := (types[j] /* as UnionType */).types
					length := sourceTypes.length
					constituents[j] = sourceTypes[ /* TODO(TS-TO-GO) Node BinaryExpression: n % length */ TODO]
					n = Math.floor(n / length)
				}
			}
			t := getIntersectionType(constituents, flags)
			if !(t.flags & TypeFlagsNever) {
				intersections.push(t)
			}
		}
		return intersections
	}
	getConstituentCount := func(type_ Type) number {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case !(type_.flags & TypeFlagsUnionOrIntersection) || type_.aliasSymbol:
			return 1
		case type_.flags&TypeFlagsUnion && (type_ /* as UnionType */).origin:
			return getConstituentCount((type_ /* as UnionType */).origin)
		default:
			return getConstituentCountOfTypes((type_ /* as UnionOrIntersectionType */).types)
		}
	}
	getConstituentCountOfTypes := func(types []Type) number {
		return reduceLeft(types, func(n number, t Type) number {
			return n + getConstituentCount(t)
		}, 0)
	}
	getTypeFromIntersectionTypeNode := func(node IntersectionTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			types := map_(node.types, getTypeFromTypeNode)
			// We perform no supertype reduction for X & {} or {} & X, where X is one of string, number, bigint,
			// or a pattern literal template type. This enables union types like "a" | "b" | string & {} or
			// "aa" | "ab" | `a${string}` which preserve the literal types for purposes of statement completion.
			var emptyIndex number
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case types.length == 2:
				emptyIndex = types.indexOf(emptyTypeLiteralType)
			default:
				emptyIndex = -1
			}
			var t Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case emptyIndex >= 0:
				t = types[1-emptyIndex]
			default:
				t = unknownType
			}
			noSupertypeReduction := !!(t.flags&(TypeFlagsString|TypeFlagsNumber|TypeFlagsBigInt) || t.flags&TypeFlagsTemplateLiteral && isPatternLiteralType(t))
			links.resolvedType = getIntersectionType(types, __COND__(noSupertypeReduction, IntersectionFlagsNoSupertypeReduction, 0), aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol))
		}
		return links.resolvedType
	}
	createIndexType := func(type_ /* TODO(TS-TO-GO) TypeNode UnionType: InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) IndexType {
		result := createType(TypeFlagsIndex) /* as IndexType */
		result.type_ = type_
		result.indexFlags = indexFlags
		return result
	}
	createOriginIndexType := func(type_ /* TODO(TS-TO-GO) TypeNode UnionType: InstantiableType | UnionOrIntersectionType */ any) IndexType {
		result := createOriginType(TypeFlagsIndex) /* as IndexType */
		result.type_ = type_
		return result
	}
	getIndexTypeForGenericType := func(type_ /* TODO(TS-TO-GO) TypeNode UnionType: InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) IndexType {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case indexFlags & IndexFlagsStringsOnly:
			return type_.resolvedStringIndexType || ( /* TODO(TS-TO-GO) Node BinaryExpression: type.resolvedStringIndexType = createIndexType(type, IndexFlags.StringsOnly) */ TODO)
		default:
			return type_.resolvedIndexType || ( /* TODO(TS-TO-GO) Node BinaryExpression: type.resolvedIndexType = createIndexType(type, IndexFlags.None) */ TODO)
		}
	}
	/**
	 * This roughly mirrors `resolveMappedTypeMembers` in the nongeneric case, except only reports a union of the keys calculated,
	 * rather than manufacturing the properties. We can't just fetch the `constraintType` since that would ignore mappings
	 * and mapping the `constraintType` directly ignores how mapped types map _properties_ and not keys (thus ignoring subtype
	 * reduction in the constraintType) when possible.
	 * @param noIndexSignatures Indicates if _string_ index signatures should be elided. (other index signatures are always reported)
	 */
	getIndexTypeForMappedType := func(type_ MappedType, indexFlags IndexFlags) Type {
		typeParameter := getTypeParameterFromMappedType(type_)
		constraintType := getConstraintTypeFromMappedType(type_)
		nameType := getNameTypeFromMappedType(type_.target /* as MappedType */ || type_)
		if !nameType && !(indexFlags & IndexFlagsNoIndexSignatures) {
			// no mapping and no filtering required, just quickly bail to returning the constraint in the common case
			return constraintType
		}
		var keyTypes []Type = []never{}
		// Calling getApparentType on the `T` of a `keyof T` in the constraint type of a generic mapped type can
		// trigger a circularity. For example, `T extends { [P in keyof T & string as Captitalize<P>]: any }` is
		// a circular definition. For this reason, we only eagerly manifest the keys if the constraint is non-generic.
		if isGenericIndexType(constraintType) {
			if isMappedTypeWithKeyofConstraintDeclaration(type_) {
				// We have a generic index and a homomorphic mapping (but a distributive key remapping) - we need to defer
				// the whole `keyof whatever` for later since it's not safe to resolve the shape of modifier type.
				return getIndexTypeForGenericType(type_, indexFlags)
			}
			// Include the generic component in the resulting type.
			forEachType(constraintType, addMemberForKeyType)
		} else if isMappedTypeWithKeyofConstraintDeclaration(type_) {
			modifiersType := getApparentType(getModifiersTypeFromMappedType(type_))
			// The 'T' in 'keyof T'
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, TypeFlagsStringOrNumberLiteralOrUnique, !!(indexFlags & IndexFlagsStringsOnly), addMemberForKeyType)
		} else {
			forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType)
		}
		// We had to pick apart the constraintType to potentially map/filter it - compare the final resulting list with the
		// original constraintType, so we can return the union that preserves aliases/origin data if possible.
		var result Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case indexFlags & IndexFlagsNoIndexSignatures:
			result = filterType(getUnionType(keyTypes), func(t Type) bool {
				return !(t.flags & (TypeFlagsAny | TypeFlagsString))
			})
		default:
			result = getUnionType(keyTypes)
		}
		if result.flags&TypeFlagsUnion && constraintType.flags&TypeFlagsUnion && getTypeListId((result /* as UnionType */).types) == getTypeListId((constraintType /* as UnionType */).types) {
			return constraintType
		}
		return result
		addMemberForKeyType := func(keyType Type) {
			var propNameType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case nameType:
				propNameType = instantiateType(nameType, appendTypeMapping(type_.mapper, typeParameter, keyType))
			default:
				propNameType = keyType
			}
			// `keyof` currently always returns `string | number` for concrete `string` index signatures - the below ternary keeps that behavior for mapped types
			// See `getLiteralTypeFromProperties` where there's a similar ternary to cause the same behavior.
			keyTypes.push(__COND__(propNameType == stringType, stringOrNumberType, propNameType))
		}
	}
	// Ordinarily we reduce a keyof M, where M is a mapped type { [P in K as N<P>]: X }, to simply N<K>. This however presumes
	// that N distributes over union types, i.e. that N<A | B | C> is equivalent to N<A> | N<B> | N<C>. Specifically, we only
	// want to perform the reduction when the name type of a mapped type is distributive with respect to the type variable
	// introduced by the 'in' clause of the mapped type. Note that non-generic types are considered to be distributive because
	// they're the same type regardless of what's being distributed over.
	hasDistributiveNameType := func(mappedType MappedType) bool {
		typeVariable := getTypeParameterFromMappedType(mappedType)
		return isDistributive(getNameTypeFromMappedType(mappedType) || typeVariable)
		isDistributive := func(type_ Type) bool {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case type_.flags & (TypeFlagsAnyOrUnknown | TypeFlagsPrimitive | TypeFlagsNever | TypeFlagsTypeParameter | TypeFlagsObject | TypeFlagsNonPrimitive):
				return true
			case type_.flags & TypeFlagsConditional:
				return (type_ /* as ConditionalType */).root.isDistributive && (type_ /* as ConditionalType */).checkType == typeVariable
			case type_.flags & (TypeFlagsUnionOrIntersection | TypeFlagsTemplateLiteral):
				return every((type_ /* as UnionOrIntersectionType | TemplateLiteralType */).types, isDistributive)
			case type_.flags & TypeFlagsIndexedAccess:
				return isDistributive((type_ /* as IndexedAccessType */).objectType) && isDistributive((type_ /* as IndexedAccessType */).indexType)
			case type_.flags & TypeFlagsSubstitution:
				return isDistributive((type_ /* as SubstitutionType */).baseType) && isDistributive((type_ /* as SubstitutionType */).constraint)
			case type_.flags & TypeFlagsStringMapping:
				return isDistributive((type_ /* as StringMappingType */).type_)
			default:
				return false
			}
		}
	}
	getLiteralTypeFromPropertyName := func(name /* TODO(TS-TO-GO) TypeNode UnionType: PropertyName | JsxAttributeName */ any) Type {
		if isPrivateIdentifier(name) {
			return neverType
		}
		if isNumericLiteral(name) {
			return getRegularTypeOfLiteralType(checkExpression(name))
		}
		if isComputedPropertyName(name) {
			return getRegularTypeOfLiteralType(checkComputedPropertyName(name))
		}
		propertyName := getPropertyNameForPropertyNameNode(name)
		if propertyName != nil {
			return getStringLiteralType(unescapeLeadingUnderscores(propertyName))
		}
		if isExpression(name) {
			return getRegularTypeOfLiteralType(checkExpression(name))
		}
		return neverType
	}
	getLiteralTypeFromProperty := func(prop Symbol, include TypeFlags, includeNonPublic bool) Type {
		if includeNonPublic || !(getDeclarationModifierFlagsFromSymbol(prop) & ModifierFlagsNonPublicAccessibilityModifier) {
			type_ := getSymbolLinks(getLateBoundSymbol(prop)).nameType
			if !type_ {
				name := getNameOfDeclaration(prop.valueDeclaration) /* as PropertyName | JsxAttributeName */
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case prop.escapedName == InternalSymbolNameDefault:
					type_ = getStringLiteralType("default")
				default:
					type_ = name && getLiteralTypeFromPropertyName(name) || (__COND__(!isKnownSymbol(prop), getStringLiteralType(symbolName(prop)), nil))
				}
			}
			if type_ && type_.flags&include {
				return type_
			}
		}
		return neverType
	}
	isKeyTypeIncluded := func(keyType Type, include TypeFlags) bool {
		return !!(keyType.flags&include || keyType.flags&TypeFlagsIntersection && some((keyType /* as IntersectionType */).types, func(t Type) bool {
			return isKeyTypeIncluded(t, include)
		}))
	}
	getLiteralTypeFromProperties := func(type_ Type, include TypeFlags, includeOrigin bool) Type {
		var origin *IndexType
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case includeOrigin && (getObjectFlags(type_)&(ObjectFlagsClassOrInterface|ObjectFlagsReference) || type_.aliasSymbol):
			origin = createOriginIndexType(type_)
		default:
			origin = nil
		}
		propertyTypes := map_(getPropertiesOfType(type_), func(prop Symbol) Type {
			return getLiteralTypeFromProperty(prop, include)
		})
		indexKeyTypes := map_(getIndexInfosOfType(type_), func(info IndexInfo) Type {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case info != enumNumberIndexInfo && isKeyTypeIncluded(info.keyType, include):
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case info.keyType == stringType && include&TypeFlagsNumber:
					return stringOrNumberType
				default:
					return info.keyType
				}
			default:
				return neverType
			}
		})
		return getUnionType(concatenate(propertyTypes, indexKeyTypes), UnionReductionLiteral /*aliasSymbol*/, nil /*aliasTypeArguments*/, nil, origin)
	}
	shouldDeferIndexType := func(type_ Type, indexFlags IndexFlags /*  = IndexFlags.None */) bool {
		return !!(type_.flags&TypeFlagsInstantiableNonPrimitive || isGenericTupleType(type_) || isGenericMappedType(type_) && (!hasDistributiveNameType(type_) || getMappedTypeNameTypeKind(type_) == MappedTypeNameTypeKindRemapping) || type_.flags&TypeFlagsUnion && !(indexFlags&IndexFlagsNoReducibleCheck) && isGenericReducibleType(type_) || type_.flags&TypeFlagsIntersection && maybeTypeOfKind(type_, TypeFlagsInstantiable) && some((type_ /* as IntersectionType */).types, isEmptyAnonymousObjectType))
	}
	getIndexType := func(type_ Type, indexFlags IndexFlags /*  = IndexFlags.None */) Type {
		type_ = getReducedType(type_)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isNoInferType(type_):
			return getNoInferType(getIndexType((type_ /* as SubstitutionType */).baseType, indexFlags))
		case shouldDeferIndexType(type_, indexFlags):
			return getIndexTypeForGenericType(type_ /* as InstantiableType | UnionOrIntersectionType */, indexFlags)
		case type_.flags & TypeFlagsUnion:
			return getIntersectionType(map_((type_ /* as UnionType */).types, func(t Type) Type {
				return getIndexType(t, indexFlags)
			}))
		case type_.flags & TypeFlagsIntersection:
			return getUnionType(map_((type_ /* as IntersectionType */).types, func(t Type) Type {
				return getIndexType(t, indexFlags)
			}))
		case getObjectFlags(type_) & ObjectFlagsMapped:
			return getIndexTypeForMappedType(type_ /* as MappedType */, indexFlags)
		case type_ == wildcardType:
			return wildcardType
		case type_.flags & TypeFlagsUnknown:
			return neverType
		case type_.flags & (TypeFlagsAny | TypeFlagsNever):
			return stringNumberSymbolType
		default:
			return getLiteralTypeFromProperties(type_, (__COND__(indexFlags&IndexFlagsNoIndexSignatures, TypeFlagsStringLiteral, TypeFlagsStringLike))|(__COND__(indexFlags&IndexFlagsStringsOnly, 0, TypeFlagsNumberLike|TypeFlagsESSymbolLike)), indexFlags == IndexFlagsNone)
		}
	}
	getExtractStringType := func(type_ Type) Type {
		extractTypeAlias := getGlobalExtractSymbol()
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case extractTypeAlias:
			return getTypeAliasInstantiation(extractTypeAlias, []Type{type_, stringType})
		default:
			return stringType
		}
	}
	getIndexTypeOrString := func(type_ Type) Type {
		indexType := getExtractStringType(getIndexType(type_))
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case indexType.flags & TypeFlagsNever:
			return stringType
		default:
			return indexType
		}
	}
	getTypeFromTypeOperatorNode := func(node TypeOperatorNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			switch node.operator {
			case SyntaxKindKeyOfKeyword:
				links.resolvedType = getIndexType(getTypeFromTypeNode(node.type_))
				break
			case SyntaxKindUniqueKeyword:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case node.type_.kind == SyntaxKindSymbolKeyword:
					links.resolvedType = getESSymbolLikeTypeForNode(walkUpParenthesizedTypes(node.parent))
				default:
					links.resolvedType = errorType
				}
				break
			case SyntaxKindReadonlyKeyword:
				links.resolvedType = getTypeFromTypeNode(node.type_)
				break
			default:
				Debug.assertNever(node.operator)
			}
		}
		return links.resolvedType
	}
	getTypeFromTemplateTypeNode := func(node TemplateLiteralTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getTemplateLiteralType([]string{node.head.text /* TODO(TS-TO-GO) Node SpreadElement: ...map(node.templateSpans, span => span.literal.text) */}, map_(node.templateSpans, func(span TemplateLiteralTypeSpan) Type {
				return getTypeFromTypeNode(span.type_)
			}))
		}
		return links.resolvedType
	}
	getTemplateLiteralType := func(texts []string, types []Type) Type {
		unionIndex := findIndex(types, func(t Type) bool {
			return !!(t.flags & (TypeFlagsNever | TypeFlagsUnion))
		})
		if unionIndex >= 0 {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case checkCrossProductUnion(types):
				return mapType(types[unionIndex], func(t Type) Type {
					return getTemplateLiteralType(texts, replaceElement(types, unionIndex, t))
				})
			default:
				return errorType
			}
		}
		if contains(types, wildcardType) {
			return wildcardType
		}
		var newTypes []Type = []never{}
		var newTexts []string = []never{}
		text := texts[0]
		if !addSpans(texts, types) {
			return stringType
		}
		if newTypes.length == 0 {
			return getStringLiteralType(text)
		}
		newTexts.push(text)
		if every(newTexts, func(t string) bool {
			return t == ""
		}) {
			if every(newTypes, func(t Type) bool {
				return !!(t.flags & TypeFlagsString)
			}) {
				return stringType
			}
			// Normalize `${Mapping<xxx>}` into Mapping<xxx>
			if newTypes.length == 1 && isPatternLiteralType(newTypes[0]) {
				return newTypes[0]
			}
		}
		id := __TEMPLATE__(getTypeListId(newTypes), "|", map_(newTexts, func(t string) number {
			return t.length
		}).join(","), "|", newTexts.join(""))
		type_ := templateLiteralTypes.get(id)
		if !type_ {
			templateLiteralTypes.set(id /* TODO(TS-TO-GO) Node BinaryExpression: type = createTemplateLiteralType(newTexts, newTypes) */, TODO)
		}
		return type_
		addSpans := func(texts []string, types []Type) bool {
			for i := 0; i < types.length; i++ {
				t := types[i]
				if t.flags & (TypeFlagsLiteral | TypeFlagsNull | TypeFlagsUndefined) {
					text += getTemplateStringForType(t) || ""
					text += texts[i+1]
				} else if t.flags & TypeFlagsTemplateLiteral {
					text += (t /* as TemplateLiteralType */).texts[0]
					if !addSpans((t /* as TemplateLiteralType */).texts, (t /* as TemplateLiteralType */).types) {
						return false
					}
					text += texts[i+1]
				} else if isGenericIndexType(t) || isPatternLiteralPlaceholderType(t) {
					newTypes.push(t)
					newTexts.push(text)
					text = texts[i+1]
				} else {
					return false
				}
			}
			return true
		}
	}
	getTemplateStringForType := func(type_ Type) *string {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsStringLiteral:
			return (type_ /* as StringLiteralType */).value
		case type_.flags & TypeFlagsNumberLiteral:
			return "" + (type_ /* as NumberLiteralType */).value
		case type_.flags & TypeFlagsBigIntLiteral:
			return pseudoBigIntToString((type_ /* as BigIntLiteralType */).value)
		case type_.flags & (TypeFlagsBooleanLiteral | TypeFlagsNullable):
			return (type_ /* as IntrinsicType */).intrinsicName
		default:
			return nil
		}
	}
	createTemplateLiteralType := func(texts []string, types []Type) TemplateLiteralType {
		type_ := createType(TypeFlagsTemplateLiteral) /* as TemplateLiteralType */
		type_.texts = texts
		type_.types = types
		return type_
	}
	getStringMappingType := func(symbol Symbol, type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & (TypeFlagsUnion | TypeFlagsNever):
			return mapType(type_, func(t Type) Type {
				return getStringMappingType(symbol, t)
			})
		case type_.flags & TypeFlagsStringLiteral:
			return getStringLiteralType(applyStringMapping(symbol, (type_ /* as StringLiteralType */).value))
		case type_.flags & TypeFlagsTemplateLiteral:
			return getTemplateLiteralType(applyTemplateStringMapping(symbol, (type_ /* as TemplateLiteralType */).texts, (type_ /* as TemplateLiteralType */).types)...)
		case type_.flags&TypeFlagsStringMapping && symbol == type_.symbol:
			return type_
		case type_.flags&(TypeFlagsAny|TypeFlagsString|TypeFlagsStringMapping) || isGenericIndexType(type_):
			return getStringMappingTypeForGenericType(symbol, type_)
		case isPatternLiteralPlaceholderType(type_):
			return getStringMappingTypeForGenericType(symbol, getTemplateLiteralType([]string{"", ""}, []Type{type_}))
		default:
			return type_
		}
	}
	applyStringMapping := func(symbol Symbol, str string) string {
		switch intrinsicTypeKinds.get(symbol.escapedName /* as string */) {
		case IntrinsicTypeKindUppercase:
			return str.toUpperCase()
		case IntrinsicTypeKindLowercase:
			return str.toLowerCase()
		case IntrinsicTypeKindCapitalize:
			return str.charAt(0).toUpperCase() + str.slice(1)
		case IntrinsicTypeKindUncapitalize:
			return str.charAt(0).toLowerCase() + str.slice(1)
		}
		return str
	}
	applyTemplateStringMapping := func(symbol Symbol, texts []string, types []Type) /* TODO(TS-TO-GO) TypeNode TupleType: [texts: readonly string[], types: readonly Type[]] */ any {
		switch intrinsicTypeKinds.get(symbol.escapedName /* as string */) {
		case IntrinsicTypeKindUppercase:
			return []any{texts.map_(func(t string) string {
				return t.toUpperCase()
			}), types.map_(func(t Type) Type {
				return getStringMappingType(symbol, t)
			})}
		case IntrinsicTypeKindLowercase:
			return []any{texts.map_(func(t string) string {
				return t.toLowerCase()
			}), types.map_(func(t Type) Type {
				return getStringMappingType(symbol, t)
			})}
		case IntrinsicTypeKindCapitalize:
			return []any{__COND__(texts[0] == "", texts, []string{texts[0].charAt(0).toUpperCase() + texts[0].slice(1) /* TODO(TS-TO-GO) Node SpreadElement: ...texts.slice(1) */}), __COND__(texts[0] == "", []Type{getStringMappingType(symbol, types[0]) /* TODO(TS-TO-GO) Node SpreadElement: ...types.slice(1) */}, types)}
		case IntrinsicTypeKindUncapitalize:
			return []any{__COND__(texts[0] == "", texts, []string{texts[0].charAt(0).toLowerCase() + texts[0].slice(1) /* TODO(TS-TO-GO) Node SpreadElement: ...texts.slice(1) */}), __COND__(texts[0] == "", []Type{getStringMappingType(symbol, types[0]) /* TODO(TS-TO-GO) Node SpreadElement: ...types.slice(1) */}, types)}
		}
		return []any{texts, types}
	}
	getStringMappingTypeForGenericType := func(symbol Symbol, type_ Type) Type {
		id := __TEMPLATE__(getSymbolId(symbol), ",", getTypeId(type_))
		result := stringMappingTypes.get(id)
		if !result {
			stringMappingTypes.set(id /* TODO(TS-TO-GO) Node BinaryExpression: result = createStringMappingType(symbol, type) */, TODO)
		}
		return result
	}
	createStringMappingType := func(symbol Symbol, type_ Type) StringMappingType {
		result := createTypeWithSymbol(TypeFlagsStringMapping, symbol) /* as StringMappingType */
		result.type_ = type_
		return result
	}
	createIndexedAccessType := func(objectType Type, indexType Type, accessFlags AccessFlags, aliasSymbol Symbol, aliasTypeArguments *[]Type) IndexedAccessType {
		type_ := createType(TypeFlagsIndexedAccess) /* as IndexedAccessType */
		type_.objectType = objectType
		type_.indexType = indexType
		type_.accessFlags = accessFlags
		type_.aliasSymbol = aliasSymbol
		type_.aliasTypeArguments = aliasTypeArguments
		return type_
	}
	/**
	 * Returns if a type is or consists of a JSLiteral object type
	 * In addition to objects which are directly literals,
	 * * unions where every element is a jsliteral
	 * * intersections where at least one element is a jsliteral
	 * * and instantiable types constrained to a jsliteral
	 * Should all count as literals and not print errors on access or assignment of possibly existing properties.
	 * This mirrors the behavior of the index signature propagation, to which this behaves similarly (but doesn't affect assignability or inference).
	 */
	isJSLiteralType := func(type_ Type) bool {
		if noImplicitAny {
			return false
			// Flag is meaningless under `noImplicitAny` mode
		}
		if getObjectFlags(type_) & ObjectFlagsJSLiteral {
			return true
		}
		if type_.flags & TypeFlagsUnion {
			return every((type_ /* as UnionType */).types, isJSLiteralType)
		}
		if type_.flags & TypeFlagsIntersection {
			return some((type_ /* as IntersectionType */).types, isJSLiteralType)
		}
		if type_.flags & TypeFlagsInstantiable {
			constraint := getResolvedBaseConstraint(type_)
			return constraint != type_ && isJSLiteralType(constraint)
		}
		return false
	}
	getPropertyNameFromIndex := func(indexType Type, accessNode /* TODO(TS-TO-GO) TypeNode UnionType: PropertyName | ObjectBindingPattern | ArrayBindingPattern | IndexedAccessTypeNode | ElementAccessExpression | SyntheticExpression | undefined */ any) *__String {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isTypeUsableAsPropertyName(indexType):
			return getPropertyNameFromType(indexType)
		case accessNode && isPropertyName(accessNode):
			return getPropertyNameForPropertyNameNode(accessNode)
		default:
			return nil
		}
	}
	isUncalledFunctionReference := func(node Node, symbol Symbol) bool {
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod) {
			parent := findAncestor(node.parent, func(n Node) bool {
				return !isAccessExpression(n)
			}) || node.parent
			if isCallLikeExpression(parent) {
				return isCallOrNewExpression(parent) && isIdentifier(node) && hasMatchingArgument(parent, node)
			}
			return every(symbol.declarations, func(d Declaration) bool {
				return !isFunctionLike(d) || isDeprecatedDeclaration(d)
			})
		}
		return true
	}
	getPropertyTypeForIndexType := func(originalObjectType Type, objectType Type, indexType Type, fullIndexType Type, accessNode /* TODO(TS-TO-GO) TypeNode UnionType: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression | undefined */ any, accessFlags AccessFlags) Type {
		var accessExpression *ElementAccessExpression
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case accessNode && accessNode.kind == SyntaxKindElementAccessExpression:
			accessExpression = accessNode
		default:
			accessExpression = nil
		}
		var propName *__String
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case accessNode && isPrivateIdentifier(accessNode):
			propName = nil
		default:
			propName = getPropertyNameFromIndex(indexType, accessNode)
		}
		if propName != nil {
			if accessFlags & AccessFlagsContextual {
				return getTypeOfPropertyOfContextualType(objectType, propName) || anyType
			}
			prop := getPropertyOfType(objectType, propName)
			if prop {
				if accessFlags&AccessFlagsReportDeprecated && accessNode && prop.declarations && isDeprecatedSymbol(prop) && isUncalledFunctionReference(accessNode, prop) {
					deprecatedNode := /* TODO(TS-TO-GO) Node BinaryExpression: accessExpression?.argumentExpression ?? (isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode) */ TODO
					addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName /* as string */)
				}
				if accessExpression {
					markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess(accessExpression.expression, objectType.symbol))
					if isAssignmentToReadonlyEntity(accessExpression, prop, getAssignmentTargetKind(accessExpression)) {
						error(accessExpression.argumentExpression, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop))
						return nil
					}
					if accessFlags & AccessFlagsCacheSymbol {
						getNodeLinks(accessNode).resolvedSymbol = prop
					}
					if isThisPropertyAccessInConstructor(accessExpression, prop) {
						return autoType
					}
				}
				var propType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case accessFlags & AccessFlagsWriting:
					propType = getWriteTypeOfSymbol(prop)
				default:
					propType = getTypeOfSymbol(prop)
				}
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case accessExpression && getAssignmentTargetKind(accessExpression) != AssignmentKindDefinite:
					return getFlowTypeOfReference(accessExpression, propType)
				case accessNode && isIndexedAccessTypeNode(accessNode) && containsMissingType(propType):
					return getUnionType([]Type{propType, undefinedType})
				default:
					return propType
				}
			}
			if everyType(objectType, isTupleType) && isNumericLiteralName(propName) {
				index := +propName
				if accessNode && everyType(objectType, func(t Type) bool {
					return !((t /* as TupleTypeReference */).target.combinedFlags & ElementFlagsVariable)
				}) && !(accessFlags & AccessFlagsAllowMissing) {
					indexNode := getIndexNodeForAccessExpression(accessNode)
					if isTupleType(objectType) {
						if index < 0 {
							error(indexNode, Diagnostics.A_tuple_type_cannot_be_indexed_with_a_negative_value)
							return undefinedType
						}
						error(indexNode, Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2, typeToString(objectType), getTypeReferenceArity(objectType), unescapeLeadingUnderscores(propName))
					} else {
						error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType))
					}
				}
				if index >= 0 {
					errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType))
					return getTupleElementTypeOutOfStartCount(objectType, index, __COND__(accessFlags&AccessFlagsIncludeUndefined, missingType, nil))
				}
			}
		}
		if !(indexType.flags & TypeFlagsNullable) && isTypeAssignableToKind(indexType, TypeFlagsStringLike|TypeFlagsNumberLike|TypeFlagsESSymbolLike) {
			if objectType.flags & (TypeFlagsAny | TypeFlagsNever) {
				return objectType
			}
			// If no index signature is applicable, we default to the string index signature. In effect, this means the string
			// index signature applies even when accessing with a symbol-like type.
			indexInfo := getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(objectType, stringType)
			if indexInfo {
				if accessFlags&AccessFlagsNoIndexSignatures && indexInfo.keyType != numberType {
					if accessExpression {
						if accessFlags & AccessFlagsWriting {
							error(accessExpression, Diagnostics.Type_0_is_generic_and_can_only_be_indexed_for_reading, typeToString(originalObjectType))
						} else {
							error(accessExpression, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType))
						}
					}
					return nil
				}
				if accessNode && indexInfo.keyType == stringType && !isTypeAssignableToKind(indexType, TypeFlagsString|TypeFlagsNumber) {
					indexNode := getIndexNodeForAccessExpression(accessNode)
					error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType))
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case accessFlags & AccessFlagsIncludeUndefined:
						return getUnionType([]Type{indexInfo.type_, missingType})
					default:
						return indexInfo.type_
					}
				}
				errorIfWritingToReadonlyIndex(indexInfo)
				// When accessing an enum object with its own type,
				// e.g. E[E.A] for enum E { A }, undefined shouldn't
				// be included in the result type
				if (accessFlags & AccessFlagsIncludeUndefined) && !(objectType.symbol && objectType.symbol.flags&(SymbolFlagsRegularEnum|SymbolFlagsConstEnum) && (indexType.symbol && indexType.flags&TypeFlagsEnumLiteral && getParentOfSymbol(indexType.symbol) == objectType.symbol)) {
					return getUnionType([]Type{indexInfo.type_, missingType})
				}
				return indexInfo.type_
			}
			if indexType.flags & TypeFlagsNever {
				return neverType
			}
			if isJSLiteralType(objectType) {
				return anyType
			}
			if accessExpression && !isConstEnumObjectType(objectType) {
				if isObjectLiteralType(objectType) {
					if noImplicitAny && indexType.flags&(TypeFlagsStringLiteral|TypeFlagsNumberLiteral) {
						diagnostics.add(createDiagnosticForNode(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType /* as StringLiteralType */).value, typeToString(objectType)))
						return undefinedType
					} else if indexType.flags & (TypeFlagsNumber | TypeFlagsString) {
						types := map_((objectType /* as ResolvedType */).properties, func(property Symbol) Type {
							return getTypeOfSymbol(property)
						})
						return getUnionType(append(types, undefinedType))
					}
				}
				if objectType.symbol == globalThisSymbol && propName != nil && globalThisSymbol.exports.has(propName) && (globalThisSymbol.exports.get(propName).flags & SymbolFlagsBlockScoped) {
					error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType))
				} else if noImplicitAny && !(accessFlags & AccessFlagsSuppressNoImplicitAnyError) {
					if propName != nil && typeHasStaticProperty(propName, objectType) {
						typeName := typeToString(objectType)
						error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName /* as string */, typeName, typeName+"["+getTextOfNode(accessExpression.argumentExpression)+"]")
					} else if getIndexTypeOfType(objectType, numberType) {
						error(accessExpression.argumentExpression, Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number)
					} else {
						var suggestion *string
						if propName != nil && ( /* TODO(TS-TO-GO) Node BinaryExpression: suggestion = getSuggestionForNonexistentProperty(propName as string, objectType) */ TODO) {
							if suggestion != nil {
								error(accessExpression.argumentExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName /* as string */, typeToString(objectType), suggestion)
							}
						} else {
							suggestion := getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType)
							if suggestion != nil {
								error(accessExpression, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion)
							} else {
								var errorInfo *DiagnosticMessageChain
								if indexType.flags & TypeFlagsEnumLiteral {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, "["+typeToString(indexType)+"]", typeToString(objectType))
								} else if indexType.flags & TypeFlagsUniqueESSymbol {
									symbolName := getFullyQualifiedName((indexType /* as UniqueESSymbolType */).symbol, accessExpression)
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, "["+symbolName+"]", typeToString(objectType))
								} else if indexType.flags & TypeFlagsStringLiteral {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType /* as StringLiteralType */).value, typeToString(objectType))
								} else if indexType.flags & TypeFlagsNumberLiteral {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType /* as NumberLiteralType */).value, typeToString(objectType))
								} else if indexType.flags & (TypeFlagsNumber | TypeFlagsString) {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType))
								}
								errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1, typeToString(fullIndexType), typeToString(objectType))
								diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(accessExpression), accessExpression, errorInfo))
							}
						}
					}
				}
				return nil
			}
		}
		if accessFlags&AccessFlagsAllowMissing && isObjectLiteralType(objectType) {
			return undefinedType
		}
		if isJSLiteralType(objectType) {
			return anyType
		}
		if accessNode {
			indexNode := getIndexNodeForAccessExpression(accessNode)
			if indexNode.kind != SyntaxKindBigIntLiteral && indexType.flags&(TypeFlagsStringLiteral|TypeFlagsNumberLiteral) {
				error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, ""+(indexType /* as StringLiteralType | NumberLiteralType */).value, typeToString(objectType))
			} else if indexType.flags & (TypeFlagsString | TypeFlagsNumber) {
				error(indexNode, Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType))
			} else {
				var typeString string
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case indexNode.kind == SyntaxKindBigIntLiteral:
					typeString = "bigint"
				default:
					typeString = typeToString(indexType)
				}
				error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeString)
			}
		}
		if isTypeAny(indexType) {
			return indexType
		}
		return nil
		errorIfWritingToReadonlyIndex := func(indexInfo *IndexInfo) {
			if indexInfo && indexInfo.isReadonly && accessExpression && (isAssignmentTarget(accessExpression) || isDeleteTarget(accessExpression)) {
				error(accessExpression, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType))
			}
		}
	}
	getIndexNodeForAccessExpression := func(accessNode /* TODO(TS-TO-GO) TypeNode UnionType: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any) /* TODO(TS-TO-GO) inferred type Expression | TypeNode | ObjectBindingPattern | ArrayBindingPattern */ any {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case accessNode.kind == SyntaxKindElementAccessExpression:
			return accessNode.argumentExpression
		case accessNode.kind == SyntaxKindIndexedAccessType:
			return accessNode.indexType
		case accessNode.kind == SyntaxKindComputedPropertyName:
			return accessNode.expression
		default:
			return accessNode
		}
	}
	isPatternLiteralPlaceholderType := func(type_ Type) bool {
		if type_.flags & TypeFlagsIntersection {
			// Return true if the intersection consists of one or more placeholders and zero or
			// more object type tags.
			seenPlaceholder := false
			for _, t := range (type_ /* as IntersectionType */).types {
				if t.flags&(TypeFlagsLiteral|TypeFlagsNullable) || isPatternLiteralPlaceholderType(t) {
					seenPlaceholder = true
				} else if !(t.flags & TypeFlagsObject) {
					return false
				}
			}
			return seenPlaceholder
		}
		return !!(type_.flags & (TypeFlagsAny | TypeFlagsString | TypeFlagsNumber | TypeFlagsBigInt)) || isPatternLiteralType(type_)
	}
	isPatternLiteralType := func(type_ Type) bool {
		// A pattern literal type is a template literal or a string mapping type that contains only
		// non-generic pattern literal placeholders.
		return !!(type_.flags&TypeFlagsTemplateLiteral) && every((type_ /* as TemplateLiteralType */).types, isPatternLiteralPlaceholderType) || !!(type_.flags&TypeFlagsStringMapping) && isPatternLiteralPlaceholderType((type_ /* as StringMappingType */).type_)
	}
	isGenericStringLikeType := func(type_ Type) bool {
		return !!(type_.flags & (TypeFlagsTemplateLiteral | TypeFlagsStringMapping)) && !isPatternLiteralType(type_)
	}
	isGenericType := func(type_ Type) bool {
		return !!getGenericObjectFlags(type_)
	}
	isGenericObjectType := func(type_ Type) bool {
		return !!(getGenericObjectFlags(type_) & ObjectFlagsIsGenericObjectType)
	}
	isGenericIndexType := func(type_ Type) bool {
		return !!(getGenericObjectFlags(type_) & ObjectFlagsIsGenericIndexType)
	}
	getGenericObjectFlags := func(type_ Type) ObjectFlags {
		if type_.flags & (TypeFlagsUnionOrIntersection) {
			if !((type_ /* as UnionOrIntersectionType */).objectFlags & ObjectFlagsIsGenericTypeComputed) {
				(type_ /* as UnionOrIntersectionType */).objectFlags |= ObjectFlagsIsGenericTypeComputed | reduceLeft((type_ /* as UnionOrIntersectionType */).types, func(flags number, t Type) number {
					return flags | getGenericObjectFlags(t)
				}, 0)
			}
			return (type_ /* as UnionOrIntersectionType */).objectFlags & ObjectFlagsIsGenericType
		}
		if type_.flags & TypeFlagsSubstitution {
			if !((type_ /* as SubstitutionType */).objectFlags & ObjectFlagsIsGenericTypeComputed) {
				(type_ /* as SubstitutionType */).objectFlags |= ObjectFlagsIsGenericTypeComputed | getGenericObjectFlags((type_ /* as SubstitutionType */).baseType) | getGenericObjectFlags((type_ /* as SubstitutionType */).constraint)
			}
			return (type_ /* as SubstitutionType */).objectFlags & ObjectFlagsIsGenericType
		}
		return (__COND__(type_.flags&TypeFlagsInstantiableNonPrimitive || isGenericMappedType(type_) || isGenericTupleType(type_), ObjectFlagsIsGenericObjectType, 0)) | (__COND__(type_.flags&(TypeFlagsInstantiableNonPrimitive|TypeFlagsIndex) || isGenericStringLikeType(type_), ObjectFlagsIsGenericIndexType, 0))
	}
	getSimplifiedType := func(type_ Type, writing bool) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsIndexedAccess:
			return getSimplifiedIndexedAccessType(type_ /* as IndexedAccessType */, writing)
		case type_.flags & TypeFlagsConditional:
			return getSimplifiedConditionalType(type_ /* as ConditionalType */, writing)
		default:
			return type_
		}
	}
	distributeIndexOverObjectType := func(objectType Type, indexType Type, writing bool) Type {
		// (T | U)[K] -> T[K] | U[K] (reading)
		// (T | U)[K] -> T[K] & U[K] (writing)
		// (T & U)[K] -> T[K] & U[K]
		if objectType.flags&TypeFlagsUnion || objectType.flags&TypeFlagsIntersection && !shouldDeferIndexType(objectType) {
			types := map_((objectType /* as UnionOrIntersectionType */).types, func(t Type) Type {
				return getSimplifiedType(getIndexedAccessType(t, indexType), writing)
			})
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case objectType.flags&TypeFlagsIntersection || writing:
				return getIntersectionType(types)
			default:
				return getUnionType(types)
			}
		}
	}
	distributeObjectOverIndexType := func(objectType Type, indexType Type, writing bool) Type {
		// T[A | B] -> T[A] | T[B] (reading)
		// T[A | B] -> T[A] & T[B] (writing)
		if indexType.flags & TypeFlagsUnion {
			types := map_((indexType /* as UnionType */).types, func(t Type) Type {
				return getSimplifiedType(getIndexedAccessType(objectType, t), writing)
			})
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case writing:
				return getIntersectionType(types)
			default:
				return getUnionType(types)
			}
		}
	}
	// Transform an indexed access to a simpler form, if possible. Return the simpler form, or return
	// the type itself if no transformation is possible. The writing flag indicates that the type is
	// the target of an assignment.
	getSimplifiedIndexedAccessType := func(type_ IndexedAccessType, writing bool) Type {
		var cache /* TODO(TS-TO-GO) inferred type "simplifiedForWriting" | "simplifiedForReading" */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case writing:
			cache = "simplifiedForWriting"
		default:
			cache = "simplifiedForReading"
		}
		if type_[cache] {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case type_[cache] == circularConstraintType:
				return type_
			default:
				return type_[cache]
			}
		}
		type_[cache] = circularConstraintType
		// We recursively simplify the object type as it may in turn be an indexed access type. For example, with
		// '{ [P in T]: { [Q in U]: number } }[T][U]' we want to first simplify the inner indexed access type.
		objectType := getSimplifiedType(type_.objectType, writing)
		indexType := getSimplifiedType(type_.indexType, writing)
		// T[A | B] -> T[A] | T[B] (reading)
		// T[A | B] -> T[A] & T[B] (writing)
		distributedOverIndex := distributeObjectOverIndexType(objectType, indexType, writing)
		if distributedOverIndex {
			type_[cache] = distributedOverIndex
			return type_[cache]
		}
		// Only do the inner distributions if the index can no longer be instantiated to cause index distribution again
		if !(indexType.flags & TypeFlagsInstantiable) {
			// (T | U)[K] -> T[K] | U[K] (reading)
			// (T | U)[K] -> T[K] & U[K] (writing)
			// (T & U)[K] -> T[K] & U[K]
			distributedOverObject := distributeIndexOverObjectType(objectType, indexType, writing)
			if distributedOverObject {
				type_[cache] = distributedOverObject
				return type_[cache]
			}
		}
		// So ultimately (reading):
		// ((A & B) | C)[K1 | K2] -> ((A & B) | C)[K1] | ((A & B) | C)[K2] -> (A & B)[K1] | C[K1] | (A & B)[K2] | C[K2] -> (A[K1] & B[K1]) | C[K1] | (A[K2] & B[K2]) | C[K2]
		// A generic tuple type indexed by a number exists only when the index type doesn't select a
		// fixed element. We simplify to either the combined type of all elements (when the index type
		// the actual number type) or to the combined type of all non-fixed elements.
		if isGenericTupleType(objectType) && indexType.flags&TypeFlagsNumberLike {
			elementType := getElementTypeOfSliceOfTupleType(objectType, __COND__(indexType.flags&TypeFlagsNumber, 0, objectType.target.fixedLength) /*endSkipCount*/, 0, writing)
			if elementType {
				type_[cache] = elementType
				return type_[cache]
			}
		}
		// If the object type is a mapped type { [P in K]: E }, where K is generic, or { [P in K as N]: E }, where
		// K is generic and N is assignable to P, instantiate E using a mapper that substitutes the index type for P.
		// For example, for an index access { [P in K]: Box<T[P]> }[X], we construct the type Box<T[X]>.
		if isGenericMappedType(objectType) {
			if getMappedTypeNameTypeKind(objectType) != MappedTypeNameTypeKindRemapping {
				type_[cache] = mapType(substituteIndexedMappedType(objectType, type_.indexType), func(t Type) Type {
					return getSimplifiedType(t, writing)
				})
				return type_[cache]
			}
		}
		type_[cache] = type_
		return type_[cache]
	}
	getSimplifiedConditionalType := func(type_ ConditionalType, writing bool) Type {
		checkType := type_.checkType
		extendsType := type_.extendsType
		trueType := getTrueTypeFromConditionalType(type_)
		falseType := getFalseTypeFromConditionalType(type_)
		// Simplifications for types of the form `T extends U ? T : never` and `T extends U ? never : T`.
		if falseType.flags&TypeFlagsNever && getActualTypeVariable(trueType) == getActualTypeVariable(checkType) {
			if checkType.flags&TypeFlagsAny || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType)) {
				return getSimplifiedType(trueType, writing)
			} else if isIntersectionEmpty(checkType, extendsType) {
				return neverType
			}
		} else if trueType.flags&TypeFlagsNever && getActualTypeVariable(falseType) == getActualTypeVariable(checkType) {
			if !(checkType.flags & TypeFlagsAny) && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType)) {
				return neverType
			} else if checkType.flags&TypeFlagsAny || isIntersectionEmpty(checkType, extendsType) {
				return getSimplifiedType(falseType, writing)
			}
		}
		return type_
	}
	/**
	 * Invokes union simplification logic to determine if an intersection is considered empty as a union constituent
	 */
	isIntersectionEmpty := func(type1 Type, type2 Type) bool {
		return !!(getUnionType([]Type{intersectTypes(type1, type2), neverType}).flags & TypeFlagsNever)
	}
	// Given an indexed access on a mapped type of the form { [P in K]: E }[X], return an instantiation of E where P is
	// replaced with X. Since this simplification doesn't account for mapped type modifiers, add 'undefined' to the
	// resulting type if the mapped type includes a '?' modifier or if the modifiers type indicates that some properties
	// are optional. If the modifiers type is generic, conservatively estimate optionality by recursively looking for
	// mapped types that include '?' modifiers.
	substituteIndexedMappedType := func(objectType MappedType, index Type) Type {
		mapper := createTypeMapper([]TypeParameter{getTypeParameterFromMappedType(objectType)}, []Type{index})
		templateMapper := combineTypeMappers(objectType.mapper, mapper)
		instantiatedTemplateType := instantiateType(getTemplateTypeFromMappedType(objectType.target /* as MappedType */ || objectType), templateMapper)
		isOptional := getMappedTypeOptionality(objectType) > 0 || (__COND__(isGenericType(objectType), getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(objectType)) > 0, couldAccessOptionalProperty(objectType, index)))
		return addOptionality(instantiatedTemplateType /*isProperty*/, true, isOptional)
	}
	// Return true if an indexed access with the given object and index types could access an optional property.
	couldAccessOptionalProperty := func(objectType Type, indexType Type) bool {
		indexConstraint := getBaseConstraintOfType(indexType)
		return !!indexConstraint && some(getPropertiesOfType(objectType), func(p Symbol) bool {
			return !!(p.flags & SymbolFlagsOptional) && isTypeAssignableTo(getLiteralTypeFromProperty(p, TypeFlagsStringOrNumberLiteralOrUnique), indexConstraint)
		})
	}
	getIndexedAccessType := func(objectType Type, indexType Type, accessFlags AccessFlags /*  = AccessFlags.None */, accessNode /* TODO(TS-TO-GO) TypeNode UnionType: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		return getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || (__COND__(accessNode, errorType, unknownType))
	}
	indexTypeLessThan := func(indexType Type, limit number) bool {
		return everyType(indexType, func(t Type) bool {
			if t.flags & TypeFlagsStringOrNumberLiteral {
				propName := getPropertyNameFromType(t /* as StringLiteralType | NumberLiteralType */)
				if isNumericLiteralName(propName) {
					index := +propName
					return index >= 0 && index < limit
				}
			}
			return false
		})
	}
	getIndexedAccessTypeOrUndefined := func(objectType Type, indexType Type, accessFlags AccessFlags /*  = AccessFlags.None */, accessNode /* TODO(TS-TO-GO) TypeNode UnionType: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		if objectType == wildcardType || indexType == wildcardType {
			return wildcardType
		}
		objectType = getReducedType(objectType)
		// If the object type has a string index signature and no other members we know that the result will
		// always be the type of that index signature and we can simplify accordingly.
		if isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & TypeFlagsNullable) && isTypeAssignableToKind(indexType, TypeFlagsString|TypeFlagsNumber) {
			indexType = stringType
		}
		// In noUncheckedIndexedAccess mode, indexed access operations that occur in an expression in a read position and resolve to
		// an index signature have 'undefined' included in their type.
		if compilerOptions.noUncheckedIndexedAccess && accessFlags&AccessFlagsExpressionPosition {
			accessFlags |= AccessFlagsIncludeUndefined
		}
		// If the index type is generic, or if the object type is generic and doesn't originate in an expression and
		// the operation isn't exclusively indexing the fixed (non-variadic) portion of a tuple type, we are performing
		// a higher-order index access where we cannot meaningfully access the properties of the object type. Note that
		// for a generic T and a non-generic K, we eagerly resolve T[K] if it originates in an expression. This is to
		// preserve backwards compatibility. For example, an element access 'this["foo"]' has always been resolved
		// eagerly using the constraint type of 'this' at the given location.
		if isGenericIndexType(indexType) || (__COND__(accessNode && accessNode.kind != SyntaxKindIndexedAccessType, isGenericTupleType(objectType) && !indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target)), isGenericObjectType(objectType) && !(isTupleType(objectType) && indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target))) || isGenericReducibleType(objectType))) {
			if objectType.flags & TypeFlagsAnyOrUnknown {
				return objectType
			}
			// Defer the operation by creating an indexed access type.
			persistentAccessFlags := accessFlags & AccessFlagsPersistent
			id := objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(aliasSymbol, aliasTypeArguments)
			type_ := indexedAccessTypes.get(id)
			if !type_ {
				indexedAccessTypes.set(id /* TODO(TS-TO-GO) Node BinaryExpression: type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments) */, TODO)
			}
			return type_
		}
		// In the following we resolve T[K] to the type of the property in T selected by K.
		// We treat boolean as different from other unions to improve errors;
		// skipping straight to getPropertyTypeForIndexType gives errors with 'boolean' instead of 'true'.
		apparentObjectType := getReducedApparentType(objectType)
		if indexType.flags&TypeFlagsUnion && !(indexType.flags & TypeFlagsBoolean) {
			var propTypes []Type = []never{}
			wasMissingProp := false
			for _, t := range (indexType /* as UnionType */).types {
				propType := getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags|(__COND__(wasMissingProp, AccessFlagsSuppressNoImplicitAnyError, 0)))
				if propType {
					propTypes.push(propType)
				} else if !accessNode {
					// If there's no error node, we can immeditely stop, since error reporting is off
					return nil
				} else {
					// Otherwise we set a flag and return at the end of the loop so we still mark all errors
					wasMissingProp = true
				}
			}
			if wasMissingProp {
				return nil
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case accessFlags & AccessFlagsWriting:
				return getIntersectionType(propTypes, IntersectionFlagsNone, aliasSymbol, aliasTypeArguments)
			default:
				return getUnionType(propTypes, UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
			}
		}
		return getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode, accessFlags|AccessFlagsCacheSymbol|AccessFlagsReportDeprecated)
	}
	getTypeFromIndexedAccessTypeNode := func(node IndexedAccessTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			objectType := getTypeFromTypeNode(node.objectType)
			indexType := getTypeFromTypeNode(node.indexType)
			potentialAlias := getAliasSymbolForTypeNode(node)
			links.resolvedType = getIndexedAccessType(objectType, indexType, AccessFlagsNone, node, potentialAlias, getTypeArgumentsForAliasSymbol(potentialAlias))
		}
		return links.resolvedType
	}
	getTypeFromMappedTypeNode := func(node MappedTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			type_ := createObjectType(ObjectFlagsMapped, node.symbol) /* as MappedType */
			type_.declaration = node
			type_.aliasSymbol = getAliasSymbolForTypeNode(node)
			type_.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type_.aliasSymbol)
			links.resolvedType = type_
			// Eagerly resolve the constraint type which forces an error if the constraint type circularly
			// references itself through one or more type aliases.
			getConstraintTypeFromMappedType(type_)
		}
		return links.resolvedType
	}
	getActualTypeVariable := func(type_ Type) Type {
		if type_.flags & TypeFlagsSubstitution {
			return getActualTypeVariable((type_ /* as SubstitutionType */).baseType)
		}
		if type_.flags&TypeFlagsIndexedAccess && ((type_ /* as IndexedAccessType */).objectType.flags&TypeFlagsSubstitution || (type_ /* as IndexedAccessType */).indexType.flags&TypeFlagsSubstitution) {
			return getIndexedAccessType(getActualTypeVariable((type_ /* as IndexedAccessType */).objectType), getActualTypeVariable((type_ /* as IndexedAccessType */).indexType))
		}
		return type_
	}
	isSimpleTupleType := func(node TypeNode) bool {
		return isTupleTypeNode(node) && length(node.elements) > 0 && !some(node.elements, func(e /* TODO(TS-TO-GO) inferred type TypeNode | NamedTupleMember */ any) bool {
			return isOptionalTypeNode(e) || isRestTypeNode(e) || isNamedTupleMember(e) && !!(e.questionToken || e.dotDotDotToken)
		})
	}
	isDeferredType := func(type_ Type, checkTuples bool) bool {
		return isGenericType(type_) || checkTuples && isTupleType(type_) && some(getElementTypes(type_), isGenericType)
	}
	getConditionalType := func(root ConditionalRoot, mapper *TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		var result TODO
		var extraTypes *[]Type
		tailCount := 0
		// We loop here for an immediately nested conditional type in the false position, effectively treating
		// types of the form 'A extends B ? X : C extends D ? Y : E extends F ? Z : ...' as a single construct for
		// purposes of resolution. We also loop here when resolution of a conditional type ends in resolution of
		// another (or, through recursion, possibly the same) conditional type. In the potentially tail-recursive
		// cases we increment the tail recursion counter and stop after 1000 iterations.
		for true {
			if tailCount == 1000 {
				error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite)
				return errorType
			}
			checkType := instantiateType(getActualTypeVariable(root.checkType), mapper)
			extendsType := instantiateType(root.extendsType, mapper)
			if checkType == errorType || extendsType == errorType {
				return errorType
			}
			if checkType == wildcardType || extendsType == wildcardType {
				return wildcardType
			}
			checkTypeNode := skipTypeParentheses(root.node.checkType)
			extendsTypeNode := skipTypeParentheses(root.node.extendsType)
			// When the check and extends types are simple tuple types of the same arity, we defer resolution of the
			// conditional type when any tuple elements are generic. This is such that non-distributable conditional
			// types can be written `[X] extends [Y] ? ...` and be deferred similarly to `X extends Y ? ...`.
			checkTuples := isSimpleTupleType(checkTypeNode) && isSimpleTupleType(extendsTypeNode) && length((checkTypeNode /* as TupleTypeNode */).elements) == length((extendsTypeNode /* as TupleTypeNode */).elements)
			checkTypeDeferred := isDeferredType(checkType, checkTuples)
			var combinedMapper *TypeMapper
			if root.inferTypeParameters {
				// When we're looking at making an inference for an infer type, when we get its constraint, it'll automagically be
				// instantiated with the context, so it doesn't need the mapper for the inference context - however the constraint
				// may refer to another _root_, _uncloned_ `infer` type parameter [1], or to something mapped by `mapper` [2].
				// [1] Eg, if we have `Foo<T, U extends T>` and `Foo<number, infer B>` - `B` is constrained to `T`, which, in turn, has been instantiated
				// as `number`
				// Conversely, if we have `Foo<infer A, infer B>`, `B` is still constrained to `T` and `T` is instantiated as `A`
				// [2] Eg, if we have `Foo<T, U extends T>` and `Foo<Q, infer B>` where `Q` is mapped by `mapper` into `number` - `B` is constrained to `T`
				// which is in turn instantiated as `Q`, which is in turn instantiated as `number`.
				// So we need to:
				//    * combine `context.nonFixingMapper` with `mapper` so their constraints can be instantiated in the context of `mapper` (otherwise they'd only get inference context information)
				//    * incorporate all of the component mappers into the combined mapper for the true and false members
				// This means we have two mappers that need applying:
				//    * The original `mapper` used to create this conditional
				//    * The mapper that maps the infer type parameter to its inference result (`context.mapper`)
				context := createInferenceContext(root.inferTypeParameters /*signature*/, nil, InferenceFlagsNone)
				if mapper {
					context.nonFixingMapper = combineTypeMappers(context.nonFixingMapper, mapper)
				}
				if !checkTypeDeferred {
					// We don't want inferences from constraints as they may cause us to eagerly resolve the
					// conditional type instead of deferring resolution. Also, we always want strict function
					// types rules (i.e. proper contravariance) for inferences.
					inferTypes(context.inferences, checkType, extendsType, InferencePriorityNoConstraints|InferencePriorityAlwaysStrict)
				}
				// It's possible for 'infer T' type paramteters to be given uninstantiated constraints when the
				// those type parameters are used in type references (see getInferredTypeParameterConstraint). For
				// that reason we need context.mapper to be first in the combined mapper. See #42636 for examples.
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case mapper:
					combinedMapper = combineTypeMappers(context.mapper, mapper)
				default:
					combinedMapper = context.mapper
				}
			}
			// Instantiate the extends type including inferences for 'infer T' type parameters
			var inferredExtendsType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case combinedMapper:
				inferredExtendsType = instantiateType(root.extendsType, combinedMapper)
			default:
				inferredExtendsType = extendsType
			}
			// We attempt to resolve the conditional type only when the check and extends types are non-generic
			if !checkTypeDeferred && !isDeferredType(inferredExtendsType, checkTuples) {
				// Return falseType for a definitely false extends check. We check an instantiations of the two
				// types with type parameters mapped to the wildcard type, the most permissive instantiations
				// possible (the wildcard type is assignable to and from all types). If those are not related,
				// then no instantiations will be and we can just return the false branch type.
				if !(inferredExtendsType.flags & TypeFlagsAnyOrUnknown) && (checkType.flags&TypeFlagsAny || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType))) {
					// Return union of trueType and falseType for 'any' since it matches anything. Furthermore, for a
					// distributive conditional type applied to the constraint of a type variable, include trueType if
					// there are possible values of the check type that are also possible values of the extends type.
					// We use a reverse assignability check as it is less expensive than the comparable relationship
					// and avoids false positives of a non-empty intersection check.
					if checkType.flags&TypeFlagsAny || forConstraint && !(inferredExtendsType.flags&TypeFlagsNever) && someType(getPermissiveInstantiation(inferredExtendsType), func(t Type) bool {
						return isTypeAssignableTo(t, getPermissiveInstantiation(checkType))
					}) {
						(extraTypes || ( /* TODO(TS-TO-GO) Node BinaryExpression: extraTypes = [] */ TODO)).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper))
					}
					// If falseType is an immediately nested conditional type that isn't distributive or has an
					// identical checkType, switch to that type and loop.
					falseType := getTypeFromTypeNode(root.node.falseType)
					if falseType.flags & TypeFlagsConditional {
						newRoot := (falseType /* as ConditionalType */).root
						if newRoot.node.parent == root.node && (!newRoot.isDistributive || newRoot.checkType == root.checkType) {
							root = newRoot
							continue
						}
						if canTailRecurse(falseType, mapper) {
							continue
						}
					}
					result = instantiateType(falseType, mapper)
					break
				}
				// Return trueType for a definitely true extends check. We check instantiations of the two
				// types with type parameters mapped to their restrictive form, i.e. a form of the type parameter
				// that has no constraint. This ensures that, for example, the type
				//   type Foo<T extends { x: any }> = T extends { x: string } ? string : number
				// doesn't immediately resolve to 'string' instead of being deferred.
				if inferredExtendsType.flags&TypeFlagsAnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType)) {
					trueType := getTypeFromTypeNode(root.node.trueType)
					trueMapper := combinedMapper || mapper
					if canTailRecurse(trueType, trueMapper) {
						continue
					}
					result = instantiateType(trueType, trueMapper)
					break
				}
			}
			// Return a deferred type for a check that is neither definitely true nor definitely false
			result = createType(TypeFlagsConditional) /* as ConditionalType */
			result.root = root
			result.checkType = instantiateType(root.checkType, mapper)
			result.extendsType = instantiateType(root.extendsType, mapper)
			result.mapper = mapper
			result.combinedMapper = combinedMapper
			result.aliasSymbol = aliasSymbol || root.aliasSymbol
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case aliasSymbol:
				result.aliasTypeArguments = aliasTypeArguments
			default:
				result.aliasTypeArguments = instantiateTypes(root.aliasTypeArguments, mapper)
			}
			// TODO: GH#18217
			break
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case extraTypes:
			return getUnionType(append(extraTypes, result))
		default:
			return result
		}
		// We tail-recurse for generic conditional types that (a) have not already been evaluated and cached, and
		// (b) are non distributive, have a check type that is unaffected by instantiation, or have a non-union check
		// type. Note that recursion is possible only through aliased conditional types, so we only increment the tail
		// recursion counter for those.
		canTailRecurse := func(newType Type, newMapper *TypeMapper) bool {
			if newType.flags&TypeFlagsConditional && newMapper {
				newRoot := (newType /* as ConditionalType */).root
				if newRoot.outerTypeParameters {
					typeParamMapper := combineTypeMappers((newType /* as ConditionalType */).mapper, newMapper)
					typeArguments := map_(newRoot.outerTypeParameters, func(t TypeParameter) Type {
						return getMappedType(t, typeParamMapper)
					})
					newRootMapper := createTypeMapper(newRoot.outerTypeParameters, typeArguments)
					var newCheckType Type
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case newRoot.isDistributive:
						newCheckType = getMappedType(newRoot.checkType, newRootMapper)
					default:
						newCheckType = nil
					}
					if !newCheckType || newCheckType == newRoot.checkType || !(newCheckType.flags & (TypeFlagsUnion | TypeFlagsNever)) {
						root = newRoot
						mapper = newRootMapper
						aliasSymbol = nil
						aliasTypeArguments = nil
						if newRoot.aliasSymbol {
							tailCount++
						}
						return true
					}
				}
			}
			return false
		}
	}
	getTrueTypeFromConditionalType := func(type_ ConditionalType) Type {
		return type_.resolvedTrueType || ( /* TODO(TS-TO-GO) Node BinaryExpression: type.resolvedTrueType = instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.mapper) */ TODO)
	}
	getFalseTypeFromConditionalType := func(type_ ConditionalType) Type {
		return type_.resolvedFalseType || ( /* TODO(TS-TO-GO) Node BinaryExpression: type.resolvedFalseType = instantiateType(getTypeFromTypeNode(type.root.node.falseType), type.mapper) */ TODO)
	}
	getInferredTrueTypeFromConditionalType := func(type_ ConditionalType) Type {
		return type_.resolvedInferredTrueType || ( /* TODO(TS-TO-GO) Node BinaryExpression: type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.combinedMapper) : getTrueTypeFromConditionalType(type) */ TODO)
	}
	getInferTypeParameters := func(node ConditionalTypeNode) *[]TypeParameter {
		var result *[]TypeParameter
		if node.locals {
			node.locals.forEach(func(symbol Symbol) {
				if symbol.flags & SymbolFlagsTypeParameter {
					result = append(result, getDeclaredTypeOfSymbol(symbol))
				}
			})
		}
		return result
	}
	isDistributionDependent := func(root ConditionalRoot) bool {
		return root.isDistributive && (isTypeParameterPossiblyReferenced(root.checkType /* as TypeParameter */, root.node.trueType) || isTypeParameterPossiblyReferenced(root.checkType /* as TypeParameter */, root.node.falseType))
	}
	getTypeFromConditionalTypeNode := func(node ConditionalTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			checkType := getTypeFromTypeNode(node.checkType)
			aliasSymbol := getAliasSymbolForTypeNode(node)
			aliasTypeArguments := getTypeArgumentsForAliasSymbol(aliasSymbol)
			allOuterTypeParameters := getOuterTypeParameters(node /*includeThisTypes*/, true)
			var outerTypeParameters *[]TypeParameter
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case aliasTypeArguments:
				outerTypeParameters = allOuterTypeParameters
			default:
				outerTypeParameters = filter(allOuterTypeParameters, func(tp TypeParameter) bool {
					return isTypeParameterPossiblyReferenced(tp, node)
				})
			}
			var root ConditionalRoot = map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"node":                node,
				"checkType":           checkType,
				"extendsType":         getTypeFromTypeNode(node.extendsType),
				"isDistributive":      !!(checkType.flags & TypeFlagsTypeParameter),
				"inferTypeParameters": getInferTypeParameters(node),
				"outerTypeParameters": outerTypeParameters,
				"instantiations":      nil,
				"aliasSymbol":         aliasSymbol,
				"aliasTypeArguments":  aliasTypeArguments,
			}
			links.resolvedType = getConditionalType(root /*mapper*/, nil /*forConstraint*/, false)
			if outerTypeParameters {
				root.instantiations = NewMap[string, Type]()
				root.instantiations.set(getTypeListId(outerTypeParameters), links.resolvedType)
			}
		}
		return links.resolvedType
	}
	getTypeFromInferTypeNode := func(node InferTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter))
		}
		return links.resolvedType
	}
	getIdentifierChain := func(node EntityName) []Identifier {
		if isIdentifier(node) {
			return []Identifier{node}
		} else {
			return append(getIdentifierChain(node.left), node.right)
		}
	}
	getTypeFromImportTypeNode := func(node ImportTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			if !isLiteralImportTypeNode(node) {
				error(node.argument, Diagnostics.String_literal_expected)
				links.resolvedSymbol = unknownSymbol
				links.resolvedType = errorType
				return links.resolvedType
			}
			var targetMeaning number
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node.isTypeOf:
				targetMeaning = SymbolFlagsValue
			case node.flags & NodeFlagsJSDoc:
				targetMeaning = SymbolFlagsValue | SymbolFlagsType
			default:
				targetMeaning = SymbolFlagsType
			}
			// TODO: Future work: support unions/generics/whatever via a deferred import-type
			innerModuleSymbol := resolveExternalModuleName(node, node.argument.literal)
			if !innerModuleSymbol {
				links.resolvedSymbol = unknownSymbol
				links.resolvedType = errorType
				return links.resolvedType
			}
			isExportEquals := !!innerModuleSymbol.exports. /* TODO(TS-TO-GO): was ? */ get(InternalSymbolNameExportEquals)
			moduleSymbol := resolveExternalModuleSymbol(innerModuleSymbol /*dontResolveAlias*/, false)
			if !nodeIsMissing(node.qualifier) {
				var nameStack []Identifier = getIdentifierChain(node.qualifier)
				currentNamespace := moduleSymbol
				var current *Identifier
				for /* TODO(TS-TO-GO) Node BinaryExpression: current = nameStack.shift() */ TODO {
					var meaning number
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case nameStack.length:
						meaning = SymbolFlagsNamespace
					default:
						meaning = targetMeaning
					}
					// typeof a.b.c is normally resolved using `checkExpression` which in turn defers to `checkQualifiedName`
					// That, in turn, ultimately uses `getPropertyOfType` on the type of the symbol, which differs slightly from
					// the `exports` lookup process that only looks up namespace members which is used for most type references
					mergedResolvedSymbol := getMergedSymbol(resolveSymbol(currentNamespace))
					var symbolFromVariable Symbol
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case node.isTypeOf || isInJSFile(node) && isExportEquals:
						symbolFromVariable = getPropertyOfType(getTypeOfSymbol(mergedResolvedSymbol), current.escapedText /*skipObjectFunctionPropertyAugment*/, false /*includeTypeOnlyMembers*/, true)
					default:
						symbolFromVariable = nil
					}
					var symbolFromModule Symbol
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case node.isTypeOf:
						symbolFromModule = nil
					default:
						symbolFromModule = getSymbol(getExportsOfSymbol(mergedResolvedSymbol), current.escapedText, meaning)
					}
					next := /* TODO(TS-TO-GO) Node BinaryExpression: symbolFromModule ?? symbolFromVariable */ TODO
					if !next {
						error(current, Diagnostics.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(currentNamespace), declarationNameToString(current))
						links.resolvedType = errorType
						return links.resolvedType
					}
					getNodeLinks(current).resolvedSymbol = next
					getNodeLinks(current.parent).resolvedSymbol = next
					currentNamespace = next
				}
				links.resolvedType = resolveImportSymbolType(node, links, currentNamespace, targetMeaning)
			} else {
				if moduleSymbol.flags & targetMeaning {
					links.resolvedType = resolveImportSymbolType(node, links, moduleSymbol, targetMeaning)
				} else {
					var errorMessage DiagnosticMessage
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case targetMeaning == SymbolFlagsValue:
						errorMessage = Diagnostics.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here
					default:
						errorMessage = Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0
					}
					error(node, errorMessage, node.argument.literal.text)
					links.resolvedSymbol = unknownSymbol
					links.resolvedType = errorType
				}
			}
		}
		return links.resolvedType
	}
	resolveImportSymbolType := func(node ImportTypeNode, links NodeLinks, symbol Symbol, meaning SymbolFlags) Type {
		resolvedSymbol := resolveSymbol(symbol)
		links.resolvedSymbol = resolvedSymbol
		if meaning == SymbolFlagsValue {
			return getInstantiationExpressionType(getTypeOfSymbol(symbol), node)
			// intentionally doesn't use resolved symbol so type is cached as expected on the alias
		} else {
			return getTypeReferenceType(node, resolvedSymbol)
			// getTypeReferenceType doesn't handle aliases - it must get the resolved symbol
		}
	}
	getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode := func(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature */ any) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			// Deferred resolution of members is handled by resolveObjectTypeMembers
			aliasSymbol := getAliasSymbolForTypeNode(node)
			if getMembersOfSymbol(node.symbol).size == 0 && !aliasSymbol {
				links.resolvedType = emptyTypeLiteralType
			} else {
				type_ := createObjectType(ObjectFlagsAnonymous, node.symbol)
				type_.aliasSymbol = aliasSymbol
				type_.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol)
				if isJSDocTypeLiteral(node) && node.isArrayType {
					type_ = createArrayType(type_)
				}
				links.resolvedType = type_
			}
		}
		return links.resolvedType
	}
	getAliasSymbolForTypeNode := func(node Node) Symbol {
		host := node.parent
		for isParenthesizedTypeNode(host) || isJSDocTypeExpression(host) || isTypeOperatorNode(host) && host.operator == SyntaxKindReadonlyKeyword {
			host = host.parent
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isTypeAlias(host):
			return getSymbolOfDeclaration(host)
		default:
			return nil
		}
	}
	getTypeArgumentsForAliasSymbol := func(symbol Symbol) *[]TypeParameter {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol:
			return getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
		default:
			return nil
		}
	}
	isNonGenericObjectType := func(type_ Type) bool {
		return !!(type_.flags & TypeFlagsObject) && !isGenericMappedType(type_)
	}
	isEmptyObjectTypeOrSpreadsIntoEmptyObject := func(type_ Type) bool {
		return isEmptyObjectType(type_) || !!(type_.flags & (TypeFlagsNull | TypeFlagsUndefined | TypeFlagsBooleanLike | TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsEnumLike | TypeFlagsNonPrimitive | TypeFlagsIndex))
	}
	tryMergeUnionOfObjectTypeAndEmptyObject := func(type_ Type, readonly bool) Type {
		if !(type_.flags & TypeFlagsUnion) {
			return type_
		}
		if every((type_ /* as UnionType */).types, isEmptyObjectTypeOrSpreadsIntoEmptyObject) {
			return find((type_ /* as UnionType */).types, isEmptyObjectType) || emptyObjectType
		}
		firstType := find((type_ /* as UnionType */).types, func(t Type) bool {
			return !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t)
		})
		if !firstType {
			return type_
		}
		secondType := find((type_ /* as UnionType */).types, func(t Type) bool {
			return t != firstType && !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t)
		})
		if secondType {
			return type_
		}
		return getAnonymousPartialType(firstType)
		getAnonymousPartialType := func(type_ Type) ResolvedType {
			// gets the type as if it had been spread, but where everything in the spread is made optional
			members := createSymbolTable()
			for _, prop := range getPropertiesOfType(type_) {
				if getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlagsPrivate | ModifierFlagsProtected) {
					// do nothing, skip privates
				} else if isSpreadableProperty(prop) {
					isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
					flags := SymbolFlagsProperty | SymbolFlagsOptional
					result := createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop)|(__COND__(readonly, CheckFlagsReadonly, 0)))
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isSetonlyAccessor:
						result.links.type_ = undefinedType
					default:
						result.links.type_ = addOptionality(getTypeOfSymbol(prop) /*isProperty*/, true)
					}
					result.declarations = prop.declarations
					result.links.nameType = getSymbolLinks(prop).nameType
					result.links.syntheticOrigin = prop
					members.set(prop.escapedName, result)
				}
			}
			spread := createAnonymousType(type_.symbol, members, emptyArray, emptyArray, getIndexInfosOfType(type_))
			spread.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
			return spread
		}
	}
	/**
	 * Since the source of spread types are object literals, which are not binary,
	 * this function should be called in a left folding style, with left = previous result of getSpreadType
	 * and right = the new element to be spread.
	 */
	getSpreadType := func(left Type, right Type, symbol Symbol, objectFlags ObjectFlags, readonly bool) Type {
		if left.flags&TypeFlagsAny || right.flags&TypeFlagsAny {
			return anyType
		}
		if left.flags&TypeFlagsUnknown || right.flags&TypeFlagsUnknown {
			return unknownType
		}
		if left.flags & TypeFlagsNever {
			return right
		}
		if right.flags & TypeFlagsNever {
			return left
		}
		left = tryMergeUnionOfObjectTypeAndEmptyObject(left, readonly)
		if left.flags & TypeFlagsUnion {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case checkCrossProductUnion([]Type{left, right}):
				return mapType(left, func(t Type) Type {
					return getSpreadType(t, right, symbol, objectFlags, readonly)
				})
			default:
				return errorType
			}
		}
		right = tryMergeUnionOfObjectTypeAndEmptyObject(right, readonly)
		if right.flags & TypeFlagsUnion {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case checkCrossProductUnion([]Type{left, right}):
				return mapType(right, func(t Type) Type {
					return getSpreadType(left, t, symbol, objectFlags, readonly)
				})
			default:
				return errorType
			}
		}
		if right.flags & (TypeFlagsBooleanLike | TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsEnumLike | TypeFlagsNonPrimitive | TypeFlagsIndex) {
			return left
		}
		if isGenericObjectType(left) || isGenericObjectType(right) {
			if isEmptyObjectType(left) {
				return right
			}
			// When the left type is an intersection, we may need to merge the last constituent of the
			// intersection with the right type. For example when the left type is 'T & { a: string }'
			// and the right type is '{ b: string }' we produce 'T & { a: string, b: string }'.
			if left.flags & TypeFlagsIntersection {
				types := (left /* as IntersectionType */).types
				lastLeft := types[types.length-1]
				if isNonGenericObjectType(lastLeft) && isNonGenericObjectType(right) {
					return getIntersectionType(concatenate(types.slice(0, types.length-1), []Type{getSpreadType(lastLeft, right, symbol, objectFlags, readonly)}))
				}
			}
			return getIntersectionType([]Type{left, right})
		}
		members := createSymbolTable()
		skippedPrivateMembers := NewSet[__String]()
		var indexInfos []IndexInfo
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case left == emptyObjectType:
			indexInfos = getIndexInfosOfType(right)
		default:
			indexInfos = getUnionIndexInfos([]Type{left, right})
		}
		for _, rightProp := range getPropertiesOfType(right) {
			if getDeclarationModifierFlagsFromSymbol(rightProp) & (ModifierFlagsPrivate | ModifierFlagsProtected) {
				skippedPrivateMembers.add(rightProp.escapedName)
			} else if isSpreadableProperty(rightProp) {
				members.set(rightProp.escapedName, getSpreadSymbol(rightProp, readonly))
			}
		}
		for _, leftProp := range getPropertiesOfType(left) {
			if skippedPrivateMembers.has(leftProp.escapedName) || !isSpreadableProperty(leftProp) {
				continue
			}
			if members.has(leftProp.escapedName) {
				rightProp := members.get(leftProp.escapedName)
				rightType := getTypeOfSymbol(rightProp)
				if rightProp.flags & SymbolFlagsOptional {
					declarations := concatenate(leftProp.declarations, rightProp.declarations)
					flags := SymbolFlagsProperty | (leftProp.flags & SymbolFlagsOptional)
					result := createSymbol(flags, leftProp.escapedName)
					// Optimization: avoid calculating the union type if spreading into the exact same type.
					// This is common, e.g. spreading one options bag into another where the bags have the
					// same type, or have properties which overlap. If the unions are large, it may turn out
					// to be expensive to perform subtype reduction.
					leftType := getTypeOfSymbol(leftProp)
					leftTypeWithoutUndefined := removeMissingOrUndefinedType(leftType)
					rightTypeWithoutUndefined := removeMissingOrUndefinedType(rightType)
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case leftTypeWithoutUndefined == rightTypeWithoutUndefined:
						result.links.type_ = leftType
					default:
						result.links.type_ = getUnionType([]Type{leftType, rightTypeWithoutUndefined}, UnionReductionSubtype)
					}
					result.links.leftSpread = leftProp
					result.links.rightSpread = rightProp
					result.declarations = declarations
					result.links.nameType = getSymbolLinks(leftProp).nameType
					members.set(leftProp.escapedName, result)
				}
			} else {
				members.set(leftProp.escapedName, getSpreadSymbol(leftProp, readonly))
			}
		}
		spread := createAnonymousType(symbol, members, emptyArray, emptyArray, sameMap(indexInfos, func(info IndexInfo) IndexInfo {
			return getIndexInfoWithReadonly(info, readonly)
		}))
		spread.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral | ObjectFlagsContainsSpread | objectFlags
		return spread
	}
	/** We approximate own properties as non-methods plus methods that are inside the object literal */
	isSpreadableProperty := func(prop Symbol) bool {
		return !some(prop.declarations, isPrivateIdentifierClassElementDeclaration) && (!(prop.flags & (SymbolFlagsMethod | SymbolFlagsGetAccessor | SymbolFlagsSetAccessor)) || !prop.declarations. /* TODO(TS-TO-GO): was ? */ some(func(decl Declaration) bool {
			return isClassLike(decl.parent)
		}))
	}
	getSpreadSymbol := func(prop Symbol, readonly bool) Symbol {
		isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
		if !isSetonlyAccessor && readonly == isReadonlySymbol(prop) {
			return prop
		}
		flags := SymbolFlagsProperty | (prop.flags & SymbolFlagsOptional)
		result := createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop)|(__COND__(readonly, CheckFlagsReadonly, 0)))
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isSetonlyAccessor:
			result.links.type_ = undefinedType
		default:
			result.links.type_ = getTypeOfSymbol(prop)
		}
		result.declarations = prop.declarations
		result.links.nameType = getSymbolLinks(prop).nameType
		result.links.syntheticOrigin = prop
		return result
	}
	getIndexInfoWithReadonly := func(info IndexInfo, readonly bool) IndexInfo {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case info.isReadonly != readonly:
			return createIndexInfo(info.keyType, info.type_, readonly, info.declaration)
		default:
			return info
		}
	}
	createLiteralType := func(flags TypeFlags, value /* TODO(TS-TO-GO) TypeNode UnionType: string | number | PseudoBigInt */ any, symbol Symbol, regularType LiteralType) LiteralType {
		type_ := createTypeWithSymbol(flags, symbol) /* as LiteralType */
		type_.value = value
		type_.regularType = regularType || type_
		return type_
	}
	getFreshTypeOfLiteralType := func(type_ Type) Type {
		if type_.flags & TypeFlagsFreshable {
			if !(type_ /* as FreshableType */).freshType {
				freshType := createLiteralType(type_.flags, (type_ /* as LiteralType */).value, (type_ /* as LiteralType */).symbol, type_ /* as LiteralType */)
				freshType.freshType = freshType
				(type_ /* as FreshableType */).freshType = freshType
			}
			return (type_ /* as FreshableType */).freshType
		}
		return type_
	}
	getRegularTypeOfLiteralType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsFreshable:
			return (type_ /* as FreshableType */).regularType
		case type_.flags & TypeFlagsUnion:
			return ((type_ /* as UnionType */).regularType || ( /* TODO(TS-TO-GO) Node BinaryExpression: (type as UnionType).regularType = mapType(type, getRegularTypeOfLiteralType) as UnionType */ TODO))
		default:
			return type_
		}
	}
	isFreshLiteralType := func(type_ Type) bool {
		return !!(type_.flags & TypeFlagsFreshable) && (type_ /* as LiteralType */).freshType == type_
	}
	getStringLiteralType := func(value string) StringLiteralType {
		var type_ TODO
		return stringLiteralTypes.get(value) || ( /* TODO(TS-TO-GO) Node BinaryExpression: stringLiteralTypes.set(value, type = createLiteralType(TypeFlags.StringLiteral, value) as StringLiteralType), type */ TODO)
	}
	getNumberLiteralType := func(value number) NumberLiteralType {
		var type_ TODO
		return numberLiteralTypes.get(value) || ( /* TODO(TS-TO-GO) Node BinaryExpression: numberLiteralTypes.set(value, type = createLiteralType(TypeFlags.NumberLiteral, value) as NumberLiteralType), type */ TODO)
	}
	getBigIntLiteralType := func(value PseudoBigInt) BigIntLiteralType {
		var type_ TODO
		key := pseudoBigIntToString(value)
		return bigIntLiteralTypes.get(key) || ( /* TODO(TS-TO-GO) Node BinaryExpression: bigIntLiteralTypes.set(key, type = createLiteralType(TypeFlags.BigIntLiteral, value) as BigIntLiteralType), type */ TODO)
	}
	getEnumLiteralType := func(value /* TODO(TS-TO-GO) TypeNode UnionType: string | number */ any, enumId number, symbol Symbol) LiteralType {
		var type_ TODO
		key := __TEMPLATE__(enumId, __COND__( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof value */ TODO == "string", "@", "#"), value)
		flags := TypeFlagsEnumLiteral | (__COND__( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof value */ TODO == "string", TypeFlagsStringLiteral, TypeFlagsNumberLiteral))
		return enumLiteralTypes.get(key) || ( /* TODO(TS-TO-GO) Node BinaryExpression: enumLiteralTypes.set(key, type = createLiteralType(flags, value, symbol)), type */ TODO)
	}
	getTypeFromLiteralTypeNode := func(node LiteralTypeNode) Type {
		if node.literal.kind == SyntaxKindNullKeyword {
			return nullType
		}
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal))
		}
		return links.resolvedType
	}
	createUniqueESSymbolType := func(symbol Symbol) UniqueESSymbolType {
		type_ := createTypeWithSymbol(TypeFlagsUniqueESSymbol, symbol)                                    /* as UniqueESSymbolType */
		type_.escapedName = __TEMPLATE__("__@", type_.symbol.escapedName, "@", getSymbolId(type_.symbol)) /* as __String */
		return type_
	}
	getESSymbolLikeTypeForNode := func(node Node) Type {
		if isInJSFile(node) && isJSDocTypeExpression(node) {
			host := getJSDocHost(node)
			if host {
				node = getSingleVariableOfVariableStatement(host) || host
			}
		}
		if isValidESSymbolDeclaration(node) {
			var symbol Symbol
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isCommonJsExportPropertyAssignment(node):
				symbol = getSymbolOfNode((node /* as BinaryExpression */).left)
			default:
				symbol = getSymbolOfNode(node)
			}
			if symbol {
				links := getSymbolLinks(symbol)
				return links.uniqueESSymbolType || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.uniqueESSymbolType = createUniqueESSymbolType(symbol) */ TODO)
			}
		}
		return esSymbolType
	}
	getThisType := func(node Node) Type {
		container := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
		parent := container && container.parent
		if parent && (isClassLike(parent) || parent.kind == SyntaxKindInterfaceDeclaration) {
			if !isStatic(container) && (!isConstructorDeclaration(container) || isNodeDescendantOf(node, container.body)) {
				return getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(parent /* as ClassLikeDeclaration | InterfaceDeclaration */)).thisType
			}
		}
		// inside x.prototype = { ... }
		if parent && isObjectLiteralExpression(parent) && isBinaryExpression(parent.parent) && getAssignmentDeclarationKind(parent.parent) == AssignmentDeclarationKindPrototype {
			return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent.parent.left).parent).thisType
		}
		// /** @return {this} */
		// x.prototype.m = function() { ... }
		var host *SignatureDeclaration
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.flags & NodeFlagsJSDoc:
			host = getHostSignatureFromJSDoc(node)
		default:
			host = nil
		}
		if host && isFunctionExpression(host) && isBinaryExpression(host.parent) && getAssignmentDeclarationKind(host.parent) == AssignmentDeclarationKindPrototypeProperty {
			return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(host.parent.left).parent).thisType
		}
		// inside constructor function C() { ... }
		if isJSConstructor(container) && isNodeDescendantOf(node, container.body) {
			return getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(container)).thisType
		}
		error(node, Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface)
		return errorType
	}
	getTypeFromThisTypeNode := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ThisExpression | ThisTypeNode */ any) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getThisType(node)
		}
		return links.resolvedType
	}
	getTypeFromRestTypeNode := func(node /* TODO(TS-TO-GO) TypeNode UnionType: RestTypeNode | NamedTupleMember */ any) Type {
		return getTypeFromTypeNode(getArrayElementTypeNode(node.type_) || node.type_)
	}
	getArrayElementTypeNode := func(node TypeNode) *TypeNode {
		switch node.kind {
		case SyntaxKindParenthesizedType:
			return getArrayElementTypeNode((node /* as ParenthesizedTypeNode */).type_)
		case SyntaxKindTupleType:
			if (node /* as TupleTypeNode */).elements.length == 1 {
				node = (node /* as TupleTypeNode */).elements[0]
				if node.kind == SyntaxKindRestType || node.kind == SyntaxKindNamedTupleMember && (node /* as NamedTupleMember */).dotDotDotToken {
					return getArrayElementTypeNode((node /* as RestTypeNode | NamedTupleMember */).type_)
				}
			}
			break
		case SyntaxKindArrayType:
			return (node /* as ArrayTypeNode */).elementType
		}
		return nil
	}
	getTypeFromNamedTupleTypeNode := func(node NamedTupleMember) Type {
		links := getNodeLinks(node)
		return links.resolvedType || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.resolvedType = node.dotDotDotToken ? getTypeFromRestTypeNode(node) : addOptionality(getTypeFromTypeNode(node.type), /*isProperty* / true, !!node.questionToken) */ TODO)
	}
	getTypeFromTypeNode := func(node TypeNode) Type {
		return getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node)
	}
	getTypeFromTypeNodeWorker := func(node TypeNode) Type {
		switch node.kind {
		case SyntaxKindAnyKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocAllType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocUnknownType:
			return anyType
		case SyntaxKindUnknownKeyword:
			return unknownType
		case SyntaxKindStringKeyword:
			return stringType
		case SyntaxKindNumberKeyword:
			return numberType
		case SyntaxKindBigIntKeyword:
			return bigintType
		case SyntaxKindBooleanKeyword:
			return booleanType
		case SyntaxKindSymbolKeyword:
			return esSymbolType
		case SyntaxKindVoidKeyword:
			return voidType
		case SyntaxKindUndefinedKeyword:
			return undefinedType
		case SyntaxKindNullKeyword /* as TypeNodeSyntaxKind */ :
			return nullType
		case SyntaxKindNeverKeyword:
			return neverType
		case SyntaxKindObjectKeyword:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node.flags&NodeFlagsJavaScriptFile && !noImplicitAny:
				return anyType
			default:
				return nonPrimitiveType
			}
		case SyntaxKindIntrinsicKeyword:
			return intrinsicMarkerType
		case SyntaxKindThisType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindThisKeyword /* as TypeNodeSyntaxKind */ :
			return getTypeFromThisTypeNode(node /* as ThisExpression | ThisTypeNode */)
		case SyntaxKindLiteralType:
			return getTypeFromLiteralTypeNode(node /* as LiteralTypeNode */)
		case SyntaxKindTypeReference:
			return getTypeFromTypeReference(node /* as TypeReferenceNode */)
		case SyntaxKindTypePredicate:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (node /* as TypePredicateNode */).assertsModifier:
				return voidType
			default:
				return booleanType
			}
		case SyntaxKindExpressionWithTypeArguments:
			return getTypeFromTypeReference(node /* as ExpressionWithTypeArguments */)
		case SyntaxKindTypeQuery:
			return getTypeFromTypeQueryNode(node /* as TypeQueryNode */)
		case SyntaxKindArrayType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTupleType:
			return getTypeFromArrayOrTupleTypeNode(node /* as ArrayTypeNode | TupleTypeNode */)
		case SyntaxKindOptionalType:
			return getTypeFromOptionalTypeNode(node /* as OptionalTypeNode */)
		case SyntaxKindUnionType:
			return getTypeFromUnionTypeNode(node /* as UnionTypeNode */)
		case SyntaxKindIntersectionType:
			return getTypeFromIntersectionTypeNode(node /* as IntersectionTypeNode */)
		case SyntaxKindJSDocNullableType:
			return getTypeFromJSDocNullableTypeNode(node /* as JSDocNullableType */)
		case SyntaxKindJSDocOptionalType:
			return addOptionality(getTypeFromTypeNode((node /* as JSDocOptionalType */).type_))
		case SyntaxKindNamedTupleMember:
			return getTypeFromNamedTupleTypeNode(node /* as NamedTupleMember */)
		case SyntaxKindParenthesizedType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocNonNullableType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocTypeExpression:
			return getTypeFromTypeNode((node /* as ParenthesizedTypeNode | JSDocTypeReferencingNode | JSDocTypeExpression | NamedTupleMember */).type_)
		case SyntaxKindRestType:
			return getTypeFromRestTypeNode(node /* as RestTypeNode */)
		case SyntaxKindJSDocVariadicType:
			return getTypeFromJSDocVariadicType(node /* as JSDocVariadicType */)
		case SyntaxKindFunctionType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindConstructorType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTypeLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocTypeLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocFunctionType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocSignature:
			return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node /* as TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature */)
		case SyntaxKindTypeOperator:
			return getTypeFromTypeOperatorNode(node /* as TypeOperatorNode */)
		case SyntaxKindIndexedAccessType:
			return getTypeFromIndexedAccessTypeNode(node /* as IndexedAccessTypeNode */)
		case SyntaxKindMappedType:
			return getTypeFromMappedTypeNode(node /* as MappedTypeNode */)
		case SyntaxKindConditionalType:
			return getTypeFromConditionalTypeNode(node /* as ConditionalTypeNode */)
		case SyntaxKindInferType:
			return getTypeFromInferTypeNode(node /* as InferTypeNode */)
		case SyntaxKindTemplateLiteralType:
			return getTypeFromTemplateTypeNode(node /* as TemplateLiteralTypeNode */)
		case SyntaxKindImportType:
			return getTypeFromImportTypeNode(node /* as ImportTypeNode */)
		case SyntaxKindIdentifier /* as TypeNodeSyntaxKind */ :
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindQualifiedName /* as TypeNodeSyntaxKind */ :
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertyAccessExpression /* as TypeNodeSyntaxKind */ :
			symbol := getSymbolAtLocation(node)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case symbol:
				return getDeclaredTypeOfSymbol(symbol)
			default:
				return errorType
			}
		default:
			return errorType
		}
	}
	/* TODO(TS-TO-GO): function instantiateList<T>(items: readonly T[], mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[]; */
	/* TODO(TS-TO-GO): function instantiateList<T>(items: readonly T[] | undefined, mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[] | undefined; */
	instantiateList := func(items *[]T, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) *[]T {
		if items && items.length {
			for i := 0; i < items.length; i++ {
				item := items[i]
				mapped := instantiator(item, mapper)
				if item != mapped {
					var result []T
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case i == 0:
						result = []never{}
					default:
						result = items.slice(0, i)
					}
					result.push(mapped)
					for i++; i < items.length; i++ {
						result.push(instantiator(items[i], mapper))
					}
					return result
				}
			}
		}
		return items
	}
	/* TODO(TS-TO-GO): function instantiateTypes(types: readonly Type[], mapper: TypeMapper): readonly Type[]; */
	/* TODO(TS-TO-GO): function instantiateTypes(types: readonly Type[] | undefined, mapper: TypeMapper): readonly Type[] | undefined; */
	instantiateTypes := func(types *[]Type, mapper TypeMapper) *[]Type {
		return instantiateList(types, mapper, instantiateType)
	}
	instantiateSignatures := func(signatures []Signature, mapper TypeMapper) []Signature {
		return instantiateList(signatures, mapper, instantiateSignature)
	}
	instantiateIndexInfos := func(indexInfos []IndexInfo, mapper TypeMapper) []IndexInfo {
		return instantiateList(indexInfos, mapper, instantiateIndexInfo)
	}
	createTypeMapper := func(sources []TypeParameter, targets *[]Type) TypeMapper {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case sources.length == 1:
			return makeUnaryTypeMapper(sources[0], __COND__(targets, targets[0], anyType))
		default:
			return makeArrayTypeMapper(sources, targets)
		}
	}
	getMappedType := func(type_ Type, mapper TypeMapper) Type {
		switch mapper.kind {
		case TypeMapKindSimple:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case type_ == mapper.source:
				return mapper.target
			default:
				return type_
			}
		case TypeMapKindArray:
			sources := mapper.sources
			targets := mapper.targets
			for i := 0; i < sources.length; i++ {
				if type_ == sources[i] {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case targets:
						return targets[i]
					default:
						return anyType
					}
				}
			}
			return type_
			fallthrough
		case TypeMapKindDeferred:
			sources := mapper.sources
			targets := mapper.targets
			for i := 0; i < sources.length; i++ {
				if type_ == sources[i] {
					return targets[i]()
				}
			}
			return type_
			fallthrough
		case TypeMapKindFunction:
			return mapper.func_(type_)
		case TypeMapKindComposite:
			fallthrough // TODO(TS-TO-GO): merge cases
		case TypeMapKindMerged:
			t1 := getMappedType(type_, mapper.mapper1)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case t1 != type_ && mapper.kind == TypeMapKindComposite:
				return instantiateType(t1, mapper.mapper2)
			default:
				return getMappedType(t1, mapper.mapper2)
			}
		}
	}
	makeUnaryTypeMapper := func(source Type, target Type) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"kind":   TypeMapKindSimple,
			"source": source,
			"target": target,
		})
	}
	makeArrayTypeMapper := func(sources []TypeParameter, targets *[]Type) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"kind":    TypeMapKindArray,
			"sources": sources,
			"targets": targets,
		})
	}
	makeFunctionTypeMapper := func(func_ func(t Type) Type, debugInfo func() string) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"kind":      TypeMapKindFunction,
			"func_":     func_,
			"debugInfo": __COND__(Debug.isDebugging, debugInfo, nil),
		})
	}
	makeDeferredTypeMapper := func(sources []TypeParameter, targets []func() Type) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"kind":    TypeMapKindDeferred,
			"sources": sources,
			"targets": targets,
		})
	}
	makeCompositeTypeMapper := func(kind /* TODO(TS-TO-GO) TypeNode UnionType: TypeMapKind.Composite | TypeMapKind.Merged */ any, mapper1 TypeMapper, mapper2 TypeMapper) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"kind":    kind,
			"mapper1": mapper1,
			"mapper2": mapper2,
		})
	}
	createTypeEraser := func(sources []TypeParameter) TypeMapper {
		return createTypeMapper(sources /*targets*/, nil)
	}
	/**
	 * Maps forward-references to later types parameters to the empty object type.
	 * This is used during inference when instantiating type parameter defaults.
	 */
	createBackreferenceMapper := func(context InferenceContext, index number) TypeMapper {
		forwardInferences := context.inferences.slice(index)
		return createTypeMapper(map_(forwardInferences, func(i InferenceInfo) TypeParameter {
			return i.typeParameter
		}), map_(forwardInferences, func() IntrinsicType {
			return unknownType
		}))
	}
	combineTypeMappers := func(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case mapper1:
			return makeCompositeTypeMapper(TypeMapKindComposite, mapper1, mapper2)
		default:
			return mapper2
		}
	}
	mergeTypeMappers := func(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case mapper1:
			return makeCompositeTypeMapper(TypeMapKindMerged, mapper1, mapper2)
		default:
			return mapper2
		}
	}
	prependTypeMapping := func(source Type, target Type, mapper *TypeMapper) TypeMapper {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case !mapper:
			return makeUnaryTypeMapper(source, target)
		default:
			return makeCompositeTypeMapper(TypeMapKindMerged, makeUnaryTypeMapper(source, target), mapper)
		}
	}
	appendTypeMapping := func(mapper *TypeMapper, source Type, target Type) TypeMapper {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case !mapper:
			return makeUnaryTypeMapper(source, target)
		default:
			return makeCompositeTypeMapper(TypeMapKindMerged, mapper, makeUnaryTypeMapper(source, target))
		}
	}
	getRestrictiveTypeParameter := func(tp TypeParameter) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case !tp.constraint && !getConstraintDeclaration(tp) || tp.constraint == noConstraintType:
			return tp
		default:
			return tp.restrictiveInstantiation || ( /* TODO(TS-TO-GO) Node BinaryExpression: tp.restrictiveInstantiation = createTypeParameter(tp.symbol), (tp.restrictiveInstantiation as TypeParameter).constraint = noConstraintType, tp.restrictiveInstantiation */ TODO)
		}
	}
	cloneTypeParameter := func(typeParameter TypeParameter) TypeParameter {
		result := createTypeParameter(typeParameter.symbol)
		result.target = typeParameter
		return result
	}
	instantiateTypePredicate := func(predicate TypePredicate, mapper TypeMapper) TypePredicate {
		return createTypePredicate(predicate.kind, predicate.parameterName, predicate.parameterIndex, instantiateType(predicate.type_, mapper))
	}
	instantiateSignature := func(signature Signature, mapper TypeMapper, eraseTypeParameters bool) Signature {
		var freshTypeParameters *[]TypeParameter
		if signature.typeParameters && !eraseTypeParameters {
			// First create a fresh set of type parameters, then include a mapping from the old to the
			// new type parameters in the mapper function. Finally store this mapper in the new type
			// parameters such that we can use it when instantiating constraints.
			freshTypeParameters = map_(signature.typeParameters, cloneTypeParameter)
			mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper)
			for _, tp := range freshTypeParameters {
				tp.mapper = mapper
			}
		}
		// Don't compute resolvedReturnType and resolvedTypePredicate now,
		// because using `mapper` now could trigger inferences to become fixed. (See `createInferenceContext`.)
		// See GH#17600.
		result := createSignature(signature.declaration, freshTypeParameters, signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper), instantiateList(signature.parameters, mapper, instantiateSymbol) /*resolvedReturnType*/, nil /*resolvedTypePredicate*/, nil, signature.minArgumentCount, signature.flags&SignatureFlagsPropagatingFlags)
		result.target = signature
		result.mapper = mapper
		return result
	}
	instantiateSymbol := func(symbol Symbol, mapper TypeMapper) Symbol {
		links := getSymbolLinks(symbol)
		// If the type of the symbol is already resolved, and if that type could not possibly
		// be affected by instantiation, simply return the symbol itself.
		if links.type_ && !couldContainTypeVariables(links.type_) {
			if !(symbol.flags & SymbolFlagsSetAccessor) {
				return symbol
			}
			// If we're a setter, check writeType.
			if links.writeType && !couldContainTypeVariables(links.writeType) {
				return symbol
			}
		}
		if getCheckFlags(symbol) & CheckFlagsInstantiated {
			// If symbol being instantiated is itself a instantiation, fetch the original target and combine the
			// type mappers. This ensures that original type identities are properly preserved and that aliases
			// always reference a non-aliases.
			symbol = links.target
			mapper = combineTypeMappers(links.mapper, mapper)
		}
		// Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and
		// also transient so that we can just store data on it directly.
		result := createSymbol(symbol.flags, symbol.escapedName, CheckFlagsInstantiated|getCheckFlags(symbol)&(CheckFlagsReadonly|CheckFlagsLate|CheckFlagsOptionalParameter|CheckFlagsRestParameter))
		result.declarations = symbol.declarations
		result.parent = symbol.parent
		result.links.target = symbol
		result.links.mapper = mapper
		if symbol.valueDeclaration {
			result.valueDeclaration = symbol.valueDeclaration
		}
		if links.nameType {
			result.links.nameType = links.nameType
		}
		return result
	}
	getObjectTypeInstantiation := func(type_ /* TODO(TS-TO-GO) TypeNode UnionType: AnonymousType | DeferredTypeReference */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		var declaration /* TODO(TS-TO-GO) inferred type Declaration | NodeWithTypeArguments | ArrayTypeNode | TupleTypeNode */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.objectFlags & ObjectFlagsReference:
			declaration = (type_ /* as TypeReference */).node
		case type_.objectFlags & ObjectFlagsInstantiationExpressionType:
			declaration = (type_ /* as InstantiationExpressionType */).node
		default:
			declaration = type_.symbol.declarations[0]
		}
		links := getNodeLinks(declaration)
		var target AnonymousType
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.objectFlags & ObjectFlagsReference:
			target = links.resolvedType /* as DeferredTypeReference */
		case type_.objectFlags & ObjectFlagsInstantiated:
			target = type_.target
		default:
			target = type_
		}
		var typeParameters *[]TypeParameter
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.objectFlags & ObjectFlagsSingleSignatureType:
			typeParameters = (type_ /* as SingleSignatureType */).outerTypeParameters
		default:
			typeParameters = links.outerTypeParameters
		}
		if !typeParameters {
			// The first time an anonymous type is instantiated we compute and store a list of the type
			// parameters that are in scope (and therefore potentially referenced). For type literals that
			// aren't the right hand side of a generic type alias declaration we optimize by reducing the
			// set of type parameters to those that are possibly referenced in the literal.
			outerTypeParameters := getOuterTypeParameters(declaration /*includeThisTypes*/, true)
			if isJSConstructor(declaration) {
				templateTagParameters := getTypeParametersFromDeclaration(declaration /* as DeclarationWithTypeParameters */)
				outerTypeParameters = addRange(outerTypeParameters, templateTagParameters)
			}
			typeParameters = outerTypeParameters || emptyArray
			var allDeclarations [] /* TODO(TS-TO-GO) inferred type (Declaration | NodeWithTypeArguments | ArrayTypeNode | TupleTypeNode) */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case type_.objectFlags & (ObjectFlagsReference | ObjectFlagsInstantiationExpressionType):
				allDeclarations = [] /* TODO(TS-TO-GO) inferred type Declaration | NodeWithTypeArguments | ArrayTypeNode | TupleTypeNode */ any{declaration}
			default:
				allDeclarations = type_.symbol.declarations
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (target.objectFlags&(ObjectFlagsReference|ObjectFlagsInstantiationExpressionType) || target.symbol.flags&SymbolFlagsMethod || target.symbol.flags&SymbolFlagsTypeLiteral) && !target.aliasTypeArguments:
				typeParameters = filter(typeParameters, func(tp TypeParameter) bool {
					return some(allDeclarations, func(d /* TODO(TS-TO-GO) inferred type Declaration | NodeWithTypeArguments | ArrayTypeNode | TupleTypeNode */ any) bool {
						return isTypeParameterPossiblyReferenced(tp, d)
					})
				})
			default:
				typeParameters = typeParameters
			}
			links.outerTypeParameters = typeParameters
		}
		if typeParameters.length {
			// We are instantiating an anonymous type that has one or more type parameters in scope. Apply the
			// mapper to the type parameters to produce the effective list of type arguments, and compute the
			// instantiation cache key from the type IDs of the type arguments.
			combinedMapper := combineTypeMappers(type_.mapper, mapper)
			typeArguments := map_(typeParameters, func(t TypeParameter) Type {
				return getMappedType(t, combinedMapper)
			})
			newAliasSymbol := aliasSymbol || type_.aliasSymbol
			var newAliasTypeArguments *[]Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case aliasSymbol:
				newAliasTypeArguments = aliasTypeArguments
			default:
				newAliasTypeArguments = instantiateTypes(type_.aliasTypeArguments, mapper)
			}
			id := (__COND__(type_.objectFlags&ObjectFlagsSingleSignatureType, "S", "")) + getTypeListId(typeArguments) + getAliasId(newAliasSymbol, newAliasTypeArguments)
			if !target.instantiations {
				target.instantiations = NewMap[string, Type]()
				target.instantiations.set(getTypeListId(typeParameters)+getAliasId(target.aliasSymbol, target.aliasTypeArguments), target)
			}
			result := target.instantiations.get(id)
			if !result {
				if type_.objectFlags & ObjectFlagsSingleSignatureType {
					result = instantiateAnonymousType(type_, mapper)
					target.instantiations.set(id, result)
					return result
				}
				newMapper := createTypeMapper(typeParameters, typeArguments)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case target.objectFlags & ObjectFlagsReference:
					result = createDeferredTypeReference((type_ /* as DeferredTypeReference */).target, (type_ /* as DeferredTypeReference */).node, newMapper, newAliasSymbol, newAliasTypeArguments)
				case target.objectFlags & ObjectFlagsMapped:
					result = instantiateMappedType(target /* as MappedType */, newMapper, newAliasSymbol, newAliasTypeArguments)
				default:
					result = instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments)
				}
				target.instantiations.set(id, result)
				// Set cached result early in case we recursively invoke instantiation while eagerly computing type variable visibility below
				resultObjectFlags := getObjectFlags(result)
				if result.flags&TypeFlagsObjectFlagsType && !(resultObjectFlags & ObjectFlagsCouldContainTypeVariablesComputed) {
					resultCouldContainTypeVariables := some(typeArguments, couldContainTypeVariables)
					// one of the input type arguments might be or contain the result
					if !(getObjectFlags(result) & ObjectFlagsCouldContainTypeVariablesComputed) {
						// if `result` is one of the object types we tried to make (it may not be, due to how `instantiateMappedType` works), we can carry forward the type variable containment check from the input type arguments
						if resultObjectFlags & (ObjectFlagsMapped | ObjectFlagsAnonymous | ObjectFlagsReference) {
							(result /* as ObjectFlagsType */).objectFlags |= ObjectFlagsCouldContainTypeVariablesComputed | (__COND__(resultCouldContainTypeVariables, ObjectFlagsCouldContainTypeVariables, 0))
						} else {
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case !resultCouldContainTypeVariables:
								(result /* as ObjectFlagsType */).objectFlags |= ObjectFlagsCouldContainTypeVariablesComputed
							default:
								(result /* as ObjectFlagsType */).objectFlags |= 0
							}
						}
					}
				}
			}
			return result
		}
		return type_
	}
	maybeTypeParameterReference := func(node Node) bool {
		return !(node.parent.kind == SyntaxKindTypeReference && (node.parent /* as TypeReferenceNode */).typeArguments && node == (node.parent /* as TypeReferenceNode */).typeName || node.parent.kind == SyntaxKindImportType && (node.parent /* as ImportTypeNode */).typeArguments && node == (node.parent /* as ImportTypeNode */).qualifier)
	}
	isTypeParameterPossiblyReferenced := func(tp TypeParameter, node Node) bool {
		// If the type parameter doesn't have exactly one declaration, if there are intervening statement blocks
		// between the node and the type parameter declaration, if the node contains actual references to the
		// type parameter, or if the node contains type queries that we can't prove couldn't contain references to the type parameter,
		// we consider the type parameter possibly referenced.
		if tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length == 1 {
			container := tp.symbol.declarations[0].parent
			for n := node; n != container; n = n.parent {
				if !n || n.kind == SyntaxKindBlock || n.kind == SyntaxKindConditionalType && forEachChild((n /* as ConditionalTypeNode */).extendsType, containsReference) {
					return true
				}
			}
			return containsReference(node)
		}
		return true
		containsReference := func(node Node) bool {
			switch node.kind {
			case SyntaxKindThisType:
				return !!tp.isThisType
			case SyntaxKindIdentifier:
				return !tp.isThisType && isPartOfTypeNode(node) && maybeTypeParameterReference(node) && getTypeFromTypeNodeWorker(node /* as TypeNode */) == tp
				// use worker because we're looking for === equality
			case SyntaxKindTypeQuery:
				entityName := (node /* as TypeQueryNode */).exprName
				firstIdentifier := getFirstIdentifier(entityName)
				if !isThisIdentifier(firstIdentifier) {
					firstIdentifierSymbol := getResolvedSymbol(firstIdentifier)
					tpDeclaration := tp.symbol.declarations[0]
					// There is exactly one declaration, otherwise `containsReference` is not called
					var tpScope Node
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case tpDeclaration.kind == SyntaxKindTypeParameter:
						tpScope = tpDeclaration.parent
					case tp.isThisType:
						tpScope = tpDeclaration
					default:
						tpScope = nil
					}
					// Type parameter's declaration was unrecognized, e.g. comes from JSDoc annotation.
					if firstIdentifierSymbol.declarations && tpScope {
						return some(firstIdentifierSymbol.declarations, func(idDecl Declaration) bool {
							return isNodeDescendantOf(idDecl, tpScope)
						}) || some((node /* as TypeQueryNode */).typeArguments, containsReference)
					}
				}
				return true
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindMethodSignature:
				return !(node /* as FunctionLikeDeclaration */).type_ && !!(node /* as FunctionLikeDeclaration */).body || some((node /* as FunctionLikeDeclaration */).typeParameters, containsReference) || some((node /* as FunctionLikeDeclaration */).parameters, containsReference) || !!(node /* as FunctionLikeDeclaration */).type_ && containsReference((node /* as FunctionLikeDeclaration */).type_)
			}
			return !!forEachChild(node, containsReference)
		}
	}
	getHomomorphicTypeVariable := func(type_ MappedType) *TypeParameter {
		constraintType := getConstraintTypeFromMappedType(type_)
		if constraintType.flags & TypeFlagsIndex {
			typeVariable := getActualTypeVariable((constraintType /* as IndexType */).type_)
			if typeVariable.flags & TypeFlagsTypeParameter {
				return typeVariable /* as TypeParameter */
			}
		}
		return nil
	}
	instantiateMappedType := func(type_ MappedType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		// For a homomorphic mapped type { [P in keyof T]: X }, where T is some type variable, the mapping
		// operation depends on T as follows:
		// * If T is a primitive type no mapping is performed and the result is simply T.
		// * If T is a union type we distribute the mapped type over the union.
		// * If T is an array we map to an array where the element type has been transformed.
		// * If T is a tuple we map to a tuple where the element types have been transformed.
		// * If T is an intersection of array or tuple types we map to an intersection of transformed array or tuple types.
		// * Otherwise we map to an object type where the type of each property has been transformed.
		// For example, when T is instantiated to a union type A | B, we produce { [P in keyof A]: X } |
		// { [P in keyof B]: X }, and when when T is instantiated to a union type A | undefined, we produce
		// { [P in keyof A]: X } | undefined.
		typeVariable := getHomomorphicTypeVariable(type_)
		if typeVariable {
			mappedTypeVariable := instantiateType(typeVariable, mapper)
			if typeVariable != mappedTypeVariable {
				return mapTypeWithAlias(getReducedType(mappedTypeVariable), instantiateConstituent, aliasSymbol, aliasTypeArguments)
			}
		}
		// If the constraint type of the instantiation is the wildcard type, return the wildcard type.
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case instantiateType(getConstraintTypeFromMappedType(type_), mapper) == wildcardType:
			return wildcardType
		default:
			return instantiateAnonymousType(type_, mapper, aliasSymbol, aliasTypeArguments)
		}
		instantiateConstituent := func(t Type) Type {
			if t.flags&(TypeFlagsAnyOrUnknown|TypeFlagsInstantiableNonPrimitive|TypeFlagsObject|TypeFlagsIntersection) && t != wildcardType && !isErrorType(t) {
				if !type_.declaration.nameType {
					var constraint TODO
					if isArrayType(t) || t.flags&TypeFlagsAny && findResolutionCycleStartIndex(typeVariable, TypeSystemPropertyNameImmediateBaseConstraint) < 0 && ( /* TODO(TS-TO-GO) Node BinaryExpression: constraint = getConstraintOfTypeParameter(typeVariable!) */ TODO) && everyType(constraint, isArrayOrTupleType) {
						return instantiateMappedArrayType(t, type_, prependTypeMapping(typeVariable, t, mapper))
					}
					if isTupleType(t) {
						return instantiateMappedTupleType(t, type_, typeVariable, mapper)
					}
					if isArrayOrTupleOrIntersection(t) {
						return getIntersectionType(map_((t /* as IntersectionType */).types, instantiateConstituent))
					}
				}
				return instantiateAnonymousType(type_, prependTypeMapping(typeVariable, t, mapper))
			}
			return t
		}
	}
	getModifiedReadonlyState := func(state bool, modifiers MappedTypeModifiers) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case modifiers & MappedTypeModifiersIncludeReadonly:
			return true
		case modifiers & MappedTypeModifiersExcludeReadonly:
			return false
		default:
			return state
		}
	}
	instantiateMappedTupleType := func(tupleType TupleTypeReference, mappedType MappedType, typeVariable TypeVariable, mapper TypeMapper) Type {
		// We apply the mapped type's template type to each of the fixed part elements. For variadic elements, we
		// apply the mapped type itself to the variadic element type. For other elements in the variable part of the
		// tuple, we surround the element type with an array type and apply the mapped type to that. This ensures
		// that we get sequential property key types for the fixed part of the tuple, and property key type number
		// for the remaining elements. For example
		//
		//   type Keys<T> = { [K in keyof T]: K };
		//   type Foo<T extends any[]> = Keys<[string, string, ...T, string]>; // ["0", "1", ...Keys<T>, number]
		//
		elementFlags := tupleType.target.elementFlags
		fixedLength := tupleType.target.fixedLength
		var fixedMapper TypeMapper
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case fixedLength:
			fixedMapper = prependTypeMapping(typeVariable, tupleType, mapper)
		default:
			fixedMapper = mapper
		}
		newElementTypes := map_(getElementTypes(tupleType), func(type_ Type, i number) Type {
			flags := elementFlags[i]
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case i < fixedLength:
				return instantiateMappedTypeTemplate(mappedType, getStringLiteralType(""+i), !!(flags & ElementFlagsOptional), fixedMapper)
			case flags & ElementFlagsVariadic:
				return instantiateType(mappedType, prependTypeMapping(typeVariable, type_, mapper))
			default:
				return /* TODO(TS-TO-GO) Node BinaryExpression: getElementTypeOfArrayType(instantiateType(mappedType, prependTypeMapping(typeVariable, createArrayType(type), mapper))) ?? unknownType */ TODO
			}
		})
		modifiers := getMappedTypeModifiers(mappedType)
		var newElementFlags []ElementFlags
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case modifiers & MappedTypeModifiersIncludeOptional:
			newElementFlags = map_(elementFlags, func(f ElementFlags) ElementFlags {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case f & ElementFlagsRequired:
					return ElementFlagsOptional
				default:
					return f
				}
			})
		case modifiers & MappedTypeModifiersExcludeOptional:
			newElementFlags = map_(elementFlags, func(f ElementFlags) ElementFlags {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case f & ElementFlagsOptional:
					return ElementFlagsRequired
				default:
					return f
				}
			})
		default:
			newElementFlags = elementFlags
		}
		newReadonly := getModifiedReadonlyState(tupleType.target.readonly, getMappedTypeModifiers(mappedType))
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case contains(newElementTypes, errorType):
			return errorType
		default:
			return createTupleType(newElementTypes, newElementFlags, newReadonly, tupleType.target.labeledElementDeclarations)
		}
	}
	instantiateMappedArrayType := func(arrayType Type, mappedType MappedType, mapper TypeMapper) /* TODO(TS-TO-GO) inferred type IntrinsicType | ObjectType */ any {
		elementType := instantiateMappedTypeTemplate(mappedType, numberType /*isOptional*/, true, mapper)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isErrorType(elementType):
			return errorType
		default:
			return createArrayType(elementType, getModifiedReadonlyState(isReadonlyArrayType(arrayType), getMappedTypeModifiers(mappedType)))
		}
	}
	instantiateMappedTypeTemplate := func(type_ MappedType, key Type, isOptional bool, mapper TypeMapper) Type {
		templateMapper := appendTypeMapping(mapper, getTypeParameterFromMappedType(type_), key)
		propType := instantiateType(getTemplateTypeFromMappedType(type_.target /* as MappedType */ || type_), templateMapper)
		modifiers := getMappedTypeModifiers(type_)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case strictNullChecks && modifiers&MappedTypeModifiersIncludeOptional && !maybeTypeOfKind(propType, TypeFlagsUndefined|TypeFlagsVoid):
			return getOptionalType(propType /*isProperty*/, true)
		case strictNullChecks && modifiers&MappedTypeModifiersExcludeOptional && isOptional:
			return getTypeWithFacts(propType, TypeFactsNEUndefined)
		default:
			return propType
		}
	}
	instantiateAnonymousType := func(type_ AnonymousType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) AnonymousType {
		Debug.assert(type_.symbol, "anonymous type must have symbol to be instantiated")
		result := createObjectType(type_.objectFlags&~(ObjectFlagsCouldContainTypeVariablesComputed|ObjectFlagsCouldContainTypeVariables)|ObjectFlagsInstantiated, type_.symbol) /* as AnonymousType */
		if type_.objectFlags & ObjectFlagsMapped {
			(result /* as MappedType */).declaration = (type_ /* as MappedType */).declaration
			// C.f. instantiateSignature
			origTypeParameter := getTypeParameterFromMappedType(type_ /* as MappedType */)
			freshTypeParameter := cloneTypeParameter(origTypeParameter)
			(result /* as MappedType */).typeParameter = freshTypeParameter
			mapper = combineTypeMappers(makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper)
			freshTypeParameter.mapper = mapper
		}
		if type_.objectFlags & ObjectFlagsInstantiationExpressionType {
			(result /* as InstantiationExpressionType */).node = (type_ /* as InstantiationExpressionType */).node
		}
		if type_.objectFlags & ObjectFlagsSingleSignatureType {
			(result /* as SingleSignatureType */).outerTypeParameters = (type_ /* as SingleSignatureType */).outerTypeParameters
		}
		result.target = type_
		result.mapper = mapper
		result.aliasSymbol = aliasSymbol || type_.aliasSymbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case aliasSymbol:
			result.aliasTypeArguments = aliasTypeArguments
		default:
			result.aliasTypeArguments = instantiateTypes(type_.aliasTypeArguments, mapper)
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case result.aliasTypeArguments:
			result.objectFlags |= getPropagatingFlagsOfTypes(result.aliasTypeArguments)
		default:
			result.objectFlags |= 0
		}
		return result
	}
	getConditionalTypeInstantiation := func(type_ ConditionalType, mapper TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		root := type_.root
		if root.outerTypeParameters {
			// We are instantiating a conditional type that has one or more type parameters in scope. Apply the
			// mapper to the type parameters to produce the effective list of type arguments, and compute the
			// instantiation cache key from the type IDs of the type arguments.
			typeArguments := map_(root.outerTypeParameters, func(t TypeParameter) Type {
				return getMappedType(t, mapper)
			})
			id := (__COND__(forConstraint, "C", "")) + getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments)
			result := root.instantiations.get(id)
			if !result {
				newMapper := createTypeMapper(root.outerTypeParameters, typeArguments)
				checkType := root.checkType
				var distributionType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case root.isDistributive:
					distributionType = getReducedType(getMappedType(checkType, newMapper))
				default:
					distributionType = nil
				}
				// Distributive conditional types are distributed over union types. For example, when the
				// distributive conditional type T extends U ? X : Y is instantiated with A | B for T, the
				// result is (A extends U ? X : Y) | (B extends U ? X : Y).
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case distributionType && checkType != distributionType && distributionType.flags&(TypeFlagsUnion|TypeFlagsNever):
					result = mapTypeWithAlias(distributionType, func(t Type) Type {
						return getConditionalType(root, prependTypeMapping(checkType, t, newMapper), forConstraint)
					}, aliasSymbol, aliasTypeArguments)
				default:
					result = getConditionalType(root, newMapper, forConstraint, aliasSymbol, aliasTypeArguments)
				}
				root.instantiations.set(id, result)
			}
			return result
		}
		return type_
	}
	/* TODO(TS-TO-GO): function instantiateType(type: Type, mapper: TypeMapper | undefined): Type; */
	/* TODO(TS-TO-GO): function instantiateType(type: Type | undefined, mapper: TypeMapper | undefined): Type | undefined; */
	instantiateType := func(type_ Type, mapper *TypeMapper) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_ && mapper:
			return instantiateTypeWithAlias(type_, mapper /*aliasSymbol*/, nil /*aliasTypeArguments*/, nil)
		default:
			return type_
		}
	}
	instantiateTypeWithAlias := func(type_ Type, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments *[]Type) Type {
		if !couldContainTypeVariables(type_) {
			return type_
		}
		if instantiationDepth == 100 || instantiationCount >= 5000000 {
			// We have reached 100 recursive type instantiations, or 5M type instantiations caused by the same statement
			// or expression. There is a very high likelyhood we're dealing with a combination of infinite generic types
			// that perpetually generate new type identities, so we stop the recursion here by yielding the error type.
			tracing. /* TODO(TS-TO-GO): was ? */ instant(tracing.Phase.CheckTypes, "instantiateType_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"typeId":             type_.id,
				"instantiationDepth": instantiationDepth,
				"instantiationCount": instantiationCount,
			})
			error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite)
			return errorType
		}
		totalInstantiationCount++
		instantiationCount++
		instantiationDepth++
		result := instantiateTypeWorker(type_, mapper, aliasSymbol, aliasTypeArguments)
		instantiationDepth--
		return result
	}
	instantiateTypeWorker := func(type_ Type, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments *[]Type) Type {
		flags := type_.flags
		if flags & TypeFlagsTypeParameter {
			return getMappedType(type_, mapper)
		}
		if flags & TypeFlagsObject {
			objectFlags := (type_ /* as ObjectType */).objectFlags
			if objectFlags & (ObjectFlagsReference | ObjectFlagsAnonymous | ObjectFlagsMapped) {
				if objectFlags&ObjectFlagsReference && !(type_ /* as TypeReference */).node {
					resolvedTypeArguments := (type_ /* as TypeReference */).resolvedTypeArguments
					newTypeArguments := instantiateTypes(resolvedTypeArguments, mapper)
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case newTypeArguments != resolvedTypeArguments:
						return createNormalizedTypeReference((type_ /* as TypeReference */).target, newTypeArguments)
					default:
						return type_
					}
				}
				if objectFlags & ObjectFlagsReverseMapped {
					return instantiateReverseMappedType(type_ /* as ReverseMappedType */, mapper)
				}
				return getObjectTypeInstantiation(type_ /* as TypeReference | AnonymousType | MappedType */, mapper, aliasSymbol, aliasTypeArguments)
			}
			return type_
		}
		if flags & TypeFlagsUnionOrIntersection {
			var origin Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case type_.flags & TypeFlagsUnion:
				origin = (type_ /* as UnionType */).origin
			default:
				origin = nil
			}
			var types []Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case origin && origin.flags&TypeFlagsUnionOrIntersection:
				types = (origin /* as UnionOrIntersectionType */).types
			default:
				types = (type_ /* as UnionOrIntersectionType */).types
			}
			newTypes := instantiateTypes(types, mapper)
			if newTypes == types && aliasSymbol == type_.aliasSymbol {
				return type_
			}
			newAliasSymbol := aliasSymbol || type_.aliasSymbol
			var newAliasTypeArguments *[]Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case aliasSymbol:
				newAliasTypeArguments = aliasTypeArguments
			default:
				newAliasTypeArguments = instantiateTypes(type_.aliasTypeArguments, mapper)
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case flags&TypeFlagsIntersection || origin && origin.flags&TypeFlagsIntersection:
				return getIntersectionType(newTypes, IntersectionFlagsNone, newAliasSymbol, newAliasTypeArguments)
			default:
				return getUnionType(newTypes, UnionReductionLiteral, newAliasSymbol, newAliasTypeArguments)
			}
		}
		if flags & TypeFlagsIndex {
			return getIndexType(instantiateType((type_ /* as IndexType */).type_, mapper))
		}
		if flags & TypeFlagsTemplateLiteral {
			return getTemplateLiteralType((type_ /* as TemplateLiteralType */).texts, instantiateTypes((type_ /* as TemplateLiteralType */).types, mapper))
		}
		if flags & TypeFlagsStringMapping {
			return getStringMappingType((type_ /* as StringMappingType */).symbol, instantiateType((type_ /* as StringMappingType */).type_, mapper))
		}
		if flags & TypeFlagsIndexedAccess {
			newAliasSymbol := aliasSymbol || type_.aliasSymbol
			var newAliasTypeArguments *[]Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case aliasSymbol:
				newAliasTypeArguments = aliasTypeArguments
			default:
				newAliasTypeArguments = instantiateTypes(type_.aliasTypeArguments, mapper)
			}
			return getIndexedAccessType(instantiateType((type_ /* as IndexedAccessType */).objectType, mapper), instantiateType((type_ /* as IndexedAccessType */).indexType, mapper), (type_ /* as IndexedAccessType */).accessFlags /*accessNode*/, nil, newAliasSymbol, newAliasTypeArguments)
		}
		if flags & TypeFlagsConditional {
			return getConditionalTypeInstantiation(type_ /* as ConditionalType */, combineTypeMappers((type_ /* as ConditionalType */).mapper, mapper) /*forConstraint*/, false, aliasSymbol, aliasTypeArguments)
		}
		if flags & TypeFlagsSubstitution {
			newBaseType := instantiateType((type_ /* as SubstitutionType */).baseType, mapper)
			if isNoInferType(type_) {
				return getNoInferType(newBaseType)
			}
			newConstraint := instantiateType((type_ /* as SubstitutionType */).constraint, mapper)
			// A substitution type originates in the true branch of a conditional type and can be resolved
			// to just the base type in the same cases as the conditional type resolves to its true branch
			// (because the base type is then known to satisfy the constraint).
			if newBaseType.flags&TypeFlagsTypeVariable && isGenericType(newConstraint) {
				return getSubstitutionType(newBaseType, newConstraint)
			}
			if newConstraint.flags&TypeFlagsAnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(newBaseType), getRestrictiveInstantiation(newConstraint)) {
				return newBaseType
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case newBaseType.flags & TypeFlagsTypeVariable:
				return getSubstitutionType(newBaseType, newConstraint)
			default:
				return getIntersectionType([]Type{newConstraint, newBaseType})
			}
		}
		return type_
	}
	instantiateReverseMappedType := func(type_ ReverseMappedType, mapper TypeMapper) Type {
		innerMappedType := instantiateType(type_.mappedType, mapper)
		if !(getObjectFlags(innerMappedType) & ObjectFlagsMapped) {
			return type_
		}
		innerIndexType := instantiateType(type_.constraintType, mapper)
		if !(innerIndexType.flags & TypeFlagsIndex) {
			return type_
		}
		instantiated := inferTypeForHomomorphicMappedType(instantiateType(type_.source, mapper), innerMappedType /* as MappedType */, innerIndexType /* as IndexType */)
		if instantiated {
			return instantiated
		}
		return type_
		// Nested invocation of `inferTypeForHomomorphicMappedType` or the `source` instantiated into something unmappable
	}
	getPermissiveInstantiation := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & (TypeFlagsPrimitive | TypeFlagsAnyOrUnknown | TypeFlagsNever):
			return type_
		default:
			return type_.permissiveInstantiation || ( /* TODO(TS-TO-GO) Node BinaryExpression: type.permissiveInstantiation = instantiateType(type, permissiveMapper) */ TODO)
		}
	}
	getRestrictiveInstantiation := func(type_ Type) Type {
		if type_.flags & (TypeFlagsPrimitive | TypeFlagsAnyOrUnknown | TypeFlagsNever) {
			return type_
		}
		if type_.restrictiveInstantiation {
			return type_.restrictiveInstantiation
		}
		type_.restrictiveInstantiation = instantiateType(type_, restrictiveMapper)
		// We set the following so we don't attempt to set the restrictive instance of a restrictive instance
		// which is redundant - we'll produce new type identities, but all type params have already been mapped.
		// This also gives us a way to detect restrictive instances upon comparisons and _disable_ the "distributeive constraint"
		// assignability check for them, which is distinctly unsafe, as once you have a restrctive instance, all the type parameters
		// are constrained to `unknown` and produce tons of false positives/negatives!
		type_.restrictiveInstantiation.restrictiveInstantiation = type_.restrictiveInstantiation
		return type_.restrictiveInstantiation
	}
	instantiateIndexInfo := func(info IndexInfo, mapper TypeMapper) IndexInfo {
		return createIndexInfo(info.keyType, instantiateType(info.type_, mapper), info.isReadonly, info.declaration)
	}
	// Returns true if the given expression contains (at any level of nesting) a function or arrow expression
	// that is subject to contextual typing.
	isContextSensitive := func(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike | JsxChild */ any) bool {
		Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
		switch node.kind {
		case SyntaxKindFunctionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionDeclaration:
			return isContextSensitiveFunctionLikeDeclaration(node /* as FunctionExpression | ArrowFunction | MethodDeclaration */)
		case SyntaxKindObjectLiteralExpression:
			return some((node /* as ObjectLiteralExpression */).properties, isContextSensitive)
		case SyntaxKindArrayLiteralExpression:
			return some((node /* as ArrayLiteralExpression */).elements, isContextSensitive)
		case SyntaxKindConditionalExpression:
			return isContextSensitive((node /* as ConditionalExpression */).whenTrue) || isContextSensitive((node /* as ConditionalExpression */).whenFalse)
		case SyntaxKindBinaryExpression:
			return ((node /* as BinaryExpression */).operatorToken.kind == SyntaxKindBarBarToken || (node /* as BinaryExpression */).operatorToken.kind == SyntaxKindQuestionQuestionToken) && (isContextSensitive((node /* as BinaryExpression */).left) || isContextSensitive((node /* as BinaryExpression */).right))
		case SyntaxKindPropertyAssignment:
			return isContextSensitive((node /* as PropertyAssignment */).initializer)
		case SyntaxKindParenthesizedExpression:
			return isContextSensitive((node /* as ParenthesizedExpression */).expression)
		case SyntaxKindJsxAttributes:
			return some((node /* as JsxAttributes */).properties, isContextSensitive) || isJsxOpeningElement(node.parent) && some(node.parent.parent.children, isContextSensitive)
		case SyntaxKindJsxAttribute:
			// If there is no initializer, JSX attribute has a boolean value of true which is not context sensitive.
			TODO_IDENTIFIER := node /* as JsxAttribute */
			return !!initializer && isContextSensitive(initializer)
			fallthrough
		case SyntaxKindJsxExpression:
			// It is possible to that node.expression is undefined (e.g <div x={} />)
			TODO_IDENTIFIER := node /* as JsxExpression */
			return !!expression && isContextSensitive(expression)
		}
		return false
	}
	isContextSensitiveFunctionLikeDeclaration := func(node FunctionLikeDeclaration) bool {
		return hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node)
	}
	hasContextSensitiveReturnExpression := func(node FunctionLikeDeclaration) bool {
		if node.typeParameters || getEffectiveReturnTypeNode(node) || !node.body {
			return false
		}
		if node.body.kind != SyntaxKindBlock {
			return isContextSensitive(node.body)
		}
		return !!forEachReturnStatement(node.body /* as Block */, func(statement ReturnStatement) bool {
			return !!statement.expression && isContextSensitive(statement.expression)
		})
	}
	isContextSensitiveFunctionOrObjectLiteralMethod := func(func_ Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: func is FunctionExpression | ArrowFunction | MethodDeclaration */ any {
		return (isFunctionExpressionOrArrowFunction(func_) || isObjectLiteralMethod(func_)) && isContextSensitiveFunctionLikeDeclaration(func_)
	}
	getTypeWithoutSignatures := func(type_ Type) Type {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_ /* as ObjectType */)
			if resolved.constructSignatures.length || resolved.callSignatures.length {
				result := createObjectType(ObjectFlagsAnonymous, type_.symbol)
				result.members = resolved.members
				result.properties = resolved.properties
				result.callSignatures = emptyArray
				result.constructSignatures = emptyArray
				result.indexInfos = emptyArray
				return result
			}
		} else if type_.flags & TypeFlagsIntersection {
			return getIntersectionType(map_((type_ /* as IntersectionType */).types, getTypeWithoutSignatures))
		}
		return type_
	}
	// TYPE CHECKING
	isTypeIdenticalTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, identityRelation)
	}
	compareTypesIdentical := func(source Type, target Type) Ternary {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isTypeRelatedTo(source, target, identityRelation):
			return TernaryTrue
		default:
			return TernaryFalse
		}
	}
	compareTypesAssignable := func(source Type, target Type) Ternary {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isTypeRelatedTo(source, target, assignableRelation):
			return TernaryTrue
		default:
			return TernaryFalse
		}
	}
	compareTypesSubtypeOf := func(source Type, target Type) Ternary {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isTypeRelatedTo(source, target, subtypeRelation):
			return TernaryTrue
		default:
			return TernaryFalse
		}
	}
	isTypeSubtypeOf := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, subtypeRelation)
	}
	isTypeStrictSubtypeOf := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, strictSubtypeRelation)
	}
	isTypeAssignableTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, assignableRelation)
	}
	// An object type S is considered to be derived from an object type T if
	// S is a union type and every constituent of S is derived from T,
	// T is a union type and S is derived from at least one constituent of T, or
	// S is an intersection type and some constituent of S is derived from T, or
	// S is a type variable with a base constraint that is derived from T, or
	// T is {} and S is an object-like type (ensuring {} is less derived than Object), or
	// T is one of the global types Object and Function and S is a subtype of T, or
	// T occurs directly or indirectly in an 'extends' clause of S.
	// Note that this check ignores type parameters and only considers the
	// inheritance hierarchy.
	isTypeDerivedFrom := func(source Type, target Type) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case source.flags & TypeFlagsUnion:
			return every((source /* as UnionType */).types, func(t Type) bool {
				return isTypeDerivedFrom(t, target)
			})
		case target.flags & TypeFlagsUnion:
			return some((target /* as UnionType */).types, func(t Type) bool {
				return isTypeDerivedFrom(source, t)
			})
		case source.flags & TypeFlagsIntersection:
			return some((source /* as IntersectionType */).types, func(t Type) bool {
				return isTypeDerivedFrom(t, target)
			})
		case source.flags & TypeFlagsInstantiableNonPrimitive:
			return isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target)
		case isEmptyAnonymousObjectType(target):
			return !!(source.flags & (TypeFlagsObject | TypeFlagsNonPrimitive))
		case target == globalObjectType:
			return !!(source.flags & (TypeFlagsObject | TypeFlagsNonPrimitive)) && !isEmptyAnonymousObjectType(source)
		case target == globalFunctionType:
			return !!(source.flags & TypeFlagsObject) && isFunctionObjectType(source /* as ObjectType */)
		default:
			return hasBaseType(source, getTargetType(target)) || (isArrayType(target) && !isReadonlyArrayType(target) && isTypeDerivedFrom(source, globalReadonlyArrayType))
		}
	}
	/**
	 * This is *not* a bi-directional relationship.
	 * If one needs to check both directions for comparability, use a second call to this function or 'checkTypeComparableTo'.
	 *
	 * A type S is comparable to a type T if some (but not necessarily all) of the possible values of S are also possible values of T.
	 * It is used to check following cases:
	 *   - the types of the left and right sides of equality/inequality operators (`===`, `!==`, `==`, `!=`).
	 *   - the types of `case` clause expressions and their respective `switch` expressions.
	 *   - the type of an expression in a type assertion with the type being asserted.
	 */
	isTypeComparableTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, comparableRelation)
	}
	areTypesComparable := func(type1 Type, type2 Type) bool {
		return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1)
	}
	checkTypeAssignableTo := func(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputObject /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; } */ any) bool {
		return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject)
	}
	/**
	 * Like `checkTypeAssignableTo`, but if it would issue an error, instead performs structural comparisons of the types using the given expression node to
	 * attempt to issue more specific errors on, for example, specific object literal properties or tuple members.
	 */
	checkTypeAssignableToAndOptionallyElaborate := func(source Type, target Type, errorNode Node, expr Expression, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
		return checkTypeRelatedToAndOptionallyElaborate(source, target, assignableRelation, errorNode, expr, headMessage, containingMessageChain /*errorOutputContainer*/, nil)
	}
	checkTypeRelatedToAndOptionallyElaborate := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, expr Expression, headMessage *DiagnosticMessage, containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if isTypeRelatedTo(source, target, relation) {
			return true
		}
		if !errorNode || !elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
			return checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer)
		}
		return false
	}
	isOrHasGenericConditional := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsConditional || (type_.flags&TypeFlagsIntersection && some((type_ /* as IntersectionType */).types, isOrHasGenericConditional)))
	}
	elaborateError := func(node Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if !node || isOrHasGenericConditional(target) {
			return false
		}
		if !checkTypeRelatedTo(source, target, relation /*errorNode*/, nil) && elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
			return true
		}
		switch node.kind {
		case SyntaxKindAsExpression:
			if !isConstAssertion(node) {
				break
			}
			fallthrough
		case SyntaxKindJsxExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindParenthesizedExpression:
			return elaborateError((node /* as AsExpression | ParenthesizedExpression | JsxExpression */).expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)
		case SyntaxKindBinaryExpression:
			switch (node /* as BinaryExpression */).operatorToken.kind {
			case SyntaxKindEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindCommaToken:
				return elaborateError((node /* as BinaryExpression */).right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)
			}
			break
		case SyntaxKindObjectLiteralExpression:
			return elaborateObjectLiteral(node /* as ObjectLiteralExpression */, source, target, relation, containingMessageChain, errorOutputContainer)
		case SyntaxKindArrayLiteralExpression:
			return elaborateArrayLiteral(node /* as ArrayLiteralExpression */, source, target, relation, containingMessageChain, errorOutputContainer)
		case SyntaxKindJsxAttributes:
			return elaborateJsxComponents(node /* as JsxAttributes */, source, target, relation, containingMessageChain, errorOutputContainer)
		case SyntaxKindArrowFunction:
			return elaborateArrowFunction(node /* as ArrowFunction */, source, target, relation, containingMessageChain, errorOutputContainer)
		}
		return false
	}
	elaborateDidYouMeanToCallOrConstruct := func(node Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		callSignatures := getSignaturesOfType(source, SignatureKindCall)
		constructSignatures := getSignaturesOfType(source, SignatureKindConstruct)
		for _, signatures := range [][]Signature{constructSignatures, callSignatures} {
			if some(signatures, func(s Signature) bool {
				returnType := getReturnTypeOfSignature(s)
				return !(returnType.flags & (TypeFlagsAny | TypeFlagsNever)) && checkTypeRelatedTo(returnType, target, relation /*errorNode*/, nil)
			}) {
				var resultObj /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; } */ any = errorOutputContainer || map[any]any{ /* TODO(TS-TO-GO): was object literal */
				}
				checkTypeAssignableTo(source, target, node, headMessage, containingMessageChain, resultObj)
				diagnostic := resultObj.errors[resultObj.errors.length-1]
				addRelatedInfo(diagnostic, createDiagnosticForNode(node, __COND__(signatures == constructSignatures, Diagnostics.Did_you_mean_to_use_new_with_this_expression, Diagnostics.Did_you_mean_to_call_this_expression)))
				return true
			}
		}
		return false
	}
	elaborateArrowFunction := func(node ArrowFunction, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		// Don't elaborate blocks
		if isBlock(node.body) {
			return false
		}
		// Or functions with annotated parameter types
		if some(node.parameters, hasType) {
			return false
		}
		sourceSig := getSingleCallSignature(source)
		if !sourceSig {
			return false
		}
		targetSignatures := getSignaturesOfType(target, SignatureKindCall)
		if !length(targetSignatures) {
			return false
		}
		returnExpression := node.body
		sourceReturn := getReturnTypeOfSignature(sourceSig)
		targetReturn := getUnionType(map_(targetSignatures, getReturnTypeOfSignature))
		if !checkTypeRelatedTo(sourceReturn, targetReturn, relation /*errorNode*/, nil) {
			elaborated := returnExpression && elaborateError(returnExpression, sourceReturn, targetReturn, relation /*headMessage*/, nil, containingMessageChain, errorOutputContainer)
			if elaborated {
				return elaborated
			}
			var resultObj /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; } */ any = errorOutputContainer || map[any]any{ /* TODO(TS-TO-GO): was object literal */
			}
			checkTypeRelatedTo(sourceReturn, targetReturn, relation, returnExpression /*headMessage*/, nil, containingMessageChain, resultObj)
			if resultObj.errors {
				if target.symbol && length(target.symbol.declarations) {
					addRelatedInfo(resultObj.errors[resultObj.errors.length-1], createDiagnosticForNode(target.symbol.declarations[0], Diagnostics.The_expected_type_comes_from_the_return_type_of_this_signature))
				}
				if (getFunctionFlags(node)&FunctionFlagsAsync) == 0 && !getTypeOfPropertyOfType(sourceReturn, "then" /* as __String */) && checkTypeRelatedTo(createPromiseType(sourceReturn), targetReturn, relation /*errorNode*/, nil) {
					addRelatedInfo(resultObj.errors[resultObj.errors.length-1], createDiagnosticForNode(node, Diagnostics.Did_you_mean_to_mark_this_function_as_async))
				}
				return true
			}
		}
		return false
	}
	getBestMatchIndexedAccessTypeOrUndefined := func(source Type, target Type, nameType Type) Type {
		idx := getIndexedAccessTypeOrUndefined(target, nameType)
		if idx {
			return idx
		}
		if target.flags & TypeFlagsUnion {
			best := getBestMatchingType(source, target /* as UnionType */)
			if best {
				return getIndexedAccessTypeOrUndefined(best, nameType)
			}
		}
	}
	checkExpressionForMutableLocationWithContextualType := func(next Expression, sourcePropType Type) Type {
		pushContextualType(next, sourcePropType /*isCache*/, false)
		result := checkExpressionForMutableLocation(next, CheckModeContextual)
		popContextualType()
		return result
	}
	type ElaborationIterator IterableIterator[ /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errorNode: Node; innerExpression: Expression | undefined; nameType: Type; errorMessage?: DiagnosticMessage | undefined; } */ any]
	/**
	 * For every element returned from the iterator, checks that element to issue an error on a property of that element's type
	 * If that element would issue an error, we first attempt to dive into that element's inner expression and issue a more specific error by recuring into `elaborateError`
	 * Otherwise, we issue an error on _every_ element which fail the assignability check
	 */
	elaborateElementwise := func(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		// Assignability failure - check each prop individually, and if that fails, fall back on the bad error span
		reportedError := false
		for _, value := range iterator {
			TODO_IDENTIFIER := value
			targetPropType := getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType)
			if !targetPropType || targetPropType.flags&TypeFlagsIndexedAccess {
				continue
				// Don't elaborate on indexes on generic variables
			}
			// Don't elaborate on indexes on generic variables
			sourcePropType := getIndexedAccessTypeOrUndefined(source, nameType)
			if !sourcePropType {
				continue
			}
			propName := getPropertyNameFromIndex(nameType /*accessNode*/, nil)
			if !checkTypeRelatedTo(sourcePropType, targetPropType, relation /*errorNode*/, nil) {
				elaborated := next && elaborateError(next, sourcePropType, targetPropType, relation /*headMessage*/, nil, containingMessageChain, errorOutputContainer)
				reportedError = true
				if !elaborated {
					// Issue error on the prop itself, since the prop couldn't elaborate the error
					var resultObj /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; } */ any = errorOutputContainer || map[any]any{ /* TODO(TS-TO-GO): was object literal */
					}
					// Use the expression type, if available
					var specificSource Type
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case next:
						specificSource = checkExpressionForMutableLocationWithContextualType(next, sourcePropType)
					default:
						specificSource = sourcePropType
					}
					if exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType) {
						diag := createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType))
						diagnostics.add(diag)
						resultObj.errors = []DiagnosticWithLocation{diag}
					} else {
						targetIsOptional := !!(propName && (getPropertyOfType(target, propName) || unknownSymbol).flags&SymbolFlagsOptional)
						sourceIsOptional := !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags&SymbolFlagsOptional)
						targetPropType = removeMissingType(targetPropType, targetIsOptional)
						sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional)
						result := checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						if result && specificSource != sourcePropType {
							// If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType
							checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						}
					}
					if resultObj.errors {
						reportedDiag := resultObj.errors[resultObj.errors.length-1]
						var propertyName *__String
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isTypeUsableAsPropertyName(nameType):
							propertyName = getPropertyNameFromType(nameType)
						default:
							propertyName = nil
						}
						var targetProp Symbol
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case propertyName != nil:
							targetProp = getPropertyOfType(target, propertyName)
						default:
							targetProp = nil
						}
						issuedElaboration := false
						if !targetProp {
							indexInfo := getApplicableIndexInfo(target, nameType)
							if indexInfo && indexInfo.declaration && !getSourceFileOfNode(indexInfo.declaration).hasNoDefaultLib {
								issuedElaboration = true
								addRelatedInfo(reportedDiag, createDiagnosticForNode(indexInfo.declaration, Diagnostics.The_expected_type_comes_from_this_index_signature))
							}
						}
						if !issuedElaboration && (targetProp && length(targetProp.declarations) || target.symbol && length(target.symbol.declarations)) {
							var targetNode Declaration
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case targetProp && length(targetProp.declarations):
								targetNode = targetProp.declarations[0]
							default:
								targetNode = target.symbol.declarations[0]
							}
							if !getSourceFileOfNode(targetNode).hasNoDefaultLib {
								addRelatedInfo(reportedDiag, createDiagnosticForNode(targetNode, Diagnostics.The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1, __COND__(propertyName && !(nameType.flags&TypeFlagsUniqueESSymbol), unescapeLeadingUnderscores(propertyName), typeToString(nameType)), typeToString(target)))
							}
						}
					}
				}
			}
		}
		return reportedError
	}
	/**
	 * Assumes `target` type is assignable to the `Iterable` type, if `Iterable` is defined,
	 * or that it's an array or tuple-like type, if `Iterable` is not defined.
	 */
	elaborateIterableOrArrayLikeTargetElementwise := func(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		tupleOrArrayLikeTargetParts := filterType(target, isArrayOrTupleLikeType)
		nonTupleOrArrayLikeTargetParts := filterType(target, func(t Type) bool {
			return !isArrayOrTupleLikeType(t)
		})
		// If `nonTupleOrArrayLikeTargetParts` is not `never`, then that should mean `Iterable` is defined.
		var iterationType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case nonTupleOrArrayLikeTargetParts != neverType:
			iterationType = getIterationTypeOfIterable(IterationUseForOf, IterationTypeKindYield, nonTupleOrArrayLikeTargetParts /*errorNode*/, nil)
		default:
			iterationType = nil
		}
		reportedError := false
		for status := iterator.next(); !status.done; status = iterator.next() {
			TODO_IDENTIFIER := status.value
			targetPropType := iterationType
			var targetIndexedPropType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case tupleOrArrayLikeTargetParts != neverType:
				targetIndexedPropType = getBestMatchIndexedAccessTypeOrUndefined(source, tupleOrArrayLikeTargetParts, nameType)
			default:
				targetIndexedPropType = nil
			}
			if targetIndexedPropType && !(targetIndexedPropType.flags & TypeFlagsIndexedAccess) {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case iterationType:
					targetPropType = getUnionType([]Type{iterationType, targetIndexedPropType})
				default:
					targetPropType = targetIndexedPropType
				}
			}
			if !targetPropType {
				continue
			}
			sourcePropType := getIndexedAccessTypeOrUndefined(source, nameType)
			if !sourcePropType {
				continue
			}
			propName := getPropertyNameFromIndex(nameType /*accessNode*/, nil)
			if !checkTypeRelatedTo(sourcePropType, targetPropType, relation /*errorNode*/, nil) {
				elaborated := next && elaborateError(next, sourcePropType, targetPropType, relation /*headMessage*/, nil, containingMessageChain, errorOutputContainer)
				reportedError = true
				if !elaborated {
					// Issue error on the prop itself, since the prop couldn't elaborate the error
					var resultObj /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; } */ any = errorOutputContainer || map[any]any{ /* TODO(TS-TO-GO): was object literal */
					}
					// Use the expression type, if available
					var specificSource Type
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case next:
						specificSource = checkExpressionForMutableLocationWithContextualType(next, sourcePropType)
					default:
						specificSource = sourcePropType
					}
					if exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType) {
						diag := createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType))
						diagnostics.add(diag)
						resultObj.errors = []DiagnosticWithLocation{diag}
					} else {
						targetIsOptional := !!(propName && (getPropertyOfType(tupleOrArrayLikeTargetParts, propName) || unknownSymbol).flags&SymbolFlagsOptional)
						sourceIsOptional := !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags&SymbolFlagsOptional)
						targetPropType = removeMissingType(targetPropType, targetIsOptional)
						sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional)
						result := checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						if result && specificSource != sourcePropType {
							// If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType
							checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						}
					}
				}
			}
		}
		return reportedError
	}
	// TODO(TS-TO-GO): was generator
	generateJsxAttributes := func(node JsxAttributes) ElaborationIterator {
		if !length(node.properties) {
			return
		}
		for _, prop := range node.properties {
			if isJsxSpreadAttribute(prop) || isHyphenatedJsxName(getTextOfJsxAttributeName(prop.name)) {
				continue
			}
			yield(map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"errorNode":       prop.name,
				"innerExpression": prop.initializer,
				"nameType":        getStringLiteralType(getTextOfJsxAttributeName(prop.name)),
			})
		}
	}
	// TODO(TS-TO-GO): was generator
	generateJsxChildren := func(node JsxElement, getInvalidTextDiagnostic func() DiagnosticMessage) ElaborationIterator {
		if !length(node.children) {
			return
		}
		memberOffset := 0
		for i := 0; i < node.children.length; i++ {
			child := node.children[i]
			nameType := getNumberLiteralType(i - memberOffset)
			elem := getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic)
			if elem {
				yield(elem)
			} else {
				memberOffset++
			}
		}
	}
	getElaborationElementForJsxChild := func(child JsxChild, nameType LiteralType, getInvalidTextDiagnostic func() DiagnosticMessage) * /* TODO(TS-TO-GO) inferred type { errorNode: JsxExpression; innerExpression: Expression | undefined; nameType: LiteralType; errorMessage?: undefined; } | { errorNode: JsxText; innerExpression: undefined; nameType: LiteralType; errorMessage: DiagnosticMessage; } | { errorNode: JsxElement | JsxSelfClosingElement | JsxFragment; innerExpression: JsxElement | JsxSelfClosingElement | JsxFragment; nameType: LiteralType; errorMessage?: undefined; } */ any {
		switch child.kind {
		case SyntaxKindJsxExpression:
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"errorNode":       child,
				"innerExpression": child.expression,
				"nameType":        nameType,
			}
		case SyntaxKindJsxText:
			if child.containsOnlyTriviaWhiteSpaces {
				break
				// Whitespace only jsx text isn't real jsx text
			}
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"errorNode":       child,
				"innerExpression": nil,
				"nameType":        nameType,
				"errorMessage":    getInvalidTextDiagnostic(),
			}
		case SyntaxKindJsxElement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJsxSelfClosingElement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJsxFragment:
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"errorNode":       child,
				"innerExpression": child,
				"nameType":        nameType,
			}
		default:
			return Debug.assertNever(child, "Found invalid jsx child")
		}
	}
	elaborateJsxComponents := func(node JsxAttributes, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		result := elaborateElementwise(generateJsxAttributes(node), source, target, relation, containingMessageChain, errorOutputContainer)
		var invalidTextDiagnostic *DiagnosticMessage
		if isJsxOpeningElement(node.parent) && isJsxElement(node.parent.parent) {
			containingElement := node.parent.parent
			childPropName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
			var childrenPropName string
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case childPropName == nil:
				childrenPropName = "children"
			default:
				childrenPropName = unescapeLeadingUnderscores(childPropName)
			}
			childrenNameType := getStringLiteralType(childrenPropName)
			childrenTargetType := getIndexedAccessType(target, childrenNameType)
			validChildren := getSemanticJsxChildren(containingElement.children)
			if !length(validChildren) {
				return result
			}
			moreThanOneRealChildren := length(validChildren) > 1
			var arrayLikeTargetParts Type
			var nonArrayLikeTargetParts Type
			iterableType := getGlobalIterableType(false)
			if iterableType != emptyGenericType {
				anyIterable := createIterableType(anyType)
				arrayLikeTargetParts = filterType(childrenTargetType, func(t Type) bool {
					return isTypeAssignableTo(t, anyIterable)
				})
				nonArrayLikeTargetParts = filterType(childrenTargetType, func(t Type) bool {
					return !isTypeAssignableTo(t, anyIterable)
				})
			} else {
				arrayLikeTargetParts = filterType(childrenTargetType, isArrayOrTupleLikeType)
				nonArrayLikeTargetParts = filterType(childrenTargetType, func(t Type) bool {
					return !isArrayOrTupleLikeType(t)
				})
			}
			if moreThanOneRealChildren {
				if arrayLikeTargetParts != neverType {
					realSource := createTupleType(checkJsxChildren(containingElement, CheckModeNormal))
					children := generateJsxChildren(containingElement, getInvalidTextualChildDiagnostic)
					result = elaborateIterableOrArrayLikeTargetElementwise(children, realSource, arrayLikeTargetParts, relation, containingMessageChain, errorOutputContainer) || result
				} else if !isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) {
					// arity mismatch
					result = true
					diag := error(containingElement.openingElement.tagName, Diagnostics.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided, childrenPropName, typeToString(childrenTargetType))
					if errorOutputContainer && errorOutputContainer.skipLogging {
						(errorOutputContainer.errors || ( /* TODO(TS-TO-GO) Node BinaryExpression: errorOutputContainer.errors = [] */ TODO)).push(diag)
					}
				}
			} else {
				if nonArrayLikeTargetParts != neverType {
					child := validChildren[0]
					elem := getElaborationElementForJsxChild(child, childrenNameType, getInvalidTextualChildDiagnostic)
					if elem {
						result = elaborateElementwise((func /* generator */ () /* TODO(TS-TO-GO) inferred type Generator<{ errorNode: JsxExpression; innerExpression: Expression | undefined; nameType: LiteralType; errorMessage?: undefined; } | { errorNode: JsxText; innerExpression: undefined; nameType: LiteralType; errorMessage: DiagnosticMessage; } | { errorNode: JsxElement | JsxSelfClosingElement | JsxFragment; innerExpression: JsxElement | JsxSelfClosingElement | JsxFragment; nameType: LiteralType; errorMessage?: undefined; }, void, undefined> */ any {
							yield(elem)
						})(), source, target, relation, containingMessageChain, errorOutputContainer) || result
					}
				} else if !isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) {
					// arity mismatch
					result = true
					diag := error(containingElement.openingElement.tagName, Diagnostics.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided, childrenPropName, typeToString(childrenTargetType))
					if errorOutputContainer && errorOutputContainer.skipLogging {
						(errorOutputContainer.errors || ( /* TODO(TS-TO-GO) Node BinaryExpression: errorOutputContainer.errors = [] */ TODO)).push(diag)
					}
				}
			}
		}
		return result
		getInvalidTextualChildDiagnostic := func() DiagnosticMessage {
			if !invalidTextDiagnostic {
				tagNameText := getTextOfNode(node.parent.tagName)
				childPropName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
				var childrenPropName string
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case childPropName == nil:
					childrenPropName = "children"
				default:
					childrenPropName = unescapeLeadingUnderscores(childPropName)
				}
				childrenTargetType := getIndexedAccessType(target, getStringLiteralType(childrenPropName))
				diagnostic := Diagnostics._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2
				invalidTextDiagnostic = map[any]any{ /* TODO(TS-TO-GO): was object literal */
					/* TODO(TS-TO-GO) Node SpreadAssignment: ...diagnostic */
					"key":     "!!ALREADY FORMATTED!!",
					"message": formatMessage(diagnostic, tagNameText, childrenPropName, typeToString(childrenTargetType)),
				}
			}
			return invalidTextDiagnostic
		}
	}
	// TODO(TS-TO-GO): was generator
	generateLimitedTupleElements := func(node ArrayLiteralExpression, target Type) ElaborationIterator {
		len := length(node.elements)
		if !len {
			return
		}
		for i := 0; i < len; i++ {
			// Skip elements which do not exist in the target - a length error on the tuple overall is likely better than an error on a mismatched index signature
			if isTupleLikeType(target) && !getPropertyOfType(target, (""+i) /* as __String */) {
				continue
			}
			elem := node.elements[i]
			if isOmittedExpression(elem) {
				continue
			}
			nameType := getNumberLiteralType(i)
			checkNode := getEffectiveCheckNode(elem)
			yield(map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"errorNode":       checkNode,
				"innerExpression": checkNode,
				"nameType":        nameType,
			})
		}
	}
	elaborateArrayLiteral := func(node ArrayLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if target.flags & (TypeFlagsPrimitive | TypeFlagsNever) {
			return false
		}
		if isTupleLikeType(source) {
			return elaborateElementwise(generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer)
		}
		// recreate a tuple from the elements, if possible
		// Since we're re-doing the expression type, we need to reapply the contextual type
		pushContextualType(node, target /*isCache*/, false)
		tupleizedType := checkArrayLiteral(node, CheckModeContextual /*forceTuple*/, true)
		popContextualType()
		if isTupleLikeType(tupleizedType) {
			return elaborateElementwise(generateLimitedTupleElements(node, target), tupleizedType, target, relation, containingMessageChain, errorOutputContainer)
		}
		return false
	}
	// TODO(TS-TO-GO): was generator
	generateObjectLiteralElements := func(node ObjectLiteralExpression) ElaborationIterator {
		if !length(node.properties) {
			return
		}
		for _, prop := range node.properties {
			if isSpreadAssignment(prop) {
				continue
			}
			type_ := getLiteralTypeFromProperty(getSymbolOfDeclaration(prop), TypeFlagsStringOrNumberLiteralOrUnique)
			if !type_ || (type_.flags & TypeFlagsNever) {
				continue
			}
			switch prop.kind {
			case SyntaxKindSetAccessor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindShorthandPropertyAssignment:
				yield(map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"errorNode":       prop.name,
					"innerExpression": nil,
					"nameType":        type_,
				})
				break
			case SyntaxKindPropertyAssignment:
				yield(map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"errorNode":       prop.name,
					"innerExpression": prop.initializer,
					"nameType":        type_,
					"errorMessage":    __COND__(isComputedNonLiteralName(prop.name), Diagnostics.Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1, nil),
				})
				break
			default:
				Debug.assertNever(prop)
			}
		}
	}
	elaborateObjectLiteral := func(node ObjectLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if target.flags & (TypeFlagsPrimitive | TypeFlagsNever) {
			return false
		}
		return elaborateElementwise(generateObjectLiteralElements(node), source, target, relation, containingMessageChain, errorOutputContainer)
	}
	/**
	 * This is *not* a bi-directional relationship.
	 * If one needs to check both directions for comparability, use a second call to this function or 'isTypeComparableTo'.
	 */
	checkTypeComparableTo := func(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
		return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain)
	}
	isSignatureAssignableTo := func(source Signature, target Signature, ignoreReturnTypes bool) bool {
		return compareSignaturesRelated(source, target, __COND__(ignoreReturnTypes, SignatureCheckModeIgnoreReturnTypes, SignatureCheckModeNone) /*reportErrors*/, false /*errorReporter*/, nil /*incompatibleErrorReporter*/, nil, compareTypesAssignable /*reportUnreliableMarkers*/, nil) != TernaryFalse
	}
	type ErrorReporter func(message DiagnosticMessage, args DiagnosticArguments)
	/**
	 * Returns true if `s` is `(...args: A) => R` where `A` is `any`, `any[]`, `never`, or `never[]`, and `R` is `any` or `unknown`.
	 */
	isTopSignature := func(s Signature) bool {
		if !s.typeParameters && (!s.thisParameter || isTypeAny(getTypeOfParameter(s.thisParameter))) && s.parameters.length == 1 && signatureHasRestParameter(s) {
			paramType := getTypeOfParameter(s.parameters[0])
			var restType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isArrayType(paramType):
				restType = getTypeArguments(paramType)[0]
			default:
				restType = paramType
			}
			return !!(restType.flags&(TypeFlagsAny|TypeFlagsNever) && getReturnTypeOfSignature(s).flags&TypeFlagsAnyOrUnknown)
		}
		return false
	}
	/**
	 * See signatureRelatedTo, compareSignaturesIdentical
	 */
	compareSignaturesRelated := func(source Signature, target Signature, checkMode SignatureCheckMode, reportErrors bool, errorReporter *ErrorReporter, incompatibleErrorReporter *func(source Type, target Type), compareTypes TypeComparer, reportUnreliableMarkers *TypeMapper) Ternary {
		// TODO (drosen): De-duplicate code between related functions.
		if source == target {
			return TernaryTrue
		}
		if !(checkMode&SignatureCheckModeStrictTopSignature && isTopSignature(source)) && isTopSignature(target) {
			return TernaryTrue
		}
		if checkMode&SignatureCheckModeStrictTopSignature && isTopSignature(source) && !isTopSignature(target) {
			return TernaryFalse
		}
		targetCount := getParameterCount(target)
		sourceHasMoreParameters := !hasEffectiveRestParameter(target) && (__COND__(checkMode&SignatureCheckModeStrictArity, hasEffectiveRestParameter(source) || getParameterCount(source) > targetCount, getMinArgumentCount(source) > targetCount))
		if sourceHasMoreParameters {
			if reportErrors && !(checkMode & SignatureCheckModeStrictArity) {
				// the second condition should be redundant, because there is no error reporting when comparing signatures by strict arity
				// since it is only done for subtype reduction
				errorReporter(Diagnostics.Target_signature_provides_too_few_arguments_Expected_0_or_more_but_got_1, getMinArgumentCount(source), targetCount)
			}
			return TernaryFalse
		}
		if source.typeParameters && source.typeParameters != target.typeParameters {
			target = getCanonicalSignature(target)
			source = instantiateSignatureInContextOf(source, target /*inferenceContext*/, nil, compareTypes)
		}
		sourceCount := getParameterCount(source)
		sourceRestType := getNonArrayRestType(source)
		targetRestType := getNonArrayRestType(target)
		if sourceRestType || targetRestType {
			instantiateType(sourceRestType || targetRestType, reportUnreliableMarkers)
		}
		var kind /* TODO(TS-TO-GO) inferred type SyntaxKind.Unknown | SyntaxKind.MethodSignature | SyntaxKind.MethodDeclaration | SyntaxKind.Constructor | SyntaxKind.GetAccessor | SyntaxKind.SetAccessor | SyntaxKind.CallSignature | SyntaxKind.ConstructSignature | SyntaxKind.IndexSignature | SyntaxKind.FunctionType | SyntaxKind.ConstructorType | SyntaxKind.FunctionExpression | SyntaxKind.ArrowFunction | SyntaxKind.FunctionDeclaration | SyntaxKind.JSDocFunctionType | SyntaxKind.JSDocSignature */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case target.declaration:
			kind = target.declaration.kind
		default:
			kind = SyntaxKindUnknown
		}
		strictVariance := !(checkMode & SignatureCheckModeCallback) && strictFunctionTypes && kind != SyntaxKindMethodDeclaration && kind != SyntaxKindMethodSignature && kind != SyntaxKindConstructor
		result := TernaryTrue
		sourceThisType := getThisTypeOfSignature(source)
		if sourceThisType && sourceThisType != voidType {
			targetThisType := getThisTypeOfSignature(target)
			if targetThisType {
				// void sources are assignable to anything.
				related := !strictVariance && compareTypes(sourceThisType, targetThisType /*reportErrors*/, false) || compareTypes(targetThisType, sourceThisType, reportErrors)
				if !related {
					if reportErrors {
						errorReporter(Diagnostics.The_this_types_of_each_signature_are_incompatible)
					}
					return TernaryFalse
				}
				result &= related
			}
		}
		var paramCount number
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case sourceRestType || targetRestType:
			paramCount = Math.min(sourceCount, targetCount)
		default:
			paramCount = Math.max(sourceCount, targetCount)
		}
		var restIndex number
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case sourceRestType || targetRestType:
			restIndex = paramCount - 1
		default:
			restIndex = -1
		}
		for i := 0; i < paramCount; i++ {
			var sourceType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case i == restIndex:
				sourceType = getRestOrAnyTypeAtPosition(source, i)
			default:
				sourceType = tryGetTypeAtPosition(source, i)
			}
			var targetType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case i == restIndex:
				targetType = getRestOrAnyTypeAtPosition(target, i)
			default:
				targetType = tryGetTypeAtPosition(target, i)
			}
			if sourceType && targetType && (sourceType != targetType || checkMode&SignatureCheckModeStrictArity) {
				// In order to ensure that any generic type Foo<T> is at least co-variant with respect to T no matter
				// how Foo uses T, we need to relate parameters bi-variantly (given that parameters are input positions,
				// they naturally relate only contra-variantly). However, if the source and target parameters both have
				// function types with a single call signature, we know we are relating two callback parameters. In
				// that case it is sufficient to only relate the parameters of the signatures co-variantly because,
				// similar to return values, callback parameters are output positions. This means that a Promise<T>,
				// where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant)
				// with respect to T.
				var sourceSig *Signature
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case checkMode&SignatureCheckModeCallback || isInstantiatedGenericParameter(source, i):
					sourceSig = nil
				default:
					sourceSig = getSingleCallSignature(getNonNullableType(sourceType))
				}
				var targetSig *Signature
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case checkMode&SignatureCheckModeCallback || isInstantiatedGenericParameter(target, i):
					targetSig = nil
				default:
					targetSig = getSingleCallSignature(getNonNullableType(targetType))
				}
				callbacks := sourceSig && targetSig && !getTypePredicateOfSignature(sourceSig) && !getTypePredicateOfSignature(targetSig) && getTypeFacts(sourceType, TypeFactsIsUndefinedOrNull) == getTypeFacts(targetType, TypeFactsIsUndefinedOrNull)
				var related Ternary
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case callbacks:
					related = compareSignaturesRelated(targetSig, sourceSig, (checkMode&SignatureCheckModeStrictArity)|(__COND__(strictVariance, SignatureCheckModeStrictCallback, SignatureCheckModeBivariantCallback)), reportErrors, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers)
				default:
					related = !(checkMode&SignatureCheckModeCallback) && !strictVariance && compareTypes(sourceType, targetType /*reportErrors*/, false) || compareTypes(targetType, sourceType, reportErrors)
				}
				// With strict arity, (x: number | undefined) => void is a subtype of (x?: number | undefined) => void
				if related && checkMode&SignatureCheckModeStrictArity && i >= getMinArgumentCount(source) && i < getMinArgumentCount(target) && compareTypes(sourceType, targetType /*reportErrors*/, false) {
					related = TernaryFalse
				}
				if !related {
					if reportErrors {
						errorReporter(Diagnostics.Types_of_parameters_0_and_1_are_incompatible, unescapeLeadingUnderscores(getParameterNameAtPosition(source, i)), unescapeLeadingUnderscores(getParameterNameAtPosition(target, i)))
					}
					return TernaryFalse
				}
				result &= related
			}
		}
		if !(checkMode & SignatureCheckModeIgnoreReturnTypes) {
			// If a signature resolution is already in-flight, skip issuing a circularity error
			// here and just use the `any` type directly
			var targetReturnType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isResolvingReturnTypeOfSignature(target):
				targetReturnType = anyType
			case target.declaration && isJSConstructor(target.declaration):
				targetReturnType = getDeclaredTypeOfClassOrInterface(getMergedSymbol(target.declaration.symbol))
			default:
				targetReturnType = getReturnTypeOfSignature(target)
			}
			if targetReturnType == voidType || targetReturnType == anyType {
				return result
			}
			var sourceReturnType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isResolvingReturnTypeOfSignature(source):
				sourceReturnType = anyType
			case source.declaration && isJSConstructor(source.declaration):
				sourceReturnType = getDeclaredTypeOfClassOrInterface(getMergedSymbol(source.declaration.symbol))
			default:
				sourceReturnType = getReturnTypeOfSignature(source)
			}
			// The following block preserves behavior forbidding boolean returning functions from being assignable to type guard returning functions
			targetTypePredicate := getTypePredicateOfSignature(target)
			if targetTypePredicate {
				sourceTypePredicate := getTypePredicateOfSignature(source)
				if sourceTypePredicate {
					result &= compareTypePredicateRelatedTo(sourceTypePredicate, targetTypePredicate, reportErrors, errorReporter, compareTypes)
				} else if isIdentifierTypePredicate(targetTypePredicate) || isThisTypePredicate(targetTypePredicate) {
					if reportErrors {
						errorReporter(Diagnostics.Signature_0_must_be_a_type_predicate, signatureToString(source))
					}
					return TernaryFalse
				}
			} else {
				// When relating callback signatures, we still need to relate return types bi-variantly as otherwise
				// the containing type wouldn't be co-variant. For example, interface Foo<T> { add(cb: () => T): void }
				// wouldn't be co-variant for T without this rule.
				result &= checkMode&SignatureCheckModeBivariantCallback && compareTypes(targetReturnType, sourceReturnType /*reportErrors*/, false) || compareTypes(sourceReturnType, targetReturnType, reportErrors)
				if !result && reportErrors && incompatibleErrorReporter {
					incompatibleErrorReporter(sourceReturnType, targetReturnType)
				}
			}
		}
		return result
	}
	compareTypePredicateRelatedTo := func(source TypePredicate, target TypePredicate, reportErrors bool, errorReporter *ErrorReporter, compareTypes func(s Type, t Type, reportErrors bool) Ternary) Ternary {
		if source.kind != target.kind {
			if reportErrors {
				errorReporter(Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard)
				errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target))
			}
			return TernaryFalse
		}
		if source.kind == TypePredicateKindIdentifier || source.kind == TypePredicateKindAssertsIdentifier {
			if source.parameterIndex != (target /* as IdentifierTypePredicate */).parameterIndex {
				if reportErrors {
					errorReporter(Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1, source.parameterName, (target /* as IdentifierTypePredicate */).parameterName)
					errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target))
				}
				return TernaryFalse
			}
		}
		var related Ternary
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case source.type_ == target.type_:
			related = TernaryTrue
		case source.type_ && target.type_:
			related = compareTypes(source.type_, target.type_, reportErrors)
		default:
			related = TernaryFalse
		}
		if related == TernaryFalse && reportErrors {
			errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target))
		}
		return related
	}
	isImplementationCompatibleWithOverload := func(implementation Signature, overload Signature) bool {
		erasedSource := getErasedSignature(implementation)
		erasedTarget := getErasedSignature(overload)
		// First see if the return types are compatible in either direction.
		sourceReturnType := getReturnTypeOfSignature(erasedSource)
		targetReturnType := getReturnTypeOfSignature(erasedTarget)
		if targetReturnType == voidType || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation) || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation) {
			return isSignatureAssignableTo(erasedSource, erasedTarget /*ignoreReturnTypes*/, true)
		}
		return false
	}
	isEmptyResolvedType := func(t ResolvedType) bool {
		return t != anyFunctionType && t.properties.length == 0 && t.callSignatures.length == 0 && t.constructSignatures.length == 0 && t.indexInfos.length == 0
	}
	isEmptyObjectType := func(type_ Type) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsObject:
			return !isGenericMappedType(type_) && isEmptyResolvedType(resolveStructuredTypeMembers(type_ /* as ObjectType */))
		case type_.flags & TypeFlagsNonPrimitive:
			return true
		case type_.flags & TypeFlagsUnion:
			return some((type_ /* as UnionType */).types, isEmptyObjectType)
		case type_.flags & TypeFlagsIntersection:
			return every((type_ /* as UnionType */).types, isEmptyObjectType)
		default:
			return false
		}
	}
	isEmptyAnonymousObjectType := func(type_ Type) bool {
		return !!(getObjectFlags(type_)&ObjectFlagsAnonymous && ((type_ /* as ResolvedType */).members && isEmptyResolvedType(type_ /* as ResolvedType */) || type_.symbol && type_.symbol.flags&SymbolFlagsTypeLiteral && getMembersOfSymbol(type_.symbol).size == 0))
	}
	isUnknownLikeUnionType := func(type_ Type) bool {
		if strictNullChecks && type_.flags&TypeFlagsUnion {
			if !((type_ /* as UnionType */).objectFlags & ObjectFlagsIsUnknownLikeUnionComputed) {
				types := (type_ /* as UnionType */).types
				(type_ /* as UnionType */).objectFlags |= ObjectFlagsIsUnknownLikeUnionComputed | (__COND__(types.length >= 3 && types[0].flags&TypeFlagsUndefined && types[1].flags&TypeFlagsNull && some(types, isEmptyAnonymousObjectType), ObjectFlagsIsUnknownLikeUnion, 0))
			}
			return !!((type_ /* as UnionType */).objectFlags & ObjectFlagsIsUnknownLikeUnion)
		}
		return false
	}
	containsUndefinedType := func(type_ Type) bool {
		return !!((__COND__(type_.flags&TypeFlagsUnion, (type_ /* as UnionType */).types[0], type_)).flags & TypeFlagsUndefined)
	}
	containsNonMissingUndefinedType := func(type_ Type) bool {
		var candidate Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnion:
			candidate = (type_ /* as UnionType */).types[0]
		default:
			candidate = type_
		}
		return !!(candidate.flags & TypeFlagsUndefined) && candidate != missingType
	}
	isStringIndexSignatureOnlyType := func(type_ Type) bool {
		return type_.flags&TypeFlagsObject && !isGenericMappedType(type_) && getPropertiesOfType(type_).length == 0 && getIndexInfosOfType(type_).length == 1 && !!getIndexInfoOfType(type_, stringType) || type_.flags&TypeFlagsUnionOrIntersection && every((type_ /* as UnionOrIntersectionType */).types, isStringIndexSignatureOnlyType) || false
	}
	isEnumTypeRelatedTo := func(source Symbol, target Symbol, errorReporter ErrorReporter) bool {
		var sourceSymbol Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case source.flags & SymbolFlagsEnumMember:
			sourceSymbol = getParentOfSymbol(source)
		default:
			sourceSymbol = source
		}
		var targetSymbol Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case target.flags & SymbolFlagsEnumMember:
			targetSymbol = getParentOfSymbol(target)
		default:
			targetSymbol = target
		}
		if sourceSymbol == targetSymbol {
			return true
		}
		if sourceSymbol.escapedName != targetSymbol.escapedName || !(sourceSymbol.flags & SymbolFlagsRegularEnum) || !(targetSymbol.flags & SymbolFlagsRegularEnum) {
			return false
		}
		id := getSymbolId(sourceSymbol) + "," + getSymbolId(targetSymbol)
		entry := enumRelation.get(id)
		if entry != nil && !(entry&RelationComparisonResultFailed && errorReporter) {
			return !!(entry & RelationComparisonResultSucceeded)
		}
		targetEnumType := getTypeOfSymbol(targetSymbol)
		for _, sourceProperty := range getPropertiesOfType(getTypeOfSymbol(sourceSymbol)) {
			if sourceProperty.flags & SymbolFlagsEnumMember {
				targetProperty := getPropertyOfType(targetEnumType, sourceProperty.escapedName)
				if !targetProperty || !(targetProperty.flags & SymbolFlagsEnumMember) {
					if errorReporter {
						errorReporter(Diagnostics.Property_0_is_missing_in_type_1, symbolName(sourceProperty), typeToString(getDeclaredTypeOfSymbol(targetSymbol) /*enclosingDeclaration*/, nil, TypeFormatFlagsUseFullyQualifiedType))
					}
					enumRelation.set(id, RelationComparisonResultFailed)
					return false
				}
				sourceValue := getEnumMemberValue(getDeclarationOfKind(sourceProperty, SyntaxKindEnumMember)).value
				targetValue := getEnumMemberValue(getDeclarationOfKind(targetProperty, SyntaxKindEnumMember)).value
				if sourceValue != targetValue {
					sourceIsString := /* TODO(TS-TO-GO) Node TypeOfExpression: typeof sourceValue */ TODO == "string"
					targetIsString := /* TODO(TS-TO-GO) Node TypeOfExpression: typeof targetValue */ TODO == "string"
					// If we have 2 enums with *known* values that differ, they are incompatible.
					if sourceValue != nil && targetValue != nil {
						if errorReporter {
							var escapedSource /* TODO(TS-TO-GO) inferred type string | number */ any
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case sourceIsString:
								escapedSource = __TEMPLATE__("\"", escapeString(sourceValue), "\"")
							default:
								escapedSource = sourceValue
							}
							var escapedTarget /* TODO(TS-TO-GO) inferred type string | number */ any
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case targetIsString:
								escapedTarget = __TEMPLATE__("\"", escapeString(targetValue), "\"")
							default:
								escapedTarget = targetValue
							}
							errorReporter(Diagnostics.Each_declaration_of_0_1_differs_in_its_value_where_2_was_expected_but_3_was_given, symbolName(targetSymbol), symbolName(targetProperty), escapedTarget, escapedSource)
						}
						enumRelation.set(id, RelationComparisonResultFailed)
						return false
					}
					// At this point we know that at least one of the values is 'undefined'.
					// This may mean that we have an opaque member from an ambient enum declaration,
					// or that we were not able to calculate it (which is basically an error).
					//
					// Either way, we can assume that it's numeric.
					// If the other is a string, we have a mismatch in types.
					if sourceIsString || targetIsString {
						if errorReporter {
							knownStringValue := /* TODO(TS-TO-GO) Node BinaryExpression: sourceValue ?? targetValue */ TODO
							Debug.assert( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof knownStringValue */ TODO == "string")
							escapedValue := __TEMPLATE__("\"", escapeString(knownStringValue), "\"")
							errorReporter(Diagnostics.One_value_of_0_1_is_the_string_2_and_the_other_is_assumed_to_be_an_unknown_numeric_value, symbolName(targetSymbol), symbolName(targetProperty), escapedValue)
						}
						enumRelation.set(id, RelationComparisonResultFailed)
						return false
					}
				}
			}
		}
		enumRelation.set(id, RelationComparisonResultSucceeded)
		return true
	}
	isSimpleTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorReporter ErrorReporter) bool {
		s := source.flags
		t := target.flags
		if t&TypeFlagsAny || s&TypeFlagsNever || source == wildcardType {
			return true
		}
		if t&TypeFlagsUnknown && !(relation == strictSubtypeRelation && s&TypeFlagsAny) {
			return true
		}
		if t & TypeFlagsNever {
			return false
		}
		if s&TypeFlagsStringLike && t&TypeFlagsString {
			return true
		}
		if s&TypeFlagsStringLiteral && s&TypeFlagsEnumLiteral && t&TypeFlagsStringLiteral && !(t & TypeFlagsEnumLiteral) && (source /* as StringLiteralType */).value == (target /* as StringLiteralType */).value {
			return true
		}
		if s&TypeFlagsNumberLike && t&TypeFlagsNumber {
			return true
		}
		if s&TypeFlagsNumberLiteral && s&TypeFlagsEnumLiteral && t&TypeFlagsNumberLiteral && !(t & TypeFlagsEnumLiteral) && (source /* as NumberLiteralType */).value == (target /* as NumberLiteralType */).value {
			return true
		}
		if s&TypeFlagsBigIntLike && t&TypeFlagsBigInt {
			return true
		}
		if s&TypeFlagsBooleanLike && t&TypeFlagsBoolean {
			return true
		}
		if s&TypeFlagsESSymbolLike && t&TypeFlagsESSymbol {
			return true
		}
		if s&TypeFlagsEnum && t&TypeFlagsEnum && source.symbol.escapedName == target.symbol.escapedName && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
			return true
		}
		if s&TypeFlagsEnumLiteral && t&TypeFlagsEnumLiteral {
			if s&TypeFlagsUnion && t&TypeFlagsUnion && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
				return true
			}
			if s&TypeFlagsLiteral && t&TypeFlagsLiteral && (source /* as LiteralType */).value == (target /* as LiteralType */).value && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
				return true
			}
		}
		// In non-strictNullChecks mode, `undefined` and `null` are assignable to anything except `never`.
		// Since unions and intersections may reduce to `never`, we exclude them here.
		if s&TypeFlagsUndefined && (!strictNullChecks && !(t&TypeFlagsUnionOrIntersection) || t&(TypeFlagsUndefined|TypeFlagsVoid)) {
			return true
		}
		if s&TypeFlagsNull && (!strictNullChecks && !(t&TypeFlagsUnionOrIntersection) || t&TypeFlagsNull) {
			return true
		}
		if s&TypeFlagsObject && t&TypeFlagsNonPrimitive && !(relation == strictSubtypeRelation && isEmptyAnonymousObjectType(source) && !(getObjectFlags(source) & ObjectFlagsFreshLiteral)) {
			return true
		}
		if relation == assignableRelation || relation == comparableRelation {
			if s & TypeFlagsAny {
				return true
			}
			// Type number is assignable to any computed numeric enum type or any numeric enum literal type, and
			// a numeric literal type is assignable any computed numeric enum type or any numeric enum literal type
			// with a matching value. These rules exist such that enums can be used for bit-flag purposes.
			if s&TypeFlagsNumber && (t&TypeFlagsEnum || t&TypeFlagsNumberLiteral && t&TypeFlagsEnumLiteral) {
				return true
			}
			if s&TypeFlagsNumberLiteral && !(s & TypeFlagsEnumLiteral) && (t&TypeFlagsEnum || t&TypeFlagsNumberLiteral && t&TypeFlagsEnumLiteral && (source /* as NumberLiteralType */).value == (target /* as NumberLiteralType */).value) {
				return true
			}
			// Anything is assignable to a union containing undefined, null, and {}
			if isUnknownLikeUnionType(target) {
				return true
			}
		}
		return false
	}
	isTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult]) bool {
		if isFreshLiteralType(source) {
			source = (source /* as FreshableType */).regularType
		}
		if isFreshLiteralType(target) {
			target = (target /* as FreshableType */).regularType
		}
		if source == target {
			return true
		}
		if relation != identityRelation {
			if relation == comparableRelation && !(target.flags&TypeFlagsNever) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation) {
				return true
			}
		} else if !((source.flags | target.flags) & (TypeFlagsUnionOrIntersection | TypeFlagsIndexedAccess | TypeFlagsConditional | TypeFlagsSubstitution)) {
			// We have excluded types that may simplify to other forms, so types must have identical flags
			if source.flags != target.flags {
				return false
			}
			if source.flags & TypeFlagsSingleton {
				return true
			}
		}
		if source.flags&TypeFlagsObject && target.flags&TypeFlagsObject {
			related := relation.get(getRelationKey(source, target, IntersectionStateNone, relation /*ignoreConstraints*/, false))
			if related != nil {
				return !!(related & RelationComparisonResultSucceeded)
			}
		}
		if source.flags&TypeFlagsStructuredOrInstantiable || target.flags&TypeFlagsStructuredOrInstantiable {
			return checkTypeRelatedTo(source, target, relation /*errorNode*/, nil)
		}
		return false
	}
	isIgnoredJsxProperty := func(source Type, sourceProp Symbol) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
		return getObjectFlags(source)&ObjectFlagsJsxAttributes && isHyphenatedJsxName(sourceProp.escapedName)
	}
	getNormalizedType := func(type_ Type, writing bool) Type {
		for true {
			var t Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isFreshLiteralType(type_):
				t = (type_ /* as FreshableType */).regularType
			case isGenericTupleType(type_):
				t = getNormalizedTupleType(type_, writing)
			case getObjectFlags(type_) & ObjectFlagsReference:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case (type_ /* as TypeReference */).node:
					t = createTypeReference((type_ /* as TypeReference */).target, getTypeArguments(type_ /* as TypeReference */))
				default:
					t = getSingleBaseForNonAugmentingSubtype(type_) || type_
				}
			case type_.flags & TypeFlagsUnionOrIntersection:
				t = getNormalizedUnionOrIntersectionType(type_ /* as UnionOrIntersectionType */, writing)
			case type_.flags & TypeFlagsSubstitution:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case writing:
					t = (type_ /* as SubstitutionType */).baseType
				default:
					t = getSubstitutionIntersection(type_ /* as SubstitutionType */)
				}
			case type_.flags & TypeFlagsSimplifiable:
				t = getSimplifiedType(type_, writing)
			default:
				t = type_
			}
			if t == type_ {
				return t
			}
			type_ = t
		}
	}
	getNormalizedUnionOrIntersectionType := func(type_ UnionOrIntersectionType, writing bool) Type {
		reduced := getReducedType(type_)
		if reduced != type_ {
			return reduced
		}
		if type_.flags&TypeFlagsIntersection && shouldNormalizeIntersection(type_ /* as IntersectionType */) {
			// Normalization handles cases like
			// Partial<T>[K] & ({} | null) ==>
			// Partial<T>[K] & {} | Partial<T>[K} & null ==>
			// (T[K] | undefined) & {} | (T[K] | undefined) & null ==>
			// T[K] & {} | undefined & {} | T[K] & null | undefined & null ==>
			// T[K] & {} | T[K] & null
			normalizedTypes := sameMap(type_.types, func(t Type) Type {
				return getNormalizedType(t, writing)
			})
			if normalizedTypes != type_.types {
				return getIntersectionType(normalizedTypes)
			}
		}
		return type_
	}
	shouldNormalizeIntersection := func(type_ IntersectionType) bool {
		hasInstantiable := false
		hasNullableOrEmpty := false
		for _, t := range type_.types {
			/* TODO(TS-TO-GO) Node BinaryExpression: hasInstantiable ||= !!(t.flags & TypeFlags.Instantiable) */ TODO
			/* TODO(TS-TO-GO) Node BinaryExpression: hasNullableOrEmpty ||= !!(t.flags & TypeFlags.Nullable) || isEmptyAnonymousObjectType(t) */ TODO
			if hasInstantiable && hasNullableOrEmpty {
				return true
			}
		}
		return false
	}
	getNormalizedTupleType := func(type_ TupleTypeReference, writing bool) Type {
		elements := getElementTypes(type_)
		normalizedElements := sameMap(elements, func(t Type) Type {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case t.flags & TypeFlagsSimplifiable:
				return getSimplifiedType(t, writing)
			default:
				return t
			}
		})
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case elements != normalizedElements:
			return createNormalizedTupleType(type_.target, normalizedElements)
		default:
			return type_
		}
	}
	/**
	 * Checks if 'source' is related to 'target' (e.g.: is a assignable to).
	 * @param source The left-hand-side of the relation.
	 * @param target The right-hand-side of the relation.
	 * @param relation The relation considered. One of 'identityRelation', 'subtypeRelation', 'assignableRelation', or 'comparableRelation'.
	 * Used as both to determine which checks are performed and as a cache of previously computed results.
	 * @param errorNode The suggested node upon which all errors will be reported, if defined. This may or may not be the actual node used.
	 * @param headMessage If the error chain should be prepended by a head message, then headMessage will be used.
	 * @param containingMessageChain A chain of errors to prepend any new errors found.
	 * @param errorOutputContainer Return the diagnostic. Do not log if 'skipLogging' is truthy.
	 */
	checkTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputContainer /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		var errorInfo *DiagnosticMessageChain
		var relatedInfo * /* TODO(TS-TO-GO) TypeNode TupleType: [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] */ any
		var maybeKeys []string
		var maybeKeysSet Set[string]
		var sourceStack []Type
		var targetStack []Type
		maybeCount := 0
		sourceDepth := 0
		targetDepth := 0
		expandingFlags := ExpandingFlagsNone
		overflow := false
		overrideNextErrorInfo := 0
		// How many `reportRelationError` calls should be skipped in the elaboration pyramid
		skipParentCounter := 0
		// How many errors should be skipped 'above' in the elaboration pyramid
		var lastSkippedInfo * /* TODO(TS-TO-GO) TypeNode TupleType: [Type, Type] */ any
		var incompatibleStack *[]DiagnosticAndArguments
		// In Node.js, the maximum number of elements in a map is 2^24. We limit the number of entries an invocation
		// of checkTypeRelatedTo can add to a relation to 1/8th of its remaining capacity.
		relationCount := /* TODO(TS-TO-GO) Node BinaryExpression: (16_000_000 - relation.size) >> 3 */ TODO
		Debug.assert(relation != identityRelation || !errorNode, "no error reporting in identity checking")
		result := isRelatedTo(source, target, RecursionFlagsBoth /*reportErrors*/, !!errorNode, headMessage)
		if incompatibleStack {
			reportIncompatibleStack()
		}
		if overflow {
			// Record this relation as having failed such that we don't attempt the overflowing operation again.
			id := getRelationKey(source, target /*intersectionState*/, IntersectionStateNone, relation /*ignoreConstraints*/, false)
			relation.set(id, RelationComparisonResultFailed|(__COND__(relationCount <= 0, RelationComparisonResultComplexityOverflow, RelationComparisonResultStackDepthOverflow)))
			tracing. /* TODO(TS-TO-GO): was ? */ instant(tracing.Phase.CheckTypes, "checkTypeRelatedTo_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"sourceId":    source.id,
				"targetId":    target.id,
				"depth":       sourceDepth,
				"targetDepth": targetDepth,
			})
			var message DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case relationCount <= 0:
				message = Diagnostics.Excessive_complexity_comparing_types_0_and_1
			default:
				message = Diagnostics.Excessive_stack_depth_comparing_types_0_and_1
			}
			diag := error(errorNode || currentNode, message, typeToString(source), typeToString(target))
			if errorOutputContainer {
				(errorOutputContainer.errors || ( /* TODO(TS-TO-GO) Node BinaryExpression: errorOutputContainer.errors = [] */ TODO)).push(diag)
			}
		} else if errorInfo {
			if containingMessageChain {
				chain := containingMessageChain()
				if chain {
					concatenateDiagnosticMessageChains(chain, errorInfo)
					errorInfo = chain
				}
			}
			var relatedInformation *[]DiagnosticRelatedInformation
			// Check if we should issue an extra diagnostic to produce a quickfix for a slightly incorrect import statement
			if headMessage && errorNode && !result && source.symbol {
				links := getSymbolLinks(source.symbol)
				if links.originatingImport && !isImportCall(links.originatingImport) {
					helpfulRetry := checkTypeRelatedTo(getTypeOfSymbol(links.target), target, relation /*errorNode*/, nil)
					if helpfulRetry {
						// Likely an incorrect import. Issue a helpful diagnostic to produce a quickfix to change the import
						diag := createDiagnosticForNode(links.originatingImport, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead)
						relatedInformation = append(relatedInformation, diag)
						// Cause the error to appear with the error that triggered it
					}
				}
			}
			diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, errorInfo, relatedInformation)
			if relatedInfo {
				addRelatedInfo(diag, relatedInfo...)
			}
			if errorOutputContainer {
				(errorOutputContainer.errors || ( /* TODO(TS-TO-GO) Node BinaryExpression: errorOutputContainer.errors = [] */ TODO)).push(diag)
			}
			if !errorOutputContainer || !errorOutputContainer.skipLogging {
				diagnostics.add(diag)
			}
		}
		if errorNode && errorOutputContainer && errorOutputContainer.skipLogging && result == TernaryFalse {
			Debug.assert(!!errorOutputContainer.errors, "missed opportunity to interact with error.")
		}
		return result != TernaryFalse
		resetErrorInfo := func(saved ReturnType[ /* TODO(TS-TO-GO) TypeNode TypeQuery: typeof captureErrorCalculationState */ any]) {
			errorInfo = saved.errorInfo
			lastSkippedInfo = saved.lastSkippedInfo
			incompatibleStack = saved.incompatibleStack
			overrideNextErrorInfo = saved.overrideNextErrorInfo
			skipParentCounter = saved.skipParentCounter
			relatedInfo = saved.relatedInfo
		}
		captureErrorCalculationState := func() /* TODO(TS-TO-GO) inferred type { errorInfo: DiagnosticMessageChain | undefined; lastSkippedInfo: [Type, Type] | undefined; incompatibleStack: [message: DiagnosticMessage, ...args: (string | number)[]][] | undefined; overrideNextErrorInfo: number; skipParentCounter: number; relatedInfo: [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined; } */ any {
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"errorInfo":             errorInfo,
				"lastSkippedInfo":       lastSkippedInfo,
				"incompatibleStack":     incompatibleStack. /* TODO(TS-TO-GO): was ? */ slice(),
				"overrideNextErrorInfo": overrideNextErrorInfo,
				"skipParentCounter":     skipParentCounter,
				"relatedInfo":           relatedInfo. /* TODO(TS-TO-GO): was ? */ slice(), /* as [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined */
			}
		}
		reportIncompatibleError := func(message DiagnosticMessage, args DiagnosticArguments) {
			overrideNextErrorInfo++
			// Suppress the next relation error
			lastSkippedInfo = nil
			// Reset skipped info cache
			( /* TODO(TS-TO-GO) Node BinaryExpression: incompatibleStack ||= [] */ TODO).push([]any{message /* TODO(TS-TO-GO) Node SpreadElement: ...args */})
		}
		reportIncompatibleStack := func() undefined {
			stack := incompatibleStack || []never{}
			incompatibleStack = nil
			info := lastSkippedInfo
			lastSkippedInfo = nil
			if stack.length == 1 {
				reportError(stack[0]...)
				if info {
					// Actually do the last relation error
					reportRelationError(nil, info...)
				}
				return
			}
			// The first error will be the innermost, while the last will be the outermost - so by popping off the end,
			// we can build from left to right
			path := ""
			var secondaryRootErrors []DiagnosticAndArguments = []never{}
			for stack.length {
				TODO_IDENTIFIER := stack.pop()
				switch msg.code {
				case Diagnostics.Types_of_property_0_are_incompatible.code:
					// Parenthesize a `new` if there is one
					if path.indexOf("new ") == 0 {
						path = __TEMPLATE__("(", path, ")")
					}
					str := "" + args[0]
					// If leading, just print back the arg (irrespective of if it's a valid identifier)
					if path.length == 0 {
						path = __TEMPLATE__(str)
					} else if isIdentifierText(str, getEmitScriptTarget(compilerOptions)) {
						path = __TEMPLATE__(path, ".", str)
					} else if str[0] == "[" && str[str.length-1] == "]" {
						path = __TEMPLATE__(path, str)
					} else {
						path = __TEMPLATE__(path, "[", str, "]")
					}
					break
					fallthrough
				case Diagnostics.Call_signature_return_types_0_and_1_are_incompatible.code:
					fallthrough // TODO(TS-TO-GO): merge cases
				case Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code:
					fallthrough // TODO(TS-TO-GO): merge cases
				case Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:
					fallthrough // TODO(TS-TO-GO): merge cases
				case Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:
					if path.length == 0 {
						// Don't flatten signature compatability errors at the start of a chain - instead prefer
						// to unify (the with no arguments bit is excessive for printback) and print them back
						mappedMsg := msg
						if msg.code == Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code {
							mappedMsg = Diagnostics.Call_signature_return_types_0_and_1_are_incompatible
						} else if msg.code == Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code {
							mappedMsg = Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible
						}
						secondaryRootErrors.unshift([]any{mappedMsg, args[0], args[1]})
					} else {
						var prefix /* TODO(TS-TO-GO) inferred type "" | "new " */ any
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case (msg.code == Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code || msg.code == Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code):
							prefix = "new "
						default:
							prefix = ""
						}
						var params /* TODO(TS-TO-GO) inferred type "" | "..." */ any
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case (msg.code == Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code || msg.code == Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code):
							params = ""
						default:
							params = "..."
						}
						path = __TEMPLATE__(prefix, path, "(", params, ")")
					}
					break
					fallthrough
				case Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target.code:
					secondaryRootErrors.unshift([]any{Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, args[0], args[1]})
					break
					fallthrough
				case Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target.code:
					secondaryRootErrors.unshift([]any{Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, args[0], args[1], args[2]})
					break
					fallthrough
				default:
					return Debug.fail(__TEMPLATE__("Unhandled Diagnostic: ", msg.code))
				}
			}
			if path {
				reportError(__COND__(path[path.length-1] == ")", Diagnostics.The_types_returned_by_0_are_incompatible_between_these_types, Diagnostics.The_types_of_0_are_incompatible_between_these_types), path)
			} else {
				// Remove the innermost secondary error as it will duplicate the error already reported by `reportRelationError` on entry
				secondaryRootErrors.shift()
			}
			for _, TODO_IDENTIFIER := range secondaryRootErrors {
				originalValue := msg.elidedInCompatabilityPyramid
				msg.elidedInCompatabilityPyramid = false
				// Temporarily override elision to ensure error is reported
				reportError(msg, args...)
				msg.elidedInCompatabilityPyramid = originalValue
			}
			if info {
				// Actually do the last relation error
				reportRelationError(nil, info...)
			}
		}
		reportError := func(message DiagnosticMessage, args DiagnosticArguments) {
			Debug.assert(!!errorNode)
			if incompatibleStack {
				reportIncompatibleStack()
			}
			if message.elidedInCompatabilityPyramid {
				return
			}
			if skipParentCounter == 0 {
				errorInfo = chainDiagnosticMessages(errorInfo, message, args...)
			} else {
				skipParentCounter--
			}
		}
		reportParentSkippedError := func(message DiagnosticMessage, args DiagnosticArguments) {
			reportError(message, args...)
			skipParentCounter++
		}
		associateRelatedInfo := func(info DiagnosticRelatedInformation) {
			Debug.assert(!!errorInfo)
			if !relatedInfo {
				relatedInfo = []any{info}
			} else {
				relatedInfo.push(info)
			}
		}
		reportRelationError := func(message *DiagnosticMessage, source Type, target Type) {
			if incompatibleStack {
				reportIncompatibleStack()
			}
			TODO_IDENTIFIER := getTypeNamesForErrorDisplay(source, target)
			generalizedSource := source
			generalizedSourceType := sourceType
			if isLiteralType(source) && !typeCouldHaveTopLevelSingletonTypes(target) {
				generalizedSource = getBaseTypeOfLiteralType(source)
				Debug.assert(!isTypeAssignableTo(generalizedSource, target), "generalized source shouldn't be assignable")
				generalizedSourceType = getTypeNameForErrorDisplay(generalizedSource)
			}
			// If `target` is of indexed access type (And `source` it is not), we use the object type of `target` for better error reporting
			var targetFlags TypeFlags
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case target.flags&TypeFlagsIndexedAccess && !(source.flags & TypeFlagsIndexedAccess):
				targetFlags = (target /* as IndexedAccessType */).objectType.flags
			default:
				targetFlags = target.flags
			}
			if targetFlags&TypeFlagsTypeParameter && target != markerSuperTypeForCheck && target != markerSubTypeForCheck {
				constraint := getBaseConstraintOfType(target)
				var needsOriginalSource TODO
				if constraint && (isTypeAssignableTo(generalizedSource, constraint) || ( /* TODO(TS-TO-GO) Node BinaryExpression: needsOriginalSource = isTypeAssignableTo(source, constraint) */ TODO)) {
					reportError(Diagnostics._0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2, __COND__(needsOriginalSource, sourceType, generalizedSourceType), targetType, typeToString(constraint))
				} else {
					errorInfo = nil
					reportError(Diagnostics._0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1, targetType, generalizedSourceType)
				}
			}
			if !message {
				if relation == comparableRelation {
					message = Diagnostics.Type_0_is_not_comparable_to_type_1
				} else if sourceType == targetType {
					message = Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated
				} else if exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(source, target).length {
					message = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
				} else {
					if source.flags&TypeFlagsStringLiteral && target.flags&TypeFlagsUnion {
						suggestedType := getSuggestedTypeForNonexistentStringLiteralType(source /* as StringLiteralType */, target /* as UnionType */)
						if suggestedType {
							reportError(Diagnostics.Type_0_is_not_assignable_to_type_1_Did_you_mean_2, generalizedSourceType, targetType, typeToString(suggestedType))
							return
						}
					}
					message = Diagnostics.Type_0_is_not_assignable_to_type_1
				}
			} else if message == Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1 && exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(source, target).length {
				message = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
			}
			reportError(message, generalizedSourceType, targetType)
		}
		tryElaborateErrorsForPrimitivesAndObjects := func(source Type, target Type) {
			var sourceType string
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case symbolValueDeclarationIsContextSensitive(source.symbol):
				sourceType = typeToString(source, source.symbol.valueDeclaration)
			default:
				sourceType = typeToString(source)
			}
			var targetType string
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case symbolValueDeclarationIsContextSensitive(target.symbol):
				targetType = typeToString(target, target.symbol.valueDeclaration)
			default:
				targetType = typeToString(target)
			}
			if (globalStringType == source && stringType == target) || (globalNumberType == source && numberType == target) || (globalBooleanType == source && booleanType == target) || (getGlobalESSymbolType() == source && esSymbolType == target) {
				reportError(Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType)
			}
		}
		/**
		 * Try and elaborate array and tuple errors. Returns false
		 * if we have found an elaboration, or we should ignore
		 * any other elaborations when relating the `source` and
		 * `target` types.
		 */
		tryElaborateArrayLikeErrors := func(source Type, target Type, reportErrors bool) bool {
			/**
			 * The spec for elaboration is:
			 * - If the source is a readonly tuple and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
			 * - If the source is a tuple then skip property elaborations if the target is an array or tuple.
			 * - If the source is a readonly array and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
			 * - If the source an array then skip property elaborations if the target is a tuple.
			 */
			if isTupleType(source) {
				if source.target.readonly && isMutableArrayOrTuple(target) {
					if reportErrors {
						reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target))
					}
					return false
				}
				return isArrayOrTupleType(target)
			}
			if isReadonlyArrayType(source) && isMutableArrayOrTuple(target) {
				if reportErrors {
					reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target))
				}
				return false
			}
			if isTupleType(target) {
				return isArrayType(source)
			}
			return true
		}
		isRelatedToWorker := func(source Type, target Type, reportErrors bool) Ternary {
			return isRelatedTo(source, target, RecursionFlagsBoth, reportErrors)
		}
		/**
		 * Compare two types and return
		 * * Ternary.True if they are related with no assumptions,
		 * * Ternary.Maybe if they are related with assumptions of other relationships, or
		 * * Ternary.False if they are not related.
		 */
		isRelatedTo := func(originalSource Type, originalTarget Type, recursionFlags RecursionFlags /*  = RecursionFlags.Both */, reportErrors bool /*  = false */, headMessage DiagnosticMessage, intersectionState IntersectionState /*  = IntersectionState.None */) Ternary {
			if originalSource == originalTarget {
				return TernaryTrue
			}
			// Before normalization: if `source` is type an object type, and `target` is primitive,
			// skip all the checks we don't need and just return `isSimpleTypeRelatedTo` result
			if originalSource.flags&TypeFlagsObject && originalTarget.flags&TypeFlagsPrimitive {
				if relation == comparableRelation && !(originalTarget.flags&TypeFlagsNever) && isSimpleTypeRelatedTo(originalTarget, originalSource, relation) || isSimpleTypeRelatedTo(originalSource, originalTarget, relation, __COND__(reportErrors, reportError, nil)) {
					return TernaryTrue
				}
				if reportErrors {
					reportErrorResults(originalSource, originalTarget, originalSource, originalTarget, headMessage)
				}
				return TernaryFalse
			}
			// Normalize the source and target types: Turn fresh literal types into regular literal types,
			// turn deferred type references into regular type references, simplify indexed access and
			// conditional types, and resolve substitution types to either the substitution (on the source
			// side) or the type variable (on the target side).
			source := getNormalizedType(originalSource /*writing*/, false)
			target := getNormalizedType(originalTarget /*writing*/, true)
			if source == target {
				return TernaryTrue
			}
			if relation == identityRelation {
				if source.flags != target.flags {
					return TernaryFalse
				}
				if source.flags & TypeFlagsSingleton {
					return TernaryTrue
				}
				traceUnionsOrIntersectionsTooLarge(source, target)
				return recursiveTypeRelatedTo(source, target /*reportErrors*/, false, IntersectionStateNone, recursionFlags)
			}
			// We fastpath comparing a type parameter to exactly its constraint, as this is _super_ common,
			// and otherwise, for type parameters in large unions, causes us to need to compare the union to itself,
			// as we break down the _target_ union first, _then_ get the source constraint - so for every
			// member of the target, we attempt to find a match in the source. This avoids that in cases where
			// the target is exactly the constraint.
			if source.flags&TypeFlagsTypeParameter && getConstraintOfType(source) == target {
				return TernaryTrue
			}
			// See if we're relating a definitely non-nullable type to a union that includes null and/or undefined
			// plus a single non-nullable type. If so, remove null and/or undefined from the target type.
			if source.flags&TypeFlagsDefinitelyNonNullable && target.flags&TypeFlagsUnion {
				types := (target /* as UnionType */).types
				var candidate Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case types.length == 2 && types[0].flags&TypeFlagsNullable:
					candidate = types[1]
				case types.length == 3 && types[0].flags&TypeFlagsNullable && types[1].flags&TypeFlagsNullable:
					candidate = types[2]
				default:
					candidate = nil
				}
				if candidate && !(candidate.flags & TypeFlagsNullable) {
					target = getNormalizedType(candidate /*writing*/, true)
					if source == target {
						return TernaryTrue
					}
				}
			}
			if relation == comparableRelation && !(target.flags&TypeFlagsNever) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation, __COND__(reportErrors, reportError, nil)) {
				return TernaryTrue
			}
			if source.flags&TypeFlagsStructuredOrInstantiable || target.flags&TypeFlagsStructuredOrInstantiable {
				isPerformingExcessPropertyChecks := !(intersectionState & IntersectionStateTarget) && (isObjectLiteralType(source) && getObjectFlags(source)&ObjectFlagsFreshLiteral)
				if isPerformingExcessPropertyChecks {
					if hasExcessProperties(source /* as FreshObjectLiteralType */, target, reportErrors) {
						if reportErrors {
							reportRelationError(headMessage, source, __COND__(originalTarget.aliasSymbol, originalTarget, target))
						}
						return TernaryFalse
					}
				}
				isPerformingCommonPropertyChecks := (relation != comparableRelation || isUnitType(source)) && !(intersectionState & IntersectionStateTarget) && source.flags&(TypeFlagsPrimitive|TypeFlagsObject|TypeFlagsIntersection) && source != globalObjectType && target.flags&(TypeFlagsObject|TypeFlagsIntersection) && isWeakType(target) && (getPropertiesOfType(source).length > 0 || typeHasCallOrConstructSignatures(source))
				isComparingJsxAttributes := !!(getObjectFlags(source) & ObjectFlagsJsxAttributes)
				if isPerformingCommonPropertyChecks && !hasCommonProperties(source, target, isComparingJsxAttributes) {
					if reportErrors {
						sourceString := typeToString(__COND__(originalSource.aliasSymbol, originalSource, source))
						targetString := typeToString(__COND__(originalTarget.aliasSymbol, originalTarget, target))
						calls := getSignaturesOfType(source, SignatureKindCall)
						constructs := getSignaturesOfType(source, SignatureKindConstruct)
						if calls.length > 0 && isRelatedTo(getReturnTypeOfSignature(calls[0]), target, RecursionFlagsSource /*reportErrors*/, false) || constructs.length > 0 && isRelatedTo(getReturnTypeOfSignature(constructs[0]), target, RecursionFlagsSource /*reportErrors*/, false) {
							reportError(Diagnostics.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it, sourceString, targetString)
						} else {
							reportError(Diagnostics.Type_0_has_no_properties_in_common_with_type_1, sourceString, targetString)
						}
					}
					return TernaryFalse
				}
				traceUnionsOrIntersectionsTooLarge(source, target)
				skipCaching := source.flags&TypeFlagsUnion && (source /* as UnionType */).types.length < 4 && !(target.flags&TypeFlagsUnion) || target.flags&TypeFlagsUnion && (target /* as UnionType */).types.length < 4 && !(source.flags&TypeFlagsStructuredOrInstantiable)
				var result Ternary
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case skipCaching:
					result = unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState)
				default:
					result = recursiveTypeRelatedTo(source, target, reportErrors, intersectionState, recursionFlags)
				}
				if result {
					return result
				}
			}
			if reportErrors {
				reportErrorResults(originalSource, originalTarget, source, target, headMessage)
			}
			return TernaryFalse
		}
		reportErrorResults := func(originalSource Type, originalTarget Type, source Type, target Type, headMessage *DiagnosticMessage) {
			sourceHasBase := !!getSingleBaseForNonAugmentingSubtype(originalSource)
			targetHasBase := !!getSingleBaseForNonAugmentingSubtype(originalTarget)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (originalSource.aliasSymbol || sourceHasBase):
				source = originalSource
			default:
				source = source
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (originalTarget.aliasSymbol || targetHasBase):
				target = originalTarget
			default:
				target = target
			}
			maybeSuppress := overrideNextErrorInfo > 0
			if maybeSuppress {
				overrideNextErrorInfo--
			}
			if source.flags&TypeFlagsObject && target.flags&TypeFlagsObject {
				currentError := errorInfo
				tryElaborateArrayLikeErrors(source, target /*reportErrors*/, true)
				if errorInfo != currentError {
					maybeSuppress = !!errorInfo
				}
			}
			if source.flags&TypeFlagsObject && target.flags&TypeFlagsPrimitive {
				tryElaborateErrorsForPrimitivesAndObjects(source, target)
			} else if source.symbol && source.flags&TypeFlagsObject && globalObjectType == source {
				reportError(Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead)
			} else if getObjectFlags(source)&ObjectFlagsJsxAttributes && target.flags&TypeFlagsIntersection {
				targetTypes := (target /* as IntersectionType */).types
				intrinsicAttributes := getJsxType(JsxNames.IntrinsicAttributes, errorNode)
				intrinsicClassAttributes := getJsxType(JsxNames.IntrinsicClassAttributes, errorNode)
				if !isErrorType(intrinsicAttributes) && !isErrorType(intrinsicClassAttributes) && (contains(targetTypes, intrinsicAttributes) || contains(targetTypes, intrinsicClassAttributes)) {
					// do not report top error
					return
				}
			} else {
				errorInfo = elaborateNeverIntersection(errorInfo, originalTarget)
			}
			// Used by, eg, missing property checking to replace the top-level message with a more informative one.
			if !headMessage && maybeSuppress {
				// We suppress a call to `reportRelationError` or not depending on the state of the type checker, so
				// we call `reportRelationError` here and then undo its effects to figure out what would be the diagnostic
				// if we hadn't supress it, and save that as a canonical diagnostic for deduplication purposes.
				savedErrorState := captureErrorCalculationState()
				reportRelationError(headMessage, source, target)
				var canonical TODO
				if errorInfo && errorInfo != savedErrorState.errorInfo {
					canonical = map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"code":        errorInfo.code,
						"messageText": errorInfo.messageText,
					}
				}
				resetErrorInfo(savedErrorState)
				if canonical && errorInfo {
					errorInfo.canonicalHead = canonical
				}
				lastSkippedInfo = []any{source, target}
				return
			}
			reportRelationError(headMessage, source, target)
			if source.flags&TypeFlagsTypeParameter && source.symbol. /* TODO(TS-TO-GO): was ? */ declarations[0] && !getConstraintOfType(source /* as TypeVariable */) {
				syntheticParam := cloneTypeParameter(source /* as TypeParameter */)
				syntheticParam.constraint = instantiateType(target, makeUnaryTypeMapper(source, syntheticParam))
				if hasNonCircularBaseConstraint(syntheticParam) {
					targetConstraintString := typeToString(target, source.symbol.declarations[0])
					associateRelatedInfo(createDiagnosticForNode(source.symbol.declarations[0], Diagnostics.This_type_parameter_might_need_an_extends_0_constraint, targetConstraintString))
				}
			}
		}
		traceUnionsOrIntersectionsTooLarge := func(source Type, target Type) {
			if !tracing {
				return
			}
			if (source.flags & TypeFlagsUnionOrIntersection) && (target.flags & TypeFlagsUnionOrIntersection) {
				sourceUnionOrIntersection := source /* as UnionOrIntersectionType */
				targetUnionOrIntersection := target /* as UnionOrIntersectionType */
				if sourceUnionOrIntersection.objectFlags & targetUnionOrIntersection.objectFlags & ObjectFlagsPrimitiveUnion {
					// There's a fast path for comparing primitive unions
					return
				}
				sourceSize := sourceUnionOrIntersection.types.length
				targetSize := targetUnionOrIntersection.types.length
				if sourceSize*targetSize > 1e6 {
					tracing.instant(tracing.Phase.CheckTypes, "traceUnionsOrIntersectionsTooLarge_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"sourceId":   source.id,
						"sourceSize": sourceSize,
						"targetId":   target.id,
						"targetSize": targetSize,
						"pos":        errorNode. /* TODO(TS-TO-GO): was ? */ pos,
						"end":        errorNode. /* TODO(TS-TO-GO): was ? */ end,
					})
				}
			}
		}
		getTypeOfPropertyInTypes := func(types []Type, name __String) Type {
			appendPropType := func(propTypes *[]Type, type_ Type) []Type {
				type_ = getApparentType(type_)
				var prop Symbol
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case type_.flags & TypeFlagsUnionOrIntersection:
					prop = getPropertyOfUnionOrIntersectionType(type_ /* as UnionOrIntersectionType */, name)
				default:
					prop = getPropertyOfObjectType(type_, name)
				}
				propType := prop && getTypeOfSymbol(prop) || getApplicableIndexInfoForName(type_, name). /* TODO(TS-TO-GO): was ? */ type_ || undefinedType
				return append(propTypes, propType)
			}
			return getUnionType(reduceLeft(types, appendPropType /*initial*/, nil) || emptyArray)
		}
		hasExcessProperties := func(source FreshObjectLiteralType, target Type, reportErrors bool) bool {
			if !isExcessPropertyCheckTarget(target) || !noImplicitAny && getObjectFlags(target)&ObjectFlagsJSLiteral {
				return false
				// Disable excess property checks on JS literals to simulate having an implicit "index signature" - but only outside of noImplicitAny
			}
			isComparingJsxAttributes := !!(getObjectFlags(source) & ObjectFlagsJsxAttributes)
			if (relation == assignableRelation || relation == comparableRelation) && (isTypeSubsetOf(globalObjectType, target) || (!isComparingJsxAttributes && isEmptyObjectType(target))) {
				return false
			}
			reducedTarget := target
			var checkTypes *[]Type
			if target.flags & TypeFlagsUnion {
				reducedTarget = findMatchingDiscriminantType(source, target /* as UnionType */, isRelatedTo) || filterPrimitivesIfContainsNonPrimitive(target /* as UnionType */)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case reducedTarget.flags & TypeFlagsUnion:
					checkTypes = (reducedTarget /* as UnionType */).types
				default:
					checkTypes = []Type{reducedTarget}
				}
			}
			for _, prop := range getPropertiesOfType(source) {
				if shouldCheckAsExcessProperty(prop, source.symbol) && !isIgnoredJsxProperty(source, prop) {
					if !isKnownProperty(reducedTarget, prop.escapedName, isComparingJsxAttributes) {
						if reportErrors {
							// Report error in terms of object types in the target as those are the only ones
							// we check in isKnownProperty.
							errorTarget := filterType(reducedTarget, isExcessPropertyCheckTarget)
							// We know *exactly* where things went wrong when comparing the types.
							// Use this property as the error node as this will be more helpful in
							// reasoning about what went wrong.
							if !errorNode {
								return Debug.fail()
							}
							if isJsxAttributes(errorNode) || isJsxOpeningLikeElement(errorNode) || isJsxOpeningLikeElement(errorNode.parent) {
								// JsxAttributes has an object-literal flag and undergo same type-assignablity check as normal object-literal.
								// However, using an object-literal error message will be very confusing to the users so we give different a message.
								if prop.valueDeclaration && isJsxAttribute(prop.valueDeclaration) && getSourceFileOfNode(errorNode) == getSourceFileOfNode(prop.valueDeclaration.name) {
									// Note that extraneous children (as in `<NoChild>extra</NoChild>`) don't pass this check,
									// since `children` is a SyntaxKind.PropertySignature instead of a SyntaxKind.JsxAttribute.
									errorNode = prop.valueDeclaration.name
								}
								propName := symbolToString(prop)
								suggestionSymbol := getSuggestedSymbolForNonexistentJSXAttribute(propName, errorTarget)
								var suggestion *string
								// TODO(TS-TO-GO): converted from conditional expression
								switch {
								case suggestionSymbol:
									suggestion = symbolToString(suggestionSymbol)
								default:
									suggestion = nil
								}
								if suggestion {
									reportError(Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(errorTarget), suggestion)
								} else {
									reportError(Diagnostics.Property_0_does_not_exist_on_type_1, propName, typeToString(errorTarget))
								}
							} else {
								// use the property's value declaration if the property is assigned inside the literal itself
								objectLiteralDeclaration := source.symbol. /* TODO(TS-TO-GO): was ? */ declarations && firstOrUndefined(source.symbol.declarations)
								var suggestion *string
								if prop.valueDeclaration && findAncestor(prop.valueDeclaration, func(d Node) bool {
									return d == objectLiteralDeclaration
								}) && getSourceFileOfNode(objectLiteralDeclaration) == getSourceFileOfNode(errorNode) {
									propDeclaration := prop.valueDeclaration /* as ObjectLiteralElementLike */
									Debug.assertNode(propDeclaration, isObjectLiteralElementLike)
									name := propDeclaration.name
									errorNode = name
									if isIdentifier(name) {
										suggestion = getSuggestionForNonexistentProperty(name, errorTarget)
									}
								}
								if suggestion != nil {
									reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2, symbolToString(prop), typeToString(errorTarget), suggestion)
								} else {
									reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(prop), typeToString(errorTarget))
								}
							}
						}
						return true
					}
					if checkTypes && !isRelatedTo(getTypeOfSymbol(prop), getTypeOfPropertyInTypes(checkTypes, prop.escapedName), RecursionFlagsBoth, reportErrors) {
						if reportErrors {
							reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(prop))
						}
						return true
					}
				}
			}
			return false
		}
		shouldCheckAsExcessProperty := func(prop Symbol, container Symbol) *bool {
			return prop.valueDeclaration && container.valueDeclaration && prop.valueDeclaration.parent == container.valueDeclaration
		}
		unionOrIntersectionRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			// Note that these checks are specifically ordered to produce correct results. In particular,
			// we need to deconstruct unions before intersections (because unions are always at the top),
			// and we need to handle "each" relations before "some" relations for the same kind of type.
			if source.flags & TypeFlagsUnion {
				if target.flags & TypeFlagsUnion {
					// Intersections of union types are normalized into unions of intersection types, and such normalized
					// unions can get very large and expensive to relate. The following fast path checks if the source union
					// originated in an intersection. If so, and if that intersection contains the target type, then we know
					// the result to be true (for any two types A and B, A & B is related to both A and B).
					sourceOrigin := (source /* as UnionType */).origin
					if sourceOrigin && sourceOrigin.flags&TypeFlagsIntersection && target.aliasSymbol && contains((sourceOrigin /* as IntersectionType */).types, target) {
						return TernaryTrue
					}
					// Similarly, in unions of unions the we preserve the original list of unions. This original list is often
					// much shorter than the normalized result, so we scan it in the following fast path.
					targetOrigin := (target /* as UnionType */).origin
					if targetOrigin && targetOrigin.flags&TypeFlagsUnion && source.aliasSymbol && contains((targetOrigin /* as UnionType */).types, source) {
						return TernaryTrue
					}
				}
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case relation == comparableRelation:
					return someTypeRelatedToType(source /* as UnionType */, target, reportErrors && !(source.flags&TypeFlagsPrimitive), intersectionState)
				default:
					return eachTypeRelatedToType(source /* as UnionType */, target, reportErrors && !(source.flags&TypeFlagsPrimitive), intersectionState)
				}
			}
			if target.flags & TypeFlagsUnion {
				return typeRelatedToSomeType(getRegularTypeOfObjectLiteral(source), target /* as UnionType */, reportErrors && !(source.flags&TypeFlagsPrimitive) && !(target.flags&TypeFlagsPrimitive), intersectionState)
			}
			if target.flags & TypeFlagsIntersection {
				return typeRelatedToEachType(source, target /* as IntersectionType */, reportErrors, IntersectionStateTarget)
			}
			// Source is an intersection. For the comparable relation, if the target is a primitive type we hoist the
			// constraints of all non-primitive types in the source into a new intersection. We do this because the
			// intersection may further constrain the constraints of the non-primitive types. For example, given a type
			// parameter 'T extends 1 | 2', the intersection 'T & 1' should be reduced to '1' such that it doesn't
			// appear to be comparable to '2'.
			if relation == comparableRelation && target.flags&TypeFlagsPrimitive {
				constraints := sameMap((source /* as IntersectionType */).types, func(t Type) Type {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case t.flags & TypeFlagsInstantiable:
						return getBaseConstraintOfType(t) || unknownType
					default:
						return t
					}
				})
				if constraints != (source /* as IntersectionType */).types {
					source = getIntersectionType(constraints)
					if source.flags & TypeFlagsNever {
						return TernaryFalse
					}
					if !(source.flags & TypeFlagsIntersection) {
						return isRelatedTo(source, target, RecursionFlagsSource /*reportErrors*/, false) || isRelatedTo(target, source, RecursionFlagsSource /*reportErrors*/, false)
					}
				}
			}
			// Check to see if any constituents of the intersection are immediately related to the target.
			// Don't report errors though. Elaborating on whether a source constituent is related to the target is
			// not actually useful and leads to some confusing error messages. Instead, we rely on the caller
			// checking whether the full intersection viewed as an object is related to the target.
			return someTypeRelatedToType(source /* as IntersectionType */, target /*reportErrors*/, false, IntersectionStateSource)
		}
		eachTypeRelatedToSomeType := func(source UnionOrIntersectionType, target UnionOrIntersectionType) Ternary {
			result := TernaryTrue
			sourceTypes := source.types
			for _, sourceType := range sourceTypes {
				related := typeRelatedToSomeType(sourceType, target /*reportErrors*/, false, IntersectionStateNone)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		typeRelatedToSomeType := func(source Type, target UnionOrIntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
			targetTypes := target.types
			if target.flags & TypeFlagsUnion {
				if containsType(targetTypes, source) {
					return TernaryTrue
				}
				if relation != comparableRelation && getObjectFlags(target)&ObjectFlagsPrimitiveUnion && !(source.flags & TypeFlagsEnumLiteral) && (source.flags&(TypeFlagsStringLiteral|TypeFlagsBooleanLiteral|TypeFlagsBigIntLiteral) || (relation == subtypeRelation || relation == strictSubtypeRelation) && source.flags&TypeFlagsNumberLiteral) {
					// When relating a literal type to a union of primitive types, we know the relation is false unless
					// the union contains the base primitive type or the literal type in one of its fresh/regular forms.
					// We exclude numeric literals for non-subtype relations because numeric literals are assignable to
					// numeric enum literals with the same value. Similarly, we exclude enum literal types because
					// identically named enum types are related (see isEnumTypeRelatedTo). We exclude the comparable
					// relation in entirety because it needs to be checked in both directions.
					var alternateForm FreshableType
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case source == (source /* as StringLiteralType */).regularType:
						alternateForm = (source /* as StringLiteralType */).freshType
					default:
						alternateForm = (source /* as StringLiteralType */).regularType
					}
					var primitive *IntrinsicType
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case source.flags & TypeFlagsStringLiteral:
						primitive = stringType
					case source.flags & TypeFlagsNumberLiteral:
						primitive = numberType
					case source.flags & TypeFlagsBigIntLiteral:
						primitive = bigintType
					default:
						primitive = nil
					}
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case primitive && containsType(targetTypes, primitive) || alternateForm && containsType(targetTypes, alternateForm):
						return TernaryTrue
					default:
						return TernaryFalse
					}
				}
				match := getMatchingUnionConstituentForType(target /* as UnionType */, source)
				if match {
					related := isRelatedTo(source, match, RecursionFlagsTarget /*reportErrors*/, false /*headMessage*/, nil, intersectionState)
					if related {
						return related
					}
				}
			}
			for _, type_ := range targetTypes {
				related := isRelatedTo(source, type_, RecursionFlagsTarget /*reportErrors*/, false /*headMessage*/, nil, intersectionState)
				if related {
					return related
				}
			}
			if reportErrors {
				// Elaborate only if we can find a best matching type in the target union
				bestMatchingType := getBestMatchingType(source, target, isRelatedTo)
				if bestMatchingType {
					isRelatedTo(source, bestMatchingType, RecursionFlagsTarget /*reportErrors*/, true /*headMessage*/, nil, intersectionState)
				}
			}
			return TernaryFalse
		}
		typeRelatedToEachType := func(source Type, target IntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := TernaryTrue
			targetTypes := target.types
			for _, targetType := range targetTypes {
				related := isRelatedTo(source, targetType, RecursionFlagsTarget, reportErrors /*headMessage*/, nil, intersectionState)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		someTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			sourceTypes := source.types
			if source.flags&TypeFlagsUnion && containsType(sourceTypes, target) {
				return TernaryTrue
			}
			len := sourceTypes.length
			for i := 0; i < len; i++ {
				related := isRelatedTo(sourceTypes[i], target, RecursionFlagsSource, reportErrors && i == len-1 /*headMessage*/, nil, intersectionState)
				if related {
					return related
				}
			}
			return TernaryFalse
		}
		getUndefinedStrippedTargetIfNeeded := func(source Type, target Type) Type {
			if source.flags&TypeFlagsUnion && target.flags&TypeFlagsUnion && !((source /* as UnionType */).types[0].flags & TypeFlagsUndefined) && (target /* as UnionType */).types[0].flags&TypeFlagsUndefined {
				return extractTypesOfKind(target, ~TypeFlagsUndefined)
			}
			return target
		}
		eachTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := TernaryTrue
			sourceTypes := source.types
			// We strip `undefined` from the target if the `source` trivially doesn't contain it for our correspondence-checking fastpath
			// since `undefined` is frequently added by optionality and would otherwise spoil a potentially useful correspondence
			undefinedStrippedTarget := getUndefinedStrippedTargetIfNeeded(source, target /* as UnionType */)
			for i := 0; i < sourceTypes.length; i++ {
				sourceType := sourceTypes[i]
				if undefinedStrippedTarget.flags&TypeFlagsUnion && sourceTypes.length >= (undefinedStrippedTarget /* as UnionType */).types.length && /* TODO(TS-TO-GO) Node BinaryExpression: sourceTypes.length % (undefinedStrippedTarget as UnionType).types.length */ TODO == 0 {
					// many unions are mappings of one another; in such cases, simply comparing members at the same index can shortcut the comparison
					// such unions will have identical lengths, and their corresponding elements will match up. Another common scenario is where a large
					// union has a union of objects intersected with it. In such cases, if the input was, eg `("a" | "b" | "c") & (string | boolean | {} | {whatever})`,
					// the result will have the structure `"a" | "b" | "c" | "a" & {} | "b" & {} | "c" & {} | "a" & {whatever} | "b" & {whatever} | "c" & {whatever}`
					// - the resulting union has a length which is a multiple of the original union, and the elements correspond modulo the length of the original union
					related := isRelatedTo(sourceType, (undefinedStrippedTarget /* as UnionType */).types[ /* TODO(TS-TO-GO) Node BinaryExpression: i % (undefinedStrippedTarget as UnionType).types.length */ TODO], RecursionFlagsBoth /*reportErrors*/, false /*headMessage*/, nil, intersectionState)
					if related {
						result &= related
						continue
					}
				}
				related := isRelatedTo(sourceType, target, RecursionFlagsSource, reportErrors /*headMessage*/, nil, intersectionState)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		typeArgumentsRelatedTo := func(sources []Type /*  = emptyArray */, targets []Type /*  = emptyArray */, variances []VarianceFlags /*  = emptyArray */, reportErrors bool, intersectionState IntersectionState) Ternary {
			if sources.length != targets.length && relation == identityRelation {
				return TernaryFalse
			}
			var length number
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case sources.length <= targets.length:
				length = sources.length
			default:
				length = targets.length
			}
			result := TernaryTrue
			for i := 0; i < length; i++ {
				// When variance information isn't available we default to covariance. This happens
				// in the process of computing variance information for recursive types and when
				// comparing 'this' type arguments.
				var varianceFlags VarianceFlags
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case i < variances.length:
					varianceFlags = variances[i]
				default:
					varianceFlags = VarianceFlagsCovariant
				}
				variance := varianceFlags & VarianceFlagsVarianceMask
				// We ignore arguments for independent type parameters (because they're never witnessed).
				if variance != VarianceFlagsIndependent {
					s := sources[i]
					t := targets[i]
					related := TernaryTrue
					if varianceFlags & VarianceFlagsUnmeasurable {
						// Even an `Unmeasurable` variance works out without a structural check if the source and target are _identical_.
						// We can't simply assume invariance, because `Unmeasurable` marks nonlinear relations, for example, a relation tained by
						// the `-?` modifier in a mapped type (where, no matter how the inputs are related, the outputs still might not be)
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case relation == identityRelation:
							related = isRelatedTo(s, t, RecursionFlagsBoth /*reportErrors*/, false)
						default:
							related = compareTypesIdentical(s, t)
						}
					} else if variance == VarianceFlagsCovariant {
						related = isRelatedTo(s, t, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
					} else if variance == VarianceFlagsContravariant {
						related = isRelatedTo(t, s, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
					} else if variance == VarianceFlagsBivariant {
						// In the bivariant case we first compare contravariantly without reporting
						// errors. Then, if that doesn't succeed, we compare covariantly with error
						// reporting. Thus, error elaboration will be based on the the covariant check,
						// which is generally easier to reason about.
						related = isRelatedTo(t, s, RecursionFlagsBoth /*reportErrors*/, false)
						if !related {
							related = isRelatedTo(s, t, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
						}
					} else {
						// In the invariant case we first compare covariantly, and only when that
						// succeeds do we proceed to compare contravariantly. Thus, error elaboration
						// will typically be based on the covariant check.
						related = isRelatedTo(s, t, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
						if related {
							related &= isRelatedTo(t, s, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
						}
					}
					if !related {
						return TernaryFalse
					}
					result &= related
				}
			}
			return result
		}
		// Determine if possibly recursive types are related. First, check if the result is already available in the global cache.
		// Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.
		// Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are
		// equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion
		// and issue an error. Otherwise, actually compare the structure of the two types.
		recursiveTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, recursionFlags RecursionFlags) Ternary {
			if overflow {
				return TernaryFalse
			}
			id := getRelationKey(source, target, intersectionState, relation /*ignoreConstraints*/, false)
			entry := relation.get(id)
			if entry != nil {
				if reportErrors && entry&RelationComparisonResultFailed && !(entry & RelationComparisonResultOverflow) {
					// We are elaborating errors and the cached result is a failure not due to a comparison overflow,
					// so we will do the comparison again to generate an error message.
				} else {
					if outofbandVarianceMarkerHandler {
						// We're in the middle of variance checking - integrate any unmeasurable/unreliable flags from this cached component
						saved := entry & RelationComparisonResultReportsMask
						if saved & RelationComparisonResultReportsUnmeasurable {
							instantiateType(source, reportUnmeasurableMapper)
						}
						if saved & RelationComparisonResultReportsUnreliable {
							instantiateType(source, reportUnreliableMapper)
						}
					}
					if reportErrors && entry&RelationComparisonResultOverflow {
						var message DiagnosticMessage
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case entry & RelationComparisonResultComplexityOverflow:
							message = Diagnostics.Excessive_complexity_comparing_types_0_and_1
						default:
							message = Diagnostics.Excessive_stack_depth_comparing_types_0_and_1
						}
						reportError(message, typeToString(source), typeToString(target))
						overrideNextErrorInfo++
					}
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case entry & RelationComparisonResultSucceeded:
						return TernaryTrue
					default:
						return TernaryFalse
					}
				}
			}
			if relationCount <= 0 {
				overflow = true
				return TernaryFalse
			}
			if !maybeKeys {
				maybeKeys = []never{}
				maybeKeysSet = NewSet()
				sourceStack = []never{}
				targetStack = []never{}
			} else {
				// If source and target are already being compared, consider them related with assumptions
				if maybeKeysSet.has(id) {
					return TernaryMaybe
				}
				// A key that starts with "*" is an indication that we have type references that reference constrained
				// type parameters. For such keys we also check against the key we would have gotten if all type parameters
				// were unconstrained.
				var broadestEquivalentId *string
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case id.startsWith("*"):
					broadestEquivalentId = getRelationKey(source, target, intersectionState, relation /*ignoreConstraints*/, true)
				default:
					broadestEquivalentId = nil
				}
				if broadestEquivalentId && maybeKeysSet.has(broadestEquivalentId) {
					return TernaryMaybe
				}
				if sourceDepth == 100 || targetDepth == 100 {
					overflow = true
					return TernaryFalse
				}
			}
			maybeStart := maybeCount
			maybeKeys[maybeCount] = id
			maybeKeysSet.add(id)
			maybeCount++
			saveExpandingFlags := expandingFlags
			if recursionFlags & RecursionFlagsSource {
				sourceStack[sourceDepth] = source
				sourceDepth++
				if !(expandingFlags & ExpandingFlagsSource) && isDeeplyNestedType(source, sourceStack, sourceDepth) {
					expandingFlags |= ExpandingFlagsSource
				}
			}
			if recursionFlags & RecursionFlagsTarget {
				targetStack[targetDepth] = target
				targetDepth++
				if !(expandingFlags & ExpandingFlagsTarget) && isDeeplyNestedType(target, targetStack, targetDepth) {
					expandingFlags |= ExpandingFlagsTarget
				}
			}
			var originalHandler /* TODO(TS-TO-GO) TypeNode TypeQuery: typeof outofbandVarianceMarkerHandler */ any
			propagatingVarianceFlags := 0 /* as RelationComparisonResult */
			if outofbandVarianceMarkerHandler {
				originalHandler = outofbandVarianceMarkerHandler
				outofbandVarianceMarkerHandler = func(onlyUnreliable bool) {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case onlyUnreliable:
						propagatingVarianceFlags |= RelationComparisonResultReportsUnreliable
					default:
						propagatingVarianceFlags |= RelationComparisonResultReportsUnmeasurable
					}
					return originalHandler(onlyUnreliable)
				}
			}
			var result Ternary
			if expandingFlags == ExpandingFlagsBoth {
				tracing. /* TODO(TS-TO-GO): was ? */ instant(tracing.Phase.CheckTypes, "recursiveTypeRelatedTo_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"sourceId": source.id,
					"sourceIdStack": sourceStack.map_(func(t Type) number {
						return t.id
					}),
					"targetId": target.id,
					"targetIdStack": targetStack.map_(func(t Type) number {
						return t.id
					}),
					"depth":       sourceDepth,
					"targetDepth": targetDepth,
				})
				result = TernaryMaybe
			} else {
				tracing. /* TODO(TS-TO-GO): was ? */ push(tracing.Phase.CheckTypes, "structuredTypeRelatedTo", map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"sourceId": source.id,
					"targetId": target.id,
				})
				result = structuredTypeRelatedTo(source, target, reportErrors, intersectionState)
				tracing. /* TODO(TS-TO-GO): was ? */ pop()
			}
			if outofbandVarianceMarkerHandler {
				outofbandVarianceMarkerHandler = originalHandler
			}
			if recursionFlags & RecursionFlagsSource {
				sourceDepth--
			}
			if recursionFlags & RecursionFlagsTarget {
				targetDepth--
			}
			expandingFlags = saveExpandingFlags
			if result {
				if result == TernaryTrue || (sourceDepth == 0 && targetDepth == 0) {
					if result == TernaryTrue || result == TernaryMaybe {
						// If result is definitely true, record all maybe keys as having succeeded. Also, record Ternary.Maybe
						// results as having succeeded once we reach depth 0, but never record Ternary.Unknown results.
						resetMaybeStack(true)
					} else {
						resetMaybeStack(false)
					}
				}
				// Note: it's intentional that we don't reset in the else case;
				// we leave them on the stack such that when we hit depth zero
				// above, we can report all of them as successful.
			} else {
				// A false result goes straight into global cache (when something is false under
				// assumptions it will also be false without assumptions)
				relation.set(id, RelationComparisonResultFailed|propagatingVarianceFlags)
				relationCount--
				resetMaybeStack(false)
			}
			return result
			resetMaybeStack := func(markAllAsSucceeded bool) {
				for i := maybeStart; i < maybeCount; i++ {
					maybeKeysSet.delete(maybeKeys[i])
					if markAllAsSucceeded {
						relation.set(maybeKeys[i], RelationComparisonResultSucceeded|propagatingVarianceFlags)
						relationCount--
					}
				}
				maybeCount = maybeStart
			}
		}
		structuredTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			saveErrorInfo := captureErrorCalculationState()
			result := structuredTypeRelatedToWorker(source, target, reportErrors, intersectionState, saveErrorInfo)
			if relation != identityRelation {
				// The combined constraint of an intersection type is the intersection of the constraints of
				// the constituents. When an intersection type contains instantiable types with union type
				// constraints, there are situations where we need to examine the combined constraint. One is
				// when the target is a union type. Another is when the intersection contains types belonging
				// to one of the disjoint domains. For example, given type variables T and U, each with the
				// constraint 'string | number', the combined constraint of 'T & U' is 'string | number' and
				// we need to check this constraint against a union on the target side. Also, given a type
				// variable V constrained to 'string | number', 'V & number' has a combined constraint of
				// 'string & number | number & number' which reduces to just 'number'.
				// This also handles type parameters, as a type parameter with a union constraint compared against a union
				// needs to have its constraint hoisted into an intersection with said type parameter, this way
				// the type param can be compared with itself in the target (with the influence of its constraint to match other parts)
				// For example, if `T extends 1 | 2` and `U extends 2 | 3` and we compare `T & U` to `T & U & (1 | 2 | 3)`
				if !result && (source.flags&TypeFlagsIntersection || source.flags&TypeFlagsTypeParameter && target.flags&TypeFlagsUnion) {
					constraint := getEffectiveConstraintOfIntersection(__COND__(source.flags&TypeFlagsIntersection, (source /* as IntersectionType */).types, []Type{source}), !!(target.flags & TypeFlagsUnion))
					if constraint && everyType(constraint, func(c Type) bool {
						return c != source
					}) {
						// TODO: Stack errors so we get a pyramid for the "normal" comparison above, _and_ a second for this
						result = isRelatedTo(constraint, target, RecursionFlagsSource /*reportErrors*/, false /*headMessage*/, nil, intersectionState)
					}
				}
				// When the target is an intersection we need an extra property check in order to detect nested excess
				// properties and nested weak types. The following are motivating examples that all should be errors, but
				// aren't without this extra property check:
				//
				//   let obj: { a: { x: string } } & { c: number } = { a: { x: 'hello', y: 2 }, c: 5 };  // Nested excess property
				//
				//   declare let wrong: { a: { y: string } };
				//   let weak: { a?: { x?: number } } & { c?: string } = wrong;  // Nested weak object type
				//
				if result && !(intersectionState & IntersectionStateTarget) && target.flags&TypeFlagsIntersection && !isGenericObjectType(target) && source.flags&(TypeFlagsObject|TypeFlagsIntersection) {
					result &= propertiesRelatedTo(source, target, reportErrors /*excludedProperties*/, nil /*optionalsOnly*/, false, IntersectionStateNone)
					if result && isObjectLiteralType(source) && getObjectFlags(source)&ObjectFlagsFreshLiteral {
						result &= indexSignaturesRelatedTo(source, target /*sourceIsPrimitive*/, false, reportErrors, IntersectionStateNone)
					}
				} else if result && isNonGenericObjectType(target) && !isArrayOrTupleType(target) && source.flags&TypeFlagsIntersection && getApparentType(source).flags&TypeFlagsStructuredType && !some((source /* as IntersectionType */).types, func(t Type) bool {
					return t == target || !!(getObjectFlags(t) & ObjectFlagsNonInferrableType)
				}) {
					result &= propertiesRelatedTo(source, target, reportErrors /*excludedProperties*/, nil /*optionalsOnly*/, true, intersectionState)
				}
			}
			if result {
				resetErrorInfo(saveErrorInfo)
			}
			return result
		}
		getApparentMappedTypeKeys := func(nameType Type, targetType MappedType) Type {
			modifiersType := getApparentType(getModifiersTypeFromMappedType(targetType))
			var mappedKeys []Type = []never{}
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, TypeFlagsStringOrNumberLiteralOrUnique, false, func(t Type) undefined {
				return mappedKeys.push(instantiateType(nameType, appendTypeMapping(targetType.mapper, getTypeParameterFromMappedType(targetType), t)))
			})
			return getUnionType(mappedKeys)
		}
		structuredTypeRelatedToWorker := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, saveErrorInfo ReturnType[ /* TODO(TS-TO-GO) TypeNode TypeQuery: typeof captureErrorCalculationState */ any]) Ternary {
			var result Ternary
			var originalErrorInfo *DiagnosticMessageChain
			varianceCheckFailed := false
			sourceFlags := source.flags
			targetFlags := target.flags
			if relation == identityRelation {
				// We've already checked that source.flags and target.flags are identical
				if sourceFlags & TypeFlagsUnionOrIntersection {
					result := eachTypeRelatedToSomeType(source /* as UnionOrIntersectionType */, target /* as UnionOrIntersectionType */)
					if result {
						result &= eachTypeRelatedToSomeType(target /* as UnionOrIntersectionType */, source /* as UnionOrIntersectionType */)
					}
					return result
				}
				if sourceFlags & TypeFlagsIndex {
					return isRelatedTo((source /* as IndexType */).type_, (target /* as IndexType */).type_, RecursionFlagsBoth /*reportErrors*/, false)
				}
				if sourceFlags & TypeFlagsIndexedAccess {
					if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						if /* TODO(TS-TO-GO) Node BinaryExpression: result &= isRelatedTo((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							return result
						}
					}
				}
				if sourceFlags & TypeFlagsConditional {
					if (source /* as ConditionalType */).root.isDistributive == (target /* as ConditionalType */).root.isDistributive {
						if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo((source as ConditionalType).checkType, (target as ConditionalType).checkType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							if /* TODO(TS-TO-GO) Node BinaryExpression: result &= isRelatedTo((source as ConditionalType).extendsType, (target as ConditionalType).extendsType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
								if /* TODO(TS-TO-GO) Node BinaryExpression: result &= isRelatedTo(getTrueTypeFromConditionalType(source as ConditionalType), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
									if /* TODO(TS-TO-GO) Node BinaryExpression: result &= isRelatedTo(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
										return result
									}
								}
							}
						}
					}
				}
				if sourceFlags & TypeFlagsSubstitution {
					if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo((source as SubstitutionType).baseType, (target as SubstitutionType).baseType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						if /* TODO(TS-TO-GO) Node BinaryExpression: result &= isRelatedTo((source as SubstitutionType).constraint, (target as SubstitutionType).constraint, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							return result
						}
					}
				}
				if !(sourceFlags & TypeFlagsObject) {
					return TernaryFalse
				}
			} else if sourceFlags&TypeFlagsUnionOrIntersection || targetFlags&TypeFlagsUnionOrIntersection {
				if /* TODO(TS-TO-GO) Node BinaryExpression: result = unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) */ TODO {
					return result
				}
				// The ordered decomposition above doesn't handle all cases. Specifically, we also need to handle:
				// Source is instantiable (e.g. source has union or intersection constraint).
				// Source is an object, target is a union (e.g. { a, b: boolean } <=> { a, b: true } | { a, b: false }).
				// Source is an intersection, target is an object (e.g. { a } & { b } <=> { a, b }).
				// Source is an intersection, target is a union (e.g. { a } & { b: boolean } <=> { a, b: true } | { a, b: false }).
				// Source is an intersection, target instantiable (e.g. string & { tag } <=> T["a"] constrained to string & { tag }).
				if !(sourceFlags&TypeFlagsInstantiable || sourceFlags&TypeFlagsObject && targetFlags&TypeFlagsUnion || sourceFlags&TypeFlagsIntersection && targetFlags&(TypeFlagsObject|TypeFlagsUnion|TypeFlagsInstantiable)) {
					return TernaryFalse
				}
			}
			// We limit alias variance probing to only object and conditional types since their alias behavior
			// is more predictable than other, interned types, which may or may not have an alias depending on
			// the order in which things were checked.
			if sourceFlags&(TypeFlagsObject|TypeFlagsConditional) && source.aliasSymbol && source.aliasTypeArguments && source.aliasSymbol == target.aliasSymbol && !(isMarkerType(source) || isMarkerType(target)) {
				variances := getAliasVariances(source.aliasSymbol)
				if variances == emptyArray {
					return TernaryUnknown
				}
				params := getSymbolLinks(source.aliasSymbol).typeParameters
				minParams := getMinTypeArgumentCount(params)
				sourceTypes := fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
				targetTypes := fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
				varianceResult := relateVariances(sourceTypes, targetTypes, variances, intersectionState)
				if varianceResult != nil {
					return varianceResult
				}
			}
			// For a generic type T and a type U that is assignable to T, [...U] is assignable to T, U is assignable to readonly [...T],
			// and U is assignable to [...T] when U is constrained to a mutable array or tuple type.
			if isSingleElementGenericTupleType(source) && !source.target.readonly && ( /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(getTypeArguments(source)[0], target, RecursionFlags.Source) */ TODO) || isSingleElementGenericTupleType(target) && (target.target.readonly || isMutableArrayOrTuple(getBaseConstraintOfType(source) || source)) && ( /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(source, getTypeArguments(target)[0], RecursionFlags.Target) */ TODO) {
				return result
			}
			if targetFlags & TypeFlagsTypeParameter {
				// A source type { [P in Q]: X } is related to a target type T if keyof T is related to Q and X is related to T[Q].
				if getObjectFlags(source)&ObjectFlagsMapped && !(source /* as MappedType */).declaration.nameType && isRelatedTo(getIndexType(target), getConstraintTypeFromMappedType(source /* as MappedType */), RecursionFlagsBoth) {
					if !(getMappedTypeModifiers(source /* as MappedType */) & MappedTypeModifiersIncludeOptional) {
						templateType := getTemplateTypeFromMappedType(source /* as MappedType */)
						indexedAccessType := getIndexedAccessType(target, getTypeParameterFromMappedType(source /* as MappedType */))
						if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(templateType, indexedAccessType, RecursionFlags.Both, reportErrors) */ TODO {
							return result
						}
					}
				}
				if relation == comparableRelation && sourceFlags&TypeFlagsTypeParameter {
					// This is a carve-out in comparability to essentially forbid comparing a type parameter
					// with another type parameter unless one extends the other. (Remember: comparability is mostly bidirectional!)
					constraint := getConstraintOfTypeParameter(source)
					if constraint {
						for constraint && someType(constraint, func(c Type) bool {
							return !!(c.flags & TypeFlagsTypeParameter)
						}) {
							if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false) */ TODO {
								return result
							}
							constraint = getConstraintOfTypeParameter(constraint)
						}
					}
					return TernaryFalse
				}
			} else if targetFlags & TypeFlagsIndex {
				targetType := (target /* as IndexType */).type_
				// A keyof S is related to a keyof T if T is related to S.
				if sourceFlags & TypeFlagsIndex {
					if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(targetType, (source as IndexType).type, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						return result
					}
				}
				if isTupleType(targetType) {
					// An index type can have a tuple type target when the tuple type contains variadic elements.
					// Check if the source is related to the known keys of the tuple type.
					if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(source, getKnownKeysOfTupleType(targetType), RecursionFlags.Target, reportErrors) */ TODO {
						return result
					}
				} else {
					// A type S is assignable to keyof T if S is assignable to keyof C, where C is the
					// simplified form of T or, if T doesn't simplify, the constraint of T.
					constraint := getSimplifiedTypeOrConstraint(targetType)
					if constraint {
						// We require Ternary.True here such that circular constraints don't cause
						// false positives. For example, given 'T extends { [K in keyof T]: string }',
						// 'keyof T' has itself as its constraint and produces a Ternary.Maybe when
						// related to other types.
						if isRelatedTo(source, getIndexType(constraint, (target /* as IndexType */).indexFlags|IndexFlagsNoReducibleCheck), RecursionFlagsTarget, reportErrors) == TernaryTrue {
							return TernaryTrue
						}
					} else if isGenericMappedType(targetType) {
						// generic mapped types that don't simplify or have a constraint still have a very simple set of keys we can compare against
						// - their nameType or constraintType.
						// In many ways, this comparison is a deferred version of what `getIndexTypeForMappedType` does to actually resolve the keys for _non_-generic types
						nameType := getNameTypeFromMappedType(targetType)
						constraintType := getConstraintTypeFromMappedType(targetType)
						var targetKeys TODO
						if nameType && isMappedTypeWithKeyofConstraintDeclaration(targetType) {
							// we need to get the apparent mappings and union them with the generic mappings, since some properties may be
							// missing from the `constraintType` which will otherwise be mapped in the object
							mappedKeys := getApparentMappedTypeKeys(nameType, targetType)
							// We still need to include the non-apparent (and thus still generic) keys in the target side of the comparison (in case they're in the source side)
							targetKeys = getUnionType([]Type{mappedKeys, nameType})
						} else {
							targetKeys = nameType || constraintType
						}
						if isRelatedTo(source, targetKeys, RecursionFlagsTarget, reportErrors) == TernaryTrue {
							return TernaryTrue
						}
					}
				}
			} else if targetFlags & TypeFlagsIndexedAccess {
				if sourceFlags & TypeFlagsIndexedAccess {
					// Relate components directly before falling back to constraint relationships
					// A type S[K] is related to a type T[J] if S is related to T and K is related to J.
					if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, reportErrors) */ TODO {
						result &= isRelatedTo((source /* as IndexedAccessType */).indexType, (target /* as IndexedAccessType */).indexType, RecursionFlagsBoth, reportErrors)
					}
					if result {
						return result
					}
					if reportErrors {
						originalErrorInfo = errorInfo
					}
				}
				// A type S is related to a type T[K] if S is related to C, where C is the base
				// constraint of T[K] for writing.
				if relation == assignableRelation || relation == comparableRelation {
					objectType := (target /* as IndexedAccessType */).objectType
					indexType := (target /* as IndexedAccessType */).indexType
					baseObjectType := getBaseConstraintOfType(objectType) || objectType
					baseIndexType := getBaseConstraintOfType(indexType) || indexType
					if !isGenericObjectType(baseObjectType) && !isGenericIndexType(baseIndexType) {
						accessFlags := AccessFlagsWriting | (__COND__(baseObjectType != objectType, AccessFlagsNoIndexSignatures, 0))
						constraint := getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, accessFlags)
						if constraint {
							if reportErrors && originalErrorInfo {
								// create a new chain for the constraint error
								resetErrorInfo(saveErrorInfo)
							}
							if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(source, constraint, RecursionFlags.Target, reportErrors, /*headMessage* / undefined, intersectionState) */ TODO {
								return result
							}
							// prefer the shorter chain of the constraint comparison chain, and the direct comparison chain
							if reportErrors && originalErrorInfo && errorInfo {
								// TODO(TS-TO-GO): converted from conditional expression
								switch {
								case countMessageChainBreadth([]DiagnosticMessageChain{originalErrorInfo}) <= countMessageChainBreadth([]DiagnosticMessageChain{errorInfo}):
									errorInfo = originalErrorInfo
								default:
									errorInfo = errorInfo
								}
							}
						}
					}
				}
				if reportErrors {
					originalErrorInfo = nil
				}
			} else if isGenericMappedType(target) && relation != identityRelation {
				// Check if source type `S` is related to target type `{ [P in Q]: T }` or `{ [P in Q as R]: T}`.
				keysRemapped := !!target.declaration.nameType
				templateType := getTemplateTypeFromMappedType(target)
				modifiers := getMappedTypeModifiers(target)
				if !(modifiers & MappedTypeModifiersExcludeOptional) {
					// If the mapped type has shape `{ [P in Q]: T[P] }`,
					// source `S` is related to target if `T` = `S`, i.e. `S` is related to `{ [P in Q]: S[P] }`.
					if !keysRemapped && templateType.flags&TypeFlagsIndexedAccess && (templateType /* as IndexedAccessType */).objectType == source && (templateType /* as IndexedAccessType */).indexType == getTypeParameterFromMappedType(target) {
						return TernaryTrue
					}
					if !isGenericMappedType(source) {
						// If target has shape `{ [P in Q as R]: T}`, then its keys have type `R`.
						// If target has shape `{ [P in Q]: T }`, then its keys have type `Q`.
						var targetKeys Type
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case keysRemapped:
							targetKeys = getNameTypeFromMappedType(target)
						default:
							targetKeys = getConstraintTypeFromMappedType(target)
						}
						// Type of the keys of source type `S`, i.e. `keyof S`.
						sourceKeys := getIndexType(source, IndexFlagsNoIndexSignatures)
						includeOptional := modifiers & MappedTypeModifiersIncludeOptional
						var filteredByApplicability Type
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case includeOptional:
							filteredByApplicability = intersectTypes(targetKeys, sourceKeys)
						default:
							filteredByApplicability = nil
						}
						// A source type `S` is related to a target type `{ [P in Q]: T }` if `Q` is related to `keyof S` and `S[Q]` is related to `T`.
						// A source type `S` is related to a target type `{ [P in Q as R]: T }` if `R` is related to `keyof S` and `S[R]` is related to `T.
						// A source type `S` is related to a target type `{ [P in Q]?: T }` if some constituent `Q'` of `Q` is related to `keyof S` and `S[Q']` is related to `T`.
						// A source type `S` is related to a target type `{ [P in Q as R]?: T }` if some constituent `R'` of `R` is related to `keyof S` and `S[R']` is related to `T`.
						if __COND__(includeOptional, !(filteredByApplicability.flags & TypeFlagsNever), isRelatedTo(targetKeys, sourceKeys, RecursionFlagsBoth)) {
							templateType := getTemplateTypeFromMappedType(target)
							typeParameter := getTypeParameterFromMappedType(target)
							// Fastpath: When the template type has the form `Obj[P]` where `P` is the mapped type parameter, directly compare source `S` with `Obj`
							// to avoid creating the (potentially very large) number of new intermediate types made by manufacturing `S[P]`.
							nonNullComponent := extractTypesOfKind(templateType, ~TypeFlagsNullable)
							if !keysRemapped && nonNullComponent.flags&TypeFlagsIndexedAccess && (nonNullComponent /* as IndexedAccessType */).indexType == typeParameter {
								if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(source, (nonNullComponent as IndexedAccessType).objectType, RecursionFlags.Target, reportErrors) */ TODO {
									return result
								}
							} else {
								// We need to compare the type of a property on the source type `S` to the type of the same property on the target type,
								// so we need to construct an indexing type representing a property, and then use indexing type to index the source type for comparison.
								// If the target type has shape `{ [P in Q]: T }`, then a property of the target has type `P`.
								// If the target type has shape `{ [P in Q]?: T }`, then a property of the target has type `P`,
								// but the property is optional, so we only want to compare properties `P` that are common between `keyof S` and `Q`.
								// If the target type has shape `{ [P in Q as R]: T }`, then a property of the target has type `R`.
								// If the target type has shape `{ [P in Q as R]?: T }`, then a property of the target has type `R`,
								// but the property is optional, so we only want to compare properties `R` that are common between `keyof S` and `R`.
								var indexingType Type
								// TODO(TS-TO-GO): converted from conditional expression
								switch {
								case keysRemapped:
									indexingType = (filteredByApplicability || targetKeys)
								case filteredByApplicability:
									indexingType = getIntersectionType([]Type{filteredByApplicability, typeParameter})
								default:
									indexingType = typeParameter
								}
								indexedAccessType := getIndexedAccessType(source, indexingType)
								// Compare `S[indexingType]` to `T`, where `T` is the type of a property of the target type.
								if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(indexedAccessType, templateType, RecursionFlags.Both, reportErrors) */ TODO {
									return result
								}
							}
						}
						originalErrorInfo = errorInfo
						resetErrorInfo(saveErrorInfo)
					}
				}
			} else if targetFlags & TypeFlagsConditional {
				// If we reach 10 levels of nesting for the same conditional type, assume it is an infinitely expanding recursive
				// conditional type and bail out with a Ternary.Maybe result.
				if isDeeplyNestedType(target, targetStack, targetDepth, 10) {
					return TernaryMaybe
				}
				c := target /* as ConditionalType */
				// We check for a relationship to a conditional type target only when the conditional type has no
				// 'infer' positions, is not distributive or is distributive but doesn't reference the check type
				// parameter in either of the result types, and the source isn't an instantiation of the same
				// conditional type (as happens when computing variance).
				if !c.root.inferTypeParameters && !isDistributionDependent(c.root) && !(source.flags&TypeFlagsConditional && (source /* as ConditionalType */).root == c.root) {
					// Check if the conditional is always true or always false but still deferred for distribution purposes.
					skipTrue := !isTypeAssignableTo(getPermissiveInstantiation(c.checkType), getPermissiveInstantiation(c.extendsType))
					skipFalse := !skipTrue && isTypeAssignableTo(getRestrictiveInstantiation(c.checkType), getRestrictiveInstantiation(c.extendsType))
					// TODO: Find a nice way to include potential conditional type breakdowns in error output, if they seem good (they usually don't)
					if /* TODO(TS-TO-GO) Node BinaryExpression: result = skipTrue ? Ternary.True : isRelatedTo(source, getTrueTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case skipFalse:
							result &= TernaryTrue
						default:
							result &= isRelatedTo(source, getFalseTypeFromConditionalType(c), RecursionFlagsTarget /*reportErrors*/, false /*headMessage*/, nil, intersectionState)
						}
						if result {
							return result
						}
					}
				}
			} else if targetFlags & TypeFlagsTemplateLiteral {
				if sourceFlags & TypeFlagsTemplateLiteral {
					if relation == comparableRelation {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case templateLiteralTypesDefinitelyUnrelated(source /* as TemplateLiteralType */, target /* as TemplateLiteralType */):
							return TernaryFalse
						default:
							return TernaryTrue
						}
					}
					// Report unreliable variance for type variables referenced in template literal type placeholders.
					// For example, `foo-${number}` is related to `foo-${string}` even though number isn't related to string.
					instantiateType(source, reportUnreliableMapper)
				}
				if isTypeMatchedByTemplateLiteralType(source, target /* as TemplateLiteralType */) {
					return TernaryTrue
				}
			} else if target.flags & TypeFlagsStringMapping {
				if !(source.flags & TypeFlagsStringMapping) {
					if isMemberOfStringMapping(source, target) {
						return TernaryTrue
					}
				}
			}
			if sourceFlags & TypeFlagsTypeVariable {
				// IndexedAccess comparisons are handled above in the `targetFlags & TypeFlage.IndexedAccess` branch
				if !(sourceFlags&TypeFlagsIndexedAccess && targetFlags&TypeFlagsIndexedAccess) {
					constraint := getConstraintOfType(source /* as TypeVariable */) || unknownType
					// hi-speed no-this-instantiation check (less accurate, but avoids costly `this`-instantiation when the constraint will suffice), see #28231 for report on why this is needed
					if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
						return result
					} else if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(getTypeWithThisArgument(constraint, source), target, RecursionFlags.Source, reportErrors && constraint !== unknownType && !(targetFlags & sourceFlags & TypeFlags.TypeParameter), /*headMessage* / undefined, intersectionState) */ TODO {
						return result
					}
					if isMappedTypeGenericIndexedAccess(source) {
						// For an indexed access type { [P in K]: E}[X], above we have already explored an instantiation of E with X
						// substituted for P. We also want to explore type { [P in K]: E }[C], where C is the constraint of X.
						indexConstraint := getConstraintOfType((source /* as IndexedAccessType */).indexType)
						if indexConstraint {
							if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(getIndexedAccessType((source as IndexedAccessType).objectType, indexConstraint), target, RecursionFlags.Source, reportErrors) */ TODO {
								return result
							}
						}
					}
				}
			} else if sourceFlags & TypeFlagsIndex {
				isDeferredMappedIndex := shouldDeferIndexType((source /* as IndexType */).type_, (source /* as IndexType */).indexFlags) && getObjectFlags((source /* as IndexType */).type_)&ObjectFlagsMapped
				if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(stringNumberSymbolType, target, RecursionFlags.Source, reportErrors && !isDeferredMappedIndex) */ TODO {
					return result
				}
				if isDeferredMappedIndex {
					mappedType := (source /* as IndexType */).type_ /* as MappedType */
					nameType := getNameTypeFromMappedType(mappedType)
					// Unlike on the target side, on the source side we do *not* include the generic part of the `nameType`, since that comes from a
					// (potentially anonymous) mapped type local type parameter, so that'd never assign outside the mapped type body, but we still want to
					// allow assignments of index types of identical (or similar enough) mapped types.
					// eg, `keyof {[X in keyof A]: Obj[X]}` should be assignable to `keyof {[Y in keyof A]: Tup[Y]}` because both map over the same set of keys (`keyof A`).
					// Without this source-side breakdown, a `keyof {[X in keyof A]: Obj[X]}` style type won't be assignable to anything except itself, which is much too strict.
					var sourceMappedKeys Type
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case nameType && isMappedTypeWithKeyofConstraintDeclaration(mappedType):
						sourceMappedKeys = getApparentMappedTypeKeys(nameType, mappedType)
					default:
						sourceMappedKeys = (nameType || getConstraintTypeFromMappedType(mappedType))
					}
					if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(sourceMappedKeys, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
			} else if sourceFlags&TypeFlagsTemplateLiteral && !(targetFlags & TypeFlagsObject) {
				if !(targetFlags & TypeFlagsTemplateLiteral) {
					constraint := getBaseConstraintOfType(source)
					if constraint && constraint != source && ( /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors) */ TODO) {
						return result
					}
				}
			} else if sourceFlags & TypeFlagsStringMapping {
				if targetFlags & TypeFlagsStringMapping {
					if (source /* as StringMappingType */).symbol != (target /* as StringMappingType */).symbol {
						return TernaryFalse
					}
					if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo((source as StringMappingType).type, (target as StringMappingType).type, RecursionFlags.Both, reportErrors) */ TODO {
						return result
					}
				} else {
					constraint := getBaseConstraintOfType(source)
					if constraint && ( /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors) */ TODO) {
						return result
					}
				}
			} else if sourceFlags & TypeFlagsConditional {
				// If we reach 10 levels of nesting for the same conditional type, assume it is an infinitely expanding recursive
				// conditional type and bail out with a Ternary.Maybe result.
				if isDeeplyNestedType(source, sourceStack, sourceDepth, 10) {
					return TernaryMaybe
				}
				if targetFlags & TypeFlagsConditional {
					// Two conditional types 'T1 extends U1 ? X1 : Y1' and 'T2 extends U2 ? X2 : Y2' are related if
					// one of T1 and T2 is related to the other, U1 and U2 are identical types, X1 is related to X2,
					// and Y1 is related to Y2.
					sourceParams := (source /* as ConditionalType */).root.inferTypeParameters
					sourceExtends := (source /* as ConditionalType */).extendsType
					var mapper *TypeMapper
					if sourceParams {
						// If the source has infer type parameters, we instantiate them in the context of the target
						ctx := createInferenceContext(sourceParams /*signature*/, nil, InferenceFlagsNone, isRelatedToWorker)
						inferTypes(ctx.inferences, (target /* as ConditionalType */).extendsType, sourceExtends, InferencePriorityNoConstraints|InferencePriorityAlwaysStrict)
						sourceExtends = instantiateType(sourceExtends, ctx.mapper)
						mapper = ctx.mapper
					}
					if isTypeIdenticalTo(sourceExtends, (target /* as ConditionalType */).extendsType) && (isRelatedTo((source /* as ConditionalType */).checkType, (target /* as ConditionalType */).checkType, RecursionFlagsBoth) || isRelatedTo((target /* as ConditionalType */).checkType, (source /* as ConditionalType */).checkType, RecursionFlagsBoth)) {
						if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(instantiateType(getTrueTypeFromConditionalType(source as ConditionalType), mapper), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, reportErrors) */ TODO {
							result &= isRelatedTo(getFalseTypeFromConditionalType(source /* as ConditionalType */), getFalseTypeFromConditionalType(target /* as ConditionalType */), RecursionFlagsBoth, reportErrors)
						}
						if result {
							return result
						}
					}
				}
				// conditionals can be related to one another via normal constraint, as, eg, `A extends B ? O : never` should be assignable to `O`
				// when `O` is a conditional (`never` is trivially assignable to `O`, as is `O`!).
				defaultConstraint := getDefaultConstraintOfConditionalType(source /* as ConditionalType */)
				if defaultConstraint {
					if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(defaultConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
				// conditionals aren't related to one another via distributive constraint as it is much too inaccurate and allows way
				// more assignments than are desirable (since it maps the source check type to its constraint, it loses information).
				var distributiveConstraint Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case !(targetFlags & TypeFlagsConditional) && hasNonCircularBaseConstraint(source):
					distributiveConstraint = getConstraintOfDistributiveConditionalType(source /* as ConditionalType */)
				default:
					distributiveConstraint = nil
				}
				if distributiveConstraint {
					resetErrorInfo(saveErrorInfo)
					if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(distributiveConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
			} else {
				// An empty object type is related to any mapped type that includes a '?' modifier.
				if relation != subtypeRelation && relation != strictSubtypeRelation && isPartialMappedType(target) && isEmptyObjectType(source) {
					return TernaryTrue
				}
				if isGenericMappedType(target) {
					if isGenericMappedType(source) {
						if /* TODO(TS-TO-GO) Node BinaryExpression: result = mappedTypeRelatedTo(source, target, reportErrors) */ TODO {
							return result
						}
					}
					return TernaryFalse
				}
				sourceIsPrimitive := !!(sourceFlags & TypeFlagsPrimitive)
				if relation != identityRelation {
					source = getApparentType(source)
					sourceFlags = source.flags
				} else if isGenericMappedType(source) {
					return TernaryFalse
				}
				if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && (source /* as TypeReference */).target == (target /* as TypeReference */).target && !isTupleType(source) && !(isMarkerType(source) || isMarkerType(target)) {
					// When strictNullChecks is disabled, the element type of the empty array literal is undefinedWideningType,
					// and an empty array literal wouldn't be assignable to a `never[]` without this check.
					if isEmptyArrayLiteralType(source) {
						return TernaryTrue
					}
					// We have type references to the same generic type, and the type references are not marker
					// type references (which are intended by be compared structurally). Obtain the variance
					// information for the type parameters and relate the type arguments accordingly.
					variances := getVariances((source /* as TypeReference */).target)
					// We return Ternary.Maybe for a recursive invocation of getVariances (signalled by emptyArray). This
					// effectively means we measure variance only from type parameter occurrences that aren't nested in
					// recursive instantiations of the generic type.
					if variances == emptyArray {
						return TernaryUnknown
					}
					varianceResult := relateVariances(getTypeArguments(source /* as TypeReference */), getTypeArguments(target /* as TypeReference */), variances, intersectionState)
					if varianceResult != nil {
						return varianceResult
					}
				} else if __COND__(isReadonlyArrayType(target), everyType(source, isArrayOrTupleType), isArrayType(target) && everyType(source, func(t Type) bool {
					return isTupleType(t) && !t.target.readonly
				})) {
					if relation != identityRelation {
						return isRelatedTo(getIndexTypeOfType(source, numberType) || anyType, getIndexTypeOfType(target, numberType) || anyType, RecursionFlagsBoth, reportErrors)
					} else {
						// By flags alone, we know that the `target` is a readonly array while the source is a normal array or tuple
						// or `target` is an array and source is a tuple - in both cases the types cannot be identical, by construction
						return TernaryFalse
					}
				} else if isGenericTupleType(source) && isTupleType(target) && !isGenericTupleType(target) {
					constraint := getBaseConstraintOrType(source)
					if constraint != source {
						return isRelatedTo(constraint, target, RecursionFlagsSource, reportErrors)
					}
				} else if (relation == subtypeRelation || relation == strictSubtypeRelation) && isEmptyObjectType(target) && getObjectFlags(target)&ObjectFlagsFreshLiteral && !isEmptyObjectType(source) {
					return TernaryFalse
				}
				// Even if relationship doesn't hold for unions, intersections, or generic type references,
				// it may hold in a structural comparison.
				// In a check of the form X = A & B, we will have previously checked if A relates to X or B relates
				// to X. Failing both of those we want to check if the aggregation of A and B's members structurally
				// relates to X. Thus, we include intersection types on the source side here.
				if sourceFlags&(TypeFlagsObject|TypeFlagsIntersection) && targetFlags&TypeFlagsObject {
					// Report structural errors only if we haven't reported any errors yet
					reportStructuralErrors := reportErrors && errorInfo == saveErrorInfo.errorInfo && !sourceIsPrimitive
					result = propertiesRelatedTo(source, target, reportStructuralErrors /*excludedProperties*/, nil /*optionalsOnly*/, false, intersectionState)
					if result {
						result &= signaturesRelatedTo(source, target, SignatureKindCall, reportStructuralErrors, intersectionState)
						if result {
							result &= signaturesRelatedTo(source, target, SignatureKindConstruct, reportStructuralErrors, intersectionState)
							if result {
								result &= indexSignaturesRelatedTo(source, target, sourceIsPrimitive, reportStructuralErrors, intersectionState)
							}
						}
					}
					if varianceCheckFailed && result {
						errorInfo = originalErrorInfo || errorInfo || saveErrorInfo.errorInfo
						// Use variance error (there is no structural one) and return false
					} else if result {
						return result
					}
				}
				// If S is an object type and T is a discriminated union, S may be related to T if
				// there exists a constituent of T for every combination of the discriminants of S
				// with respect to T. We do not report errors here, as we will use the existing
				// error result from checking each constituent of the union.
				if sourceFlags&(TypeFlagsObject|TypeFlagsIntersection) && targetFlags&TypeFlagsUnion {
					objectOnlyTarget := extractTypesOfKind(target, TypeFlagsObject|TypeFlagsIntersection|TypeFlagsSubstitution)
					if objectOnlyTarget.flags & TypeFlagsUnion {
						result := typeRelatedToDiscriminatedType(source, objectOnlyTarget /* as UnionType */)
						if result {
							return result
						}
					}
				}
			}
			return TernaryFalse
			countMessageChainBreadth := func(info *[]DiagnosticMessageChain) number {
				if !info {
					return 0
				}
				return reduceLeft(info, func(value number, chain DiagnosticMessageChain) number {
					return value + 1 + countMessageChainBreadth(chain.next)
				}, 0)
			}
			relateVariances := func(sourceTypeArguments *[]Type, targetTypeArguments *[]Type, variances []VarianceFlags, intersectionState IntersectionState) *Ternary {
				if /* TODO(TS-TO-GO) Node BinaryExpression: result = typeArgumentsRelatedTo(sourceTypeArguments, targetTypeArguments, variances, reportErrors, intersectionState) */ TODO {
					return result
				}
				if some(variances, func(v VarianceFlags) bool {
					return !!(v & VarianceFlagsAllowsStructuralFallback)
				}) {
					// If some type parameter was `Unmeasurable` or `Unreliable`, and we couldn't pass by assuming it was identical, then we
					// have to allow a structural fallback check
					// We elide the variance-based error elaborations, since those might not be too helpful, since we'll potentially
					// be assuming identity of the type parameter.
					originalErrorInfo = nil
					resetErrorInfo(saveErrorInfo)
					return nil
				}
				allowStructuralFallback := targetTypeArguments && hasCovariantVoidArgument(targetTypeArguments, variances)
				varianceCheckFailed = !allowStructuralFallback
				// The type arguments did not relate appropriately, but it may be because we have no variance
				// information (in which case typeArgumentsRelatedTo defaulted to covariance for all type
				// arguments). It might also be the case that the target type has a 'void' type argument for
				// a covariant type parameter that is only used in return positions within the generic type
				// (in which case any type argument is permitted on the source side). In those cases we proceed
				// with a structural comparison. Otherwise, we know for certain the instantiations aren't
				// related and we can return here.
				if variances != emptyArray && !allowStructuralFallback {
					// In some cases generic types that are covariant in regular type checking mode become
					// invariant in --strictFunctionTypes mode because one or more type parameters are used in
					// both co- and contravariant positions. In order to make it easier to diagnose *why* such
					// types are invariant, if any of the type parameters are invariant we reset the reported
					// errors and instead force a structural comparison (which will include elaborations that
					// reveal the reason).
					// We can switch on `reportErrors` here, since varianceCheckFailed guarantees we return `False`,
					// we can return `False` early here to skip calculating the structural error message we don't need.
					if varianceCheckFailed && !(reportErrors && some(variances, func(v VarianceFlags) bool {
						return (v & VarianceFlagsVarianceMask) == VarianceFlagsInvariant
					})) {
						return TernaryFalse
					}
					// We remember the original error information so we can restore it in case the structural
					// comparison unexpectedly succeeds. This can happen when the structural comparison result
					// is a Ternary.Maybe for example caused by the recursion depth limiter.
					originalErrorInfo = errorInfo
					resetErrorInfo(saveErrorInfo)
				}
			}
		}
		// A type [P in S]: X is related to a type [Q in T]: Y if T is related to S and X' is
		// related to Y, where X' is an instantiation of X in which P is replaced with Q. Notice
		// that S and T are contra-variant whereas X and Y are co-variant.
		mappedTypeRelatedTo := func(source MappedType, target MappedType, reportErrors bool) Ternary {
			modifiersRelated := relation == comparableRelation || (__COND__(relation == identityRelation, getMappedTypeModifiers(source) == getMappedTypeModifiers(target), getCombinedMappedTypeOptionality(source) <= getCombinedMappedTypeOptionality(target)))
			if modifiersRelated {
				var result Ternary
				targetConstraint := getConstraintTypeFromMappedType(target)
				sourceConstraint := instantiateType(getConstraintTypeFromMappedType(source), __COND__(getCombinedMappedTypeOptionality(source) < 0, reportUnmeasurableMapper, reportUnreliableMapper))
				if /* TODO(TS-TO-GO) Node BinaryExpression: result = isRelatedTo(targetConstraint, sourceConstraint, RecursionFlags.Both, reportErrors) */ TODO {
					mapper := createTypeMapper([]TypeParameter{getTypeParameterFromMappedType(source)}, []TypeParameter{getTypeParameterFromMappedType(target)})
					if instantiateType(getNameTypeFromMappedType(source), mapper) == instantiateType(getNameTypeFromMappedType(target), mapper) {
						return result & isRelatedTo(instantiateType(getTemplateTypeFromMappedType(source), mapper), getTemplateTypeFromMappedType(target), RecursionFlagsBoth, reportErrors)
					}
				}
			}
			return TernaryFalse
		}
		typeRelatedToDiscriminatedType := func(source Type, target UnionType) Ternary {
			// 1. Generate the combinations of discriminant properties & types 'source' can satisfy.
			//    a. If the number of combinations is above a set limit, the comparison is too complex.
			// 2. Filter 'target' to the subset of types whose discriminants exist in the matrix.
			//    a. If 'target' does not satisfy all discriminants in the matrix, 'source' is not related.
			// 3. For each type in the filtered 'target', determine if all non-discriminant properties of
			//    'target' are related to a property in 'source'.
			//
			// NOTE: See ~/tests/cases/conformance/types/typeRelationships/assignmentCompatibility/assignmentCompatWithDiscriminatedUnion.ts
			//       for examples.
			sourceProperties := getPropertiesOfType(source)
			sourcePropertiesFiltered := findDiscriminantProperties(sourceProperties, target)
			if !sourcePropertiesFiltered {
				return TernaryFalse
			}
			// Though we could compute the number of combinations as we generate
			// the matrix, this would incur additional memory overhead due to
			// array allocations. To reduce this overhead, we first compute
			// the number of combinations to ensure we will not surpass our
			// fixed limit before incurring the cost of any allocations:
			numCombinations := 1
			for _, sourceProperty := range sourcePropertiesFiltered {
				numCombinations *= countTypes(getNonMissingTypeOfSymbol(sourceProperty))
				if numCombinations > 25 {
					// We've reached the complexity limit.
					tracing. /* TODO(TS-TO-GO): was ? */ instant(tracing.Phase.CheckTypes, "typeRelatedToDiscriminatedType_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"sourceId":        source.id,
						"targetId":        target.id,
						"numCombinations": numCombinations,
					})
					return TernaryFalse
				}
			}
			// Compute the set of types for each discriminant property.
			var sourceDiscriminantTypes [][]Type = NewArray[[]Type](sourcePropertiesFiltered.length)
			excludedProperties := NewSet[__String]()
			for i := 0; i < sourcePropertiesFiltered.length; i++ {
				sourceProperty := sourcePropertiesFiltered[i]
				sourcePropertyType := getNonMissingTypeOfSymbol(sourceProperty)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case sourcePropertyType.flags & TypeFlagsUnion:
					sourceDiscriminantTypes[i] = (sourcePropertyType /* as UnionType */).types
				default:
					sourceDiscriminantTypes[i] = []Type{sourcePropertyType}
				}
				excludedProperties.add(sourceProperty.escapedName)
			}
			// Match each combination of the cartesian product of discriminant properties to one or more
			// constituents of 'target'. If any combination does not have a match then 'source' is not relatable.
			discriminantCombinations := cartesianProduct(sourceDiscriminantTypes)
			var matchingTypes []Type = []never{}
			for _, combination := range discriminantCombinations {
				hasMatch := false
			outer:
				for _, type_ := range target.types {
					for i := 0; i < sourcePropertiesFiltered.length; i++ {
						sourceProperty := sourcePropertiesFiltered[i]
						targetProperty := getPropertyOfType(type_, sourceProperty.escapedName)
						if !targetProperty {
							continue outer
						}
						if sourceProperty == targetProperty {
							continue
						}
						// We compare the source property to the target in the context of a single discriminant type.
						related := propertyRelatedTo(source, target, sourceProperty, targetProperty, func(_ Symbol) Type {
							return combination[i]
						}, /*reportErrors*/ false, IntersectionStateNone /*skipOptional*/, strictNullChecks || relation == comparableRelation)
						// If the target property could not be found, or if the properties were not related,
						// then this constituent is not a match.
						if !related {
							continue outer
						}
					}
					pushIfUnique(matchingTypes, type_, equateValues)
					hasMatch = true
				}
				if !hasMatch {
					// We failed to match any type for this combination.
					return TernaryFalse
				}
			}
			// Compare the remaining non-discriminant properties of each match.
			result := TernaryTrue
			for _, type_ := range matchingTypes {
				result &= propertiesRelatedTo(source, type_ /*reportErrors*/, false, excludedProperties /*optionalsOnly*/, false, IntersectionStateNone)
				if result {
					result &= signaturesRelatedTo(source, type_, SignatureKindCall /*reportErrors*/, false, IntersectionStateNone)
					if result {
						result &= signaturesRelatedTo(source, type_, SignatureKindConstruct /*reportErrors*/, false, IntersectionStateNone)
						if result && !(isTupleType(source) && isTupleType(type_)) {
							// Comparing numeric index types when both `source` and `type` are tuples is unnecessary as the
							// element types should be sufficiently covered by `propertiesRelatedTo`. It also causes problems
							// with index type assignability as the types for the excluded discriminants are still included
							// in the index type.
							result &= indexSignaturesRelatedTo(source, type_ /*sourceIsPrimitive*/, false /*reportErrors*/, false, IntersectionStateNone)
						}
					}
				}
				if !result {
					return result
				}
			}
			return result
		}
		excludeProperties := func(properties []Symbol, excludedProperties *Set[__String]) []Symbol {
			if !excludedProperties || properties.length == 0 {
				return properties
			}
			var result *[]Symbol
			for i := 0; i < properties.length; i++ {
				if !excludedProperties.has(properties[i].escapedName) {
					if result {
						result.push(properties[i])
					}
				} else if !result {
					result = properties.slice(0, i)
				}
			}
			return result || properties
		}
		isPropertySymbolTypeRelated := func(sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			targetIsOptional := strictNullChecks && !!(getCheckFlags(targetProp) & CheckFlagsPartial)
			effectiveTarget := addOptionality(getNonMissingTypeOfSymbol(targetProp) /*isProperty*/, false, targetIsOptional)
			effectiveSource := getTypeOfSourceProperty(sourceProp)
			return isRelatedTo(effectiveSource, effectiveTarget, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
		}
		propertyRelatedTo := func(source Type, target Type, sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState, skipOptional bool) Ternary {
			sourcePropFlags := getDeclarationModifierFlagsFromSymbol(sourceProp)
			targetPropFlags := getDeclarationModifierFlagsFromSymbol(targetProp)
			if sourcePropFlags&ModifierFlagsPrivate || targetPropFlags&ModifierFlagsPrivate {
				if sourceProp.valueDeclaration != targetProp.valueDeclaration {
					if reportErrors {
						if sourcePropFlags&ModifierFlagsPrivate && targetPropFlags&ModifierFlagsPrivate {
							reportError(Diagnostics.Types_have_separate_declarations_of_a_private_property_0, symbolToString(targetProp))
						} else {
							reportError(Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, symbolToString(targetProp), typeToString(__COND__(sourcePropFlags&ModifierFlagsPrivate, source, target)), typeToString(__COND__(sourcePropFlags&ModifierFlagsPrivate, target, source)))
						}
					}
					return TernaryFalse
				}
			} else if targetPropFlags & ModifierFlagsProtected {
				if !isValidOverrideOf(sourceProp, targetProp) {
					if reportErrors {
						reportError(Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, symbolToString(targetProp), typeToString(getDeclaringClass(sourceProp) || source), typeToString(getDeclaringClass(targetProp) || target))
					}
					return TernaryFalse
				}
			} else if sourcePropFlags & ModifierFlagsProtected {
				if reportErrors {
					reportError(Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target))
				}
				return TernaryFalse
			}
			// Ensure {readonly a: whatever} is not a subtype of {a: whatever},
			// while {a: whatever} is a subtype of {readonly a: whatever}.
			// This ensures the subtype relationship is ordered, and preventing declaration order
			// from deciding which type "wins" in union subtype reduction.
			// They're still assignable to one another, since `readonly` doesn't affect assignability.
			// This is only applied during the strictSubtypeRelation -- currently used in subtype reduction
			if relation == strictSubtypeRelation && isReadonlySymbol(sourceProp) && !isReadonlySymbol(targetProp) {
				return TernaryFalse
			}
			// If the target comes from a partial union prop, allow `undefined` in the target type
			related := isPropertySymbolTypeRelated(sourceProp, targetProp, getTypeOfSourceProperty, reportErrors, intersectionState)
			if !related {
				if reportErrors {
					reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(targetProp))
				}
				return TernaryFalse
			}
			// When checking for comparability, be more lenient with optional properties.
			if !skipOptional && sourceProp.flags&SymbolFlagsOptional && targetProp.flags&SymbolFlagsClassMember && !(targetProp.flags & SymbolFlagsOptional) {
				// TypeScript 1.0 spec (April 2014): 3.8.3
				// S is a subtype of a type T, and T is a supertype of S if ...
				// S' and T are object types and, for each member M in T..
				// M is a property and S' contains a property N where
				// if M is a required property, N is also a required property
				// (M - property in T)
				// (N - property in S)
				if reportErrors {
					reportError(Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target))
				}
				return TernaryFalse
			}
			return related
		}
		reportUnmatchedProperty := func(source Type, target Type, unmatchedProperty Symbol, requireOptionalProperties bool) {
			shouldSkipElaboration := false
			// give specific error in case where private names have the same description
			if unmatchedProperty.valueDeclaration && isNamedDeclaration(unmatchedProperty.valueDeclaration) && isPrivateIdentifier(unmatchedProperty.valueDeclaration.name) && source.symbol && source.symbol.flags&SymbolFlagsClass {
				privateIdentifierDescription := unmatchedProperty.valueDeclaration.name.escapedText
				symbolTableKey := getSymbolNameForPrivateIdentifier(source.symbol, privateIdentifierDescription)
				if symbolTableKey && getPropertyOfType(source, symbolTableKey) {
					sourceName := factory.getDeclarationName(source.symbol.valueDeclaration)
					targetName := factory.getDeclarationName(target.symbol.valueDeclaration)
					reportError(Diagnostics.Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2, diagnosticName(privateIdentifierDescription), diagnosticName(__COND__(sourceName.escapedText == "", anon, sourceName)), diagnosticName(__COND__(targetName.escapedText == "", anon, targetName)))
					return
				}
			}
			props := arrayFrom(getUnmatchedProperties(source, target, requireOptionalProperties /*matchDiscriminantProperties*/, false))
			if !headMessage || (headMessage.code != Diagnostics.Class_0_incorrectly_implements_interface_1.code && headMessage.code != Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass.code) {
				shouldSkipElaboration = true
				// Retain top-level error for interface implementing issues, otherwise omit it
			}
			if props.length == 1 {
				propName := symbolToString(unmatchedProperty /*enclosingDeclaration*/, nil, SymbolFlagsNone, SymbolFormatFlagsAllowAnyNodeKind|SymbolFormatFlagsWriteComputedProps)
				reportError(Diagnostics.Property_0_is_missing_in_type_1_but_required_in_type_2, propName, getTypeNamesForErrorDisplay(source, target)...)
				if length(unmatchedProperty.declarations) {
					associateRelatedInfo(createDiagnosticForNode(unmatchedProperty.declarations[0], Diagnostics._0_is_declared_here, propName))
				}
				if shouldSkipElaboration && errorInfo {
					overrideNextErrorInfo++
				}
			} else if tryElaborateArrayLikeErrors(source, target /*reportErrors*/, false) {
				if props.length > 5 {
					reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more, typeToString(source), typeToString(target), map_(props.slice(0, 4), func(p Symbol) string {
						return symbolToString(p)
					}).join(", "), props.length-4)
				} else {
					reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2, typeToString(source), typeToString(target), map_(props, func(p Symbol) string {
						return symbolToString(p)
					}).join(", "))
				}
				if shouldSkipElaboration && errorInfo {
					overrideNextErrorInfo++
				}
			}
			// No array like or unmatched property error - just issue top level error (errorInfo = undefined)
		}
		propertiesRelatedTo := func(source Type, target Type, reportErrors bool, excludedProperties *Set[__String], optionalsOnly bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return propertiesIdenticalTo(source, target, excludedProperties)
			}
			result := TernaryTrue
			if isTupleType(target) {
				if isArrayOrTupleType(source) {
					if !target.target.readonly && (isReadonlyArrayType(source) || isTupleType(source) && source.target.readonly) {
						return TernaryFalse
					}
					sourceArity := getTypeReferenceArity(source)
					targetArity := getTypeReferenceArity(target)
					var sourceRestFlag number
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isTupleType(source):
						sourceRestFlag = source.target.combinedFlags & ElementFlagsRest
					default:
						sourceRestFlag = ElementFlagsRest
					}
					targetHasRestElement := !!(target.target.combinedFlags & ElementFlagsVariable)
					var sourceMinLength number
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isTupleType(source):
						sourceMinLength = source.target.minLength
					default:
						sourceMinLength = 0
					}
					targetMinLength := target.target.minLength
					if !sourceRestFlag && sourceArity < targetMinLength {
						if reportErrors {
							reportError(Diagnostics.Source_has_0_element_s_but_target_requires_1, sourceArity, targetMinLength)
						}
						return TernaryFalse
					}
					if !targetHasRestElement && targetArity < sourceMinLength {
						if reportErrors {
							reportError(Diagnostics.Source_has_0_element_s_but_target_allows_only_1, sourceMinLength, targetArity)
						}
						return TernaryFalse
					}
					if !targetHasRestElement && (sourceRestFlag || targetArity < sourceArity) {
						if reportErrors {
							if sourceMinLength < targetMinLength {
								reportError(Diagnostics.Target_requires_0_element_s_but_source_may_have_fewer, targetMinLength)
							} else {
								reportError(Diagnostics.Target_allows_only_0_element_s_but_source_may_have_more, targetArity)
							}
						}
						return TernaryFalse
					}
					sourceTypeArguments := getTypeArguments(source)
					targetTypeArguments := getTypeArguments(target)
					targetStartCount := getStartElementCount(target.target, ElementFlagsNonRest)
					targetEndCount := getEndElementCount(target.target, ElementFlagsNonRest)
					canExcludeDiscriminants := !!excludedProperties
					for sourcePosition := 0; sourcePosition < sourceArity; sourcePosition++ {
						var sourceFlags ElementFlags
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isTupleType(source):
							sourceFlags = source.target.elementFlags[sourcePosition]
						default:
							sourceFlags = ElementFlagsRest
						}
						sourcePositionFromEnd := sourceArity - 1 - sourcePosition
						var targetPosition number
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case targetHasRestElement && sourcePosition >= targetStartCount:
							targetPosition = targetArity - 1 - Math.min(sourcePositionFromEnd, targetEndCount)
						default:
							targetPosition = sourcePosition
						}
						targetFlags := target.target.elementFlags[targetPosition]
						if targetFlags&ElementFlagsVariadic && !(sourceFlags & ElementFlagsVariadic) {
							if reportErrors {
								reportError(Diagnostics.Source_provides_no_match_for_variadic_element_at_position_0_in_target, targetPosition)
							}
							return TernaryFalse
						}
						if sourceFlags&ElementFlagsVariadic && !(targetFlags & ElementFlagsVariable) {
							if reportErrors {
								reportError(Diagnostics.Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target, sourcePosition, targetPosition)
							}
							return TernaryFalse
						}
						if targetFlags&ElementFlagsRequired && !(sourceFlags & ElementFlagsRequired) {
							if reportErrors {
								reportError(Diagnostics.Source_provides_no_match_for_required_element_at_position_0_in_target, targetPosition)
							}
							return TernaryFalse
						}
						// We can only exclude discriminant properties if we have not yet encountered a variable-length element.
						if canExcludeDiscriminants {
							if sourceFlags&ElementFlagsVariable || targetFlags&ElementFlagsVariable {
								canExcludeDiscriminants = false
							}
							if canExcludeDiscriminants && excludedProperties. /* TODO(TS-TO-GO): was ? */ has(("" + sourcePosition) /* as __String */) {
								continue
							}
						}
						sourceType := removeMissingType(sourceTypeArguments[sourcePosition], !!(sourceFlags & targetFlags & ElementFlagsOptional))
						targetType := targetTypeArguments[targetPosition]
						var targetCheckType Type
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case sourceFlags&ElementFlagsVariadic && targetFlags&ElementFlagsRest:
							targetCheckType = createArrayType(targetType)
						default:
							targetCheckType = removeMissingType(targetType, !!(targetFlags & ElementFlagsOptional))
						}
						related := isRelatedTo(sourceType, targetCheckType, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
						if !related {
							if reportErrors && (targetArity > 1 || sourceArity > 1) {
								if targetHasRestElement && sourcePosition >= targetStartCount && sourcePositionFromEnd >= targetEndCount && targetStartCount != sourceArity-targetEndCount-1 {
									reportIncompatibleError(Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, targetStartCount, sourceArity-targetEndCount-1, targetPosition)
								} else {
									reportIncompatibleError(Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, sourcePosition, targetPosition)
								}
							}
							return TernaryFalse
						}
						result &= related
					}
					return result
				}
				if target.target.combinedFlags & ElementFlagsVariable {
					return TernaryFalse
				}
			}
			requireOptionalProperties := (relation == subtypeRelation || relation == strictSubtypeRelation) && !isObjectLiteralType(source) && !isEmptyArrayLiteralType(source) && !isTupleType(source)
			unmatchedProperty := getUnmatchedProperty(source, target, requireOptionalProperties /*matchDiscriminantProperties*/, false)
			if unmatchedProperty {
				if reportErrors && shouldReportUnmatchedPropertyError(source, target) {
					reportUnmatchedProperty(source, target, unmatchedProperty, requireOptionalProperties)
				}
				return TernaryFalse
			}
			if isObjectLiteralType(target) {
				for _, sourceProp := range excludeProperties(getPropertiesOfType(source), excludedProperties) {
					if !getPropertyOfObjectType(target, sourceProp.escapedName) {
						sourceType := getTypeOfSymbol(sourceProp)
						if !(sourceType.flags & TypeFlagsUndefined) {
							if reportErrors {
								reportError(Diagnostics.Property_0_does_not_exist_on_type_1, symbolToString(sourceProp), typeToString(target))
							}
							return TernaryFalse
						}
					}
				}
			}
			// We only call this for union target types when we're attempting to do excess property checking - in those cases, we want to get _all possible props_
			// from the target union, across all members
			properties := getPropertiesOfType(target)
			numericNamesOnly := isTupleType(source) && isTupleType(target)
			for _, targetProp := range excludeProperties(properties, excludedProperties) {
				name := targetProp.escapedName
				if !(targetProp.flags & SymbolFlagsPrototype) && (!numericNamesOnly || isNumericLiteralName(name) || name == "length") && (!optionalsOnly || targetProp.flags&SymbolFlagsOptional) {
					sourceProp := getPropertyOfType(source, name)
					if sourceProp && sourceProp != targetProp {
						related := propertyRelatedTo(source, target, sourceProp, targetProp, getNonMissingTypeOfSymbol, reportErrors, intersectionState, relation == comparableRelation)
						if !related {
							return TernaryFalse
						}
						result &= related
					}
				}
			}
			return result
		}
		propertiesIdenticalTo := func(source Type, target Type, excludedProperties *Set[__String]) Ternary {
			if !(source.flags&TypeFlagsObject && target.flags&TypeFlagsObject) {
				return TernaryFalse
			}
			sourceProperties := excludeProperties(getPropertiesOfObjectType(source), excludedProperties)
			targetProperties := excludeProperties(getPropertiesOfObjectType(target), excludedProperties)
			if sourceProperties.length != targetProperties.length {
				return TernaryFalse
			}
			result := TernaryTrue
			for _, sourceProp := range sourceProperties {
				targetProp := getPropertyOfObjectType(target, sourceProp.escapedName)
				if !targetProp {
					return TernaryFalse
				}
				related := compareProperties(sourceProp, targetProp, isRelatedTo)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		signaturesRelatedTo := func(source Type, target Type, kind SignatureKind, reportErrors bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return signaturesIdenticalTo(source, target, kind)
			}
			if target == anyFunctionType || source == anyFunctionType {
				return TernaryTrue
			}
			sourceIsJSConstructor := source.symbol && isJSConstructor(source.symbol.valueDeclaration)
			targetIsJSConstructor := target.symbol && isJSConstructor(target.symbol.valueDeclaration)
			sourceSignatures := getSignaturesOfType(source, __COND__((sourceIsJSConstructor && kind == SignatureKindConstruct), SignatureKindCall, kind))
			targetSignatures := getSignaturesOfType(target, __COND__((targetIsJSConstructor && kind == SignatureKindConstruct), SignatureKindCall, kind))
			if kind == SignatureKindConstruct && sourceSignatures.length && targetSignatures.length {
				sourceIsAbstract := !!(sourceSignatures[0].flags & SignatureFlagsAbstract)
				targetIsAbstract := !!(targetSignatures[0].flags & SignatureFlagsAbstract)
				if sourceIsAbstract && !targetIsAbstract {
					// An abstract constructor type is not assignable to a non-abstract constructor type
					// as it would otherwise be possible to new an abstract class. Note that the assignability
					// check we perform for an extends clause excludes construct signatures from the target,
					// so this check never proceeds.
					if reportErrors {
						reportError(Diagnostics.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type)
					}
					return TernaryFalse
				}
				if !constructorVisibilitiesAreCompatible(sourceSignatures[0], targetSignatures[0], reportErrors) {
					return TernaryFalse
				}
			}
			result := TernaryTrue
			var incompatibleReporter /* TODO(TS-TO-GO) inferred type (siga: Signature, sigb: Signature) => (source: Type, target: Type) => void */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case kind == SignatureKindConstruct:
				incompatibleReporter = reportIncompatibleConstructSignatureReturn
			default:
				incompatibleReporter = reportIncompatibleCallSignatureReturn
			}
			sourceObjectFlags := getObjectFlags(source)
			targetObjectFlags := getObjectFlags(target)
			if sourceObjectFlags&ObjectFlagsInstantiated && targetObjectFlags&ObjectFlagsInstantiated && source.symbol == target.symbol || sourceObjectFlags&ObjectFlagsReference && targetObjectFlags&ObjectFlagsReference && (source /* as TypeReference */).target == (target /* as TypeReference */).target {
				// We have instantiations of the same anonymous type (which typically will be the type of a
				// method). Simply do a pairwise comparison of the signatures in the two signature lists instead
				// of the much more expensive N * M comparison matrix we explore below. We erase type parameters
				// as they are known to always be the same.
				Debug.assertEqual(sourceSignatures.length, targetSignatures.length)
				for i := 0; i < targetSignatures.length; i++ {
					related := signatureRelatedTo(sourceSignatures[i], targetSignatures[i] /*erase*/, true, reportErrors, intersectionState, incompatibleReporter(sourceSignatures[i], targetSignatures[i]))
					if !related {
						return TernaryFalse
					}
					result &= related
				}
			} else if sourceSignatures.length == 1 && targetSignatures.length == 1 {
				// For simple functions (functions with a single signature) we only erase type parameters for
				// the comparable relation. Otherwise, if the source signature is generic, we instantiate it
				// in the context of the target signature before checking the relationship. Ideally we'd do
				// this regardless of the number of signatures, but the potential costs are prohibitive due
				// to the quadratic nature of the logic below.
				eraseGenerics := relation == comparableRelation
				sourceSignature := first(sourceSignatures)
				targetSignature := first(targetSignatures)
				result = signatureRelatedTo(sourceSignature, targetSignature, eraseGenerics, reportErrors, intersectionState, incompatibleReporter(sourceSignature, targetSignature))
				if !result && reportErrors && kind == SignatureKindConstruct && (sourceObjectFlags & targetObjectFlags) && (targetSignature.declaration. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindConstructor || sourceSignature.declaration. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindConstructor) {
					constructSignatureToString := func(signature Signature) string {
						return signatureToString(signature /*enclosingDeclaration*/, nil, TypeFormatFlagsWriteArrowStyleSignature, kind)
					}
					reportError(Diagnostics.Type_0_is_not_assignable_to_type_1, constructSignatureToString(sourceSignature), constructSignatureToString(targetSignature))
					reportError(Diagnostics.Types_of_construct_signatures_are_incompatible)
					return result
				}
			} else {
			outer:
				for _, t := range targetSignatures {
					saveErrorInfo := captureErrorCalculationState()
					// Only elaborate errors from the first failure
					shouldElaborateErrors := reportErrors
					for _, s := range sourceSignatures {
						related := signatureRelatedTo(s, t /*erase*/, true, shouldElaborateErrors, intersectionState, incompatibleReporter(s, t))
						if related {
							result &= related
							resetErrorInfo(saveErrorInfo)
							continue outer
						}
						shouldElaborateErrors = false
					}
					if shouldElaborateErrors {
						reportError(Diagnostics.Type_0_provides_no_match_for_the_signature_1, typeToString(source), signatureToString(t /*enclosingDeclaration*/, nil /*flags*/, nil, kind))
					}
					return TernaryFalse
				}
			}
			return result
		}
		shouldReportUnmatchedPropertyError := func(source Type, target Type) bool {
			typeCallSignatures := getSignaturesOfStructuredType(source, SignatureKindCall)
			typeConstructSignatures := getSignaturesOfStructuredType(source, SignatureKindConstruct)
			typeProperties := getPropertiesOfObjectType(source)
			if (typeCallSignatures.length || typeConstructSignatures.length) && !typeProperties.length {
				if (getSignaturesOfType(target, SignatureKindCall).length && typeCallSignatures.length) || (getSignaturesOfType(target, SignatureKindConstruct).length && typeConstructSignatures.length) {
					return true
					// target has similar signature kinds to source, still focus on the unmatched property
				}
				return false
			}
			return true
		}
		reportIncompatibleCallSignatureReturn := func(siga Signature, sigb Signature) /* TODO(TS-TO-GO) inferred type (source: Type, target: Type) => void */ any {
			if siga.parameters.length == 0 && sigb.parameters.length == 0 {
				return func(source Type, target Type) {
					return reportIncompatibleError(Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target))
				}
			}
			return func(source Type, target Type) {
				return reportIncompatibleError(Diagnostics.Call_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target))
			}
		}
		reportIncompatibleConstructSignatureReturn := func(siga Signature, sigb Signature) /* TODO(TS-TO-GO) inferred type (source: Type, target: Type) => void */ any {
			if siga.parameters.length == 0 && sigb.parameters.length == 0 {
				return func(source Type, target Type) {
					return reportIncompatibleError(Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target))
				}
			}
			return func(source Type, target Type) {
				return reportIncompatibleError(Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target))
			}
		}
		/**
		 * See signatureAssignableTo, compareSignaturesIdentical
		 */
		signatureRelatedTo := func(source Signature, target Signature, erase bool, reportErrors bool, intersectionState IntersectionState, incompatibleReporter func(source Type, target Type)) Ternary {
			var checkMode number
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case relation == subtypeRelation:
				checkMode = SignatureCheckModeStrictTopSignature
			case relation == strictSubtypeRelation:
				checkMode = SignatureCheckModeStrictTopSignature | SignatureCheckModeStrictArity
			default:
				checkMode = SignatureCheckModeNone
			}
			return compareSignaturesRelated(__COND__(erase, getErasedSignature(source), source), __COND__(erase, getErasedSignature(target), target), checkMode, reportErrors, reportError, incompatibleReporter, isRelatedToWorker, reportUnreliableMapper)
			isRelatedToWorker := func(source Type, target Type, reportErrors bool) Ternary {
				return isRelatedTo(source, target, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
			}
		}
		signaturesIdenticalTo := func(source Type, target Type, kind SignatureKind) Ternary {
			sourceSignatures := getSignaturesOfType(source, kind)
			targetSignatures := getSignaturesOfType(target, kind)
			if sourceSignatures.length != targetSignatures.length {
				return TernaryFalse
			}
			result := TernaryTrue
			for i := 0; i < sourceSignatures.length; i++ {
				related := compareSignaturesIdentical(sourceSignatures[i], targetSignatures[i] /*partialMatch*/, false /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, false, isRelatedTo)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		membersRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := TernaryTrue
			keyType := targetInfo.keyType
			var props []Symbol
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case source.flags & TypeFlagsIntersection:
				props = getPropertiesOfUnionOrIntersectionType(source /* as IntersectionType */)
			default:
				props = getPropertiesOfObjectType(source)
			}
			for _, prop := range props {
				// Skip over ignored JSX and symbol-named members
				if isIgnoredJsxProperty(source, prop) {
					continue
				}
				if isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique), keyType) {
					propType := getNonMissingTypeOfSymbol(prop)
					var type_ Type
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case exactOptionalPropertyTypes || propType.flags&TypeFlagsUndefined || keyType == numberType || !(prop.flags & SymbolFlagsOptional):
						type_ = propType
					default:
						type_ = getTypeWithFacts(propType, TypeFactsNEUndefined)
					}
					related := isRelatedTo(type_, targetInfo.type_, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
					if !related {
						if reportErrors {
							reportError(Diagnostics.Property_0_is_incompatible_with_index_signature, symbolToString(prop))
						}
						return TernaryFalse
					}
					result &= related
				}
			}
			for _, info := range getIndexInfosOfType(source) {
				if isApplicableIndexType(info.keyType, keyType) {
					related := indexInfoRelatedTo(info, targetInfo, reportErrors, intersectionState)
					if !related {
						return TernaryFalse
					}
					result &= related
				}
			}
			return result
		}
		indexInfoRelatedTo := func(sourceInfo IndexInfo, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
			related := isRelatedTo(sourceInfo.type_, targetInfo.type_, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
			if !related && reportErrors {
				if sourceInfo.keyType == targetInfo.keyType {
					reportError(Diagnostics._0_index_signatures_are_incompatible, typeToString(sourceInfo.keyType))
				} else {
					reportError(Diagnostics._0_and_1_index_signatures_are_incompatible, typeToString(sourceInfo.keyType), typeToString(targetInfo.keyType))
				}
			}
			return related
		}
		indexSignaturesRelatedTo := func(source Type, target Type, sourceIsPrimitive bool, reportErrors bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return indexSignaturesIdenticalTo(source, target)
			}
			indexInfos := getIndexInfosOfType(target)
			targetHasStringIndex := some(indexInfos, func(info IndexInfo) bool {
				return info.keyType == stringType
			})
			result := TernaryTrue
			for _, targetInfo := range indexInfos {
				var related Ternary
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case relation != strictSubtypeRelation && !sourceIsPrimitive && targetHasStringIndex && targetInfo.type_.flags&TypeFlagsAny:
					related = TernaryTrue
				case isGenericMappedType(source) && targetHasStringIndex:
					related = isRelatedTo(getTemplateTypeFromMappedType(source), targetInfo.type_, RecursionFlagsBoth, reportErrors)
				default:
					related = typeRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState)
				}
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		typeRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
			sourceInfo := getApplicableIndexInfo(source, targetInfo.keyType)
			if sourceInfo {
				return indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors, intersectionState)
			}
			// Intersection constituents are never considered to have an inferred index signature. Also, in the strict subtype relation,
			// only fresh object literals are considered to have inferred index signatures. This ensures { [x: string]: xxx } <: {} but
			// not vice-versa. Without this rule, those types would be mutual strict subtypes.
			if !(intersectionState & IntersectionStateSource) && (relation != strictSubtypeRelation || getObjectFlags(source)&ObjectFlagsFreshLiteral) && isObjectTypeWithInferableIndex(source) {
				return membersRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState)
			}
			if reportErrors {
				reportError(Diagnostics.Index_signature_for_type_0_is_missing_in_type_1, typeToString(targetInfo.keyType), typeToString(source))
			}
			return TernaryFalse
		}
		indexSignaturesIdenticalTo := func(source Type, target Type) Ternary {
			sourceInfos := getIndexInfosOfType(source)
			targetInfos := getIndexInfosOfType(target)
			if sourceInfos.length != targetInfos.length {
				return TernaryFalse
			}
			for _, targetInfo := range targetInfos {
				sourceInfo := getIndexInfoOfType(source, targetInfo.keyType)
				if !(sourceInfo && isRelatedTo(sourceInfo.type_, targetInfo.type_, RecursionFlagsBoth) && sourceInfo.isReadonly == targetInfo.isReadonly) {
					return TernaryFalse
				}
			}
			return TernaryTrue
		}
		constructorVisibilitiesAreCompatible := func(sourceSignature Signature, targetSignature Signature, reportErrors bool) bool {
			if !sourceSignature.declaration || !targetSignature.declaration {
				return true
			}
			sourceAccessibility := getSelectedEffectiveModifierFlags(sourceSignature.declaration, ModifierFlagsNonPublicAccessibilityModifier)
			targetAccessibility := getSelectedEffectiveModifierFlags(targetSignature.declaration, ModifierFlagsNonPublicAccessibilityModifier)
			// A public, protected and private signature is assignable to a private signature.
			if targetAccessibility == ModifierFlagsPrivate {
				return true
			}
			// A public and protected signature is assignable to a protected signature.
			if targetAccessibility == ModifierFlagsProtected && sourceAccessibility != ModifierFlagsPrivate {
				return true
			}
			// Only a public signature is assignable to public signature.
			if targetAccessibility != ModifierFlagsProtected && !sourceAccessibility {
				return true
			}
			if reportErrors {
				reportError(Diagnostics.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type, visibilityToString(sourceAccessibility), visibilityToString(targetAccessibility))
			}
			return false
		}
	}
	typeCouldHaveTopLevelSingletonTypes := func(type_ Type) bool {
		// Okay, yes, 'boolean' is a union of 'true | false', but that's not useful
		// in error reporting scenarios. If you need to use this function but that detail matters,
		// feel free to add a flag.
		if type_.flags & TypeFlagsBoolean {
			return false
		}
		if type_.flags & TypeFlagsUnionOrIntersection {
			return !!forEach((type_ /* as IntersectionType */).types, typeCouldHaveTopLevelSingletonTypes)
		}
		if type_.flags & TypeFlagsInstantiable {
			constraint := getConstraintOfType(type_)
			if constraint && constraint != type_ {
				return typeCouldHaveTopLevelSingletonTypes(constraint)
			}
		}
		return isUnitType(type_) || !!(type_.flags & TypeFlagsTemplateLiteral) || !!(type_.flags & TypeFlagsStringMapping)
	}
	getExactOptionalUnassignableProperties := func(source Type, target Type) []Symbol {
		if isTupleType(source) && isTupleType(target) {
			return emptyArray
		}
		return getPropertiesOfType(target).filter(func(targetProp Symbol) bool {
			return isExactOptionalPropertyMismatch(getTypeOfPropertyOfType(source, targetProp.escapedName), getTypeOfSymbol(targetProp))
		})
	}
	isExactOptionalPropertyMismatch := func(source Type, target Type) bool {
		return !!source && !!target && maybeTypeOfKind(source, TypeFlagsUndefined) && !!containsMissingType(target)
	}
	getExactOptionalProperties := func(type_ Type) []Symbol {
		return getPropertiesOfType(type_).filter(func(targetProp Symbol) bool {
			return containsMissingType(getTypeOfSymbol(targetProp))
		})
	}
	getBestMatchingType := func(source Type, target UnionOrIntersectionType, isRelatedTo /* TODO(TS-TO-GO) inferred type (source: Type, target: Type) => Ternary */ any /*  = compareTypesAssignable */) Type {
		return findMatchingDiscriminantType(source, target, isRelatedTo) || findMatchingTypeReferenceOrTypeAliasReference(source, target) || findBestTypeForObjectLiteral(source, target) || findBestTypeForInvokable(source, target) || findMostOverlappyType(source, target)
	}
	discriminateTypeByDiscriminableItems := func(target UnionType, discriminators [] /* TODO(TS-TO-GO) TypeNode TupleType: [() => Type, __String] */ any, related func(source Type, target Type) /* TODO(TS-TO-GO) TypeNode UnionType: boolean | Ternary */ any) Type {
		types := target.types
		var include []Ternary = types.map_(func(t Type) /* TODO(TS-TO-GO) inferred type Ternary.False | Ternary.True */ any {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case t.flags & TypeFlagsPrimitive:
				return TernaryFalse
			default:
				return TernaryTrue
			}
		})
		for _, TODO_IDENTIFIER := range discriminators {
			// If the remaining target types include at least one with a matching discriminant, eliminate those that
			// have non-matching discriminants. This ensures that we ignore erroneous discriminators and gradually
			// refine the target set without eliminating every constituent (which would lead to `never`).
			matched := false
			for i := 0; i < types.length; i++ {
				if include[i] {
					targetType := getTypeOfPropertyOrIndexSignatureOfType(types[i], propertyName)
					if targetType && someType(getDiscriminatingType(), func(t Type) bool {
						return !!related(t, targetType)
					}) {
						matched = true
					} else {
						include[i] = TernaryMaybe
					}
				}
			}
			// Turn each Ternary.Maybe into Ternary.False if there was a match. Otherwise, revert to Ternary.True.
			for i := 0; i < types.length; i++ {
				if include[i] == TernaryMaybe {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case matched:
						include[i] = TernaryFalse
					default:
						include[i] = TernaryTrue
					}
				}
			}
		}
		var filtered Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case contains(include, TernaryFalse):
			filtered = getUnionType(types.filter(func(_ Type, i number) Ternary {
				return include[i]
			}), UnionReductionNone)
		default:
			filtered = target
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case filtered.flags & TypeFlagsNever:
			return target
		default:
			return filtered
		}
	}
	/**
	 * A type is 'weak' if it is an object type with at least one optional property
	 * and no required properties, call/construct signatures or index signatures
	 */
	isWeakType := func(type_ Type) bool {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_ /* as ObjectType */)
			return resolved.callSignatures.length == 0 && resolved.constructSignatures.length == 0 && resolved.indexInfos.length == 0 && resolved.properties.length > 0 && every(resolved.properties, func(p Symbol) bool {
				return !!(p.flags & SymbolFlagsOptional)
			})
		}
		if type_.flags & TypeFlagsSubstitution {
			return isWeakType((type_ /* as SubstitutionType */).baseType)
		}
		if type_.flags & TypeFlagsIntersection {
			return every((type_ /* as IntersectionType */).types, isWeakType)
		}
		return false
	}
	hasCommonProperties := func(source Type, target Type, isComparingJsxAttributes bool) bool {
		for _, prop := range getPropertiesOfType(source) {
			if isKnownProperty(target, prop.escapedName, isComparingJsxAttributes) {
				return true
			}
		}
		return false
	}
	getVariances := func(type_ GenericType) []VarianceFlags {
		// Arrays and tuples are known to be covariant, no need to spend time computing this.
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_ == globalArrayType || type_ == globalReadonlyArrayType || type_.objectFlags&ObjectFlagsTuple:
			return arrayVariances
		default:
			return getVariancesWorker(type_.symbol, type_.typeParameters)
		}
	}
	getAliasVariances := func(symbol Symbol) []VarianceFlags {
		return getVariancesWorker(symbol, getSymbolLinks(symbol).typeParameters)
	}
	// Return an array containing the variance of each type parameter. The variance is effectively
	// a digest of the type comparisons that occur for each type argument when instantiations of the
	// generic type are structurally compared. We infer the variance information by comparing
	// instantiations of the generic type for type arguments with known relations. The function
	// returns the emptyArray singleton when invoked recursively for the given generic type.
	getVariancesWorker := func(symbol Symbol, typeParameters []TypeParameter /*  = emptyArray */) []VarianceFlags {
		links := getSymbolLinks(symbol)
		if !links.variances {
			tracing. /* TODO(TS-TO-GO): was ? */ push(tracing.Phase.CheckTypes, "getVariancesWorker", map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"arity": typeParameters.length,
				"id":    getTypeId(getDeclaredTypeOfSymbol(symbol)),
			})
			oldVarianceComputation := inVarianceComputation
			saveResolutionStart := resolutionStart
			if !inVarianceComputation {
				inVarianceComputation = true
				resolutionStart = resolutionTargets.length
			}
			links.variances = emptyArray
			variances := []never{}
			for _, tp := range typeParameters {
				modifiers := getTypeParameterModifiers(tp)
				var variance *VarianceFlags
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case modifiers & ModifierFlagsOut:
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case modifiers & ModifierFlagsIn:
						variance = VarianceFlagsInvariant
					default:
						variance = VarianceFlagsCovariant
					}
				case modifiers & ModifierFlagsIn:
					variance = VarianceFlagsContravariant
				default:
					variance = nil
				}
				if variance == nil {
					unmeasurable := false
					unreliable := false
					oldHandler := outofbandVarianceMarkerHandler
					outofbandVarianceMarkerHandler = func(onlyUnreliable bool) bool {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case onlyUnreliable:
							return /* TODO(TS-TO-GO) Node BinaryExpression: unreliable = true */ TODO
						default:
							return /* TODO(TS-TO-GO) Node BinaryExpression: unmeasurable = true */ TODO
						}
					}
					// We first compare instantiations where the type parameter is replaced with
					// marker types that have a known subtype relationship. From this we can infer
					// invariance, covariance, contravariance or bivariance.
					typeWithSuper := createMarkerType(symbol, tp, markerSuperType)
					typeWithSub := createMarkerType(symbol, tp, markerSubType)
					variance = (__COND__(isTypeAssignableTo(typeWithSub, typeWithSuper), VarianceFlagsCovariant, 0)) | (__COND__(isTypeAssignableTo(typeWithSuper, typeWithSub), VarianceFlagsContravariant, 0))
					// If the instantiations appear to be related bivariantly it may be because the
					// type parameter is independent (i.e. it isn't witnessed anywhere in the generic
					// type). To determine this we compare instantiations where the type parameter is
					// replaced with marker types that are known to be unrelated.
					if variance == VarianceFlagsBivariant && isTypeAssignableTo(createMarkerType(symbol, tp, markerOtherType), typeWithSuper) {
						variance = VarianceFlagsIndependent
					}
					outofbandVarianceMarkerHandler = oldHandler
					if unmeasurable || unreliable {
						if unmeasurable {
							variance |= VarianceFlagsUnmeasurable
						}
						if unreliable {
							variance |= VarianceFlagsUnreliable
						}
					}
				}
				variances.push(variance)
			}
			if !oldVarianceComputation {
				inVarianceComputation = false
				resolutionStart = saveResolutionStart
			}
			links.variances = variances
			tracing. /* TODO(TS-TO-GO): was ? */ pop(map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"variances": variances.map_(Debug.formatVariance),
			})
		}
		return links.variances
	}
	createMarkerType := func(symbol Symbol, source TypeParameter, target Type) Type {
		mapper := makeUnaryTypeMapper(source, target)
		type_ := getDeclaredTypeOfSymbol(symbol)
		if isErrorType(type_) {
			return type_
		}
		var result Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol.flags & SymbolFlagsTypeAlias:
			result = getTypeAliasInstantiation(symbol, instantiateTypes(getSymbolLinks(symbol).typeParameters, mapper))
		default:
			result = createTypeReference(type_ /* as GenericType */, instantiateTypes((type_ /* as GenericType */).typeParameters, mapper))
		}
		markerTypes.add(getTypeId(result))
		return result
	}
	isMarkerType := func(type_ Type) bool {
		return markerTypes.has(getTypeId(type_))
	}
	getTypeParameterModifiers := func(tp TypeParameter) ModifierFlags {
		return reduceLeft(tp.symbol. /* TODO(TS-TO-GO): was ? */ declarations, func(modifiers ModifierFlags, d Declaration) number {
			return modifiers | getEffectiveModifierFlags(d)
		}, ModifierFlagsNone) & (ModifierFlagsIn | ModifierFlagsOut | ModifierFlagsConst)
	}
	// Return true if the given type reference has a 'void' type argument for a covariant type parameter.
	// See comment at call in recursiveTypeRelatedTo for when this case matters.
	hasCovariantVoidArgument := func(typeArguments []Type, variances []VarianceFlags) bool {
		for i := 0; i < variances.length; i++ {
			if (variances[i]&VarianceFlagsVarianceMask) == VarianceFlagsCovariant && typeArguments[i].flags&TypeFlagsVoid {
				return true
			}
		}
		return false
	}
	isUnconstrainedTypeParameter := func(type_ Type) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
		return type_.flags&TypeFlagsTypeParameter && !getConstraintOfTypeParameter(type_ /* as TypeParameter */)
	}
	isNonDeferredTypeReference := func(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is TypeReference */ any {
		return !!(getObjectFlags(type_) & ObjectFlagsReference) && !(type_ /* as TypeReference */).node
	}
	isTypeReferenceWithGenericArguments := func(type_ Type) bool {
		return isNonDeferredTypeReference(type_) && some(getTypeArguments(type_), func(t Type) bool {
			return !!(t.flags & TypeFlagsTypeParameter) || isTypeReferenceWithGenericArguments(t)
		})
	}
	getGenericTypeReferenceRelationKey := func(source TypeReference, target TypeReference, postFix string, ignoreConstraints bool) string {
		var typeParameters []Type = []never{}
		constraintMarker := ""
		sourceId := getTypeReferenceId(source, 0)
		targetId := getTypeReferenceId(target, 0)
		return __TEMPLATE__(constraintMarker, sourceId, ",", targetId, postFix)
		// getTypeReferenceId(A<T, number, U>) returns "111=0-12=1"
		// where A.id=111 and number.id=12
		getTypeReferenceId := func(type_ TypeReference, depth number /*  = 0 */) string {
			result := "" + type_.target.id
			for _, t := range getTypeArguments(type_) {
				if t.flags & TypeFlagsTypeParameter {
					if ignoreConstraints || isUnconstrainedTypeParameter(t) {
						index := typeParameters.indexOf(t)
						if index < 0 {
							index = typeParameters.length
							typeParameters.push(t)
						}
						result += "=" + index
						continue
					}
					// We mark type references that reference constrained type parameters such that we know to obtain
					// and look for a "broadest equivalent key" in the cache.
					constraintMarker = "*"
				} else if depth < 4 && isTypeReferenceWithGenericArguments(t) {
					result += "<" + getTypeReferenceId(t /* as TypeReference */, depth+1) + ">"
					continue
				}
				result += "-" + t.id
			}
			return result
		}
	}
	/**
	 * To improve caching, the relation key for two generic types uses the target's id plus ids of the type parameters.
	 * For other cases, the types ids are used.
	 */
	getRelationKey := func(source Type, target Type, intersectionState IntersectionState, relation Map[string, RelationComparisonResult], ignoreConstraints bool) string {
		if relation == identityRelation && source.id > target.id {
			temp := source
			source = target
			target = temp
		}
		var postFix string
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case intersectionState:
			postFix = ":" + intersectionState
		default:
			postFix = ""
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isTypeReferenceWithGenericArguments(source) && isTypeReferenceWithGenericArguments(target):
			return getGenericTypeReferenceRelationKey(source /* as TypeReference */, target /* as TypeReference */, postFix, ignoreConstraints)
		default:
			return __TEMPLATE__(source.id, ",", target.id, postFix)
		}
	}
	// Invoke the callback for each underlying property symbol of the given symbol and return the first
	// value that isn't undefined.
	forEachProperty := func(prop Symbol, callback func(p Symbol) T) *T {
		if getCheckFlags(prop) & CheckFlagsSynthetic {
			// NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.Synthetic
			for _, t := range (prop /* as TransientSymbol */).links.containingType.types {
				p := getPropertyOfType(t, prop.escapedName)
				result := p && forEachProperty(p, callback)
				if result {
					return result
				}
			}
			return nil
		}
		return callback(prop)
	}
	// Return the declaring class type of a property or undefined if property not declared in class
	getDeclaringClass := func(prop Symbol) *InterfaceType {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case prop.parent && prop.parent.flags&SymbolFlagsClass:
			return getDeclaredTypeOfSymbol(getParentOfSymbol(prop)) /* as InterfaceType */
		default:
			return nil
		}
	}
	// Return the inherited type of the given property or undefined if property doesn't exist in a base class.
	getTypeOfPropertyInBaseClass := func(property Symbol) Type {
		classType := getDeclaringClass(property)
		baseClassType := classType && getBaseTypes(classType)[0]
		return baseClassType && getTypeOfPropertyOfType(baseClassType, property.escapedName)
	}
	// Return true if some underlying source property is declared in a class that derives
	// from the given base class.
	isPropertyInClassDerivedFrom := func(prop Symbol, baseClass Type) *bool {
		return forEachProperty(prop, func(sp Symbol) bool {
			sourceClass := getDeclaringClass(sp)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case sourceClass:
				return hasBaseType(sourceClass, baseClass)
			default:
				return false
			}
		})
	}
	// Return true if source property is a valid override of protected parts of target property.
	isValidOverrideOf := func(sourceProp Symbol, targetProp Symbol) bool {
		return !forEachProperty(targetProp, func(tp Symbol) bool {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case getDeclarationModifierFlagsFromSymbol(tp) & ModifierFlagsProtected:
				return !isPropertyInClassDerivedFrom(sourceProp, getDeclaringClass(tp))
			default:
				return false
			}
		})
	}
	// Return true if the given class derives from each of the declaring classes of the protected
	// constituents of the given property.
	isClassDerivedFromDeclaringClasses := func(checkClass T, prop Symbol, writing bool) *T {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case forEachProperty(prop, func(p Symbol) bool {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case getDeclarationModifierFlagsFromSymbol(p, writing) & ModifierFlagsProtected:
				return !hasBaseType(checkClass, getDeclaringClass(p))
			default:
				return false
			}
		}):
			return nil
		default:
			return checkClass
		}
	}
	// Return true if the given type is deeply nested. We consider this to be the case when the given stack contains
	// maxDepth or more occurrences of types with the same recursion identity as the given type. The recursion identity
	// provides a shared identity for type instantiations that repeat in some (possibly infinite) pattern. For example,
	// in `type Deep<T> = { next: Deep<Deep<T>> }`, repeatedly referencing the `next` property leads to an infinite
	// sequence of ever deeper instantiations with the same recursion identity (in this case the symbol associated with
	// the object type literal).
	// A homomorphic mapped type is considered deeply nested if its target type is deeply nested, and an intersection is
	// considered deeply nested if any constituent of the intersection is deeply nested.
	// It is possible, though highly unlikely, for the deeply nested check to be true in a situation where a chain of
	// instantiations is not infinitely expanding. Effectively, we will generate a false positive when two types are
	// structurally equal to at least maxDepth levels, but unequal at some level beyond that.
	isDeeplyNestedType := func(type_ Type, stack []Type, depth number, maxDepth number /*  = 3 */) bool {
		if depth >= maxDepth {
			if (getObjectFlags(type_) & ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped {
				type_ = getMappedTargetWithSymbol(type_)
			}
			if type_.flags & TypeFlagsIntersection {
				return some((type_ /* as IntersectionType */).types, func(t Type) bool {
					return isDeeplyNestedType(t, stack, depth, maxDepth)
				})
			}
			identity := getRecursionIdentity(type_)
			count := 0
			lastTypeId := 0
			for i := 0; i < depth; i++ {
				t := stack[i]
				if hasMatchingRecursionIdentity(t, identity) {
					// We only count occurrences with a higher type id than the previous occurrence, since higher
					// type ids are an indicator of newer instantiations caused by recursion.
					if t.id >= lastTypeId {
						count++
						if count >= maxDepth {
							return true
						}
					}
					lastTypeId = t.id
				}
			}
		}
		return false
	}
	// Unwrap nested homomorphic mapped types and return the deepest target type that has a symbol. This better
	// preserves unique type identities for mapped types applied to explicitly written object literals. For example
	// in `Mapped<{ x: Mapped<{ x: Mapped<{ x: string }>}>}>`, each of the mapped type applications will have a
	// unique recursion identity (that of their target object type literal) and thus avoid appearing deeply nested.
	getMappedTargetWithSymbol := func(type_ Type) Type {
		var target TODO
		for (getObjectFlags(type_)&ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped && ( /* TODO(TS-TO-GO) Node BinaryExpression: target = getModifiersTypeFromMappedType(type as MappedType) */ TODO) && (target.symbol || target.flags&TypeFlagsIntersection && some((target /* as IntersectionType */).types, func(t Type) true {
			return !!t.symbol
		})) {
			type_ = target
		}
		return type_
	}
	hasMatchingRecursionIdentity := func(type_ Type, identity any) bool {
		if (getObjectFlags(type_) & ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped {
			type_ = getMappedTargetWithSymbol(type_)
		}
		if type_.flags & TypeFlagsIntersection {
			return some((type_ /* as IntersectionType */).types, func(t Type) bool {
				return hasMatchingRecursionIdentity(t, identity)
			})
		}
		return getRecursionIdentity(type_) == identity
	}
	// The recursion identity of a type is an object identity that is shared among multiple instantiations of the type.
	// We track recursion identities in order to identify deeply nested and possibly infinite type instantiations with
	// the same origin. For example, when type parameters are in scope in an object type such as { x: T }, all
	// instantiations of that type have the same recursion identity. The default recursion identity is the object
	// identity of the type, meaning that every type is unique. Generally, types with constituents that could circularly
	// reference the type have a recursion identity that differs from the object identity.
	getRecursionIdentity := func(type_ Type) any {
		// Object and array literals are known not to contain recursive references and don't need a recursion identity.
		if type_.flags&TypeFlagsObject && !isObjectOrArrayLiteralType(type_) {
			if getObjectFlags(type_)&ObjectFlagsReference && (type_ /* as TypeReference */).node {
				// Deferred type references are tracked through their associated AST node. This gives us finer
				// granularity than using their associated target because each manifest type reference has a
				// unique AST node.
				return (type_ /* as TypeReference */).node
			}
			if type_.symbol && !(getObjectFlags(type_)&ObjectFlagsAnonymous && type_.symbol.flags&SymbolFlagsClass) {
				// We track object types that have a symbol by that symbol (representing the origin of the type), but
				// exclude the static side of a class since it shares its symbol with the instance side.
				return type_.symbol
			}
			if isTupleType(type_) {
				return type_.target
			}
		}
		if type_.flags & TypeFlagsTypeParameter {
			// We use the symbol of the type parameter such that all "fresh" instantiations of that type parameter
			// have the same recursion identity.
			return type_.symbol
		}
		if type_.flags & TypeFlagsIndexedAccess {
			// Identity is the leftmost object type in a chain of indexed accesses, eg, in A[P1][P2][P3] it is A.
			// TODO(TS-TO-GO): refactor do-while loop approximation
			for ok := true; ok; ok = type_.flags & TypeFlagsIndexedAccess {
				type_ = (type_ /* as IndexedAccessType */).objectType
			}
			return type_
		}
		if type_.flags & TypeFlagsConditional {
			// The root object represents the origin of the conditional type
			return (type_ /* as ConditionalType */).root
		}
		return type_
	}
	isPropertyIdenticalTo := func(sourceProp Symbol, targetProp Symbol) bool {
		return compareProperties(sourceProp, targetProp, compareTypesIdentical) != TernaryFalse
	}
	compareProperties := func(sourceProp Symbol, targetProp Symbol, compareTypes func(source Type, target Type) Ternary) Ternary {
		// Two members are considered identical when
		// - they are public properties with identical names, optionality, and types,
		// - they are private or protected properties originating in the same declaration and having identical types
		if sourceProp == targetProp {
			return TernaryTrue
		}
		sourcePropAccessibility := getDeclarationModifierFlagsFromSymbol(sourceProp) & ModifierFlagsNonPublicAccessibilityModifier
		targetPropAccessibility := getDeclarationModifierFlagsFromSymbol(targetProp) & ModifierFlagsNonPublicAccessibilityModifier
		if sourcePropAccessibility != targetPropAccessibility {
			return TernaryFalse
		}
		if sourcePropAccessibility {
			if getTargetSymbol(sourceProp) != getTargetSymbol(targetProp) {
				return TernaryFalse
			}
		} else {
			if (sourceProp.flags & SymbolFlagsOptional) != (targetProp.flags & SymbolFlagsOptional) {
				return TernaryFalse
			}
		}
		if isReadonlySymbol(sourceProp) != isReadonlySymbol(targetProp) {
			return TernaryFalse
		}
		return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp))
	}
	isMatchingSignature := func(source Signature, target Signature, partialMatch bool) bool {
		sourceParameterCount := getParameterCount(source)
		targetParameterCount := getParameterCount(target)
		sourceMinArgumentCount := getMinArgumentCount(source)
		targetMinArgumentCount := getMinArgumentCount(target)
		sourceHasRestParameter := hasEffectiveRestParameter(source)
		targetHasRestParameter := hasEffectiveRestParameter(target)
		// A source signature matches a target signature if the two signatures have the same number of required,
		// optional, and rest parameters.
		if sourceParameterCount == targetParameterCount && sourceMinArgumentCount == targetMinArgumentCount && sourceHasRestParameter == targetHasRestParameter {
			return true
		}
		// A source signature partially matches a target signature if the target signature has no fewer required
		// parameters
		if partialMatch && sourceMinArgumentCount <= targetMinArgumentCount {
			return true
		}
		return false
	}
	/**
	 * See signatureRelatedTo, compareSignaturesIdentical
	 */
	compareSignaturesIdentical := func(source Signature, target Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool, compareTypes func(s Type, t Type) Ternary) Ternary {
		// TODO (drosen): De-duplicate code between related functions.
		if source == target {
			return TernaryTrue
		}
		if !(isMatchingSignature(source, target, partialMatch)) {
			return TernaryFalse
		}
		// Check that the two signatures have the same number of type parameters.
		if length(source.typeParameters) != length(target.typeParameters) {
			return TernaryFalse
		}
		// Check that type parameter constraints and defaults match. If they do, instantiate the source
		// signature with the type parameters of the target signature and continue the comparison.
		if target.typeParameters {
			mapper := createTypeMapper(source.typeParameters, target.typeParameters)
			for i := 0; i < target.typeParameters.length; i++ {
				s := source.typeParameters[i]
				t := target.typeParameters[i]
				if !(s == t || compareTypes(instantiateType(getConstraintFromTypeParameter(s), mapper) || unknownType, getConstraintFromTypeParameter(t) || unknownType) && compareTypes(instantiateType(getDefaultFromTypeParameter(s), mapper) || unknownType, getDefaultFromTypeParameter(t) || unknownType)) {
					return TernaryFalse
				}
			}
			source = instantiateSignature(source, mapper /*eraseTypeParameters*/, true)
		}
		result := TernaryTrue
		if !ignoreThisTypes {
			sourceThisType := getThisTypeOfSignature(source)
			if sourceThisType {
				targetThisType := getThisTypeOfSignature(target)
				if targetThisType {
					related := compareTypes(sourceThisType, targetThisType)
					if !related {
						return TernaryFalse
					}
					result &= related
				}
			}
		}
		targetLen := getParameterCount(target)
		for i := 0; i < targetLen; i++ {
			s := getTypeAtPosition(source, i)
			t := getTypeAtPosition(target, i)
			related := compareTypes(t, s)
			if !related {
				return TernaryFalse
			}
			result &= related
		}
		if !ignoreReturnTypes {
			sourceTypePredicate := getTypePredicateOfSignature(source)
			targetTypePredicate := getTypePredicateOfSignature(target)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case sourceTypePredicate || targetTypePredicate:
				result &= compareTypePredicatesIdentical(sourceTypePredicate, targetTypePredicate, compareTypes)
			default:
				result &= compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target))
			}
		}
		return result
	}
	compareTypePredicatesIdentical := func(source *TypePredicate, target *TypePredicate, compareTypes func(s Type, t Type) Ternary) Ternary {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case !(source && target && typePredicateKindsMatch(source, target)):
			return TernaryFalse
		case source.type_ == target.type_:
			return TernaryTrue
		case source.type_ && target.type_:
			return compareTypes(source.type_, target.type_)
		default:
			return TernaryFalse
		}
	}
	literalTypesWithSameBaseType := func(types []Type) bool {
		var commonBaseType Type
		for _, t := range types {
			if !(t.flags & TypeFlagsNever) {
				baseType := getBaseTypeOfLiteralType(t)
				/* TODO(TS-TO-GO) Node BinaryExpression: commonBaseType ??= baseType */ TODO
				if baseType == t || baseType != commonBaseType {
					return false
				}
			}
		}
		return true
	}
	getCombinedTypeFlags := func(types []Type) TypeFlags {
		return reduceLeft(types, func(flags TypeFlags, t Type) number {
			return flags | (__COND__(t.flags&TypeFlagsUnion, getCombinedTypeFlags((t /* as UnionType */).types), t.flags))
		}, 0 /* as TypeFlags */)
	}
	getCommonSupertype := func(types []Type) Type {
		if types.length == 1 {
			return types[0]
		}
		// Remove nullable types from each of the candidates.
		var primaryTypes []Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case strictNullChecks:
			primaryTypes = sameMap(types, func(t Type) Type {
				return filterType(t, func(u Type) bool {
					return !(u.flags & TypeFlagsNullable)
				})
			})
		default:
			primaryTypes = types
		}
		// When the candidate types are all literal types with the same base type, return a union
		// of those literal types. Otherwise, return the leftmost type for which no type to the
		// right is a supertype.
		var superTypeOrUnion Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case literalTypesWithSameBaseType(primaryTypes):
			superTypeOrUnion = getUnionType(primaryTypes)
		default:
			superTypeOrUnion = reduceLeft(primaryTypes, func(s Type, t Type) Type {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isTypeSubtypeOf(s, t):
					return t
				default:
					return s
				}
			})
		}
		// Add any nullable types that occurred in the candidates back to the result.
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case primaryTypes == types:
			return superTypeOrUnion
		default:
			return getNullableType(superTypeOrUnion, getCombinedTypeFlags(types)&TypeFlagsNullable)
		}
	}
	// Return the leftmost type for which no type to the right is a subtype.
	getCommonSubtype := func(types []Type) Type {
		return reduceLeft(types, func(s Type, t Type) Type {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isTypeSubtypeOf(t, s):
				return t
			default:
				return s
			}
		})
	}
	isArrayType := func(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is TypeReference */ any {
		return !!(getObjectFlags(type_) & ObjectFlagsReference) && ((type_ /* as TypeReference */).target == globalArrayType || (type_ /* as TypeReference */).target == globalReadonlyArrayType)
	}
	isReadonlyArrayType := func(type_ Type) bool {
		return !!(getObjectFlags(type_) & ObjectFlagsReference) && (type_ /* as TypeReference */).target == globalReadonlyArrayType
	}
	isArrayOrTupleType := func(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is TypeReference */ any {
		return isArrayType(type_) || isTupleType(type_)
	}
	isMutableArrayOrTuple := func(type_ Type) bool {
		return isArrayType(type_) && !isReadonlyArrayType(type_) || isTupleType(type_) && !type_.target.readonly
	}
	getElementTypeOfArrayType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isArrayType(type_):
			return getTypeArguments(type_)[0]
		default:
			return nil
		}
	}
	isArrayLikeType := func(type_ Type) bool {
		// A type is array-like if it is a reference to the global Array or global ReadonlyArray type,
		// or if it is not the undefined or null type and if it is assignable to ReadonlyArray<any>
		return isArrayType(type_) || !(type_.flags&TypeFlagsNullable) && isTypeAssignableTo(type_, anyReadonlyArrayType)
	}
	isMutableArrayLikeType := func(type_ Type) bool {
		// A type is mutable-array-like if it is a reference to the global Array type, or if it is not the
		// any, undefined or null type and if it is assignable to Array<any>
		return isMutableArrayOrTuple(type_) || !(type_.flags&(TypeFlagsAny|TypeFlagsNullable)) && isTypeAssignableTo(type_, anyArrayType)
	}
	getSingleBaseForNonAugmentingSubtype := func(type_ Type) Type {
		if !(getObjectFlags(type_) & ObjectFlagsReference) || !(getObjectFlags((type_ /* as TypeReference */).target) & ObjectFlagsClassOrInterface) {
			return nil
		}
		if getObjectFlags(type_) & ObjectFlagsIdenticalBaseTypeCalculated {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case getObjectFlags(type_) & ObjectFlagsIdenticalBaseTypeExists:
				return (type_ /* as TypeReference */).cachedEquivalentBaseType
			default:
				return nil
			}
		}
		(type_ /* as TypeReference */).objectFlags |= ObjectFlagsIdenticalBaseTypeCalculated
		target := (type_ /* as TypeReference */).target /* as InterfaceType */
		if getObjectFlags(target) & ObjectFlagsClass {
			baseTypeNode := getBaseTypeNodeOfClass(target)
			// A base type expression may circularly reference the class itself (e.g. as an argument to function call), so we only
			// check for base types specified as simple qualified names.
			if baseTypeNode && baseTypeNode.expression.kind != SyntaxKindIdentifier && baseTypeNode.expression.kind != SyntaxKindPropertyAccessExpression {
				return nil
			}
		}
		bases := getBaseTypes(target)
		if bases.length != 1 {
			return nil
		}
		if getMembersOfSymbol(type_.symbol).size {
			return nil
			// If the interface has any members, they may subtype members in the base, so we should do a full structural comparison
		}
		var instantiatedBase Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case !length(target.typeParameters):
			instantiatedBase = bases[0]
		default:
			instantiatedBase = instantiateType(bases[0], createTypeMapper(target.typeParameters, getTypeArguments(type_ /* as TypeReference */).slice(0, target.typeParameters.length)))
		}
		if length(getTypeArguments(type_ /* as TypeReference */)) > length(target.typeParameters) {
			instantiatedBase = getTypeWithThisArgument(instantiatedBase, last(getTypeArguments(type_ /* as TypeReference */)))
		}
		(type_ /* as TypeReference */).objectFlags |= ObjectFlagsIdenticalBaseTypeExists
		(type_ /* as TypeReference */).cachedEquivalentBaseType = instantiatedBase
		return (type_ /* as TypeReference */).cachedEquivalentBaseType
	}
	isEmptyLiteralType := func(type_ Type) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case strictNullChecks:
			return type_ == implicitNeverType
		default:
			return type_ == undefinedWideningType
		}
	}
	isEmptyArrayLiteralType := func(type_ Type) bool {
		elementType := getElementTypeOfArrayType(type_)
		return !!elementType && isEmptyLiteralType(elementType)
	}
	isTupleLikeType := func(type_ Type) bool {
		var lengthType TODO
		return isTupleType(type_) || !!getPropertyOfType(type_, "0" /* as __String */) || isArrayLikeType(type_) && !!( /* TODO(TS-TO-GO) Node BinaryExpression: lengthType = getTypeOfPropertyOfType(type, "length" as __String) */ TODO) && everyType(lengthType, func(t Type) bool {
			return !!(t.flags & TypeFlagsNumberLiteral)
		})
	}
	isArrayOrTupleLikeType := func(type_ Type) bool {
		return isArrayLikeType(type_) || isTupleLikeType(type_)
	}
	getTupleElementType := func(type_ Type, index number) Type {
		propType := getTypeOfPropertyOfType(type_, ""+index /* as __String */)
		if propType {
			return propType
		}
		if everyType(type_, isTupleType) {
			return getTupleElementTypeOutOfStartCount(type_, index, __COND__(compilerOptions.noUncheckedIndexedAccess, undefinedType, nil))
		}
		return nil
	}
	isNeitherUnitTypeNorNever := func(type_ Type) bool {
		return !(type_.flags & (TypeFlagsUnit | TypeFlagsNever))
	}
	isUnitType := func(type_ Type) bool {
		return !!(type_.flags & TypeFlagsUnit)
	}
	isUnitLikeType := func(type_ Type) bool {
		// Intersections that reduce to 'never' (e.g. 'T & null' where 'T extends {}') are not unit types.
		t := getBaseConstraintOrType(type_)
		// Scan intersections such that tagged literal types are considered unit types.
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case t.flags & TypeFlagsIntersection:
			return some((t /* as IntersectionType */).types, isUnitType)
		default:
			return isUnitType(t)
		}
	}
	extractUnitType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsIntersection:
			return find((type_ /* as IntersectionType */).types, isUnitType) || type_
		default:
			return type_
		}
	}
	isLiteralType := func(type_ Type) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsBoolean:
			return true
		case type_.flags & TypeFlagsUnion:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case type_.flags & TypeFlagsEnumLiteral:
				return true
			default:
				return every((type_ /* as UnionType */).types, isUnitType)
			}
		default:
			return isUnitType(type_)
		}
	}
	getBaseTypeOfLiteralType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsEnumLike:
			return getBaseTypeOfEnumLikeType(type_ /* as LiteralType */)
		case type_.flags & (TypeFlagsStringLiteral | TypeFlagsTemplateLiteral | TypeFlagsStringMapping):
			return stringType
		case type_.flags & TypeFlagsNumberLiteral:
			return numberType
		case type_.flags & TypeFlagsBigIntLiteral:
			return bigintType
		case type_.flags & TypeFlagsBooleanLiteral:
			return booleanType
		case type_.flags & TypeFlagsUnion:
			return getBaseTypeOfLiteralTypeUnion(type_ /* as UnionType */)
		default:
			return type_
		}
	}
	getBaseTypeOfLiteralTypeUnion := func(type_ UnionType) Type {
		key := __TEMPLATE__("B", getTypeId(type_))
		return /* TODO(TS-TO-GO) Node BinaryExpression: getCachedType(key) ?? setCachedType(key, mapType(type, getBaseTypeOfLiteralType)) */ TODO
	}
	// This like getBaseTypeOfLiteralType, but instead treats enum literals as strings/numbers instead
	// of returning their enum base type (which depends on the types of other literals in the enum).
	getBaseTypeOfLiteralTypeForComparison := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & (TypeFlagsStringLiteral | TypeFlagsTemplateLiteral | TypeFlagsStringMapping):
			return stringType
		case type_.flags & (TypeFlagsNumberLiteral | TypeFlagsEnum):
			return numberType
		case type_.flags & TypeFlagsBigIntLiteral:
			return bigintType
		case type_.flags & TypeFlagsBooleanLiteral:
			return booleanType
		case type_.flags & TypeFlagsUnion:
			return mapType(type_, getBaseTypeOfLiteralTypeForComparison)
		default:
			return type_
		}
	}
	getWidenedLiteralType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags&TypeFlagsEnumLike && isFreshLiteralType(type_):
			return getBaseTypeOfEnumLikeType(type_ /* as LiteralType */)
		case type_.flags&TypeFlagsStringLiteral && isFreshLiteralType(type_):
			return stringType
		case type_.flags&TypeFlagsNumberLiteral && isFreshLiteralType(type_):
			return numberType
		case type_.flags&TypeFlagsBigIntLiteral && isFreshLiteralType(type_):
			return bigintType
		case type_.flags&TypeFlagsBooleanLiteral && isFreshLiteralType(type_):
			return booleanType
		case type_.flags & TypeFlagsUnion:
			return mapType(type_ /* as UnionType */, getWidenedLiteralType)
		default:
			return type_
		}
	}
	getWidenedUniqueESSymbolType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUniqueESSymbol:
			return esSymbolType
		case type_.flags & TypeFlagsUnion:
			return mapType(type_ /* as UnionType */, getWidenedUniqueESSymbolType)
		default:
			return type_
		}
	}
	getWidenedLiteralLikeTypeForContextualType := func(type_ Type, contextualType Type) Type {
		if !isLiteralOfContextualType(type_, contextualType) {
			type_ = getWidenedUniqueESSymbolType(getWidenedLiteralType(type_))
		}
		return getRegularTypeOfLiteralType(type_)
	}
	getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded := func(type_ Type, contextualSignatureReturnType Type, isAsync bool) Type {
		if type_ && isUnitType(type_) {
			var contextualType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !contextualSignatureReturnType:
				contextualType = nil
			case isAsync:
				contextualType = getPromisedTypeOfPromise(contextualSignatureReturnType)
			default:
				contextualType = contextualSignatureReturnType
			}
			type_ = getWidenedLiteralLikeTypeForContextualType(type_, contextualType)
		}
		return type_
	}
	getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded := func(type_ Type, contextualSignatureReturnType Type, kind IterationTypeKind, isAsyncGenerator bool) Type {
		if type_ && isUnitType(type_) {
			var contextualType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !contextualSignatureReturnType:
				contextualType = nil
			default:
				contextualType = getIterationTypeOfGeneratorFunctionReturnType(kind, contextualSignatureReturnType, isAsyncGenerator)
			}
			type_ = getWidenedLiteralLikeTypeForContextualType(type_, contextualType)
		}
		return type_
	}
	/**
	 * Check if a Type was written as a tuple type literal.
	 * Prefer using isTupleLikeType() unless the use of `elementTypes`/`getTypeArguments` is required.
	 */
	isTupleType := func(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is TupleTypeReference */ any {
		return !!(getObjectFlags(type_)&ObjectFlagsReference && (type_ /* as TypeReference */).target.objectFlags&ObjectFlagsTuple)
	}
	isGenericTupleType := func(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is TupleTypeReference */ any {
		return isTupleType(type_) && !!(type_.target.combinedFlags & ElementFlagsVariadic)
	}
	isSingleElementGenericTupleType := func(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is TupleTypeReference */ any {
		return isGenericTupleType(type_) && type_.target.elementFlags.length == 1
	}
	getRestTypeOfTupleType := func(type_ TupleTypeReference) Type {
		return getElementTypeOfSliceOfTupleType(type_, type_.target.fixedLength)
	}
	getTupleElementTypeOutOfStartCount := func(type_ Type, index number, undefinedOrMissingType Type) Type {
		return mapType(type_, func(t Type) Type {
			tupleType := t /* as TupleTypeReference */
			restType := getRestTypeOfTupleType(tupleType)
			if !restType {
				return undefinedType
			}
			if undefinedOrMissingType && index >= getTotalFixedElementCount(tupleType.target) {
				return getUnionType([]Type{restType, undefinedOrMissingType})
			}
			return restType
		})
	}
	getRestArrayTypeOfTupleType := func(type_ TupleTypeReference) *ObjectType {
		restType := getRestTypeOfTupleType(type_)
		return restType && createArrayType(restType)
	}
	getElementTypeOfSliceOfTupleType := func(type_ TupleTypeReference, index number, endSkipCount number /*  = 0 */, writing bool /*  = false */, noReductions bool /*  = false */) Type {
		length := getTypeReferenceArity(type_) - endSkipCount
		if index < length {
			typeArguments := getTypeArguments(type_)
			var elementTypes []Type = []never{}
			for i := index; i < length; i++ {
				t := typeArguments[i]
				elementTypes.push(__COND__(type_.target.elementFlags[i]&ElementFlagsVariadic, getIndexedAccessType(t, numberType), t))
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case writing:
				return getIntersectionType(elementTypes)
			default:
				return getUnionType(elementTypes, __COND__(noReductions, UnionReductionNone, UnionReductionLiteral))
			}
		}
		return nil
	}
	isTupleTypeStructureMatching := func(t1 TupleTypeReference, t2 TupleTypeReference) bool {
		return getTypeReferenceArity(t1) == getTypeReferenceArity(t2) && every(t1.target.elementFlags, func(f ElementFlags, i number) bool {
			return (f & ElementFlagsVariable) == (t2.target.elementFlags[i] & ElementFlagsVariable)
		})
	}
	isZeroBigInt := func(TODO_IDENTIFIER BigIntLiteralType) bool {
		return value.base10Value == "0"
	}
	removeDefinitelyFalsyTypes := func(type_ Type) Type {
		return filterType(type_, func(t Type) bool {
			return hasTypeFacts(t, TypeFactsTruthy)
		})
	}
	extractDefinitelyFalsyTypes := func(type_ Type) Type {
		return mapType(type_, getDefinitelyFalsyPartOfType)
	}
	getDefinitelyFalsyPartOfType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsString:
			return emptyStringType
		case type_.flags & TypeFlagsNumber:
			return zeroType
		case type_.flags & TypeFlagsBigInt:
			return zeroBigIntType
		case type_ == regularFalseType || type_ == falseType || type_.flags&(TypeFlagsVoid|TypeFlagsUndefined|TypeFlagsNull|TypeFlagsAnyOrUnknown) || type_.flags&TypeFlagsStringLiteral && (type_ /* as StringLiteralType */).value == "" || type_.flags&TypeFlagsNumberLiteral && (type_ /* as NumberLiteralType */).value == 0 || type_.flags&TypeFlagsBigIntLiteral && isZeroBigInt(type_ /* as BigIntLiteralType */):
			return type_
		default:
			return neverType
		}
	}
	/**
	 * Add undefined or null or both to a type if they are missing.
	 * @param type - type to add undefined and/or null to if not present
	 * @param flags - Either TypeFlags.Undefined or TypeFlags.Null, or both
	 */
	getNullableType := func(type_ Type, flags TypeFlags) Type {
		missing := (flags & ~type_.flags) & (TypeFlagsUndefined | TypeFlagsNull)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case missing == 0:
			return type_
		case missing == TypeFlagsUndefined:
			return getUnionType([]Type{type_, undefinedType})
		case missing == TypeFlagsNull:
			return getUnionType([]Type{type_, nullType})
		default:
			return getUnionType([]Type{type_, undefinedType, nullType})
		}
	}
	getOptionalType := func(type_ Type, isProperty bool /*  = false */) Type {
		Debug.assert(strictNullChecks)
		var missingOrUndefined IntrinsicType
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isProperty:
			missingOrUndefined = undefinedOrMissingType
		default:
			missingOrUndefined = undefinedType
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_ == missingOrUndefined || type_.flags&TypeFlagsUnion && (type_ /* as UnionType */).types[0] == missingOrUndefined:
			return type_
		default:
			return getUnionType([]Type{type_, missingOrUndefined})
		}
	}
	getGlobalNonNullableTypeInstantiation := func(type_ Type) Type {
		if !deferredGlobalNonNullableTypeAlias {
			deferredGlobalNonNullableTypeAlias = getGlobalSymbol("NonNullable" /* as __String */, SymbolFlagsTypeAlias /*diagnostic*/, nil) || unknownSymbol
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case deferredGlobalNonNullableTypeAlias != unknownSymbol:
			return getTypeAliasInstantiation(deferredGlobalNonNullableTypeAlias, []Type{type_})
		default:
			return getIntersectionType([]Type{type_, emptyObjectType})
		}
	}
	getNonNullableType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case strictNullChecks:
			return getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
		default:
			return type_
		}
	}
	addOptionalTypeMarker := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case strictNullChecks:
			return getUnionType([]Type{type_, optionalType})
		default:
			return type_
		}
	}
	removeOptionalTypeMarker := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case strictNullChecks:
			return removeType(type_, optionalType)
		default:
			return type_
		}
	}
	propagateOptionalTypeMarker := func(type_ Type, node OptionalChain, wasOptional bool) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case wasOptional:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isOutermostOptionalChain(node):
				return getOptionalType(type_)
			default:
				return addOptionalTypeMarker(type_)
			}
		default:
			return type_
		}
	}
	getOptionalExpressionType := func(exprType Type, expression Expression) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isExpressionOfOptionalChainRoot(expression):
			return getNonNullableType(exprType)
		case isOptionalChain(expression):
			return removeOptionalTypeMarker(exprType)
		default:
			return exprType
		}
	}
	removeMissingType := func(type_ Type, isOptional bool) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case exactOptionalPropertyTypes && isOptional:
			return removeType(type_, missingType)
		default:
			return type_
		}
	}
	containsMissingType := func(type_ Type) bool {
		return type_ == missingType || !!(type_.flags&TypeFlagsUnion) && (type_ /* as UnionType */).types[0] == missingType
	}
	removeMissingOrUndefinedType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case exactOptionalPropertyTypes:
			return removeType(type_, missingType)
		default:
			return getTypeWithFacts(type_, TypeFactsNEUndefined)
		}
	}
	/**
	 * Is source potentially coercible to target type under `==`.
	 * Assumes that `source` is a constituent of a union, hence
	 * the boolean literal flag on the LHS, but not on the RHS.
	 *
	 * This does not fully replicate the semantics of `==`. The
	 * intention is to catch cases that are clearly not right.
	 *
	 * Comparing (string | number) to number should not remove the
	 * string element.
	 *
	 * Comparing (string | number) to 1 will remove the string
	 * element, though this is not sound. This is a pragmatic
	 * choice.
	 *
	 * @see narrowTypeByEquality
	 *
	 * @param source
	 * @param target
	 */
	isCoercibleUnderDoubleEquals := func(source Type, target Type) bool {
		return ((source.flags & (TypeFlagsNumber | TypeFlagsString | TypeFlagsBooleanLiteral)) != 0) && ((target.flags & (TypeFlagsNumber | TypeFlagsString | TypeFlagsBoolean)) != 0)
	}
	/**
	 * Return true if type was inferred from an object literal, written as an object type literal, or is the shape of a module
	 * with no call or construct signatures.
	 */
	isObjectTypeWithInferableIndex := func(type_ Type) bool {
		objectFlags := getObjectFlags(type_)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsIntersection:
			return every((type_ /* as IntersectionType */).types, isObjectTypeWithInferableIndex)
		default:
			return !!(type_.symbol && (type_.symbol.flags&(SymbolFlagsObjectLiteral|SymbolFlagsTypeLiteral|SymbolFlagsEnum|SymbolFlagsValueModule)) != 0 && !(type_.symbol.flags & SymbolFlagsClass) && !typeHasCallOrConstructSignatures(type_)) || !!(objectFlags & ObjectFlagsObjectRestType) || !!(objectFlags&ObjectFlagsReverseMapped && isObjectTypeWithInferableIndex((type_ /* as ReverseMappedType */).source))
		}
	}
	createSymbolWithType := func(source Symbol, type_ Type) TransientSymbol {
		symbol := createSymbol(source.flags, source.escapedName, getCheckFlags(source)&CheckFlagsReadonly)
		symbol.declarations = source.declarations
		symbol.parent = source.parent
		symbol.links.type_ = type_
		symbol.links.target = source
		if source.valueDeclaration {
			symbol.valueDeclaration = source.valueDeclaration
		}
		nameType := getSymbolLinks(source).nameType
		if nameType {
			symbol.links.nameType = nameType
		}
		return symbol
	}
	transformTypeOfMembers := func(type_ Type, f func(propertyType Type) Type) SymbolTable {
		members := createSymbolTable()
		for _, property := range getPropertiesOfObjectType(type_) {
			original := getTypeOfSymbol(property)
			updated := f(original)
			members.set(property.escapedName, __COND__(updated == original, property, createSymbolWithType(property, updated)))
		}
		return members
	}
	/**
	 * If the the provided object literal is subject to the excess properties check,
	 * create a new that is exempt. Recursively mark object literal members as exempt.
	 * Leave signatures alone since they are not subject to the check.
	 */
	getRegularTypeOfObjectLiteral := func(type_ Type) Type {
		if !(isObjectLiteralType(type_) && getObjectFlags(type_)&ObjectFlagsFreshLiteral) {
			return type_
		}
		regularType := (type_ /* as FreshObjectLiteralType */).regularType
		if regularType {
			return regularType
		}
		resolved := type_ /* as ResolvedType */
		members := transformTypeOfMembers(type_, getRegularTypeOfObjectLiteral)
		regularNew := createAnonymousType(resolved.symbol, members, resolved.callSignatures, resolved.constructSignatures, resolved.indexInfos)
		regularNew.flags = resolved.flags
		regularNew.objectFlags |= resolved.objectFlags & ~ObjectFlagsFreshLiteral
		(type_ /* as FreshObjectLiteralType */).regularType = regularNew
		return regularNew
	}
	createWideningContext := func(parent *WideningContext, propertyName *__String, siblings *[]Type) WideningContext {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"parent":             parent,
			"propertyName":       propertyName,
			"siblings":           siblings,
			"resolvedProperties": nil,
		}
	}
	getSiblingsOfContext := func(context WideningContext) []Type {
		if !context.siblings {
			var siblings []Type = []never{}
			for _, type_ := range getSiblingsOfContext(context.parent) {
				if isObjectLiteralType(type_) {
					prop := getPropertyOfObjectType(type_, context.propertyName)
					if prop {
						forEachType(getTypeOfSymbol(prop), func(t Type) {
							siblings.push(t)
						})
					}
				}
			}
			context.siblings = siblings
		}
		return context.siblings
	}
	getPropertiesOfContext := func(context WideningContext) []Symbol {
		if !context.resolvedProperties {
			names := NewMap[__String, Symbol]()
			for _, t := range getSiblingsOfContext(context) {
				if isObjectLiteralType(t) && !(getObjectFlags(t) & ObjectFlagsContainsSpread) {
					for _, prop := range getPropertiesOfType(t) {
						names.set(prop.escapedName, prop)
					}
				}
			}
			context.resolvedProperties = arrayFrom(names.values())
		}
		return context.resolvedProperties
	}
	getWidenedProperty := func(prop Symbol, context *WideningContext) Symbol {
		if !(prop.flags & SymbolFlagsProperty) {
			// Since get accessors already widen their return value there is no need to
			// widen accessor based properties here.
			return prop
		}
		original := getTypeOfSymbol(prop)
		propContext := context && createWideningContext(context, prop.escapedName /*siblings*/, nil)
		widened := getWidenedTypeWithContext(original, propContext)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case widened == original:
			return prop
		default:
			return createSymbolWithType(prop, widened)
		}
	}
	getUndefinedProperty := func(prop Symbol) Symbol {
		cached := undefinedProperties.get(prop.escapedName)
		if cached {
			return cached
		}
		result := createSymbolWithType(prop, undefinedOrMissingType)
		result.flags |= SymbolFlagsOptional
		undefinedProperties.set(prop.escapedName, result)
		return result
	}
	getWidenedTypeOfObjectLiteral := func(type_ Type, context *WideningContext) Type {
		members := createSymbolTable()
		for _, prop := range getPropertiesOfObjectType(type_) {
			members.set(prop.escapedName, getWidenedProperty(prop, context))
		}
		if context {
			for _, prop := range getPropertiesOfContext(context) {
				if !members.has(prop.escapedName) {
					members.set(prop.escapedName, getUndefinedProperty(prop))
				}
			}
		}
		result := createAnonymousType(type_.symbol, members, emptyArray, emptyArray, sameMap(getIndexInfosOfType(type_), func(info IndexInfo) IndexInfo {
			return createIndexInfo(info.keyType, getWidenedType(info.type_), info.isReadonly)
		}))
		result.objectFlags |= getObjectFlags(type_) & (ObjectFlagsJSLiteral | ObjectFlagsNonInferrableType)
		// Retain js literal flag through widening
		return result
	}
	getWidenedType := func(type_ Type) Type {
		return getWidenedTypeWithContext(type_ /*context*/, nil)
	}
	getWidenedTypeWithContext := func(type_ Type, context *WideningContext) Type {
		if getObjectFlags(type_) & ObjectFlagsRequiresWidening {
			if context == nil && type_.widened {
				return type_.widened
			}
			var result Type
			if type_.flags & (TypeFlagsAny | TypeFlagsNullable) {
				result = anyType
			} else if isObjectLiteralType(type_) {
				result = getWidenedTypeOfObjectLiteral(type_, context)
			} else if type_.flags & TypeFlagsUnion {
				unionContext := context || createWideningContext(nil /*propertyName*/, nil, (type_ /* as UnionType */).types)
				widenedTypes := sameMap((type_ /* as UnionType */).types, func(t Type) Type {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case t.flags & TypeFlagsNullable:
						return t
					default:
						return getWidenedTypeWithContext(t, unionContext)
					}
				})
				// Widening an empty object literal transitions from a highly restrictive type to
				// a highly inclusive one. For that reason we perform subtype reduction here if the
				// union includes empty object types (e.g. reducing {} | string to just {}).
				result = getUnionType(widenedTypes, __COND__(some(widenedTypes, isEmptyObjectType), UnionReductionSubtype, UnionReductionLiteral))
			} else if type_.flags & TypeFlagsIntersection {
				result = getIntersectionType(sameMap((type_ /* as IntersectionType */).types, getWidenedType))
			} else if isArrayOrTupleType(type_) {
				result = createTypeReference(type_.target, sameMap(getTypeArguments(type_), getWidenedType))
			}
			if result && context == nil {
				type_.widened = result
			}
			return result || type_
		}
		return type_
	}
	/**
	 * Reports implicit any errors that occur as a result of widening 'null' and 'undefined'
	 * to 'any'. A call to reportWideningErrorsInType is normally accompanied by a call to
	 * getWidenedType. But in some cases getWidenedType is called without reporting errors
	 * (type argument inference is an example).
	 *
	 * The return value indicates whether an error was in fact reported. The particular circumstances
	 * are on a best effort basis. Currently, if the null or undefined that causes widening is inside
	 * an object literal property (arbitrarily deeply), this function reports an error. If no error is
	 * reported, reportImplicitAnyError is a suitable fallback to report a general error.
	 */
	reportWideningErrorsInType := func(type_ Type) bool {
		errorReported := false
		if getObjectFlags(type_) & ObjectFlagsContainsWideningType {
			if type_.flags & TypeFlagsUnion {
				if some((type_ /* as UnionType */).types, isEmptyObjectType) {
					errorReported = true
				} else {
					for _, t := range (type_ /* as UnionType */).types {
						/* TODO(TS-TO-GO) Node BinaryExpression: errorReported ||= reportWideningErrorsInType(t) */ TODO
					}
				}
			} else if isArrayOrTupleType(type_) {
				for _, t := range getTypeArguments(type_) {
					/* TODO(TS-TO-GO) Node BinaryExpression: errorReported ||= reportWideningErrorsInType(t) */ TODO
				}
			} else if isObjectLiteralType(type_) {
				for _, p := range getPropertiesOfObjectType(type_) {
					t := getTypeOfSymbol(p)
					if getObjectFlags(t) & ObjectFlagsContainsWideningType {
						errorReported = reportWideningErrorsInType(t)
						if !errorReported {
							// we need to account for property types coming from object literal type normalization in unions
							valueDeclaration := p.declarations. /* TODO(TS-TO-GO): was ? */ find(func(d Declaration) bool {
								return d.symbol.valueDeclaration. /* TODO(TS-TO-GO): was ? */ parent == type_.symbol.valueDeclaration
							})
							if valueDeclaration {
								error(valueDeclaration, Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, symbolToString(p), typeToString(getWidenedType(t)))
								errorReported = true
							}
						}
					}
				}
			}
		}
		return errorReported
	}
	reportImplicitAny := func(declaration Declaration, type_ Type, wideningKind WideningKind) {
		typeAsString := typeToString(getWidenedType(type_))
		if isInJSFile(declaration) && !isCheckJsEnabledForFile(getSourceFileOfNode(declaration), compilerOptions) {
			// Only report implicit any errors/suggestions in TS and ts-check JS files
			return
		}
		var diagnostic DiagnosticMessage
		switch declaration.kind {
		case SyntaxKindBinaryExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertyDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertySignature:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case noImplicitAny:
				diagnostic = Diagnostics.Member_0_implicitly_has_an_1_type
			default:
				diagnostic = Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage
			}
			break
		case SyntaxKindParameter:
			param := declaration /* as ParameterDeclaration */
			if isIdentifier(param.name) {
				originalKeywordKind := identifierToKeywordKind(param.name)
				if (isCallSignatureDeclaration(param.parent) || isMethodSignature(param.parent) || isFunctionTypeNode(param.parent)) && param.parent.parameters.includes(param) && (resolveName(param, param.name.escapedText, SymbolFlagsType /*nameNotFoundMessage*/, nil /*isUse*/, true) || originalKeywordKind && isTypeNodeKind(originalKeywordKind)) {
					newName := "arg" + param.parent.parameters.indexOf(param)
					typeName := declarationNameToString(param.name) + (__COND__(param.dotDotDotToken, "[]", ""))
					errorOrSuggestion(noImplicitAny, declaration, Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1, newName, typeName)
					return
				}
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (declaration /* as ParameterDeclaration */).dotDotDotToken:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case noImplicitAny:
					diagnostic = Diagnostics.Rest_parameter_0_implicitly_has_an_any_type
				default:
					diagnostic = Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage
				}
			case noImplicitAny:
				diagnostic = Diagnostics.Parameter_0_implicitly_has_an_1_type
			default:
				diagnostic = Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage
			}
			break
		case SyntaxKindBindingElement:
			diagnostic = Diagnostics.Binding_element_0_implicitly_has_an_1_type
			if !noImplicitAny {
				// Don't issue a suggestion for binding elements since the codefix doesn't yet support them.
				return
			}
			break
		case SyntaxKindJSDocFunctionType:
			error(declaration, Diagnostics.Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString)
			return
		case SyntaxKindJSDocSignature:
			if noImplicitAny && isJSDocOverloadTag(declaration.parent) {
				error(declaration.parent.tagName, Diagnostics.This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation, typeAsString)
			}
			return
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMethodSignature:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindSetAccessor:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrowFunction:
			if noImplicitAny && !(declaration /* as NamedDeclaration */).name {
				if wideningKind == WideningKindGeneratorYield {
					error(declaration, Diagnostics.Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation, typeAsString)
				} else {
					error(declaration, Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString)
				}
				return
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !noImplicitAny:
				diagnostic = Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage
			case wideningKind == WideningKindGeneratorYield:
				diagnostic = Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type
			default:
				diagnostic = Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type
			}
			break
		case SyntaxKindMappedType:
			if noImplicitAny {
				error(declaration, Diagnostics.Mapped_object_type_implicitly_has_an_any_template_type)
			}
			return
		default:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case noImplicitAny:
				diagnostic = Diagnostics.Variable_0_implicitly_has_an_1_type
			default:
				diagnostic = Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage
			}
		}
		errorOrSuggestion(noImplicitAny, declaration, diagnostic, declarationNameToString(getNameOfDeclaration(declaration)), typeAsString)
	}
	reportErrorsFromWidening := func(declaration Declaration, type_ Type, wideningKind WideningKind) {
		addLazyDiagnostic(func() {
			if noImplicitAny && getObjectFlags(type_)&ObjectFlagsContainsWideningType && (!wideningKind || !getContextualSignatureForFunctionLikeDeclaration(declaration /* as FunctionLikeDeclaration */)) {
				// Report implicit any error within type if possible, otherwise report error on declaration
				if !reportWideningErrorsInType(type_) {
					reportImplicitAny(declaration, type_, wideningKind)
				}
			}
		})
	}
	applyToParameterTypes := func(source Signature, target Signature, callback func(s Type, t Type)) {
		sourceCount := getParameterCount(source)
		targetCount := getParameterCount(target)
		sourceRestType := getEffectiveRestType(source)
		targetRestType := getEffectiveRestType(target)
		var targetNonRestCount number
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case targetRestType:
			targetNonRestCount = targetCount - 1
		default:
			targetNonRestCount = targetCount
		}
		var paramCount number
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case sourceRestType:
			paramCount = targetNonRestCount
		default:
			paramCount = Math.min(sourceCount, targetNonRestCount)
		}
		sourceThisType := getThisTypeOfSignature(source)
		if sourceThisType {
			targetThisType := getThisTypeOfSignature(target)
			if targetThisType {
				callback(sourceThisType, targetThisType)
			}
		}
		for i := 0; i < paramCount; i++ {
			callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i))
		}
		if targetRestType {
			callback(getRestTypeAtPosition(source, paramCount /*readonly*/, isConstTypeVariable(targetRestType) && !someType(targetRestType, isMutableArrayLikeType)), targetRestType)
		}
	}
	applyToReturnTypes := func(source Signature, target Signature, callback func(s Type, t Type)) {
		targetTypePredicate := getTypePredicateOfSignature(target)
		if targetTypePredicate {
			sourceTypePredicate := getTypePredicateOfSignature(source)
			if sourceTypePredicate && typePredicateKindsMatch(sourceTypePredicate, targetTypePredicate) && sourceTypePredicate.type_ && targetTypePredicate.type_ {
				callback(sourceTypePredicate.type_, targetTypePredicate.type_)
				return
			}
		}
		targetReturnType := getReturnTypeOfSignature(target)
		if couldContainTypeVariables(targetReturnType) {
			callback(getReturnTypeOfSignature(source), targetReturnType)
		}
	}
	createInferenceContext := func(typeParameters []TypeParameter, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
		return createInferenceContextWorker(typeParameters.map_(createInferenceInfo), signature, flags, compareTypes || compareTypesAssignable)
	}
	cloneInferenceContext := func(context T, extraFlags InferenceFlags /*  = 0 */) /* TODO(TS-TO-GO) TypeNode UnionType: InferenceContext | T & undefined */ any {
		return context && createInferenceContextWorker(map_(context.inferences, cloneInferenceInfo), context.signature, context.flags|extraFlags, context.compareTypes)
	}
	createInferenceContextWorker := func(inferences []InferenceInfo, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
		var context InferenceContext = map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"inferences":      inferences,
			"signature":       signature,
			"flags":           flags,
			"compareTypes":    compareTypes,
			"mapper":          reportUnmeasurableMapper,
			"nonFixingMapper": reportUnmeasurableMapper,
		}
		context.mapper = makeFixingMapperForContext(context)
		context.nonFixingMapper = makeNonFixingMapperForContext(context)
		return context
	}
	makeFixingMapperForContext := func(context InferenceContext) TypeMapper {
		return makeDeferredTypeMapper(map_(context.inferences, func(i InferenceInfo) TypeParameter {
			return i.typeParameter
		}), map_(context.inferences, func(inference InferenceInfo, i number) /* TODO(TS-TO-GO) inferred type () => Type */ any {
			return func() Type {
				if !inference.isFixed {
					// Before we commit to a particular inference (and thus lock out any further inferences),
					// we infer from any intra-expression inference sites we have collected.
					inferFromIntraExpressionSites(context)
					clearCachedInferences(context.inferences)
					inference.isFixed = true
				}
				return getInferredType(context, i)
			}
		}))
	}
	makeNonFixingMapperForContext := func(context InferenceContext) TypeMapper {
		return makeDeferredTypeMapper(map_(context.inferences, func(i InferenceInfo) TypeParameter {
			return i.typeParameter
		}), map_(context.inferences, func(_ InferenceInfo, i number) /* TODO(TS-TO-GO) inferred type () => Type */ any {
			return func() Type {
				return getInferredType(context, i)
			}
		}))
	}
	clearCachedInferences := func(inferences []InferenceInfo) {
		for _, inference := range inferences {
			if !inference.isFixed {
				inference.inferredType = nil
			}
		}
	}
	addIntraExpressionInferenceSite := func(context InferenceContext, node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | MethodDeclaration */ any, type_ Type) {
		( /* TODO(TS-TO-GO) Node BinaryExpression: context.intraExpressionInferenceSites ??= [] */ TODO).push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"node":  node,
			"type_": type_,
		})
	}
	// We collect intra-expression inference sites within object and array literals to handle cases where
	// inferred types flow between context sensitive element expressions. For example:
	//
	//   declare function foo<T>(arg: [(n: number) => T, (x: T) => void]): void;
	//   foo([_a => 0, n => n.toFixed()]);
	//
	// Above, both arrow functions in the tuple argument are context sensitive, thus both are omitted from the
	// pass that collects inferences from the non-context sensitive parts of the arguments. In the subsequent
	// pass where nothing is omitted, we need to commit to an inference for T in order to contextually type the
	// parameter in the second arrow function, but we want to first infer from the return type of the first
	// arrow function. This happens automatically when the arrow functions are discrete arguments (because we
	// infer from each argument before processing the next), but when the arrow functions are elements of an
	// object or array literal, we need to perform intra-expression inferences early.
	inferFromIntraExpressionSites := func(context InferenceContext) {
		if context.intraExpressionInferenceSites {
			for _, TODO_IDENTIFIER := range context.intraExpressionInferenceSites {
				var contextualType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case node.kind == SyntaxKindMethodDeclaration:
					contextualType = getContextualTypeForObjectLiteralMethod(node /* as MethodDeclaration */, ContextFlagsNoConstraints)
				default:
					contextualType = getContextualType(node, ContextFlagsNoConstraints)
				}
				if contextualType {
					inferTypes(context.inferences, type_, contextualType)
				}
			}
			context.intraExpressionInferenceSites = nil
		}
	}
	createInferenceInfo := func(typeParameter TypeParameter) InferenceInfo {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"typeParameter":    typeParameter,
			"candidates":       nil,
			"contraCandidates": nil,
			"inferredType":     nil,
			"priority":         nil,
			"topLevel":         true,
			"isFixed":          false,
			"impliedArity":     nil,
		}
	}
	cloneInferenceInfo := func(inference InferenceInfo) InferenceInfo {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"typeParameter":    inference.typeParameter,
			"candidates":       inference.candidates && inference.candidates.slice(),
			"contraCandidates": inference.contraCandidates && inference.contraCandidates.slice(),
			"inferredType":     inference.inferredType,
			"priority":         inference.priority,
			"topLevel":         inference.topLevel,
			"isFixed":          inference.isFixed,
			"impliedArity":     inference.impliedArity,
		}
	}
	cloneInferredPartOfContext := func(context InferenceContext) *InferenceContext {
		inferences := filter(context.inferences, hasInferenceCandidates)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case inferences.length:
			return createInferenceContextWorker(map_(inferences, cloneInferenceInfo), context.signature, context.flags, context.compareTypes)
		default:
			return nil
		}
	}
	getMapperFromContext := func(context T) /* TODO(TS-TO-GO) TypeNode UnionType: TypeMapper | T & undefined */ any {
		return context && context.mapper
	}
	// Return true if the given type could possibly reference a type parameter for which
	// we perform type inference (i.e. a type parameter of a generic function). We cache
	// results for union and intersection types for performance reasons.
	couldContainTypeVariables := func(type_ Type) bool {
		objectFlags := getObjectFlags(type_)
		if objectFlags & ObjectFlagsCouldContainTypeVariablesComputed {
			return !!(objectFlags & ObjectFlagsCouldContainTypeVariables)
		}
		result := !!(type_.flags&TypeFlagsInstantiable || type_.flags&TypeFlagsObject && !isNonGenericTopLevelType(type_) && (objectFlags&ObjectFlagsReference && ((type_ /* as TypeReference */).node || some(getTypeArguments(type_ /* as TypeReference */), couldContainTypeVariables)) || objectFlags&ObjectFlagsSingleSignatureType && !!length((type_ /* as SingleSignatureType */).outerTypeParameters) || objectFlags&ObjectFlagsAnonymous && type_.symbol && type_.symbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod|SymbolFlagsClass|SymbolFlagsTypeLiteral|SymbolFlagsObjectLiteral) && type_.symbol.declarations || objectFlags&(ObjectFlagsMapped|ObjectFlagsReverseMapped|ObjectFlagsObjectRestType|ObjectFlagsInstantiationExpressionType)) || type_.flags&TypeFlagsUnionOrIntersection && !(type_.flags&TypeFlagsEnumLiteral) && !isNonGenericTopLevelType(type_) && some((type_ /* as UnionOrIntersectionType */).types, couldContainTypeVariables))
		if type_.flags & TypeFlagsObjectFlagsType {
			(type_ /* as ObjectFlagsType */).objectFlags |= ObjectFlagsCouldContainTypeVariablesComputed | (__COND__(result, ObjectFlagsCouldContainTypeVariables, 0))
		}
		return result
	}
	isNonGenericTopLevelType := func(type_ Type) bool {
		if type_.aliasSymbol && !type_.aliasTypeArguments {
			declaration := getDeclarationOfKind(type_.aliasSymbol, SyntaxKindTypeAliasDeclaration)
			return !!(declaration && findAncestor(declaration.parent, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case n.kind == SyntaxKindSourceFile:
					return true
				case n.kind == SyntaxKindModuleDeclaration:
					return false
				default:
					return "quit"
				}
			}))
		}
		return false
	}
	isTypeParameterAtTopLevel := func(type_ Type, tp TypeParameter, depth number /*  = 0 */) bool {
		return !!(type_ == tp || type_.flags&TypeFlagsUnionOrIntersection && some((type_ /* as UnionOrIntersectionType */).types, func(t Type) bool {
			return isTypeParameterAtTopLevel(t, tp, depth)
		}) || depth < 3 && type_.flags&TypeFlagsConditional && (isTypeParameterAtTopLevel(getTrueTypeFromConditionalType(type_ /* as ConditionalType */), tp, depth+1) || isTypeParameterAtTopLevel(getFalseTypeFromConditionalType(type_ /* as ConditionalType */), tp, depth+1)))
	}
	isTypeParameterAtTopLevelInReturnType := func(signature Signature, typeParameter TypeParameter) bool {
		typePredicate := getTypePredicateOfSignature(signature)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case typePredicate:
			return !!typePredicate.type_ && isTypeParameterAtTopLevel(typePredicate.type_, typeParameter)
		default:
			return isTypeParameterAtTopLevel(getReturnTypeOfSignature(signature), typeParameter)
		}
	}
	/** Create an object with properties named in the string literal type. Every property has type `any` */
	createEmptyObjectTypeFromStringLiteral := func(type_ Type) ResolvedType {
		members := createSymbolTable()
		forEachType(type_, func(t Type) {
			if !(t.flags & TypeFlagsStringLiteral) {
				return
			}
			name := escapeLeadingUnderscores((t /* as StringLiteralType */).value)
			literalProp := createSymbol(SymbolFlagsProperty, name)
			literalProp.links.type_ = anyType
			if t.symbol {
				literalProp.declarations = t.symbol.declarations
				literalProp.valueDeclaration = t.symbol.valueDeclaration
			}
			members.set(name, literalProp)
		})
		var indexInfos []IndexInfo
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsString:
			indexInfos = []IndexInfo{createIndexInfo(stringType, emptyObjectType /*isReadonly*/, false)}
		default:
			indexInfos = emptyArray
		}
		return createAnonymousType(nil, members, emptyArray, emptyArray, indexInfos)
	}
	/**
	 * Infer a suitable input type for a homomorphic mapped type { [P in keyof T]: X }. We construct
	 * an object type with the same set of properties as the source type, where the type of each
	 * property is computed by inferring from the source property type to X for the type
	 * variable T[P] (i.e. we treat the type T[P] as the type variable we're inferring for).
	 */
	inferTypeForHomomorphicMappedType := func(source Type, target MappedType, constraint IndexType) Type {
		cacheKey := source.id + "," + target.id + "," + constraint.id
		if reverseHomomorphicMappedCache.has(cacheKey) {
			return reverseHomomorphicMappedCache.get(cacheKey)
		}
		type_ := createReverseMappedType(source, target, constraint)
		reverseHomomorphicMappedCache.set(cacheKey, type_)
		return type_
	}
	// We consider a type to be partially inferable if it isn't marked non-inferable or if it is
	// an object literal type with at least one property of an inferable type. For example, an object
	// literal { a: 123, b: x => true } is marked non-inferable because it contains a context sensitive
	// arrow function, but is considered partially inferable because property 'a' has an inferable type.
	isPartiallyInferableType := func(type_ Type) bool {
		return !(getObjectFlags(type_) & ObjectFlagsNonInferrableType) || isObjectLiteralType(type_) && some(getPropertiesOfType(type_), func(prop Symbol) bool {
			return isPartiallyInferableType(getTypeOfSymbol(prop))
		}) || isTupleType(type_) && some(getElementTypes(type_), isPartiallyInferableType)
	}
	createReverseMappedType := func(source Type, target MappedType, constraint IndexType) Type {
		// We consider a source type reverse mappable if it has a string index signature or if
		// it has one or more properties and is of a partially inferable type.
		if !(getIndexInfoOfType(source, stringType) || getPropertiesOfType(source).length != 0 && isPartiallyInferableType(source)) {
			return nil
		}
		// For arrays and tuples we infer new arrays and tuples where the reverse mapping has been
		// applied to the element type(s).
		if isArrayType(source) {
			elementType := inferReverseMappedType(getTypeArguments(source)[0], target, constraint)
			if !elementType {
				return nil
			}
			return createArrayType(elementType, isReadonlyArrayType(source))
		}
		if isTupleType(source) {
			elementTypes := map_(getElementTypes(source), func(t Type) Type {
				return inferReverseMappedType(t, target, constraint)
			})
			if !every(elementTypes, func(t Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: t is Type */ any {
				return !!t
			}) {
				return nil
			}
			var elementFlags []ElementFlags
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case getMappedTypeModifiers(target) & MappedTypeModifiersIncludeOptional:
				elementFlags = sameMap(source.target.elementFlags, func(f ElementFlags) ElementFlags {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case f & ElementFlagsOptional:
						return ElementFlagsRequired
					default:
						return f
					}
				})
			default:
				elementFlags = source.target.elementFlags
			}
			return createTupleType(elementTypes, elementFlags, source.target.readonly, source.target.labeledElementDeclarations)
		}
		// For all other object types we infer a new object type where the reverse mapping has been
		// applied to the type of each property.
		reversed := createObjectType(ObjectFlagsReverseMapped|ObjectFlagsAnonymous /*symbol*/, nil) /* as ReverseMappedType */
		reversed.source = source
		reversed.mappedType = target
		reversed.constraintType = constraint
		return reversed
	}
	getTypeOfReverseMappedSymbol := func(symbol ReverseMappedSymbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			links.type_ = inferReverseMappedType(symbol.links.propertyType, symbol.links.mappedType, symbol.links.constraintType) || unknownType
		}
		return links.type_
	}
	inferReverseMappedTypeWorker := func(sourceType Type, target MappedType, constraint IndexType) Type {
		typeParameter := getIndexedAccessType(constraint.type_, getTypeParameterFromMappedType(target)) /* as TypeParameter */
		templateType := getTemplateTypeFromMappedType(target)
		inference := createInferenceInfo(typeParameter)
		inferTypes([]InferenceInfo{inference}, sourceType, templateType)
		return getTypeFromInference(inference) || unknownType
	}
	inferReverseMappedType := func(source Type, target MappedType, constraint IndexType) Type {
		cacheKey := source.id + "," + target.id + "," + constraint.id
		if reverseMappedCache.has(cacheKey) {
			return reverseMappedCache.get(cacheKey) || unknownType
		}
		reverseMappedSourceStack.push(source)
		reverseMappedTargetStack.push(target)
		saveExpandingFlags := reverseExpandingFlags
		if isDeeplyNestedType(source, reverseMappedSourceStack, reverseMappedSourceStack.length, 2) {
			reverseExpandingFlags |= ExpandingFlagsSource
		}
		if isDeeplyNestedType(target, reverseMappedTargetStack, reverseMappedTargetStack.length, 2) {
			reverseExpandingFlags |= ExpandingFlagsTarget
		}
		var type_ TODO
		if reverseExpandingFlags != ExpandingFlagsBoth {
			type_ = inferReverseMappedTypeWorker(source, target, constraint)
		}
		reverseMappedSourceStack.pop()
		reverseMappedTargetStack.pop()
		reverseExpandingFlags = saveExpandingFlags
		reverseMappedCache.set(cacheKey, type_)
		return type_
	}
	// TODO(TS-TO-GO): was generator
	getUnmatchedProperties := func(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) IterableIterator[Symbol] {
		properties := getPropertiesOfType(target)
		for _, targetProp := range properties {
			// TODO: remove this when we support static private identifier fields and find other solutions to get privateNamesAndStaticFields test to pass
			if isStaticPrivateIdentifierProperty(targetProp) {
				continue
			}
			if requireOptionalProperties || !(targetProp.flags&SymbolFlagsOptional || getCheckFlags(targetProp)&CheckFlagsPartial) {
				sourceProp := getPropertyOfType(source, targetProp.escapedName)
				if !sourceProp {
					yield(targetProp)
				} else if matchDiscriminantProperties {
					targetType := getTypeOfSymbol(targetProp)
					if targetType.flags & TypeFlagsUnit {
						sourceType := getTypeOfSymbol(sourceProp)
						if !(sourceType.flags&TypeFlagsAny || getRegularTypeOfLiteralType(sourceType) == getRegularTypeOfLiteralType(targetType)) {
							yield(targetProp)
						}
					}
				}
			}
		}
	}
	getUnmatchedProperty := func(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) Symbol {
		return firstOrUndefinedIterator(getUnmatchedProperties(source, target, requireOptionalProperties, matchDiscriminantProperties))
	}
	tupleTypesDefinitelyUnrelated := func(source TupleTypeReference, target TupleTypeReference) bool {
		return !(target.target.combinedFlags&ElementFlagsVariadic) && target.target.minLength > source.target.minLength || !(target.target.combinedFlags&ElementFlagsVariable) && (!!(source.target.combinedFlags&ElementFlagsVariable) || target.target.fixedLength < source.target.fixedLength)
	}
	typesDefinitelyUnrelated := func(source Type, target Type) bool {
		// Two tuple types with incompatible arities are definitely unrelated.
		// Two object types that each have a property that is unmatched in the other are definitely unrelated.
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isTupleType(source) && isTupleType(target):
			return tupleTypesDefinitelyUnrelated(source, target)
		default:
			return !!getUnmatchedProperty(source, target /*requireOptionalProperties*/, false /*matchDiscriminantProperties*/, true) && !!getUnmatchedProperty(target, source /*requireOptionalProperties*/, false /*matchDiscriminantProperties*/, false)
		}
	}
	getTypeFromInference := func(inference InferenceInfo) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case inference.candidates:
			return getUnionType(inference.candidates, UnionReductionSubtype)
		case inference.contraCandidates:
			return getIntersectionType(inference.contraCandidates)
		default:
			return nil
		}
	}
	hasSkipDirectInferenceFlag := func(node Node) bool {
		return !!getNodeLinks(node).skipDirectInference
	}
	isFromInferenceBlockedSource := func(type_ Type) bool {
		return !!(type_.symbol && some(type_.symbol.declarations, hasSkipDirectInferenceFlag))
	}
	templateLiteralTypesDefinitelyUnrelated := func(source TemplateLiteralType, target TemplateLiteralType) bool {
		// Two template literal types with diffences in their starting or ending text spans are definitely unrelated.
		sourceStart := source.texts[0]
		targetStart := target.texts[0]
		sourceEnd := source.texts[source.texts.length-1]
		targetEnd := target.texts[target.texts.length-1]
		startLen := Math.min(sourceStart.length, targetStart.length)
		endLen := Math.min(sourceEnd.length, targetEnd.length)
		return sourceStart.slice(0, startLen) != targetStart.slice(0, startLen) || sourceEnd.slice(sourceEnd.length-endLen) != targetEnd.slice(targetEnd.length-endLen)
	}
	/**
	 * Tests whether the provided string can be parsed as a number.
	 * @param s The string to test.
	 * @param roundTripOnly Indicates the resulting number matches the input when converted back to a string.
	 */
	isValidNumberString := func(s string, roundTripOnly bool) bool {
		if s == "" {
			return false
		}
		n := +s
		return isFinite(n) && (!roundTripOnly || ""+n == s)
	}
	/**
	 * @param text a valid bigint string excluding a trailing `n`, but including a possible prefix `-`. Use `isValidBigIntString(text, roundTripOnly)` before calling this function.
	 */
	parseBigIntLiteralType := func(text string) BigIntLiteralType {
		return getBigIntLiteralType(parseValidBigInt(text))
	}
	isMemberOfStringMapping := func(source Type, target Type) bool {
		if target.flags & TypeFlagsAny {
			return true
		}
		if target.flags & (TypeFlagsString | TypeFlagsTemplateLiteral) {
			return isTypeAssignableTo(source, target)
		}
		if target.flags & TypeFlagsStringMapping {
			// We need to see whether applying the same mappings of the target
			// onto the source would produce an identical type *and* that
			// it's compatible with the inner-most non-string-mapped type.
			//
			// The intuition here is that if same mappings don't affect the source at all,
			// and the source is compatible with the unmapped target, then they must
			// still reside in the same domain.
			mappingStack := []never{}
			for target.flags & TypeFlagsStringMapping {
				mappingStack.unshift(target.symbol)
				target = (target /* as StringMappingType */).type_
			}
			mappedSource := reduceLeft(mappingStack, func(memo Type, value Symbol) Type {
				return getStringMappingType(value, memo)
			}, source)
			return mappedSource == source && isMemberOfStringMapping(source, target)
		}
		return false
	}
	isValidTypeForTemplateLiteralPlaceholder := func(source Type, target Type) bool {
		if target.flags & TypeFlagsIntersection {
			return every((target /* as IntersectionType */).types, func(t Type) bool {
				return t == emptyTypeLiteralType || isValidTypeForTemplateLiteralPlaceholder(source, t)
			})
		}
		if target.flags&TypeFlagsString || isTypeAssignableTo(source, target) {
			return true
		}
		if source.flags & TypeFlagsStringLiteral {
			value := (source /* as StringLiteralType */).value
			return !!(target.flags&TypeFlagsNumber && isValidNumberString(value /*roundTripOnly*/, false) || target.flags&TypeFlagsBigInt && isValidBigIntString(value /*roundTripOnly*/, false) || target.flags&(TypeFlagsBooleanLiteral|TypeFlagsNullable) && value == (target /* as IntrinsicType */).intrinsicName || target.flags&TypeFlagsStringMapping && isMemberOfStringMapping(getStringLiteralType(value), target) || target.flags&TypeFlagsTemplateLiteral && isTypeMatchedByTemplateLiteralType(source, target /* as TemplateLiteralType */))
		}
		if source.flags & TypeFlagsTemplateLiteral {
			texts := (source /* as TemplateLiteralType */).texts
			return texts.length == 2 && texts[0] == "" && texts[1] == "" && isTypeAssignableTo((source /* as TemplateLiteralType */).types[0], target)
		}
		return false
	}
	inferTypesFromTemplateLiteralType := func(source Type, target TemplateLiteralType) *[]Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case source.flags & TypeFlagsStringLiteral:
			return inferFromLiteralPartsToTemplateLiteral([]string{(source /* as StringLiteralType */).value}, emptyArray, target)
		case source.flags & TypeFlagsTemplateLiteral:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case arrayIsEqualTo((source /* as TemplateLiteralType */).texts, target.texts):
				return map_((source /* as TemplateLiteralType */).types, func(s Type, i number) Type {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isTypeAssignableTo(getBaseConstraintOrType(s), getBaseConstraintOrType(target.types[i])):
						return s
					default:
						return getStringLikeTypeForType(s)
					}
				})
			default:
				return inferFromLiteralPartsToTemplateLiteral((source /* as TemplateLiteralType */).texts, (source /* as TemplateLiteralType */).types, target)
			}
		default:
			return nil
		}
	}
	isTypeMatchedByTemplateLiteralType := func(source Type, target TemplateLiteralType) bool {
		inferences := inferTypesFromTemplateLiteralType(source, target)
		return !!inferences && every(inferences, func(r Type, i number) bool {
			return isValidTypeForTemplateLiteralPlaceholder(r, target.types[i])
		})
	}
	getStringLikeTypeForType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & (TypeFlagsAny | TypeFlagsStringLike):
			return type_
		default:
			return getTemplateLiteralType([]string{"", ""}, []Type{type_})
		}
	}
	// This function infers from the text parts and type parts of a source literal to a target template literal. The number
	// of text parts is always one more than the number of type parts, and a source string literal is treated as a source
	// with one text part and zero type parts. The function returns an array of inferred string or template literal types
	// corresponding to the placeholders in the target template literal, or undefined if the source doesn't match the target.
	//
	// We first check that the starting source text part matches the starting target text part, and that the ending source
	// text part ends matches the ending target text part. We then iterate through the remaining target text parts, finding
	// a match for each in the source and inferring string or template literal types created from the segments of the source
	// that occur between the matches. During this iteration, seg holds the index of the current text part in the sourceTexts
	// array and pos holds the current character position in the current text part.
	//
	// Consider inference from type `<<${string}>.<${number}-${number}>>` to type `<${string}.${string}>`, i.e.
	//   sourceTexts = ['<<', '>.<', '-', '>>']
	//   sourceTypes = [string, number, number]
	//   target.texts = ['<', '.', '>']
	// We first match '<' in the target to the start of '<<' in the source and '>' in the target to the end of '>>' in
	// the source. The first match for the '.' in target occurs at character 1 in the source text part at index 1, and thus
	// the first inference is the template literal type `<${string}>`. The remainder of the source makes up the second
	// inference, the template literal type `<${number}-${number}>`.
	inferFromLiteralPartsToTemplateLiteral := func(sourceTexts []string, sourceTypes []Type, target TemplateLiteralType) *[]Type {
		lastSourceIndex := sourceTexts.length - 1
		sourceStartText := sourceTexts[0]
		sourceEndText := sourceTexts[lastSourceIndex]
		targetTexts := target.texts
		lastTargetIndex := targetTexts.length - 1
		targetStartText := targetTexts[0]
		targetEndText := targetTexts[lastTargetIndex]
		if lastSourceIndex == 0 && sourceStartText.length < targetStartText.length+targetEndText.length || !sourceStartText.startsWith(targetStartText) || !sourceEndText.endsWith(targetEndText) {
			return nil
		}
		remainingEndText := sourceEndText.slice(0, sourceEndText.length-targetEndText.length)
		var matches []Type = []never{}
		seg := 0
		pos := targetStartText.length
		for i := 1; i < lastTargetIndex; i++ {
			delim := targetTexts[i]
			if delim.length > 0 {
				s := seg
				p := pos
				for true {
					p = getSourceText(s).indexOf(delim, p)
					if p >= 0 {
						break
					}
					s++
					if s == sourceTexts.length {
						return nil
					}
					p = 0
				}
				addMatch(s, p)
				pos += delim.length
			} else if pos < getSourceText(seg).length {
				addMatch(seg, pos+1)
			} else if seg < lastSourceIndex {
				addMatch(seg+1, 0)
			} else {
				return nil
			}
		}
		addMatch(lastSourceIndex, getSourceText(lastSourceIndex).length)
		return matches
		getSourceText := func(index number) string {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case index < lastSourceIndex:
				return sourceTexts[index]
			default:
				return remainingEndText
			}
		}
		addMatch := func(s number, p number) {
			var matchType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case s == seg:
				matchType = getStringLiteralType(getSourceText(s).slice(pos, p))
			default:
				matchType = getTemplateLiteralType([]string{sourceTexts[seg].slice(pos) /* TODO(TS-TO-GO) Node SpreadElement: ...sourceTexts.slice(seg + 1, s) */, getSourceText(s).slice(0, p)}, sourceTypes.slice(seg, s))
			}
			matches.push(matchType)
			seg = s
			pos = p
		}
	}
	/**
	 * @returns `true` if `type` has the shape `[T[0]]` where `T` is `typeParameter`
	 */
	isTupleOfSelf := func(typeParameter TypeParameter, type_ Type) bool {
		return isTupleType(type_) && getTupleElementType(type_, 0) == getIndexedAccessType(typeParameter, getNumberLiteralType(0)) && !getTypeOfPropertyOfType(type_, "1" /* as __String */)
	}
	inferTypes := func(inferences []InferenceInfo, originalSource Type, originalTarget Type, priority InferencePriority /*  = InferencePriority.None */, contravariant bool /*  = false */) {
		bivariant := false
		var propagationType Type
		var inferencePriority number = InferencePriorityMaxValue
		var visited Map[string, number]
		var sourceStack []Type
		var targetStack []Type
		expandingFlags := ExpandingFlagsNone
		inferFromTypes(originalSource, originalTarget)
		inferFromTypes := func(source Type, target Type) {
			if !couldContainTypeVariables(target) || isNoInferType(target) {
				return
			}
			if source == wildcardType || source == blockedStringType {
				// We are inferring from an 'any' type. We want to infer this type for every type parameter
				// referenced in the target type, so we record it as the propagation type and infer from the
				// target to itself. Then, as we find candidates we substitute the propagation type.
				savePropagationType := propagationType
				propagationType = source
				inferFromTypes(target, target)
				propagationType = savePropagationType
				return
			}
			if source.aliasSymbol && source.aliasSymbol == target.aliasSymbol {
				if source.aliasTypeArguments {
					// Source and target are types originating in the same generic type alias declaration.
					// Simply infer from source type arguments to target type arguments, with defaults applied.
					params := getSymbolLinks(source.aliasSymbol).typeParameters
					minParams := getMinTypeArgumentCount(params)
					sourceTypes := fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
					targetTypes := fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
					inferFromTypeArguments(sourceTypes, targetTypes, getAliasVariances(source.aliasSymbol))
				}
				// And if there weren't any type arguments, there's no reason to run inference as the types must be the same.
				return
			}
			if source == target && source.flags&TypeFlagsUnionOrIntersection {
				// When source and target are the same union or intersection type, just relate each constituent
				// type to itself.
				for _, t := range (source /* as UnionOrIntersectionType */).types {
					inferFromTypes(t, t)
				}
				return
			}
			if target.flags & TypeFlagsUnion {
				// First, infer between identically matching source and target constituents and remove the
				// matching types.
				TODO_IDENTIFIER := inferFromMatchingTypes(__COND__(source.flags&TypeFlagsUnion, (source /* as UnionType */).types, []Type{source}), (target /* as UnionType */).types, isTypeOrBaseIdenticalTo)
				// Next, infer between closely matching source and target constituents and remove
				// the matching types. Types closely match when they are instantiations of the same
				// object type or instantiations of the same type alias.
				TODO_IDENTIFIER := inferFromMatchingTypes(tempSources, tempTargets, isTypeCloselyMatchedBy)
				if targets.length == 0 {
					return
				}
				target = getUnionType(targets)
				if sources.length == 0 {
					// All source constituents have been matched and there is nothing further to infer from.
					// However, simply making no inferences is undesirable because it could ultimately mean
					// inferring a type parameter constraint. Instead, make a lower priority inference from
					// the full source to whatever remains in the target. For example, when inferring from
					// string to 'string | T', make a lower priority inference of string for T.
					inferWithPriority(source, target, InferencePriorityNakedTypeVariable)
					return
				}
				source = getUnionType(sources)
			} else if target.flags&TypeFlagsIntersection && !every((target /* as IntersectionType */).types, isNonGenericObjectType) {
				// We reduce intersection types unless they're simple combinations of object types. For example,
				// when inferring from 'string[] & { extra: any }' to 'string[] & T' we want to remove string[] and
				// infer { extra: any } for T. But when inferring to 'string[] & Iterable<T>' we want to keep the
				// string[] on the source side and infer string for T.
				if !(source.flags & TypeFlagsUnion) {
					// Infer between identically matching source and target constituents and remove the matching types.
					TODO_IDENTIFIER := inferFromMatchingTypes(__COND__(source.flags&TypeFlagsIntersection, (source /* as IntersectionType */).types, []Type{source}), (target /* as IntersectionType */).types, isTypeIdenticalTo)
					if sources.length == 0 || targets.length == 0 {
						return
					}
					source = getIntersectionType(sources)
					target = getIntersectionType(targets)
				}
			}
			if target.flags & (TypeFlagsIndexedAccess | TypeFlagsSubstitution) {
				if isNoInferType(target) {
					return
				}
				target = getActualTypeVariable(target)
			}
			if target.flags & TypeFlagsTypeVariable {
				// Skip inference if the source is "blocked", which is used by the language service to
				// prevent inference on nodes currently being edited.
				if isFromInferenceBlockedSource(source) {
					return
				}
				inference := getInferenceInfoForType(target)
				if inference {
					// If target is a type parameter, make an inference, unless the source type contains
					// a "non-inferrable" type. Types with this flag set are markers used to prevent inference.
					//
					// For example:
					//     - anyFunctionType is a wildcard type that's used to avoid contextually typing functions;
					//       it's internal, so should not be exposed to the user by adding it as a candidate.
					//     - autoType (and autoArrayType) is a special "any" used in control flow; like anyFunctionType,
					//       it's internal and should not be observable.
					//     - silentNeverType is returned by getInferredType when instantiating a generic function for
					//       inference (and a type variable has no mapping).
					//
					// This flag is infectious; if we produce Box<never> (where never is silentNeverType), Box<never> is
					// also non-inferrable.
					//
					// As a special case, also ignore nonInferrableAnyType, which is a special form of the any type
					// used as a stand-in for binding elements when they are being inferred.
					if getObjectFlags(source)&ObjectFlagsNonInferrableType || source == nonInferrableAnyType {
						return
					}
					if !inference.isFixed {
						candidate := propagationType || source
						if candidate == blockedStringType {
							return
						}
						if inference.priority == nil || priority < inference.priority {
							inference.candidates = nil
							inference.contraCandidates = nil
							inference.topLevel = true
							inference.priority = priority
						}
						if priority == inference.priority {
							// Inferring A to [A[0]] is a zero information inference (it guarantees A becomes its constraint), but oft arises from generic argument list inferences
							// By discarding it early, we can allow more fruitful results to be used instead.
							if isTupleOfSelf(inference.typeParameter, candidate) {
								return
							}
							// We make contravariant inferences only if we are in a pure contravariant position,
							// i.e. only if we have not descended into a bivariant position.
							if contravariant && !bivariant {
								if !contains(inference.contraCandidates, candidate) {
									inference.contraCandidates = append(inference.contraCandidates, candidate)
									clearCachedInferences(inferences)
								}
							} else if !contains(inference.candidates, candidate) {
								inference.candidates = append(inference.candidates, candidate)
								clearCachedInferences(inferences)
							}
						}
						if !(priority & InferencePriorityReturnType) && target.flags&TypeFlagsTypeParameter && inference.topLevel && !isTypeParameterAtTopLevel(originalTarget, target /* as TypeParameter */) {
							inference.topLevel = false
							clearCachedInferences(inferences)
						}
					}
					inferencePriority = Math.min(inferencePriority, priority)
					return
				}
				// Infer to the simplified version of an indexed access, if possible, to (hopefully) expose more bare type parameters to the inference engine
				simplified := getSimplifiedType(target /*writing*/, false)
				if simplified != target {
					inferFromTypes(source, simplified)
				} else if target.flags & TypeFlagsIndexedAccess {
					indexType := getSimplifiedType((target /* as IndexedAccessType */).indexType /*writing*/, false)
					// Generally simplifications of instantiable indexes are avoided to keep relationship checking correct, however if our target is an access, we can consider
					// that key of that access to be "instantiated", since we're looking to find the infernce goal in any way we can.
					if indexType.flags & TypeFlagsInstantiable {
						simplified := distributeIndexOverObjectType(getSimplifiedType((target /* as IndexedAccessType */).objectType /*writing*/, false), indexType /*writing*/, false)
						if simplified && simplified != target {
							inferFromTypes(source, simplified)
						}
					}
				}
			}
			if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && ((source /* as TypeReference */).target == (target /* as TypeReference */).target || isArrayType(source) && isArrayType(target)) && !((source /* as TypeReference */).node && (target /* as TypeReference */).node) {
				// If source and target are references to the same generic type, infer from type arguments
				inferFromTypeArguments(getTypeArguments(source /* as TypeReference */), getTypeArguments(target /* as TypeReference */), getVariances((source /* as TypeReference */).target))
			} else if source.flags&TypeFlagsIndex && target.flags&TypeFlagsIndex {
				inferFromContravariantTypes((source /* as IndexType */).type_, (target /* as IndexType */).type_)
			} else if (isLiteralType(source) || source.flags&TypeFlagsString) && target.flags&TypeFlagsIndex {
				empty := createEmptyObjectTypeFromStringLiteral(source)
				inferFromContravariantTypesWithPriority(empty, (target /* as IndexType */).type_, InferencePriorityLiteralKeyof)
			} else if source.flags&TypeFlagsIndexedAccess && target.flags&TypeFlagsIndexedAccess {
				inferFromTypes((source /* as IndexedAccessType */).objectType, (target /* as IndexedAccessType */).objectType)
				inferFromTypes((source /* as IndexedAccessType */).indexType, (target /* as IndexedAccessType */).indexType)
			} else if source.flags&TypeFlagsStringMapping && target.flags&TypeFlagsStringMapping {
				if (source /* as StringMappingType */).symbol == (target /* as StringMappingType */).symbol {
					inferFromTypes((source /* as StringMappingType */).type_, (target /* as StringMappingType */).type_)
				}
			} else if source.flags & TypeFlagsSubstitution {
				inferFromTypes((source /* as SubstitutionType */).baseType, target)
				inferWithPriority(getSubstitutionIntersection(source /* as SubstitutionType */), target, InferencePrioritySubstituteSource)
				// Make substitute inference at a lower priority
			} else if target.flags & TypeFlagsConditional {
				invokeOnce(source, target /* as ConditionalType */, inferToConditionalType)
			} else if target.flags & TypeFlagsUnionOrIntersection {
				inferToMultipleTypes(source, (target /* as UnionOrIntersectionType */).types, target.flags)
			} else if source.flags & TypeFlagsUnion {
				// Source is a union or intersection type, infer from each constituent type
				sourceTypes := (source /* as UnionOrIntersectionType */).types
				for _, sourceType := range sourceTypes {
					inferFromTypes(sourceType, target)
				}
			} else if target.flags & TypeFlagsTemplateLiteral {
				inferToTemplateLiteralType(source, target /* as TemplateLiteralType */)
			} else {
				source = getReducedType(source)
				if isGenericMappedType(source) && isGenericMappedType(target) {
					invokeOnce(source, target, inferFromGenericMappedTypes)
				}
				if !(priority&InferencePriorityNoConstraints && source.flags&(TypeFlagsIntersection|TypeFlagsInstantiable)) {
					apparentSource := getApparentType(source)
					// getApparentType can return _any_ type, since an indexed access or conditional may simplify to any other type.
					// If that occurs and it doesn't simplify to an object or intersection, we'll need to restart `inferFromTypes`
					// with the simplified source.
					if apparentSource != source && !(apparentSource.flags & (TypeFlagsObject | TypeFlagsIntersection)) {
						return inferFromTypes(apparentSource, target)
					}
					source = apparentSource
				}
				if source.flags & (TypeFlagsObject | TypeFlagsIntersection) {
					invokeOnce(source, target, inferFromObjectTypes)
				}
			}
		}
		inferWithPriority := func(source Type, target Type, newPriority InferencePriority) {
			savePriority := priority
			priority |= newPriority
			inferFromTypes(source, target)
			priority = savePriority
		}
		inferFromContravariantTypesWithPriority := func(source Type, target Type, newPriority InferencePriority) {
			savePriority := priority
			priority |= newPriority
			inferFromContravariantTypes(source, target)
			priority = savePriority
		}
		inferToMultipleTypesWithPriority := func(source Type, targets []Type, targetFlags TypeFlags, newPriority InferencePriority) {
			savePriority := priority
			priority |= newPriority
			inferToMultipleTypes(source, targets, targetFlags)
			priority = savePriority
		}
		// Ensure an inference action is performed only once for the given source and target types.
		// This includes two things:
		// Avoiding inferring between the same pair of source and target types,
		// and avoiding circularly inferring between source and target types.
		// For an example of the last, consider if we are inferring between source type
		// `type Deep<T> = { next: Deep<Deep<T>> }` and target type `type Loop<U> = { next: Loop<U> }`.
		// We would then infer between the types of the `next` property: `Deep<Deep<T>>` = `{ next: Deep<Deep<Deep<T>>> }` and `Loop<U>` = `{ next: Loop<U> }`.
		// We will then infer again between the types of the `next` property:
		// `Deep<Deep<Deep<T>>>` and `Loop<U>`, and so on, such that we would be forever inferring
		// between instantiations of the same types `Deep` and `Loop`.
		// In particular, we would be inferring from increasingly deep instantiations of `Deep` to `Loop`,
		// such that we would go on inferring forever, even though we would never infer
		// between the same pair of types.
		invokeOnce := func(source Source, target Target, action func(source Source, target Target)) {
			key := source.id + "," + target.id
			status := visited && visited.get(key)
			if status != nil {
				inferencePriority = Math.min(inferencePriority, status)
				return
			}
			(visited || ( /* TODO(TS-TO-GO) Node BinaryExpression: visited = new Map<string, number>() */ TODO)).set(key, InferencePriorityCircularity)
			saveInferencePriority := inferencePriority
			inferencePriority = InferencePriorityMaxValue
			// We stop inferring and report a circularity if we encounter duplicate recursion identities on both
			// the source side and the target side.
			saveExpandingFlags := expandingFlags
			( /* TODO(TS-TO-GO) Node BinaryExpression: sourceStack ??= [] */ TODO).push(source)
			( /* TODO(TS-TO-GO) Node BinaryExpression: targetStack ??= [] */ TODO).push(target)
			if isDeeplyNestedType(source, sourceStack, sourceStack.length, 2) {
				expandingFlags |= ExpandingFlagsSource
			}
			if isDeeplyNestedType(target, targetStack, targetStack.length, 2) {
				expandingFlags |= ExpandingFlagsTarget
			}
			if expandingFlags != ExpandingFlagsBoth {
				action(source, target)
			} else {
				inferencePriority = InferencePriorityCircularity
			}
			targetStack.pop()
			sourceStack.pop()
			expandingFlags = saveExpandingFlags
			visited.set(key, inferencePriority)
			inferencePriority = Math.min(inferencePriority, saveInferencePriority)
		}
		inferFromMatchingTypes := func(sources []Type, targets []Type, matches func(s Type, t Type) bool) /* TODO(TS-TO-GO) TypeNode TupleType: [Type[], Type[]] */ any {
			var matchedSources *[]Type
			var matchedTargets *[]Type
			for _, t := range targets {
				for _, s := range sources {
					if matches(s, t) {
						inferFromTypes(s, t)
						matchedSources = appendIfUnique(matchedSources, s)
						matchedTargets = appendIfUnique(matchedTargets, t)
					}
				}
			}
			return []any{__COND__(matchedSources, filter(sources, func(t Type) bool {
				return !contains(matchedSources, t)
			}), sources), __COND__(matchedTargets, filter(targets, func(t Type) bool {
				return !contains(matchedTargets, t)
			}), targets)}
		}
		inferFromTypeArguments := func(sourceTypes []Type, targetTypes []Type, variances []VarianceFlags) {
			var count number
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case sourceTypes.length < targetTypes.length:
				count = sourceTypes.length
			default:
				count = targetTypes.length
			}
			for i := 0; i < count; i++ {
				if i < variances.length && (variances[i]&VarianceFlagsVarianceMask) == VarianceFlagsContravariant {
					inferFromContravariantTypes(sourceTypes[i], targetTypes[i])
				} else {
					inferFromTypes(sourceTypes[i], targetTypes[i])
				}
			}
		}
		inferFromContravariantTypes := func(source Type, target Type) {
			contravariant = !contravariant
			inferFromTypes(source, target)
			contravariant = !contravariant
		}
		inferFromContravariantTypesIfStrictFunctionTypes := func(source Type, target Type) {
			if strictFunctionTypes || priority&InferencePriorityAlwaysStrict {
				inferFromContravariantTypes(source, target)
			} else {
				inferFromTypes(source, target)
			}
		}
		getInferenceInfoForType := func(type_ Type) *InferenceInfo {
			if type_.flags & TypeFlagsTypeVariable {
				for _, inference := range inferences {
					if type_ == inference.typeParameter {
						return inference
					}
				}
			}
			return nil
		}
		getSingleTypeVariableFromIntersectionTypes := func(types []Type) Type {
			var typeVariable Type
			for _, type_ := range types {
				t := type_.flags&TypeFlagsIntersection && find((type_ /* as IntersectionType */).types, func(t Type) bool {
					return !!getInferenceInfoForType(t)
				})
				if !t || typeVariable && t != typeVariable {
					return nil
				}
				typeVariable = t
			}
			return typeVariable
		}
		inferToMultipleTypes := func(source Type, targets []Type, targetFlags TypeFlags) {
			typeVariableCount := 0
			if targetFlags & TypeFlagsUnion {
				var nakedTypeVariable Type
				var sources []Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case source.flags & TypeFlagsUnion:
					sources = (source /* as UnionType */).types
				default:
					sources = []Type{source}
				}
				matched := NewArray[bool](sources.length)
				inferenceCircularity := false
				// First infer to types that are not naked type variables. For each source type we
				// track whether inferences were made from that particular type to some target with
				// equal priority (i.e. of equal quality) to what we would infer for a naked type
				// parameter.
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						nakedTypeVariable = t
						typeVariableCount++
					} else {
						for i := 0; i < sources.length; i++ {
							saveInferencePriority := inferencePriority
							inferencePriority = InferencePriorityMaxValue
							inferFromTypes(sources[i], t)
							if inferencePriority == priority {
								matched[i] = true
							}
							inferenceCircularity = inferenceCircularity || inferencePriority == InferencePriorityCircularity
							inferencePriority = Math.min(inferencePriority, saveInferencePriority)
						}
					}
				}
				if typeVariableCount == 0 {
					// If every target is an intersection of types containing a single naked type variable,
					// make a lower priority inference to that type variable. This handles inferring from
					// 'A | B' to 'T & (X | Y)' where we want to infer 'A | B' for T.
					intersectionTypeVariable := getSingleTypeVariableFromIntersectionTypes(targets)
					if intersectionTypeVariable {
						inferWithPriority(source, intersectionTypeVariable, InferencePriorityNakedTypeVariable)
					}
					return
				}
				// If the target has a single naked type variable and no inference circularities were
				// encountered above (meaning we explored the types fully), create a union of the source
				// types from which no inferences have been made so far and infer from that union to the
				// naked type variable.
				if typeVariableCount == 1 && !inferenceCircularity {
					unmatched := flatMap(sources, func(s Type, i number) Type {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case matched[i]:
							return nil
						default:
							return s
						}
					})
					if unmatched.length {
						inferFromTypes(getUnionType(unmatched), nakedTypeVariable)
						return
					}
				}
			} else {
				// We infer from types that are not naked type variables first so that inferences we
				// make from nested naked type variables and given slightly higher priority by virtue
				// of being first in the candidates array.
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						typeVariableCount++
					} else {
						inferFromTypes(source, t)
					}
				}
			}
			// Inferences directly to naked type variables are given lower priority as they are
			// less specific. For example, when inferring from Promise<string> to T | Promise<T>,
			// we want to infer string for T, not Promise<string> | string. For intersection types
			// we only infer to single naked type variables.
			if __COND__(targetFlags&TypeFlagsIntersection, typeVariableCount == 1, typeVariableCount > 0) {
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						inferWithPriority(source, t, InferencePriorityNakedTypeVariable)
					}
				}
			}
		}
		inferToMappedType := func(source Type, target MappedType, constraintType Type) bool {
			if (constraintType.flags & TypeFlagsUnion) || (constraintType.flags & TypeFlagsIntersection) {
				result := false
				for _, type_ := range (constraintType /* as (UnionType | IntersectionType) */).types {
					result = inferToMappedType(source, target, type_) || result
				}
				return result
			}
			if constraintType.flags & TypeFlagsIndex {
				// We're inferring from some source type S to a homomorphic mapped type { [P in keyof T]: X },
				// where T is a type variable. Use inferTypeForHomomorphicMappedType to infer a suitable source
				// type and then make a secondary inference from that type to T. We make a secondary inference
				// such that direct inferences to T get priority over inferences to Partial<T>, for example.
				inference := getInferenceInfoForType((constraintType /* as IndexType */).type_)
				if inference && !inference.isFixed && !isFromInferenceBlockedSource(source) {
					inferredType := inferTypeForHomomorphicMappedType(source, target, constraintType /* as IndexType */)
					if inferredType {
						// We assign a lower priority to inferences made from types containing non-inferrable
						// types because we may only have a partial result (i.e. we may have failed to make
						// reverse inferences for some properties).
						inferWithPriority(inferredType, inference.typeParameter, __COND__(getObjectFlags(source)&ObjectFlagsNonInferrableType, InferencePriorityPartialHomomorphicMappedType, InferencePriorityHomomorphicMappedType))
					}
				}
				return true
			}
			if constraintType.flags & TypeFlagsTypeParameter {
				// We're inferring from some source type S to a mapped type { [P in K]: X }, where K is a type
				// parameter. First infer from 'keyof S' to K.
				inferWithPriority(getIndexType(source /*indexFlags*/, __COND__(!!source.pattern, IndexFlagsNoIndexSignatures, IndexFlagsNone)), constraintType, InferencePriorityMappedTypeConstraint)
				// If K is constrained to a type C, also infer to C. Thus, for a mapped type { [P in K]: X },
				// where K extends keyof T, we make the same inferences as for a homomorphic mapped type
				// { [P in keyof T]: X }. This enables us to make meaningful inferences when the target is a
				// Pick<T, K>.
				extendedConstraint := getConstraintOfType(constraintType)
				if extendedConstraint && inferToMappedType(source, target, extendedConstraint) {
					return true
				}
				// If no inferences can be made to K's constraint, infer from a union of the property types
				// in the source to the template type X.
				propTypes := map_(getPropertiesOfType(source), getTypeOfSymbol)
				indexTypes := map_(getIndexInfosOfType(source), func(info IndexInfo) Type {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case info != enumNumberIndexInfo:
						return info.type_
					default:
						return neverType
					}
				})
				inferFromTypes(getUnionType(concatenate(propTypes, indexTypes)), getTemplateTypeFromMappedType(target))
				return true
			}
			return false
		}
		inferToConditionalType := func(source Type, target ConditionalType) {
			if source.flags & TypeFlagsConditional {
				inferFromTypes((source /* as ConditionalType */).checkType, target.checkType)
				inferFromTypes((source /* as ConditionalType */).extendsType, target.extendsType)
				inferFromTypes(getTrueTypeFromConditionalType(source /* as ConditionalType */), getTrueTypeFromConditionalType(target))
				inferFromTypes(getFalseTypeFromConditionalType(source /* as ConditionalType */), getFalseTypeFromConditionalType(target))
			} else {
				targetTypes := []Type{getTrueTypeFromConditionalType(target), getFalseTypeFromConditionalType(target)}
				inferToMultipleTypesWithPriority(source, targetTypes, target.flags, __COND__(contravariant, InferencePriorityContravariantConditional, 0))
			}
		}
		inferToTemplateLiteralType := func(source Type, target TemplateLiteralType) {
			matches := inferTypesFromTemplateLiteralType(source, target)
			types := target.types
			// When the target template literal contains only placeholders (meaning that inference is intended to extract
			// single characters and remainder strings) and inference fails to produce matches, we want to infer 'never' for
			// each placeholder such that instantiation with the inferred value(s) produces 'never', a type for which an
			// assignment check will fail. If we make no inferences, we'll likely end up with the constraint 'string' which,
			// upon instantiation, would collapse all the placeholders to just 'string', and an assignment check might
			// succeed. That would be a pointless and confusing outcome.
			if matches || every(target.texts, func(s string) bool {
				return s.length == 0
			}) {
				for i := 0; i < types.length; i++ {
					var source Type
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case matches:
						source = matches[i]
					default:
						source = neverType
					}
					target := types[i]
					// If we are inferring from a string literal type to a type variable whose constraint includes one of the
					// allowed template literal placeholder types, infer from a literal type corresponding to the constraint.
					if source.flags&TypeFlagsStringLiteral && target.flags&TypeFlagsTypeVariable {
						inferenceContext := getInferenceInfoForType(target)
						var constraint Type
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case inferenceContext:
							constraint = getBaseConstraintOfType(inferenceContext.typeParameter)
						default:
							constraint = nil
						}
						if constraint && !isTypeAny(constraint) {
							var constraintTypes []Type
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case constraint.flags & TypeFlagsUnion:
								constraintTypes = (constraint /* as UnionType */).types
							default:
								constraintTypes = []Type{constraint}
							}
							var allTypeFlags TypeFlags = reduceLeft(constraintTypes, func(flags TypeFlags, t Type) number {
								return flags | t.flags
							}, 0 /* as TypeFlags */)
							// If the constraint contains `string`, we don't need to look for a more preferred type
							if !(allTypeFlags & TypeFlagsString) {
								str := (source /* as StringLiteralType */).value
								// If the type contains `number` or a number literal and the string isn't a valid number, exclude numbers
								if allTypeFlags&TypeFlagsNumberLike && !isValidNumberString(str /*roundTripOnly*/, true) {
									allTypeFlags &= ~TypeFlagsNumberLike
								}
								// If the type contains `bigint` or a bigint literal and the string isn't a valid bigint, exclude bigints
								if allTypeFlags&TypeFlagsBigIntLike && !isValidBigIntString(str /*roundTripOnly*/, true) {
									allTypeFlags &= ~TypeFlagsBigIntLike
								}
								// for each type in the constraint, find the highest priority matching type
								matchingType := reduceLeft(constraintTypes, func(left Type, right Type) Type {
									// TODO(TS-TO-GO): converted from conditional expression
									switch {
									case !(right.flags & allTypeFlags):
										return left
									case left.flags & TypeFlagsString:
										return left
									case right.flags & TypeFlagsString:
										return source
									case left.flags & TypeFlagsTemplateLiteral:
										return left
									case right.flags&TypeFlagsTemplateLiteral && isTypeMatchedByTemplateLiteralType(source, right /* as TemplateLiteralType */):
										return source
									case left.flags & TypeFlagsStringMapping:
										return left
									case right.flags&TypeFlagsStringMapping && str == applyStringMapping(right.symbol, str):
										return source
									case left.flags & TypeFlagsStringLiteral:
										return left
									case right.flags&TypeFlagsStringLiteral && (right /* as StringLiteralType */).value == str:
										return right
									case left.flags & TypeFlagsNumber:
										return left
									case right.flags & TypeFlagsNumber:
										return getNumberLiteralType(+str)
									case left.flags & TypeFlagsEnum:
										return left
									case right.flags & TypeFlagsEnum:
										return getNumberLiteralType(+str)
									case left.flags & TypeFlagsNumberLiteral:
										return left
									case right.flags&TypeFlagsNumberLiteral && (right /* as NumberLiteralType */).value == +str:
										return right
									case left.flags & TypeFlagsBigInt:
										return left
									case right.flags & TypeFlagsBigInt:
										return parseBigIntLiteralType(str)
									case left.flags & TypeFlagsBigIntLiteral:
										return left
									case right.flags&TypeFlagsBigIntLiteral && pseudoBigIntToString((right /* as BigIntLiteralType */).value) == str:
										return right
									case left.flags & TypeFlagsBoolean:
										return left
									case right.flags & TypeFlagsBoolean:
										// TODO(TS-TO-GO): converted from conditional expression
										switch {
										case str == "true":
											return trueType
										case str == "false":
											return falseType
										default:
											return booleanType
										}
									case left.flags & TypeFlagsBooleanLiteral:
										return left
									case right.flags&TypeFlagsBooleanLiteral && (right /* as IntrinsicType */).intrinsicName == str:
										return right
									case left.flags & TypeFlagsUndefined:
										return left
									case right.flags&TypeFlagsUndefined && (right /* as IntrinsicType */).intrinsicName == str:
										return right
									case left.flags & TypeFlagsNull:
										return left
									case right.flags&TypeFlagsNull && (right /* as IntrinsicType */).intrinsicName == str:
										return right
									default:
										return left
									}
								}, neverType /* as Type */)
								if !(matchingType.flags & TypeFlagsNever) {
									inferFromTypes(matchingType, target)
									continue
								}
							}
						}
					}
					inferFromTypes(source, target)
				}
			}
		}
		inferFromGenericMappedTypes := func(source MappedType, target MappedType) {
			// The source and target types are generic types { [P in S]: X } and { [P in T]: Y }, so we infer
			// from S to T and from X to Y.
			inferFromTypes(getConstraintTypeFromMappedType(source), getConstraintTypeFromMappedType(target))
			inferFromTypes(getTemplateTypeFromMappedType(source), getTemplateTypeFromMappedType(target))
			sourceNameType := getNameTypeFromMappedType(source)
			targetNameType := getNameTypeFromMappedType(target)
			if sourceNameType && targetNameType {
				inferFromTypes(sourceNameType, targetNameType)
			}
		}
		inferFromObjectTypes := func(source Type, target Type) {
			if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && ((source /* as TypeReference */).target == (target /* as TypeReference */).target || isArrayType(source) && isArrayType(target)) {
				// If source and target are references to the same generic type, infer from type arguments
				inferFromTypeArguments(getTypeArguments(source /* as TypeReference */), getTypeArguments(target /* as TypeReference */), getVariances((source /* as TypeReference */).target))
				return
			}
			if isGenericMappedType(source) && isGenericMappedType(target) {
				inferFromGenericMappedTypes(source, target)
			}
			if getObjectFlags(target)&ObjectFlagsMapped && !(target /* as MappedType */).declaration.nameType {
				constraintType := getConstraintTypeFromMappedType(target /* as MappedType */)
				if inferToMappedType(source, target /* as MappedType */, constraintType) {
					return
				}
			}
			// Infer from the members of source and target only if the two types are possibly related
			if !typesDefinitelyUnrelated(source, target) {
				if isArrayOrTupleType(source) {
					if isTupleType(target) {
						sourceArity := getTypeReferenceArity(source)
						targetArity := getTypeReferenceArity(target)
						elementTypes := getTypeArguments(target)
						elementFlags := target.target.elementFlags
						// When source and target are tuple types with the same structure (fixed, variadic, and rest are matched
						// to the same kind in each position), simply infer between the element types.
						if isTupleType(source) && isTupleTypeStructureMatching(source, target) {
							for i := 0; i < targetArity; i++ {
								inferFromTypes(getTypeArguments(source)[i], elementTypes[i])
							}
							return
						}
						var startLength number
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isTupleType(source):
							startLength = Math.min(source.target.fixedLength, target.target.fixedLength)
						default:
							startLength = 0
						}
						endLength := Math.min(__COND__(isTupleType(source), getEndElementCount(source.target, ElementFlagsFixed), 0), __COND__(target.target.combinedFlags&ElementFlagsVariable, getEndElementCount(target.target, ElementFlagsFixed), 0))
						// Infer between starting fixed elements.
						for i := 0; i < startLength; i++ {
							inferFromTypes(getTypeArguments(source)[i], elementTypes[i])
						}
						if !isTupleType(source) || sourceArity-startLength-endLength == 1 && source.target.elementFlags[startLength]&ElementFlagsRest {
							// Single rest element remains in source, infer from that to every element in target
							restType := getTypeArguments(source)[startLength]
							for i := startLength; i < targetArity-endLength; i++ {
								inferFromTypes(__COND__(elementFlags[i]&ElementFlagsVariadic, createArrayType(restType), restType), elementTypes[i])
							}
						} else {
							middleLength := targetArity - startLength - endLength
							if middleLength == 2 {
								if elementFlags[startLength] & elementFlags[startLength+1] & ElementFlagsVariadic {
									// Middle of target is [...T, ...U] and source is tuple type
									targetInfo := getInferenceInfoForType(elementTypes[startLength])
									if targetInfo && targetInfo.impliedArity != nil {
										// Infer slices from source based on implied arity of T.
										inferFromTypes(sliceTupleType(source, startLength, endLength+sourceArity-targetInfo.impliedArity), elementTypes[startLength])
										inferFromTypes(sliceTupleType(source, startLength+targetInfo.impliedArity, endLength), elementTypes[startLength+1])
									}
								} else if elementFlags[startLength]&ElementFlagsVariadic && elementFlags[startLength+1]&ElementFlagsRest {
									// Middle of target is [...T, ...rest] and source is tuple type
									// if T is constrained by a fixed-size tuple we might be able to use its arity to infer T
									param := getInferenceInfoForType(elementTypes[startLength]). /* TODO(TS-TO-GO): was ? */ typeParameter
									constraint := param && getBaseConstraintOfType(param)
									if constraint && isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlagsVariable) {
										impliedArity := constraint.target.fixedLength
										inferFromTypes(sliceTupleType(source, startLength, sourceArity-(startLength+impliedArity)), elementTypes[startLength])
										inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength+impliedArity, endLength), elementTypes[startLength+1])
									}
								} else if elementFlags[startLength]&ElementFlagsRest && elementFlags[startLength+1]&ElementFlagsVariadic {
									// Middle of target is [...rest, ...T] and source is tuple type
									// if T is constrained by a fixed-size tuple we might be able to use its arity to infer T
									param := getInferenceInfoForType(elementTypes[startLength+1]). /* TODO(TS-TO-GO): was ? */ typeParameter
									constraint := param && getBaseConstraintOfType(param)
									if constraint && isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlagsVariable) {
										impliedArity := constraint.target.fixedLength
										endIndex := sourceArity - getEndElementCount(target.target, ElementFlagsFixed)
										startIndex := endIndex - impliedArity
										trailingSlice := createTupleType(getTypeArguments(source).slice(startIndex, endIndex), source.target.elementFlags.slice(startIndex, endIndex) /*readonly*/, false, source.target.labeledElementDeclarations && source.target.labeledElementDeclarations.slice(startIndex, endIndex))
										inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength, endLength+impliedArity), elementTypes[startLength])
										inferFromTypes(trailingSlice, elementTypes[startLength+1])
									}
								}
							} else if middleLength == 1 && elementFlags[startLength]&ElementFlagsVariadic {
								// Middle of target is exactly one variadic element. Infer the slice between the fixed parts in the source.
								// If target ends in optional element(s), make a lower priority a speculative inference.
								endsInOptional := target.target.elementFlags[targetArity-1] & ElementFlagsOptional
								sourceSlice := sliceTupleType(source, startLength, endLength)
								inferWithPriority(sourceSlice, elementTypes[startLength], __COND__(endsInOptional, InferencePrioritySpeculativeTuple, 0))
							} else if middleLength == 1 && elementFlags[startLength]&ElementFlagsRest {
								// Middle of target is exactly one rest element. If middle of source is not empty, infer union of middle element types.
								restType := getElementTypeOfSliceOfTupleType(source, startLength, endLength)
								if restType {
									inferFromTypes(restType, elementTypes[startLength])
								}
							}
						}
						// Infer between ending fixed elements
						for i := 0; i < endLength; i++ {
							inferFromTypes(getTypeArguments(source)[sourceArity-i-1], elementTypes[targetArity-i-1])
						}
						return
					}
					if isArrayType(target) {
						inferFromIndexTypes(source, target)
						return
					}
				}
				inferFromProperties(source, target)
				inferFromSignatures(source, target, SignatureKindCall)
				inferFromSignatures(source, target, SignatureKindConstruct)
				inferFromIndexTypes(source, target)
			}
		}
		inferFromProperties := func(source Type, target Type) {
			properties := getPropertiesOfObjectType(target)
			for _, targetProp := range properties {
				sourceProp := getPropertyOfType(source, targetProp.escapedName)
				if sourceProp && !some(sourceProp.declarations, hasSkipDirectInferenceFlag) {
					inferFromTypes(removeMissingType(getTypeOfSymbol(sourceProp), !!(sourceProp.flags&SymbolFlagsOptional)), removeMissingType(getTypeOfSymbol(targetProp), !!(targetProp.flags&SymbolFlagsOptional)))
				}
			}
		}
		inferFromSignatures := func(source Type, target Type, kind SignatureKind) {
			sourceSignatures := getSignaturesOfType(source, kind)
			sourceLen := sourceSignatures.length
			if sourceLen > 0 {
				// We match source and target signatures from the bottom up, and if the source has fewer signatures
				// than the target, we infer from the first source signature to the excess target signatures.
				targetSignatures := getSignaturesOfType(target, kind)
				targetLen := targetSignatures.length
				for i := 0; i < targetLen; i++ {
					sourceIndex := Math.max(sourceLen-targetLen+i, 0)
					inferFromSignature(getBaseSignature(sourceSignatures[sourceIndex]), getErasedSignature(targetSignatures[i]))
				}
			}
		}
		inferFromSignature := func(source Signature, target Signature) {
			if !(source.flags & SignatureFlagsIsNonInferrable) {
				saveBivariant := bivariant
				var kind /* TODO(TS-TO-GO) inferred type SyntaxKind.Unknown | SyntaxKind.MethodSignature | SyntaxKind.MethodDeclaration | SyntaxKind.Constructor | SyntaxKind.GetAccessor | SyntaxKind.SetAccessor | SyntaxKind.CallSignature | SyntaxKind.ConstructSignature | SyntaxKind.IndexSignature | SyntaxKind.FunctionType | SyntaxKind.ConstructorType | SyntaxKind.FunctionExpression | SyntaxKind.ArrowFunction | SyntaxKind.FunctionDeclaration | SyntaxKind.JSDocFunctionType | SyntaxKind.JSDocSignature */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case target.declaration:
					kind = target.declaration.kind
				default:
					kind = SyntaxKindUnknown
				}
				// Once we descend into a bivariant signature we remain bivariant for all nested inferences
				bivariant = bivariant || kind == SyntaxKindMethodDeclaration || kind == SyntaxKindMethodSignature || kind == SyntaxKindConstructor
				applyToParameterTypes(source, target, inferFromContravariantTypesIfStrictFunctionTypes)
				bivariant = saveBivariant
			}
			applyToReturnTypes(source, target, inferFromTypes)
		}
		inferFromIndexTypes := func(source Type, target Type) {
			// Inferences across mapped type index signatures are pretty much the same a inferences to homomorphic variables
			var priority /* TODO(TS-TO-GO) inferred type 0 | InferencePriority.HomomorphicMappedType */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (getObjectFlags(source) & getObjectFlags(target) & ObjectFlagsMapped):
				priority = InferencePriorityHomomorphicMappedType
			default:
				priority = 0
			}
			indexInfos := getIndexInfosOfType(target)
			if isObjectTypeWithInferableIndex(source) {
				for _, targetInfo := range indexInfos {
					var propTypes []Type = []never{}
					for _, prop := range getPropertiesOfType(source) {
						if isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique), targetInfo.keyType) {
							propType := getTypeOfSymbol(prop)
							propTypes.push(__COND__(prop.flags&SymbolFlagsOptional, removeMissingOrUndefinedType(propType), propType))
						}
					}
					for _, info := range getIndexInfosOfType(source) {
						if isApplicableIndexType(info.keyType, targetInfo.keyType) {
							propTypes.push(info.type_)
						}
					}
					if propTypes.length {
						inferWithPriority(getUnionType(propTypes), targetInfo.type_, priority)
					}
				}
			}
			for _, targetInfo := range indexInfos {
				sourceInfo := getApplicableIndexInfo(source, targetInfo.keyType)
				if sourceInfo {
					inferWithPriority(sourceInfo.type_, targetInfo.type_, priority)
				}
			}
		}
	}
	isTypeOrBaseIdenticalTo := func(s Type, t Type) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case t == missingType:
			return s == t
		default:
			return (isTypeIdenticalTo(s, t) || !!(t.flags&TypeFlagsString && s.flags&TypeFlagsStringLiteral || t.flags&TypeFlagsNumber && s.flags&TypeFlagsNumberLiteral))
		}
	}
	isTypeCloselyMatchedBy := func(s Type, t Type) bool {
		return !!(s.flags&TypeFlagsObject && t.flags&TypeFlagsObject && s.symbol && s.symbol == t.symbol || s.aliasSymbol && s.aliasTypeArguments && s.aliasSymbol == t.aliasSymbol)
	}
	hasPrimitiveConstraint := func(type_ TypeParameter) bool {
		constraint := getConstraintOfTypeParameter(type_)
		return !!constraint && maybeTypeOfKind(__COND__(constraint.flags&TypeFlagsConditional, getDefaultConstraintOfConditionalType(constraint /* as ConditionalType */), constraint), TypeFlagsPrimitive|TypeFlagsIndex|TypeFlagsTemplateLiteral|TypeFlagsStringMapping)
	}
	isObjectLiteralType := func(type_ Type) bool {
		return !!(getObjectFlags(type_) & ObjectFlagsObjectLiteral)
	}
	isObjectOrArrayLiteralType := func(type_ Type) bool {
		return !!(getObjectFlags(type_) & (ObjectFlagsObjectLiteral | ObjectFlagsArrayLiteral))
	}
	unionObjectAndArrayLiteralCandidates := func(candidates []Type) []Type {
		if candidates.length > 1 {
			objectLiterals := filter(candidates, isObjectOrArrayLiteralType)
			if objectLiterals.length {
				literalsType := getUnionType(objectLiterals, UnionReductionSubtype)
				return concatenate(filter(candidates, func(t Type) bool {
					return !isObjectOrArrayLiteralType(t)
				}), []Type{literalsType})
			}
		}
		return candidates
	}
	getContravariantInference := func(inference InferenceInfo) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case inference.priority & InferencePriorityPriorityImpliesCombination:
			return getIntersectionType(inference.contraCandidates)
		default:
			return getCommonSubtype(inference.contraCandidates)
		}
	}
	getCovariantInference := func(inference InferenceInfo, signature Signature) Type {
		// Extract all object and array literal types and replace them with a single widened and normalized type.
		candidates := unionObjectAndArrayLiteralCandidates(inference.candidates)
		// We widen inferred literal types if
		// all inferences were made to top-level occurrences of the type parameter, and
		// the type parameter has no constraint or its constraint includes no primitive or literal types, and
		// the type parameter was fixed during inference or does not occur at top-level in the return type.
		primitiveConstraint := hasPrimitiveConstraint(inference.typeParameter) || isConstTypeVariable(inference.typeParameter)
		widenLiteralTypes := !primitiveConstraint && inference.topLevel && (inference.isFixed || !isTypeParameterAtTopLevelInReturnType(signature, inference.typeParameter))
		var baseCandidates []Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case primitiveConstraint:
			baseCandidates = sameMap(candidates, getRegularTypeOfLiteralType)
		case widenLiteralTypes:
			baseCandidates = sameMap(candidates, getWidenedLiteralType)
		default:
			baseCandidates = candidates
		}
		// If all inferences were made from a position that implies a combined result, infer a union type.
		// Otherwise, infer a common supertype.
		var unwidenedType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case inference.priority & InferencePriorityPriorityImpliesCombination:
			unwidenedType = getUnionType(baseCandidates, UnionReductionSubtype)
		default:
			unwidenedType = getCommonSupertype(baseCandidates)
		}
		return getWidenedType(unwidenedType)
	}
	getInferredType := func(context InferenceContext, index number) Type {
		inference := context.inferences[index]
		if !inference.inferredType {
			var inferredType Type
			var fallbackType Type
			if context.signature {
				var inferredCovariantType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case inference.candidates:
					inferredCovariantType = getCovariantInference(inference, context.signature)
				default:
					inferredCovariantType = nil
				}
				var inferredContravariantType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case inference.contraCandidates:
					inferredContravariantType = getContravariantInference(inference)
				default:
					inferredContravariantType = nil
				}
				if inferredCovariantType || inferredContravariantType {
					// If we have both co- and contra-variant inferences, we prefer the co-variant inference if it is not 'never',
					// all co-variant inferences are assignable to it (i.e. it isn't one of a conflicting set of candidates), it is
					// assignable to some contra-variant inference, and no other type parameter is constrained to this type parameter
					// and has inferences that would conflict. Otherwise, we prefer the contra-variant inference.
					// Similarly ignore co-variant `any` inference when both are available as almost everything is assignable to it
					// and it would spoil the overall inference.
					preferCovariantType := inferredCovariantType && (!inferredContravariantType || !(inferredCovariantType.flags&(TypeFlagsNever|TypeFlagsAny)) && some(inference.contraCandidates, func(t Type) bool {
						return isTypeAssignableTo(inferredCovariantType, t)
					}) && every(context.inferences, func(other InferenceInfo) bool {
						return other != inference && getConstraintOfTypeParameter(other.typeParameter) != inference.typeParameter || every(other.candidates, func(t Type) bool {
							return isTypeAssignableTo(t, inferredCovariantType)
						})
					}))
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case preferCovariantType:
						inferredType = inferredCovariantType
					default:
						inferredType = inferredContravariantType
					}
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case preferCovariantType:
						fallbackType = inferredContravariantType
					default:
						fallbackType = inferredCovariantType
					}
				} else if context.flags & InferenceFlagsNoDefault {
					// We use silentNeverType as the wildcard that signals no inferences.
					inferredType = silentNeverType
				} else {
					// Infer either the default or the empty object type when no inferences were
					// made. It is important to remember that in this case, inference still
					// succeeds, meaning there is no error for not having inference candidates. An
					// inference error only occurs when there are *conflicting* candidates, i.e.
					// candidates with no common supertype.
					defaultType := getDefaultFromTypeParameter(inference.typeParameter)
					if defaultType {
						// Instantiate the default type. Any forward reference to a type
						// parameter should be instantiated to the empty object type.
						inferredType = instantiateType(defaultType, mergeTypeMappers(createBackreferenceMapper(context, index), context.nonFixingMapper))
					}
				}
			} else {
				inferredType = getTypeFromInference(inference)
			}
			inference.inferredType = inferredType || getDefaultTypeArgumentType(!!(context.flags & InferenceFlagsAnyDefault))
			constraint := getConstraintOfTypeParameter(inference.typeParameter)
			if constraint {
				instantiatedConstraint := instantiateType(constraint, context.nonFixingMapper)
				if !inferredType || !context.compareTypes(inferredType, getTypeWithThisArgument(instantiatedConstraint, inferredType)) {
					// If the fallback type satisfies the constraint, we pick it. Otherwise, we pick the constraint.
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case fallbackType && context.compareTypes(fallbackType, getTypeWithThisArgument(instantiatedConstraint, fallbackType)):
						inference.inferredType = fallbackType
					default:
						inference.inferredType = instantiatedConstraint
					}
				}
			}
		}
		return inference.inferredType
	}
	getDefaultTypeArgumentType := func(isInJavaScriptFile bool) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isInJavaScriptFile:
			return anyType
		default:
			return unknownType
		}
	}
	getInferredTypes := func(context InferenceContext) []Type {
		var result []Type = []never{}
		for i := 0; i < context.inferences.length; i++ {
			result.push(getInferredType(context, i))
		}
		return result
	}
	// EXPRESSION TYPE CHECKING
	getCannotFindNameDiagnosticForName := func(node Identifier) DiagnosticMessage {
		switch node.escapedText {
		case "document":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "console":
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom
		case "$":
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case compilerOptions.types:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig
			default:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery
			}
		case "describe":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "suite":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "it":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "test":
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case compilerOptions.types:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig
			default:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha
			}
		case "process":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "require":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Buffer":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "module":
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case compilerOptions.types:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig
			default:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode
			}
		case "Bun":
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case compilerOptions.types:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun_and_then_add_bun_to_the_types_field_in_your_tsconfig
			default:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun
			}
		case "Map":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Set":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Promise":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Symbol":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "WeakMap":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "WeakSet":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Iterator":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "AsyncIterator":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "SharedArrayBuffer":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Atomics":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "AsyncIterable":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "AsyncIterableIterator":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "AsyncGenerator":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "AsyncGeneratorFunction":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "BigInt":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Reflect":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "BigInt64Array":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "BigUint64Array":
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later
		case "await":
			if isCallExpression(node.parent) {
				return Diagnostics.Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function
			}
			fallthrough
		default:
			if node.parent.kind == SyntaxKindShorthandPropertyAssignment {
				return Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer
			} else {
				return Diagnostics.Cannot_find_name_0
			}
		}
	}
	getResolvedSymbol := func(node Identifier) Symbol {
		links := getNodeLinks(node)
		if !links.resolvedSymbol {
			links.resolvedSymbol = !nodeIsMissing(node) && resolveName(node, node, SymbolFlagsValue|SymbolFlagsExportValue, getCannotFindNameDiagnosticForName(node), !isWriteOnlyAccess(node), false) || unknownSymbol
		}
		return links.resolvedSymbol
	}
	isInAmbientOrTypeNode := func(node Node) bool {
		return !!(node.flags&NodeFlagsAmbient || findAncestor(node, func(n Node) bool {
			return isInterfaceDeclaration(n) || isTypeAliasDeclaration(n) || isTypeLiteralNode(n)
		}))
	}
	// Return the flow cache key for a "dotted name" (i.e. a sequence of identifiers
	// separated by dots). The key consists of the id of the symbol referenced by the
	// leftmost identifier followed by zero or more property names separated by dots.
	// The result is undefined if the reference isn't a dotted name.
	getFlowCacheKey := func(node Node, declaredType Type, initialType Type, flowContainer Node) *string {
		switch node.kind {
		case SyntaxKindIdentifier:
			if !isThisInTypeQuery(node) {
				symbol := getResolvedSymbol(node /* as Identifier */)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case symbol != unknownSymbol:
					return __TEMPLATE__(__COND__(flowContainer, getNodeId(flowContainer), "-1"), "|", getTypeId(declaredType), "|", getTypeId(initialType), "|", getSymbolId(symbol))
				default:
					return nil
				}
			}
			fallthrough
		case SyntaxKindThisKeyword:
			return __TEMPLATE__("0|", __COND__(flowContainer, getNodeId(flowContainer), "-1"), "|", getTypeId(declaredType), "|", getTypeId(initialType))
		case SyntaxKindNonNullExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindParenthesizedExpression:
			return getFlowCacheKey((node /* as NonNullExpression | ParenthesizedExpression */).expression, declaredType, initialType, flowContainer)
		case SyntaxKindQualifiedName:
			left := getFlowCacheKey((node /* as QualifiedName */).left, declaredType, initialType, flowContainer)
			return left && __TEMPLATE__(left, ".", (node /* as QualifiedName */).right.escapedText)
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindElementAccessExpression:
			propName := getAccessedPropertyName(node /* as AccessExpression */)
			if propName != nil {
				key := getFlowCacheKey((node /* as AccessExpression */).expression, declaredType, initialType, flowContainer)
				return key && __TEMPLATE__(key, ".", propName)
			}
			if isElementAccessExpression(node) && isIdentifier(node.argumentExpression) {
				symbol := getResolvedSymbol(node.argumentExpression)
				if isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol) {
					key := getFlowCacheKey((node /* as AccessExpression */).expression, declaredType, initialType, flowContainer)
					return key && __TEMPLATE__(key, ".@", getSymbolId(symbol))
				}
			}
			break
		case SyntaxKindObjectBindingPattern:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrayBindingPattern:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMethodDeclaration:
			return __TEMPLATE__(getNodeId(node), "#", getTypeId(declaredType))
		}
		return nil
	}
	isMatchingReference := func(source Node, target Node) bool {
		switch target.kind {
		case SyntaxKindParenthesizedExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNonNullExpression:
			return isMatchingReference(source, (target /* as NonNullExpression | ParenthesizedExpression */).expression)
		case SyntaxKindBinaryExpression:
			return (isAssignmentExpression(target) && isMatchingReference(source, target.left)) || (isBinaryExpression(target) && target.operatorToken.kind == SyntaxKindCommaToken && isMatchingReference(source, target.right))
		}
		switch source.kind {
		case SyntaxKindMetaProperty:
			return target.kind == SyntaxKindMetaProperty && (source /* as MetaProperty */).keywordToken == (target /* as MetaProperty */).keywordToken && (source /* as MetaProperty */).name.escapedText == (target /* as MetaProperty */).name.escapedText
		case SyntaxKindIdentifier:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPrivateIdentifier:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isThisInTypeQuery(source):
				return target.kind == SyntaxKindThisKeyword
			default:
				return target.kind == SyntaxKindIdentifier && getResolvedSymbol(source /* as Identifier */) == getResolvedSymbol(target /* as Identifier */) || (isVariableDeclaration(target) || isBindingElement(target)) && getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(source /* as Identifier */)) == getSymbolOfDeclaration(target)
			}
		case SyntaxKindThisKeyword:
			return target.kind == SyntaxKindThisKeyword
		case SyntaxKindSuperKeyword:
			return target.kind == SyntaxKindSuperKeyword
		case SyntaxKindNonNullExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindParenthesizedExpression:
			return isMatchingReference((source /* as NonNullExpression | ParenthesizedExpression */).expression, target)
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindElementAccessExpression:
			sourcePropertyName := getAccessedPropertyName(source /* as AccessExpression */)
			if sourcePropertyName != nil {
				var targetPropertyName *__String
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isAccessExpression(target):
					targetPropertyName = getAccessedPropertyName(target)
				default:
					targetPropertyName = nil
				}
				if targetPropertyName != nil {
					return targetPropertyName == sourcePropertyName && isMatchingReference((source /* as AccessExpression */).expression, (target /* as AccessExpression */).expression)
				}
			}
			if isElementAccessExpression(source) && isElementAccessExpression(target) && isIdentifier(source.argumentExpression) && isIdentifier(target.argumentExpression) {
				symbol := getResolvedSymbol(source.argumentExpression)
				if symbol == getResolvedSymbol(target.argumentExpression) && (isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol)) {
					return isMatchingReference(source.expression, target.expression)
				}
			}
			break
		case SyntaxKindQualifiedName:
			return isAccessExpression(target) && (source /* as QualifiedName */).right.escapedText == getAccessedPropertyName(target) && isMatchingReference((source /* as QualifiedName */).left, target.expression)
		case SyntaxKindBinaryExpression:
			return (isBinaryExpression(source) && source.operatorToken.kind == SyntaxKindCommaToken && isMatchingReference(source.right, target))
		}
		return false
	}
	getAccessedPropertyName := func(access /* TODO(TS-TO-GO) TypeNode UnionType: AccessExpression | BindingElement | ParameterDeclaration */ any) *__String {
		if isPropertyAccessExpression(access) {
			return access.name.escapedText
		}
		if isElementAccessExpression(access) {
			return tryGetElementAccessExpressionName(access)
		}
		if isBindingElement(access) {
			name := getDestructuringPropertyName(access)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case name:
				return escapeLeadingUnderscores(name)
			default:
				return nil
			}
		}
		if isParameter(access) {
			return ("" + access.parent.parameters.indexOf(access)) /* as __String */
		}
		return nil
	}
	tryGetNameFromType := func(type_ Type) *__String {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUniqueESSymbol:
			return (type_ /* as UniqueESSymbolType */).escapedName
		case type_.flags & TypeFlagsStringOrNumberLiteral:
			return escapeLeadingUnderscores("" + (type_ /* as StringLiteralType | NumberLiteralType */).value)
		default:
			return nil
		}
	}
	tryGetElementAccessExpressionName := func(node ElementAccessExpression) *__String {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isStringOrNumericLiteralLike(node.argumentExpression):
			return escapeLeadingUnderscores(node.argumentExpression.text)
		case isEntityNameExpression(node.argumentExpression):
			return tryGetNameFromEntityNameExpression(node.argumentExpression)
		default:
			return nil
		}
	}
	tryGetNameFromEntityNameExpression := func(node EntityNameOrEntityNameExpression) *__String {
		symbol := resolveEntityName(node, SymbolFlagsValue /*ignoreErrors*/, true)
		if !symbol || !(isConstantVariable(symbol) || (symbol.flags & SymbolFlagsEnumMember)) {
			return nil
		}
		declaration := symbol.valueDeclaration
		if declaration == nil {
			return nil
		}
		type_ := tryGetTypeFromEffectiveTypeNode(declaration)
		if type_ {
			name := tryGetNameFromType(type_)
			if name != nil {
				return name
			}
		}
		if hasOnlyExpressionInitializer(declaration) && isBlockScopedNameDeclaredBeforeUse(declaration, node) {
			initializer := getEffectiveInitializer(declaration)
			if initializer {
				var initializerType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isBindingPattern(declaration.parent):
					initializerType = getTypeForBindingElement(declaration /* as BindingElement */)
				default:
					initializerType = getTypeOfExpression(initializer)
				}
				return initializerType && tryGetNameFromType(initializerType)
			}
			if isEnumMember(declaration) {
				return getTextOfPropertyName(declaration.name)
			}
		}
		return nil
	}
	containsMatchingReference := func(source Node, target Node) bool {
		for isAccessExpression(source) {
			source = source.expression
			if isMatchingReference(source, target) {
				return true
			}
		}
		return false
	}
	optionalChainContainsReference := func(source Node, target Node) bool {
		for isOptionalChain(source) {
			source = source.expression
			if isMatchingReference(source, target) {
				return true
			}
		}
		return false
	}
	isDiscriminantProperty := func(type_ Type, name __String) bool {
		if type_ && type_.flags&TypeFlagsUnion {
			prop := getUnionOrIntersectionProperty(type_ /* as UnionType */, name)
			if prop && getCheckFlags(prop)&CheckFlagsSyntheticProperty {
				// NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.SyntheticProperty
				if (prop /* as TransientSymbol */).links.isDiscriminantProperty == nil {
					(prop /* as TransientSymbol */).links.isDiscriminantProperty = ((prop /* as TransientSymbol */).links.checkFlags&CheckFlagsDiscriminant) == CheckFlagsDiscriminant && !isGenericType(getTypeOfSymbol(prop))
				}
				return !!(prop /* as TransientSymbol */).links.isDiscriminantProperty
			}
		}
		return false
	}
	findDiscriminantProperties := func(sourceProperties []Symbol, target Type) *[]Symbol {
		var result *[]Symbol
		for _, sourceProperty := range sourceProperties {
			if isDiscriminantProperty(target, sourceProperty.escapedName) {
				if result {
					result.push(sourceProperty)
					continue
				}
				result = []Symbol{sourceProperty}
			}
		}
		return result
	}
	// Given a set of constituent types and a property name, create and return a map keyed by the literal
	// types of the property by that name in each constituent type. No map is returned if some key property
	// has a non-literal type or if less than 10 or less than 50% of the constituents have a unique key.
	// Entries with duplicate keys have unknownType as the value.
	mapTypesByKeyProperty := func(types []Type, name __String) *Map[number, Type] {
		map_ := NewMap[TypeId, Type]()
		count := 0
		for _, type_ := range types {
			if type_.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsInstantiableNonPrimitive) {
				discriminant := getTypeOfPropertyOfType(type_, name)
				if discriminant {
					if !isLiteralType(discriminant) {
						return nil
					}
					duplicate := false
					forEachType(discriminant, func(t Type) {
						id := getTypeId(getRegularTypeOfLiteralType(t))
						existing := map_.get(id)
						if !existing {
							map_.set(id, type_)
						} else if existing != unknownType {
							map_.set(id, unknownType)
							duplicate = true
						}
					})
					if !duplicate {
						count++
					}
				}
			}
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case count >= 10 && count*2 >= types.length:
			return map_
		default:
			return nil
		}
	}
	// Return the name of a discriminant property for which it was possible and feasible to construct a map of
	// constituent types keyed by the literal types of the property by that name in each constituent type.
	getKeyPropertyName := func(unionType UnionType) *__String {
		types := unionType.types
		// We only construct maps for unions with many non-primitive constituents.
		if types.length < 10 || getObjectFlags(unionType)&ObjectFlagsPrimitiveUnion || countWhere(types, func(t Type) bool {
			return !!(t.flags & (TypeFlagsObject | TypeFlagsInstantiableNonPrimitive))
		}) < 10 {
			return nil
		}
		if unionType.keyPropertyName == nil {
			// The candidate key property name is the name of the first property with a unit type in one of the
			// constituent types.
			keyPropertyName := forEach(types, func(t Type) * /* TODO(TS-TO-GO) inferred type (string & { __escapedIdentifier: void; }) | (void & { __escapedIdentifier: void; }) | InternalSymbolName */ any {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case t.flags & (TypeFlagsObject | TypeFlagsInstantiableNonPrimitive):
					return forEach(getPropertiesOfType(t), func(p Symbol) *__String {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isUnitType(getTypeOfSymbol(p)):
							return p.escapedName
						default:
							return nil
						}
					})
				default:
					return nil
				}
			})
			mapByKeyProperty := keyPropertyName && mapTypesByKeyProperty(types, keyPropertyName)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case mapByKeyProperty:
				unionType.keyPropertyName = keyPropertyName
			default:
				unionType.keyPropertyName = "" /* as __String */
			}
			unionType.constituentMap = mapByKeyProperty
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case (unionType.keyPropertyName /* as string */).length:
			return unionType.keyPropertyName
		default:
			return nil
		}
	}
	// Given a union type for which getKeyPropertyName returned a non-undefined result, return the constituent
	// that corresponds to the given key type for that property name.
	getConstituentTypeForKeyType := func(unionType UnionType, keyType Type) Type {
		result := unionType.constituentMap. /* TODO(TS-TO-GO): was ? */ get(getTypeId(getRegularTypeOfLiteralType(keyType)))
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case result != unknownType:
			return result
		default:
			return nil
		}
	}
	getMatchingUnionConstituentForType := func(unionType UnionType, type_ Type) Type {
		keyPropertyName := getKeyPropertyName(unionType)
		propType := keyPropertyName && getTypeOfPropertyOfType(type_, keyPropertyName)
		return propType && getConstituentTypeForKeyType(unionType, propType)
	}
	getMatchingUnionConstituentForObjectLiteral := func(unionType UnionType, node ObjectLiteralExpression) Type {
		keyPropertyName := getKeyPropertyName(unionType)
		propNode := keyPropertyName && find(node.properties, func(p /* TODO(TS-TO-GO) inferred type SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | GetAccessorDeclaration */ any) bool {
			return p.symbol && p.kind == SyntaxKindPropertyAssignment && p.symbol.escapedName == keyPropertyName && isPossiblyDiscriminantValue(p.initializer)
		})
		propType := propNode && getContextFreeTypeOfExpression((propNode /* as PropertyAssignment */).initializer)
		return propType && getConstituentTypeForKeyType(unionType, propType)
	}
	isOrContainsMatchingReference := func(source Node, target Node) bool {
		return isMatchingReference(source, target) || containsMatchingReference(source, target)
	}
	hasMatchingArgument := func(expression /* TODO(TS-TO-GO) TypeNode UnionType: CallExpression | NewExpression */ any, reference Node) bool {
		if expression.arguments {
			for _, argument := range expression.arguments {
				if isOrContainsMatchingReference(reference, argument) || optionalChainContainsReference(argument, reference) {
					return true
				}
			}
		}
		if expression.expression.kind == SyntaxKindPropertyAccessExpression && isOrContainsMatchingReference(reference, (expression.expression /* as PropertyAccessExpression */).expression) {
			return true
		}
		return false
	}
	getFlowNodeId := func(flow FlowNode) number {
		if flow.id <= 0 {
			flow.id = nextFlowId
			nextFlowId++
		}
		return flow.id
	}
	typeMaybeAssignableTo := func(source Type, target Type) bool {
		if !(source.flags & TypeFlagsUnion) {
			return isTypeAssignableTo(source, target)
		}
		for _, t := range (source /* as UnionType */).types {
			if isTypeAssignableTo(t, target) {
				return true
			}
		}
		return false
	}
	// Remove those constituent types of declaredType to which no constituent type of assignedType is assignable.
	// For example, when a variable of type number | string | boolean is assigned a value of type number | boolean,
	// we remove type string.
	getAssignmentReducedType := func(declaredType UnionType, assignedType Type) Type {
		if declaredType == assignedType {
			return declaredType
		}
		if assignedType.flags & TypeFlagsNever {
			return assignedType
		}
		key := __TEMPLATE__("A", getTypeId(declaredType), ",", getTypeId(assignedType))
		return /* TODO(TS-TO-GO) Node BinaryExpression: getCachedType(key) ?? setCachedType(key, getAssignmentReducedTypeWorker(declaredType, assignedType)) */ TODO
	}
	getAssignmentReducedTypeWorker := func(declaredType UnionType, assignedType Type) Type {
		filteredType := filterType(declaredType, func(t Type) bool {
			return typeMaybeAssignableTo(assignedType, t)
		})
		// Ensure that we narrow to fresh types if the assignment is a fresh boolean literal type.
		var reducedType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case assignedType.flags&TypeFlagsBooleanLiteral && isFreshLiteralType(assignedType):
			reducedType = mapType(filteredType, getFreshTypeOfLiteralType)
		default:
			reducedType = filteredType
		}
		// Our crude heuristic produces an invalid result in some cases: see GH#26130.
		// For now, when that happens, we give up and don't narrow at all.  (This also
		// means we'll never narrow for erroneous assignments where the assigned type
		// is not assignable to the declared type.)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isTypeAssignableTo(assignedType, reducedType):
			return reducedType
		default:
			return declaredType
		}
	}
	isFunctionObjectType := func(type_ ObjectType) bool {
		if getObjectFlags(type_) & ObjectFlagsEvolvingArray {
			return false
		}
		// We do a quick check for a "bind" property before performing the more expensive subtype
		// check. This gives us a quicker out in the common case where an object type is not a function.
		resolved := resolveStructuredTypeMembers(type_)
		return !!(resolved.callSignatures.length || resolved.constructSignatures.length || resolved.members.get("bind" /* as __String */) && isTypeSubtypeOf(type_, globalFunctionType))
	}
	getTypeFacts := func(type_ Type, mask TypeFacts) TypeFacts {
		return getTypeFactsWorker(type_, mask) & mask
	}
	hasTypeFacts := func(type_ Type, mask TypeFacts) bool {
		return getTypeFacts(type_, mask) != 0
	}
	getTypeFactsWorker := func(type_ Type, callerOnlyNeeds TypeFacts) TypeFacts {
		if type_.flags & (TypeFlagsIntersection | TypeFlagsInstantiable) {
			type_ = getBaseConstraintOfType(type_) || unknownType
		}
		flags := type_.flags
		if flags & (TypeFlagsString | TypeFlagsStringMapping) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks:
				return TypeFactsStringStrictFacts
			default:
				return TypeFactsStringFacts
			}
		}
		if flags & (TypeFlagsStringLiteral | TypeFlagsTemplateLiteral) {
			isEmpty := flags&TypeFlagsStringLiteral && (type_ /* as StringLiteralType */).value == ""
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isEmpty:
					return TypeFactsEmptyStringStrictFacts
				default:
					return TypeFactsNonEmptyStringStrictFacts
				}
			case isEmpty:
				return TypeFactsEmptyStringFacts
			default:
				return TypeFactsNonEmptyStringFacts
			}
		}
		if flags & (TypeFlagsNumber | TypeFlagsEnum) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks:
				return TypeFactsNumberStrictFacts
			default:
				return TypeFactsNumberFacts
			}
		}
		if flags & TypeFlagsNumberLiteral {
			isZero := (type_ /* as NumberLiteralType */).value == 0
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isZero:
					return TypeFactsZeroNumberStrictFacts
				default:
					return TypeFactsNonZeroNumberStrictFacts
				}
			case isZero:
				return TypeFactsZeroNumberFacts
			default:
				return TypeFactsNonZeroNumberFacts
			}
		}
		if flags & TypeFlagsBigInt {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks:
				return TypeFactsBigIntStrictFacts
			default:
				return TypeFactsBigIntFacts
			}
		}
		if flags & TypeFlagsBigIntLiteral {
			isZero := isZeroBigInt(type_ /* as BigIntLiteralType */)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isZero:
					return TypeFactsZeroBigIntStrictFacts
				default:
					return TypeFactsNonZeroBigIntStrictFacts
				}
			case isZero:
				return TypeFactsZeroBigIntFacts
			default:
				return TypeFactsNonZeroBigIntFacts
			}
		}
		if flags & TypeFlagsBoolean {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks:
				return TypeFactsBooleanStrictFacts
			default:
				return TypeFactsBooleanFacts
			}
		}
		if flags & TypeFlagsBooleanLike {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case (type_ == falseType || type_ == regularFalseType):
					return TypeFactsFalseStrictFacts
				default:
					return TypeFactsTrueStrictFacts
				}
			case (type_ == falseType || type_ == regularFalseType):
				return TypeFactsFalseFacts
			default:
				return TypeFactsTrueFacts
			}
		}
		if flags & TypeFlagsObject {
			var possibleFacts number
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks:
				possibleFacts = TypeFactsEmptyObjectStrictFacts | TypeFactsFunctionStrictFacts | TypeFactsObjectStrictFacts
			default:
				possibleFacts = TypeFactsEmptyObjectFacts | TypeFactsFunctionFacts | TypeFactsObjectFacts
			}
			if (callerOnlyNeeds & possibleFacts) == 0 {
				// If the caller doesn't care about any of the facts that we could possibly produce,
				// return zero so we can skip resolving members.
				return 0
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case getObjectFlags(type_)&ObjectFlagsAnonymous && isEmptyObjectType(type_ /* as ObjectType */):
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case strictNullChecks:
					return TypeFactsEmptyObjectStrictFacts
				default:
					return TypeFactsEmptyObjectFacts
				}
			case isFunctionObjectType(type_ /* as ObjectType */):
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case strictNullChecks:
					return TypeFactsFunctionStrictFacts
				default:
					return TypeFactsFunctionFacts
				}
			case strictNullChecks:
				return TypeFactsObjectStrictFacts
			default:
				return TypeFactsObjectFacts
			}
		}
		if flags & TypeFlagsVoid {
			return TypeFactsVoidFacts
		}
		if flags & TypeFlagsUndefined {
			return TypeFactsUndefinedFacts
		}
		if flags & TypeFlagsNull {
			return TypeFactsNullFacts
		}
		if flags & TypeFlagsESSymbolLike {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks:
				return TypeFactsSymbolStrictFacts
			default:
				return TypeFactsSymbolFacts
			}
		}
		if flags & TypeFlagsNonPrimitive {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case strictNullChecks:
				return TypeFactsObjectStrictFacts
			default:
				return TypeFactsObjectFacts
			}
		}
		if flags & TypeFlagsNever {
			return TypeFactsNone
		}
		if flags & TypeFlagsUnion {
			return reduceLeft((type_ /* as UnionType */).types, func(facts /* TODO(TS-TO-GO) inferred type TypeFacts.None */ any, t Type) number {
				return facts | getTypeFactsWorker(t, callerOnlyNeeds)
			}, TypeFactsNone)
		}
		if flags & TypeFlagsIntersection {
			return getIntersectionTypeFacts(type_ /* as IntersectionType */, callerOnlyNeeds)
		}
		return TypeFactsUnknownFacts
	}
	getIntersectionTypeFacts := func(type_ IntersectionType, callerOnlyNeeds TypeFacts) TypeFacts {
		// When an intersection contains a primitive type we ignore object type constituents as they are
		// presumably type tags. For example, in string & { __kind__: "name" } we ignore the object type.
		ignoreObjects := maybeTypeOfKind(type_, TypeFlagsPrimitive)
		// When computing the type facts of an intersection type, certain type facts are computed as `and`
		// and others are computed as `or`.
		oredFacts := TypeFactsNone
		andedFacts := TypeFactsAll
		for _, t := range type_.types {
			if !(ignoreObjects && t.flags&TypeFlagsObject) {
				f := getTypeFactsWorker(t, callerOnlyNeeds)
				oredFacts |= f
				andedFacts &= f
			}
		}
		return oredFacts&TypeFactsOrFactsMask | andedFacts&TypeFactsAndFactsMask
	}
	getTypeWithFacts := func(type_ Type, include TypeFacts) Type {
		return filterType(type_, func(t Type) bool {
			return hasTypeFacts(t, include)
		})
	}
	// This function is similar to getTypeWithFacts, except that in strictNullChecks mode it replaces type
	// unknown with the union {} | null | undefined (and reduces that accordingly), and it intersects remaining
	// instantiable types with {}, {} | null, or {} | undefined in order to remove null and/or undefined.
	getAdjustedTypeWithFacts := func(type_ Type, facts TypeFacts) Type {
		reduced := recombineUnknownType(getTypeWithFacts(__COND__(strictNullChecks && type_.flags&TypeFlagsUnknown, unknownUnionType, type_), facts))
		if strictNullChecks {
			switch facts {
			case TypeFactsNEUndefined:
				return removeNullableByIntersection(reduced, TypeFactsEQUndefined, TypeFactsEQNull, TypeFactsIsNull, nullType)
			case TypeFactsNENull:
				return removeNullableByIntersection(reduced, TypeFactsEQNull, TypeFactsEQUndefined, TypeFactsIsUndefined, undefinedType)
			case TypeFactsNEUndefinedOrNull:
				fallthrough // TODO(TS-TO-GO): merge cases
			case TypeFactsTruthy:
				return mapType(reduced, func(t Type) Type {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case hasTypeFacts(t, TypeFactsEQUndefinedOrNull):
						return getGlobalNonNullableTypeInstantiation(t)
					default:
						return t
					}
				})
			}
		}
		return reduced
	}
	removeNullableByIntersection := func(type_ Type, targetFacts TypeFacts, otherFacts TypeFacts, otherIncludesFacts TypeFacts, otherType Type) Type {
		facts := getTypeFacts(type_, TypeFactsEQUndefined|TypeFactsEQNull|TypeFactsIsUndefined|TypeFactsIsNull)
		// Simply return the type if it never compares equal to the target nullable.
		if !(facts & targetFacts) {
			return type_
		}
		// By default we intersect with a union of {} and the opposite nullable.
		emptyAndOtherUnion := getUnionType([]Type{emptyObjectType, otherType})
		// For each constituent type that can compare equal to the target nullable, intersect with the above union
		// if the type doesn't already include the opppsite nullable and the constituent can compare equal to the
		// opposite nullable; otherwise, just intersect with {}.
		return mapType(type_, func(t Type) Type {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case hasTypeFacts(t, targetFacts):
				return getIntersectionType([]Type{t, __COND__(!(facts&otherIncludesFacts) && hasTypeFacts(t, otherFacts), emptyAndOtherUnion, emptyObjectType)})
			default:
				return t
			}
		})
	}
	recombineUnknownType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_ == unknownUnionType:
			return unknownType
		default:
			return type_
		}
	}
	getTypeWithDefault := func(type_ Type, defaultExpression Expression) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case defaultExpression:
			return getUnionType([]Type{getNonUndefinedType(type_), getTypeOfExpression(defaultExpression)})
		default:
			return type_
		}
	}
	getTypeOfDestructuredProperty := func(type_ Type, name PropertyName) Type {
		nameType := getLiteralTypeFromPropertyName(name)
		if !isTypeUsableAsPropertyName(nameType) {
			return errorType
		}
		text := getPropertyNameFromType(nameType)
		return getTypeOfPropertyOfType(type_, text) || includeUndefinedInIndexSignature(getApplicableIndexInfoForName(type_, text). /* TODO(TS-TO-GO): was ? */ type_) || errorType
	}
	getTypeOfDestructuredArrayElement := func(type_ Type, index number) Type {
		return everyType(type_, isTupleLikeType) && getTupleElementType(type_, index) || includeUndefinedInIndexSignature(checkIteratedTypeOrElementType(IterationUseDestructuring, type_, undefinedType /*errorNode*/, nil)) || errorType
	}
	includeUndefinedInIndexSignature := func(type_ Type) Type {
		if !type_ {
			return type_
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case compilerOptions.noUncheckedIndexedAccess:
			return getUnionType([]Type{type_, missingType})
		default:
			return type_
		}
	}
	getTypeOfDestructuredSpreadExpression := func(type_ Type) ObjectType {
		return createArrayType(checkIteratedTypeOrElementType(IterationUseDestructuring, type_, undefinedType /*errorNode*/, nil) || errorType)
	}
	getAssignedTypeOfBinaryExpression := func(node BinaryExpression) Type {
		isDestructuringDefaultAssignment := node.parent.kind == SyntaxKindArrayLiteralExpression && isDestructuringAssignmentTarget(node.parent) || node.parent.kind == SyntaxKindPropertyAssignment && isDestructuringAssignmentTarget(node.parent.parent)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isDestructuringDefaultAssignment:
			return getTypeWithDefault(getAssignedType(node), node.right)
		default:
			return getTypeOfExpression(node.right)
		}
	}
	isDestructuringAssignmentTarget := func(parent Node) bool {
		return parent.parent.kind == SyntaxKindBinaryExpression && (parent.parent /* as BinaryExpression */).left == parent || parent.parent.kind == SyntaxKindForOfStatement && (parent.parent /* as ForOfStatement */).initializer == parent
	}
	getAssignedTypeOfArrayLiteralElement := func(node ArrayLiteralExpression, element Expression) Type {
		return getTypeOfDestructuredArrayElement(getAssignedType(node), node.elements.indexOf(element))
	}
	getAssignedTypeOfSpreadExpression := func(node SpreadElement) Type {
		return getTypeOfDestructuredSpreadExpression(getAssignedType(node.parent /* as ArrayLiteralExpression */))
	}
	getAssignedTypeOfPropertyAssignment := func(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAssignment | ShorthandPropertyAssignment */ any) Type {
		return getTypeOfDestructuredProperty(getAssignedType(node.parent), node.name)
	}
	getAssignedTypeOfShorthandPropertyAssignment := func(node ShorthandPropertyAssignment) Type {
		return getTypeWithDefault(getAssignedTypeOfPropertyAssignment(node), node.objectAssignmentInitializer)
	}
	getAssignedType := func(node Expression) Type {
		TODO_IDENTIFIER := node
		switch parent.kind {
		case SyntaxKindForInStatement:
			return stringType
		case SyntaxKindForOfStatement:
			return checkRightHandSideOfForOf(parent /* as ForOfStatement */) || errorType
		case SyntaxKindBinaryExpression:
			return getAssignedTypeOfBinaryExpression(parent /* as BinaryExpression */)
		case SyntaxKindDeleteExpression:
			return undefinedType
		case SyntaxKindArrayLiteralExpression:
			return getAssignedTypeOfArrayLiteralElement(parent /* as ArrayLiteralExpression */, node)
		case SyntaxKindSpreadElement:
			return getAssignedTypeOfSpreadExpression(parent /* as SpreadElement */)
		case SyntaxKindPropertyAssignment:
			return getAssignedTypeOfPropertyAssignment(parent /* as PropertyAssignment */)
		case SyntaxKindShorthandPropertyAssignment:
			return getAssignedTypeOfShorthandPropertyAssignment(parent /* as ShorthandPropertyAssignment */)
		}
		return errorType
	}
	getInitialTypeOfBindingElement := func(node BindingElement) Type {
		pattern := node.parent
		parentType := getInitialType(pattern.parent /* as VariableDeclaration | BindingElement */)
		var type_ Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case pattern.kind == SyntaxKindObjectBindingPattern:
			type_ = getTypeOfDestructuredProperty(parentType, node.propertyName || node.name /* as Identifier */)
		case !node.dotDotDotToken:
			type_ = getTypeOfDestructuredArrayElement(parentType, pattern.elements.indexOf(node))
		default:
			type_ = getTypeOfDestructuredSpreadExpression(parentType)
		}
		return getTypeWithDefault(type_, node.initializer)
	}
	getTypeOfInitializer := func(node Expression) Type {
		// Return the cached type if one is available. If the type of the variable was inferred
		// from its initializer, we'll already have cached the type. Otherwise we compute it now
		// without caching such that transient types are reflected.
		links := getNodeLinks(node)
		return links.resolvedType || getTypeOfExpression(node)
	}
	getInitialTypeOfVariableDeclaration := func(node VariableDeclaration) Type {
		if node.initializer {
			return getTypeOfInitializer(node.initializer)
		}
		if node.parent.parent.kind == SyntaxKindForInStatement {
			return stringType
		}
		if node.parent.parent.kind == SyntaxKindForOfStatement {
			return checkRightHandSideOfForOf(node.parent.parent) || errorType
		}
		return errorType
	}
	getInitialType := func(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | BindingElement */ any) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.kind == SyntaxKindVariableDeclaration:
			return getInitialTypeOfVariableDeclaration(node)
		default:
			return getInitialTypeOfBindingElement(node)
		}
	}
	isEmptyArrayAssignment := func(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | BindingElement | Expression */ any) bool {
		return node.kind == SyntaxKindVariableDeclaration && (node /* as VariableDeclaration */).initializer && isEmptyArrayLiteral((node /* as VariableDeclaration */).initializer) || node.kind != SyntaxKindBindingElement && node.parent.kind == SyntaxKindBinaryExpression && isEmptyArrayLiteral((node.parent /* as BinaryExpression */).right)
	}
	getReferenceCandidate := func(node Expression) Expression {
		switch node.kind {
		case SyntaxKindParenthesizedExpression:
			return getReferenceCandidate((node /* as ParenthesizedExpression */).expression)
		case SyntaxKindBinaryExpression:
			switch (node /* as BinaryExpression */).operatorToken.kind {
			case SyntaxKindEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindBarBarEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindAmpersandAmpersandEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindQuestionQuestionEqualsToken:
				return getReferenceCandidate((node /* as BinaryExpression */).left)
			case SyntaxKindCommaToken:
				return getReferenceCandidate((node /* as BinaryExpression */).right)
			}
		}
		return node
	}
	getReferenceRoot := func(node Node) Node {
		TODO_IDENTIFIER := node
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case parent.kind == SyntaxKindParenthesizedExpression || parent.kind == SyntaxKindBinaryExpression && (parent /* as BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken && (parent /* as BinaryExpression */).left == node || parent.kind == SyntaxKindBinaryExpression && (parent /* as BinaryExpression */).operatorToken.kind == SyntaxKindCommaToken && (parent /* as BinaryExpression */).right == node:
			return getReferenceRoot(parent)
		default:
			return node
		}
	}
	getTypeOfSwitchClause := func(clause /* TODO(TS-TO-GO) TypeNode UnionType: CaseClause | DefaultClause */ any) Type {
		if clause.kind == SyntaxKindCaseClause {
			return getRegularTypeOfLiteralType(getTypeOfExpression(clause.expression))
		}
		return neverType
	}
	getSwitchClauseTypes := func(switchStatement SwitchStatement) []Type {
		links := getNodeLinks(switchStatement)
		if !links.switchTypes {
			links.switchTypes = []never{}
			for _, clause := range switchStatement.caseBlock.clauses {
				links.switchTypes.push(getTypeOfSwitchClause(clause))
			}
		}
		return links.switchTypes
	}
	// Get the type names from all cases in a switch on `typeof`. The default clause and/or duplicate type names are
	// represented as undefined. Return undefined if one or more case clause expressions are not string literals.
	getSwitchClauseTypeOfWitnesses := func(switchStatement SwitchStatement) *[]*string {
		if some(switchStatement.caseBlock.clauses, func(clause /* TODO(TS-TO-GO) inferred type CaseClause | DefaultClause */ any) bool {
			return clause.kind == SyntaxKindCaseClause && !isStringLiteralLike(clause.expression)
		}) {
			return nil
		}
		var witnesses []*string = []never{}
		for _, clause := range switchStatement.caseBlock.clauses {
			var text *string
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case clause.kind == SyntaxKindCaseClause:
				text = (clause.expression /* as StringLiteralLike */).text
			default:
				text = nil
			}
			witnesses.push(__COND__(text && !contains(witnesses, text), text, nil))
		}
		return witnesses
	}
	eachTypeContainedIn := func(source Type, types []Type) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case source.flags & TypeFlagsUnion:
			return !forEach((source /* as UnionType */).types, func(t Type) bool {
				return !contains(types, t)
			})
		default:
			return contains(types, source)
		}
	}
	isTypeSubsetOf := func(source Type, target Type) bool {
		return !!(source == target || source.flags&TypeFlagsNever || target.flags&TypeFlagsUnion && isTypeSubsetOfUnion(source, target /* as UnionType */))
	}
	isTypeSubsetOfUnion := func(source Type, target UnionType) bool {
		if source.flags & TypeFlagsUnion {
			for _, t := range (source /* as UnionType */).types {
				if !containsType(target.types, t) {
					return false
				}
			}
			return true
		}
		if source.flags&TypeFlagsEnumLike && getBaseTypeOfEnumLikeType(source /* as LiteralType */) == target {
			return true
		}
		return containsType(target.types, source)
	}
	forEachType := func(type_ Type, f func(t Type) *T) *T {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnion:
			return forEach((type_ /* as UnionType */).types, f)
		default:
			return f(type_)
		}
	}
	someType := func(type_ Type, f func(t Type) bool) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnion:
			return some((type_ /* as UnionType */).types, f)
		default:
			return f(type_)
		}
	}
	everyType := func(type_ Type, f func(t Type) bool) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnion:
			return every((type_ /* as UnionType */).types, f)
		default:
			return f(type_)
		}
	}
	everyContainedType := func(type_ Type, f func(t Type) bool) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnionOrIntersection:
			return every((type_ /* as UnionOrIntersectionType */).types, f)
		default:
			return f(type_)
		}
	}
	filterType := func(type_ Type, f func(t Type) bool) Type {
		if type_.flags & TypeFlagsUnion {
			types := (type_ /* as UnionType */).types
			filtered := filter(types, f)
			if filtered == types {
				return type_
			}
			origin := (type_ /* as UnionType */).origin
			var newOrigin Type
			if origin && origin.flags&TypeFlagsUnion {
				// If the origin type is a (denormalized) union type, filter its non-union constituents. If that ends
				// up removing a smaller number of types than in the normalized constituent set (meaning some of the
				// filtered types are within nested unions in the origin), then we can't construct a new origin type.
				// Otherwise, if we have exactly one type left in the origin set, return that as the filtered type.
				// Otherwise, construct a new filtered origin type.
				originTypes := (origin /* as UnionType */).types
				originFiltered := filter(originTypes, func(t Type) bool {
					return !!(t.flags & TypeFlagsUnion) || f(t)
				})
				if originTypes.length-originFiltered.length == types.length-filtered.length {
					if originFiltered.length == 1 {
						return originFiltered[0]
					}
					newOrigin = createOriginUnionOrIntersectionType(TypeFlagsUnion, originFiltered)
				}
			}
			// filtering could remove intersections so `ContainsIntersections` might be forwarded "incorrectly"
			// it is purely an optimization hint so there is no harm in accidentally forwarding it
			return getUnionTypeFromSortedList(filtered, (type_ /* as UnionType */).objectFlags&(ObjectFlagsPrimitiveUnion|ObjectFlagsContainsIntersections) /*aliasSymbol*/, nil /*aliasTypeArguments*/, nil, newOrigin)
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags&TypeFlagsNever || f(type_):
			return type_
		default:
			return neverType
		}
	}
	removeType := func(type_ Type, targetType Type) Type {
		return filterType(type_, func(t Type) bool {
			return t != targetType
		})
	}
	countTypes := func(type_ Type) number {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnion:
			return (type_ /* as UnionType */).types.length
		default:
			return 1
		}
	}
	// Apply a mapping function to a type and return the resulting type. If the source type
	// is a union type, the mapping function is applied to each constituent type and a union
	// of the resulting types is returned.
	/* TODO(TS-TO-GO): function mapType(type: Type, mapper: (t: Type) => Type, noReductions?: boolean): Type; */
	/* TODO(TS-TO-GO): function mapType(type: Type, mapper: (t: Type) => Type | undefined, noReductions?: boolean): Type | undefined; */
	mapType := func(type_ Type, mapper func(t Type) Type, noReductions bool) Type {
		if type_.flags & TypeFlagsNever {
			return type_
		}
		if !(type_.flags & TypeFlagsUnion) {
			return mapper(type_)
		}
		origin := (type_ /* as UnionType */).origin
		var types []Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case origin && origin.flags&TypeFlagsUnion:
			types = (origin /* as UnionType */).types
		default:
			types = (type_ /* as UnionType */).types
		}
		var mappedTypes *[]Type
		changed := false
		for _, t := range types {
			var mapped Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case t.flags & TypeFlagsUnion:
				mapped = mapType(t, mapper, noReductions)
			default:
				mapped = mapper(t)
			}
			/* TODO(TS-TO-GO) Node BinaryExpression: changed ||= t !== mapped */ TODO
			if mapped {
				if !mappedTypes {
					mappedTypes = []Type{mapped}
				} else {
					mappedTypes.push(mapped)
				}
			}
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case changed:
			return mappedTypes && getUnionType(mappedTypes, __COND__(noReductions, UnionReductionNone, UnionReductionLiteral))
		default:
			return type_
		}
	}
	mapTypeWithAlias := func(type_ Type, mapper func(t Type) Type, aliasSymbol Symbol, aliasTypeArguments *[]Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags&TypeFlagsUnion && aliasSymbol:
			return getUnionType(map_((type_ /* as UnionType */).types, mapper), UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
		default:
			return mapType(type_, mapper)
		}
	}
	extractTypesOfKind := func(type_ Type, kind TypeFlags) Type {
		return filterType(type_, func(t Type) bool {
			return (t.flags & kind) != 0
		})
	}
	// Return a new type in which occurrences of the string, number and bigint primitives and placeholder template
	// literal types in typeWithPrimitives have been replaced with occurrences of compatible and more specific types
	// from typeWithLiterals. This is essentially a limited form of intersection between the two types. We avoid a
	// true intersection because it is more costly and, when applied to union types, generates a large number of
	// types we don't actually care about.
	replacePrimitivesWithLiterals := func(typeWithPrimitives Type, typeWithLiterals Type) Type {
		if maybeTypeOfKind(typeWithPrimitives, TypeFlagsString|TypeFlagsTemplateLiteral|TypeFlagsNumber|TypeFlagsBigInt) && maybeTypeOfKind(typeWithLiterals, TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping|TypeFlagsNumberLiteral|TypeFlagsBigIntLiteral) {
			return mapType(typeWithPrimitives, func(t Type) Type {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case t.flags & TypeFlagsString:
					return extractTypesOfKind(typeWithLiterals, TypeFlagsString|TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping)
				case isPatternLiteralType(t) && !maybeTypeOfKind(typeWithLiterals, TypeFlagsString|TypeFlagsTemplateLiteral|TypeFlagsStringMapping):
					return extractTypesOfKind(typeWithLiterals, TypeFlagsStringLiteral)
				case t.flags & TypeFlagsNumber:
					return extractTypesOfKind(typeWithLiterals, TypeFlagsNumber|TypeFlagsNumberLiteral)
				case t.flags & TypeFlagsBigInt:
					return extractTypesOfKind(typeWithLiterals, TypeFlagsBigInt|TypeFlagsBigIntLiteral)
				default:
					return t
				}
			})
		}
		return typeWithPrimitives
	}
	isIncomplete := func(flowType FlowType) bool {
		return flowType.flags == 0
	}
	getTypeFromFlowType := func(flowType FlowType) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case flowType.flags == 0:
			return flowType.type_
		default:
			return flowType /* as Type */
		}
	}
	createFlowType := func(type_ Type, incomplete bool) FlowType {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case incomplete:
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"flags": 0,
				"type_": __COND__(type_.flags&TypeFlagsNever, silentNeverType, type_),
			}
		default:
			return type_
		}
	}
	// An evolving array type tracks the element types that have so far been seen in an
	// 'x.push(value)' or 'x[n] = value' operation along the control flow graph. Evolving
	// array types are ultimately converted into manifest array types (using getFinalArrayType)
	// and never escape the getFlowTypeOfReference function.
	createEvolvingArrayType := func(elementType Type) EvolvingArrayType {
		result := createObjectType(ObjectFlagsEvolvingArray) /* as EvolvingArrayType */
		result.elementType = elementType
		return result
	}
	getEvolvingArrayType := func(elementType Type) EvolvingArrayType {
		return evolvingArrayTypes[elementType.id] || ( /* TODO(TS-TO-GO) Node BinaryExpression: evolvingArrayTypes[elementType.id] = createEvolvingArrayType(elementType) */ TODO)
	}
	// When adding evolving array element types we do not perform subtype reduction. Instead,
	// we defer subtype reduction until the evolving array type is finalized into a manifest
	// array type.
	addEvolvingArrayElementType := func(evolvingArrayType EvolvingArrayType, node Expression) EvolvingArrayType {
		elementType := getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(getContextFreeTypeOfExpression(node)))
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isTypeSubsetOf(elementType, evolvingArrayType.elementType):
			return evolvingArrayType
		default:
			return getEvolvingArrayType(getUnionType([]Type{evolvingArrayType.elementType, elementType}))
		}
	}
	createFinalArrayType := func(elementType Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case elementType.flags & TypeFlagsNever:
			return autoArrayType
		default:
			return createArrayType(__COND__(elementType.flags&TypeFlagsUnion, getUnionType((elementType /* as UnionType */).types, UnionReductionSubtype), elementType))
		}
	}
	// We perform subtype reduction upon obtaining the final array type from an evolving array type.
	getFinalArrayType := func(evolvingArrayType EvolvingArrayType) Type {
		return evolvingArrayType.finalArrayType || ( /* TODO(TS-TO-GO) Node BinaryExpression: evolvingArrayType.finalArrayType = createFinalArrayType(evolvingArrayType.elementType) */ TODO)
	}
	finalizeEvolvingArrayType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getObjectFlags(type_) & ObjectFlagsEvolvingArray:
			return getFinalArrayType(type_ /* as EvolvingArrayType */)
		default:
			return type_
		}
	}
	getElementTypeOfEvolvingArrayType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getObjectFlags(type_) & ObjectFlagsEvolvingArray:
			return (type_ /* as EvolvingArrayType */).elementType
		default:
			return neverType
		}
	}
	isEvolvingArrayTypeList := func(types []Type) bool {
		hasEvolvingArrayType := false
		for _, t := range types {
			if !(t.flags & TypeFlagsNever) {
				if !(getObjectFlags(t) & ObjectFlagsEvolvingArray) {
					return false
				}
				hasEvolvingArrayType = true
			}
		}
		return hasEvolvingArrayType
	}
	// Return true if the given node is 'x' in an 'x.length', x.push(value)', 'x.unshift(value)' or
	// 'x[n] = value' operation, where 'n' is an expression of type any, undefined, or a number-like type.
	isEvolvingArrayOperationTarget := func(node Node) bool {
		root := getReferenceRoot(node)
		parent := root.parent
		isLengthPushOrUnshift := isPropertyAccessExpression(parent) && (parent.name.escapedText == "length" || parent.parent.kind == SyntaxKindCallExpression && isIdentifier(parent.name) && isPushOrUnshiftIdentifier(parent.name))
		isElementAssignment := parent.kind == SyntaxKindElementAccessExpression && (parent /* as ElementAccessExpression */).expression == root && parent.parent.kind == SyntaxKindBinaryExpression && (parent.parent /* as BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken && (parent.parent /* as BinaryExpression */).left == parent && !isAssignmentTarget(parent.parent) && isTypeAssignableToKind(getTypeOfExpression((parent /* as ElementAccessExpression */).argumentExpression), TypeFlagsNumberLike)
		return isLengthPushOrUnshift || isElementAssignment
	}
	isDeclarationWithExplicitTypeAnnotation := func(node Declaration) bool {
		return (isVariableDeclaration(node) || isPropertyDeclaration(node) || isPropertySignature(node) || isParameter(node)) && !!(getEffectiveTypeAnnotationNode(node) || isInJSFile(node) && hasInitializer(node) && node.initializer && isFunctionExpressionOrArrowFunction(node.initializer) && getEffectiveReturnTypeNode(node.initializer))
	}
	getExplicitTypeOfSymbol := func(symbol Symbol, diagnostic Diagnostic) Type {
		symbol = resolveSymbol(symbol)
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsValueModule) {
			return getTypeOfSymbol(symbol)
		}
		if symbol.flags & (SymbolFlagsVariable | SymbolFlagsProperty) {
			if getCheckFlags(symbol) & CheckFlagsMapped {
				origin := (symbol /* as MappedSymbol */).links.syntheticOrigin
				if origin && getExplicitTypeOfSymbol(origin) {
					return getTypeOfSymbol(symbol)
				}
			}
			declaration := symbol.valueDeclaration
			if declaration {
				if isDeclarationWithExplicitTypeAnnotation(declaration) {
					return getTypeOfSymbol(symbol)
				}
				if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForOfStatement {
					statement := declaration.parent.parent
					expressionType := getTypeOfDottedName(statement.expression /*diagnostic*/, nil)
					if expressionType {
						var use /* TODO(TS-TO-GO) inferred type IterationUse.ForOf | IterationUse.ForAwaitOf */ any
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case statement.awaitModifier:
							use = IterationUseForAwaitOf
						default:
							use = IterationUseForOf
						}
						return checkIteratedTypeOrElementType(use, expressionType, undefinedType /*errorNode*/, nil)
					}
				}
				if diagnostic {
					addRelatedInfo(diagnostic, createDiagnosticForNode(declaration, Diagnostics._0_needs_an_explicit_type_annotation, symbolToString(symbol)))
				}
			}
		}
	}
	// We require the dotted function name in an assertion expression to be comprised of identifiers
	// that reference function, method, class or value module symbols; or variable, property or
	// parameter symbols with declarations that have explicit type annotations. Such references are
	// resolvable with no possibility of triggering circularities in control flow analysis.
	getTypeOfDottedName := func(node Expression, diagnostic *Diagnostic) Type {
		if !(node.flags & NodeFlagsInWithStatement) {
			switch node.kind {
			case SyntaxKindIdentifier:
				symbol := getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(node /* as Identifier */))
				return getExplicitTypeOfSymbol(symbol, diagnostic)
			case SyntaxKindThisKeyword:
				return getExplicitThisType(node)
			case SyntaxKindSuperKeyword:
				return checkSuperExpression(node)
			case SyntaxKindPropertyAccessExpression:
				type_ := getTypeOfDottedName((node /* as PropertyAccessExpression */).expression, diagnostic)
				if type_ {
					name := (node /* as PropertyAccessExpression */).name
					var prop Symbol
					if isPrivateIdentifier(name) {
						if !type_.symbol {
							return nil
						}
						prop = getPropertyOfType(type_, getSymbolNameForPrivateIdentifier(type_.symbol, name.escapedText))
					} else {
						prop = getPropertyOfType(type_, name.escapedText)
					}
					return prop && getExplicitTypeOfSymbol(prop, diagnostic)
				}
				return nil
				fallthrough
			case SyntaxKindParenthesizedExpression:
				return getTypeOfDottedName((node /* as ParenthesizedExpression */).expression, diagnostic)
			}
		}
	}
	getEffectsSignature := func(node /* TODO(TS-TO-GO) TypeNode UnionType: CallExpression | InstanceofExpression */ any) *Signature {
		links := getNodeLinks(node)
		signature := links.effectsSignature
		if signature == nil {
			// A call expression parented by an expression statement is a potential assertion. Other call
			// expressions are potential type predicate function calls. In order to avoid triggering
			// circularities in control flow analysis, we use getTypeOfDottedName when resolving the call
			// target expression of an assertion.
			var funcType Type
			if isBinaryExpression(node) {
				rightType := checkNonNullExpression(node.right)
				funcType = getSymbolHasInstanceMethodOfObjectType(rightType)
			} else if node.parent.kind == SyntaxKindExpressionStatement {
				funcType = getTypeOfDottedName(node.expression /*diagnostic*/, nil)
			} else if node.expression.kind != SyntaxKindSuperKeyword {
				if isOptionalChain(node) {
					funcType = checkNonNullType(getOptionalExpressionType(checkExpression(node.expression), node.expression), node.expression)
				} else {
					funcType = checkNonNullExpression(node.expression)
				}
			}
			signatures := getSignaturesOfType(funcType && getApparentType(funcType) || unknownType, SignatureKindCall)
			var candidate *Signature
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case signatures.length == 1 && !signatures[0].typeParameters:
				candidate = signatures[0]
			case some(signatures, hasTypePredicateOrNeverReturnType):
				candidate = getResolvedSignature(node)
			default:
				candidate = nil
			}
			signature = /* TODO(TS-TO-GO) Node BinaryExpression: links.effectsSignature = candidate && hasTypePredicateOrNeverReturnType(candidate) ? candidate : unknownSignature */ TODO
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case signature == unknownSignature:
			return nil
		default:
			return signature
		}
	}
	hasTypePredicateOrNeverReturnType := func(signature Signature) bool {
		return !!(getTypePredicateOfSignature(signature) || signature.declaration && (getReturnTypeFromAnnotation(signature.declaration) || unknownType).flags&TypeFlagsNever)
	}
	getTypePredicateArgument := func(predicate TypePredicate, callExpression CallExpression) Expression {
		if predicate.kind == TypePredicateKindIdentifier || predicate.kind == TypePredicateKindAssertsIdentifier {
			return callExpression.arguments[predicate.parameterIndex]
		}
		invokedExpression := skipParentheses(callExpression.expression)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isAccessExpression(invokedExpression):
			return skipParentheses(invokedExpression.expression)
		default:
			return nil
		}
	}
	reportFlowControlError := func(node Node) {
		block := findAncestor(node, isFunctionOrModuleBlock) /* as Block | ModuleBlock | SourceFile */
		sourceFile := getSourceFileOfNode(node)
		span := getSpanOfTokenAtPosition(sourceFile, block.statements.pos)
		diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_containing_function_or_module_body_is_too_large_for_control_flow_analysis))
	}
	isReachableFlowNode := func(flow FlowNode) bool {
		result := isReachableFlowNodeWorker(flow /*noCacheCheck*/, false)
		lastFlowNode = flow
		lastFlowNodeReachable = result
		return result
	}
	isFalseExpression := func(expr Expression) bool {
		node := skipParentheses(expr /*excludeJSDocTypeAssertions*/, true)
		return node.kind == SyntaxKindFalseKeyword || node.kind == SyntaxKindBinaryExpression && ((node /* as BinaryExpression */).operatorToken.kind == SyntaxKindAmpersandAmpersandToken && (isFalseExpression((node /* as BinaryExpression */).left) || isFalseExpression((node /* as BinaryExpression */).right)) || (node /* as BinaryExpression */).operatorToken.kind == SyntaxKindBarBarToken && isFalseExpression((node /* as BinaryExpression */).left) && isFalseExpression((node /* as BinaryExpression */).right))
	}
	isReachableFlowNodeWorker := func(flow FlowNode, noCacheCheck bool) bool {
		for true {
			if flow == lastFlowNode {
				return lastFlowNodeReachable
			}
			flags := flow.flags
			if flags & FlowFlagsShared {
				if !noCacheCheck {
					id := getFlowNodeId(flow)
					reachable := flowNodeReachable[id]
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case reachable != nil:
						return reachable
					default:
						return ( /* TODO(TS-TO-GO) Node BinaryExpression: flowNodeReachable[id] = isReachableFlowNodeWorker(flow, /*noCacheCheck* / true) */ TODO)
					}
				}
				noCacheCheck = false
			}
			if flags & (FlowFlagsAssignment | FlowFlagsCondition | FlowFlagsArrayMutation) {
				flow = (flow /* as FlowAssignment | FlowCondition | FlowArrayMutation */).antecedent
			} else if flags & FlowFlagsCall {
				signature := getEffectsSignature((flow /* as FlowCall */).node)
				if signature {
					predicate := getTypePredicateOfSignature(signature)
					if predicate && predicate.kind == TypePredicateKindAssertsIdentifier && !predicate.type_ {
						predicateArgument := (flow /* as FlowCall */).node.arguments[predicate.parameterIndex]
						if predicateArgument && isFalseExpression(predicateArgument) {
							return false
						}
					}
					if getReturnTypeOfSignature(signature).flags & TypeFlagsNever {
						return false
					}
				}
				flow = (flow /* as FlowCall */).antecedent
			} else if flags & FlowFlagsBranchLabel {
				// A branching point is reachable if any branch is reachable.
				return some((flow /* as FlowLabel */).antecedent, func(f FlowNode) bool {
					return isReachableFlowNodeWorker(f /*noCacheCheck*/, false)
				})
			} else if flags & FlowFlagsLoopLabel {
				antecedents := (flow /* as FlowLabel */).antecedent
				if antecedents == nil || antecedents.length == 0 {
					return false
				}
				// A loop is reachable if the control flow path that leads to the top is reachable.
				flow = antecedents[0]
			} else if flags & FlowFlagsSwitchClause {
				// The control flow path representing an unmatched value in a switch statement with
				// no default clause is unreachable if the switch statement is exhaustive.
				data := (flow /* as FlowSwitchClause */).node
				if data.clauseStart == data.clauseEnd && isExhaustiveSwitchStatement(data.switchStatement) {
					return false
				}
				flow = (flow /* as FlowSwitchClause */).antecedent
			} else if flags & FlowFlagsReduceLabel {
				// Cache is unreliable once we start adjusting labels
				lastFlowNode = nil
				target := (flow /* as FlowReduceLabel */).node.target
				saveAntecedents := target.antecedent
				target.antecedent = (flow /* as FlowReduceLabel */).node.antecedents
				result := isReachableFlowNodeWorker((flow /* as FlowReduceLabel */).antecedent /*noCacheCheck*/, false)
				target.antecedent = saveAntecedents
				return result
			} else {
				return !(flags & FlowFlagsUnreachable)
			}
		}
	}
	// Return true if the given flow node is preceded by a 'super(...)' call in every possible code path
	// leading to the node.
	isPostSuperFlowNode := func(flow FlowNode, noCacheCheck bool) bool {
		for true {
			flags := flow.flags
			if flags & FlowFlagsShared {
				if !noCacheCheck {
					id := getFlowNodeId(flow)
					postSuper := flowNodePostSuper[id]
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case postSuper != nil:
						return postSuper
					default:
						return ( /* TODO(TS-TO-GO) Node BinaryExpression: flowNodePostSuper[id] = isPostSuperFlowNode(flow, /*noCacheCheck* / true) */ TODO)
					}
				}
				noCacheCheck = false
			}
			if flags & (FlowFlagsAssignment | FlowFlagsCondition | FlowFlagsArrayMutation | FlowFlagsSwitchClause) {
				flow = (flow /* as FlowAssignment | FlowCondition | FlowArrayMutation | FlowSwitchClause */).antecedent
			} else if flags & FlowFlagsCall {
				if (flow /* as FlowCall */).node.expression.kind == SyntaxKindSuperKeyword {
					return true
				}
				flow = (flow /* as FlowCall */).antecedent
			} else if flags & FlowFlagsBranchLabel {
				// A branching point is post-super if every branch is post-super.
				return every((flow /* as FlowLabel */).antecedent, func(f FlowNode) bool {
					return isPostSuperFlowNode(f /*noCacheCheck*/, false)
				})
			} else if flags & FlowFlagsLoopLabel {
				// A loop is post-super if the control flow path that leads to the top is post-super.
				flow = (flow /* as FlowLabel */).antecedent[0]
			} else if flags & FlowFlagsReduceLabel {
				target := (flow /* as FlowReduceLabel */).node.target
				saveAntecedents := target.antecedent
				target.antecedent = (flow /* as FlowReduceLabel */).node.antecedents
				result := isPostSuperFlowNode((flow /* as FlowReduceLabel */).antecedent /*noCacheCheck*/, false)
				target.antecedent = saveAntecedents
				return result
			} else {
				// Unreachable nodes are considered post-super to silence errors
				return !!(flags & FlowFlagsUnreachable)
			}
		}
	}
	isConstantReference := func(node Node) bool {
		switch node.kind {
		case SyntaxKindThisKeyword:
			return true
		case SyntaxKindIdentifier:
			if !isThisInTypeQuery(node) {
				symbol := getResolvedSymbol(node /* as Identifier */)
				return isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol) || !!symbol.valueDeclaration && isFunctionExpression(symbol.valueDeclaration)
			}
			break
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindElementAccessExpression:
			return isConstantReference((node /* as AccessExpression */).expression) && isReadonlySymbol(getNodeLinks(node).resolvedSymbol || unknownSymbol)
		case SyntaxKindObjectBindingPattern:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrayBindingPattern:
			rootDeclaration := getRootDeclaration(node.parent)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isParameter(rootDeclaration) || isCatchClauseVariableDeclaration(rootDeclaration):
				return !isSomeSymbolAssigned(rootDeclaration)
			default:
				return isVariableDeclaration(rootDeclaration) && isVarConstLike(rootDeclaration)
			}
		}
		return false
	}
	getFlowTypeOfReference := func(reference Node, declaredType Type, initialType Type /*  = declaredType */, flowContainer Node, flowNode *FlowNode /*  = tryCast(reference, canHaveFlowNode)?.flowNode */) Type {
		var key *string
		isKeySet := false
		flowDepth := 0
		if flowAnalysisDisabled {
			return errorType
		}
		if !flowNode {
			return declaredType
		}
		flowInvocationCount++
		sharedFlowStart := sharedFlowCount
		evolvedType := getTypeFromFlowType(getTypeAtFlowNode(flowNode))
		sharedFlowCount = sharedFlowStart
		// When the reference is 'x' in an 'x.length', 'x.push(value)', 'x.unshift(value)' or x[n] = value' operation,
		// we give type 'any[]' to 'x' instead of using the type determined by control flow analysis such that operations
		// on empty arrays are possible without implicit any errors and new element types can be inferred without
		// type mismatch errors.
		var resultType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getObjectFlags(evolvedType)&ObjectFlagsEvolvingArray && isEvolvingArrayOperationTarget(reference):
			resultType = autoArrayType
		default:
			resultType = finalizeEvolvingArrayType(evolvedType)
		}
		if resultType == unreachableNeverType || reference.parent && reference.parent.kind == SyntaxKindNonNullExpression && !(resultType.flags&TypeFlagsNever) && getTypeWithFacts(resultType, TypeFactsNEUndefinedOrNull).flags&TypeFlagsNever {
			return declaredType
		}
		return resultType
		getOrSetCacheKey := func() *string {
			if isKeySet {
				return key
			}
			isKeySet = true
			key = getFlowCacheKey(reference, declaredType, initialType, flowContainer)
			return key
		}
		getTypeAtFlowNode := func(flow FlowNode) FlowType {
			if flowDepth == 2000 {
				// We have made 2000 recursive invocations. To avoid overflowing the call stack we report an error
				// and disable further control flow analysis in the containing function or module body.
				tracing. /* TODO(TS-TO-GO): was ? */ instant(tracing.Phase.CheckTypes, "getTypeAtFlowNode_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"flowId": flow.id,
				})
				flowAnalysisDisabled = true
				reportFlowControlError(reference)
				return errorType
			}
			flowDepth++
			var sharedFlow *FlowNode
			for true {
				flags := flow.flags
				if flags & FlowFlagsShared {
					// We cache results of flow type resolution for shared nodes that were previously visited in
					// the same getFlowTypeOfReference invocation. A node is considered shared when it is the
					// antecedent of more than one node.
					for i := sharedFlowStart; i < sharedFlowCount; i++ {
						if sharedFlowNodes[i] == flow {
							flowDepth--
							return sharedFlowTypes[i]
						}
					}
					sharedFlow = flow
				}
				var type_ *FlowType
				if flags & FlowFlagsAssignment {
					type_ = getTypeAtFlowAssignment(flow /* as FlowAssignment */)
					if !type_ {
						flow = (flow /* as FlowAssignment */).antecedent
						continue
					}
				} else if flags & FlowFlagsCall {
					type_ = getTypeAtFlowCall(flow /* as FlowCall */)
					if !type_ {
						flow = (flow /* as FlowCall */).antecedent
						continue
					}
				} else if flags & FlowFlagsCondition {
					type_ = getTypeAtFlowCondition(flow /* as FlowCondition */)
				} else if flags & FlowFlagsSwitchClause {
					type_ = getTypeAtSwitchClause(flow /* as FlowSwitchClause */)
				} else if flags & FlowFlagsLabel {
					if (flow /* as FlowLabel */).antecedent.length == 1 {
						flow = (flow /* as FlowLabel */).antecedent[0]
						continue
					}
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case flags & FlowFlagsBranchLabel:
						type_ = getTypeAtFlowBranchLabel(flow /* as FlowLabel */)
					default:
						type_ = getTypeAtFlowLoopLabel(flow /* as FlowLabel */)
					}
				} else if flags & FlowFlagsArrayMutation {
					type_ = getTypeAtFlowArrayMutation(flow /* as FlowArrayMutation */)
					if !type_ {
						flow = (flow /* as FlowArrayMutation */).antecedent
						continue
					}
				} else if flags & FlowFlagsReduceLabel {
					target := (flow /* as FlowReduceLabel */).node.target
					saveAntecedents := target.antecedent
					target.antecedent = (flow /* as FlowReduceLabel */).node.antecedents
					type_ = getTypeAtFlowNode((flow /* as FlowReduceLabel */).antecedent)
					target.antecedent = saveAntecedents
				} else if flags & FlowFlagsStart {
					// Check if we should continue with the control flow of the containing function.
					container := (flow /* as FlowStart */).node
					if container && container != flowContainer && reference.kind != SyntaxKindPropertyAccessExpression && reference.kind != SyntaxKindElementAccessExpression && !(reference.kind == SyntaxKindThisKeyword && container.kind != SyntaxKindArrowFunction) {
						flow = container.flowNode
						continue
					}
					// At the top of the flow we have the initial type.
					type_ = initialType
				} else {
					// Unreachable code errors are reported in the binding phase. Here we
					// simply return the non-auto declared type to reduce follow-on errors.
					type_ = convertAutoToAny(declaredType)
				}
				if sharedFlow {
					// Record visited node and the associated type in the cache.
					sharedFlowNodes[sharedFlowCount] = sharedFlow
					sharedFlowTypes[sharedFlowCount] = type_
					sharedFlowCount++
				}
				flowDepth--
				return type_
			}
		}
		getInitialOrAssignedType := func(flow FlowAssignment) Type {
			node := flow.node
			return getNarrowableTypeForReference(__COND__(node.kind == SyntaxKindVariableDeclaration || node.kind == SyntaxKindBindingElement, getInitialType(node /* as VariableDeclaration | BindingElement */), getAssignedType(node)), reference)
		}
		getTypeAtFlowAssignment := func(flow FlowAssignment) *FlowType {
			node := flow.node
			// Assignments only narrow the computed type if the declared type is a union type. Thus, we
			// only need to evaluate the assigned type if the declared type is a union type.
			if isMatchingReference(reference, node) {
				if !isReachableFlowNode(flow) {
					return unreachableNeverType
				}
				if getAssignmentTargetKind(node) == AssignmentKindCompound {
					flowType := getTypeAtFlowNode(flow.antecedent)
					return createFlowType(getBaseTypeOfLiteralType(getTypeFromFlowType(flowType)), isIncomplete(flowType))
				}
				if declaredType == autoType || declaredType == autoArrayType {
					if isEmptyArrayAssignment(node) {
						return getEvolvingArrayType(neverType)
					}
					assignedType := getWidenedLiteralType(getInitialOrAssignedType(flow))
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isTypeAssignableTo(assignedType, declaredType):
						return assignedType
					default:
						return anyArrayType
					}
				}
				var t Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isInCompoundLikeAssignment(node):
					t = getBaseTypeOfLiteralType(declaredType)
				default:
					t = declaredType
				}
				if t.flags & TypeFlagsUnion {
					return getAssignmentReducedType(t /* as UnionType */, getInitialOrAssignedType(flow))
				}
				return t
			}
			// We didn't have a direct match. However, if the reference is a dotted name, this
			// may be an assignment to a left hand part of the reference. For example, for a
			// reference 'x.y.z', we may be at an assignment to 'x.y' or 'x'. In that case,
			// return the declared type.
			if containsMatchingReference(reference, node) {
				if !isReachableFlowNode(flow) {
					return unreachableNeverType
				}
				// A matching dotted name might also be an expando property on a function *expression*,
				// in which case we continue control flow analysis back to the function's declaration
				if isVariableDeclaration(node) && (isInJSFile(node) || isVarConstLike(node)) {
					init := getDeclaredExpandoInitializer(node)
					if init && (init.kind == SyntaxKindFunctionExpression || init.kind == SyntaxKindArrowFunction) {
						return getTypeAtFlowNode(flow.antecedent)
					}
				}
				return declaredType
			}
			// for (const _ in ref) acts as a nonnull on ref
			if isVariableDeclaration(node) && node.parent.parent.kind == SyntaxKindForInStatement && (isMatchingReference(reference, node.parent.parent.expression) || optionalChainContainsReference(node.parent.parent.expression, reference)) {
				return getNonNullableTypeIfNeeded(finalizeEvolvingArrayType(getTypeFromFlowType(getTypeAtFlowNode(flow.antecedent))))
			}
			// Assignment doesn't affect reference
			return nil
		}
		narrowTypeByAssertion := func(type_ Type, expr Expression) Type {
			node := skipParentheses(expr /*excludeJSDocTypeAssertions*/, true)
			if node.kind == SyntaxKindFalseKeyword {
				return unreachableNeverType
			}
			if node.kind == SyntaxKindBinaryExpression {
				if (node /* as BinaryExpression */).operatorToken.kind == SyntaxKindAmpersandAmpersandToken {
					return narrowTypeByAssertion(narrowTypeByAssertion(type_, (node /* as BinaryExpression */).left), (node /* as BinaryExpression */).right)
				}
				if (node /* as BinaryExpression */).operatorToken.kind == SyntaxKindBarBarToken {
					return getUnionType([]Type{narrowTypeByAssertion(type_, (node /* as BinaryExpression */).left), narrowTypeByAssertion(type_, (node /* as BinaryExpression */).right)})
				}
			}
			return narrowType(type_, node /*assumeTrue*/, true)
		}
		getTypeAtFlowCall := func(flow FlowCall) *FlowType {
			signature := getEffectsSignature(flow.node)
			if signature {
				predicate := getTypePredicateOfSignature(signature)
				if predicate && (predicate.kind == TypePredicateKindAssertsThis || predicate.kind == TypePredicateKindAssertsIdentifier) {
					flowType := getTypeAtFlowNode(flow.antecedent)
					type_ := finalizeEvolvingArrayType(getTypeFromFlowType(flowType))
					var narrowedType Type
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case predicate.type_:
						narrowedType = narrowTypeByTypePredicate(type_, predicate, flow.node /*assumeTrue*/, true)
					case predicate.kind == TypePredicateKindAssertsIdentifier && predicate.parameterIndex >= 0 && predicate.parameterIndex < flow.node.arguments.length:
						narrowedType = narrowTypeByAssertion(type_, flow.node.arguments[predicate.parameterIndex])
					default:
						narrowedType = type_
					}
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case narrowedType == type_:
						return flowType
					default:
						return createFlowType(narrowedType, isIncomplete(flowType))
					}
				}
				if getReturnTypeOfSignature(signature).flags & TypeFlagsNever {
					return unreachableNeverType
				}
			}
			return nil
		}
		getTypeAtFlowArrayMutation := func(flow FlowArrayMutation) *FlowType {
			if declaredType == autoType || declaredType == autoArrayType {
				node := flow.node
				var expr LeftHandSideExpression
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case node.kind == SyntaxKindCallExpression:
					expr = (node.expression /* as PropertyAccessExpression */).expression
				default:
					expr = (node.left /* as ElementAccessExpression */).expression
				}
				if isMatchingReference(reference, getReferenceCandidate(expr)) {
					flowType := getTypeAtFlowNode(flow.antecedent)
					type_ := getTypeFromFlowType(flowType)
					if getObjectFlags(type_) & ObjectFlagsEvolvingArray {
						evolvedType := type_ /* as EvolvingArrayType */
						if node.kind == SyntaxKindCallExpression {
							for _, arg := range node.arguments {
								evolvedType = addEvolvingArrayElementType(evolvedType, arg)
							}
						} else {
							// We must get the context free expression type so as to not recur in an uncached fashion on the LHS (which causes exponential blowup in compile time)
							indexType := getContextFreeTypeOfExpression((node.left /* as ElementAccessExpression */).argumentExpression)
							if isTypeAssignableToKind(indexType, TypeFlagsNumberLike) {
								evolvedType = addEvolvingArrayElementType(evolvedType, node.right)
							}
						}
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case evolvedType == type_:
							return flowType
						default:
							return createFlowType(evolvedType, isIncomplete(flowType))
						}
					}
					return flowType
				}
			}
			return nil
		}
		getTypeAtFlowCondition := func(flow FlowCondition) FlowType {
			flowType := getTypeAtFlowNode(flow.antecedent)
			type_ := getTypeFromFlowType(flowType)
			if type_.flags & TypeFlagsNever {
				return flowType
			}
			// If we have an antecedent type (meaning we're reachable in some way), we first
			// attempt to narrow the antecedent type. If that produces the never type, and if
			// the antecedent type is incomplete (i.e. a transient type in a loop), then we
			// take the type guard as an indication that control *could* reach here once we
			// have the complete type. We proceed by switching to the silent never type which
			// doesn't report errors when operators are applied to it. Note that this is the
			// *only* place a silent never type is ever generated.
			assumeTrue := (flow.flags & FlowFlagsTrueCondition) != 0
			nonEvolvingType := finalizeEvolvingArrayType(type_)
			narrowedType := narrowType(nonEvolvingType, flow.node, assumeTrue)
			if narrowedType == nonEvolvingType {
				return flowType
			}
			return createFlowType(narrowedType, isIncomplete(flowType))
		}
		getTypeAtSwitchClause := func(flow FlowSwitchClause) FlowType {
			expr := skipParentheses(flow.node.switchStatement.expression)
			flowType := getTypeAtFlowNode(flow.antecedent)
			type_ := getTypeFromFlowType(flowType)
			if isMatchingReference(reference, expr) {
				type_ = narrowTypeBySwitchOnDiscriminant(type_, flow.node)
			} else if expr.kind == SyntaxKindTypeOfExpression && isMatchingReference(reference, (expr /* as TypeOfExpression */).expression) {
				type_ = narrowTypeBySwitchOnTypeOf(type_, flow.node)
			} else if expr.kind == SyntaxKindTrueKeyword {
				type_ = narrowTypeBySwitchOnTrue(type_, flow.node)
			} else {
				if strictNullChecks {
					if optionalChainContainsReference(expr, reference) {
						type_ = narrowTypeBySwitchOptionalChainContainment(type_, flow.node, func(t Type) bool {
							return !(t.flags & (TypeFlagsUndefined | TypeFlagsNever))
						})
					} else if expr.kind == SyntaxKindTypeOfExpression && optionalChainContainsReference((expr /* as TypeOfExpression */).expression, reference) {
						type_ = narrowTypeBySwitchOptionalChainContainment(type_, flow.node, func(t Type) bool {
							return !(t.flags&TypeFlagsNever || t.flags&TypeFlagsStringLiteral && (t /* as StringLiteralType */).value == "undefined")
						})
					}
				}
				access := getDiscriminantPropertyAccess(expr, type_)
				if access {
					type_ = narrowTypeBySwitchOnDiscriminantProperty(type_, access, flow.node)
				}
			}
			return createFlowType(type_, isIncomplete(flowType))
		}
		getTypeAtFlowBranchLabel := func(flow FlowLabel) FlowType {
			var antecedentTypes []Type = []never{}
			subtypeReduction := false
			seenIncomplete := false
			var bypassFlow *FlowSwitchClause
			for _, antecedent := range flow.antecedent {
				if !bypassFlow && antecedent.flags&FlowFlagsSwitchClause && (antecedent /* as FlowSwitchClause */).node.clauseStart == (antecedent /* as FlowSwitchClause */).node.clauseEnd {
					// The antecedent is the bypass branch of a potentially exhaustive switch statement.
					bypassFlow = antecedent /* as FlowSwitchClause */
					continue
				}
				flowType := getTypeAtFlowNode(antecedent)
				type_ := getTypeFromFlowType(flowType)
				// If the type at a particular antecedent path is the declared type and the
				// reference is known to always be assigned (i.e. when declared and initial types
				// are the same), there is no reason to process more antecedents since the only
				// possible outcome is subtypes that will be removed in the final union type anyway.
				if type_ == declaredType && declaredType == initialType {
					return type_
				}
				pushIfUnique(antecedentTypes, type_)
				// If an antecedent type is not a subset of the declared type, we need to perform
				// subtype reduction. This happens when a "foreign" type is injected into the control
				// flow using the instanceof operator or a user defined type predicate.
				if !isTypeSubsetOf(type_, initialType) {
					subtypeReduction = true
				}
				if isIncomplete(flowType) {
					seenIncomplete = true
				}
			}
			if bypassFlow {
				flowType := getTypeAtFlowNode(bypassFlow)
				type_ := getTypeFromFlowType(flowType)
				// If the bypass flow contributes a type we haven't seen yet and the switch statement
				// isn't exhaustive, process the bypass flow type. Since exhaustiveness checks increase
				// the risk of circularities, we only want to perform them when they make a difference.
				if !(type_.flags & TypeFlagsNever) && !contains(antecedentTypes, type_) && !isExhaustiveSwitchStatement(bypassFlow.node.switchStatement) {
					if type_ == declaredType && declaredType == initialType {
						return type_
					}
					antecedentTypes.push(type_)
					if !isTypeSubsetOf(type_, initialType) {
						subtypeReduction = true
					}
					if isIncomplete(flowType) {
						seenIncomplete = true
					}
				}
			}
			return createFlowType(getUnionOrEvolvingArrayType(antecedentTypes, __COND__(subtypeReduction, UnionReductionSubtype, UnionReductionLiteral)), seenIncomplete)
		}
		getTypeAtFlowLoopLabel := func(flow FlowLabel) FlowType {
			// If we have previously computed the control flow type for the reference at
			// this flow loop junction, return the cached type.
			id := getFlowNodeId(flow)
			cache := flowLoopCaches[id] || ( /* TODO(TS-TO-GO) Node BinaryExpression: flowLoopCaches[id] = new Map<string, Type>() */ TODO)
			key := getOrSetCacheKey()
			if !key {
				// No cache key is generated when binding patterns are in unnarrowable situations
				return declaredType
			}
			cached := cache.get(key)
			if cached {
				return cached
			}
			// If this flow loop junction and reference are already being processed, return
			// the union of the types computed for each branch so far, marked as incomplete.
			// It is possible to see an empty array in cases where loops are nested and the
			// back edge of the outer loop reaches an inner loop that is already being analyzed.
			// In such cases we restart the analysis of the inner loop, which will then see
			// a non-empty in-process array for the outer loop and eventually terminate because
			// the first antecedent of a loop junction is always the non-looping control flow
			// path that leads to the top.
			for i := flowLoopStart; i < flowLoopCount; i++ {
				if flowLoopNodes[i] == flow && flowLoopKeys[i] == key && flowLoopTypes[i].length {
					return createFlowType(getUnionOrEvolvingArrayType(flowLoopTypes[i], UnionReductionLiteral) /*incomplete*/, true)
				}
			}
			// Add the flow loop junction and reference to the in-process stack and analyze
			// each antecedent code path.
			var antecedentTypes []Type = []never{}
			subtypeReduction := false
			var firstAntecedentType *FlowType
			for _, antecedent := range flow.antecedent {
				var flowType TODO
				if !firstAntecedentType {
					// The first antecedent of a loop junction is always the non-looping control
					// flow path that leads to the top.
					flowType = /* TODO(TS-TO-GO) Node BinaryExpression: firstAntecedentType = getTypeAtFlowNode(antecedent) */ TODO
				} else {
					// All but the first antecedent are the looping control flow paths that lead
					// back to the loop junction. We track these on the flow loop stack.
					flowLoopNodes[flowLoopCount] = flow
					flowLoopKeys[flowLoopCount] = key
					flowLoopTypes[flowLoopCount] = antecedentTypes
					flowLoopCount++
					saveFlowTypeCache := flowTypeCache
					flowTypeCache = nil
					flowType = getTypeAtFlowNode(antecedent)
					flowTypeCache = saveFlowTypeCache
					flowLoopCount--
					// If we see a value appear in the cache it is a sign that control flow analysis
					// was restarted and completed by checkExpressionCached. We can simply pick up
					// the resulting type and bail out.
					cached := cache.get(key)
					if cached {
						return cached
					}
				}
				type_ := getTypeFromFlowType(flowType)
				pushIfUnique(antecedentTypes, type_)
				// If an antecedent type is not a subset of the declared type, we need to perform
				// subtype reduction. This happens when a "foreign" type is injected into the control
				// flow using the instanceof operator or a user defined type predicate.
				if !isTypeSubsetOf(type_, initialType) {
					subtypeReduction = true
				}
				// If the type at a particular antecedent path is the declared type there is no
				// reason to process more antecedents since the only possible outcome is subtypes
				// that will be removed in the final union type anyway.
				if type_ == declaredType {
					break
				}
			}
			// The result is incomplete if the first antecedent (the non-looping control flow path)
			// is incomplete.
			result := getUnionOrEvolvingArrayType(antecedentTypes, __COND__(subtypeReduction, UnionReductionSubtype, UnionReductionLiteral))
			if isIncomplete(firstAntecedentType) {
				return createFlowType(result /*incomplete*/, true)
			}
			cache.set(key, result)
			return result
		}
		// At flow control branch or loop junctions, if the type along every antecedent code path
		// is an evolving array type, we construct a combined evolving array type. Otherwise we
		// finalize all evolving array types.
		getUnionOrEvolvingArrayType := func(types []Type, subtypeReduction UnionReduction) Type {
			if isEvolvingArrayTypeList(types) {
				return getEvolvingArrayType(getUnionType(map_(types, getElementTypeOfEvolvingArrayType)))
			}
			result := recombineUnknownType(getUnionType(sameMap(types, finalizeEvolvingArrayType), subtypeReduction))
			if result != declaredType && result.flags&declaredType.flags&TypeFlagsUnion && arrayIsEqualTo((result /* as UnionType */).types, (declaredType /* as UnionType */).types) {
				return declaredType
			}
			return result
		}
		getCandidateDiscriminantPropertyAccess := func(expr Expression) * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | BindingElement | AccessExpression */ any {
			if isBindingPattern(reference) || isFunctionExpressionOrArrowFunction(reference) || isObjectLiteralMethod(reference) {
				// When the reference is a binding pattern or function or arrow expression, we are narrowing a pesudo-reference in
				// getNarrowedTypeOfSymbol. An identifier for a destructuring variable declared in the same binding pattern or
				// parameter declared in the same parameter list is a candidate.
				if isIdentifier(expr) {
					symbol := getResolvedSymbol(expr)
					declaration := symbol.valueDeclaration
					if declaration && (isBindingElement(declaration) || isParameter(declaration)) && reference == declaration.parent && !declaration.initializer && !declaration.dotDotDotToken {
						return declaration
					}
				}
			} else if isAccessExpression(expr) {
				// An access expression is a candidate if the reference matches the left hand expression.
				if isMatchingReference(reference, expr.expression) {
					return expr
				}
			} else if isIdentifier(expr) {
				symbol := getResolvedSymbol(expr)
				if isConstantVariable(symbol) {
					declaration := symbol.valueDeclaration
					// Given 'const x = obj.kind', allow 'x' as an alias for 'obj.kind'
					if isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && isAccessExpression(declaration.initializer) && isMatchingReference(reference, declaration.initializer.expression) {
						return declaration.initializer
					}
					// Given 'const { kind: x } = obj', allow 'x' as an alias for 'obj.kind'
					if isBindingElement(declaration) && !declaration.initializer {
						parent := declaration.parent.parent
						if isVariableDeclaration(parent) && !parent.type_ && parent.initializer && (isIdentifier(parent.initializer) || isAccessExpression(parent.initializer)) && isMatchingReference(reference, parent.initializer) {
							return declaration
						}
					}
				}
			}
			return nil
		}
		getDiscriminantPropertyAccess := func(expr Expression, computedType Type) * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | BindingElement | AccessExpression */ any {
			// As long as the computed type is a subset of the declared type, we use the full declared type to detect
			// a discriminant property. In cases where the computed type isn't a subset, e.g because of a preceding type
			// predicate narrowing, we use the actual computed type.
			if declaredType.flags&TypeFlagsUnion || computedType.flags&TypeFlagsUnion {
				access := getCandidateDiscriminantPropertyAccess(expr)
				if access {
					name := getAccessedPropertyName(access)
					if name {
						var type_ Type
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case declaredType.flags&TypeFlagsUnion && isTypeSubsetOf(computedType, declaredType):
							type_ = declaredType
						default:
							type_ = computedType
						}
						if isDiscriminantProperty(type_, name) {
							return access
						}
					}
				}
			}
			return nil
		}
		narrowTypeByDiscriminant := func(type_ Type, access /* TODO(TS-TO-GO) TypeNode UnionType: AccessExpression | BindingElement | ParameterDeclaration */ any, narrowType func(t Type) Type) Type {
			propName := getAccessedPropertyName(access)
			if propName == nil {
				return type_
			}
			optionalChain := isOptionalChain(access)
			removeNullable := strictNullChecks && (optionalChain || isNonNullAccess(access)) && maybeTypeOfKind(type_, TypeFlagsNullable)
			propType := getTypeOfPropertyOfType(__COND__(removeNullable, getTypeWithFacts(type_, TypeFactsNEUndefinedOrNull), type_), propName)
			if !propType {
				return type_
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case removeNullable && optionalChain:
				propType = getOptionalType(propType)
			default:
				propType = propType
			}
			narrowedPropType := narrowType(propType)
			return filterType(type_, func(t Type) bool {
				discriminantType := getTypeOfPropertyOrIndexSignatureOfType(t, propName) || unknownType
				return !(discriminantType.flags & TypeFlagsNever) && !(narrowedPropType.flags & TypeFlagsNever) && areTypesComparable(narrowedPropType, discriminantType)
			})
		}
		narrowTypeByDiscriminantProperty := func(type_ Type, access /* TODO(TS-TO-GO) TypeNode UnionType: AccessExpression | BindingElement | ParameterDeclaration */ any, operator SyntaxKind, value Expression, assumeTrue bool) Type {
			if (operator == SyntaxKindEqualsEqualsEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken) && type_.flags&TypeFlagsUnion {
				keyPropertyName := getKeyPropertyName(type_ /* as UnionType */)
				if keyPropertyName && keyPropertyName == getAccessedPropertyName(access) {
					candidate := getConstituentTypeForKeyType(type_ /* as UnionType */, getTypeOfExpression(value))
					if candidate {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case operator == (__COND__(assumeTrue, SyntaxKindEqualsEqualsEqualsToken, SyntaxKindExclamationEqualsEqualsToken)):
							return candidate
						case isUnitType(getTypeOfPropertyOfType(candidate, keyPropertyName) || unknownType):
							return removeType(type_, candidate)
						default:
							return type_
						}
					}
				}
			}
			return narrowTypeByDiscriminant(type_, access, func(t Type) Type {
				return narrowTypeByEquality(t, operator, value, assumeTrue)
			})
		}
		narrowTypeBySwitchOnDiscriminantProperty := func(type_ Type, access /* TODO(TS-TO-GO) TypeNode UnionType: AccessExpression | BindingElement | ParameterDeclaration */ any, data FlowSwitchClauseData) Type {
			if data.clauseStart < data.clauseEnd && type_.flags&TypeFlagsUnion && getKeyPropertyName(type_ /* as UnionType */) == getAccessedPropertyName(access) {
				clauseTypes := getSwitchClauseTypes(data.switchStatement).slice(data.clauseStart, data.clauseEnd)
				candidate := getUnionType(map_(clauseTypes, func(t Type) Type {
					return getConstituentTypeForKeyType(type_ /* as UnionType */, t) || unknownType
				}))
				if candidate != unknownType {
					return candidate
				}
			}
			return narrowTypeByDiscriminant(type_, access, func(t Type) Type {
				return narrowTypeBySwitchOnDiscriminant(t, data)
			})
		}
		narrowTypeByTruthiness := func(type_ Type, expr Expression, assumeTrue bool) Type {
			if isMatchingReference(reference, expr) {
				return getAdjustedTypeWithFacts(type_, __COND__(assumeTrue, TypeFactsTruthy, TypeFactsFalsy))
			}
			if strictNullChecks && assumeTrue && optionalChainContainsReference(expr, reference) {
				type_ = getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
			}
			access := getDiscriminantPropertyAccess(expr, type_)
			if access {
				return narrowTypeByDiscriminant(type_, access, func(t Type) Type {
					return getTypeWithFacts(t, __COND__(assumeTrue, TypeFactsTruthy, TypeFactsFalsy))
				})
			}
			return type_
		}
		isTypePresencePossible := func(type_ Type, propName __String, assumeTrue bool) bool {
			prop := getPropertyOfType(type_, propName)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case prop:
				return !!(prop.flags&SymbolFlagsOptional || getCheckFlags(prop)&CheckFlagsPartial) || assumeTrue
			default:
				return !!getApplicableIndexInfoForName(type_, propName) || !assumeTrue
			}
		}
		narrowTypeByInKeyword := func(type_ Type, nameType /* TODO(TS-TO-GO) TypeNode UnionType: StringLiteralType | NumberLiteralType | UniqueESSymbolType */ any, assumeTrue bool) Type {
			name := getPropertyNameFromType(nameType)
			isKnownProperty := someType(type_, func(t Type) bool {
				return isTypePresencePossible(t, name /*assumeTrue*/, true)
			})
			if isKnownProperty {
				// If the check is for a known property (i.e. a property declared in some constituent of
				// the target type), we filter the target type by presence of absence of the property.
				return filterType(type_, func(t Type) bool {
					return isTypePresencePossible(t, name, assumeTrue)
				})
			}
			if assumeTrue {
				// If the check is for an unknown property, we intersect the target type with `Record<X, unknown>`,
				// where X is the name of the property.
				recordSymbol := getGlobalRecordSymbol()
				if recordSymbol {
					return getIntersectionType([]Type{type_, getTypeAliasInstantiation(recordSymbol, [] /* TODO(TS-TO-GO) inferred type IntrinsicType | StringLiteralType | NumberLiteralType | UniqueESSymbolType */ any{nameType, unknownType})})
				}
			}
			return type_
		}
		narrowTypeByBooleanComparison := func(type_ Type, expr Expression, bool BooleanLiteral, operator BinaryOperator, assumeTrue bool) Type {
			assumeTrue = (assumeTrue != (bool.kind == SyntaxKindTrueKeyword)) != (operator != SyntaxKindExclamationEqualsEqualsToken && operator != SyntaxKindExclamationEqualsToken)
			return narrowType(type_, expr, assumeTrue)
		}
		narrowTypeByBinaryExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
			switch expr.operatorToken.kind {
			case SyntaxKindEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindBarBarEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindAmpersandAmpersandEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindQuestionQuestionEqualsToken:
				return narrowTypeByTruthiness(narrowType(type_, expr.right, assumeTrue), expr.left, assumeTrue)
			case SyntaxKindEqualsEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindExclamationEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindEqualsEqualsEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindExclamationEqualsEqualsToken:
				operator := expr.operatorToken.kind
				left := getReferenceCandidate(expr.left)
				right := getReferenceCandidate(expr.right)
				if left.kind == SyntaxKindTypeOfExpression && isStringLiteralLike(right) {
					return narrowTypeByTypeof(type_, left /* as TypeOfExpression */, operator, right, assumeTrue)
				}
				if right.kind == SyntaxKindTypeOfExpression && isStringLiteralLike(left) {
					return narrowTypeByTypeof(type_, right /* as TypeOfExpression */, operator, left, assumeTrue)
				}
				if isMatchingReference(reference, left) {
					return narrowTypeByEquality(type_, operator, right, assumeTrue)
				}
				if isMatchingReference(reference, right) {
					return narrowTypeByEquality(type_, operator, left, assumeTrue)
				}
				if strictNullChecks {
					if optionalChainContainsReference(left, reference) {
						type_ = narrowTypeByOptionalChainContainment(type_, operator, right, assumeTrue)
					} else if optionalChainContainsReference(right, reference) {
						type_ = narrowTypeByOptionalChainContainment(type_, operator, left, assumeTrue)
					}
				}
				leftAccess := getDiscriminantPropertyAccess(left, type_)
				if leftAccess {
					return narrowTypeByDiscriminantProperty(type_, leftAccess, operator, right, assumeTrue)
				}
				rightAccess := getDiscriminantPropertyAccess(right, type_)
				if rightAccess {
					return narrowTypeByDiscriminantProperty(type_, rightAccess, operator, left, assumeTrue)
				}
				if isMatchingConstructorReference(left) {
					return narrowTypeByConstructor(type_, operator, right, assumeTrue)
				}
				if isMatchingConstructorReference(right) {
					return narrowTypeByConstructor(type_, operator, left, assumeTrue)
				}
				if isBooleanLiteral(right) && !isAccessExpression(left) {
					return narrowTypeByBooleanComparison(type_, left, right, operator, assumeTrue)
				}
				if isBooleanLiteral(left) && !isAccessExpression(right) {
					return narrowTypeByBooleanComparison(type_, right, left, operator, assumeTrue)
				}
				break
			case SyntaxKindInstanceOfKeyword:
				return narrowTypeByInstanceof(type_, expr /* as InstanceofExpression */, assumeTrue)
			case SyntaxKindInKeyword:
				if isPrivateIdentifier(expr.left) {
					return narrowTypeByPrivateIdentifierInInExpression(type_, expr, assumeTrue)
				}
				target := getReferenceCandidate(expr.right)
				if containsMissingType(type_) && isAccessExpression(reference) && isMatchingReference(reference.expression, target) {
					leftType := getTypeOfExpression(expr.left)
					if isTypeUsableAsPropertyName(leftType) && getAccessedPropertyName(reference) == getPropertyNameFromType(leftType) {
						return getTypeWithFacts(type_, __COND__(assumeTrue, TypeFactsNEUndefined, TypeFactsEQUndefined))
					}
				}
				if isMatchingReference(reference, target) {
					leftType := getTypeOfExpression(expr.left)
					if isTypeUsableAsPropertyName(leftType) {
						return narrowTypeByInKeyword(type_, leftType, assumeTrue)
					}
				}
				break
			case SyntaxKindCommaToken:
				return narrowType(type_, expr.right, assumeTrue)
			case SyntaxKindAmpersandAmpersandToken:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case assumeTrue:
					return narrowType(narrowType(type_, expr.left /*assumeTrue*/, true), expr.right /*assumeTrue*/, true)
				default:
					return getUnionType([]Type{narrowType(type_, expr.left /*assumeTrue*/, false), narrowType(type_, expr.right /*assumeTrue*/, false)})
				}
			case SyntaxKindBarBarToken:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case assumeTrue:
					return getUnionType([]Type{narrowType(type_, expr.left /*assumeTrue*/, true), narrowType(type_, expr.right /*assumeTrue*/, true)})
				default:
					return narrowType(narrowType(type_, expr.left /*assumeTrue*/, false), expr.right /*assumeTrue*/, false)
				}
			}
			return type_
		}
		narrowTypeByPrivateIdentifierInInExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
			target := getReferenceCandidate(expr.right)
			if !isMatchingReference(reference, target) {
				return type_
			}
			Debug.assertNode(expr.left, isPrivateIdentifier)
			symbol := getSymbolForPrivateIdentifierExpression(expr.left)
			if symbol == nil {
				return type_
			}
			classSymbol := symbol.parent
			var targetType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case hasStaticModifier(Debug.checkDefined(symbol.valueDeclaration, "should always have a declaration")):
				targetType = getTypeOfSymbol(classSymbol) /* as InterfaceType */
			default:
				targetType = getDeclaredTypeOfSymbol(classSymbol)
			}
			return getNarrowedType(type_, targetType, assumeTrue /*checkDerived*/, true)
		}
		narrowTypeByOptionalChainContainment := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
			// We are in a branch of obj?.foo === value (or any one of the other equality operators). We narrow obj as follows:
			// When operator is === and type of value excludes undefined, null and undefined is removed from type of obj in true branch.
			// When operator is !== and type of value excludes undefined, null and undefined is removed from type of obj in false branch.
			// When operator is == and type of value excludes null and undefined, null and undefined is removed from type of obj in true branch.
			// When operator is != and type of value excludes null and undefined, null and undefined is removed from type of obj in false branch.
			// When operator is === and type of value is undefined, null and undefined is removed from type of obj in false branch.
			// When operator is !== and type of value is undefined, null and undefined is removed from type of obj in true branch.
			// When operator is == and type of value is null or undefined, null and undefined is removed from type of obj in false branch.
			// When operator is != and type of value is null or undefined, null and undefined is removed from type of obj in true branch.
			equalsOperator := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindEqualsEqualsEqualsToken
			var nullableFlags /* TODO(TS-TO-GO) inferred type TypeFlags.Undefined | TypeFlags.Nullable */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindExclamationEqualsToken:
				nullableFlags = TypeFlagsNullable
			default:
				nullableFlags = TypeFlagsUndefined
			}
			valueType := getTypeOfExpression(value)
			// Note that we include any and unknown in the exclusion test because their domain includes null and undefined.
			removeNullable := equalsOperator != assumeTrue && everyType(valueType, func(t Type) bool {
				return !!(t.flags & nullableFlags)
			}) || equalsOperator == assumeTrue && everyType(valueType, func(t Type) bool {
				return !(t.flags & (TypeFlagsAnyOrUnknown | nullableFlags))
			})
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case removeNullable:
				return getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
			default:
				return type_
			}
		}
		narrowTypeByEquality := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
			if type_.flags & TypeFlagsAny {
				return type_
			}
			if operator == SyntaxKindExclamationEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken {
				assumeTrue = !assumeTrue
			}
			valueType := getTypeOfExpression(value)
			doubleEquals := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindExclamationEqualsToken
			if valueType.flags & TypeFlagsNullable {
				if !strictNullChecks {
					return type_
				}
				var facts /* TODO(TS-TO-GO) inferred type TypeFacts.EQUndefined | TypeFacts.EQNull | TypeFacts.EQUndefinedOrNull | TypeFacts.NEUndefined | TypeFacts.NENull | TypeFacts.NEUndefinedOrNull */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case doubleEquals:
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case assumeTrue:
						facts = TypeFactsEQUndefinedOrNull
					default:
						facts = TypeFactsNEUndefinedOrNull
					}
				case valueType.flags & TypeFlagsNull:
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case assumeTrue:
						facts = TypeFactsEQNull
					default:
						facts = TypeFactsNENull
					}
				case assumeTrue:
					facts = TypeFactsEQUndefined
				default:
					facts = TypeFactsNEUndefined
				}
				return getAdjustedTypeWithFacts(type_, facts)
			}
			if assumeTrue {
				if !doubleEquals && (type_.flags&TypeFlagsUnknown || someType(type_, isEmptyAnonymousObjectType)) {
					if valueType.flags&(TypeFlagsPrimitive|TypeFlagsNonPrimitive) || isEmptyAnonymousObjectType(valueType) {
						return valueType
					}
					if valueType.flags & TypeFlagsObject {
						return nonPrimitiveType
					}
				}
				filteredType := filterType(type_, func(t Type) bool {
					return areTypesComparable(t, valueType) || doubleEquals && isCoercibleUnderDoubleEquals(t, valueType)
				})
				return replacePrimitivesWithLiterals(filteredType, valueType)
			}
			if isUnitType(valueType) {
				return filterType(type_, func(t Type) bool {
					return !(isUnitLikeType(t) && areTypesComparable(t, valueType))
				})
			}
			return type_
		}
		narrowTypeByTypeof := func(type_ Type, typeOfExpr TypeOfExpression, operator SyntaxKind, literal LiteralExpression, assumeTrue bool) Type {
			// We have '==', '!=', '===', or !==' operator with 'typeof xxx' and string literal operands
			if operator == SyntaxKindExclamationEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken {
				assumeTrue = !assumeTrue
			}
			target := getReferenceCandidate(typeOfExpr.expression)
			if !isMatchingReference(reference, target) {
				if strictNullChecks && optionalChainContainsReference(target, reference) && assumeTrue == (literal.text != "undefined") {
					type_ = getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
				}
				propertyAccess := getDiscriminantPropertyAccess(target, type_)
				if propertyAccess {
					return narrowTypeByDiscriminant(type_, propertyAccess, func(t Type) Type {
						return narrowTypeByLiteralExpression(t, literal, assumeTrue)
					})
				}
				return type_
			}
			return narrowTypeByLiteralExpression(type_, literal, assumeTrue)
		}
		narrowTypeByLiteralExpression := func(type_ Type, literal LiteralExpression, assumeTrue bool) Type {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case assumeTrue:
				return narrowTypeByTypeName(type_, literal.text)
			default:
				return getAdjustedTypeWithFacts(type_, typeofNEFacts.get(literal.text) || TypeFactsTypeofNEHostObject)
			}
		}
		narrowTypeBySwitchOptionalChainContainment := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData, clauseCheck func(type_ Type) bool) Type {
			everyClauseChecks := clauseStart != clauseEnd && every(getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd), clauseCheck)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case everyClauseChecks:
				return getTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
			default:
				return type_
			}
		}
		narrowTypeBySwitchOnDiscriminant := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
			// We only narrow if all case expressions specify
			// values with unit types, except for the case where
			// `type` is unknown. In this instance we map object
			// types to the nonPrimitive type and narrow with that.
			switchTypes := getSwitchClauseTypes(switchStatement)
			if !switchTypes.length {
				return type_
			}
			clauseTypes := switchTypes.slice(clauseStart, clauseEnd)
			hasDefaultClause := clauseStart == clauseEnd || contains(clauseTypes, neverType)
			if (type_.flags & TypeFlagsUnknown) && !hasDefaultClause {
				var groundClauseTypes *[]Type
				for i := 0; i < clauseTypes.length; i += 1 {
					t := clauseTypes[i]
					if t.flags & (TypeFlagsPrimitive | TypeFlagsNonPrimitive) {
						if groundClauseTypes != nil {
							groundClauseTypes.push(t)
						}
					} else if t.flags & TypeFlagsObject {
						if groundClauseTypes == nil {
							groundClauseTypes = clauseTypes.slice(0, i)
						}
						groundClauseTypes.push(nonPrimitiveType)
					} else {
						return type_
					}
				}
				return getUnionType(__COND__(groundClauseTypes == nil, clauseTypes, groundClauseTypes))
			}
			discriminantType := getUnionType(clauseTypes)
			var caseType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case discriminantType.flags & TypeFlagsNever:
				caseType = neverType
			default:
				caseType = replacePrimitivesWithLiterals(filterType(type_, func(t Type) bool {
					return areTypesComparable(discriminantType, t)
				}), discriminantType)
			}
			if !hasDefaultClause {
				return caseType
			}
			defaultType := filterType(type_, func(t Type) bool {
				return !(isUnitLikeType(t) && contains(switchTypes, __COND__(t.flags&TypeFlagsUndefined, undefinedType, getRegularTypeOfLiteralType(extractUnitType(t)))))
			})
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case caseType.flags & TypeFlagsNever:
				return defaultType
			default:
				return getUnionType([]Type{caseType, defaultType})
			}
		}
		narrowTypeByTypeName := func(type_ Type, typeName string) Type {
			switch typeName {
			case "string":
				return narrowTypeByTypeFacts(type_, stringType, TypeFactsTypeofEQString)
			case "number":
				return narrowTypeByTypeFacts(type_, numberType, TypeFactsTypeofEQNumber)
			case "bigint":
				return narrowTypeByTypeFacts(type_, bigintType, TypeFactsTypeofEQBigInt)
			case "boolean":
				return narrowTypeByTypeFacts(type_, booleanType, TypeFactsTypeofEQBoolean)
			case "symbol":
				return narrowTypeByTypeFacts(type_, esSymbolType, TypeFactsTypeofEQSymbol)
			case "object":
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case type_.flags & TypeFlagsAny:
					return type_
				default:
					return getUnionType([]Type{narrowTypeByTypeFacts(type_, nonPrimitiveType, TypeFactsTypeofEQObject), narrowTypeByTypeFacts(type_, nullType, TypeFactsEQNull)})
				}
			case "function":
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case type_.flags & TypeFlagsAny:
					return type_
				default:
					return narrowTypeByTypeFacts(type_, globalFunctionType, TypeFactsTypeofEQFunction)
				}
			case "undefined":
				return narrowTypeByTypeFacts(type_, undefinedType, TypeFactsEQUndefined)
			}
			return narrowTypeByTypeFacts(type_, nonPrimitiveType, TypeFactsTypeofEQHostObject)
		}
		narrowTypeByTypeFacts := func(type_ Type, impliedType Type, facts TypeFacts) Type {
			return mapType(type_, func(t Type) Type {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isTypeRelatedTo(t, impliedType, strictSubtypeRelation):
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case hasTypeFacts(t, facts):
						return t
					default:
						return neverType
					}
				case isTypeSubtypeOf(impliedType, t):
					return impliedType
				case hasTypeFacts(t, facts):
					return getIntersectionType([]Type{t, impliedType})
				default:
					return neverType
				}
			})
		}
		narrowTypeBySwitchOnTypeOf := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
			witnesses := getSwitchClauseTypeOfWitnesses(switchStatement)
			if !witnesses {
				return type_
			}
			// Equal start and end denotes implicit fallthrough; undefined marks explicit default clause.
			defaultIndex := findIndex(switchStatement.caseBlock.clauses, func(clause /* TODO(TS-TO-GO) inferred type CaseClause | DefaultClause */ any) bool {
				return clause.kind == SyntaxKindDefaultClause
			})
			hasDefaultClause := clauseStart == clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd)
			if hasDefaultClause {
				// In the default clause we filter constituents down to those that are not-equal to all handled cases.
				notEqualFacts := getNotEqualFactsFromTypeofSwitch(clauseStart, clauseEnd, witnesses)
				return filterType(type_, func(t Type) bool {
					return getTypeFacts(t, notEqualFacts) == notEqualFacts
				})
			}
			// In the non-default cause we create a union of the type narrowed by each of the listed cases.
			clauseWitnesses := witnesses.slice(clauseStart, clauseEnd)
			return getUnionType(map_(clauseWitnesses, func(text *string) Type {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case text:
					return narrowTypeByTypeName(type_, text)
				default:
					return neverType
				}
			}))
		}
		narrowTypeBySwitchOnTrue := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
			defaultIndex := findIndex(switchStatement.caseBlock.clauses, func(clause /* TODO(TS-TO-GO) inferred type CaseClause | DefaultClause */ any) bool {
				return clause.kind == SyntaxKindDefaultClause
			})
			hasDefaultClause := clauseStart == clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd)
			// First, narrow away all of the cases that preceded this set of cases.
			for i := 0; i < clauseStart; i++ {
				clause := switchStatement.caseBlock.clauses[i]
				if clause.kind == SyntaxKindCaseClause {
					type_ = narrowType(type_, clause.expression /*assumeTrue*/, false)
				}
			}
			// If our current set has a default, then none the other cases were hit either.
			// There's no point in narrowing by the the other cases in the set, since we can
			// get here through other paths.
			if hasDefaultClause {
				for i := clauseEnd; i < switchStatement.caseBlock.clauses.length; i++ {
					clause := switchStatement.caseBlock.clauses[i]
					if clause.kind == SyntaxKindCaseClause {
						type_ = narrowType(type_, clause.expression /*assumeTrue*/, false)
					}
				}
				return type_
			}
			// Now, narrow based on the cases in this set.
			clauses := switchStatement.caseBlock.clauses.slice(clauseStart, clauseEnd)
			return getUnionType(map_(clauses, func(clause CaseOrDefaultClause) Type {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case clause.kind == SyntaxKindCaseClause:
					return narrowType(type_, clause.expression /*assumeTrue*/, true)
				default:
					return neverType
				}
			}))
		}
		isMatchingConstructorReference := func(expr Expression) bool {
			return (isPropertyAccessExpression(expr) && idText(expr.name) == "constructor" || isElementAccessExpression(expr) && isStringLiteralLike(expr.argumentExpression) && expr.argumentExpression.text == "constructor") && isMatchingReference(reference, expr.expression)
		}
		narrowTypeByConstructor := func(type_ Type, operator SyntaxKind, identifier Expression, assumeTrue bool) Type {
			// Do not narrow when checking inequality.
			if __COND__(assumeTrue, (operator != SyntaxKindEqualsEqualsToken && operator != SyntaxKindEqualsEqualsEqualsToken), (operator != SyntaxKindExclamationEqualsToken && operator != SyntaxKindExclamationEqualsEqualsToken)) {
				return type_
			}
			// Get the type of the constructor identifier expression, if it is not a function then do not narrow.
			identifierType := getTypeOfExpression(identifier)
			if !isFunctionType(identifierType) && !isConstructorType(identifierType) {
				return type_
			}
			// Get the prototype property of the type identifier so we can find out its type.
			prototypeProperty := getPropertyOfType(identifierType, "prototype" /* as __String */)
			if !prototypeProperty {
				return type_
			}
			// Get the type of the prototype, if it is undefined, or the global `Object` or `Function` types then do not narrow.
			prototypeType := getTypeOfSymbol(prototypeProperty)
			var candidate Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !isTypeAny(prototypeType):
				candidate = prototypeType
			default:
				candidate = nil
			}
			if !candidate || candidate == globalObjectType || candidate == globalFunctionType {
				return type_
			}
			// If the type that is being narrowed is `any` then just return the `candidate` type since every type is a subtype of `any`.
			if isTypeAny(type_) {
				return candidate
			}
			// Filter out types that are not considered to be "constructed by" the `candidate` type.
			return filterType(type_, func(t Type) bool {
				return isConstructedBy(t, candidate)
			})
			isConstructedBy := func(source Type, target Type) bool {
				// If either the source or target type are a class type then we need to check that they are the same exact type.
				// This is because you may have a class `A` that defines some set of properties, and another class `B`
				// that defines the same set of properties as class `A`, in that case they are structurally the same
				// type, but when you do something like `instanceOfA.constructor === B` it will return false.
				if source.flags&TypeFlagsObject && getObjectFlags(source)&ObjectFlagsClass || target.flags&TypeFlagsObject && getObjectFlags(target)&ObjectFlagsClass {
					return source.symbol == target.symbol
				}
				// For all other types just check that the `source` type is a subtype of the `target` type.
				return isTypeSubtypeOf(source, target)
			}
		}
		narrowTypeByInstanceof := func(type_ Type, expr InstanceofExpression, assumeTrue bool) Type {
			left := getReferenceCandidate(expr.left)
			if !isMatchingReference(reference, left) {
				if assumeTrue && strictNullChecks && optionalChainContainsReference(left, reference) {
					return getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
				}
				return type_
			}
			right := expr.right
			rightType := getTypeOfExpression(right)
			if !isTypeDerivedFrom(rightType, globalObjectType) {
				return type_
			}
			// if the right-hand side has an object type with a custom `[Symbol.hasInstance]` method, and that method
			// has a type predicate, use the type predicate to perform narrowing. This allows normal `object` types to
			// participate in `instanceof`, as per Step 2 of https://tc39.es/ecma262/#sec-instanceofoperator.
			signature := getEffectsSignature(expr)
			predicate := signature && getTypePredicateOfSignature(signature)
			if predicate && predicate.kind == TypePredicateKindIdentifier && predicate.parameterIndex == 0 {
				return getNarrowedType(type_, predicate.type_, assumeTrue /*checkDerived*/, true)
			}
			if !isTypeDerivedFrom(rightType, globalFunctionType) {
				return type_
			}
			instanceType := mapType(rightType, getInstanceType)
			// Don't narrow from `any` if the target type is exactly `Object` or `Function`, and narrow
			// in the false branch only if the target is a non-empty object type.
			if isTypeAny(type_) && (instanceType == globalObjectType || instanceType == globalFunctionType) || !assumeTrue && !(instanceType.flags&TypeFlagsObject && !isEmptyAnonymousObjectType(instanceType)) {
				return type_
			}
			return getNarrowedType(type_, instanceType, assumeTrue /*checkDerived*/, true)
		}
		getInstanceType := func(constructorType Type) Type {
			prototypePropertyType := getTypeOfPropertyOfType(constructorType, "prototype" /* as __String */)
			if prototypePropertyType && !isTypeAny(prototypePropertyType) {
				return prototypePropertyType
			}
			constructSignatures := getSignaturesOfType(constructorType, SignatureKindConstruct)
			if constructSignatures.length {
				return getUnionType(map_(constructSignatures, func(signature Signature) Type {
					return getReturnTypeOfSignature(getErasedSignature(signature))
				}))
			}
			// We use the empty object type to indicate we don't know the type of objects created by
			// this constructor function.
			return emptyObjectType
		}
		getNarrowedType := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) Type {
			var key *string
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case type_.flags & TypeFlagsUnion:
				key = __TEMPLATE__("N", getTypeId(type_), ",", getTypeId(candidate), ",", (__COND__(assumeTrue, 1, 0))|(__COND__(checkDerived, 2, 0)))
			default:
				key = nil
			}
			return /* TODO(TS-TO-GO) Node BinaryExpression: getCachedType(key) ?? setCachedType(key, getNarrowedTypeWorker(type, candidate, assumeTrue, checkDerived)) */ TODO
		}
		getNarrowedTypeWorker := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) Type {
			if !assumeTrue {
				if type_ == candidate {
					return neverType
				}
				if checkDerived {
					return filterType(type_, func(t Type) bool {
						return !isTypeDerivedFrom(t, candidate)
					})
				}
				trueType := getNarrowedType(type_, candidate /*assumeTrue*/, true /*checkDerived*/, false)
				return filterType(type_, func(t Type) bool {
					return !isTypeSubsetOf(t, trueType)
				})
			}
			if type_.flags & TypeFlagsAnyOrUnknown {
				return candidate
			}
			if type_ == candidate {
				return candidate
			}
			// We first attempt to filter the current type, narrowing constituents as appropriate and removing
			// constituents that are unrelated to the candidate.
			var isRelated /* TODO(TS-TO-GO) inferred type (source: Type, target: Type) => boolean */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case checkDerived:
				isRelated = isTypeDerivedFrom
			default:
				isRelated = isTypeSubtypeOf
			}
			var keyPropertyName *__String
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case type_.flags & TypeFlagsUnion:
				keyPropertyName = getKeyPropertyName(type_ /* as UnionType */)
			default:
				keyPropertyName = nil
			}
			narrowedType := mapType(candidate, func(c Type) Type {
				// If a discriminant property is available, use that to reduce the type.
				discriminant := keyPropertyName && getTypeOfPropertyOfType(c, keyPropertyName)
				matching := discriminant && getConstituentTypeForKeyType(type_ /* as UnionType */, discriminant)
				// For each constituent t in the current type, if t and and c are directly related, pick the most
				// specific of the two. When t and c are related in both directions, we prefer c for type predicates
				// because that is the asserted type, but t for `instanceof` because generics aren't reflected in
				// prototype object types.
				directlyRelated := mapType(matching || type_, __COND__(checkDerived, func(t Type) Type {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isTypeDerivedFrom(t, c):
						return t
					case isTypeDerivedFrom(c, t):
						return c
					default:
						return neverType
					}
				}, func(t Type) Type {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isTypeStrictSubtypeOf(t, c):
						return t
					case isTypeStrictSubtypeOf(c, t):
						return c
					case isTypeSubtypeOf(t, c):
						return t
					case isTypeSubtypeOf(c, t):
						return c
					default:
						return neverType
					}
				}))
				// If no constituents are directly related, create intersections for any generic constituents that
				// are related by constraint.
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case directlyRelated.flags & TypeFlagsNever:
					return mapType(type_, func(t Type) Type {
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case maybeTypeOfKind(t, TypeFlagsInstantiable) && isRelated(c, getBaseConstraintOfType(t) || unknownType):
							return getIntersectionType([]Type{t, c})
						default:
							return neverType
						}
					})
				default:
					return directlyRelated
				}
			})
			// If filtering produced a non-empty type, return that. Otherwise, pick the most specific of the two
			// based on assignability, or as a last resort produce an intersection.
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !(narrowedType.flags & TypeFlagsNever):
				return narrowedType
			case isTypeSubtypeOf(candidate, type_):
				return candidate
			case isTypeAssignableTo(type_, candidate):
				return type_
			case isTypeAssignableTo(candidate, type_):
				return candidate
			default:
				return getIntersectionType([]Type{type_, candidate})
			}
		}
		narrowTypeByCallExpression := func(type_ Type, callExpression CallExpression, assumeTrue bool) Type {
			if hasMatchingArgument(callExpression, reference) {
				var signature *Signature
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case assumeTrue || !isCallChain(callExpression):
					signature = getEffectsSignature(callExpression)
				default:
					signature = nil
				}
				predicate := signature && getTypePredicateOfSignature(signature)
				if predicate && (predicate.kind == TypePredicateKindThis || predicate.kind == TypePredicateKindIdentifier) {
					return narrowTypeByTypePredicate(type_, predicate, callExpression, assumeTrue)
				}
			}
			if containsMissingType(type_) && isAccessExpression(reference) && isPropertyAccessExpression(callExpression.expression) {
				callAccess := callExpression.expression
				if isMatchingReference(reference.expression, getReferenceCandidate(callAccess.expression)) && isIdentifier(callAccess.name) && callAccess.name.escapedText == "hasOwnProperty" && callExpression.arguments.length == 1 {
					argument := callExpression.arguments[0]
					if isStringLiteralLike(argument) && getAccessedPropertyName(reference) == escapeLeadingUnderscores(argument.text) {
						return getTypeWithFacts(type_, __COND__(assumeTrue, TypeFactsNEUndefined, TypeFactsEQUndefined))
					}
				}
			}
			return type_
		}
		narrowTypeByTypePredicate := func(type_ Type, predicate TypePredicate, callExpression CallExpression, assumeTrue bool) Type {
			// Don't narrow from 'any' if the predicate type is exactly 'Object' or 'Function'
			if predicate.type_ && !(isTypeAny(type_) && (predicate.type_ == globalObjectType || predicate.type_ == globalFunctionType)) {
				predicateArgument := getTypePredicateArgument(predicate, callExpression)
				if predicateArgument {
					if isMatchingReference(reference, predicateArgument) {
						return getNarrowedType(type_, predicate.type_, assumeTrue /*checkDerived*/, false)
					}
					if strictNullChecks && optionalChainContainsReference(predicateArgument, reference) && (assumeTrue && !(hasTypeFacts(predicate.type_, TypeFactsEQUndefined)) || !assumeTrue && everyType(predicate.type_, isNullableType)) {
						type_ = getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
					}
					access := getDiscriminantPropertyAccess(predicateArgument, type_)
					if access {
						return narrowTypeByDiscriminant(type_, access, func(t Type) Type {
							return getNarrowedType(t, predicate.type_, assumeTrue /*checkDerived*/, false)
						})
					}
				}
			}
			return type_
		}
		// Narrow the given type based on the given expression having the assumed boolean value. The returned type
		// will be a subtype or the same type as the argument.
		narrowType := func(type_ Type, expr Expression, assumeTrue bool) Type {
			// for `a?.b`, we emulate a synthetic `a !== null && a !== undefined` condition for `a`
			if isExpressionOfOptionalChainRoot(expr) || isBinaryExpression(expr.parent) && (expr.parent.operatorToken.kind == SyntaxKindQuestionQuestionToken || expr.parent.operatorToken.kind == SyntaxKindQuestionQuestionEqualsToken) && expr.parent.left == expr {
				return narrowTypeByOptionality(type_, expr, assumeTrue)
			}
			switch expr.kind {
			case SyntaxKindIdentifier:
				if !isMatchingReference(reference, expr) && inlineLevel < 5 {
					symbol := getResolvedSymbol(expr /* as Identifier */)
					if isConstantVariable(symbol) {
						declaration := symbol.valueDeclaration
						if declaration && isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && isConstantReference(reference) {
							inlineLevel++
							result := narrowType(type_, declaration.initializer, assumeTrue)
							inlineLevel--
							return result
						}
					}
				}
				fallthrough
			case SyntaxKindThisKeyword:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindSuperKeyword:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindPropertyAccessExpression:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindElementAccessExpression:
				return narrowTypeByTruthiness(type_, expr, assumeTrue)
			case SyntaxKindCallExpression:
				return narrowTypeByCallExpression(type_, expr /* as CallExpression */, assumeTrue)
			case SyntaxKindParenthesizedExpression:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindNonNullExpression:
				return narrowType(type_, (expr /* as ParenthesizedExpression | NonNullExpression */).expression, assumeTrue)
			case SyntaxKindBinaryExpression:
				return narrowTypeByBinaryExpression(type_, expr /* as BinaryExpression */, assumeTrue)
			case SyntaxKindPrefixUnaryExpression:
				if (expr /* as PrefixUnaryExpression */).operator == SyntaxKindExclamationToken {
					return narrowType(type_, (expr /* as PrefixUnaryExpression */).operand, !assumeTrue)
				}
				break
			}
			return type_
		}
		narrowTypeByOptionality := func(type_ Type, expr Expression, assumePresent bool) Type {
			if isMatchingReference(reference, expr) {
				return getAdjustedTypeWithFacts(type_, __COND__(assumePresent, TypeFactsNEUndefinedOrNull, TypeFactsEQUndefinedOrNull))
			}
			access := getDiscriminantPropertyAccess(expr, type_)
			if access {
				return narrowTypeByDiscriminant(type_, access, func(t Type) Type {
					return getTypeWithFacts(t, __COND__(assumePresent, TypeFactsNEUndefinedOrNull, TypeFactsEQUndefinedOrNull))
				})
			}
			return type_
		}
	}
	getTypeOfSymbolAtLocation := func(symbol Symbol, location Node) Type {
		symbol = getExportSymbolOfValueSymbolIfExported(symbol)
		// If we have an identifier or a property access at the given location, if the location is
		// an dotted name expression, and if the location is not an assignment target, obtain the type
		// of the expression (which will reflect control flow analysis). If the expression indeed
		// resolved to the given symbol, return the narrowed type.
		if location.kind == SyntaxKindIdentifier || location.kind == SyntaxKindPrivateIdentifier {
			if isRightSideOfQualifiedNameOrPropertyAccess(location) {
				location = location.parent
			}
			if isExpressionNode(location) && (!isAssignmentTarget(location) || isWriteAccess(location)) {
				type_ := removeOptionalTypeMarker(__COND__(isWriteAccess(location) && location.kind == SyntaxKindPropertyAccessExpression, checkPropertyAccessExpression(location /* as PropertyAccessExpression */ /*checkMode*/, nil /*writeOnly*/, true), getTypeOfExpression(location /* as Expression */)))
				if getExportSymbolOfValueSymbolIfExported(getNodeLinks(location).resolvedSymbol) == symbol {
					return type_
				}
			}
		}
		if isDeclarationName(location) && isSetAccessor(location.parent) && getAnnotatedAccessorTypeNode(location.parent) {
			return getWriteTypeOfAccessors(location.parent.symbol)
		}
		// The location isn't a reference to the given symbol, meaning we're being asked
		// a hypothetical question of what type the symbol would have if there was a reference
		// to it at the given location. Since we have no control flow information for the
		// hypothetical reference (control flow information is created and attached by the
		// binder), we simply return the declared type of the symbol.
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isRightSideOfAccessExpression(location) && isWriteAccess(location.parent):
			return getWriteTypeOfSymbol(symbol)
		default:
			return getNonMissingTypeOfSymbol(symbol)
		}
	}
	getControlFlowContainer := func(node Node) Node {
		return findAncestor(node.parent, func(node Node) bool {
			return isFunctionLike(node) && !getImmediatelyInvokedFunctionExpression(node) || node.kind == SyntaxKindModuleBlock || node.kind == SyntaxKindSourceFile || node.kind == SyntaxKindPropertyDeclaration
		})
	}
	// Check if a parameter, catch variable, or mutable local variable is assigned anywhere definitely
	isSymbolAssignedDefinitely := func(symbol Symbol) bool {
		if symbol.lastAssignmentPos != nil {
			return symbol.lastAssignmentPos < 0
		}
		return isSymbolAssigned(symbol) && symbol.lastAssignmentPos != nil && symbol.lastAssignmentPos < 0
	}
	// Check if a parameter, catch variable, or mutable local variable is assigned anywhere
	isSymbolAssigned := func(symbol Symbol) bool {
		return !isPastLastAssignment(symbol /*location*/, nil)
	}
	// Return true if there are no assignments to the given symbol or if the given location
	// is past the last assignment to the symbol.
	isPastLastAssignment := func(symbol Symbol, location Node) *bool {
		parent := findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile)
		if !parent {
			return false
		}
		links := getNodeLinks(parent)
		if !(links.flags & NodeCheckFlagsAssignmentsMarked) {
			links.flags |= NodeCheckFlagsAssignmentsMarked
			if !hasParentWithAssignmentsMarked(parent) {
				markNodeAssignments(parent)
			}
		}
		return !symbol.lastAssignmentPos || location && Math.abs(symbol.lastAssignmentPos) < location.pos
	}
	// Check if a parameter or catch variable (or their bindings elements) is assigned anywhere
	isSomeSymbolAssigned := func(rootDeclaration Node) bool {
		Debug.assert(isVariableDeclaration(rootDeclaration) || isParameter(rootDeclaration))
		return isSomeSymbolAssignedWorker(rootDeclaration.name)
	}
	isSomeSymbolAssignedWorker := func(node BindingName) bool {
		if node.kind == SyntaxKindIdentifier {
			return isSymbolAssigned(getSymbolOfDeclaration(node.parent /* as Declaration */))
		}
		return some(node.elements, func(e /* TODO(TS-TO-GO) inferred type BindingElement | OmittedExpression */ any) bool {
			return e.kind != SyntaxKindOmittedExpression && isSomeSymbolAssignedWorker(e.name)
		})
	}
	hasParentWithAssignmentsMarked := func(node Node) bool {
		return !!findAncestor(node.parent, func(node Node) bool {
			return isFunctionOrSourceFile(node) && !!(getNodeLinks(node).flags & NodeCheckFlagsAssignmentsMarked)
		})
	}
	isFunctionOrSourceFile := func(node Node) bool {
		return isFunctionLikeDeclaration(node) || isSourceFile(node)
	}
	// For all assignments within the given root node, record the last assignment source position for all
	// referenced parameters and mutable local variables. When assignments occur in nested functions  or
	// references occur in export specifiers, record Number.MAX_VALUE as the assignment position. When
	// assignments occur in compound statements, record the ending source position of the compound statement
	// as the assignment position (this is more conservative than full control flow analysis, but requires
	// only a single walk over the AST).
	markNodeAssignments := func(node Node) {
		switch node.kind {
		case SyntaxKindIdentifier:
			assigmentTarget := getAssignmentTargetKind(node)
			if assigmentTarget != AssignmentKindNone {
				symbol := getResolvedSymbol(node /* as Identifier */)
				hasDefiniteAssignment := assigmentTarget == AssignmentKindDefinite || (symbol.lastAssignmentPos != nil && symbol.lastAssignmentPos < 0)
				if isParameterOrMutableLocalVariable(symbol) {
					if symbol.lastAssignmentPos == nil || Math.abs(symbol.lastAssignmentPos) != Number.MAX_VALUE {
						referencingFunction := findAncestor(node, isFunctionOrSourceFile)
						declaringFunction := findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile)
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case referencingFunction == declaringFunction:
							symbol.lastAssignmentPos = extendAssignmentPosition(node, symbol.valueDeclaration)
						default:
							symbol.lastAssignmentPos = Number.MAX_VALUE
						}
					}
					if hasDefiniteAssignment && symbol.lastAssignmentPos > 0 {
						symbol.lastAssignmentPos *= -1
					}
				}
			}
			return
		case SyntaxKindExportSpecifier:
			exportDeclaration := (node /* as ExportSpecifier */).parent.parent
			name := (node /* as ExportSpecifier */).propertyName || (node /* as ExportSpecifier */).name
			if !(node /* as ExportSpecifier */).isTypeOnly && !exportDeclaration.isTypeOnly && !exportDeclaration.moduleSpecifier && name.kind != SyntaxKindStringLiteral {
				symbol := resolveEntityName(name, SymbolFlagsValue /*ignoreErrors*/, true /*dontResolveAlias*/, true)
				if symbol && isParameterOrMutableLocalVariable(symbol) {
					var sign /* TODO(TS-TO-GO) inferred type 1 | -1 */ any
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case symbol.lastAssignmentPos != nil && symbol.lastAssignmentPos < 0:
						sign = -1
					default:
						sign = 1
					}
					symbol.lastAssignmentPos = sign * Number.MAX_VALUE
				}
			}
			return
		case SyntaxKindInterfaceDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTypeAliasDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindEnumDeclaration:
			return
		}
		if isTypeNode(node) {
			return
		}
		forEachChild(node, markNodeAssignments)
	}
	// Extend the position of the given assignment target node to the end of any intervening variable statement,
	// expression statement, compound statement, or class declaration occurring between the node and the given
	// declaration node.
	extendAssignmentPosition := func(node Node, declaration Declaration) number {
		pos := node.pos
		for node && node.pos > declaration.pos {
			switch node.kind {
			case SyntaxKindVariableStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindExpressionStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindIfStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindDoStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindWhileStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindForStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindForInStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindForOfStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindWithStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindSwitchStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindTryStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindClassDeclaration:
				pos = node.end
			}
			node = node.parent
		}
		return pos
	}
	isConstantVariable := func(symbol Symbol) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
		return symbol.flags&SymbolFlagsVariable && (getDeclarationNodeFlagsFromSymbol(symbol)&NodeFlagsConstant) != 0
	}
	isParameterOrMutableLocalVariable := func(symbol Symbol) bool {
		// Return true if symbol is a parameter, a catch clause variable, or a mutable local variable
		declaration := symbol.valueDeclaration && getRootDeclaration(symbol.valueDeclaration)
		return !!declaration && (isParameter(declaration) || isVariableDeclaration(declaration) && (isCatchClause(declaration.parent) || isMutableLocalVariableDeclaration(declaration)))
	}
	isMutableLocalVariableDeclaration := func(declaration VariableDeclaration) bool {
		// Return true if symbol is a non-exported and non-global `let` variable
		return !!(declaration.parent.flags & NodeFlagsLet) && !(getCombinedModifierFlags(declaration)&ModifierFlagsExport || declaration.parent.parent.kind == SyntaxKindVariableStatement && isGlobalSourceFile(declaration.parent.parent.parent))
	}
	parameterInitializerContainsUndefined := func(declaration ParameterDeclaration) bool {
		links := getNodeLinks(declaration)
		if links.parameterInitializerContainsUndefined == nil {
			if !pushTypeResolution(declaration, TypeSystemPropertyNameParameterInitializerContainsUndefined) {
				reportCircularityError(declaration.symbol)
				return true
			}
			containsUndefined := !!(hasTypeFacts(checkDeclarationInitializer(declaration, CheckModeNormal), TypeFactsIsUndefined))
			if !popTypeResolution() {
				reportCircularityError(declaration.symbol)
				return true
			}
			/* TODO(TS-TO-GO) Node BinaryExpression: links.parameterInitializerContainsUndefined ??= containsUndefined */ TODO
		}
		return links.parameterInitializerContainsUndefined
	}
	/** remove undefined from the annotated type of a parameter when there is an initializer (that doesn't include undefined) */
	removeOptionalityFromDeclaredType := func(declaredType Type, declaration VariableLikeDeclaration) Type {
		removeUndefined := strictNullChecks && declaration.kind == SyntaxKindParameter && declaration.initializer && hasTypeFacts(declaredType, TypeFactsIsUndefined) && !parameterInitializerContainsUndefined(declaration)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case removeUndefined:
			return getTypeWithFacts(declaredType, TypeFactsNEUndefined)
		default:
			return declaredType
		}
	}
	isConstraintPosition := func(type_ Type, node Node) bool {
		parent := node.parent
		// In an element access obj[x], we consider obj to be in a constraint position, except when obj is of
		// a generic type without a nullable constraint and x is a generic type. This is because when both obj
		// and x are of generic types T and K, we want the resulting type to be T[K].
		return parent.kind == SyntaxKindPropertyAccessExpression || parent.kind == SyntaxKindQualifiedName || parent.kind == SyntaxKindCallExpression && (parent /* as CallExpression */).expression == node || parent.kind == SyntaxKindNewExpression && (parent /* as NewExpression */).expression == node || parent.kind == SyntaxKindElementAccessExpression && (parent /* as ElementAccessExpression */).expression == node && !(someType(type_, isGenericTypeWithoutNullableConstraint) && isGenericIndexType(getTypeOfExpression((parent /* as ElementAccessExpression */).argumentExpression)))
	}
	isGenericTypeWithUnionConstraint := func(type_ Type) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsIntersection:
			return some((type_ /* as IntersectionType */).types, isGenericTypeWithUnionConstraint)
		default:
			return !!(type_.flags&TypeFlagsInstantiable && getBaseConstraintOrType(type_).flags&(TypeFlagsNullable|TypeFlagsUnion))
		}
	}
	isGenericTypeWithoutNullableConstraint := func(type_ Type) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsIntersection:
			return some((type_ /* as IntersectionType */).types, isGenericTypeWithoutNullableConstraint)
		default:
			return !!(type_.flags&TypeFlagsInstantiable && !maybeTypeOfKind(getBaseConstraintOrType(type_), TypeFlagsNullable))
		}
	}
	hasContextualTypeWithNoGenericTypes := func(node Node, checkMode *CheckMode) *bool {
		// Computing the contextual type for a child of a JSX element involves resolving the type of the
		// element's tag name, so we exclude that here to avoid circularities.
		// If check mode has `CheckMode.RestBindingElement`, we skip binding pattern contextual types,
		// as we want the type of a rest element to be generic when possible.
		contextualType := (isIdentifier(node) || isPropertyAccessExpression(node) || isElementAccessExpression(node)) && !((isJsxOpeningElement(node.parent) || isJsxSelfClosingElement(node.parent)) && node.parent.tagName == node) && (__COND__(checkMode && checkMode&CheckModeRestBindingElement, getContextualType(node, ContextFlagsSkipBindingPatterns), getContextualType(node /*contextFlags*/, nil)))
		return contextualType && !isGenericType(contextualType)
	}
	getNarrowableTypeForReference := func(type_ Type, reference Node, checkMode CheckMode) Type {
		if isNoInferType(type_) {
			type_ = (type_ /* as SubstitutionType */).baseType
		}
		// When the type of a reference is or contains an instantiable type with a union type constraint, and
		// when the reference is in a constraint position (where it is known we'll obtain the apparent type) or
		// has a contextual type containing no top-level instantiables (meaning constraints will determine
		// assignability), we substitute constraints for all instantiables in the type of the reference to give
		// control flow analysis an opportunity to narrow it further. For example, for a reference of a type
		// parameter type 'T extends string | undefined' with a contextual type 'string', we substitute
		// 'string | undefined' to give control flow analysis the opportunity to narrow to type 'string'.
		substituteConstraints := !(checkMode && checkMode&CheckModeInferential) && someType(type_, isGenericTypeWithUnionConstraint) && (isConstraintPosition(type_, reference) || hasContextualTypeWithNoGenericTypes(reference, checkMode))
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case substituteConstraints:
			return mapType(type_, getBaseConstraintOrType)
		default:
			return type_
		}
	}
	isExportOrExportExpression := func(location Node) bool {
		return !!findAncestor(location, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			parent := n.parent
			if parent == nil {
				return "quit"
			}
			if isExportAssignment(parent) {
				return parent.expression == n && isEntityNameExpression(n)
			}
			if isExportSpecifier(parent) {
				return parent.name == n || parent.propertyName == n
			}
			return false
		})
	}
	/**
	 * This function marks all the imports the given location refers to as `.referenced` in `NodeLinks` (transitively through local import aliases).
	 * (This corresponds to not getting elided in JS emit.)
	 * It can be called on *most* nodes in the AST with `ReferenceHint.Unspecified` and will filter its inputs, but care should be taken to avoid calling it on the RHS of an `import =` or specifiers in a `import {} from "..."`,
	 * unless you *really* want to *definitely* mark those as referenced.
	 * These shouldn't be directly marked, and should only get marked transitively by the internals of this function.
	 *
	 * @param location The location to mark js import refernces for
	 * @param hint The kind of reference `location` has already been checked to be
	 * @param propSymbol The optional symbol of the property we're looking up - this is used for property accesses when `const enum`s do not count as references (no `isolatedModules`, no `preserveConstEnums` + export). It will be calculated if not provided.
	 * @param parentType The optional type of the parent of the LHS of the property access - this will be recalculated if not provided (but is costly).
	 */
	/* TODO(TS-TO-GO): function markLinkedReferences(location: PropertyAccessExpression | QualifiedName, hint: ReferenceHint.Property, propSymbol: Symbol | undefined, parentType: Type): void; */
	/* TODO(TS-TO-GO): function markLinkedReferences(location: Identifier, hint: ReferenceHint.Identifier): void; */
	/* TODO(TS-TO-GO): function markLinkedReferences(location: ExportAssignment, hint: ReferenceHint.ExportAssignment): void; */
	/* TODO(TS-TO-GO): function markLinkedReferences(location: JsxOpeningLikeElement | JsxOpeningFragment, hint: ReferenceHint.Jsx): void; */
	/* TODO(TS-TO-GO): function markLinkedReferences(location: FunctionLikeDeclaration | MethodSignature, hint: ReferenceHint.AsyncFunction): void; */
	/* TODO(TS-TO-GO): function markLinkedReferences(location: ImportEqualsDeclaration, hint: ReferenceHint.ExportImportEquals): void; */
	/* TODO(TS-TO-GO): function markLinkedReferences(location: ExportSpecifier, hint: ReferenceHint.ExportSpecifier): void; */
	/* TODO(TS-TO-GO): function markLinkedReferences(location: HasDecorators, hint: ReferenceHint.Decorator): void; */
	/* TODO(TS-TO-GO): function markLinkedReferences(location: Node, hint: ReferenceHint.Unspecified, propSymbol?: Symbol, parentType?: Type): void; */
	markLinkedReferences := func(location Node, hint ReferenceHint, propSymbol Symbol, parentType Type) {
		if !canCollectSymbolAliasAccessabilityData {
			return
		}
		if location.flags&NodeFlagsAmbient && !isPropertySignature(location) && !isPropertyDeclaration(location) {
			// References within types and declaration files are never going to contribute to retaining a JS import,
			// except for properties (which can be decorated).
			return
		}
		switch hint {
		case ReferenceHintIdentifier:
			return markIdentifierAliasReferenced(location /* as Identifier */)
		case ReferenceHintProperty:
			return markPropertyAliasReferenced(location /* as PropertyAccessExpression | QualifiedName */, propSymbol, parentType)
		case ReferenceHintExportAssignment:
			return markExportAssignmentAliasReferenced(location /* as ExportAssignment */)
		case ReferenceHintJsx:
			return markJsxAliasReferenced(location /* as JsxOpeningLikeElement | JsxOpeningFragment */)
		case ReferenceHintAsyncFunction:
			return markAsyncFunctionAliasReferenced(location /* as FunctionLikeDeclaration | MethodSignature */)
		case ReferenceHintExportImportEquals:
			return markImportEqualsAliasReferenced(location /* as ImportEqualsDeclaration */)
		case ReferenceHintExportSpecifier:
			return markExportSpecifierAliasReferenced(location /* as ExportSpecifier */)
		case ReferenceHintDecorator:
			return markDecoratorAliasReferenced(location /* as HasDecorators */)
		case ReferenceHintUnspecified:
			// Identifiers in expression contexts are emitted, so we need to follow their referenced aliases and mark them as used
			// Some non-expression identifiers are also treated as expression identifiers for this purpose, eg, `a` in `b = {a}` or `q` in `import r = q`
			// This is the exception, rather than the rule - most non-expression identifiers are declaration names.
			if isIdentifier(location) && (isExpressionNode(location) || isShorthandPropertyAssignment(location.parent) || (isImportEqualsDeclaration(location.parent) && location.parent.moduleReference == location)) && shouldMarkIdentifierAliasReferenced(location) {
				if isPropertyAccessOrQualifiedName(location.parent) {
					var left /* TODO(TS-TO-GO) inferred type LeftHandSideExpression | QualifiedName */ any
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isPropertyAccessExpression(location.parent):
						left = location.parent.expression
					default:
						left = location.parent.left
					}
					if left != location {
						return
						// Only mark the LHS (the RHS is a property lookup)
					}
					// Only mark the LHS (the RHS is a property lookup)
				}
				markIdentifierAliasReferenced(location)
				return
			}
			if isPropertyAccessOrQualifiedName(location) {
				var topProp Node = location
				for isPropertyAccessOrQualifiedName(topProp) {
					if isPartOfTypeNode(topProp) {
						return
					}
					topProp = topProp.parent
				}
				return markPropertyAliasReferenced(location)
			}
			if isExportAssignment(location) {
				return markExportAssignmentAliasReferenced(location)
			}
			if isJsxOpeningLikeElement(location) || isJsxOpeningFragment(location) {
				return markJsxAliasReferenced(location)
			}
			if isImportEqualsDeclaration(location) {
				if isInternalModuleImportEqualsDeclaration(location) || checkExternalImportOrExportDeclaration(location) {
					return markImportEqualsAliasReferenced(location)
				}
				return
			}
			if isExportSpecifier(location) {
				return markExportSpecifierAliasReferenced(location)
			}
			if isFunctionLikeDeclaration(location) || isMethodSignature(location) {
				markAsyncFunctionAliasReferenced(location)
				// Might be decorated, fall through to decorator final case
			}
			if !compilerOptions.emitDecoratorMetadata {
				return
			}
			if !canHaveDecorators(location) || !hasDecorators(location) || !location.modifiers || !nodeCanBeDecorated(legacyDecorators, location, location.parent, location.parent.parent) {
				return
			}
			return markDecoratorAliasReferenced(location)
			fallthrough
		default:
			Debug.assertNever(hint, __TEMPLATE__("Unhandled reference hint: ", hint))
		}
	}
	markIdentifierAliasReferenced := func(location Identifier) {
		symbol := getResolvedSymbol(location)
		if symbol && symbol != argumentsSymbol && symbol != unknownSymbol && !isThisInTypeQuery(location) {
			markAliasReferenced(symbol, location)
		}
	}
	markPropertyAliasReferenced := func(location /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | QualifiedName */ any, propSymbol Symbol, parentType Type) {
		var left /* TODO(TS-TO-GO) inferred type LeftHandSideExpression | QualifiedName */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isPropertyAccessExpression(location):
			left = location.expression
		default:
			left = location.left
		}
		if isThisIdentifier(left) || !isIdentifier(left) {
			return
		}
		parentSymbol := getResolvedSymbol(left)
		if !parentSymbol || parentSymbol == unknownSymbol {
			return
		}
		// In `Foo.Bar.Baz`, 'Foo' is not referenced if 'Bar' is a const enum or a module containing only const enums.
		// `Foo` is also not referenced in `enum FooCopy { Bar = Foo.Bar }`, because the enum member value gets inlined
		// here even if `Foo` is not a const enum.
		//
		// The exceptions are:
		//   1. if 'isolatedModules' is enabled, because the const enum value will not be inlined, and
		//   2. if 'preserveConstEnums' is enabled and the expression is itself an export, e.g. `export = Foo.Bar.Baz`.
		//
		// The property lookup is deferred as much as possible, in as many situations as possible, to avoid alias marking
		// pulling on types/symbols it doesn't strictly need to.
		if getIsolatedModules(compilerOptions) || (shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location)) {
			markAliasReferenced(parentSymbol, location)
			return
		}
		// Hereafter, this relies on type checking - but every check prior to this only used symbol information
		leftType := parentType || checkExpressionCached(left)
		if isTypeAny(leftType) || leftType == silentNeverType {
			markAliasReferenced(parentSymbol, location)
			return
		}
		prop := propSymbol
		if !prop && !parentType {
			var right MemberName
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isPropertyAccessExpression(location):
				right = location.name
			default:
				right = location.right
			}
			lexicallyScopedSymbol := isPrivateIdentifier(right) && lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right)
			assignmentKind := getAssignmentTargetKind(location)
			apparentType := getApparentType(__COND__(assignmentKind != AssignmentKindNone || isMethodAccessForCall(location), getWidenedType(leftType), leftType))
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isPrivateIdentifier(right):
				prop = lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(apparentType, lexicallyScopedSymbol) || nil
			default:
				prop = getPropertyOfType(apparentType, right.escapedText)
			}
		}
		if !(prop && (isConstEnumOrConstEnumOnlyModule(prop) || prop.flags&SymbolFlagsEnumMember && location.parent.kind == SyntaxKindEnumMember)) {
			markAliasReferenced(parentSymbol, location)
		}
		return
	}
	markExportAssignmentAliasReferenced := func(location ExportAssignment) {
		if isIdentifier(location.expression) {
			id := location.expression
			sym := getExportSymbolOfValueSymbolIfExported(resolveEntityName(id, SymbolFlagsAll /*ignoreErrors*/, true /*dontResolveAlias*/, true, location))
			if sym {
				markAliasReferenced(sym, id)
			}
		}
	}
	markJsxAliasReferenced := func(node /* TODO(TS-TO-GO) TypeNode UnionType: JsxOpeningLikeElement | JsxOpeningFragment */ any) {
		if !getJsxNamespaceContainerForImplicitImport(node) {
			// The reactNamespace/jsxFactory's root symbol should be marked as 'used' so we don't incorrectly elide its import.
			// And if there is no reactNamespace/jsxFactory's symbol in scope when targeting React emit, we should issue an error.
			var jsxFactoryRefErr *DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case diagnostics && compilerOptions.jsx == JsxEmitReact:
				jsxFactoryRefErr = Diagnostics.Cannot_find_name_0
			default:
				jsxFactoryRefErr = nil
			}
			jsxFactoryNamespace := getJsxNamespace(node)
			var jsxFactoryLocation /* TODO(TS-TO-GO) inferred type JsxTagNameExpression | JsxOpeningFragment */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isJsxOpeningLikeElement(node):
				jsxFactoryLocation = node.tagName
			default:
				jsxFactoryLocation = node
			}
			// allow null as jsxFragmentFactory
			var jsxFactorySym Symbol
			if !(isJsxOpeningFragment(node) && jsxFactoryNamespace == "null") {
				jsxFactorySym = resolveName(jsxFactoryLocation, jsxFactoryNamespace, SymbolFlagsValue, jsxFactoryRefErr /*isUse*/, true)
			}
			if jsxFactorySym {
				// Mark local symbol as referenced here because it might not have been marked
				// if jsx emit was not jsxFactory as there wont be error being emitted
				jsxFactorySym.isReferenced = SymbolFlagsAll
				// If react/jsxFactory symbol is alias, mark it as refereced
				if canCollectSymbolAliasAccessabilityData && jsxFactorySym.flags&SymbolFlagsAlias && !getTypeOnlyAliasDeclaration(jsxFactorySym) {
					markAliasSymbolAsReferenced(jsxFactorySym)
				}
			}
			// For JsxFragment, mark jsx pragma as referenced via resolveName
			if isJsxOpeningFragment(node) {
				file := getSourceFileOfNode(node)
				localJsxNamespace := getLocalJsxNamespace(file)
				if localJsxNamespace {
					resolveName(jsxFactoryLocation, localJsxNamespace, SymbolFlagsValue, jsxFactoryRefErr /*isUse*/, true)
				}
			}
		}
		return
	}
	markAsyncFunctionAliasReferenced := func(location /* TODO(TS-TO-GO) TypeNode UnionType: FunctionLikeDeclaration | MethodSignature */ any) {
		if languageVersion < ScriptTargetES2015 {
			if getFunctionFlags(location) & FunctionFlagsAsync {
				returnTypeNode := getEffectiveReturnTypeNode(location)
				markTypeNodeAsReferenced(returnTypeNode)
			}
		}
	}
	markImportEqualsAliasReferenced := func(location ImportEqualsDeclaration) {
		if hasSyntacticModifier(location, ModifierFlagsExport) {
			markExportAsReferenced(location)
		}
	}
	markExportSpecifierAliasReferenced := func(location ExportSpecifier) {
		if !location.parent.parent.moduleSpecifier && !location.isTypeOnly && !location.parent.parent.isTypeOnly {
			exportedName := location.propertyName || location.name
			if exportedName.kind == SyntaxKindStringLiteral {
				return
				// Skip for invalid syntax like this: export { "x" }
			}
			symbol := resolveName(exportedName, exportedName.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias /*nameNotFoundMessage*/, nil /*isUse*/, true)
			if symbol && (symbol == undefinedSymbol || symbol == globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0]))) {
				// Do nothing, non-local symbol
			} else {
				target := symbol && (__COND__(symbol.flags&SymbolFlagsAlias, resolveAlias(symbol), symbol))
				if !target || getSymbolFlags(target)&SymbolFlagsValue {
					markExportAsReferenced(location)
					// marks export as used
					markIdentifierAliasReferenced(exportedName)
					// marks target of export as used
				}
			}
			return
		}
	}
	markDecoratorAliasReferenced := func(node HasDecorators) {
		if compilerOptions.emitDecoratorMetadata {
			firstDecorator := find(node.modifiers, isDecorator)
			if !firstDecorator {
				return
			}
			checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersMetadata)
			// we only need to perform these checks if we are emitting serialized type metadata for the target of a decorator.
			switch node.kind {
			case SyntaxKindClassDeclaration:
				constructor := getFirstConstructorWithBody(node)
				if constructor {
					for _, parameter := range constructor.parameters {
						markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter))
					}
				}
				break
			case SyntaxKindGetAccessor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindSetAccessor:
				var otherKind /* TODO(TS-TO-GO) inferred type SyntaxKind.GetAccessor | SyntaxKind.SetAccessor */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case node.kind == SyntaxKindGetAccessor:
					otherKind = SyntaxKindSetAccessor
				default:
					otherKind = SyntaxKindGetAccessor
				}
				otherAccessor := getDeclarationOfKind(getSymbolOfDeclaration(node), otherKind)
				markDecoratorMedataDataTypeNodeAsReferenced(getAnnotatedAccessorTypeNode(node) || otherAccessor && getAnnotatedAccessorTypeNode(otherAccessor))
				break
			case SyntaxKindMethodDeclaration:
				for _, parameter := range node.parameters {
					markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter))
				}
				markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(node))
				break
			case SyntaxKindPropertyDeclaration:
				markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveTypeAnnotationNode(node))
				break
			case SyntaxKindParameter:
				markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(node))
				containingSignature := node.parent
				for _, parameter := range containingSignature.parameters {
					markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter))
				}
				markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(containingSignature))
				break
			}
		}
	}
	markAliasReferenced := func(symbol Symbol, location Node) {
		if !canCollectSymbolAliasAccessabilityData {
			return
		}
		if isNonLocalAlias(symbol /*excludes*/, SymbolFlagsValue) && !isInTypeQuery(location) {
			target := resolveAlias(symbol)
			if getSymbolFlags(symbol /*excludeTypeOnlyMeanings*/, true) & (SymbolFlagsValue | SymbolFlagsExportValue) {
				// An alias resolving to a const enum cannot be elided if (1) 'isolatedModules' is enabled
				// (because the const enum value will not be inlined), or if (2) the alias is an export
				// of a const enum declaration that will be preserved.
				if getIsolatedModules(compilerOptions) || shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location) || !isConstEnumOrConstEnumOnlyModule(getExportSymbolOfValueSymbolIfExported(target)) {
					markAliasSymbolAsReferenced(symbol)
				}
			}
		}
	}
	// When an alias symbol is referenced, we need to mark the entity it references as referenced and in turn repeat that until
	// we reach a non-alias or an exported entity (which is always considered referenced). We do this by checking the target of
	// the alias as an expression (which recursively takes us back here if the target references another alias).
	markAliasSymbolAsReferenced := func(symbol Symbol) undefined {
		Debug.assert(canCollectSymbolAliasAccessabilityData)
		links := getSymbolLinks(symbol)
		if !links.referenced {
			links.referenced = true
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				return Debug.fail()
			}
			// We defer checking of the reference of an `import =` until the import itself is referenced,
			// This way a chain of imports can be elided if ultimately the final input is only used in a type
			// position.
			if isInternalModuleImportEqualsDeclaration(node) {
				if getSymbolFlags(resolveSymbol(symbol)) & SymbolFlagsValue {
					// import foo = <symbol>
					left := getFirstIdentifier(node.moduleReference /* as EntityNameExpression */)
					markIdentifierAliasReferenced(left)
				}
			}
		}
	}
	markExportAsReferenced := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportEqualsDeclaration | ExportSpecifier */ any) {
		symbol := getSymbolOfDeclaration(node)
		target := resolveAlias(symbol)
		if target {
			markAlias := target == unknownSymbol || ((getSymbolFlags(symbol /*excludeTypeOnlyMeanings*/, true) & SymbolFlagsValue) && !isConstEnumOrConstEnumOnlyModule(target))
			if markAlias {
				markAliasSymbolAsReferenced(symbol)
			}
		}
	}
	markEntityNameOrEntityExpressionAsReference := func(typeName *EntityNameOrEntityNameExpression, forDecoratorMetadata bool) {
		if !typeName {
			return
		}
		rootName := getFirstIdentifier(typeName)
		meaning := (__COND__(typeName.kind == SyntaxKindIdentifier, SymbolFlagsType, SymbolFlagsNamespace)) | SymbolFlagsAlias
		rootSymbol := resolveName(rootName, rootName.escapedText, meaning /*nameNotFoundMessage*/, nil /*isUse*/, true)
		if rootSymbol && rootSymbol.flags&SymbolFlagsAlias {
			if canCollectSymbolAliasAccessabilityData && symbolIsValue(rootSymbol) && !isConstEnumOrConstEnumOnlyModule(resolveAlias(rootSymbol)) && !getTypeOnlyAliasDeclaration(rootSymbol) {
				markAliasSymbolAsReferenced(rootSymbol)
			} else if forDecoratorMetadata && getIsolatedModules(compilerOptions) && getEmitModuleKind(compilerOptions) >= ModuleKindES2015 && !symbolIsValue(rootSymbol) && !some(rootSymbol.declarations, isTypeOnlyImportOrExportDeclaration) {
				diag := error(typeName, Diagnostics.A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled)
				aliasDeclaration := find(rootSymbol.declarations || emptyArray, isAliasSymbolDeclaration)
				if aliasDeclaration {
					addRelatedInfo(diag, createDiagnosticForNode(aliasDeclaration, Diagnostics._0_was_imported_here, idText(rootName)))
				}
			}
		}
	}
	/**
	 * If a TypeNode can be resolved to a value symbol imported from an external module, it is
	 * marked as referenced to prevent import elision.
	 */
	markTypeNodeAsReferenced := func(node *TypeNode) {
		markEntityNameOrEntityExpressionAsReference(node && getEntityNameFromTypeNode(node) /*forDecoratorMetadata*/, false)
	}
	/**
	 * This function marks the type used for metadata decorator as referenced if it is import
	 * from external module.
	 * This is different from markTypeNodeAsReferenced because it tries to simplify type nodes in
	 * union and intersection type
	 * @param node
	 */
	markDecoratorMedataDataTypeNodeAsReferenced := func(node *TypeNode) {
		entityName := getEntityNameForDecoratorMetadata(node)
		if entityName && isEntityName(entityName) {
			markEntityNameOrEntityExpressionAsReference(entityName /*forDecoratorMetadata*/, true)
		}
	}
	getNarrowedTypeOfSymbol := func(symbol Symbol, location Identifier) Type {
		type_ := getTypeOfSymbol(symbol)
		declaration := symbol.valueDeclaration
		if declaration {
			// If we have a non-rest binding element with no initializer declared as a const variable or a const-like
			// parameter (a parameter for which there are no assignments in the function body), and if the parent type
			// for the destructuring is a union type, one or more of the binding elements may represent discriminant
			// properties, and we want the effects of conditional checks on such discriminants to affect the types of
			// other binding elements from the same destructuring. Consider:
			//
			//   type Action =
			//       | { kind: 'A', payload: number }
			//       | { kind: 'B', payload: string };
			//
			//   function f({ kind, payload }: Action) {
			//       if (kind === 'A') {
			//           payload.toFixed();
			//       }
			//       if (kind === 'B') {
			//           payload.toUpperCase();
			//       }
			//   }
			//
			// Above, we want the conditional checks on 'kind' to affect the type of 'payload'. To facilitate this, we use
			// the binding pattern AST instance for '{ kind, payload }' as a pseudo-reference and narrow this reference
			// as if it occurred in the specified location. We then recompute the narrowed binding element type by
			// destructuring from the narrowed parent type.
			if isBindingElement(declaration) && !declaration.initializer && !declaration.dotDotDotToken && declaration.parent.elements.length >= 2 {
				parent := declaration.parent.parent
				rootDeclaration := getRootDeclaration(parent)
				if rootDeclaration.kind == SyntaxKindVariableDeclaration && getCombinedNodeFlagsCached(rootDeclaration)&NodeFlagsConstant || rootDeclaration.kind == SyntaxKindParameter {
					links := getNodeLinks(parent)
					if !(links.flags & NodeCheckFlagsInCheckIdentifier) {
						links.flags |= NodeCheckFlagsInCheckIdentifier
						parentType := getTypeForBindingElementParent(parent, CheckModeNormal)
						parentTypeConstraint := parentType && mapType(parentType, getBaseConstraintOrType)
						links.flags &= ~NodeCheckFlagsInCheckIdentifier
						if parentTypeConstraint && parentTypeConstraint.flags&TypeFlagsUnion && !(rootDeclaration.kind == SyntaxKindParameter && isSomeSymbolAssigned(rootDeclaration)) {
							pattern := declaration.parent
							narrowedType := getFlowTypeOfReference(pattern, parentTypeConstraint, parentTypeConstraint /*flowContainer*/, nil, location.flowNode)
							if narrowedType.flags & TypeFlagsNever {
								return neverType
							}
							// Destructurings are validated against the parent type elsewhere. Here we disable tuple bounds
							// checks because the narrowed type may have lower arity than the full parent type. For example,
							// for the declaration [x, y]: [1, 2] | [3], we may have narrowed the parent type to just [3].
							return getBindingElementTypeFromParentType(declaration, narrowedType /*noTupleBoundsCheck*/, true)
						}
					}
				}
			}
			// If we have a const-like parameter with no type annotation or initializer, and if the parameter is contextually
			// typed by a signature with a single rest parameter of a union of tuple types, one or more of the parameters may
			// represent discriminant tuple elements, and we want the effects of conditional checks on such discriminants to
			// affect the types of other parameters in the same parameter list. Consider:
			//
			//   type Action = [kind: 'A', payload: number] | [kind: 'B', payload: string];
			//
			//   const f: (...args: Action) => void = (kind, payload) => {
			//       if (kind === 'A') {
			//           payload.toFixed();
			//       }
			//       if (kind === 'B') {
			//           payload.toUpperCase();
			//       }
			//   }
			//
			// Above, we want the conditional checks on 'kind' to affect the type of 'payload'. To facilitate this, we use
			// the arrow function AST node for '(kind, payload) => ...' as a pseudo-reference and narrow this reference as
			// if it occurred in the specified location. We then recompute the narrowed parameter type by indexing into the
			// narrowed tuple type.
			if isParameter(declaration) && !declaration.type_ && !declaration.initializer && !declaration.dotDotDotToken {
				func_ := declaration.parent
				if func_.parameters.length >= 2 && isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
					contextualSignature := getContextualSignature(func_)
					if contextualSignature && contextualSignature.parameters.length == 1 && signatureHasRestParameter(contextualSignature) {
						restType := getReducedApparentType(instantiateType(getTypeOfSymbol(contextualSignature.parameters[0]), getInferenceContext(func_). /* TODO(TS-TO-GO): was ? */ nonFixingMapper))
						if restType.flags&TypeFlagsUnion && everyType(restType, isTupleType) && !some(func_.parameters, isSomeSymbolAssigned) {
							narrowedType := getFlowTypeOfReference(func_, restType, restType /*flowContainer*/, nil, location.flowNode)
							index := func_.parameters.indexOf(declaration) - (__COND__(getThisParameter(func_), 1, 0))
							return getIndexedAccessType(narrowedType, getNumberLiteralType(index))
						}
					}
				}
			}
		}
		return type_
	}
	/**
	 * This part of `checkIdentifier` is kept seperate from the rest, so `NodeCheckFlags` (and related diagnostics) can be lazily calculated
	 * without calculating the flow type of the identifier.
	 */
	checkIdentifierCalculateNodeCheckFlags := func(node Identifier, symbol Symbol) {
		if isThisInTypeQuery(node) {
			return
		}
		// As noted in ECMAScript 6 language spec, arrow functions never have an arguments objects.
		// Although in down-level emit of arrow function, we emit it using function expression which means that
		// arguments objects will be bound to the inner object; emitting arrow function natively in ES6, arguments objects
		// will be bound to non-arrow function that contain this arrow function. This results in inconsistent behavior.
		// To avoid that we will give an error to users if they use arguments objects in arrow function so that they
		// can explicitly bound arguments objects
		if symbol == argumentsSymbol {
			if isInPropertyInitializerOrClassStaticBlock(node) {
				error(node, Diagnostics.arguments_cannot_be_referenced_in_property_initializers)
				return
			}
			container := getContainingFunction(node)
			if container {
				if languageVersion < ScriptTargetES2015 {
					if container.kind == SyntaxKindArrowFunction {
						error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES5_Consider_using_a_standard_function_expression)
					} else if hasSyntacticModifier(container, ModifierFlagsAsync) {
						error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES5_Consider_using_a_standard_function_or_method)
					}
				}
				getNodeLinks(container).flags |= NodeCheckFlagsCaptureArguments
				for container && isArrowFunction(container) {
					container = getContainingFunction(container)
					if container {
						getNodeLinks(container).flags |= NodeCheckFlagsCaptureArguments
					}
				}
			}
			return
		}
		localOrExportSymbol := getExportSymbolOfValueSymbolIfExported(symbol)
		targetSymbol := resolveAliasWithDeprecationCheck(localOrExportSymbol, node)
		if isDeprecatedSymbol(targetSymbol) && isUncalledFunctionReference(node, targetSymbol) && targetSymbol.declarations {
			addDeprecatedSuggestion(node, targetSymbol.declarations, node.escapedText /* as string */)
		}
		declaration := localOrExportSymbol.valueDeclaration
		if declaration && localOrExportSymbol.flags&SymbolFlagsClass {
			// When we downlevel classes we may emit some code outside of the class body. Due to the fact the
			// class name is double-bound, we must ensure we mark references to the class name so that we can
			// emit an alias to the class later.
			if isClassLike(declaration) && declaration.name != node {
				container := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
				for container.kind != SyntaxKindSourceFile && container.parent != declaration {
					container = getThisContainer(container /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
				}
				if container.kind != SyntaxKindSourceFile {
					getNodeLinks(declaration).flags |= NodeCheckFlagsContainsConstructorReference
					getNodeLinks(container).flags |= NodeCheckFlagsContainsConstructorReference
					getNodeLinks(node).flags |= NodeCheckFlagsConstructorReference
				}
			}
		}
		checkNestedBlockScopedBinding(node, symbol)
	}
	checkIdentifier := func(node Identifier, checkMode *CheckMode) Type {
		if isThisInTypeQuery(node) {
			return checkThisExpression(node)
		}
		symbol := getResolvedSymbol(node)
		if symbol == unknownSymbol {
			return errorType
		}
		checkIdentifierCalculateNodeCheckFlags(node, symbol)
		if symbol == argumentsSymbol {
			if isInPropertyInitializerOrClassStaticBlock(node) {
				return errorType
			}
			return getTypeOfSymbol(symbol)
		}
		if shouldMarkIdentifierAliasReferenced(node) {
			markLinkedReferences(node, ReferenceHintIdentifier)
		}
		localOrExportSymbol := getExportSymbolOfValueSymbolIfExported(symbol)
		declaration := localOrExportSymbol.valueDeclaration
		immediateDeclaration := declaration
		// If the identifier is declared in a binding pattern for which we're currently computing the implied type and the
		// reference occurs with the same binding pattern, return the non-inferrable any type. This for example occurs in
		// 'const [a, b = a + 1] = [2]' when we're computing the contextual type for the array literal '[2]'.
		if declaration && declaration.kind == SyntaxKindBindingElement && contains(contextualBindingPatterns, declaration.parent) && findAncestor(node, func(parent Node) bool {
			return parent == declaration.parent
		}) {
			return nonInferrableAnyType
		}
		type_ := getNarrowedTypeOfSymbol(localOrExportSymbol, node)
		assignmentKind := getAssignmentTargetKind(node)
		if assignmentKind {
			if !(localOrExportSymbol.flags & SymbolFlagsVariable) && !(isInJSFile(node) && localOrExportSymbol.flags&SymbolFlagsValueModule) {
				var assignmentError DiagnosticMessage
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case localOrExportSymbol.flags & SymbolFlagsEnum:
					assignmentError = Diagnostics.Cannot_assign_to_0_because_it_is_an_enum
				case localOrExportSymbol.flags & SymbolFlagsClass:
					assignmentError = Diagnostics.Cannot_assign_to_0_because_it_is_a_class
				case localOrExportSymbol.flags & SymbolFlagsModule:
					assignmentError = Diagnostics.Cannot_assign_to_0_because_it_is_a_namespace
				case localOrExportSymbol.flags & SymbolFlagsFunction:
					assignmentError = Diagnostics.Cannot_assign_to_0_because_it_is_a_function
				case localOrExportSymbol.flags & SymbolFlagsAlias:
					assignmentError = Diagnostics.Cannot_assign_to_0_because_it_is_an_import
				default:
					assignmentError = Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable
				}
				error(node, assignmentError, symbolToString(symbol))
				return errorType
			}
			if isReadonlySymbol(localOrExportSymbol) {
				if localOrExportSymbol.flags & SymbolFlagsVariable {
					error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_constant, symbolToString(symbol))
				} else {
					error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(symbol))
				}
				return errorType
			}
		}
		isAlias := localOrExportSymbol.flags & SymbolFlagsAlias
		// We only narrow variables and parameters occurring in a non-assignment position. For all other
		// entities we simply return the declared type.
		if localOrExportSymbol.flags & SymbolFlagsVariable {
			if assignmentKind == AssignmentKindDefinite {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isInCompoundLikeAssignment(node):
					return getBaseTypeOfLiteralType(type_)
				default:
					return type_
				}
			}
		} else if isAlias {
			declaration = getDeclarationOfAliasSymbol(symbol)
		} else {
			return type_
		}
		if !declaration {
			return type_
		}
		type_ = getNarrowableTypeForReference(type_, node, checkMode)
		// The declaration container is the innermost function that encloses the declaration of the variable
		// or parameter. The flow container is the innermost function starting with which we analyze the control
		// flow graph to determine the control flow based type.
		isParameter := getRootDeclaration(declaration).kind == SyntaxKindParameter
		declarationContainer := getControlFlowContainer(declaration)
		flowContainer := getControlFlowContainer(node)
		isOuterVariable := flowContainer != declarationContainer
		isSpreadDestructuringAssignmentTarget := node.parent && node.parent.parent && isSpreadAssignment(node.parent) && isDestructuringAssignmentTarget(node.parent.parent)
		isModuleExports := symbol.flags & SymbolFlagsModuleExports
		typeIsAutomatic := type_ == autoType || type_ == autoArrayType
		isAutomaticTypeInNonNull := typeIsAutomatic && node.parent.kind == SyntaxKindNonNullExpression
		// When the control flow originates in a function expression, arrow function, method, or accessor, and
		// we are referencing a closed-over const variable or parameter or mutable local variable past its last
		// assignment, we extend the origin of the control flow analysis to include the immediately enclosing
		// control flow container.
		for flowContainer != declarationContainer && (flowContainer.kind == SyntaxKindFunctionExpression || flowContainer.kind == SyntaxKindArrowFunction || isObjectLiteralOrClassExpressionMethodOrAccessor(flowContainer)) && (isConstantVariable(localOrExportSymbol) && type_ != autoArrayType || isParameterOrMutableLocalVariable(localOrExportSymbol) && isPastLastAssignment(localOrExportSymbol, node)) {
			flowContainer = getControlFlowContainer(flowContainer)
		}
		// We only look for uninitialized variables in strict null checking mode, and only when we can analyze
		// the entire control flow graph from the variable's declaration (i.e. when the flow container and
		// declaration container are the same).
		isNeverInitialized := immediateDeclaration && isVariableDeclaration(immediateDeclaration) && !immediateDeclaration.initializer && !immediateDeclaration.exclamationToken && isMutableLocalVariableDeclaration(immediateDeclaration) && !isSymbolAssignedDefinitely(symbol)
		assumeInitialized := isParameter || isAlias || (isOuterVariable && !isNeverInitialized) || isSpreadDestructuringAssignmentTarget || isModuleExports || isSameScopedBindingElement(node, declaration) || type_ != autoType && type_ != autoArrayType && (!strictNullChecks || (type_.flags&(TypeFlagsAnyOrUnknown|TypeFlagsVoid)) != 0 || isInTypeQuery(node) || isInAmbientOrTypeNode(node) || node.parent.kind == SyntaxKindExportSpecifier) || node.parent.kind == SyntaxKindNonNullExpression || declaration.kind == SyntaxKindVariableDeclaration && (declaration /* as VariableDeclaration */).exclamationToken || declaration.flags&NodeFlagsAmbient
		var initialType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isAutomaticTypeInNonNull:
			initialType = undefinedType
		case assumeInitialized:
			initialType = (__COND__(isParameter, removeOptionalityFromDeclaredType(type_, declaration /* as VariableLikeDeclaration */), type_))
		case typeIsAutomatic:
			initialType = undefinedType
		default:
			initialType = getOptionalType(type_)
		}
		var flowType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isAutomaticTypeInNonNull:
			flowType = getNonNullableType(getFlowTypeOfReference(node, type_, initialType, flowContainer))
		default:
			flowType = getFlowTypeOfReference(node, type_, initialType, flowContainer)
		}
		// A variable is considered uninitialized when it is possible to analyze the entire control flow graph
		// from declaration to use, and when the variable's declared type doesn't include undefined but the
		// control flow based type does include undefined.
		if !isEvolvingArrayOperationTarget(node) && (type_ == autoType || type_ == autoArrayType) {
			if flowType == autoType || flowType == autoArrayType {
				if noImplicitAny {
					error(getNameOfDeclaration(declaration), Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined, symbolToString(symbol), typeToString(flowType))
					error(node, Diagnostics.Variable_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType))
				}
				return convertAutoToAny(flowType)
			}
		} else if !assumeInitialized && !containsUndefinedType(type_) && containsUndefinedType(flowType) {
			error(node, Diagnostics.Variable_0_is_used_before_being_assigned, symbolToString(symbol))
			// Return the declared type to reduce follow-on errors
			return type_
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case assignmentKind:
			return getBaseTypeOfLiteralType(flowType)
		default:
			return flowType
		}
	}
	isSameScopedBindingElement := func(node Identifier, declaration Declaration) *bool {
		if isBindingElement(declaration) {
			bindingElement := findAncestor(node, isBindingElement)
			return bindingElement && getRootDeclaration(bindingElement) == getRootDeclaration(declaration)
		}
	}
	shouldMarkIdentifierAliasReferenced := func(node Identifier) bool {
		parent := node.parent
		if parent {
			// A property access expression LHS? checkPropertyAccessExpression will handle that.
			if isPropertyAccessExpression(parent) && parent.expression == node {
				return false
			}
			// Next two check for an identifier inside a type only export.
			if isExportSpecifier(parent) && parent.isTypeOnly {
				return false
			}
			greatGrandparent := parent.parent. /* TODO(TS-TO-GO): was ? */ parent
			if greatGrandparent && isExportDeclaration(greatGrandparent) && greatGrandparent.isTypeOnly {
				return false
			}
		}
		return true
	}
	isInsideFunctionOrInstancePropertyInitializer := func(node Node, threshold Node) bool {
		return !!findAncestor(node, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case n == threshold:
				return "quit"
			default:
				return isFunctionLike(n) || (n.parent && isPropertyDeclaration(n.parent) && !hasStaticModifier(n.parent) && n.parent.initializer == n)
			}
		})
	}
	getPartOfForStatementContainingNode := func(node Node, container ForStatement) Node {
		return findAncestor(node, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case n == container:
				return "quit"
			default:
				return n == container.initializer || n == container.condition || n == container.incrementor || n == container.statement
			}
		})
	}
	getEnclosingIterationStatement := func(node Node) Node {
		return findAncestor(node, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (!n || nodeStartsNewLexicalEnvironment(n)):
				return "quit"
			default:
				return isIterationStatement(n /*lookInLabeledStatements*/, false)
			}
		})
	}
	checkNestedBlockScopedBinding := func(node Identifier, symbol Symbol) {
		if languageVersion >= ScriptTargetES2015 || (symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsClass)) == 0 || !symbol.valueDeclaration || isSourceFile(symbol.valueDeclaration) || symbol.valueDeclaration.parent.kind == SyntaxKindCatchClause {
			return
		}
		// 1. walk from the use site up to the declaration and check
		// if there is anything function like between declaration and use-site (is binding/class is captured in function).
		// 2. walk from the declaration up to the boundary of lexical environment and check
		// if there is an iteration statement in between declaration and boundary (is binding/class declared inside iteration statement)
		container := getEnclosingBlockScopeContainer(symbol.valueDeclaration)
		isCaptured := isInsideFunctionOrInstancePropertyInitializer(node, container)
		enclosingIterationStatement := getEnclosingIterationStatement(container)
		if enclosingIterationStatement {
			if isCaptured {
				// mark iteration statement as containing block-scoped binding captured in some function
				capturesBlockScopeBindingInLoopBody := true
				if isForStatement(container) {
					varDeclList := getAncestor(symbol.valueDeclaration, SyntaxKindVariableDeclarationList)
					if varDeclList && varDeclList.parent == container {
						part := getPartOfForStatementContainingNode(node.parent, container)
						if part {
							links := getNodeLinks(part)
							links.flags |= NodeCheckFlagsContainsCapturedBlockScopeBinding
							capturedBindings := links.capturedBlockScopeBindings || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.capturedBlockScopeBindings = [] */ TODO)
							pushIfUnique(capturedBindings, symbol)
							if part == container.initializer {
								capturesBlockScopeBindingInLoopBody = false
								// Initializer is outside of loop body
							}
						}
					}
				}
				if capturesBlockScopeBindingInLoopBody {
					getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
				}
			}
			// mark variables that are declared in loop initializer and reassigned inside the body of ForStatement.
			// if body of ForStatement will be converted to function then we'll need a extra machinery to propagate reassigned values back.
			if isForStatement(container) {
				varDeclList := getAncestor(symbol.valueDeclaration, SyntaxKindVariableDeclarationList)
				if varDeclList && varDeclList.parent == container && isAssignedInBodyOfForStatement(node, container) {
					getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsNeedsLoopOutParameter
				}
			}
			// set 'declared inside loop' bit on the block-scoped binding
			getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsBlockScopedBindingInLoop
		}
		if isCaptured {
			getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsCapturedBlockScopedBinding
		}
	}
	isBindingCapturedByNode := func(node Node, decl /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | BindingElement */ any) bool {
		links := getNodeLinks(node)
		return !!links && contains(links.capturedBlockScopeBindings, getSymbolOfDeclaration(decl))
	}
	isAssignedInBodyOfForStatement := func(node Identifier, container ForStatement) bool {
		// skip parenthesized nodes
		var current Node = node
		for current.parent.kind == SyntaxKindParenthesizedExpression {
			current = current.parent
		}
		// check if node is used as LHS in some assignment expression
		isAssigned := false
		if isAssignmentTarget(current) {
			isAssigned = true
		} else if current.parent.kind == SyntaxKindPrefixUnaryExpression || current.parent.kind == SyntaxKindPostfixUnaryExpression {
			expr := current.parent /* as PrefixUnaryExpression | PostfixUnaryExpression */
			isAssigned = expr.operator == SyntaxKindPlusPlusToken || expr.operator == SyntaxKindMinusMinusToken
		}
		if !isAssigned {
			return false
		}
		// at this point we know that node is the target of assignment
		// now check that modification happens inside the statement part of the ForStatement
		return !!findAncestor(current, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case n == container:
				return "quit"
			default:
				return n == container.statement
			}
		})
	}
	captureLexicalThis := func(node Node, container Node) {
		getNodeLinks(node).flags |= NodeCheckFlagsLexicalThis
		if container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindConstructor {
			classNode := container.parent
			getNodeLinks(classNode).flags |= NodeCheckFlagsCaptureThis
		} else {
			getNodeLinks(container).flags |= NodeCheckFlagsCaptureThis
		}
	}
	findFirstSuperCall := func(node Node) *SuperCall {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isSuperCall(node):
			return node
		case isFunctionLike(node):
			return nil
		default:
			return forEachChild(node, findFirstSuperCall)
		}
	}
	/**
	 * Check if the given class-declaration extends null then return true.
	 * Otherwise, return false
	 * @param classDecl a class declaration to check if it extends null
	 */
	classDeclarationExtendsNull := func(classDecl ClassLikeDeclaration) bool {
		classSymbol := getSymbolOfDeclaration(classDecl)
		classInstanceType := getDeclaredTypeOfSymbol(classSymbol) /* as InterfaceType */
		baseConstructorType := getBaseConstructorTypeOfClass(classInstanceType)
		return baseConstructorType == nullWideningType
	}
	checkThisBeforeSuper := func(node Node, container Node, diagnosticMessage DiagnosticMessage) {
		containingClassDecl := container.parent /* as ClassDeclaration */
		baseTypeNode := getClassExtendsHeritageElement(containingClassDecl)
		// If a containing class does not have extends clause or the class extends null
		// skip checking whether super statement is called before "this" accessing.
		if baseTypeNode && !classDeclarationExtendsNull(containingClassDecl) {
			if canHaveFlowNode(node) && node.flowNode && !isPostSuperFlowNode(node.flowNode /*noCacheCheck*/, false) {
				error(node, diagnosticMessage)
			}
		}
	}
	checkThisInStaticClassFieldInitializerInDecoratedClass := func(thisExpression Node, container Node) {
		if isPropertyDeclaration(container) && hasStaticModifier(container) && legacyDecorators && container.initializer && textRangeContainsPositionInclusive(container.initializer, thisExpression.pos) && hasDecorators(container.parent) {
			error(thisExpression, Diagnostics.Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class)
		}
	}
	checkThisExpression := func(node Node) Type {
		isNodeInTypeQuery := isInTypeQuery(node)
		// Stop at the first arrow function so that we can
		// tell whether 'this' needs to be captured.
		container := getThisContainer(node /*includeArrowFunctions*/, true /*includeClassComputedPropertyName*/, true)
		capturedByArrowFunction := false
		thisInComputedPropertyName := false
		if container.kind == SyntaxKindConstructor {
			checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class)
		}
		for true {
			// Now skip arrow functions to get the "real" owner of 'this'.
			if container.kind == SyntaxKindArrowFunction {
				container = getThisContainer(container /*includeArrowFunctions*/, false, !thisInComputedPropertyName)
				capturedByArrowFunction = true
			}
			if container.kind == SyntaxKindComputedPropertyName {
				container = getThisContainer(container, !capturedByArrowFunction /*includeClassComputedPropertyName*/, false)
				thisInComputedPropertyName = true
				continue
			}
			break
		}
		checkThisInStaticClassFieldInitializerInDecoratedClass(node, container)
		if thisInComputedPropertyName {
			error(node, Diagnostics.this_cannot_be_referenced_in_a_computed_property_name)
		} else {
			switch container.kind {
			case SyntaxKindModuleDeclaration:
				error(node, Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body)
				break
			case SyntaxKindEnumDeclaration:
				error(node, Diagnostics.this_cannot_be_referenced_in_current_location)
				break
			}
		}
		// When targeting es6, mark that we'll need to capture `this` in its lexically bound scope.
		if !isNodeInTypeQuery && capturedByArrowFunction && languageVersion < ScriptTargetES2015 {
			captureLexicalThis(node, container)
		}
		type_ := tryGetThisTypeAt(node /*includeGlobalThis*/, true, container)
		if noImplicitThis {
			globalThisType := getTypeOfSymbol(globalThisSymbol)
			if type_ == globalThisType && capturedByArrowFunction {
				error(node, Diagnostics.The_containing_arrow_function_captures_the_global_value_of_this)
			} else if !type_ {
				// With noImplicitThis, functions may not reference 'this' if it has type 'any'
				diag := error(node, Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation)
				if !isSourceFile(container) {
					outsideThis := tryGetThisTypeAt(container)
					if outsideThis && outsideThis != globalThisType {
						addRelatedInfo(diag, createDiagnosticForNode(container, Diagnostics.An_outer_value_of_this_is_shadowed_by_this_container))
					}
				}
			}
		}
		return type_ || anyType
	}
	tryGetThisTypeAt := func(node Node, includeGlobalThis bool /*  = true */, container ThisContainer /*  = getThisContainer(node, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false) */) Type {
		isInJS := isInJSFile(node)
		if isFunctionLike(container) && (!isInParameterInitializerBeforeContainingFunction(node) || getThisParameter(container)) {
			thisType := getThisTypeOfDeclaration(container) || isInJS && getTypeForThisExpressionFromJSDoc(container)
			// Note: a parameter initializer should refer to class-this unless function-this is explicitly annotated.
			// If this is a function in a JS file, it might be a class method.
			if !thisType {
				className := getClassNameFromPrototypeMethod(container)
				if isInJS && className {
					classSymbol := checkExpression(className).symbol
					if classSymbol && classSymbol.members && (classSymbol.flags & SymbolFlagsFunction) {
						thisType = (getDeclaredTypeOfSymbol(classSymbol) /* as InterfaceType */).thisType
					}
				} else if isJSConstructor(container) {
					thisType = (getDeclaredTypeOfSymbol(getMergedSymbol(container.symbol)) /* as InterfaceType */).thisType
				}
				/* TODO(TS-TO-GO) Node BinaryExpression: thisType ||= getContextualThisParameterType(container) */ TODO
			}
			if thisType {
				return getFlowTypeOfReference(node, thisType)
			}
		}
		if isClassLike(container.parent) {
			symbol := getSymbolOfDeclaration(container.parent)
			var type_ Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isStatic(container):
				type_ = getTypeOfSymbol(symbol)
			default:
				type_ = (getDeclaredTypeOfSymbol(symbol) /* as InterfaceType */).thisType
			}
			return getFlowTypeOfReference(node, type_)
		}
		if isSourceFile(container) {
			// look up in the source file's locals or exports
			if container.commonJsModuleIndicator {
				fileSymbol := getSymbolOfDeclaration(container)
				return fileSymbol && getTypeOfSymbol(fileSymbol)
			} else if container.externalModuleIndicator {
				// TODO: Maybe issue a better error than 'object is possibly undefined'
				return undefinedType
			} else if includeGlobalThis {
				return getTypeOfSymbol(globalThisSymbol)
			}
		}
	}
	getExplicitThisType := func(node Expression) Type {
		container := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
		if isFunctionLike(container) {
			signature := getSignatureFromDeclaration(container)
			if signature.thisParameter {
				return getExplicitTypeOfSymbol(signature.thisParameter)
			}
		}
		if isClassLike(container.parent) {
			symbol := getSymbolOfDeclaration(container.parent)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isStatic(container):
				return getTypeOfSymbol(symbol)
			default:
				return (getDeclaredTypeOfSymbol(symbol) /* as InterfaceType */).thisType
			}
		}
	}
	getClassNameFromPrototypeMethod := func(container Node) *LeftHandSideExpression {
		// Check if it's the RHS of a x.prototype.y = function [name]() { .... }
		if container.kind == SyntaxKindFunctionExpression && isBinaryExpression(container.parent) && getAssignmentDeclarationKind(container.parent) == AssignmentDeclarationKindPrototypeProperty {
			// Get the 'x' of 'x.prototype.y = container'
			return ((container.parent.left /* as PropertyAccessExpression */).expression /* as PropertyAccessExpression */).expression
			// x
		} else if container.kind == SyntaxKindMethodDeclaration && container.parent.kind == SyntaxKindObjectLiteralExpression && isBinaryExpression(container.parent.parent) && getAssignmentDeclarationKind(container.parent.parent) == AssignmentDeclarationKindPrototype {
			return (container.parent.parent.left /* as PropertyAccessExpression */).expression
		} else if container.kind == SyntaxKindFunctionExpression && container.parent.kind == SyntaxKindPropertyAssignment && container.parent.parent.kind == SyntaxKindObjectLiteralExpression && isBinaryExpression(container.parent.parent.parent) && getAssignmentDeclarationKind(container.parent.parent.parent) == AssignmentDeclarationKindPrototype {
			return (container.parent.parent.parent.left /* as PropertyAccessExpression */).expression
		} else if container.kind == SyntaxKindFunctionExpression && isPropertyAssignment(container.parent) && isIdentifier(container.parent.name) && (container.parent.name.escapedText == "value" || container.parent.name.escapedText == "get" || container.parent.name.escapedText == "set") && isObjectLiteralExpression(container.parent.parent) && isCallExpression(container.parent.parent.parent) && container.parent.parent.parent.arguments[2] == container.parent.parent && getAssignmentDeclarationKind(container.parent.parent.parent) == AssignmentDeclarationKindObjectDefinePrototypeProperty {
			return (container.parent.parent.parent.arguments[0] /* as PropertyAccessExpression */).expression
		} else if isMethodDeclaration(container) && isIdentifier(container.name) && (container.name.escapedText == "value" || container.name.escapedText == "get" || container.name.escapedText == "set") && isObjectLiteralExpression(container.parent) && isCallExpression(container.parent.parent) && container.parent.parent.arguments[2] == container.parent && getAssignmentDeclarationKind(container.parent.parent) == AssignmentDeclarationKindObjectDefinePrototypeProperty {
			return (container.parent.parent.arguments[0] /* as PropertyAccessExpression */).expression
		}
	}
	getTypeForThisExpressionFromJSDoc := func(node SignatureDeclaration) Type {
		thisTag := getJSDocThisTag(node)
		if thisTag && thisTag.typeExpression {
			return getTypeFromTypeNode(thisTag.typeExpression)
		}
		signature := getSignatureOfTypeTag(node)
		if signature {
			return getThisTypeOfSignature(signature)
		}
	}
	isInConstructorArgumentInitializer := func(node Node, constructorDecl Node) bool {
		return !!findAncestor(node, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isFunctionLikeDeclaration(n):
				return "quit"
			default:
				return n.kind == SyntaxKindParameter && n.parent == constructorDecl
			}
		})
	}
	checkSuperExpression := func(node Node) Type {
		isCallExpression := node.parent.kind == SyntaxKindCallExpression && (node.parent /* as CallExpression */).expression == node
		immediateContainer := getSuperContainer(node /*stopOnFunctions*/, true)
		container := immediateContainer
		needToCaptureLexicalThis := false
		inAsyncFunction := false
		// adjust the container reference in case if super is used inside arrow functions with arbitrarily deep nesting
		if !isCallExpression {
			for container && container.kind == SyntaxKindArrowFunction {
				if hasSyntacticModifier(container, ModifierFlagsAsync) {
					inAsyncFunction = true
				}
				container = getSuperContainer(container /*stopOnFunctions*/, true)
				needToCaptureLexicalThis = languageVersion < ScriptTargetES2015
			}
			if container && hasSyntacticModifier(container, ModifierFlagsAsync) {
				inAsyncFunction = true
			}
		}
		var nodeCheckFlag NodeCheckFlags = 0
		if !container || !isLegalUsageOfSuperExpression(container) {
			// issue more specific error if super is used in computed property name
			// class A { foo() { return "1" }}
			// class B {
			//     [super.foo()]() {}
			// }
			current := findAncestor(node, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case n == container:
					return "quit"
				default:
					return n.kind == SyntaxKindComputedPropertyName
				}
			})
			if current && current.kind == SyntaxKindComputedPropertyName {
				error(node, Diagnostics.super_cannot_be_referenced_in_a_computed_property_name)
			} else if isCallExpression {
				error(node, Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors)
			} else if !container || !container.parent || !(isClassLike(container.parent) || container.parent.kind == SyntaxKindObjectLiteralExpression) {
				error(node, Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions)
			} else {
				error(node, Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class)
			}
			return errorType
		}
		if !isCallExpression && immediateContainer.kind == SyntaxKindConstructor {
			checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class)
		}
		if isStatic(container) || isCallExpression {
			nodeCheckFlag = NodeCheckFlagsSuperStatic
			if !isCallExpression && languageVersion >= ScriptTargetES2015 && languageVersion <= ScriptTargetES2021 && (isPropertyDeclaration(container) || isClassStaticBlockDeclaration(container)) {
				// for `super.x` or `super[x]` in a static initializer, mark all enclosing
				// block scope containers so that we can report potential collisions with
				// `Reflect`.
				forEachEnclosingBlockScopeContainer(node.parent, func(current Node) {
					if !isSourceFile(current) || isExternalOrCommonJsModule(current) {
						getNodeLinks(current).flags |= NodeCheckFlagsContainsSuperPropertyInStaticInitializer
					}
				})
			}
		} else {
			nodeCheckFlag = NodeCheckFlagsSuperInstance
		}
		getNodeLinks(node).flags |= nodeCheckFlag
		// Due to how we emit async functions, we need to specialize the emit for an async method that contains a `super` reference.
		// This is due to the fact that we emit the body of an async function inside of a generator function. As generator
		// functions cannot reference `super`, we emit a helper inside of the method body, but outside of the generator. This helper
		// uses an arrow function, which is permitted to reference `super`.
		//
		// There are two primary ways we can access `super` from within an async method. The first is getting the value of a property
		// or indexed access on super, either as part of a right-hand-side expression or call expression. The second is when setting the value
		// of a property or indexed access, either as part of an assignment expression or destructuring assignment.
		//
		// The simplest case is reading a value, in which case we will emit something like the following:
		//
		//  // ts
		//  ...
		//  async asyncMethod() {
		//    let x = await super.asyncMethod();
		//    return x;
		//  }
		//  ...
		//
		//  // js
		//  ...
		//  asyncMethod() {
		//      const _super = Object.create(null, {
		//        asyncMethod: { get: () => super.asyncMethod },
		//      });
		//      return __awaiter(this, arguments, Promise, function *() {
		//          let x = yield _super.asyncMethod.call(this);
		//          return x;
		//      });
		//  }
		//  ...
		//
		// The more complex case is when we wish to assign a value, especially as part of a destructuring assignment. As both cases
		// are legal in ES6, but also likely less frequent, we only emit setters if there is an assignment:
		//
		//  // ts
		//  ...
		//  async asyncMethod(ar: Promise<any[]>) {
		//      [super.a, super.b] = await ar;
		//  }
		//  ...
		//
		//  // js
		//  ...
		//  asyncMethod(ar) {
		//      const _super = Object.create(null, {
		//        a: { get: () => super.a, set: (v) => super.a = v },
		//        b: { get: () => super.b, set: (v) => super.b = v }
		//      };
		//      return __awaiter(this, arguments, Promise, function *() {
		//          [_super.a, _super.b] = yield ar;
		//      });
		//  }
		//  ...
		//
		// Creating an object that has getter and setters instead of just an accessor function is required for destructuring assignments
		// as a call expression cannot be used as the target of a destructuring assignment while a property access can.
		//
		// For element access expressions (`super[x]`), we emit a generic helper that forwards the element access in both situations.
		if container.kind == SyntaxKindMethodDeclaration && inAsyncFunction {
			if isSuperProperty(node.parent) && isAssignmentTarget(node.parent) {
				getNodeLinks(container).flags |= NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync
			} else {
				getNodeLinks(container).flags |= NodeCheckFlagsMethodWithSuperPropertyAccessInAsync
			}
		}
		if needToCaptureLexicalThis {
			// call expressions are allowed only in constructors so they should always capture correct 'this'
			// super property access expressions can also appear in arrow functions -
			// in this case they should also use correct lexical this
			captureLexicalThis(node.parent, container)
		}
		if container.parent.kind == SyntaxKindObjectLiteralExpression {
			if languageVersion < ScriptTargetES2015 {
				error(node, Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher)
				return errorType
			} else {
				// for object literal assume that type of 'super' is 'any'
				return anyType
			}
		}
		// at this point the only legal case for parent is ClassLikeDeclaration
		classLikeDeclaration := container.parent /* as ClassLikeDeclaration */
		if !getClassExtendsHeritageElement(classLikeDeclaration) {
			error(node, Diagnostics.super_can_only_be_referenced_in_a_derived_class)
			return errorType
		}
		if classDeclarationExtendsNull(classLikeDeclaration) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isCallExpression:
				return errorType
			default:
				return nullWideningType
			}
		}
		classType := getDeclaredTypeOfSymbol(getSymbolOfDeclaration(classLikeDeclaration)) /* as InterfaceType */
		baseClassType := classType && getBaseTypes(classType)[0]
		if !baseClassType {
			return errorType
		}
		if container.kind == SyntaxKindConstructor && isInConstructorArgumentInitializer(node, container) {
			// issue custom error message for super property access in constructor arguments (to be aligned with old compiler)
			error(node, Diagnostics.super_cannot_be_referenced_in_constructor_arguments)
			return errorType
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case nodeCheckFlag == NodeCheckFlagsSuperStatic:
			return getBaseConstructorTypeOfClass(classType)
		default:
			return getTypeWithThisArgument(baseClassType, classType.thisType)
		}
		isLegalUsageOfSuperExpression := func(container Node) bool {
			if isCallExpression {
				// TS 1.0 SPEC (April 2014): 4.8.1
				// Super calls are only permitted in constructors of derived classes
				return container.kind == SyntaxKindConstructor
			} else {
				// TS 1.0 SPEC (April 2014)
				// 'super' property access is allowed
				// - In a constructor, instance member function, instance member accessor, or instance member variable initializer where this references a derived class instance
				// - In a static member function or static member accessor
				// topmost container must be something that is directly nested in the class declaration\object literal expression
				if isClassLike(container.parent) || container.parent.kind == SyntaxKindObjectLiteralExpression {
					if isStatic(container) {
						return container.kind == SyntaxKindMethodDeclaration || container.kind == SyntaxKindMethodSignature || container.kind == SyntaxKindGetAccessor || container.kind == SyntaxKindSetAccessor || container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindClassStaticBlockDeclaration
					} else {
						return container.kind == SyntaxKindMethodDeclaration || container.kind == SyntaxKindMethodSignature || container.kind == SyntaxKindGetAccessor || container.kind == SyntaxKindSetAccessor || container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindPropertySignature || container.kind == SyntaxKindConstructor
					}
				}
			}
			return false
		}
	}
	getContainingObjectLiteral := func(func_ SignatureDeclaration) *ObjectLiteralExpression {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case (func_.kind == SyntaxKindMethodDeclaration || func_.kind == SyntaxKindGetAccessor || func_.kind == SyntaxKindSetAccessor) && func_.parent.kind == SyntaxKindObjectLiteralExpression:
			return func_.parent
		case func_.kind == SyntaxKindFunctionExpression && func_.parent.kind == SyntaxKindPropertyAssignment:
			return func_.parent.parent /* as ObjectLiteralExpression */
		default:
			return nil
		}
	}
	getThisTypeArgument := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getObjectFlags(type_)&ObjectFlagsReference && (type_ /* as TypeReference */).target == globalThisType:
			return getTypeArguments(type_ /* as TypeReference */)[0]
		default:
			return nil
		}
	}
	getThisTypeFromContextualType := func(type_ Type) Type {
		return mapType(type_, func(t Type) Type {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case t.flags & TypeFlagsIntersection:
				return forEach((t /* as IntersectionType */).types, getThisTypeArgument)
			default:
				return getThisTypeArgument(t)
			}
		})
	}
	getThisTypeOfObjectLiteralFromContextualType := func(containingLiteral ObjectLiteralExpression, contextualType Type) Type {
		literal := containingLiteral
		type_ := contextualType
		for type_ {
			thisType := getThisTypeFromContextualType(type_)
			if thisType {
				return thisType
			}
			if literal.parent.kind != SyntaxKindPropertyAssignment {
				break
			}
			literal = literal.parent.parent /* as ObjectLiteralExpression */
			type_ = getApparentTypeOfContextualType(literal /*contextFlags*/, nil)
		}
	}
	getContextualThisParameterType := func(func_ SignatureDeclaration) Type {
		if func_.kind == SyntaxKindArrowFunction {
			return nil
		}
		if isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
			contextualSignature := getContextualSignature(func_)
			if contextualSignature {
				thisParameter := contextualSignature.thisParameter
				if thisParameter {
					return getTypeOfSymbol(thisParameter)
				}
			}
		}
		inJs := isInJSFile(func_)
		if noImplicitThis || inJs {
			containingLiteral := getContainingObjectLiteral(func_)
			if containingLiteral {
				// We have an object literal method. Check if the containing object literal has a contextual type
				// that includes a ThisType<T>. If so, T is the contextual type for 'this'. We continue looking in
				// any directly enclosing object literals.
				contextualType := getApparentTypeOfContextualType(containingLiteral /*contextFlags*/, nil)
				thisType := getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
				if thisType {
					return instantiateType(thisType, getMapperFromContext(getInferenceContext(containingLiteral)))
				}
				// There was no contextual ThisType<T> for the containing object literal, so the contextual type
				// for 'this' is the non-null form of the contextual type for the containing object literal or
				// the type of the object literal itself.
				return getWidenedType(__COND__(contextualType, getNonNullableType(contextualType), checkExpressionCached(containingLiteral)))
			}
			// In an assignment of the form 'obj.xxx = function(...)' or 'obj[xxx] = function(...)', the
			// contextual type for 'this' is 'obj'.
			parent := walkUpParenthesizedExpressions(func_.parent)
			if isAssignmentExpression(parent) {
				target := parent.left
				if isAccessExpression(target) {
					TODO_IDENTIFIER := target
					// Don't contextually type `this` as `exports` in `exports.Point = function(x, y) { this.x = x; this.y = y; }`
					if inJs && isIdentifier(expression) {
						sourceFile := getSourceFileOfNode(parent)
						if sourceFile.commonJsModuleIndicator && getResolvedSymbol(expression) == sourceFile.symbol {
							return nil
						}
					}
					return getWidenedType(checkExpressionCached(expression))
				}
			}
		}
		return nil
	}
	// Return contextual type of parameter or undefined if no contextual type is available
	getContextuallyTypedParameterType := func(parameter ParameterDeclaration) Type {
		func_ := parameter.parent
		if !isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
			return nil
		}
		iife := getImmediatelyInvokedFunctionExpression(func_)
		if iife && iife.arguments {
			args := getEffectiveCallArguments(iife)
			indexOfParameter := func_.parameters.indexOf(parameter)
			if parameter.dotDotDotToken {
				return getSpreadArgumentType(args, indexOfParameter, args.length, anyType /*context*/, nil, CheckModeNormal)
			}
			links := getNodeLinks(iife)
			cached := links.resolvedSignature
			links.resolvedSignature = anySignature
			var type_ Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case indexOfParameter < args.length:
				type_ = getWidenedLiteralType(checkExpression(args[indexOfParameter]))
			case parameter.initializer:
				type_ = nil
			default:
				type_ = undefinedWideningType
			}
			links.resolvedSignature = cached
			return type_
		}
		contextualSignature := getContextualSignature(func_)
		if contextualSignature {
			index := func_.parameters.indexOf(parameter) - (__COND__(getThisParameter(func_), 1, 0))
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case parameter.dotDotDotToken && lastOrUndefined(func_.parameters) == parameter:
				return getRestTypeAtPosition(contextualSignature, index)
			default:
				return tryGetTypeAtPosition(contextualSignature, index)
			}
		}
	}
	getContextualTypeForVariableLikeDeclaration := func(declaration VariableLikeDeclaration, contextFlags *ContextFlags) Type {
		typeNode := getEffectiveTypeAnnotationNode(declaration) || (__COND__(isInJSFile(declaration), tryGetJSDocSatisfiesTypeNode(declaration), nil))
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
		switch declaration.kind {
		case SyntaxKindParameter:
			return getContextuallyTypedParameterType(declaration)
		case SyntaxKindBindingElement:
			return getContextualTypeForBindingElement(declaration, contextFlags)
		case SyntaxKindPropertyDeclaration:
			if isStatic(declaration) {
				return getContextualTypeForStaticPropertyDeclaration(declaration, contextFlags)
			}
		}
	}
	getContextualTypeForBindingElement := func(declaration BindingElement, contextFlags *ContextFlags) Type {
		parent := declaration.parent.parent
		name := declaration.propertyName || declaration.name
		parentType := getContextualTypeForVariableLikeDeclaration(parent, contextFlags) || parent.kind != SyntaxKindBindingElement && parent.initializer && checkDeclarationInitializer(parent, __COND__(declaration.dotDotDotToken, CheckModeRestBindingElement, CheckModeNormal))
		if !parentType || isBindingPattern(name) || isComputedNonLiteralName(name) {
			return nil
		}
		if parent.name.kind == SyntaxKindArrayBindingPattern {
			index := indexOfNode(declaration.parent.elements, declaration)
			if index < 0 {
				return nil
			}
			return getContextualTypeForElementExpression(parentType, index)
		}
		nameType := getLiteralTypeFromPropertyName(name)
		if isTypeUsableAsPropertyName(nameType) {
			text := getPropertyNameFromType(nameType)
			return getTypeOfPropertyOfType(parentType, text)
		}
	}
	getContextualTypeForStaticPropertyDeclaration := func(declaration PropertyDeclaration, contextFlags *ContextFlags) Type {
		parentType := isExpression(declaration.parent) && getContextualType(declaration.parent, contextFlags)
		if !parentType {
			return nil
		}
		return getTypeOfPropertyOfContextualType(parentType, getSymbolOfDeclaration(declaration).escapedName)
	}
	// In a variable, parameter or property declaration with a type annotation,
	//   the contextual type of an initializer expression is the type of the variable, parameter or property.
	// Otherwise, in a parameter declaration of a contextually typed function expression,
	//   the contextual type of an initializer expression is the contextual type of the parameter.
	// Otherwise, in a variable or parameter declaration with a binding pattern name,
	//   the contextual type of an initializer expression is the type implied by the binding pattern.
	// Otherwise, in a binding pattern inside a variable or parameter declaration,
	//   the contextual type of an initializer expression is the type annotation of the containing declaration, if present.
	getContextualTypeForInitializerExpression := func(node Expression, contextFlags *ContextFlags) Type {
		declaration := node.parent /* as VariableLikeDeclaration */
		if hasInitializer(declaration) && node == declaration.initializer {
			result := getContextualTypeForVariableLikeDeclaration(declaration, contextFlags)
			if result {
				return result
			}
			if !(contextFlags & ContextFlagsSkipBindingPatterns) && isBindingPattern(declaration.name) && declaration.name.elements.length > 0 {
				return getTypeFromBindingPattern(declaration.name /*includePatternInType*/, true /*reportErrors*/, false)
			}
		}
		return nil
	}
	getContextualTypeForReturnExpression := func(node Expression, contextFlags *ContextFlags) Type {
		func_ := getContainingFunction(node)
		if func_ {
			contextualReturnType := getContextualReturnType(func_, contextFlags)
			if contextualReturnType {
				functionFlags := getFunctionFlags(func_)
				if functionFlags & FunctionFlagsGenerator {
					isAsyncGenerator := (functionFlags & FunctionFlagsAsync) != 0
					if contextualReturnType.flags & TypeFlagsUnion {
						contextualReturnType = filterType(contextualReturnType, func(type_ Type) bool {
							return !!getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, type_, isAsyncGenerator)
						})
					}
					iterationReturnType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, contextualReturnType, (functionFlags&FunctionFlagsAsync) != 0)
					if !iterationReturnType {
						return nil
					}
					contextualReturnType = iterationReturnType
					// falls through to unwrap Promise for AsyncGenerators
				}
				if functionFlags & FunctionFlagsAsync {
					// Get the awaited type without the `Awaited<T>` alias
					contextualAwaitedType := mapType(contextualReturnType, getAwaitedTypeNoAlias)
					return contextualAwaitedType && getUnionType([]Type{contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)})
				}
				return contextualReturnType
				// Regular function or Generator function
			}
		}
		return nil
	}
	getContextualTypeForAwaitOperand := func(node AwaitExpression, contextFlags *ContextFlags) Type {
		contextualType := getContextualType(node, contextFlags)
		if contextualType {
			contextualAwaitedType := getAwaitedTypeNoAlias(contextualType)
			return contextualAwaitedType && getUnionType([]Type{contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)})
		}
		return nil
	}
	getContextualTypeForYieldOperand := func(node YieldExpression, contextFlags *ContextFlags) Type {
		func_ := getContainingFunction(node)
		if func_ {
			functionFlags := getFunctionFlags(func_)
			contextualReturnType := getContextualReturnType(func_, contextFlags)
			if contextualReturnType {
				isAsyncGenerator := (functionFlags & FunctionFlagsAsync) != 0
				if !node.asteriskToken && contextualReturnType.flags&TypeFlagsUnion {
					contextualReturnType = filterType(contextualReturnType, func(type_ Type) bool {
						return !!getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, type_, isAsyncGenerator)
					})
				}
				if node.asteriskToken {
					iterationTypes := getIterationTypesOfGeneratorFunctionReturnType(contextualReturnType, isAsyncGenerator)
					yieldType := /* TODO(TS-TO-GO) Node BinaryExpression: iterationTypes?.yieldType ?? silentNeverType */ TODO
					returnType := /* TODO(TS-TO-GO) Node BinaryExpression: getContextualType(node, contextFlags) ?? silentNeverType */ TODO
					nextType := /* TODO(TS-TO-GO) Node BinaryExpression: iterationTypes?.nextType ?? unknownType */ TODO
					generatorType := createGeneratorType(yieldType, returnType, nextType /*isAsyncGenerator*/, false)
					if isAsyncGenerator {
						asyncGeneratorType := createGeneratorType(yieldType, returnType, nextType /*isAsyncGenerator*/, true)
						return getUnionType([]ObjectType{generatorType, asyncGeneratorType})
					}
					return generatorType
				}
				return getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindYield, contextualReturnType, isAsyncGenerator)
			}
		}
		return nil
	}
	isInParameterInitializerBeforeContainingFunction := func(node Node) bool {
		inBindingInitializer := false
		for node.parent && !isFunctionLike(node.parent) {
			if isParameter(node.parent) && (inBindingInitializer || node.parent.initializer == node) {
				return true
			}
			if isBindingElement(node.parent) && node.parent.initializer == node {
				inBindingInitializer = true
			}
			node = node.parent
		}
		return false
	}
	getContextualIterationType := func(kind IterationTypeKind, functionDecl SignatureDeclaration) Type {
		isAsync := !!(getFunctionFlags(functionDecl) & FunctionFlagsAsync)
		contextualReturnType := getContextualReturnType(functionDecl /*contextFlags*/, nil)
		if contextualReturnType {
			return getIterationTypeOfGeneratorFunctionReturnType(kind, contextualReturnType, isAsync) || nil
		}
		return nil
	}
	getContextualReturnType := func(functionDecl SignatureDeclaration, contextFlags *ContextFlags) Type {
		// If the containing function has a return type annotation, is a constructor, or is a get accessor whose
		// corresponding set accessor has a type annotation, return statements in the function are contextually typed
		returnType := getReturnTypeFromAnnotation(functionDecl)
		if returnType {
			return returnType
		}
		// Otherwise, if the containing function is contextually typed by a function type with exactly one call signature
		// and that call signature is non-generic, return statements are contextually typed by the return type of the signature
		signature := getContextualSignatureForFunctionLikeDeclaration(functionDecl /* as FunctionExpression */)
		if signature && !isResolvingReturnTypeOfSignature(signature) {
			returnType := getReturnTypeOfSignature(signature)
			functionFlags := getFunctionFlags(functionDecl)
			if functionFlags & FunctionFlagsGenerator {
				return filterType(returnType, func(t Type) bool {
					return !!(t.flags & (TypeFlagsAnyOrUnknown | TypeFlagsVoid | TypeFlagsInstantiableNonPrimitive)) || checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags /*errorNode*/, nil)
				})
			}
			if functionFlags & FunctionFlagsAsync {
				return filterType(returnType, func(t Type) bool {
					return !!(t.flags & (TypeFlagsAnyOrUnknown | TypeFlagsVoid | TypeFlagsInstantiableNonPrimitive)) || !!getAwaitedTypeOfPromise(t)
				})
			}
			return returnType
		}
		iife := getImmediatelyInvokedFunctionExpression(functionDecl)
		if iife {
			return getContextualType(iife, contextFlags)
		}
		return nil
	}
	// In a typed function call, an argument or substitution expression is contextually typed by the type of the corresponding parameter.
	getContextualTypeForArgument := func(callTarget CallLikeExpression, arg Expression) Type {
		args := getEffectiveCallArguments(callTarget)
		argIndex := args.indexOf(arg)
		// -1 for e.g. the expression of a CallExpression, or the tag of a TaggedTemplateExpression
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case argIndex == -1:
			return nil
		default:
			return getContextualTypeForArgumentAtIndex(callTarget, argIndex)
		}
	}
	getContextualTypeForArgumentAtIndex := func(callTarget CallLikeExpression, argIndex number) Type {
		if isImportCall(callTarget) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case argIndex == 0:
				return stringType
			case argIndex == 1:
				return getGlobalImportCallOptionsType(false)
			default:
				return anyType
			}
		}
		// If we're already in the process of resolving the given signature, don't resolve again as
		// that could cause infinite recursion. Instead, return anySignature.
		var signature Signature
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getNodeLinks(callTarget).resolvedSignature == resolvingSignature:
			signature = resolvingSignature
		default:
			signature = getResolvedSignature(callTarget)
		}
		if isJsxOpeningLikeElement(callTarget) && argIndex == 0 {
			return getEffectiveFirstArgumentForJsxSignature(signature, callTarget)
		}
		restIndex := signature.parameters.length - 1
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case signatureHasRestParameter(signature) && argIndex >= restIndex:
			return getIndexedAccessType(getTypeOfSymbol(signature.parameters[restIndex]), getNumberLiteralType(argIndex-restIndex), AccessFlagsContextual)
		default:
			return getTypeAtPosition(signature, argIndex)
		}
	}
	getContextualTypeForDecorator := func(decorator Decorator) Type {
		signature := getDecoratorCallSignature(decorator)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case signature:
			return getOrCreateTypeFromSignature(signature)
		default:
			return nil
		}
	}
	getContextualTypeForSubstitutionExpression := func(template TemplateExpression, substitutionExpression Expression) Type {
		if template.parent.kind == SyntaxKindTaggedTemplateExpression {
			return getContextualTypeForArgument(template.parent /* as TaggedTemplateExpression */, substitutionExpression)
		}
		return nil
	}
	getContextualTypeForBinaryOperand := func(node Expression, contextFlags *ContextFlags) Type {
		binaryExpression := node.parent /* as BinaryExpression */
		TODO_IDENTIFIER := binaryExpression
		switch operatorToken.kind {
		case SyntaxKindEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindAmpersandAmpersandEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBarBarEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindQuestionQuestionEqualsToken:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node == right:
				return getContextualTypeForAssignmentDeclaration(binaryExpression)
			default:
				return nil
			}
		case SyntaxKindBarBarToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindQuestionQuestionToken:
			type_ := getContextualType(binaryExpression, contextFlags)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node == right && (type_ && type_.pattern || !type_ && !isDefaultedExpandoInitializer(binaryExpression)):
				return getTypeOfExpression(left)
			default:
				return type_
			}
		case SyntaxKindAmpersandAmpersandToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindCommaToken:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node == right:
				return getContextualType(binaryExpression, contextFlags)
			default:
				return nil
			}
		default:
			return nil
		}
	}
	/**
	 * Try to find a resolved symbol for an expression without also resolving its type, as
	 * getSymbolAtLocation would (as that could be reentrant into contextual typing)
	 */
	getSymbolForExpression := func(e Expression) Symbol {
		if canHaveSymbol(e) && e.symbol {
			return e.symbol
		}
		if isIdentifier(e) {
			return getResolvedSymbol(e)
		}
		if isPropertyAccessExpression(e) {
			lhsType := getTypeOfExpression(e.expression)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isPrivateIdentifier(e.name):
				return tryGetPrivateIdentifierPropertyOfType(lhsType, e.name)
			default:
				return getPropertyOfType(lhsType, e.name.escapedText)
			}
		}
		if isElementAccessExpression(e) {
			propType := checkExpressionCached(e.argumentExpression)
			if !isTypeUsableAsPropertyName(propType) {
				return nil
			}
			lhsType := getTypeOfExpression(e.expression)
			return getPropertyOfType(lhsType, getPropertyNameFromType(propType))
		}
		return nil
		tryGetPrivateIdentifierPropertyOfType := func(type_ Type, id PrivateIdentifier) Symbol {
			lexicallyScopedSymbol := lookupSymbolForPrivateIdentifierDeclaration(id.escapedText, id)
			return lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(type_, lexicallyScopedSymbol)
		}
	}
	// In an assignment expression, the right operand is contextually typed by the type of the left operand.
	// Don't do this for assignment declarations unless there is a type tag on the assignment, to avoid circularity from checking the right operand.
	getContextualTypeForAssignmentDeclaration := func(binaryExpression BinaryExpression) Type {
		kind := getAssignmentDeclarationKind(binaryExpression)
		switch kind {
		case AssignmentDeclarationKindNone:
			fallthrough // TODO(TS-TO-GO): merge cases
		case AssignmentDeclarationKindThisProperty:
			lhsSymbol := getSymbolForExpression(binaryExpression.left)
			decl := lhsSymbol && lhsSymbol.valueDeclaration
			if decl && (isPropertyDeclaration(decl) || isPropertySignature(decl)) {
				overallAnnotation := getEffectiveTypeAnnotationNode(decl)
				return (overallAnnotation && instantiateType(getTypeFromTypeNode(overallAnnotation), getSymbolLinks(lhsSymbol).mapper)) || (__COND__(isPropertyDeclaration(decl), decl.initializer && getTypeOfExpression(binaryExpression.left), nil))
			}
			if kind == AssignmentDeclarationKindNone {
				return getTypeOfExpression(binaryExpression.left)
			}
			return getContextualTypeForThisPropertyAssignment(binaryExpression)
		case AssignmentDeclarationKindProperty:
			if isPossiblyAliasedThisProperty(binaryExpression, kind) {
				return getContextualTypeForThisPropertyAssignment(binaryExpression)
			} else if !canHaveSymbol(binaryExpression.left) || !binaryExpression.left.symbol {
				return getTypeOfExpression(binaryExpression.left)
			} else {
				decl := binaryExpression.left.symbol.valueDeclaration
				if !decl {
					return nil
				}
				lhs := cast(binaryExpression.left, isAccessExpression)
				overallAnnotation := getEffectiveTypeAnnotationNode(decl)
				if overallAnnotation {
					return getTypeFromTypeNode(overallAnnotation)
				} else if isIdentifier(lhs.expression) {
					id := lhs.expression
					parentSymbol := resolveName(id, id.escapedText, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, true)
					if parentSymbol {
						annotated := parentSymbol.valueDeclaration && getEffectiveTypeAnnotationNode(parentSymbol.valueDeclaration)
						if annotated {
							nameStr := getElementOrPropertyAccessName(lhs)
							if nameStr != nil {
								return getTypeOfPropertyOfContextualType(getTypeFromTypeNode(annotated), nameStr)
							}
						}
						return nil
					}
				}
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isInJSFile(decl) || decl == binaryExpression.left:
					return nil
				default:
					return getTypeOfExpression(binaryExpression.left)
				}
			}
			fallthrough
		case AssignmentDeclarationKindExportsProperty:
			fallthrough // TODO(TS-TO-GO): merge cases
		case AssignmentDeclarationKindPrototype:
			fallthrough // TODO(TS-TO-GO): merge cases
		case AssignmentDeclarationKindPrototypeProperty:
			fallthrough // TODO(TS-TO-GO): merge cases
		case AssignmentDeclarationKindModuleExports:
			var valueDeclaration Declaration
			if kind != AssignmentDeclarationKindModuleExports {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case canHaveSymbol(binaryExpression.left):
					valueDeclaration = binaryExpression.left.symbol. /* TODO(TS-TO-GO): was ? */ valueDeclaration
				default:
					valueDeclaration = nil
				}
			}
			/* TODO(TS-TO-GO) Node BinaryExpression: valueDeclaration ||= binaryExpression.symbol?.valueDeclaration */ TODO
			annotated := valueDeclaration && getEffectiveTypeAnnotationNode(valueDeclaration)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case annotated:
				return getTypeFromTypeNode(annotated)
			default:
				return nil
			}
		case AssignmentDeclarationKindObjectDefinePropertyValue:
			fallthrough // TODO(TS-TO-GO): merge cases
		case AssignmentDeclarationKindObjectDefinePropertyExports:
			fallthrough // TODO(TS-TO-GO): merge cases
		case AssignmentDeclarationKindObjectDefinePrototypeProperty:
			return Debug.fail("Does not apply")
		default:
			return Debug.assertNever(kind)
		}
	}
	isPossiblyAliasedThisProperty := func(declaration BinaryExpression, kind AssignmentDeclarationKind /*  = getAssignmentDeclarationKind(declaration) */) bool {
		if kind == AssignmentDeclarationKindThisProperty {
			return true
		}
		if !isInJSFile(declaration) || kind != AssignmentDeclarationKindProperty || !isIdentifier((declaration.left /* as AccessExpression */).expression) {
			return false
		}
		name := ((declaration.left /* as AccessExpression */).expression /* as Identifier */).escapedText
		symbol := resolveName(declaration.left, name, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, true /*excludeGlobals*/, true)
		return isThisInitializedDeclaration(symbol. /* TODO(TS-TO-GO): was ? */ valueDeclaration)
	}
	getContextualTypeForThisPropertyAssignment := func(binaryExpression BinaryExpression) Type {
		if !binaryExpression.symbol {
			return getTypeOfExpression(binaryExpression.left)
		}
		if binaryExpression.symbol.valueDeclaration {
			annotated := getEffectiveTypeAnnotationNode(binaryExpression.symbol.valueDeclaration)
			if annotated {
				type_ := getTypeFromTypeNode(annotated)
				if type_ {
					return type_
				}
			}
		}
		thisAccess := cast(binaryExpression.left, isAccessExpression)
		if !isObjectLiteralMethod(getThisContainer(thisAccess.expression /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)) {
			return nil
		}
		thisType := checkThisExpression(thisAccess.expression)
		nameStr := getElementOrPropertyAccessName(thisAccess)
		return nameStr != nil && getTypeOfPropertyOfContextualType(thisType, nameStr) || nil
	}
	isCircularMappedProperty := func(symbol Symbol) bool {
		return !!(getCheckFlags(symbol)&CheckFlagsMapped && !(symbol /* as MappedSymbol */).links.type_ && findResolutionCycleStartIndex(symbol, TypeSystemPropertyNameType) >= 0)
	}
	isExcludedMappedPropertyName := func(constraint Type, propertyNameType Type) bool {
		if constraint.flags & TypeFlagsConditional {
			type_ := constraint /* as ConditionalType */
			return !!(getReducedType(getTrueTypeFromConditionalType(type_)).flags & TypeFlagsNever) && getActualTypeVariable(getFalseTypeFromConditionalType(type_)) == getActualTypeVariable(type_.checkType) && isTypeAssignableTo(propertyNameType, type_.extendsType)
		}
		if constraint.flags & TypeFlagsIntersection {
			return some((constraint /* as IntersectionType */).types, func(t Type) bool {
				return isExcludedMappedPropertyName(t, propertyNameType)
			})
		}
		return false
	}
	getTypeOfPropertyOfContextualType := func(type_ Type, name __String, nameType Type) Type {
		return mapType(type_, func(t Type) Type {
			if t.flags & TypeFlagsIntersection {
				var types *[]Type
				var indexInfoCandidates *[]Type
				ignoreIndexInfos := false
				for _, constituentType := range (t /* as IntersectionType */).types {
					if !(constituentType.flags & TypeFlagsObject) {
						continue
					}
					if isGenericMappedType(constituentType) && getMappedTypeNameTypeKind(constituentType) != MappedTypeNameTypeKindRemapping {
						substitutedType := getIndexedMappedTypeSubstitutedTypeOfContextualType(constituentType, name, nameType)
						types = appendContextualPropertyTypeConstituent(types, substitutedType)
						continue
					}
					propertyType := getTypeOfConcretePropertyOfContextualType(constituentType, name)
					if !propertyType {
						if !ignoreIndexInfos {
							indexInfoCandidates = append(indexInfoCandidates, constituentType)
						}
						continue
					}
					ignoreIndexInfos = true
					indexInfoCandidates = nil
					types = appendContextualPropertyTypeConstituent(types, propertyType)
				}
				if indexInfoCandidates {
					for _, candidate := range indexInfoCandidates {
						indexInfoType := getTypeFromIndexInfosOfContextualType(candidate, name, nameType)
						types = appendContextualPropertyTypeConstituent(types, indexInfoType)
					}
				}
				if !types {
					return
				}
				if types.length == 1 {
					return types[0]
				}
				return getIntersectionType(types)
			}
			if !(t.flags & TypeFlagsObject) {
				return
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isGenericMappedType(t) && getMappedTypeNameTypeKind(t) != MappedTypeNameTypeKindRemapping:
				return getIndexedMappedTypeSubstitutedTypeOfContextualType(t, name, nameType)
			default:
				return /* TODO(TS-TO-GO) Node BinaryExpression: getTypeOfConcretePropertyOfContextualType(t, name) ?? getTypeFromIndexInfosOfContextualType(t, name, nameType) */ TODO
			}
		}, /*noReductions*/ true)
	}
	appendContextualPropertyTypeConstituent := func(types *[]Type, type_ Type) *[]Type {
		// any doesn't provide any contextual information but could spoil the overall result by nullifying contextual information provided by other intersection constituents
		// so it gets replaced with `unknown` as `T & unknown` is just `T` and all types computed based on the contextual information provided by other constituens are still assignable to any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_:
			return append(types, __COND__(type_.flags&TypeFlagsAny, unknownType, type_))
		default:
			return types
		}
	}
	getIndexedMappedTypeSubstitutedTypeOfContextualType := func(type_ MappedType, name __String, nameType Type) Type {
		propertyNameType := nameType || getStringLiteralType(unescapeLeadingUnderscores(name))
		constraint := getConstraintTypeFromMappedType(type_)
		// special case for conditional types pretending to be negated types
		if type_.nameType && isExcludedMappedPropertyName(type_.nameType, propertyNameType) || isExcludedMappedPropertyName(constraint, propertyNameType) {
			return
		}
		constraintOfConstraint := getBaseConstraintOfType(constraint) || constraint
		if !isTypeAssignableTo(propertyNameType, constraintOfConstraint) {
			return
		}
		return substituteIndexedMappedType(type_, propertyNameType)
	}
	getTypeOfConcretePropertyOfContextualType := func(type_ Type, name __String) Type {
		prop := getPropertyOfType(type_, name)
		if !prop || isCircularMappedProperty(prop) {
			return
		}
		return removeMissingType(getTypeOfSymbol(prop), !!(prop.flags & SymbolFlagsOptional))
	}
	getTypeFromIndexInfosOfContextualType := func(type_ Type, name __String, nameType Type) Type {
		if isTupleType(type_) && isNumericLiteralName(name) && +name >= 0 {
			restType := getElementTypeOfSliceOfTupleType(type_, type_.target.fixedLength /*endSkipCount*/, 0 /*writing*/, false /*noReductions*/, true)
			if restType {
				return restType
			}
		}
		return findApplicableIndexInfo(getIndexInfosOfStructuredType(type_), nameType || getStringLiteralType(unescapeLeadingUnderscores(name))). /* TODO(TS-TO-GO): was ? */ type_
	}
	// In an object literal contextually typed by a type T, the contextual type of a property assignment is the type of
	// the matching property in T, if one exists. Otherwise, it is the type of the numeric index signature in T, if one
	// exists. Otherwise, it is the type of the string index signature in T, if one exists.
	getContextualTypeForObjectLiteralMethod := func(node MethodDeclaration, contextFlags *ContextFlags) Type {
		Debug.assert(isObjectLiteralMethod(node))
		if node.flags & NodeFlagsInWithStatement {
			// We cannot answer semantic questions within a with block, do not proceed any further
			return nil
		}
		return getContextualTypeForObjectLiteralElement(node, contextFlags)
	}
	getContextualTypeForObjectLiteralElement := func(element ObjectLiteralElementLike, contextFlags *ContextFlags) Type {
		objectLiteral := element.parent /* as ObjectLiteralExpression */
		propertyAssignmentType := isPropertyAssignment(element) && getContextualTypeForVariableLikeDeclaration(element, contextFlags)
		if propertyAssignmentType {
			return propertyAssignmentType
		}
		type_ := getApparentTypeOfContextualType(objectLiteral, contextFlags)
		if type_ {
			if hasBindableName(element) {
				// For a (non-symbol) computed property, there is no reason to look up the name
				// in the type. It will just be "__computed", which does not appear in any
				// SymbolTable.
				symbol := getSymbolOfDeclaration(element)
				return getTypeOfPropertyOfContextualType(type_, symbol.escapedName, getSymbolLinks(symbol).nameType)
			}
			if hasDynamicName(element) {
				name := getNameOfDeclaration(element)
				if name && isComputedPropertyName(name) {
					exprType := checkExpression(name.expression)
					propType := isTypeUsableAsPropertyName(exprType) && getTypeOfPropertyOfContextualType(type_, getPropertyNameFromType(exprType))
					if propType {
						return propType
					}
				}
			}
			if element.name {
				nameType := getLiteralTypeFromPropertyName(element.name)
				// We avoid calling getApplicableIndexInfo here because it performs potentially expensive intersection reduction.
				return mapType(type_, func(t Type) Type {
					return findApplicableIndexInfo(getIndexInfosOfStructuredType(t), nameType). /* TODO(TS-TO-GO): was ? */ type_
				}, /*noReductions*/ true)
			}
		}
		return nil
	}
	getSpreadIndices := func(elements []Node) /* TODO(TS-TO-GO) inferred type { first: number | undefined; last: number | undefined; } */ any {
		var first TODO
		var last TODO
		for i := 0; i < elements.length; i++ {
			if isSpreadElement(elements[i]) {
				/* TODO(TS-TO-GO) Node BinaryExpression: first ??= i */ TODO
				last = i
			}
		}
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"first": first,
			"last":  last,
		}
	}
	getContextualTypeForElementExpression := func(type_ Type, index number, length number, firstSpreadIndex number, lastSpreadIndex number) Type {
		return type_ && mapType(type_, func(t Type) Type {
			if isTupleType(t) {
				// If index is before any spread element and within the fixed part of the contextual tuple type, return
				// the type of the contextual tuple element.
				if (firstSpreadIndex == nil || index < firstSpreadIndex) && index < t.target.fixedLength {
					return removeMissingType(getTypeArguments(t)[index], !!(t.target.elementFlags[index] && ElementFlagsOptional))
				}
				// When the length is known and the index is after all spread elements we compute the offset from the element
				// to the end and the number of ending fixed elements in the contextual tuple type.
				var offset number
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case length != nil && (lastSpreadIndex == nil || index > lastSpreadIndex):
					offset = length - index
				default:
					offset = 0
				}
				var fixedEndLength number
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case offset > 0 && (t.target.combinedFlags & ElementFlagsVariable):
					fixedEndLength = getEndElementCount(t.target, ElementFlagsFixed)
				default:
					fixedEndLength = 0
				}
				// If the offset is within the ending fixed part of the contextual tuple type, return the type of the contextual
				// tuple element.
				if offset > 0 && offset <= fixedEndLength {
					return getTypeArguments(t)[getTypeReferenceArity(t)-offset]
				}
				// Return a union of the possible contextual element types with no subtype reduction.
				return getElementTypeOfSliceOfTupleType(t, __COND__(firstSpreadIndex == nil, t.target.fixedLength, Math.min(t.target.fixedLength, firstSpreadIndex)), __COND__(length == nil || lastSpreadIndex == nil, fixedEndLength, Math.min(fixedEndLength, length-lastSpreadIndex)) /*writing*/, false /*noReductions*/, true)
			}
			// If element index is known and a contextual property with that name exists, return it. Otherwise return the
			// iterated or element type of the contextual type.
			return (!firstSpreadIndex || index < firstSpreadIndex) && getTypeOfPropertyOfContextualType(t, ""+index /* as __String */) || getIteratedTypeOrElementType(IterationUseElement, t, undefinedType /*errorNode*/, nil /*checkAssignability*/, false)
		}, /*noReductions*/ true)
	}
	// In a contextually typed conditional expression, the true/false expressions are contextually typed by the same type.
	getContextualTypeForConditionalOperand := func(node Expression, contextFlags *ContextFlags) Type {
		conditional := node.parent /* as ConditionalExpression */
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node == conditional.whenTrue || node == conditional.whenFalse:
			return getContextualType(conditional, contextFlags)
		default:
			return nil
		}
	}
	getContextualTypeForChildJsxExpression := func(node JsxElement, child JsxChild, contextFlags *ContextFlags) Type {
		attributesType := getApparentTypeOfContextualType(node.openingElement.attributes, contextFlags)
		// JSX expression is in children of JSX Element, we will look for an "children" attribute (we get the name from JSX.ElementAttributesProperty)
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
		if !(attributesType && !isTypeAny(attributesType) && jsxChildrenPropertyName && jsxChildrenPropertyName != "") {
			return nil
		}
		realChildren := getSemanticJsxChildren(node.children)
		childIndex := realChildren.indexOf(child)
		childFieldType := getTypeOfPropertyOfContextualType(attributesType, jsxChildrenPropertyName)
		return childFieldType && (__COND__(realChildren.length == 1, childFieldType, mapType(childFieldType, func(t Type) Type {
			if isArrayLikeType(t) {
				return getIndexedAccessType(t, getNumberLiteralType(childIndex))
			} else {
				return t
			}
		}, /*noReductions*/ true)))
	}
	getContextualTypeForJsxExpression := func(node JsxExpression, contextFlags *ContextFlags) Type {
		exprParent := node.parent
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isJsxAttributeLike(exprParent):
			return getContextualType(node, contextFlags)
		case isJsxElement(exprParent):
			return getContextualTypeForChildJsxExpression(exprParent, node, contextFlags)
		default:
			return nil
		}
	}
	getContextualTypeForJsxAttribute := func(attribute /* TODO(TS-TO-GO) TypeNode UnionType: JsxAttribute | JsxSpreadAttribute */ any, contextFlags *ContextFlags) Type {
		// When we trying to resolve JsxOpeningLikeElement as a stateless function element, we will already give its attributes a contextual type
		// which is a type of the parameter of the signature we are trying out.
		// If there is no contextual type (e.g. we are trying to resolve stateful component), get attributes type from resolving element's tagName
		if isJsxAttribute(attribute) {
			attributesType := getApparentTypeOfContextualType(attribute.parent, contextFlags)
			if !attributesType || isTypeAny(attributesType) {
				return nil
			}
			return getTypeOfPropertyOfContextualType(attributesType, getEscapedTextOfJsxAttributeName(attribute.name))
		} else {
			return getContextualType(attribute.parent, contextFlags)
		}
	}
	// Return true if the given expression is possibly a discriminant value. We limit the kinds of
	// expressions we check to those that don't depend on their contextual type in order not to cause
	// recursive (and possibly infinite) invocations of getContextualType.
	isPossiblyDiscriminantValue := func(node Expression) bool {
		switch node.kind {
		case SyntaxKindStringLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNumericLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBigIntLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTemplateExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTrueKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFalseKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNullKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindIdentifier:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindUndefinedKeyword:
			return true
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindParenthesizedExpression:
			return isPossiblyDiscriminantValue((node /* as PropertyAccessExpression | ParenthesizedExpression */).expression)
		case SyntaxKindJsxExpression:
			return !(node /* as JsxExpression */).expression || isPossiblyDiscriminantValue((node /* as JsxExpression */).expression)
		}
		return false
	}
	discriminateContextualTypeByObjectMembers := func(node ObjectLiteralExpression, contextualType UnionType) Type {
		key := __TEMPLATE__("D", getNodeId(node), ",", getTypeId(contextualType))
		return /* TODO(TS-TO-GO) Node BinaryExpression: getCachedType(key) ?? setCachedType( key, getMatchingUnionConstituentForObjectLiteral(contextualType, node) ?? discriminateTypeByDiscriminableItems( contextualType, concatenate( map( filter(node.properties, (p): p is PropertyAssignment | ShorthandPropertyAssignment => { if (!p.symbol) { return false; } if (p.kind === SyntaxKind.PropertyAssignment) { return isPossiblyDiscriminantValue(p.initializer) && isDiscriminantProperty(contextualType, p.symbol.escapedName); } if (p.kind === SyntaxKind.ShorthandPropertyAssignment) { return isDiscriminantProperty(contextualType, p.symbol.escapedName); } return false; }), prop => ([() => getContextFreeTypeOfExpression(prop.kind === SyntaxKind.PropertyAssignment ? prop.initializer : prop.name), prop.symbol.escapedName] as const), ), map( filter(getPropertiesOfType(contextualType), s => !!(s.flags & SymbolFlags.Optional) && !!node?.symbol?.members && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)), s => [() => undefinedType, s.escapedName] as const, ), ), isTypeAssignableTo, ), ) */ TODO
	}
	discriminateContextualTypeByJSXAttributes := func(node JsxAttributes, contextualType UnionType) Type {
		key := __TEMPLATE__("D", getNodeId(node), ",", getTypeId(contextualType))
		cached := getCachedType(key)
		if cached {
			return cached
		}
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
		return setCachedType(key, discriminateTypeByDiscriminableItems(contextualType, concatenate(map_(filter(node.properties, func(p /* TODO(TS-TO-GO) inferred type JsxAttribute | JsxSpreadAttribute */ any) bool {
			return !!p.symbol && p.kind == SyntaxKindJsxAttribute && isDiscriminantProperty(contextualType, p.symbol.escapedName) && (!p.initializer || isPossiblyDiscriminantValue(p.initializer))
		}), func(prop /* TODO(TS-TO-GO) inferred type JsxAttribute | JsxSpreadAttribute */ any) /* TODO(TS-TO-GO) inferred type [() => Type, __String] */ any {
			return ([]any{__COND__(!(prop /* as JsxAttribute */).initializer, (func() FreshableIntrinsicType {
				return trueType
			}), (func() Type {
				return getContextFreeTypeOfExpression((prop /* as JsxAttribute */).initializer)
			})), prop.symbol.escapedName} /* as const */)
		}), map_(filter(getPropertiesOfType(contextualType), func(s Symbol) bool {
			if !(s.flags & SymbolFlagsOptional) || !node. /* TODO(TS-TO-GO): was ? */ symbol. /* TODO(TS-TO-GO): was ? */ members {
				return false
			}
			element := node.parent.parent
			if s.escapedName == jsxChildrenPropertyName && isJsxElement(element) && getSemanticJsxChildren(element.children).length {
				return false
			}
			return !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)
		}), func(s Symbol) /* TODO(TS-TO-GO) inferred type [() => IntrinsicType, __String] */ any {
			return []any{func() IntrinsicType {
				return undefinedType
			}, s.escapedName} /* as const */
		})), isTypeAssignableTo))
	}
	// Return the contextual type for a given expression node. During overload resolution, a contextual type may temporarily
	// be "pushed" onto a node using the contextualType property.
	getApparentTypeOfContextualType := func(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | MethodDeclaration */ any, contextFlags *ContextFlags) Type {
		var contextualType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isObjectLiteralMethod(node):
			contextualType = getContextualTypeForObjectLiteralMethod(node, contextFlags)
		default:
			contextualType = getContextualType(node, contextFlags)
		}
		instantiatedType := instantiateContextualType(contextualType, node, contextFlags)
		if instantiatedType && !(contextFlags && contextFlags&ContextFlagsNoConstraints && instantiatedType.flags&TypeFlagsTypeVariable) {
			apparentType := mapType(instantiatedType, func(t Type) Type {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case getObjectFlags(t) & ObjectFlagsMapped:
					return t
				default:
					return getApparentType(t)
				}
			}, true)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case apparentType.flags&TypeFlagsUnion && isObjectLiteralExpression(node):
				return discriminateContextualTypeByObjectMembers(node, apparentType /* as UnionType */)
			case apparentType.flags&TypeFlagsUnion && isJsxAttributes(node):
				return discriminateContextualTypeByJSXAttributes(node, apparentType /* as UnionType */)
			default:
				return apparentType
			}
		}
	}
	// If the given contextual type contains instantiable types and if a mapper representing
	// return type inferences is available, instantiate those types using that mapper.
	instantiateContextualType := func(contextualType Type, node Node, contextFlags *ContextFlags) Type {
		if contextualType && maybeTypeOfKind(contextualType, TypeFlagsInstantiable) {
			inferenceContext := getInferenceContext(node)
			// If no inferences have been made, and none of the type parameters for which we are inferring
			// specify default types, nothing is gained from instantiating as type parameters would just be
			// replaced with their constraints similar to the apparent type.
			if inferenceContext && contextFlags&ContextFlagsSignature && some(inferenceContext.inferences, hasInferenceCandidatesOrDefault) {
				// For contextual signatures we incorporate all inferences made so far, e.g. from return
				// types as well as arguments to the left in a function call.
				return instantiateInstantiableTypes(contextualType, inferenceContext.nonFixingMapper)
			}
			if inferenceContext. /* TODO(TS-TO-GO): was ? */ returnMapper {
				// For other purposes (e.g. determining whether to produce literal types) we only
				// incorporate inferences made from the return type in a function call. We remove
				// the 'boolean' type from the contextual type such that contextually typed boolean
				// literals actually end up widening to 'boolean' (see #48363).
				type_ := instantiateInstantiableTypes(contextualType, inferenceContext.returnMapper)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case type_.flags&TypeFlagsUnion && containsType((type_ /* as UnionType */).types, regularFalseType) && containsType((type_ /* as UnionType */).types, regularTrueType):
					return filterType(type_, func(t Type) bool {
						return t != regularFalseType && t != regularTrueType
					})
				default:
					return type_
				}
			}
		}
		return contextualType
	}
	// This function is similar to instantiateType, except that (a) it only instantiates types that
	// are classified as instantiable (i.e. it doesn't instantiate object types), and (b) it performs
	// no reductions on instantiated union types.
	instantiateInstantiableTypes := func(type_ Type, mapper TypeMapper) Type {
		if type_.flags & TypeFlagsInstantiable {
			return instantiateType(type_, mapper)
		}
		if type_.flags & TypeFlagsUnion {
			return getUnionType(map_((type_ /* as UnionType */).types, func(t Type) Type {
				return instantiateInstantiableTypes(t, mapper)
			}), UnionReductionNone)
		}
		if type_.flags & TypeFlagsIntersection {
			return getIntersectionType(map_((type_ /* as IntersectionType */).types, func(t Type) Type {
				return instantiateInstantiableTypes(t, mapper)
			}))
		}
		return type_
	}
	/**
	 * Whoa! Do you really want to use this function?
	 *
	 * Unless you're trying to get the *non-apparent* type for a
	 * value-literal type or you're authoring relevant portions of this algorithm,
	 * you probably meant to use 'getApparentTypeOfContextualType'.
	 * Otherwise this may not be very useful.
	 *
	 * In cases where you *are* working on this function, you should understand
	 * when it is appropriate to use 'getContextualType' and 'getApparentTypeOfContextualType'.
	 *
	 *   - Use 'getContextualType' when you are simply going to propagate the result to the expression.
	 *   - Use 'getApparentTypeOfContextualType' when you're going to need the members of the type.
	 *
	 * @param node the expression whose contextual type will be returned.
	 * @returns the contextual type of an expression.
	 */
	getContextualType := func(node Expression, contextFlags *ContextFlags) Type {
		if node.flags & NodeFlagsInWithStatement {
			// We cannot answer semantic questions within a with block, do not proceed any further
			return nil
		}
		// Cached contextual types are obtained with no ContextFlags, so we can only consult them for
		// requests with no ContextFlags.
		index := findContextualNode(node /*includeCaches*/, !contextFlags)
		if index >= 0 {
			return contextualTypes[index]
		}
		TODO_IDENTIFIER := node
		switch parent.kind {
		case SyntaxKindVariableDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindParameter:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertyDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertySignature:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBindingElement:
			return getContextualTypeForInitializerExpression(node, contextFlags)
		case SyntaxKindArrowFunction:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindReturnStatement:
			return getContextualTypeForReturnExpression(node, contextFlags)
		case SyntaxKindYieldExpression:
			return getContextualTypeForYieldOperand(parent /* as YieldExpression */, contextFlags)
		case SyntaxKindAwaitExpression:
			return getContextualTypeForAwaitOperand(parent /* as AwaitExpression */, contextFlags)
		case SyntaxKindCallExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNewExpression:
			return getContextualTypeForArgument(parent /* as CallExpression | NewExpression | Decorator */, node)
		case SyntaxKindDecorator:
			return getContextualTypeForDecorator(parent /* as Decorator */)
		case SyntaxKindTypeAssertionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindAsExpression:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isConstTypeReference((parent /* as AssertionExpression */).type_):
				return getContextualType(parent /* as AssertionExpression */, contextFlags)
			default:
				return getTypeFromTypeNode((parent /* as AssertionExpression */).type_)
			}
		case SyntaxKindBinaryExpression:
			return getContextualTypeForBinaryOperand(node, contextFlags)
		case SyntaxKindPropertyAssignment:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindShorthandPropertyAssignment:
			return getContextualTypeForObjectLiteralElement(parent /* as PropertyAssignment | ShorthandPropertyAssignment */, contextFlags)
		case SyntaxKindSpreadAssignment:
			return getContextualType(parent.parent /* as ObjectLiteralExpression */, contextFlags)
		case SyntaxKindArrayLiteralExpression:
			arrayLiteral := parent /* as ArrayLiteralExpression */
			type_ := getApparentTypeOfContextualType(arrayLiteral, contextFlags)
			elementIndex := indexOfNode(arrayLiteral.elements, node)
			spreadIndices := /* TODO(TS-TO-GO) Node BinaryExpression: getNodeLinks(arrayLiteral).spreadIndices ??= getSpreadIndices(arrayLiteral.elements) */ TODO
			return getContextualTypeForElementExpression(type_, elementIndex, arrayLiteral.elements.length, spreadIndices.first, spreadIndices.last)
			fallthrough
		case SyntaxKindConditionalExpression:
			return getContextualTypeForConditionalOperand(node, contextFlags)
		case SyntaxKindTemplateSpan:
			Debug.assert(parent.parent.kind == SyntaxKindTemplateExpression)
			return getContextualTypeForSubstitutionExpression(parent.parent /* as TemplateExpression */, node)
		case SyntaxKindParenthesizedExpression:
			if isInJSFile(parent) {
				if isJSDocSatisfiesExpression(parent) {
					return getTypeFromTypeNode(getJSDocSatisfiesExpressionType(parent))
				}
				// Like in `checkParenthesizedExpression`, an `/** @type {xyz} */` comment before a parenthesized expression acts as a type cast.
				typeTag := getJSDocTypeTag(parent)
				if typeTag && !isConstTypeReference(typeTag.typeExpression.type_) {
					return getTypeFromTypeNode(typeTag.typeExpression.type_)
				}
			}
			return getContextualType(parent /* as ParenthesizedExpression */, contextFlags)
			fallthrough
		case SyntaxKindNonNullExpression:
			return getContextualType(parent /* as NonNullExpression */, contextFlags)
		case SyntaxKindSatisfiesExpression:
			return getTypeFromTypeNode((parent /* as SatisfiesExpression */).type_)
		case SyntaxKindExportAssignment:
			return tryGetTypeFromEffectiveTypeNode(parent /* as ExportAssignment */)
		case SyntaxKindJsxExpression:
			return getContextualTypeForJsxExpression(parent /* as JsxExpression */, contextFlags)
		case SyntaxKindJsxAttribute:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJsxSpreadAttribute:
			return getContextualTypeForJsxAttribute(parent /* as JsxAttribute | JsxSpreadAttribute */, contextFlags)
		case SyntaxKindJsxOpeningElement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJsxSelfClosingElement:
			return getContextualJsxElementAttributesType(parent /* as JsxOpeningLikeElement */, contextFlags)
		case SyntaxKindImportAttribute:
			return getContextualImportAttributeType(parent /* as ImportAttribute */)
		}
		return nil
	}
	pushCachedContextualType := func(node Expression) {
		pushContextualType(node, getContextualType(node /*contextFlags*/, nil) /*isCache*/, true)
	}
	pushContextualType := func(node Expression, type_ Type, isCache bool) {
		contextualTypeNodes[contextualTypeCount] = node
		contextualTypes[contextualTypeCount] = type_
		contextualIsCache[contextualTypeCount] = isCache
		contextualTypeCount++
	}
	popContextualType := func() {
		contextualTypeCount--
	}
	findContextualNode := func(node Node, includeCaches bool) number {
		for i := contextualTypeCount - 1; i >= 0; i-- {
			if node == contextualTypeNodes[i] && (includeCaches || !contextualIsCache[i]) {
				return i
			}
		}
		return -1
	}
	pushInferenceContext := func(node Node, inferenceContext *InferenceContext) {
		inferenceContextNodes[inferenceContextCount] = node
		inferenceContexts[inferenceContextCount] = inferenceContext
		inferenceContextCount++
	}
	popInferenceContext := func() {
		inferenceContextCount--
	}
	getInferenceContext := func(node Node) *InferenceContext {
		for i := inferenceContextCount - 1; i >= 0; i-- {
			if isNodeDescendantOf(node, inferenceContextNodes[i]) {
				return inferenceContexts[i]
			}
		}
	}
	getContextualImportAttributeType := func(node ImportAttribute) Type {
		return getTypeOfPropertyOfContextualType(getGlobalImportAttributesType(false), getNameFromImportAttribute(node))
	}
	getContextualJsxElementAttributesType := func(node JsxOpeningLikeElement, contextFlags *ContextFlags) Type {
		if isJsxOpeningElement(node) && contextFlags != ContextFlagsCompletions {
			index := findContextualNode(node.parent /*includeCaches*/, !contextFlags)
			if index >= 0 {
				// Contextually applied type is moved from attributes up to the outer jsx attributes so when walking up from the children they get hit
				// _However_ to hit them from the _attributes_ we must look for them here; otherwise we'll used the declared type
				// (as below) instead!
				return contextualTypes[index]
			}
		}
		return getContextualTypeForArgumentAtIndex(node, 0)
	}
	getEffectiveFirstArgumentForJsxSignature := func(signature Signature, node JsxOpeningLikeElement) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getJsxReferenceKind(node) != JsxReferenceKindComponent:
			return getJsxPropsTypeFromCallSignature(signature, node)
		default:
			return getJsxPropsTypeFromClassType(signature, node)
		}
	}
	getJsxPropsTypeFromCallSignature := func(sig Signature, context JsxOpeningLikeElement) Type {
		propsType := getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)
		propsType = getJsxManagedAttributesFromLocatedAttributes(context, getJsxNamespaceAt(context), propsType)
		intrinsicAttribs := getJsxType(JsxNames.IntrinsicAttributes, context)
		if !isErrorType(intrinsicAttribs) {
			propsType = intersectTypes(intrinsicAttribs, propsType)
		}
		return propsType
	}
	getJsxPropsTypeForSignatureFromMember := func(sig Signature, forcedLookupLocation __String) Type {
		if sig.compositeSignatures {
			// JSX Elements using the legacy `props`-field based lookup (eg, react class components) need to treat the `props` member as an input
			// instead of an output position when resolving the signature. We need to go back to the input signatures of the composite signature,
			// get the type of `props` on each return type individually, and then _intersect them_, rather than union them (as would normally occur
			// for a union signature). It's an unfortunate quirk of looking in the output of the signature for the type we want to use for the input.
			// The default behavior of `getTypeOfFirstParameterOfSignatureWithFallback` when no `props` member name is defined is much more sane.
			var results []Type = []never{}
			for _, signature := range sig.compositeSignatures {
				instance := getReturnTypeOfSignature(signature)
				if isTypeAny(instance) {
					return instance
				}
				propType := getTypeOfPropertyOfType(instance, forcedLookupLocation)
				if !propType {
					return
				}
				results.push(propType)
			}
			return getIntersectionType(results)
			// Same result for both union and intersection signatures
		}
		instanceType := getReturnTypeOfSignature(sig)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isTypeAny(instanceType):
			return instanceType
		default:
			return getTypeOfPropertyOfType(instanceType, forcedLookupLocation)
		}
	}
	getStaticTypeOfReferencedJsxConstructor := func(context JsxOpeningLikeElement) Type {
		if isJsxIntrinsicTagName(context.tagName) {
			result := getIntrinsicAttributesTypeFromJsxOpeningLikeElement(context)
			fakeSignature := createSignatureForJSXIntrinsic(context, result)
			return getOrCreateTypeFromSignature(fakeSignature)
		}
		tagType := checkExpressionCached(context.tagName)
		if tagType.flags & TypeFlagsStringLiteral {
			result := getIntrinsicAttributesTypeFromStringLiteralType(tagType /* as StringLiteralType */, context)
			if !result {
				return errorType
			}
			fakeSignature := createSignatureForJSXIntrinsic(context, result)
			return getOrCreateTypeFromSignature(fakeSignature)
		}
		return tagType
	}
	getJsxManagedAttributesFromLocatedAttributes := func(context JsxOpeningLikeElement, ns Symbol, attributesType Type) Type {
		managedSym := getJsxLibraryManagedAttributes(ns)
		if managedSym {
			ctorType := getStaticTypeOfReferencedJsxConstructor(context)
			result := instantiateAliasOrInterfaceWithDefaults(managedSym, isInJSFile(context), ctorType, attributesType)
			if result {
				return result
			}
		}
		return attributesType
	}
	getJsxPropsTypeFromClassType := func(sig Signature, context JsxOpeningLikeElement) Type {
		ns := getJsxNamespaceAt(context)
		forcedLookupLocation := getJsxElementPropertiesName(ns)
		var attributesType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case forcedLookupLocation == nil:
			attributesType = getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)
		case forcedLookupLocation == "":
			attributesType = getReturnTypeOfSignature(sig)
		default:
			attributesType = getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation)
		}
		if !attributesType {
			// There is no property named 'props' on this instance type
			if !!forcedLookupLocation && !!length(context.attributes.properties) {
				error(context, Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property, unescapeLeadingUnderscores(forcedLookupLocation))
			}
			return unknownType
		}
		attributesType = getJsxManagedAttributesFromLocatedAttributes(context, ns, attributesType)
		if isTypeAny(attributesType) {
			// Props is of type 'any' or unknown
			return attributesType
		} else {
			// Normal case -- add in IntrinsicClassElements<T> and IntrinsicElements
			apparentAttributesType := attributesType
			intrinsicClassAttribs := getJsxType(JsxNames.IntrinsicClassAttributes, context)
			if !isErrorType(intrinsicClassAttribs) {
				typeParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(intrinsicClassAttribs.symbol)
				hostClassType := getReturnTypeOfSignature(sig)
				var libraryManagedAttributeType Type
				if typeParams {
					// apply JSX.IntrinsicClassElements<hostClassType, ...>
					inferredArgs := fillMissingTypeArguments([]Type{hostClassType}, typeParams, getMinTypeArgumentCount(typeParams), isInJSFile(context))
					libraryManagedAttributeType = instantiateType(intrinsicClassAttribs, createTypeMapper(typeParams, inferredArgs))
				} else {
					libraryManagedAttributeType = intrinsicClassAttribs
				}
				apparentAttributesType = intersectTypes(libraryManagedAttributeType, apparentAttributesType)
			}
			intrinsicAttribs := getJsxType(JsxNames.IntrinsicAttributes, context)
			if !isErrorType(intrinsicAttribs) {
				apparentAttributesType = intersectTypes(intrinsicAttribs, apparentAttributesType)
			}
			return apparentAttributesType
		}
	}
	getIntersectedSignatures := func(signatures []Signature) *Signature {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getStrictOptionValue(compilerOptions, "noImplicitAny"):
			return reduceLeft(signatures, func(left *Signature, right *Signature) *Signature {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case left == right || !left:
					return left
				case compareTypeParametersIdentical(left.typeParameters, right.typeParameters):
					return combineSignaturesOfIntersectionMembers(left, right)
				default:
					return nil
				}
			})
		default:
			return nil
		}
	}
	combineIntersectionThisParam := func(left Symbol, right Symbol, mapper *TypeMapper) Symbol {
		if !left || !right {
			return left || right
		}
		// A signature `this` type might be a read or a write position... It's very possible that it should be invariant
		// and we should refuse to merge signatures if there are `this` types and they do not match. However, so as to be
		// pessimistic when contextual typing, for now, we'll union the `this` types.
		thisType := getUnionType([]Type{getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)})
		return createSymbolWithType(left, thisType)
	}
	combineIntersectionParameters := func(left Signature, right Signature, mapper *TypeMapper) []Symbol {
		leftCount := getParameterCount(left)
		rightCount := getParameterCount(right)
		var longest Signature
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case leftCount >= rightCount:
			longest = left
		default:
			longest = right
		}
		var shorter Signature
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case longest == left:
			shorter = right
		default:
			shorter = left
		}
		var longestCount number
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case longest == left:
			longestCount = leftCount
		default:
			longestCount = rightCount
		}
		eitherHasEffectiveRest := hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right)
		needsExtraRestElement := eitherHasEffectiveRest && !hasEffectiveRestParameter(longest)
		params := NewArray[Symbol](longestCount + (__COND__(needsExtraRestElement, 1, 0)))
		for i := 0; i < longestCount; i++ {
			longestParamType := tryGetTypeAtPosition(longest, i)
			if longest == right {
				longestParamType = instantiateType(longestParamType, mapper)
			}
			shorterParamType := tryGetTypeAtPosition(shorter, i) || unknownType
			if shorter == right {
				shorterParamType = instantiateType(shorterParamType, mapper)
			}
			unionParamType := getUnionType([]Type{longestParamType, shorterParamType})
			isRestParam := eitherHasEffectiveRest && !needsExtraRestElement && i == (longestCount-1)
			isOptional := i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter)
			var leftName *__String
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case i >= leftCount:
				leftName = nil
			default:
				leftName = getParameterNameAtPosition(left, i)
			}
			var rightName *__String
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case i >= rightCount:
				rightName = nil
			default:
				rightName = getParameterNameAtPosition(right, i)
			}
			var paramName *__String
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case leftName == rightName:
				paramName = leftName
			case !leftName:
				paramName = rightName
			case !rightName:
				paramName = leftName
			default:
				paramName = nil
			}
			paramSymbol := createSymbol(SymbolFlagsFunctionScopedVariable|(__COND__(isOptional && !isRestParam, SymbolFlagsOptional, 0)), paramName || __TEMPLATE__("arg", i) /* as __String */)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isRestParam:
				paramSymbol.links.type_ = createArrayType(unionParamType)
			default:
				paramSymbol.links.type_ = unionParamType
			}
			params[i] = paramSymbol
		}
		if needsExtraRestElement {
			restParamSymbol := createSymbol(SymbolFlagsFunctionScopedVariable, "args" /* as __String */)
			restParamSymbol.links.type_ = createArrayType(getTypeAtPosition(shorter, longestCount))
			if shorter == right {
				restParamSymbol.links.type_ = instantiateType(restParamSymbol.links.type_, mapper)
			}
			params[longestCount] = restParamSymbol
		}
		return params
	}
	combineSignaturesOfIntersectionMembers := func(left Signature, right Signature) Signature {
		typeParams := left.typeParameters || right.typeParameters
		var paramMapper *TypeMapper
		if left.typeParameters && right.typeParameters {
			paramMapper = createTypeMapper(right.typeParameters, left.typeParameters)
			// We just use the type parameter defaults from the first signature
		}
		declaration := left.declaration
		params := combineIntersectionParameters(left, right, paramMapper)
		thisParam := combineIntersectionThisParam(left.thisParameter, right.thisParameter, paramMapper)
		minArgCount := Math.max(left.minArgumentCount, right.minArgumentCount)
		result := createSignature(declaration, typeParams, thisParam, params, nil, nil, minArgCount, (left.flags|right.flags)&SignatureFlagsPropagatingFlags)
		result.compositeKind = TypeFlagsIntersection
		result.compositeSignatures = concatenate(left.compositeKind == TypeFlagsIntersection && left.compositeSignatures || []Signature{left}, []Signature{right})
		if paramMapper {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case left.compositeKind == TypeFlagsIntersection && left.mapper && left.compositeSignatures:
				result.mapper = combineTypeMappers(left.mapper, paramMapper)
			default:
				result.mapper = paramMapper
			}
		}
		return result
	}
	// If the given type is an object or union type with a single signature, and if that signature has at
	// least as many parameters as the given function, return the signature. Otherwise return undefined.
	getContextualCallSignature := func(type_ Type, node SignatureDeclaration) *Signature {
		signatures := getSignaturesOfType(type_, SignatureKindCall)
		applicableByArity := filter(signatures, func(s Signature) bool {
			return !isAritySmaller(s, node)
		})
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case applicableByArity.length == 1:
			return applicableByArity[0]
		default:
			return getIntersectedSignatures(applicableByArity)
		}
	}
	/** If the contextual signature has fewer parameters than the function expression, do not use it */
	isAritySmaller := func(signature Signature, target SignatureDeclaration) bool {
		targetParameterCount := 0
		for ; targetParameterCount < target.parameters.length; targetParameterCount++ {
			param := target.parameters[targetParameterCount]
			if param.initializer || param.questionToken || param.dotDotDotToken || isJSDocOptionalParameter(param) {
				break
			}
		}
		if target.parameters.length && parameterIsThisKeyword(target.parameters[0]) {
			targetParameterCount--
		}
		return !hasEffectiveRestParameter(signature) && getParameterCount(signature) < targetParameterCount
	}
	getContextualSignatureForFunctionLikeDeclaration := func(node FunctionLikeDeclaration) *Signature {
		// Only function expressions, arrow functions, and object literal methods are contextually typed.
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isFunctionExpressionOrArrowFunction(node) || isObjectLiteralMethod(node):
			return getContextualSignature(node /* as FunctionExpression */)
		default:
			return nil
		}
	}
	// Return the contextual signature for a given expression node. A contextual type provides a
	// contextual signature if it has a single call signature and if that call signature is non-generic.
	// If the contextual type is a union type, get the signature from each type possible and if they are
	// all identical ignoring their return type, the result is same signature but with return type as
	// union type of return types from these signatures
	getContextualSignature := func(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionExpression | ArrowFunction | MethodDeclaration */ any) *Signature {
		Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
		typeTagSignature := getSignatureOfTypeTag(node)
		if typeTagSignature {
			return typeTagSignature
		}
		type_ := getApparentTypeOfContextualType(node, ContextFlagsSignature)
		if !type_ {
			return nil
		}
		if !(type_.flags & TypeFlagsUnion) {
			return getContextualCallSignature(type_, node)
		}
		var signatureList *[]Signature
		types := (type_ /* as UnionType */).types
		for _, current := range types {
			signature := getContextualCallSignature(current, node)
			if signature {
				if !signatureList {
					// This signature will contribute to contextual union signature
					signatureList = []Signature{signature}
				} else if !compareSignaturesIdentical(signatureList[0], signature /*partialMatch*/, false /*ignoreThisTypes*/, true /*ignoreReturnTypes*/, true, compareTypesIdentical) {
					// Signatures aren't identical, do not use
					return nil
				} else {
					// Use this signature for contextual union signature
					signatureList.push(signature)
				}
			}
		}
		// Result is union of signatures collected (return type is union of return types of this signature set)
		if signatureList {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case signatureList.length == 1:
				return signatureList[0]
			default:
				return createUnionSignature(signatureList[0], signatureList)
			}
		}
	}
	checkGrammarRegularExpressionLiteral := func(node RegularExpressionLiteral) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) && !node.isUnterminated {
			var lastError *DiagnosticWithLocation
			/* TODO(TS-TO-GO) Node BinaryExpression: scanner ??= createScanner(ScriptTarget.ESNext, /*skipTrivia* / true) */ TODO
			scanner.setScriptTarget(sourceFile.languageVersion)
			scanner.setLanguageVariant(sourceFile.languageVariant)
			scanner.setOnError(func(message DiagnosticMessage, length number, arg0 any) {
				// For providing spelling suggestions
				start := scanner.getTokenEnd()
				if message.category == DiagnosticCategoryMessage && lastError && start == lastError.start && length == lastError.length {
					error := createDetachedDiagnostic(sourceFile.fileName, sourceFile.text, start, length, message, arg0)
					addRelatedInfo(lastError, error)
				} else if !lastError || start != lastError.start {
					lastError = createFileDiagnostic(sourceFile, start, length, message, arg0)
					diagnostics.add(lastError)
				}
			})
			scanner.setText(sourceFile.text, node.pos, node.end-node.pos)
			// TODO(TS-TO-GO): try
			{
				scanner.scan()
				Debug.assert(scanner.reScanSlashToken(true) == SyntaxKindRegularExpressionLiteral, "Expected scanner to rescan RegularExpressionLiteral")
				return !!lastError
			}
			/* TODO(TS-TO-GO) Node Block: { scanner.setText(""); scanner.setOnError(/*onError* / undefined); } */
			/* TODO(TS-TO-GO) Node TryStatement: try { scanner.scan(); Debug.assert(scanner.reScanSlashToken(/*reportErrors* / true) === SyntaxKind.RegularExpressionLiteral, "Expected scanner to rescan RegularExpressionLiteral"); return !!lastError; } finally { scanner.setText(""); scanner.setOnError(/*onError* / undefined); } */
		}
		return false
	}
	checkRegularExpressionLiteral := func(node RegularExpressionLiteral) ObjectType {
		nodeLinks := getNodeLinks(node)
		if !(nodeLinks.flags & NodeCheckFlagsTypeChecked) {
			nodeLinks.flags |= NodeCheckFlagsTypeChecked
			addLazyDiagnostic(func() bool {
				return checkGrammarRegularExpressionLiteral(node)
			})
		}
		return globalRegExpType
	}
	checkSpreadExpression := func(node SpreadElement, checkMode CheckMode) Type {
		if languageVersion < LanguageFeatureMinimumTargetSpreadElements {
			checkExternalEmitHelpers(node, __COND__(compilerOptions.downlevelIteration, ExternalEmitHelpersSpreadIncludes, ExternalEmitHelpersSpreadArray))
		}
		arrayOrIterableType := checkExpression(node.expression, checkMode)
		return checkIteratedTypeOrElementType(IterationUseSpread, arrayOrIterableType, undefinedType, node.expression)
	}
	checkSyntheticExpression := func(node SyntheticExpression) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.isSpread:
			return getIndexedAccessType(node.type_, numberType)
		default:
			return node.type_
		}
	}
	hasDefaultValue := func(node /* TODO(TS-TO-GO) TypeNode UnionType: BindingElement | ObjectLiteralElementLike | Expression */ any) bool {
		return node.kind == SyntaxKindBindingElement && !!(node /* as BindingElement */).initializer || node.kind == SyntaxKindPropertyAssignment && hasDefaultValue((node /* as PropertyAssignment */).initializer) || node.kind == SyntaxKindShorthandPropertyAssignment && !!(node /* as ShorthandPropertyAssignment */).objectAssignmentInitializer || node.kind == SyntaxKindBinaryExpression && (node /* as BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken
	}
	isSpreadIntoCallOrNew := func(node ArrayLiteralExpression) bool {
		parent := walkUpParenthesizedExpressions(node.parent)
		return isSpreadElement(parent) && isCallOrNewExpression(parent.parent)
	}
	checkArrayLiteral := func(node ArrayLiteralExpression, checkMode *CheckMode, forceTuple *bool) Type {
		elements := node.elements
		elementCount := elements.length
		var elementTypes []Type = []never{}
		var elementFlags []ElementFlags = []never{}
		pushCachedContextualType(node)
		inDestructuringPattern := isAssignmentTarget(node)
		inConstContext := isConstContext(node)
		contextualType := getApparentTypeOfContextualType(node /*contextFlags*/, nil)
		inTupleContext := isSpreadIntoCallOrNew(node) || !!contextualType && someType(contextualType, func(t Type) bool {
			return isTupleLikeType(t) || isGenericMappedType(t) && !t.nameType && !!getHomomorphicTypeVariable(t.target /* as MappedType */ || t)
		})
		hasOmittedExpression := false
		for i := 0; i < elementCount; i++ {
			e := elements[i]
			if e.kind == SyntaxKindSpreadElement {
				if languageVersion < LanguageFeatureMinimumTargetSpreadElements {
					checkExternalEmitHelpers(e, __COND__(compilerOptions.downlevelIteration, ExternalEmitHelpersSpreadIncludes, ExternalEmitHelpersSpreadArray))
				}
				spreadType := checkExpression((e /* as SpreadElement */).expression, checkMode, forceTuple)
				if isArrayLikeType(spreadType) {
					elementTypes.push(spreadType)
					elementFlags.push(ElementFlagsVariadic)
				} else if inDestructuringPattern {
					// Given the following situation:
					//    var c: {};
					//    [...c] = ["", 0];
					//
					// c is represented in the tree as a spread element in an array literal.
					// But c really functions as a rest element, and its purpose is to provide
					// a contextual type for the right hand side of the assignment. Therefore,
					// instead of calling checkExpression on "...c", which will give an error
					// if c is not iterable/array-like, we need to act as if we are trying to
					// get the contextual element type from it. So we do something similar to
					// getContextualTypeForElementExpression, which will crucially not error
					// if there is no index type / iterated type.
					restElementType := getIndexTypeOfType(spreadType, numberType) || getIteratedTypeOrElementType(IterationUseDestructuring, spreadType, undefinedType /*errorNode*/, nil /*checkAssignability*/, false) || unknownType
					elementTypes.push(restElementType)
					elementFlags.push(ElementFlagsRest)
				} else {
					elementTypes.push(checkIteratedTypeOrElementType(IterationUseSpread, spreadType, undefinedType, (e /* as SpreadElement */).expression))
					elementFlags.push(ElementFlagsRest)
				}
			} else if exactOptionalPropertyTypes && e.kind == SyntaxKindOmittedExpression {
				hasOmittedExpression = true
				elementTypes.push(undefinedOrMissingType)
				elementFlags.push(ElementFlagsOptional)
			} else {
				type_ := checkExpressionForMutableLocation(e, checkMode, forceTuple)
				elementTypes.push(addOptionality(type_ /*isProperty*/, true, hasOmittedExpression))
				elementFlags.push(__COND__(hasOmittedExpression, ElementFlagsOptional, ElementFlagsRequired))
				if inTupleContext && checkMode && checkMode&CheckModeInferential && !(checkMode & CheckModeSkipContextSensitive) && isContextSensitive(e) {
					inferenceContext := getInferenceContext(node)
					Debug.assert(inferenceContext)
					// In CheckMode.Inferential we should always have an inference context
					addIntraExpressionInferenceSite(inferenceContext, e, type_)
				}
			}
		}
		popContextualType()
		if inDestructuringPattern {
			return createTupleType(elementTypes, elementFlags)
		}
		if forceTuple || inConstContext || inTupleContext {
			return createArrayLiteralType(createTupleType(elementTypes, elementFlags /*readonly*/, inConstContext && !(contextualType && someType(contextualType, isMutableArrayLikeType))))
		}
		return createArrayLiteralType(createArrayType(__COND__(elementTypes.length, getUnionType(sameMap(elementTypes, func(t Type, i number) Type {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case elementFlags[i] & ElementFlagsVariadic:
				return getIndexedAccessTypeOrUndefined(t, numberType) || anyType
			default:
				return t
			}
		}), UnionReductionSubtype), __COND__(strictNullChecks, implicitNeverType, undefinedWideningType)), inConstContext))
	}
	createArrayLiteralType := func(type_ Type) Type {
		if !(getObjectFlags(type_) & ObjectFlagsReference) {
			return type_
		}
		literalType := (type_ /* as TypeReference */).literalType
		if !literalType {
			literalType = /* TODO(TS-TO-GO) Node BinaryExpression: (type as TypeReference).literalType = cloneTypeReference(type as TypeReference) */ TODO
			literalType.objectFlags |= ObjectFlagsArrayLiteral | ObjectFlagsContainsObjectOrArrayLiteral
		}
		return literalType
	}
	isNumericName := func(name DeclarationName) bool {
		switch name.kind {
		case SyntaxKindComputedPropertyName:
			return isNumericComputedName(name)
		case SyntaxKindIdentifier:
			return isNumericLiteralName(name.escapedText)
		case SyntaxKindNumericLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindStringLiteral:
			return isNumericLiteralName(name.text)
		default:
			return false
		}
	}
	isNumericComputedName := func(name ComputedPropertyName) bool {
		// It seems odd to consider an expression of type Any to result in a numeric name,
		// but this behavior is consistent with checkIndexedAccess
		return isTypeAssignableToKind(checkComputedPropertyName(name), TypeFlagsNumberLike)
	}
	checkComputedPropertyName := func(node ComputedPropertyName) Type {
		links := getNodeLinks(node.expression)
		if !links.resolvedType {
			if (isTypeLiteralNode(node.parent.parent) || isClassLike(node.parent.parent) || isInterfaceDeclaration(node.parent.parent)) && isBinaryExpression(node.expression) && node.expression.operatorToken.kind == SyntaxKindInKeyword && node.parent.kind != SyntaxKindGetAccessor && node.parent.kind != SyntaxKindSetAccessor {
				links.resolvedType = errorType
				return links.resolvedType
			}
			links.resolvedType = checkExpression(node.expression)
			// The computed property name of a non-static class field within a loop must be stored in a block-scoped binding.
			// (It needs to be bound at class evaluation time.)
			if isPropertyDeclaration(node.parent) && !hasStaticModifier(node.parent) && isClassExpression(node.parent.parent) {
				container := getEnclosingBlockScopeContainer(node.parent.parent)
				enclosingIterationStatement := getEnclosingIterationStatement(container)
				if enclosingIterationStatement {
					// The computed field name will use a block scoped binding which can be unique for each iteration of the loop.
					getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
					// The generated variable which stores the computed field name must be block-scoped.
					getNodeLinks(node).flags |= NodeCheckFlagsBlockScopedBindingInLoop
					// The generated variable which stores the class must be block-scoped.
					getNodeLinks(node.parent.parent).flags |= NodeCheckFlagsBlockScopedBindingInLoop
				}
			}
			// This will allow types number, string, symbol or any. It will also allow enums, the unknown
			// type, and any union of these types (like string | number).
			if links.resolvedType.flags&TypeFlagsNullable || !isTypeAssignableToKind(links.resolvedType, TypeFlagsStringLike|TypeFlagsNumberLike|TypeFlagsESSymbolLike) && !isTypeAssignableTo(links.resolvedType, stringNumberSymbolType) {
				error(node, Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any)
			}
		}
		return links.resolvedType
	}
	isSymbolWithNumericName := func(symbol Symbol) *bool {
		firstDecl := symbol.declarations[0]
		return isNumericLiteralName(symbol.escapedName) || (firstDecl && isNamedDeclaration(firstDecl) && isNumericName(firstDecl.name))
	}
	isSymbolWithSymbolName := func(symbol Symbol) *bool {
		firstDecl := symbol.declarations[0]
		return isKnownSymbol(symbol) || (firstDecl && isNamedDeclaration(firstDecl) && isComputedPropertyName(firstDecl.name) && isTypeAssignableToKind(checkComputedPropertyName(firstDecl.name), TypeFlagsESSymbol))
	}
	getObjectLiteralIndexInfo := func(node ObjectLiteralExpression, offset number, properties []Symbol, keyType Type) IndexInfo {
		var propTypes []Type = []never{}
		for i := offset; i < properties.length; i++ {
			prop := properties[i]
			if keyType == stringType && !isSymbolWithSymbolName(prop) || keyType == numberType && isSymbolWithNumericName(prop) || keyType == esSymbolType && isSymbolWithSymbolName(prop) {
				propTypes.push(getTypeOfSymbol(properties[i]))
			}
		}
		var unionType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case propTypes.length:
			unionType = getUnionType(propTypes, UnionReductionSubtype)
		default:
			unionType = undefinedType
		}
		return createIndexInfo(keyType, unionType, isConstContext(node))
	}
	getImmediateAliasedSymbol := func(symbol Symbol) Symbol {
		Debug.assert((symbol.flags&SymbolFlagsAlias) != 0, "Should only get Alias here.")
		links := getSymbolLinks(symbol)
		if !links.immediateTarget {
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				return Debug.fail()
			}
			links.immediateTarget = getTargetOfAliasDeclaration(node /*dontRecursivelyResolve*/, true)
		}
		return links.immediateTarget
	}
	checkObjectLiteral := func(node ObjectLiteralExpression, checkMode CheckMode /*  = CheckMode.Normal */) Type {
		inDestructuringPattern := isAssignmentTarget(node)
		// Grammar checking
		checkGrammarObjectLiteralExpression(node, inDestructuringPattern)
		var allPropertiesTable *SymbolTable
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case strictNullChecks:
			allPropertiesTable = createSymbolTable()
		default:
			allPropertiesTable = nil
		}
		propertiesTable := createSymbolTable()
		var propertiesArray []Symbol = []never{}
		var spread Type = emptyObjectType
		pushCachedContextualType(node)
		contextualType := getApparentTypeOfContextualType(node /*contextFlags*/, nil)
		contextualTypeHasPattern := contextualType && contextualType.pattern && (contextualType.pattern.kind == SyntaxKindObjectBindingPattern || contextualType.pattern.kind == SyntaxKindObjectLiteralExpression)
		inConstContext := isConstContext(node)
		var checkFlags /* TODO(TS-TO-GO) inferred type 0 | CheckFlags.Readonly */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case inConstContext:
			checkFlags = CheckFlagsReadonly
		default:
			checkFlags = 0
		}
		isInJavascript := isInJSFile(node) && !isInJsonFile(node)
		var enumTag *JSDocEnumTag
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isInJavascript:
			enumTag = getJSDocEnumTag(node)
		default:
			enumTag = nil
		}
		isJSObjectLiteral := !contextualType && isInJavascript && !enumTag
		var objectFlags ObjectFlags = ObjectFlagsFreshLiteral
		patternWithComputedProperties := false
		hasComputedStringProperty := false
		hasComputedNumberProperty := false
		hasComputedSymbolProperty := false
		// Spreads may cause an early bail; ensure computed names are always checked (this is cached)
		// As otherwise they may not be checked until exports for the type at this position are retrieved,
		// which may never occur.
		for _, elem := range node.properties {
			if elem.name && isComputedPropertyName(elem.name) {
				checkComputedPropertyName(elem.name)
			}
		}
		offset := 0
		for _, memberDecl := range node.properties {
			member := getSymbolOfDeclaration(memberDecl)
			var computedNameType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case memberDecl.name && memberDecl.name.kind == SyntaxKindComputedPropertyName:
				computedNameType = checkComputedPropertyName(memberDecl.name)
			default:
				computedNameType = nil
			}
			if memberDecl.kind == SyntaxKindPropertyAssignment || memberDecl.kind == SyntaxKindShorthandPropertyAssignment || isObjectLiteralMethod(memberDecl) {
				var type_ Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case memberDecl.kind == SyntaxKindPropertyAssignment:
					type_ = checkPropertyAssignment(memberDecl, checkMode)
				case memberDecl.kind == SyntaxKindShorthandPropertyAssignment:
					type_ = checkExpressionForMutableLocation(__COND__(!inDestructuringPattern && memberDecl.objectAssignmentInitializer, memberDecl.objectAssignmentInitializer, memberDecl.name), checkMode)
				default:
					type_ = checkObjectLiteralMethod(memberDecl, checkMode)
				}
				if isInJavascript {
					jsDocType := getTypeForDeclarationFromJSDocComment(memberDecl)
					if jsDocType {
						checkTypeAssignableTo(type_, jsDocType, memberDecl)
						type_ = jsDocType
					} else if enumTag && enumTag.typeExpression {
						checkTypeAssignableTo(type_, getTypeFromTypeNode(enumTag.typeExpression), memberDecl)
					}
				}
				objectFlags |= getObjectFlags(type_) & ObjectFlagsPropagatingFlags
				var nameType * /* TODO(TS-TO-GO) inferred type StringLiteralType | NumberLiteralType | UniqueESSymbolType */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case computedNameType && isTypeUsableAsPropertyName(computedNameType):
					nameType = computedNameType
				default:
					nameType = nil
				}
				var prop TransientSymbol
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case nameType:
					prop = createSymbol(SymbolFlagsProperty|member.flags, getPropertyNameFromType(nameType), checkFlags|CheckFlagsLate)
				default:
					prop = createSymbol(SymbolFlagsProperty|member.flags, member.escapedName, checkFlags)
				}
				if nameType {
					prop.links.nameType = nameType
				}
				if inDestructuringPattern && hasDefaultValue(memberDecl) {
					// If object literal is an assignment pattern and if the assignment pattern specifies a default value
					// for the property, make the property optional.
					prop.flags |= SymbolFlagsOptional
				} else if contextualTypeHasPattern && !(getObjectFlags(contextualType) & ObjectFlagsObjectLiteralPatternWithComputedProperties) {
					// If object literal is contextually typed by the implied type of a binding pattern, and if the
					// binding pattern specifies a default value for the property, make the property optional.
					impliedProp := getPropertyOfType(contextualType, member.escapedName)
					if impliedProp {
						prop.flags |= impliedProp.flags & SymbolFlagsOptional
					} else if !getIndexInfoOfType(contextualType, stringType) {
						error(memberDecl.name, Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(member), typeToString(contextualType))
					}
				}
				prop.declarations = member.declarations
				prop.parent = member.parent
				if member.valueDeclaration {
					prop.valueDeclaration = member.valueDeclaration
				}
				prop.links.type_ = type_
				prop.links.target = member
				member = prop
				allPropertiesTable. /* TODO(TS-TO-GO): was ? */ set(prop.escapedName, prop)
				if contextualType && checkMode&CheckModeInferential && !(checkMode & CheckModeSkipContextSensitive) && (memberDecl.kind == SyntaxKindPropertyAssignment || memberDecl.kind == SyntaxKindMethodDeclaration) && isContextSensitive(memberDecl) {
					inferenceContext := getInferenceContext(node)
					Debug.assert(inferenceContext)
					// In CheckMode.Inferential we should always have an inference context
					var inferenceNode /* TODO(TS-TO-GO) inferred type Expression | MethodDeclaration */ any
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case memberDecl.kind == SyntaxKindPropertyAssignment:
						inferenceNode = memberDecl.initializer
					default:
						inferenceNode = memberDecl
					}
					addIntraExpressionInferenceSite(inferenceContext, inferenceNode, type_)
				}
			} else if memberDecl.kind == SyntaxKindSpreadAssignment {
				if languageVersion < LanguageFeatureMinimumTargetObjectAssign {
					checkExternalEmitHelpers(memberDecl, ExternalEmitHelpersAssign)
				}
				if propertiesArray.length > 0 {
					spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext)
					propertiesArray = []never{}
					propertiesTable = createSymbolTable()
					hasComputedStringProperty = false
					hasComputedNumberProperty = false
					hasComputedSymbolProperty = false
				}
				type_ := getReducedType(checkExpression(memberDecl.expression, checkMode&CheckModeInferential))
				if isValidSpreadType(type_) {
					mergedType := tryMergeUnionOfObjectTypeAndEmptyObject(type_, inConstContext)
					if allPropertiesTable {
						checkSpreadPropOverrides(mergedType, allPropertiesTable, memberDecl)
					}
					offset = propertiesArray.length
					if isErrorType(spread) {
						continue
					}
					spread = getSpreadType(spread, mergedType, node.symbol, objectFlags, inConstContext)
				} else {
					error(memberDecl, Diagnostics.Spread_types_may_only_be_created_from_object_types)
					spread = errorType
				}
				continue
			} else {
				// TypeScript 1.0 spec (April 2014)
				// A get accessor declaration is processed in the same manner as
				// an ordinary function declaration(section 6.1) with no parameters.
				// A set accessor declaration is processed in the same manner
				// as an ordinary function declaration with a single parameter and a Void return type.
				Debug.assert(memberDecl.kind == SyntaxKindGetAccessor || memberDecl.kind == SyntaxKindSetAccessor)
				checkNodeDeferred(memberDecl)
			}
			if computedNameType && !(computedNameType.flags & TypeFlagsStringOrNumberLiteralOrUnique) {
				if isTypeAssignableTo(computedNameType, stringNumberSymbolType) {
					if isTypeAssignableTo(computedNameType, numberType) {
						hasComputedNumberProperty = true
					} else if isTypeAssignableTo(computedNameType, esSymbolType) {
						hasComputedSymbolProperty = true
					} else {
						hasComputedStringProperty = true
					}
					if inDestructuringPattern {
						patternWithComputedProperties = true
					}
				}
			} else {
				propertiesTable.set(member.escapedName, member)
			}
			propertiesArray.push(member)
		}
		popContextualType()
		if isErrorType(spread) {
			return errorType
		}
		if spread != emptyObjectType {
			if propertiesArray.length > 0 {
				spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext)
				propertiesArray = []never{}
				propertiesTable = createSymbolTable()
				hasComputedStringProperty = false
				hasComputedNumberProperty = false
			}
			// remap the raw emptyObjectType fed in at the top into a fresh empty object literal type, unique to this use site
			return mapType(spread, func(t Type) Type {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case t == emptyObjectType:
					return createObjectLiteralType()
				default:
					return t
				}
			})
		}
		return createObjectLiteralType()
		createObjectLiteralType := func() ResolvedType {
			indexInfos := []never{}
			if hasComputedStringProperty {
				indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, stringType))
			}
			if hasComputedNumberProperty {
				indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, numberType))
			}
			if hasComputedSymbolProperty {
				indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, esSymbolType))
			}
			result := createAnonymousType(node.symbol, propertiesTable, emptyArray, emptyArray, indexInfos)
			result.objectFlags |= objectFlags | ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
			if isJSObjectLiteral {
				result.objectFlags |= ObjectFlagsJSLiteral
			}
			if patternWithComputedProperties {
				result.objectFlags |= ObjectFlagsObjectLiteralPatternWithComputedProperties
			}
			if inDestructuringPattern {
				result.pattern = node
			}
			return result
		}
	}
	isValidSpreadType := func(type_ Type) bool {
		t := removeDefinitelyFalsyTypes(mapType(type_, getBaseConstraintOrType))
		return !!(t.flags&(TypeFlagsAny|TypeFlagsNonPrimitive|TypeFlagsObject|TypeFlagsInstantiableNonPrimitive) || t.flags&TypeFlagsUnionOrIntersection && every((t /* as UnionOrIntersectionType */).types, isValidSpreadType))
	}
	checkJsxSelfClosingElementDeferred := func(node JsxSelfClosingElement) {
		checkJsxOpeningLikeElementOrOpeningFragment(node)
	}
	checkJsxSelfClosingElement := func(node JsxSelfClosingElement, _checkMode *CheckMode) Type {
		checkNodeDeferred(node)
		return getJsxElementTypeAt(node) || anyType
	}
	checkJsxElementDeferred := func(node JsxElement) {
		// Check attributes
		checkJsxOpeningLikeElementOrOpeningFragment(node.openingElement)
		// Perform resolution on the closing tag so that rename/go to definition/etc work
		if isJsxIntrinsicTagName(node.closingElement.tagName) {
			getIntrinsicTagSymbol(node.closingElement)
		} else {
			checkExpression(node.closingElement.tagName)
		}
		checkJsxChildren(node)
	}
	checkJsxElement := func(node JsxElement, _checkMode *CheckMode) Type {
		checkNodeDeferred(node)
		return getJsxElementTypeAt(node) || anyType
	}
	checkJsxFragment := func(node JsxFragment) Type {
		checkJsxOpeningLikeElementOrOpeningFragment(node.openingFragment)
		// by default, jsx:'react' will use jsxFactory = React.createElement and jsxFragmentFactory = React.Fragment
		// if jsxFactory compiler option is provided, ensure jsxFragmentFactory compiler option or @jsxFrag pragma is provided too
		nodeSourceFile := getSourceFileOfNode(node)
		if getJSXTransformEnabled(compilerOptions) && (compilerOptions.jsxFactory || nodeSourceFile.pragmas.has("jsx")) && !compilerOptions.jsxFragmentFactory && !nodeSourceFile.pragmas.has("jsxfrag") {
			error(node, __COND__(compilerOptions.jsxFactory, Diagnostics.The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option, Diagnostics.An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments))
		}
		checkJsxChildren(node)
		return getJsxElementTypeAt(node) || anyType
	}
	isHyphenatedJsxName := func(name /* TODO(TS-TO-GO) TypeNode UnionType: string | __String */ any) bool {
		return (name /* as string */).includes("-")
	}
	/**
	 * Returns true iff React would emit this tag name as a string rather than an identifier or qualified name
	 */
	isJsxIntrinsicTagName := func(tagName Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: tagName is Identifier | JsxNamespacedName */ any {
		return isIdentifier(tagName) && isIntrinsicJsxName(tagName.escapedText) || isJsxNamespacedName(tagName)
	}
	checkJsxAttribute := func(node JsxAttribute, checkMode CheckMode) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.initializer:
			return checkExpressionForMutableLocation(node.initializer, checkMode)
		default:
			return trueType
		}
		// <Elem attr /> is sugar for <Elem attr={true} />
	}
	/**
	 * Get attributes type of the JSX opening-like element. The result is from resolving "attributes" property of the opening-like element.
	 *
	 * @param openingLikeElement a JSX opening-like element
	 * @param filter a function to remove attributes that will not participate in checking whether attributes are assignable
	 * @return an anonymous type (similar to the one returned by checkObjectLiteral) in which its properties are attributes property.
	 * @remarks Because this function calls getSpreadType, it needs to use the same checks as checkObjectLiteral,
	 * which also calls getSpreadType.
	 */
	createJsxAttributesTypeFromAttributesProperty := func(openingLikeElement JsxOpeningLikeElement, checkMode CheckMode /*  = CheckMode.Normal */) Type {
		attributes := openingLikeElement.attributes
		contextualType := getContextualType(attributes, ContextFlagsNone)
		var allAttributesTable *SymbolTable
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case strictNullChecks:
			allAttributesTable = createSymbolTable()
		default:
			allAttributesTable = nil
		}
		attributesTable := createSymbolTable()
		var spread Type = emptyJsxObjectType
		hasSpreadAnyType := false
		var typeToIntersect Type
		explicitlySpecifyChildrenAttribute := false
		var objectFlags ObjectFlags = ObjectFlagsJsxAttributes
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(openingLikeElement))
		for _, attributeDecl := range attributes.properties {
			member := attributeDecl.symbol
			if isJsxAttribute(attributeDecl) {
				exprType := checkJsxAttribute(attributeDecl, checkMode)
				objectFlags |= getObjectFlags(exprType) & ObjectFlagsPropagatingFlags
				attributeSymbol := createSymbol(SymbolFlagsProperty|member.flags, member.escapedName)
				attributeSymbol.declarations = member.declarations
				attributeSymbol.parent = member.parent
				if member.valueDeclaration {
					attributeSymbol.valueDeclaration = member.valueDeclaration
				}
				attributeSymbol.links.type_ = exprType
				attributeSymbol.links.target = member
				attributesTable.set(attributeSymbol.escapedName, attributeSymbol)
				allAttributesTable. /* TODO(TS-TO-GO): was ? */ set(attributeSymbol.escapedName, attributeSymbol)
				if getEscapedTextOfJsxAttributeName(attributeDecl.name) == jsxChildrenPropertyName {
					explicitlySpecifyChildrenAttribute = true
				}
				if contextualType {
					prop := getPropertyOfType(contextualType, member.escapedName)
					if prop && prop.declarations && isDeprecatedSymbol(prop) && isIdentifier(attributeDecl.name) {
						addDeprecatedSuggestion(attributeDecl.name, prop.declarations, attributeDecl.name.escapedText /* as string */)
					}
				}
				if contextualType && checkMode&CheckModeInferential && !(checkMode & CheckModeSkipContextSensitive) && isContextSensitive(attributeDecl) {
					inferenceContext := getInferenceContext(attributes)
					Debug.assert(inferenceContext)
					// In CheckMode.Inferential we should always have an inference context
					inferenceNode := (attributeDecl.initializer /* as JsxExpression */).expression
					addIntraExpressionInferenceSite(inferenceContext, inferenceNode, exprType)
				}
			} else {
				Debug.assert(attributeDecl.kind == SyntaxKindJsxSpreadAttribute)
				if attributesTable.size > 0 {
					spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags /*readonly*/, false)
					attributesTable = createSymbolTable()
				}
				exprType := getReducedType(checkExpression(attributeDecl.expression, checkMode&CheckModeInferential))
				if isTypeAny(exprType) {
					hasSpreadAnyType = true
				}
				if isValidSpreadType(exprType) {
					spread = getSpreadType(spread, exprType, attributes.symbol, objectFlags /*readonly*/, false)
					if allAttributesTable {
						checkSpreadPropOverrides(exprType, allAttributesTable, attributeDecl)
					}
				} else {
					error(attributeDecl.expression, Diagnostics.Spread_types_may_only_be_created_from_object_types)
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case typeToIntersect:
						typeToIntersect = getIntersectionType([]Type{typeToIntersect, exprType})
					default:
						typeToIntersect = exprType
					}
				}
			}
		}
		if !hasSpreadAnyType {
			if attributesTable.size > 0 {
				spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags /*readonly*/, false)
			}
		}
		// Handle children attribute
		var parent *JsxElement
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case openingLikeElement.parent.kind == SyntaxKindJsxElement:
			parent = openingLikeElement.parent /* as JsxElement */
		default:
			parent = nil
		}
		// We have to check that openingElement of the parent is the one we are visiting as this may not be true for selfClosingElement
		if parent && parent.openingElement == openingLikeElement && getSemanticJsxChildren(parent.children).length > 0 {
			var childrenTypes []Type = checkJsxChildren(parent, checkMode)
			if !hasSpreadAnyType && jsxChildrenPropertyName && jsxChildrenPropertyName != "" {
				// Error if there is a attribute named "children" explicitly specified and children element.
				// This is because children element will overwrite the value from attributes.
				// Note: we will not warn "children" attribute overwritten if "children" attribute is specified in object spread.
				if explicitlySpecifyChildrenAttribute {
					error(attributes, Diagnostics._0_are_specified_twice_The_attribute_named_0_will_be_overwritten, unescapeLeadingUnderscores(jsxChildrenPropertyName))
				}
				contextualType := getApparentTypeOfContextualType(openingLikeElement.attributes /*contextFlags*/, nil)
				childrenContextualType := contextualType && getTypeOfPropertyOfContextualType(contextualType, jsxChildrenPropertyName)
				// If there are children in the body of JSX element, create dummy attribute "children" with the union of children types so that it will pass the attribute checking process
				childrenPropSymbol := createSymbol(SymbolFlagsProperty, jsxChildrenPropertyName)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case childrenTypes.length == 1:
					childrenPropSymbol.links.type_ = childrenTypes[0]
				case childrenContextualType && someType(childrenContextualType, isTupleLikeType):
					childrenPropSymbol.links.type_ = createTupleType(childrenTypes)
				default:
					childrenPropSymbol.links.type_ = createArrayType(getUnionType(childrenTypes))
				}
				// Fake up a property declaration for the children
				childrenPropSymbol.valueDeclaration = factory.createPropertySignature(nil, unescapeLeadingUnderscores(jsxChildrenPropertyName) /*questionToken*/, nil /*type*/, nil)
				setParent(childrenPropSymbol.valueDeclaration, attributes)
				childrenPropSymbol.valueDeclaration.symbol = childrenPropSymbol
				childPropMap := createSymbolTable()
				childPropMap.set(jsxChildrenPropertyName, childrenPropSymbol)
				spread = getSpreadType(spread, createAnonymousType(attributes.symbol, childPropMap, emptyArray, emptyArray, emptyArray), attributes.symbol, objectFlags /*readonly*/, false)
			}
		}
		if hasSpreadAnyType {
			return anyType
		}
		if typeToIntersect && spread != emptyJsxObjectType {
			return getIntersectionType([]Type{typeToIntersect, spread})
		}
		return typeToIntersect || (__COND__(spread == emptyJsxObjectType, createJsxAttributesType(), spread))
		/**
		 * Create anonymous type from given attributes symbol table.
		 * @param symbol a symbol of JsxAttributes containing attributes corresponding to attributesTable
		 * @param attributesTable a symbol table of attributes property
		 */
		createJsxAttributesType := func() ResolvedType {
			objectFlags |= ObjectFlagsFreshLiteral
			result := createAnonymousType(attributes.symbol, attributesTable, emptyArray, emptyArray, emptyArray)
			result.objectFlags |= objectFlags | ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
			return result
		}
	}
	checkJsxChildren := func(node /* TODO(TS-TO-GO) TypeNode UnionType: JsxElement | JsxFragment */ any, checkMode CheckMode) []Type {
		var childrenTypes []Type = []never{}
		for _, child := range node.children {
			// In React, JSX text that contains only whitespaces will be ignored so we don't want to type-check that
			// because then type of children property will have constituent of string type.
			if child.kind == SyntaxKindJsxText {
				if !child.containsOnlyTriviaWhiteSpaces {
					childrenTypes.push(stringType)
				}
			} else if child.kind == SyntaxKindJsxExpression && !child.expression {
				continue
				// empty jsx expressions don't *really* count as present children
			} else {
				childrenTypes.push(checkExpressionForMutableLocation(child, checkMode))
			}
		}
		return childrenTypes
	}
	checkSpreadPropOverrides := func(type_ Type, props SymbolTable, spread /* TODO(TS-TO-GO) TypeNode UnionType: SpreadAssignment | JsxSpreadAttribute */ any) {
		for _, right := range getPropertiesOfType(type_) {
			if !(right.flags & SymbolFlagsOptional) {
				left := props.get(right.escapedName)
				if left {
					diagnostic := error(left.valueDeclaration, Diagnostics._0_is_specified_more_than_once_so_this_usage_will_be_overwritten, unescapeLeadingUnderscores(left.escapedName))
					addRelatedInfo(diagnostic, createDiagnosticForNode(spread, Diagnostics.This_spread_always_overwrites_this_property))
				}
			}
		}
	}
	/**
	 * Check attributes property of opening-like element. This function is called during chooseOverload to get call signature of a JSX opening-like element.
	 * (See "checkApplicableSignatureForJsxOpeningLikeElement" for how the function is used)
	 * @param node a JSXAttributes to be resolved of its type
	 */
	checkJsxAttributes := func(node JsxAttributes, checkMode *CheckMode) Type {
		return createJsxAttributesTypeFromAttributesProperty(node.parent, checkMode)
	}
	getJsxType := func(name __String, location Node) Type {
		namespace := getJsxNamespaceAt(location)
		exports := namespace && getExportsOfSymbol(namespace)
		typeSymbol := exports && getSymbol(exports, name, SymbolFlagsType)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case typeSymbol:
			return getDeclaredTypeOfSymbol(typeSymbol)
		default:
			return errorType
		}
	}
	/**
	 * Looks up an intrinsic tag name and returns a symbol that either points to an intrinsic
	 * property (in which case nodeLinks.jsxFlags will be IntrinsicNamedElement) or an intrinsic
	 * string index signature (in which case nodeLinks.jsxFlags will be IntrinsicIndexedElement).
	 * May also return unknownSymbol if both of these lookups fail.
	 */
	getIntrinsicTagSymbol := func(node /* TODO(TS-TO-GO) TypeNode UnionType: JsxOpeningLikeElement | JsxClosingElement */ any) Symbol {
		links := getNodeLinks(node)
		if !links.resolvedSymbol {
			intrinsicElementsType := getJsxType(JsxNames.IntrinsicElements, node)
			if !isErrorType(intrinsicElementsType) {
				// Property case
				if !isIdentifier(node.tagName) && !isJsxNamespacedName(node.tagName) {
					return Debug.fail()
				}
				var propName __String
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isJsxNamespacedName(node.tagName):
					propName = getEscapedTextOfJsxNamespacedName(node.tagName)
				default:
					propName = node.tagName.escapedText
				}
				intrinsicProp := getPropertyOfType(intrinsicElementsType, propName)
				if intrinsicProp {
					links.jsxFlags |= JsxFlagsIntrinsicNamedElement
					links.resolvedSymbol = intrinsicProp
					return links.resolvedSymbol
				}
				// Intrinsic string indexer case
				indexSymbol := getApplicableIndexSymbol(intrinsicElementsType, getStringLiteralType(unescapeLeadingUnderscores(propName)))
				if indexSymbol {
					links.jsxFlags |= JsxFlagsIntrinsicIndexedElement
					links.resolvedSymbol = indexSymbol
					return links.resolvedSymbol
				}
				if getTypeOfPropertyOrIndexSignatureOfType(intrinsicElementsType, propName) {
					links.jsxFlags |= JsxFlagsIntrinsicIndexedElement
					links.resolvedSymbol = intrinsicElementsType.symbol
					return links.resolvedSymbol
				}
				// Wasn't found
				error(node, Diagnostics.Property_0_does_not_exist_on_type_1, intrinsicTagNameToString(node.tagName), "JSX."+JsxNames.IntrinsicElements)
				links.resolvedSymbol = unknownSymbol
				return links.resolvedSymbol
			} else {
				if noImplicitAny {
					error(node, Diagnostics.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists, unescapeLeadingUnderscores(JsxNames.IntrinsicElements))
				}
				links.resolvedSymbol = unknownSymbol
				return links.resolvedSymbol
			}
		}
		return links.resolvedSymbol
	}
	getJsxNamespaceContainerForImplicitImport := func(location Node) Symbol {
		file := location && getSourceFileOfNode(location)
		links := file && getNodeLinks(file)
		if links && links.jsxImplicitImportContainer == false {
			return nil
		}
		if links && links.jsxImplicitImportContainer {
			return links.jsxImplicitImportContainer
		}
		runtimeImportSpecifier := getJSXRuntimeImport(getJSXImplicitImportBase(compilerOptions, file), compilerOptions)
		if !runtimeImportSpecifier {
			return nil
		}
		isClassic := getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindClassic
		var errorMessage DiagnosticMessage
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isClassic:
			errorMessage = Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option
		default:
			errorMessage = Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations
		}
		specifier := getJSXRuntimeImportSpecifier(file, runtimeImportSpecifier)
		mod := resolveExternalModule(specifier || location, runtimeImportSpecifier, errorMessage, location)
		var result Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case mod && mod != unknownSymbol:
			result = getMergedSymbol(resolveSymbol(mod))
		default:
			result = nil
		}
		if links {
			links.jsxImplicitImportContainer = result || false
		}
		return result
	}
	getJsxNamespaceAt := func(location Node) Symbol {
		links := location && getNodeLinks(location)
		if links && links.jsxNamespace {
			return links.jsxNamespace
		}
		if !links || links.jsxNamespace != false {
			resolvedNamespace := getJsxNamespaceContainerForImplicitImport(location)
			if !resolvedNamespace || resolvedNamespace == unknownSymbol {
				namespaceName := getJsxNamespace(location)
				resolvedNamespace = resolveName(location, namespaceName, SymbolFlagsNamespace /*nameNotFoundMessage*/, nil /*isUse*/, false)
			}
			if resolvedNamespace {
				candidate := resolveSymbol(getSymbol(getExportsOfSymbol(resolveSymbol(resolvedNamespace)), JsxNames.JSX, SymbolFlagsNamespace))
				if candidate && candidate != unknownSymbol {
					if links {
						links.jsxNamespace = candidate
					}
					return candidate
				}
			}
			if links {
				links.jsxNamespace = false
			}
		}
		// JSX global fallback
		s := resolveSymbol(getGlobalSymbol(JsxNames.JSX, SymbolFlagsNamespace /*diagnostic*/, nil))
		if s == unknownSymbol {
			return nil
			// TODO: GH#18217
		}
		return s
		// TODO: GH#18217
	}
	/**
	 * Look into JSX namespace and then look for container with matching name as nameOfAttribPropContainer.
	 * Get a single property from that container if existed. Report an error if there are more than one property.
	 *
	 * @param nameOfAttribPropContainer a string of value JsxNames.ElementAttributesPropertyNameContainer or JsxNames.ElementChildrenAttributeNameContainer
	 *          if other string is given or the container doesn't exist, return undefined.
	 */
	getNameFromJsxElementAttributesContainer := func(nameOfAttribPropContainer __String, jsxNamespace Symbol) *__String {
		// JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute [symbol]
		jsxElementAttribPropInterfaceSym := jsxNamespace && getSymbol(jsxNamespace.exports, nameOfAttribPropContainer, SymbolFlagsType)
		// JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute [type]
		jsxElementAttribPropInterfaceType := jsxElementAttribPropInterfaceSym && getDeclaredTypeOfSymbol(jsxElementAttribPropInterfaceSym)
		// The properties of JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute
		propertiesOfJsxElementAttribPropInterface := jsxElementAttribPropInterfaceType && getPropertiesOfType(jsxElementAttribPropInterfaceType)
		if propertiesOfJsxElementAttribPropInterface {
			// Element Attributes has zero properties, so the element attributes type will be the class instance type
			if propertiesOfJsxElementAttribPropInterface.length == 0 {
				return "" /* as __String */
			} else if propertiesOfJsxElementAttribPropInterface.length == 1 {
				return propertiesOfJsxElementAttribPropInterface[0].escapedName
			} else if propertiesOfJsxElementAttribPropInterface.length > 1 && jsxElementAttribPropInterfaceSym.declarations {
				// More than one property on ElementAttributesProperty is an error
				error(jsxElementAttribPropInterfaceSym.declarations[0], Diagnostics.The_global_type_JSX_0_may_not_have_more_than_one_property, unescapeLeadingUnderscores(nameOfAttribPropContainer))
			}
		}
		return nil
	}
	getJsxLibraryManagedAttributes := func(jsxNamespace Symbol) Symbol {
		// JSX.LibraryManagedAttributes [symbol]
		return jsxNamespace && getSymbol(jsxNamespace.exports, JsxNames.LibraryManagedAttributes, SymbolFlagsType)
	}
	getJsxElementTypeSymbol := func(jsxNamespace Symbol) Symbol {
		// JSX.ElementType [symbol]
		return jsxNamespace && getSymbol(jsxNamespace.exports, JsxNames.ElementType, SymbolFlagsType)
	}
	/// e.g. "props" for React.d.ts,
	/// or 'undefined' if ElementAttributesProperty doesn't exist (which means all
	///     non-intrinsic elements' attributes type is 'any'),
	/// or '' if it has 0 properties (which means every
	///     non-intrinsic elements' attributes type is the element instance type)
	getJsxElementPropertiesName := func(jsxNamespace Symbol) *__String {
		return getNameFromJsxElementAttributesContainer(JsxNames.ElementAttributesPropertyNameContainer, jsxNamespace)
	}
	getJsxElementChildrenPropertyName := func(jsxNamespace Symbol) *__String {
		return getNameFromJsxElementAttributesContainer(JsxNames.ElementChildrenAttributeNameContainer, jsxNamespace)
	}
	getUninstantiatedJsxSignaturesOfType := func(elementType Type, caller JsxOpeningLikeElement) []Signature {
		if elementType.flags & TypeFlagsString {
			return []Signature{anySignature}
		} else if elementType.flags & TypeFlagsStringLiteral {
			intrinsicType := getIntrinsicAttributesTypeFromStringLiteralType(elementType /* as StringLiteralType */, caller)
			if !intrinsicType {
				error(caller, Diagnostics.Property_0_does_not_exist_on_type_1, (elementType /* as StringLiteralType */).value, "JSX."+JsxNames.IntrinsicElements)
				return emptyArray
			} else {
				fakeSignature := createSignatureForJSXIntrinsic(caller, intrinsicType)
				return []Signature{fakeSignature}
			}
		}
		apparentElemType := getApparentType(elementType)
		// Resolve the signatures, preferring constructor
		signatures := getSignaturesOfType(apparentElemType, SignatureKindConstruct)
		if signatures.length == 0 {
			// No construct signatures, try call signatures
			signatures = getSignaturesOfType(apparentElemType, SignatureKindCall)
		}
		if signatures.length == 0 && apparentElemType.flags&TypeFlagsUnion {
			// If each member has some combination of new/call signatures; make a union signature list for those
			signatures = getUnionSignatures(map_((apparentElemType /* as UnionType */).types, func(t Type) []Signature {
				return getUninstantiatedJsxSignaturesOfType(t, caller)
			}))
		}
		return signatures
	}
	getIntrinsicAttributesTypeFromStringLiteralType := func(type_ StringLiteralType, location Node) Type {
		// If the elemType is a stringLiteral type, we can then provide a check to make sure that the string literal type is one of the Jsx intrinsic element type
		// For example:
		//      var CustomTag: "h1" = "h1";
		//      <CustomTag> Hello World </CustomTag>
		intrinsicElementsType := getJsxType(JsxNames.IntrinsicElements, location)
		if !isErrorType(intrinsicElementsType) {
			stringLiteralTypeName := type_.value
			intrinsicProp := getPropertyOfType(intrinsicElementsType, escapeLeadingUnderscores(stringLiteralTypeName))
			if intrinsicProp {
				return getTypeOfSymbol(intrinsicProp)
			}
			indexSignatureType := getIndexTypeOfType(intrinsicElementsType, stringType)
			if indexSignatureType {
				return indexSignatureType
			}
			return nil
		}
		// If we need to report an error, we already done so here. So just return any to prevent any more error downstream
		return anyType
	}
	checkJsxReturnAssignableToAppropriateBound := func(refKind JsxReferenceKind, elemInstanceType Type, openingLikeElement JsxOpeningLikeElement) {
		if refKind == JsxReferenceKindFunction {
			sfcReturnConstraint := getJsxStatelessElementTypeAt(openingLikeElement)
			if sfcReturnConstraint {
				checkTypeRelatedTo(elemInstanceType, sfcReturnConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_return_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
			}
		} else if refKind == JsxReferenceKindComponent {
			classConstraint := getJsxElementClassTypeAt(openingLikeElement)
			if classConstraint {
				// Issue an error if this return type isn't assignable to JSX.ElementClass, failing that
				checkTypeRelatedTo(elemInstanceType, classConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_instance_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
			}
		} else {
			sfcReturnConstraint := getJsxStatelessElementTypeAt(openingLikeElement)
			classConstraint := getJsxElementClassTypeAt(openingLikeElement)
			if !sfcReturnConstraint || !classConstraint {
				return
			}
			combined := getUnionType([]Type{sfcReturnConstraint, classConstraint})
			checkTypeRelatedTo(elemInstanceType, combined, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_element_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
		}
		generateInitialErrorChain := func() DiagnosticMessageChain {
			componentName := getTextOfNode(openingLikeElement.tagName)
			return chainDiagnosticMessages(nil, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName)
		}
	}
	/**
	 * Get attributes type of the given intrinsic opening-like Jsx element by resolving the tag name.
	 * The function is intended to be called from a function which has checked that the opening element is an intrinsic element.
	 * @param node an intrinsic JSX opening-like element
	 */
	getIntrinsicAttributesTypeFromJsxOpeningLikeElement := func(node JsxOpeningLikeElement) Type {
		Debug.assert(isJsxIntrinsicTagName(node.tagName))
		links := getNodeLinks(node)
		if !links.resolvedJsxElementAttributesType {
			symbol := getIntrinsicTagSymbol(node)
			if links.jsxFlags & JsxFlagsIntrinsicNamedElement {
				links.resolvedJsxElementAttributesType = getTypeOfSymbol(symbol) || errorType
				return links.resolvedJsxElementAttributesType
			} else if links.jsxFlags & JsxFlagsIntrinsicIndexedElement {
				var propName __String
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isJsxNamespacedName(node.tagName):
					propName = getEscapedTextOfJsxNamespacedName(node.tagName)
				default:
					propName = node.tagName.escapedText
				}
				links.resolvedJsxElementAttributesType = getApplicableIndexInfoForName(getJsxType(JsxNames.IntrinsicElements, node), propName). /* TODO(TS-TO-GO): was ? */ type_ || errorType
				return links.resolvedJsxElementAttributesType
			} else {
				links.resolvedJsxElementAttributesType = errorType
				return links.resolvedJsxElementAttributesType
			}
		}
		return links.resolvedJsxElementAttributesType
	}
	getJsxElementClassTypeAt := func(location Node) Type {
		type_ := getJsxType(JsxNames.ElementClass, location)
		if isErrorType(type_) {
			return nil
		}
		return type_
	}
	getJsxElementTypeAt := func(location Node) Type {
		return getJsxType(JsxNames.Element, location)
	}
	getJsxStatelessElementTypeAt := func(location Node) Type {
		jsxElementType := getJsxElementTypeAt(location)
		if jsxElementType {
			return getUnionType([]Type{jsxElementType, nullType})
		}
	}
	getJsxElementTypeTypeAt := func(location Node) Type {
		ns := getJsxNamespaceAt(location)
		if !ns {
			return nil
		}
		sym := getJsxElementTypeSymbol(ns)
		if !sym {
			return nil
		}
		type_ := instantiateAliasOrInterfaceWithDefaults(sym, isInJSFile(location))
		if !type_ || isErrorType(type_) {
			return nil
		}
		return type_
	}
	instantiateAliasOrInterfaceWithDefaults := func(managedSym Symbol, inJs bool, typeArguments []Type) Type {
		declaredManagedType := getDeclaredTypeOfSymbol(managedSym)
		// fetches interface type, or initializes symbol links type parmaeters
		if managedSym.flags & SymbolFlagsTypeAlias {
			params := getSymbolLinks(managedSym).typeParameters
			if length(params) >= typeArguments.length {
				args := fillMissingTypeArguments(typeArguments, params, typeArguments.length, inJs)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case length(args) == 0:
					return declaredManagedType
				default:
					return getTypeAliasInstantiation(managedSym, args)
				}
			}
		}
		if length((declaredManagedType /* as GenericType */).typeParameters) >= typeArguments.length {
			args := fillMissingTypeArguments(typeArguments, (declaredManagedType /* as GenericType */).typeParameters, typeArguments.length, inJs)
			return createTypeReference(declaredManagedType /* as GenericType */, args)
		}
		return nil
	}
	/**
	 * Returns all the properties of the Jsx.IntrinsicElements interface
	 */
	getJsxIntrinsicTagNamesAt := func(location Node) []Symbol {
		intrinsics := getJsxType(JsxNames.IntrinsicElements, location)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case intrinsics:
			return getPropertiesOfType(intrinsics)
		default:
			return emptyArray
		}
	}
	checkJsxPreconditions := func(errorNode Node) {
		// Preconditions for using JSX
		if (compilerOptions.jsx || JsxEmitNone) == JsxEmitNone {
			error(errorNode, Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided)
		}
		if getJsxElementTypeAt(errorNode) == nil {
			if noImplicitAny {
				error(errorNode, Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist)
			}
		}
	}
	checkJsxOpeningLikeElementOrOpeningFragment := func(node /* TODO(TS-TO-GO) TypeNode UnionType: JsxOpeningLikeElement | JsxOpeningFragment */ any) {
		isNodeOpeningLikeElement := isJsxOpeningLikeElement(node)
		if isNodeOpeningLikeElement {
			checkGrammarJsxElement(node)
		}
		checkJsxPreconditions(node)
		markJsxAliasReferenced(node)
		if isNodeOpeningLikeElement {
			jsxOpeningLikeNode := node
			sig := getResolvedSignature(jsxOpeningLikeNode)
			checkDeprecatedSignature(sig, node)
			elementTypeConstraint := getJsxElementTypeTypeAt(jsxOpeningLikeNode)
			if elementTypeConstraint != nil {
				tagName := jsxOpeningLikeNode.tagName
				var tagType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isJsxIntrinsicTagName(tagName):
					tagType = getStringLiteralType(intrinsicTagNameToString(tagName))
				default:
					tagType = checkExpression(tagName)
				}
				checkTypeRelatedTo(tagType, elementTypeConstraint, assignableRelation, tagName, Diagnostics.Its_type_0_is_not_a_valid_JSX_element_type, func() DiagnosticMessageChain {
					componentName := getTextOfNode(tagName)
					return chainDiagnosticMessages(nil, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName)
				})
			} else {
				checkJsxReturnAssignableToAppropriateBound(getJsxReferenceKind(jsxOpeningLikeNode), getReturnTypeOfSignature(sig), jsxOpeningLikeNode)
			}
		}
	}
	/**
	 * Check if a property with the given name is known anywhere in the given type. In an object type, a property
	 * is considered known if
	 * 1. the object type is empty and the check is for assignability, or
	 * 2. if the object type has index signatures, or
	 * 3. if the property is actually declared in the object type
	 *    (this means that 'toString', for example, is not usually a known property).
	 * 4. In a union or intersection type,
	 *    a property is considered known if it is known in any constituent type.
	 * @param targetType a type to search a given name in
	 * @param name a property name to search
	 * @param isComparingJsxAttributes a boolean flag indicating whether we are searching in JsxAttributesType
	 */
	isKnownProperty := func(targetType Type, name __String, isComparingJsxAttributes bool) bool {
		if targetType.flags & TypeFlagsObject {
			// For backwards compatibility a symbol-named property is satisfied by a string index signature. This
			// is incorrect and inconsistent with element access expressions, where it is an error, so eventually
			// we should remove this exception.
			if getPropertyOfObjectType(targetType, name) || getApplicableIndexInfoForName(targetType, name) || isLateBoundName(name) && getIndexInfoOfType(targetType, stringType) || isComparingJsxAttributes && isHyphenatedJsxName(name) {
				// For JSXAttributes, if the attribute has a hyphenated name, consider that the attribute to be known.
				return true
			}
		}
		if targetType.flags & TypeFlagsSubstitution {
			return isKnownProperty((targetType /* as SubstitutionType */).baseType, name, isComparingJsxAttributes)
		}
		if targetType.flags&TypeFlagsUnionOrIntersection && isExcessPropertyCheckTarget(targetType) {
			for _, t := range (targetType /* as UnionOrIntersectionType */).types {
				if isKnownProperty(t, name, isComparingJsxAttributes) {
					return true
				}
			}
		}
		return false
	}
	isExcessPropertyCheckTarget := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsObject && !(getObjectFlags(type_)&ObjectFlagsObjectLiteralPatternWithComputedProperties) || type_.flags&TypeFlagsNonPrimitive || type_.flags&TypeFlagsSubstitution && isExcessPropertyCheckTarget((type_ /* as SubstitutionType */).baseType) || type_.flags&TypeFlagsUnion && some((type_ /* as UnionType */).types, isExcessPropertyCheckTarget) || type_.flags&TypeFlagsIntersection && every((type_ /* as IntersectionType */).types, isExcessPropertyCheckTarget))
	}
	checkJsxExpression := func(node JsxExpression, checkMode CheckMode) Type {
		checkGrammarJsxExpression(node)
		if node.expression {
			type_ := checkExpression(node.expression, checkMode)
			if node.dotDotDotToken && type_ != anyType && !isArrayType(type_) {
				error(node, Diagnostics.JSX_spread_child_must_be_an_array_type)
			}
			return type_
		} else {
			return errorType
		}
	}
	getDeclarationNodeFlagsFromSymbol := func(s Symbol) NodeFlags {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case s.valueDeclaration:
			return getCombinedNodeFlagsCached(s.valueDeclaration)
		default:
			return 0
		}
	}
	/**
	 * Return whether this symbol is a member of a prototype somewhere
	 * Note that this is not tracked well within the compiler, so the answer may be incorrect.
	 */
	isPrototypeProperty := func(symbol Symbol) *bool {
		if symbol.flags&SymbolFlagsMethod || getCheckFlags(symbol)&CheckFlagsSyntheticMethod {
			return true
		}
		if isInJSFile(symbol.valueDeclaration) {
			parent := symbol.valueDeclaration.parent
			return parent && isBinaryExpression(parent) && getAssignmentDeclarationKind(parent) == AssignmentDeclarationKindPrototypeProperty
		}
	}
	/**
	 * Check whether the requested property access is valid.
	 * Returns true if node is a valid property access, and false otherwise.
	 * @param node The node to be checked.
	 * @param isSuper True if the access is from `super.`.
	 * @param type The type of the object whose property is being accessed. (Not the type of the property.)
	 * @param prop The symbol for the property being accessed.
	 */
	checkPropertyAccessibility := func(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | QualifiedName | PropertyAccessExpression | VariableDeclaration | ParameterDeclaration | ImportTypeNode | PropertyAssignment | ShorthandPropertyAssignment | BindingElement */ any, isSuper bool, writing bool, type_ Type, prop Symbol, reportError bool /*  = true */) bool {
		var errorNode * /* TODO(TS-TO-GO) inferred type ObjectBindingPattern | ArrayBindingPattern | PropertyName | ImportTypeNode */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case !reportError:
			errorNode = nil
		case node.kind == SyntaxKindQualifiedName:
			errorNode = node.right
		case node.kind == SyntaxKindImportType:
			errorNode = node
		case node.kind == SyntaxKindBindingElement && node.propertyName:
			errorNode = node.propertyName
		default:
			errorNode = node.name
		}
		return checkPropertyAccessibilityAtLocation(node, isSuper, writing, type_, prop, errorNode)
	}
	/**
	 * Check whether the requested property can be accessed at the requested location.
	 * Returns true if node is a valid property access, and false otherwise.
	 * @param location The location node where we want to check if the property is accessible.
	 * @param isSuper True if the access is from `super.`.
	 * @param writing True if this is a write property access, false if it is a read property access.
	 * @param containingType The type of the object whose property is being accessed. (Not the type of the property.)
	 * @param prop The symbol for the property being accessed.
	 * @param errorNode The node where we should report an invalid property access error, or undefined if we should not report errors.
	 */
	checkPropertyAccessibilityAtLocation := func(location Node, isSuper bool, writing bool, containingType Type, prop Symbol, errorNode Node) bool {
		flags := getDeclarationModifierFlagsFromSymbol(prop, writing)
		if isSuper {
			// TS 1.0 spec (April 2014): 4.8.2
			// - In a constructor, instance member function, instance member accessor, or
			//   instance member variable initializer where this references a derived class instance,
			//   a super property access is permitted and must specify a public instance member function of the base class.
			// - In a static member function or static member accessor
			//   where this references the constructor function object of a derived class,
			//   a super property access is permitted and must specify a public static member function of the base class.
			if languageVersion < ScriptTargetES2015 {
				if symbolHasNonMethodDeclaration(prop) {
					if errorNode {
						error(errorNode, Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword)
					}
					return false
				}
			}
			if flags & ModifierFlagsAbstract {
				// A method cannot be accessed in a super property access if the method is abstract.
				// This error could mask a private property access error. But, a member
				// cannot simultaneously be private and abstract, so this will trigger an
				// additional error elsewhere.
				if errorNode {
					error(errorNode, Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, symbolToString(prop), typeToString(getDeclaringClass(prop)))
				}
				return false
			}
			// A class field cannot be accessed via super.* from a derived class.
			// This is true for both [[Set]] (old) and [[Define]] (ES spec) semantics.
			if !(flags & ModifierFlagsStatic) && prop.declarations. /* TODO(TS-TO-GO): was ? */ some(isClassInstanceProperty) {
				if errorNode {
					error(errorNode, Diagnostics.Class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super, symbolToString(prop))
				}
				return false
			}
		}
		// Referencing abstract properties within their own constructors is not allowed
		if (flags & ModifierFlagsAbstract) && symbolHasNonMethodDeclaration(prop) && (isThisProperty(location) || isThisInitializedObjectBindingExpression(location) || isObjectBindingPattern(location.parent) && isThisInitializedDeclaration(location.parent.parent)) {
			declaringClassDeclaration := getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop))
			if declaringClassDeclaration && isNodeUsedDuringClassInitialization(location) {
				if errorNode {
					error(errorNode, Diagnostics.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor, symbolToString(prop), getTextOfIdentifierOrLiteral(declaringClassDeclaration.name))
				}
				return false
			}
		}
		// Public properties are otherwise accessible.
		if !(flags & ModifierFlagsNonPublicAccessibilityModifier) {
			return true
		}
		// Property is known to be private or protected at this point
		// Private property is accessible if the property is within the declaring class
		if flags & ModifierFlagsPrivate {
			declaringClassDeclaration := getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop))
			if !isNodeWithinClass(location, declaringClassDeclaration) {
				if errorNode {
					error(errorNode, Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(getDeclaringClass(prop)))
				}
				return false
			}
			return true
		}
		// Property is known to be protected at this point
		// All protected properties of a supertype are accessible in a super access
		if isSuper {
			return true
		}
		// Find the first enclosing class that has the declaring classes of the protected constituents
		// of the property as base classes
		enclosingClass := forEachEnclosingClass(location, func(enclosingDeclaration ClassLikeDeclaration) *InterfaceType {
			enclosingClass := getDeclaredTypeOfSymbol(getSymbolOfDeclaration(enclosingDeclaration)) /* as InterfaceType */
			return isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing)
		})
		// A protected property is accessible if the property is within the declaring class or classes derived from it
		if !enclosingClass {
			// allow PropertyAccessibility if context is in function with this parameter
			// static member access is disallowed
			enclosingClass = getEnclosingClassFromThisParameter(location)
			enclosingClass = enclosingClass && isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing)
			if flags&ModifierFlagsStatic || !enclosingClass {
				if errorNode {
					error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(getDeclaringClass(prop) || containingType))
				}
				return false
			}
		}
		// No further restrictions for static properties
		if flags & ModifierFlagsStatic {
			return true
		}
		if containingType.flags & TypeFlagsTypeParameter {
			// get the original type -- represented as the type constraint of the 'this' type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (containingType /* as TypeParameter */).isThisType:
				containingType = getConstraintOfTypeParameter(containingType /* as TypeParameter */)
			default:
				containingType = getBaseConstraintOfType(containingType /* as TypeParameter */)
			}
			// TODO: GH#18217 Use a different variable that's allowed to be undefined
		}
		if !containingType || !hasBaseType(containingType, enclosingClass) {
			if errorNode {
				error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2, symbolToString(prop), typeToString(enclosingClass), typeToString(containingType))
			}
			return false
		}
		return true
	}
	getEnclosingClassFromThisParameter := func(node Node) *InterfaceType {
		// 'this' type for a node comes from, in priority order...
		// 1. The type of a syntactic 'this' parameter in the enclosing function scope
		thisParameter := getThisParameterFromNodeContext(node)
		thisType := thisParameter. /* TODO(TS-TO-GO): was ? */ type_ && getTypeFromTypeNode(thisParameter.type_)
		if thisType {
			// 2. The constraint of a type parameter used for an explicit 'this' parameter
			if thisType.flags & TypeFlagsTypeParameter {
				thisType = getConstraintOfTypeParameter(thisType /* as TypeParameter */)
			}
		} else {
			// 3. The 'this' parameter of a contextual type
			thisContainer := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
			if isFunctionLike(thisContainer) {
				thisType = getContextualThisParameterType(thisContainer)
			}
		}
		if thisType && getObjectFlags(thisType)&(ObjectFlagsClassOrInterface|ObjectFlagsReference) {
			return getTargetType(thisType) /* as InterfaceType */
		}
		return nil
	}
	getThisParameterFromNodeContext := func(node Node) *ParameterDeclaration {
		thisContainer := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case thisContainer && isFunctionLike(thisContainer):
			return getThisParameter(thisContainer)
		default:
			return nil
		}
	}
	symbolHasNonMethodDeclaration := func(symbol Symbol) bool {
		return !!forEachProperty(symbol, func(prop Symbol) bool {
			return !(prop.flags & SymbolFlagsMethod)
		})
	}
	checkNonNullExpression := func(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any) Type {
		return checkNonNullType(checkExpression(node), node)
	}
	isNullableType := func(type_ Type) bool {
		return hasTypeFacts(type_, TypeFactsIsUndefinedOrNull)
	}
	getNonNullableTypeIfNeeded := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isNullableType(type_):
			return getNonNullableType(type_)
		default:
			return type_
		}
	}
	reportObjectPossiblyNullOrUndefinedError := func(node Node, facts TypeFacts) {
		var nodeText *string
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isEntityNameExpression(node):
			nodeText = entityNameToString(node)
		default:
			nodeText = nil
		}
		if node.kind == SyntaxKindNullKeyword {
			error(node, Diagnostics.The_value_0_cannot_be_used_here, "null")
			return
		}
		if nodeText != nil && nodeText.length < 100 {
			if isIdentifier(node) && nodeText == "undefined" {
				error(node, Diagnostics.The_value_0_cannot_be_used_here, "undefined")
				return
			}
			error(node, __COND__(facts&TypeFactsIsUndefined, __COND__(facts&TypeFactsIsNull, Diagnostics._0_is_possibly_null_or_undefined, Diagnostics._0_is_possibly_undefined), Diagnostics._0_is_possibly_null), nodeText)
		} else {
			error(node, __COND__(facts&TypeFactsIsUndefined, __COND__(facts&TypeFactsIsNull, Diagnostics.Object_is_possibly_null_or_undefined, Diagnostics.Object_is_possibly_undefined), Diagnostics.Object_is_possibly_null))
		}
	}
	reportCannotInvokePossiblyNullOrUndefinedError := func(node Node, facts TypeFacts) {
		error(node, __COND__(facts&TypeFactsIsUndefined, __COND__(facts&TypeFactsIsNull, Diagnostics.Cannot_invoke_an_object_which_is_possibly_null_or_undefined, Diagnostics.Cannot_invoke_an_object_which_is_possibly_undefined), Diagnostics.Cannot_invoke_an_object_which_is_possibly_null))
	}
	checkNonNullTypeWithReporter := func(type_ Type, node Node, reportError func(node Node, facts TypeFacts)) Type {
		if strictNullChecks && type_.flags&TypeFlagsUnknown {
			if isEntityNameExpression(node) {
				nodeText := entityNameToString(node)
				if nodeText.length < 100 {
					error(node, Diagnostics._0_is_of_type_unknown, nodeText)
					return errorType
				}
			}
			error(node, Diagnostics.Object_is_of_type_unknown)
			return errorType
		}
		facts := getTypeFacts(type_, TypeFactsIsUndefinedOrNull)
		if facts & TypeFactsIsUndefinedOrNull {
			reportError(node, facts)
			t := getNonNullableType(type_)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case t.flags & (TypeFlagsNullable | TypeFlagsNever):
				return errorType
			default:
				return t
			}
		}
		return type_
	}
	checkNonNullType := func(type_ Type, node Node) Type {
		return checkNonNullTypeWithReporter(type_, node, reportObjectPossiblyNullOrUndefinedError)
	}
	checkNonNullNonVoidType := func(type_ Type, node Node) Type {
		nonNullType := checkNonNullType(type_, node)
		if nonNullType.flags & TypeFlagsVoid {
			if isEntityNameExpression(node) {
				nodeText := entityNameToString(node)
				if isIdentifier(node) && nodeText == "undefined" {
					error(node, Diagnostics.The_value_0_cannot_be_used_here, nodeText)
					return nonNullType
				}
				if nodeText.length < 100 {
					error(node, Diagnostics._0_is_possibly_undefined, nodeText)
					return nonNullType
				}
			}
			error(node, Diagnostics.Object_is_possibly_undefined)
		}
		return nonNullType
	}
	checkPropertyAccessExpression := func(node PropertyAccessExpression, checkMode *CheckMode, writeOnly bool) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.flags & NodeFlagsOptionalChain:
			return checkPropertyAccessChain(node /* as PropertyAccessChain */, checkMode)
		default:
			return checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullExpression(node.expression), node.name, checkMode, writeOnly)
		}
	}
	checkPropertyAccessChain := func(node PropertyAccessChain, checkMode *CheckMode) Type {
		leftType := checkExpression(node.expression)
		nonOptionalType := getOptionalExpressionType(leftType, node.expression)
		return propagateOptionalTypeMarker(checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullType(nonOptionalType, node.expression), node.name, checkMode), node, nonOptionalType != leftType)
	}
	checkQualifiedName := func(node QualifiedName, checkMode *CheckMode) Type {
		var leftType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isPartOfTypeQuery(node) && isThisIdentifier(node.left):
			leftType = checkNonNullType(checkThisExpression(node.left), node.left)
		default:
			leftType = checkNonNullExpression(node.left)
		}
		return checkPropertyAccessExpressionOrQualifiedName(node, node.left, leftType, node.right, checkMode)
	}
	isMethodAccessForCall := func(node Node) bool {
		for node.parent.kind == SyntaxKindParenthesizedExpression {
			node = node.parent
		}
		return isCallOrNewExpression(node.parent) && node.parent.expression == node
	}
	// Lookup the private identifier lexically.
	lookupSymbolForPrivateIdentifierDeclaration := func(propName __String, location Node) Symbol {
		for containingClass := getContainingClassExcludingClassDecorators(location); !!containingClass; containingClass = getContainingClass(containingClass) {
			TODO_IDENTIFIER := containingClass
			name := getSymbolNameForPrivateIdentifier(symbol, propName)
			prop := (symbol.members && symbol.members.get(name)) || (symbol.exports && symbol.exports.get(name))
			if prop {
				return prop
			}
		}
	}
	checkGrammarPrivateIdentifierExpression := func(privId PrivateIdentifier) bool {
		if !getContainingClass(privId) {
			return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		}
		if !isForInStatement(privId.parent) {
			if !isExpressionNode(privId) {
				return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression)
			}
			isInOperation := isBinaryExpression(privId.parent) && privId.parent.operatorToken.kind == SyntaxKindInKeyword
			if !getSymbolForPrivateIdentifierExpression(privId) && !isInOperation {
				return grammarErrorOnNode(privId, Diagnostics.Cannot_find_name_0, idText(privId))
			}
		}
		return false
	}
	checkPrivateIdentifierExpression := func(privId PrivateIdentifier) Type {
		checkGrammarPrivateIdentifierExpression(privId)
		symbol := getSymbolForPrivateIdentifierExpression(privId)
		if symbol {
			markPropertyAsReferenced(symbol /*nodeForCheckWriteOnly*/, nil /*isSelfTypeAccess*/, false)
		}
		return anyType
	}
	getSymbolForPrivateIdentifierExpression := func(privId PrivateIdentifier) Symbol {
		if !isExpressionNode(privId) {
			return nil
		}
		links := getNodeLinks(privId)
		if links.resolvedSymbol == nil {
			links.resolvedSymbol = lookupSymbolForPrivateIdentifierDeclaration(privId.escapedText, privId)
		}
		return links.resolvedSymbol
	}
	getPrivateIdentifierPropertyOfType := func(leftType Type, lexicallyScopedIdentifier Symbol) Symbol {
		return getPropertyOfType(leftType, lexicallyScopedIdentifier.escapedName)
	}
	checkPrivateIdentifierPropertyAccess := func(leftType Type, right PrivateIdentifier, lexicallyScopedIdentifier Symbol) bool {
		// Either the identifier could not be looked up in the lexical scope OR the lexically scoped identifier did not exist on the type.
		// Find a private identifier with the same description on the type.
		var propertyOnType Symbol
		properties := getPropertiesOfType(leftType)
		if properties {
			forEach(properties, func(symbol Symbol) *true {
				decl := symbol.valueDeclaration
				if decl && isNamedDeclaration(decl) && isPrivateIdentifier(decl.name) && decl.name.escapedText == right.escapedText {
					propertyOnType = symbol
					return true
				}
			})
		}
		diagName := diagnosticName(right)
		if propertyOnType {
			typeValueDecl := Debug.checkDefined(propertyOnType.valueDeclaration)
			typeClass := Debug.checkDefined(getContainingClass(typeValueDecl))
			// We found a private identifier property with the same description.
			// Either:
			// - There is a lexically scoped private identifier AND it shadows the one we found on the type.
			// - It is an attempt to access the private identifier outside of the class.
			if lexicallyScopedIdentifier. /* TODO(TS-TO-GO): was ? */ valueDeclaration {
				lexicalValueDecl := lexicallyScopedIdentifier.valueDeclaration
				lexicalClass := getContainingClass(lexicalValueDecl)
				Debug.assert(!!lexicalClass)
				if findAncestor(lexicalClass, func(n Node) bool {
					return typeClass == n
				}) {
					diagnostic := error(right, Diagnostics.The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling, diagName, typeToString(leftType))
					addRelatedInfo(diagnostic, createDiagnosticForNode(lexicalValueDecl, Diagnostics.The_shadowing_declaration_of_0_is_defined_here, diagName), createDiagnosticForNode(typeValueDecl, Diagnostics.The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here, diagName))
					return true
				}
			}
			error(right, Diagnostics.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier, diagName, diagnosticName(typeClass.name || anon))
			return true
		}
		return false
	}
	isThisPropertyAccessInConstructor := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop Symbol) *bool {
		return (isConstructorDeclaredProperty(prop) || isThisProperty(node) && isAutoTypedProperty(prop)) && getThisContainer(node /*includeArrowFunctions*/, true /*includeClassComputedPropertyName*/, false) == getDeclaringConstructor(prop)
	}
	checkPropertyAccessExpressionOrQualifiedName := func(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | QualifiedName */ any, left /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any, leftType Type, right /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier */ any, checkMode *CheckMode, writeOnly bool) Type {
		parentSymbol := getNodeLinks(left).resolvedSymbol
		assignmentKind := getAssignmentTargetKind(node)
		apparentType := getApparentType(__COND__(assignmentKind != AssignmentKindNone || isMethodAccessForCall(node), getWidenedType(leftType), leftType))
		isAnyLike := isTypeAny(apparentType) || apparentType == silentNeverType
		var prop Symbol
		if isPrivateIdentifier(right) {
			if languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !useDefineForClassFields {
				if assignmentKind != AssignmentKindNone {
					checkExternalEmitHelpers(node, ExternalEmitHelpersClassPrivateFieldSet)
				}
				if assignmentKind != AssignmentKindDefinite {
					checkExternalEmitHelpers(node, ExternalEmitHelpersClassPrivateFieldGet)
				}
			}
			lexicallyScopedSymbol := lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right)
			if assignmentKind && lexicallyScopedSymbol && lexicallyScopedSymbol.valueDeclaration && isMethodDeclaration(lexicallyScopedSymbol.valueDeclaration) {
				grammarErrorOnNode(right, Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable, idText(right))
			}
			if isAnyLike {
				if lexicallyScopedSymbol {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isErrorType(apparentType):
						return errorType
					default:
						return apparentType
					}
				}
				if getContainingClassExcludingClassDecorators(right) == nil {
					grammarErrorOnNode(right, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
					return anyType
				}
			}
			prop = lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedSymbol)
			if prop == nil {
				// Check for private-identifier-specific shadowing and lexical-scoping errors.
				if checkPrivateIdentifierPropertyAccess(leftType, right, lexicallyScopedSymbol) {
					return errorType
				}
				containingClass := getContainingClassExcludingClassDecorators(right)
				if containingClass && isPlainJsFile(getSourceFileOfNode(containingClass), compilerOptions.checkJs) {
					grammarErrorOnNode(right, Diagnostics.Private_field_0_must_be_declared_in_an_enclosing_class, idText(right))
				}
			} else {
				isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
				if isSetonlyAccessor && assignmentKind != AssignmentKindDefinite {
					error(node, Diagnostics.Private_accessor_was_defined_without_a_getter)
				}
			}
		} else {
			if isAnyLike {
				if isIdentifier(left) && parentSymbol {
					markLinkedReferences(node, ReferenceHintProperty /*propSymbol*/, nil, leftType)
				}
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isErrorType(apparentType):
					return errorType
				default:
					return apparentType
				}
			}
			prop = getPropertyOfType(apparentType, right.escapedText /*skipObjectFunctionPropertyAugment*/, isConstEnumObjectType(apparentType) /*includeTypeOnlyMembers*/, node.kind == SyntaxKindQualifiedName)
		}
		markLinkedReferences(node, ReferenceHintProperty, prop, leftType)
		var propType Type
		if !prop {
			var indexInfo *IndexInfo
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !isPrivateIdentifier(right) && (assignmentKind == AssignmentKindNone || !isGenericObjectType(leftType) || isThisTypeParameter(leftType)):
				indexInfo = getApplicableIndexInfoForName(apparentType, right.escapedText)
			default:
				indexInfo = nil
			}
			if !(indexInfo && indexInfo.type_) {
				isUncheckedJS := isUncheckedJSSuggestion(node, leftType.symbol /*excludeClasses*/, true)
				if !isUncheckedJS && isJSLiteralType(leftType) {
					return anyType
				}
				if leftType.symbol == globalThisSymbol {
					if globalThisSymbol.exports.has(right.escapedText) && (globalThisSymbol.exports.get(right.escapedText).flags & SymbolFlagsBlockScoped) {
						error(right, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(right.escapedText), typeToString(leftType))
					} else if noImplicitAny {
						error(right, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature, typeToString(leftType))
					}
					return anyType
				}
				if right.escapedText && !checkAndReportErrorForExtendingInterface(node) {
					reportNonexistentProperty(right, __COND__(isThisTypeParameter(leftType), apparentType, leftType), isUncheckedJS)
				}
				return errorType
			}
			if indexInfo.isReadonly && (isAssignmentTarget(node) || isDeleteTarget(node)) {
				error(node, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(apparentType))
			}
			propType = indexInfo.type_
			if compilerOptions.noUncheckedIndexedAccess && getAssignmentTargetKind(node) != AssignmentKindDefinite {
				propType = getUnionType([]Type{propType, missingType})
			}
			if compilerOptions.noPropertyAccessFromIndexSignature && isPropertyAccessExpression(node) {
				error(right, Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0, unescapeLeadingUnderscores(right.escapedText))
			}
			if indexInfo.declaration && isDeprecatedDeclaration(indexInfo.declaration) {
				addDeprecatedSuggestion(right, []IndexSignatureDeclaration{indexInfo.declaration}, right.escapedText /* as string */)
			}
		} else {
			targetPropSymbol := resolveAliasWithDeprecationCheck(prop, right)
			if isDeprecatedSymbol(targetPropSymbol) && isUncalledFunctionReference(node, targetPropSymbol) && targetPropSymbol.declarations {
				addDeprecatedSuggestion(right, targetPropSymbol.declarations, right.escapedText /* as string */)
			}
			checkPropertyNotUsedBeforeDeclaration(prop, node, right)
			markPropertyAsReferenced(prop, node, isSelfTypeAccess(left, parentSymbol))
			getNodeLinks(node).resolvedSymbol = prop
			checkPropertyAccessibility(node, left.kind == SyntaxKindSuperKeyword, isWriteAccess(node), apparentType, prop)
			if isAssignmentToReadonlyEntity(node /* as Expression */, prop, assignmentKind) {
				error(right, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, idText(right))
				return errorType
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isThisPropertyAccessInConstructor(node, prop):
				propType = autoType
			case writeOnly || isWriteOnlyAccess(node):
				propType = getWriteTypeOfSymbol(prop)
			default:
				propType = getTypeOfSymbol(prop)
			}
		}
		return getFlowTypeOfAccessExpression(node, prop, propType, right, checkMode)
	}
	/**
	 * Determines whether a did-you-mean error should be a suggestion in an unchecked JS file.
	 * Only applies to unchecked JS files without checkJS, // @ts-check or // @ts-nocheck
	 * It does not suggest when the suggestion:
	 * - Is from a global file that is different from the reference file, or
	 * - (optionally) Is a class, or is a this.x property access expression
	 */
	isUncheckedJSSuggestion := func(node Node, suggestion Symbol, excludeClasses bool) bool {
		file := getSourceFileOfNode(node)
		if file {
			if compilerOptions.checkJs == nil && file.checkJsDirective == nil && (file.scriptKind == ScriptKindJS || file.scriptKind == ScriptKindJSX) {
				declarationFile := forEach(suggestion. /* TODO(TS-TO-GO): was ? */ declarations, getSourceFileOfNode)
				suggestionHasNoExtendsOrDecorators := !suggestion. /* TODO(TS-TO-GO): was ? */ valueDeclaration || !isClassLike(suggestion.valueDeclaration) || suggestion.valueDeclaration.heritageClauses. /* TODO(TS-TO-GO): was ? */ length || classOrConstructorParameterIsDecorated(false, suggestion.valueDeclaration)
				return !(file != declarationFile && !!declarationFile && isGlobalSourceFile(declarationFile)) && !(excludeClasses && suggestion && suggestion.flags&SymbolFlagsClass && suggestionHasNoExtendsOrDecorators) && !(!!node && excludeClasses && isPropertyAccessExpression(node) && node.expression.kind == SyntaxKindThisKeyword && suggestionHasNoExtendsOrDecorators)
			}
		}
		return false
	}
	getFlowTypeOfAccessExpression := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop Symbol, propType Type, errorNode Node, checkMode *CheckMode) Type {
		// Only compute control flow type if this is a property access expression that isn't an
		// assignment target, and the referenced property was declared as a variable, property,
		// accessor, or optional method.
		assignmentKind := getAssignmentTargetKind(node)
		if assignmentKind == AssignmentKindDefinite {
			return removeMissingType(propType, !!(prop && prop.flags&SymbolFlagsOptional))
		}
		if prop && !(prop.flags & (SymbolFlagsVariable | SymbolFlagsProperty | SymbolFlagsAccessor)) && !(prop.flags&SymbolFlagsMethod && propType.flags&TypeFlagsUnion) && !isDuplicatedCommonJSExport(prop.declarations) {
			return propType
		}
		if propType == autoType {
			return getFlowTypeOfProperty(node, prop)
		}
		propType = getNarrowableTypeForReference(propType, node, checkMode)
		// If strict null checks and strict property initialization checks are enabled, if we have
		// a this.xxx property access, if the property is an instance property without an initializer,
		// and if we are in a constructor of the same class as the property declaration, assume that
		// the property is uninitialized at the top of the control flow.
		assumeUninitialized := false
		if strictNullChecks && strictPropertyInitialization && isAccessExpression(node) && node.expression.kind == SyntaxKindThisKeyword {
			declaration := prop && prop.valueDeclaration
			if declaration && isPropertyWithoutInitializer(declaration) {
				if !isStatic(declaration) {
					flowContainer := getControlFlowContainer(node)
					if flowContainer.kind == SyntaxKindConstructor && flowContainer.parent == declaration.parent && !(declaration.flags & NodeFlagsAmbient) {
						assumeUninitialized = true
					}
				}
			}
		} else if strictNullChecks && prop && prop.valueDeclaration && isPropertyAccessExpression(prop.valueDeclaration) && getAssignmentDeclarationPropertyAccessKind(prop.valueDeclaration) && getControlFlowContainer(node) == getControlFlowContainer(prop.valueDeclaration) {
			assumeUninitialized = true
		}
		flowType := getFlowTypeOfReference(node, propType, __COND__(assumeUninitialized, getOptionalType(propType), propType))
		if assumeUninitialized && !containsUndefinedType(propType) && containsUndefinedType(flowType) {
			error(errorNode, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(prop))
			// Return the declared type to reduce follow-on errors
			return propType
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case assignmentKind:
			return getBaseTypeOfLiteralType(flowType)
		default:
			return flowType
		}
	}
	checkPropertyNotUsedBeforeDeclaration := func(prop Symbol, node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | QualifiedName */ any, right /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier */ any) {
		TODO_IDENTIFIER := prop
		if !valueDeclaration || getSourceFileOfNode(node).isDeclarationFile {
			return
		}
		var diagnosticMessage TODO
		declarationName := idText(right)
		if isInPropertyInitializerOrClassStaticBlock(node) && !isOptionalPropertyDeclaration(valueDeclaration) && !(isAccessExpression(node) && isAccessExpression(node.expression)) && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) && !(isMethodDeclaration(valueDeclaration) && getCombinedModifierFlagsCached(valueDeclaration)&ModifierFlagsStatic) && (useDefineForClassFields || !isPropertyDeclaredInAncestorClass(prop)) {
			diagnosticMessage = error(right, Diagnostics.Property_0_is_used_before_its_initialization, declarationName)
		} else if valueDeclaration.kind == SyntaxKindClassDeclaration && node.parent.kind != SyntaxKindTypeReference && !(valueDeclaration.flags & NodeFlagsAmbient) && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) {
			diagnosticMessage = error(right, Diagnostics.Class_0_used_before_its_declaration, declarationName)
		}
		if diagnosticMessage {
			addRelatedInfo(diagnosticMessage, createDiagnosticForNode(valueDeclaration, Diagnostics._0_is_declared_here, declarationName))
		}
	}
	isInPropertyInitializerOrClassStaticBlock := func(node Node) bool {
		return !!findAncestor(node, func(node Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			switch node.kind {
			case SyntaxKindPropertyDeclaration:
				return true
			case SyntaxKindPropertyAssignment:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindSetAccessor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindSpreadAssignment:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindComputedPropertyName:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindTemplateSpan:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJsxExpression:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJsxAttribute:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJsxAttributes:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJsxSpreadAttribute:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJsxOpeningElement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindExpressionWithTypeArguments:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindHeritageClause:
				return false
			case SyntaxKindArrowFunction:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindExpressionStatement:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isBlock(node.parent) && isClassStaticBlockDeclaration(node.parent.parent):
					return true
				default:
					return "quit"
				}
			default:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isExpressionNode(node):
					return false
				default:
					return "quit"
				}
			}
		})
	}
	/**
	 * It's possible that "prop.valueDeclaration" is a local declaration, but the property was also declared in a superclass.
	 * In that case we won't consider it used before its declaration, because it gets its value from the superclass' declaration.
	 */
	isPropertyDeclaredInAncestorClass := func(prop Symbol) bool {
		if !(prop.parent.flags & SymbolFlagsClass) {
			return false
		}
		var classType *InterfaceType = getTypeOfSymbol(prop.parent) /* as InterfaceType */
		for true {
			classType = classType.symbol && getSuperClass(classType) /* as InterfaceType | undefined */
			if !classType {
				return false
			}
			superProperty := getPropertyOfType(classType, prop.escapedName)
			if superProperty && superProperty.valueDeclaration {
				return true
			}
		}
	}
	getSuperClass := func(classType InterfaceType) Type {
		x := getBaseTypes(classType)
		if x.length == 0 {
			return nil
		}
		return getIntersectionType(x)
	}
	reportNonexistentProperty := func(propNode /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier */ any, containingType Type, isUncheckedJS bool) {
		var errorInfo *DiagnosticMessageChain
		var relatedInfo *Diagnostic
		if !isPrivateIdentifier(propNode) && containingType.flags&TypeFlagsUnion && !(containingType.flags & TypeFlagsPrimitive) {
			for _, subtype := range (containingType /* as UnionType */).types {
				if !getPropertyOfType(subtype, propNode.escapedText) && !getApplicableIndexInfoForName(subtype, propNode.escapedText) {
					errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(subtype))
					break
				}
			}
		}
		if typeHasStaticProperty(propNode.escapedText, containingType) {
			propName := declarationNameToString(propNode)
			typeName := typeToString(containingType)
			errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName, typeName+"."+propName)
		} else {
			promisedType := getPromisedTypeOfPromise(containingType)
			if promisedType && getPropertyOfType(promisedType, propNode.escapedText) {
				errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(containingType))
				relatedInfo = createDiagnosticForNode(propNode, Diagnostics.Did_you_forget_to_use_await)
			} else {
				missingProperty := declarationNameToString(propNode)
				container := typeToString(containingType)
				libSuggestion := getSuggestedLibForNonExistentProperty(missingProperty, containingType)
				if libSuggestion != nil {
					errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later, missingProperty, container, libSuggestion)
				} else {
					suggestion := getSuggestedSymbolForNonexistentProperty(propNode, containingType)
					if suggestion != nil {
						suggestedName := symbolName(suggestion)
						var message DiagnosticMessage
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isUncheckedJS:
							message = Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2
						default:
							message = Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2
						}
						errorInfo = chainDiagnosticMessages(errorInfo, message, missingProperty, container, suggestedName)
						relatedInfo = suggestion.valueDeclaration && createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestedName)
					} else {
						var diagnostic DiagnosticMessage
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case containerSeemsToBeEmptyDomElement(containingType):
							diagnostic = Diagnostics.Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom
						default:
							diagnostic = Diagnostics.Property_0_does_not_exist_on_type_1
						}
						errorInfo = chainDiagnosticMessages(elaborateNeverIntersection(errorInfo, containingType), diagnostic, missingProperty, container)
					}
				}
			}
		}
		resultDiagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(propNode), propNode, errorInfo)
		if relatedInfo {
			addRelatedInfo(resultDiagnostic, relatedInfo)
		}
		addErrorOrSuggestion(!isUncheckedJS || errorInfo.code != Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2.code, resultDiagnostic)
	}
	containerSeemsToBeEmptyDomElement := func(containingType Type) *bool {
		return (compilerOptions.lib && !compilerOptions.lib.includes("dom")) && everyContainedType(containingType, func(type_ Type) bool {
			return type_.symbol && regexp.MustParse(`^(?:EventTarget|Node|(?:HTML[a-zA-Z]*)?Element)$`).test(unescapeLeadingUnderscores(type_.symbol.escapedName))
		}) && isEmptyObjectType(containingType)
	}
	typeHasStaticProperty := func(propName __String, containingType Type) bool {
		prop := containingType.symbol && getPropertyOfType(getTypeOfSymbol(containingType.symbol), propName)
		return prop != nil && !!prop.valueDeclaration && isStatic(prop.valueDeclaration)
	}
	getSuggestedLibForNonExistentName := func(name /* TODO(TS-TO-GO) TypeNode UnionType: __String | Identifier */ any) *string {
		missingName := diagnosticName(name)
		allFeatures := getScriptTargetFeatures()
		typeFeatures := allFeatures.get(missingName)
		return typeFeatures && firstIterator(typeFeatures.keys())
	}
	getSuggestedLibForNonExistentProperty := func(missingProperty string, containingType Type) *string {
		container := getApparentType(containingType).symbol
		if !container {
			return nil
		}
		containingTypeName := symbolName(container)
		allFeatures := getScriptTargetFeatures()
		typeFeatures := allFeatures.get(containingTypeName)
		if typeFeatures {
			for _, TODO_IDENTIFIER := range typeFeatures {
				if contains(featuresOfType, missingProperty) {
					return libTarget
				}
			}
		}
	}
	getSuggestedSymbolForNonexistentClassMember := func(name string, baseType Type) Symbol {
		return getSpellingSuggestionForName(name, getPropertiesOfType(baseType), SymbolFlagsClassMember)
	}
	getSuggestedSymbolForNonexistentProperty := func(name /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier | string */ any, containingType Type) Symbol {
		props := getPropertiesOfType(containingType)
		if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof name */ TODO != "string" {
			parent := name.parent
			if isPropertyAccessExpression(parent) {
				props = filter(props, func(prop Symbol) bool {
					return isValidPropertyAccessForCompletions(parent, containingType, prop)
				})
			}
			name = idText(name)
		}
		return getSpellingSuggestionForName(name, props, SymbolFlagsValue)
	}
	getSuggestedSymbolForNonexistentJSXAttribute := func(name /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier | string */ any, containingType Type) Symbol {
		var strName string
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isString(name):
			strName = name
		default:
			strName = idText(name)
		}
		properties := getPropertiesOfType(containingType)
		var jsxSpecific Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case strName == "for":
			jsxSpecific = find(properties, func(x Symbol) bool {
				return symbolName(x) == "htmlFor"
			})
		case strName == "class":
			jsxSpecific = find(properties, func(x Symbol) bool {
				return symbolName(x) == "className"
			})
		default:
			jsxSpecific = nil
		}
		return /* TODO(TS-TO-GO) Node BinaryExpression: jsxSpecific ?? getSpellingSuggestionForName(strName, properties, SymbolFlags.Value) */ TODO
	}
	getSuggestionForNonexistentProperty := func(name /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier | string */ any, containingType Type) *string {
		suggestion := getSuggestedSymbolForNonexistentProperty(name, containingType)
		return suggestion && symbolName(suggestion)
	}
	getSuggestionForSymbolNameLookup := func(symbols SymbolTable, name __String, meaning SymbolFlags) Symbol {
		symbol := getSymbol(symbols, name, meaning)
		// Sometimes the symbol is found when location is a return type of a function: `typeof x` and `x` is declared in the body of the function
		// So the table *contains* `x` but `x` isn't actually in scope.
		// However, resolveNameHelper will continue and call this callback again, so we'll eventually get a correct suggestion.
		if symbol {
			return symbol
		}
		var candidates []Symbol
		if symbols == globals {
			primitives := mapDefined([]string{"string", "number", "boolean", "object", "bigint", "symbol"}, func(s string) Symbol {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case symbols.has((s.charAt(0).toUpperCase() + s.slice(1)) /* as __String */):
					return createSymbol(SymbolFlagsTypeAlias, s /* as __String */) /* as Symbol */
				default:
					return nil
				}
			})
			candidates = primitives.concat(arrayFrom(symbols.values()))
		} else {
			candidates = arrayFrom(symbols.values())
		}
		return getSpellingSuggestionForName(unescapeLeadingUnderscores(name), candidates, meaning)
	}
	getSuggestedSymbolForNonexistentSymbol := func(location Node, outerName __String, meaning SymbolFlags) Symbol {
		Debug.assert(outerName != nil, "outername should always be defined")
		result := resolveNameForSymbolSuggestion(location, outerName, meaning /*nameNotFoundMessage*/, nil /*isUse*/, false /*excludeGlobals*/, false)
		return result
	}
	getSuggestedSymbolForNonexistentModule := func(name Identifier, targetModule Symbol) Symbol {
		return targetModule.exports && getSpellingSuggestionForName(idText(name), getExportsOfModuleAsArray(targetModule), SymbolFlagsModuleMember)
	}
	getSuggestionForNonexistentIndexSignature := func(objectType Type, expr ElementAccessExpression, keyedType Type) *string {
		// check if object type has setter or getter
		hasProp := func(name /* TODO(TS-TO-GO) TypeNode UnionType: "set" | "get" */ any) bool {
			prop := getPropertyOfObjectType(objectType, name /* as __String */)
			if prop {
				s := getSingleCallSignature(getTypeOfSymbol(prop))
				return !!s && getMinArgumentCount(s) >= 1 && isTypeAssignableTo(keyedType, getTypeAtPosition(s, 0))
			}
			return false
		}
		var suggestedMethod /* TODO(TS-TO-GO) inferred type "set" | "get" */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isAssignmentTarget(expr):
			suggestedMethod = "set"
		default:
			suggestedMethod = "get"
		}
		if !hasProp(suggestedMethod) {
			return nil
		}
		suggestion := tryGetPropertyAccessOrIdentifierToString(expr.expression)
		if suggestion == nil {
			suggestion = suggestedMethod
		} else {
			suggestion += "." + suggestedMethod
		}
		return suggestion
	}
	getSuggestedTypeForNonexistentStringLiteralType := func(source StringLiteralType, target UnionType) *StringLiteralType {
		candidates := target.types.filter(func(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is StringLiteralType */ any {
			return !!(type_.flags & TypeFlagsStringLiteral)
		})
		return getSpellingSuggestion(source.value, candidates, func(type_ StringLiteralType) string {
			return type_.value
		})
	}
	/**
	 * Given a name and a list of symbols whose names are *not* equal to the name, return a spelling suggestion if there is one that is close enough.
	 * Names less than length 3 only check for case-insensitive equality, not levenshtein distance.
	 *
	 * If there is a candidate that's the same except for case, return that.
	 * If there is a candidate that's within one edit of the name, return that.
	 * Otherwise, return the candidate with the smallest Levenshtein distance,
	 *    except for candidates:
	 *      * With no name
	 *      * Whose meaning doesn't match the `meaning` parameter.
	 *      * Whose length differs from the target name by more than 0.34 of the length of the name.
	 *      * Whose levenshtein distance is more than 0.4 of the length of the name
	 *        (0.4 allows 1 substitution/transposition for every 5 characters,
	 *         and 1 insertion/deletion at 3 characters)
	 */
	getSpellingSuggestionForName := func(name string, symbols []Symbol, meaning SymbolFlags) Symbol {
		return getSpellingSuggestion(name, symbols, getCandidateName)
		getCandidateName := func(candidate Symbol) *string {
			candidateName := symbolName(candidate)
			if startsWith(candidateName, '"') {
				return nil
			}
			if candidate.flags & meaning {
				return candidateName
			}
			if candidate.flags & SymbolFlagsAlias {
				alias := tryResolveAlias(candidate)
				if alias && alias.flags&meaning {
					return candidateName
				}
			}
			return nil
		}
	}
	markPropertyAsReferenced := func(prop Symbol, nodeForCheckWriteOnly Node, isSelfTypeAccess bool) {
		valueDeclaration := prop && (prop.flags & SymbolFlagsClassMember) && prop.valueDeclaration
		if !valueDeclaration {
			return
		}
		hasPrivateModifier := hasEffectiveModifier(valueDeclaration, ModifierFlagsPrivate)
		hasPrivateIdentifier := prop.valueDeclaration && isNamedDeclaration(prop.valueDeclaration) && isPrivateIdentifier(prop.valueDeclaration.name)
		if !hasPrivateModifier && !hasPrivateIdentifier {
			return
		}
		if nodeForCheckWriteOnly && isWriteOnlyAccess(nodeForCheckWriteOnly) && !(prop.flags & SymbolFlagsSetAccessor) {
			return
		}
		if isSelfTypeAccess {
			// Find any FunctionLikeDeclaration because those create a new 'this' binding. But this should only matter for methods (or getters/setters).
			containingMethod := findAncestor(nodeForCheckWriteOnly, isFunctionLikeDeclaration)
			if containingMethod && containingMethod.symbol == prop {
				return
			}
		}
		(__COND__(getCheckFlags(prop)&CheckFlagsInstantiated, getSymbolLinks(prop).target, prop)).isReferenced = SymbolFlagsAll
	}
	isSelfTypeAccess := func(name /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any, parent Symbol) bool {
		return name.kind == SyntaxKindThisKeyword || !!parent && isEntityNameExpression(name) && parent == getResolvedSymbol(getFirstIdentifier(name))
	}
	isValidPropertyAccess := func(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, propertyName __String) bool {
		switch node.kind {
		case SyntaxKindPropertyAccessExpression:
			return isValidPropertyAccessWithType(node, node.expression.kind == SyntaxKindSuperKeyword, propertyName, getWidenedType(checkExpression(node.expression)))
		case SyntaxKindQualifiedName:
			return isValidPropertyAccessWithType(node /*isSuper*/, false, propertyName, getWidenedType(checkExpression(node.left)))
		case SyntaxKindImportType:
			return isValidPropertyAccessWithType(node /*isSuper*/, false, propertyName, getTypeFromTypeNode(node))
		}
	}
	/**
	 * Checks if an existing property access is valid for completions purposes.
	 * @param node a property access-like node where we want to check if we can access a property.
	 * This node does not need to be an access of the property we are checking.
	 * e.g. in completions, this node will often be an incomplete property access node, as in `foo.`.
	 * Besides providing a location (i.e. scope) used to check property accessibility, we use this node for
	 * computing whether this is a `super` property access.
	 * @param type the type whose property we are checking.
	 * @param property the accessed property's symbol.
	 */
	isValidPropertyAccessForCompletions := func(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | ImportTypeNode | QualifiedName */ any, type_ Type, property Symbol) bool {
		return isPropertyAccessible(node, node.kind == SyntaxKindPropertyAccessExpression && node.expression.kind == SyntaxKindSuperKeyword /*isWrite*/, false, type_, property)
		// Previously we validated the 'this' type of methods but this adversely affected performance. See #31377 for more context.
	}
	isValidPropertyAccessWithType := func(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, isSuper bool, propertyName __String, type_ Type) bool {
		// Short-circuiting for improved performance.
		if isTypeAny(type_) {
			return true
		}
		prop := getPropertyOfType(type_, propertyName)
		return !!prop && isPropertyAccessible(node, isSuper /*isWrite*/, false, type_, prop)
	}
	/**
	 * Checks if a property can be accessed in a location.
	 * The location is given by the `node` parameter.
	 * The node does not need to be a property access.
	 * @param node location where to check property accessibility
	 * @param isSuper whether to consider this a `super` property access, e.g. `super.foo`.
	 * @param isWrite whether this is a write access, e.g. `++foo.x`.
	 * @param containingType type where the property comes from.
	 * @param property property symbol.
	 */
	isPropertyAccessible := func(node Node, isSuper bool, isWrite bool, containingType Type, property Symbol) bool {
		// Short-circuiting for improved performance.
		if isTypeAny(containingType) {
			return true
		}
		// A #private property access in an optional chain is an error dealt with by the parser.
		// The checker does not check for it, so we need to do our own check here.
		if property.valueDeclaration && isPrivateIdentifierClassElementDeclaration(property.valueDeclaration) {
			declClass := getContainingClass(property.valueDeclaration)
			return !isOptionalChain(node) && !!findAncestor(node, func(parent Node) bool {
				return parent == declClass
			})
		}
		return checkPropertyAccessibilityAtLocation(node, isSuper, isWrite, containingType, property)
	}
	/**
	 * Return the symbol of the for-in variable declared or referenced by the given for-in statement.
	 */
	getForInVariableSymbol := func(node ForInStatement) Symbol {
		initializer := node.initializer
		if initializer.kind == SyntaxKindVariableDeclarationList {
			variable := (initializer /* as VariableDeclarationList */).declarations[0]
			if variable && !isBindingPattern(variable.name) {
				return getSymbolOfDeclaration(variable)
			}
		} else if initializer.kind == SyntaxKindIdentifier {
			return getResolvedSymbol(initializer /* as Identifier */)
		}
		return nil
	}
	/**
	 * Return true if the given type is considered to have numeric property names.
	 */
	hasNumericPropertyNames := func(type_ Type) bool {
		return getIndexInfosOfType(type_).length == 1 && !!getIndexInfoOfType(type_, numberType)
	}
	/**
	 * Return true if given node is an expression consisting of an identifier (possibly parenthesized)
	 * that references a for-in variable for an object with numeric property names.
	 */
	isForInVariableForNumericPropertyNames := func(expr Expression) bool {
		e := skipParentheses(expr)
		if e.kind == SyntaxKindIdentifier {
			symbol := getResolvedSymbol(e /* as Identifier */)
			if symbol.flags & SymbolFlagsVariable {
				var child Node = expr
				node := expr.parent
				for node {
					if node.kind == SyntaxKindForInStatement && child == (node /* as ForInStatement */).statement && getForInVariableSymbol(node /* as ForInStatement */) == symbol && hasNumericPropertyNames(getTypeOfExpression((node /* as ForInStatement */).expression)) {
						return true
					}
					child = node
					node = node.parent
				}
			}
		}
		return false
	}
	checkIndexedAccess := func(node ElementAccessExpression, checkMode *CheckMode) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.flags & NodeFlagsOptionalChain:
			return checkElementAccessChain(node /* as ElementAccessChain */, checkMode)
		default:
			return checkElementAccessExpression(node, checkNonNullExpression(node.expression), checkMode)
		}
	}
	checkElementAccessChain := func(node ElementAccessChain, checkMode *CheckMode) Type {
		exprType := checkExpression(node.expression)
		nonOptionalType := getOptionalExpressionType(exprType, node.expression)
		return propagateOptionalTypeMarker(checkElementAccessExpression(node, checkNonNullType(nonOptionalType, node.expression), checkMode), node, nonOptionalType != exprType)
	}
	checkElementAccessExpression := func(node ElementAccessExpression, exprType Type, checkMode *CheckMode) Type {
		var objectType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getAssignmentTargetKind(node) != AssignmentKindNone || isMethodAccessForCall(node):
			objectType = getWidenedType(exprType)
		default:
			objectType = exprType
		}
		indexExpression := node.argumentExpression
		indexType := checkExpression(indexExpression)
		if isErrorType(objectType) || objectType == silentNeverType {
			return objectType
		}
		if isConstEnumObjectType(objectType) && !isStringLiteralLike(indexExpression) {
			error(indexExpression, Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal)
			return errorType
		}
		var effectiveIndexType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isForInVariableForNumericPropertyNames(indexExpression):
			effectiveIndexType = numberType
		default:
			effectiveIndexType = indexType
		}
		assignmentTargetKind := getAssignmentTargetKind(node)
		var accessFlags AccessFlags
		if assignmentTargetKind == AssignmentKindNone {
			accessFlags = AccessFlagsExpressionPosition
		} else {
			accessFlags = AccessFlagsWriting | (__COND__(isGenericObjectType(objectType) && !isThisTypeParameter(objectType), AccessFlagsNoIndexSignatures, 0))
			if assignmentTargetKind == AssignmentKindCompound {
				accessFlags |= AccessFlagsExpressionPosition
			}
		}
		indexedAccessType := getIndexedAccessTypeOrUndefined(objectType, effectiveIndexType, accessFlags, node) || errorType
		return checkIndexedAccessIndexType(getFlowTypeOfAccessExpression(node, getNodeLinks(node).resolvedSymbol, indexedAccessType, indexExpression, checkMode), node)
	}
	callLikeExpressionMayHaveTypeArguments := func(node CallLikeExpression) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement */ any {
		return isCallOrNewExpression(node) || isTaggedTemplateExpression(node) || isJsxOpeningLikeElement(node)
	}
	resolveUntypedCall := func(node CallLikeExpression) Signature {
		if callLikeExpressionMayHaveTypeArguments(node) {
			// Check type arguments even though we will give an error that untyped calls may not accept type arguments.
			// This gets us diagnostics for the type arguments and marks them as referenced.
			forEach(node.typeArguments, checkSourceElement)
		}
		if node.kind == SyntaxKindTaggedTemplateExpression {
			checkExpression(node.template)
		} else if isJsxOpeningLikeElement(node) {
			checkExpression(node.attributes)
		} else if isBinaryExpression(node) {
			checkExpression(node.left)
		} else if isCallOrNewExpression(node) {
			forEach(node.arguments, func(argument Expression) {
				checkExpression(argument)
			})
		}
		return anySignature
	}
	resolveErrorCall := func(node CallLikeExpression) Signature {
		resolveUntypedCall(node)
		return unknownSignature
	}
	// Re-order candidate signatures into the result array. Assumes the result array to be empty.
	// The candidate list orders groups in reverse, but within a group signatures are kept in declaration order
	// A nit here is that we reorder only signatures that belong to the same symbol,
	// so order how inherited signatures are processed is still preserved.
	// interface A { (x: string): void }
	// interface B extends A { (x: 'foo'): string }
	// const b: B;
	// b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]
	reorderCandidates := func(signatures []Signature, result []Signature, callChainFlags SignatureFlags) {
		var lastParent Node
		var lastSymbol Symbol
		cutoffIndex := 0
		var index *number
		specializedIndex := -1
		var spliceIndex number
		Debug.assert(!result.length)
		for _, signature := range signatures {
			symbol := signature.declaration && getSymbolOfDeclaration(signature.declaration)
			parent := signature.declaration && signature.declaration.parent
			if !lastSymbol || symbol == lastSymbol {
				if lastParent && parent == lastParent {
					index = index + 1
				} else {
					lastParent = parent
					index = cutoffIndex
				}
			} else {
				// current declaration belongs to a different symbol
				// set cutoffIndex so re-orderings in the future won't change result set from 0 to cutoffIndex
				index = /* TODO(TS-TO-GO) Node BinaryExpression: cutoffIndex = result.length */ TODO
				lastParent = parent
			}
			lastSymbol = symbol
			// specialized signatures always need to be placed before non-specialized signatures regardless
			// of the cutoff position; see GH#1133
			if signatureHasLiteralTypes(signature) {
				specializedIndex++
				spliceIndex = specializedIndex
				// The cutoff index always needs to be greater than or equal to the specialized signature index
				// in order to prevent non-specialized signatures from being added before a specialized
				// signature.
				cutoffIndex++
			} else {
				spliceIndex = index
			}
			result.splice(spliceIndex, 0, __COND__(callChainFlags, getOptionalCallSignature(signature, callChainFlags), signature))
		}
	}
	isSpreadArgument := func(arg Expression) /* TODO(TS-TO-GO) TypeNode TypePredicate: arg is Expression */ any {
		return !!arg && (arg.kind == SyntaxKindSpreadElement || arg.kind == SyntaxKindSyntheticExpression && (arg /* as SyntheticExpression */).isSpread)
	}
	getSpreadArgumentIndex := func(args []Expression) number {
		return findIndex(args, isSpreadArgument)
	}
	acceptsVoid := func(t Type) bool {
		return !!(t.flags & TypeFlagsVoid)
	}
	acceptsVoidUndefinedUnknownOrAny := func(t Type) bool {
		return !!(t.flags & (TypeFlagsVoid | TypeFlagsUndefined | TypeFlagsUnknown | TypeFlagsAny))
	}
	hasCorrectArity := func(node CallLikeExpression, args []Expression, signature Signature, signatureHelpTrailingComma bool /*  = false */) bool {
		var argCount number
		callIsIncomplete := false
		// In incomplete call we want to be lenient when we have too few arguments
		effectiveParameterCount := getParameterCount(signature)
		effectiveMinimumArguments := getMinArgumentCount(signature)
		if node.kind == SyntaxKindTaggedTemplateExpression {
			argCount = args.length
			if node.template.kind == SyntaxKindTemplateExpression {
				// If a tagged template expression lacks a tail literal, the call is incomplete.
				// Specifically, a template only can end in a TemplateTail or a Missing literal.
				lastSpan := last(node.template.templateSpans)
				// we should always have at least one span.
				callIsIncomplete = nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated
			} else {
				// If the template didn't end in a backtick, or its beginning occurred right prior to EOF,
				// then this might actually turn out to be a TemplateHead in the future;
				// so we consider the call to be incomplete.
				templateLiteral := node.template /* as LiteralExpression */
				Debug.assert(templateLiteral.kind == SyntaxKindNoSubstitutionTemplateLiteral)
				callIsIncomplete = !!templateLiteral.isUnterminated
			}
		} else if node.kind == SyntaxKindDecorator {
			argCount = getDecoratorArgumentCount(node, signature)
		} else if node.kind == SyntaxKindBinaryExpression {
			argCount = 1
		} else if isJsxOpeningLikeElement(node) {
			callIsIncomplete = node.attributes.end == node.end
			if callIsIncomplete {
				return true
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case effectiveMinimumArguments == 0:
				argCount = args.length
			default:
				argCount = 1
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case args.length == 0:
				effectiveParameterCount = effectiveParameterCount
			default:
				effectiveParameterCount = 1
			}
			// class may have argumentless ctor functions - still resolve ctor and compare vs props member type
			effectiveMinimumArguments = Math.min(effectiveMinimumArguments, 1)
			// sfc may specify context argument - handled by framework and not typechecked
		} else if !node.arguments {
			// This only happens when we have something of the form: 'new C'
			Debug.assert(node.kind == SyntaxKindNewExpression)
			return getMinArgumentCount(signature) == 0
		} else {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case signatureHelpTrailingComma:
				argCount = args.length + 1
			default:
				argCount = args.length
			}
			// If we are missing the close parenthesis, the call is incomplete.
			callIsIncomplete = node.arguments.end == node.end
			// If a spread argument is present, check that it corresponds to a rest parameter or at least that it's in the valid range.
			spreadArgIndex := getSpreadArgumentIndex(args)
			if spreadArgIndex >= 0 {
				return spreadArgIndex >= getMinArgumentCount(signature) && (hasEffectiveRestParameter(signature) || spreadArgIndex < getParameterCount(signature))
			}
		}
		// Too many arguments implies incorrect arity.
		if !hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount {
			return false
		}
		// If the call is incomplete, we should skip the lower bound check.
		// JSX signatures can have extra parameters provided by the library which we don't check
		if callIsIncomplete || argCount >= effectiveMinimumArguments {
			return true
		}
		for i := argCount; i < effectiveMinimumArguments; i++ {
			type_ := getTypeAtPosition(signature, i)
			if filterType(type_, __COND__(isInJSFile(node) && !strictNullChecks, acceptsVoidUndefinedUnknownOrAny, acceptsVoid)).flags & TypeFlagsNever {
				return false
			}
		}
		return true
	}
	hasCorrectTypeArgumentArity := func(signature Signature, typeArguments *NodeArray[TypeNode]) bool {
		// If the user supplied type arguments, but the number of type arguments does not match
		// the declared number of type parameters, the call has an incorrect arity.
		numTypeParameters := length(signature.typeParameters)
		minTypeArgumentCount := getMinTypeArgumentCount(signature.typeParameters)
		return !some(typeArguments) || (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters)
	}
	isInstantiatedGenericParameter := func(signature Signature, pos number) bool {
		var type_ TODO
		return !!(signature.target && ( /* TODO(TS-TO-GO) Node BinaryExpression: type = tryGetTypeAtPosition(signature.target, pos) */ TODO) && isGenericType(type_))
	}
	// If type has a single call signature and no other members, return that signature. Otherwise, return undefined.
	getSingleCallSignature := func(type_ Type) *Signature {
		return getSingleSignature(type_, SignatureKindCall /*allowMembers*/, false)
	}
	getSingleCallOrConstructSignature := func(type_ Type) *Signature {
		return getSingleSignature(type_, SignatureKindCall /*allowMembers*/, false) || getSingleSignature(type_, SignatureKindConstruct /*allowMembers*/, false)
	}
	getSingleSignature := func(type_ Type, kind SignatureKind, allowMembers bool) *Signature {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_ /* as ObjectType */)
			if allowMembers || resolved.properties.length == 0 && resolved.indexInfos.length == 0 {
				if kind == SignatureKindCall && resolved.callSignatures.length == 1 && resolved.constructSignatures.length == 0 {
					return resolved.callSignatures[0]
				}
				if kind == SignatureKindConstruct && resolved.constructSignatures.length == 1 && resolved.callSignatures.length == 0 {
					return resolved.constructSignatures[0]
				}
			}
		}
		return nil
	}
	// Instantiate a generic signature in the context of a non-generic signature (section 3.8.5 in TypeScript spec)
	instantiateSignatureInContextOf := func(signature Signature, contextualSignature Signature, inferenceContext InferenceContext, compareTypes TypeComparer) Signature {
		context := createInferenceContext(getTypeParametersForMapper(signature), signature, InferenceFlagsNone, compareTypes)
		// We clone the inferenceContext to avoid fixing. For example, when the source signature is <T>(x: T) => T[] and
		// the contextual signature is (...args: A) => B, we want to infer the element type of A's constraint (say 'any')
		// for T but leave it possible to later infer '[any]' back to A.
		restType := getEffectiveRestType(contextualSignature)
		mapper := inferenceContext && (__COND__(restType && restType.flags&TypeFlagsTypeParameter, inferenceContext.nonFixingMapper, inferenceContext.mapper))
		var sourceSignature Signature
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case mapper:
			sourceSignature = instantiateSignature(contextualSignature, mapper)
		default:
			sourceSignature = contextualSignature
		}
		applyToParameterTypes(sourceSignature, signature, func(source Type, target Type) {
			// Type parameters from outer context referenced by source type are fixed by instantiation of the source type
			inferTypes(context.inferences, source, target)
		})
		if !inferenceContext {
			applyToReturnTypes(contextualSignature, signature, func(source Type, target Type) {
				inferTypes(context.inferences, source, target, InferencePriorityReturnType)
			})
		}
		return getSignatureInstantiation(signature, getInferredTypes(context), isInJSFile(contextualSignature.declaration))
	}
	inferJsxTypeArguments := func(node JsxOpeningLikeElement, signature Signature, checkMode CheckMode, context InferenceContext) []Type {
		paramType := getEffectiveFirstArgumentForJsxSignature(signature, node)
		checkAttrType := checkExpressionWithContextualType(node.attributes, paramType, context, checkMode)
		inferTypes(context.inferences, checkAttrType, paramType)
		return getInferredTypes(context)
	}
	getThisArgumentType := func(thisArgumentNode Expression) Type {
		if !thisArgumentNode {
			return voidType
		}
		thisArgumentType := checkExpression(thisArgumentNode)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isRightSideOfInstanceofExpression(thisArgumentNode):
			return thisArgumentType
		case isOptionalChainRoot(thisArgumentNode.parent):
			return getNonNullableType(thisArgumentType)
		case isOptionalChain(thisArgumentNode.parent):
			return removeOptionalTypeMarker(thisArgumentType)
		default:
			return thisArgumentType
		}
	}
	inferTypeArguments := func(node CallLikeExpression, signature Signature, args []Expression, checkMode CheckMode, context InferenceContext) []Type {
		if isJsxOpeningLikeElement(node) {
			return inferJsxTypeArguments(node, signature, checkMode, context)
		}
		// If a contextual type is available, infer from that type to the return type of the call expression. For
		// example, given a 'function wrap<T, U>(cb: (x: T) => U): (x: T) => U' and a call expression
		// 'let f: (x: string) => number = wrap(s => s.length)', we infer from the declared type of 'f' to the
		// return type of 'wrap'.
		if node.kind != SyntaxKindDecorator && node.kind != SyntaxKindBinaryExpression {
			skipBindingPatterns := every(signature.typeParameters, func(p TypeParameter) bool {
				return !!getDefaultFromTypeParameter(p)
			})
			contextualType := getContextualType(node, __COND__(skipBindingPatterns, ContextFlagsSkipBindingPatterns, ContextFlagsNone))
			if contextualType {
				inferenceTargetType := getReturnTypeOfSignature(signature)
				if couldContainTypeVariables(inferenceTargetType) {
					outerContext := getInferenceContext(node)
					isFromBindingPattern := !skipBindingPatterns && getContextualType(node, ContextFlagsSkipBindingPatterns) != contextualType
					// A return type inference from a binding pattern can be used in instantiating the contextual
					// type of an argument later in inference, but cannot stand on its own as the final return type.
					// It is incorporated into `context.returnMapper` which is used in `instantiateContextualType`,
					// but doesn't need to go into `context.inferences`. This allows a an array binding pattern to
					// produce a tuple for `T` in
					//   declare function f<T>(cb: () => T): T;
					//   const [e1, e2, e3] = f(() => [1, "hi", true]);
					// but does not produce any inference for `T` in
					//   declare function f<T>(): T;
					//   const [e1, e2, e3] = f();
					if !isFromBindingPattern {
						// We clone the inference context to avoid disturbing a resolution in progress for an
						// outer call expression. Effectively we just want a snapshot of whatever has been
						// inferred for any outer call expression so far.
						outerMapper := getMapperFromContext(cloneInferenceContext(outerContext, InferenceFlagsNoDefault))
						instantiatedType := instantiateType(contextualType, outerMapper)
						// If the contextual type is a generic function type with a single call signature, we
						// instantiate the type with its own type parameters and type arguments. This ensures that
						// the type parameters are not erased to type any during type inference such that they can
						// be inferred as actual types from the contextual type. For example:
						//   declare function arrayMap<T, U>(f: (x: T) => U): (a: T[]) => U[];
						//   const boxElements: <A>(a: A[]) => { value: A }[] = arrayMap(value => ({ value }));
						// Above, the type of the 'value' parameter is inferred to be 'A'.
						contextualSignature := getSingleCallSignature(instantiatedType)
						var inferenceSourceType Type
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case contextualSignature && contextualSignature.typeParameters:
							inferenceSourceType = getOrCreateTypeFromSignature(getSignatureInstantiationWithoutFillingInTypeArguments(contextualSignature, contextualSignature.typeParameters))
						default:
							inferenceSourceType = instantiatedType
						}
						// Inferences made from return types have lower priority than all other inferences.
						inferTypes(context.inferences, inferenceSourceType, inferenceTargetType, InferencePriorityReturnType)
					}
					// Create a type mapper for instantiating generic contextual types using the inferences made
					// from the return type. We need a separate inference pass here because (a) instantiation of
					// the source type uses the outer context's return mapper (which excludes inferences made from
					// outer arguments), and (b) we don't want any further inferences going into this context.
					returnContext := createInferenceContext(signature.typeParameters, signature, context.flags)
					returnSourceType := instantiateType(contextualType, outerContext && outerContext.returnMapper)
					inferTypes(returnContext.inferences, returnSourceType, inferenceTargetType)
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case some(returnContext.inferences, hasInferenceCandidates):
						context.returnMapper = getMapperFromContext(cloneInferredPartOfContext(returnContext))
					default:
						context.returnMapper = nil
					}
				}
			}
		}
		restType := getNonArrayRestType(signature)
		var argCount number
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case restType:
			argCount = Math.min(getParameterCount(signature)-1, args.length)
		default:
			argCount = args.length
		}
		if restType && restType.flags&TypeFlagsTypeParameter {
			info := find(context.inferences, func(info InferenceInfo) bool {
				return info.typeParameter == restType
			})
			if info {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case findIndex(args, isSpreadArgument, argCount) < 0:
					info.impliedArity = args.length - argCount
				default:
					info.impliedArity = nil
				}
			}
		}
		thisType := getThisTypeOfSignature(signature)
		if thisType && couldContainTypeVariables(thisType) {
			thisArgumentNode := getThisArgumentOfCall(node)
			inferTypes(context.inferences, getThisArgumentType(thisArgumentNode), thisType)
		}
		for i := 0; i < argCount; i++ {
			arg := args[i]
			if arg.kind != SyntaxKindOmittedExpression {
				paramType := getTypeAtPosition(signature, i)
				if couldContainTypeVariables(paramType) {
					argType := checkExpressionWithContextualType(arg, paramType, context, checkMode)
					inferTypes(context.inferences, argType, paramType)
				}
			}
		}
		if restType && couldContainTypeVariables(restType) {
			spreadType := getSpreadArgumentType(args, argCount, args.length, restType, context, checkMode)
			inferTypes(context.inferences, spreadType, restType)
		}
		return getInferredTypes(context)
	}
	getMutableArrayOrTupleType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnion:
			return mapType(type_, getMutableArrayOrTupleType)
		case type_.flags&TypeFlagsAny || isMutableArrayOrTuple(getBaseConstraintOfType(type_) || type_):
			return type_
		case isTupleType(type_):
			return createTupleType(getElementTypes(type_), type_.target.elementFlags /*readonly*/, false, type_.target.labeledElementDeclarations)
		default:
			return createTupleType([]Type{type_}, [] /* TODO(TS-TO-GO) inferred type ElementFlags.Variadic */ any{ElementFlagsVariadic})
		}
	}
	getSpreadArgumentType := func(args []Expression, index number, argCount number, restType Type, context *InferenceContext, checkMode CheckMode) Type {
		inConstContext := isConstTypeVariable(restType)
		if index >= argCount-1 {
			arg := args[argCount-1]
			if isSpreadArgument(arg) {
				// We are inferring from a spread expression in the last argument position, i.e. both the parameter
				// and the argument are ...x forms.
				var spreadType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case arg.kind == SyntaxKindSyntheticExpression:
					spreadType = (arg /* as SyntheticExpression */).type_
				default:
					spreadType = checkExpressionWithContextualType((arg /* as SpreadElement */).expression, restType, context, checkMode)
				}
				if isArrayLikeType(spreadType) {
					return getMutableArrayOrTupleType(spreadType)
				}
				return createArrayType(checkIteratedTypeOrElementType(IterationUseSpread, spreadType, undefinedType, __COND__(arg.kind == SyntaxKindSpreadElement, (arg /* as SpreadElement */).expression, arg)), inConstContext)
			}
		}
		types := []never{}
		flags := []never{}
		names := []never{}
		for i := index; i < argCount; i++ {
			arg := args[i]
			if isSpreadArgument(arg) {
				var spreadType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case arg.kind == SyntaxKindSyntheticExpression:
					spreadType = (arg /* as SyntheticExpression */).type_
				default:
					spreadType = checkExpression((arg /* as SpreadElement */).expression)
				}
				if isArrayLikeType(spreadType) {
					types.push(spreadType)
					flags.push(ElementFlagsVariadic)
				} else {
					types.push(checkIteratedTypeOrElementType(IterationUseSpread, spreadType, undefinedType, __COND__(arg.kind == SyntaxKindSpreadElement, (arg /* as SpreadElement */).expression, arg)))
					flags.push(ElementFlagsRest)
				}
			} else {
				var contextualType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isTupleType(restType):
					contextualType = getContextualTypeForElementExpression(restType, i-index, argCount-index) || unknownType
				default:
					contextualType = getIndexedAccessType(restType, getNumberLiteralType(i-index), AccessFlagsContextual)
				}
				argType := checkExpressionWithContextualType(arg, contextualType, context, checkMode)
				hasPrimitiveContextualType := inConstContext || maybeTypeOfKind(contextualType, TypeFlagsPrimitive|TypeFlagsIndex|TypeFlagsTemplateLiteral|TypeFlagsStringMapping)
				types.push(__COND__(hasPrimitiveContextualType, getRegularTypeOfLiteralType(argType), getWidenedLiteralType(argType)))
				flags.push(ElementFlagsRequired)
			}
			if arg.kind == SyntaxKindSyntheticExpression && (arg /* as SyntheticExpression */).tupleNameSource {
				names.push((arg /* as SyntheticExpression */).tupleNameSource)
			} else {
				names.push(nil)
			}
		}
		return createTupleType(types, flags, inConstContext && !someType(restType, isMutableArrayLikeType), names)
	}
	checkTypeArguments := func(signature Signature, typeArgumentNodes []TypeNode, reportErrors bool, headMessage DiagnosticMessage) *[]Type {
		isJavascript := isInJSFile(signature.declaration)
		typeParameters := signature.typeParameters
		typeArgumentTypes := fillMissingTypeArguments(map_(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript)
		var mapper *TypeMapper
		for i := 0; i < typeArgumentNodes.length; i++ {
			Debug.assert(typeParameters[i] != nil, "Should not call checkTypeArguments with too many type arguments")
			constraint := getConstraintOfTypeParameter(typeParameters[i])
			if constraint {
				var errorInfo * /* TODO(TS-TO-GO) inferred type (() => DiagnosticMessageChain) */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case reportErrors && headMessage:
					errorInfo = (func() DiagnosticMessageChain {
						return chainDiagnosticMessages(nil, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)
					})
				default:
					errorInfo = nil
				}
				typeArgumentHeadMessage := headMessage || Diagnostics.Type_0_does_not_satisfy_the_constraint_1
				if !mapper {
					mapper = createTypeMapper(typeParameters, typeArgumentTypes)
				}
				typeArgument := typeArgumentTypes[i]
				if !checkTypeAssignableTo(typeArgument, getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument), __COND__(reportErrors, typeArgumentNodes[i], nil), typeArgumentHeadMessage, errorInfo) {
					return nil
				}
			}
		}
		return typeArgumentTypes
	}
	getJsxReferenceKind := func(node JsxOpeningLikeElement) JsxReferenceKind {
		if isJsxIntrinsicTagName(node.tagName) {
			return JsxReferenceKindMixed
		}
		tagType := getApparentType(checkExpression(node.tagName))
		if length(getSignaturesOfType(tagType, SignatureKindConstruct)) {
			return JsxReferenceKindComponent
		}
		if length(getSignaturesOfType(tagType, SignatureKindCall)) {
			return JsxReferenceKindFunction
		}
		return JsxReferenceKindMixed
	}
	/**
	 * Check if the given signature can possibly be a signature called by the JSX opening-like element.
	 * @param node a JSX opening-like element we are trying to figure its call signature
	 * @param signature a candidate signature we are trying whether it is a call signature
	 * @param relation a relationship to check parameter and argument type
	 */
	checkApplicableSignatureForJsxOpeningLikeElement := func(node JsxOpeningLikeElement, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		// Stateless function components can have maximum of three arguments: "props", "context", and "updater".
		// However "context" and "updater" are implicit and can't be specify by users. Only the first parameter, props,
		// can be specified by users through attributes property.
		paramType := getEffectiveFirstArgumentForJsxSignature(signature, node)
		attributesType := checkExpressionWithContextualType(node.attributes, paramType /*inferenceContext*/, nil, checkMode)
		var checkAttributesType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case checkMode & CheckModeSkipContextSensitive:
			checkAttributesType = getRegularTypeOfObjectLiteral(attributesType)
		default:
			checkAttributesType = attributesType
		}
		return checkTagNameDoesNotExpectTooManyArguments() && checkTypeRelatedToAndOptionallyElaborate(checkAttributesType, paramType, relation, __COND__(reportErrors, node.tagName, nil), node.attributes, nil, containingMessageChain, errorOutputContainer)
		checkTagNameDoesNotExpectTooManyArguments := func() bool {
			if getJsxNamespaceContainerForImplicitImport(node) {
				return true
				// factory is implicitly jsx/jsxdev - assume it fits the bill, since we don't strongly look for the jsx/jsxs/jsxDEV factory APIs anywhere else (at least not yet)
			}
			var tagType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (isJsxOpeningElement(node) || isJsxSelfClosingElement(node)) && !(isJsxIntrinsicTagName(node.tagName) || isJsxNamespacedName(node.tagName)):
				tagType = checkExpression(node.tagName)
			default:
				tagType = nil
			}
			if !tagType {
				return true
			}
			tagCallSignatures := getSignaturesOfType(tagType, SignatureKindCall)
			if !length(tagCallSignatures) {
				return true
			}
			factory := getJsxFactoryEntity(node)
			if !factory {
				return true
			}
			factorySymbol := resolveEntityName(factory, SymbolFlagsValue /*ignoreErrors*/, true /*dontResolveAlias*/, false, node)
			if !factorySymbol {
				return true
			}
			factoryType := getTypeOfSymbol(factorySymbol)
			callSignatures := getSignaturesOfType(factoryType, SignatureKindCall)
			if !length(callSignatures) {
				return true
			}
			hasFirstParamSignatures := false
			maxParamCount := 0
			// Check that _some_ first parameter expects a FC-like thing, and that some overload of the SFC expects an acceptable number of arguments
			for _, sig := range callSignatures {
				firstparam := getTypeAtPosition(sig, 0)
				signaturesOfParam := getSignaturesOfType(firstparam, SignatureKindCall)
				if !length(signaturesOfParam) {
					continue
				}
				for _, paramSig := range signaturesOfParam {
					hasFirstParamSignatures = true
					if hasEffectiveRestParameter(paramSig) {
						return true
						// some signature has a rest param, so function components can have an arbitrary number of arguments
					}
					paramCount := getParameterCount(paramSig)
					if paramCount > maxParamCount {
						maxParamCount = paramCount
					}
				}
			}
			if !hasFirstParamSignatures {
				// Not a single signature had a first parameter which expected a signature - for back compat, and
				// to guard against generic factories which won't have signatures directly, do not error
				return true
			}
			absoluteMinArgCount := Infinity
			for _, tagSig := range tagCallSignatures {
				tagRequiredArgCount := getMinArgumentCount(tagSig)
				if tagRequiredArgCount < absoluteMinArgCount {
					absoluteMinArgCount = tagRequiredArgCount
				}
			}
			if absoluteMinArgCount <= maxParamCount {
				return true
				// some signature accepts the number of arguments the function component provides
			}
			if reportErrors {
				diag := createDiagnosticForNode(node.tagName, Diagnostics.Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3, entityNameToString(node.tagName), absoluteMinArgCount, entityNameToString(factory), maxParamCount)
				tagNameDeclaration := getSymbolAtLocation(node.tagName). /* TODO(TS-TO-GO): was ? */ valueDeclaration
				if tagNameDeclaration {
					addRelatedInfo(diag, createDiagnosticForNode(tagNameDeclaration, Diagnostics._0_is_declared_here, entityNameToString(node.tagName)))
				}
				if errorOutputContainer && errorOutputContainer.skipLogging {
					(errorOutputContainer.errors || ( /* TODO(TS-TO-GO) Node BinaryExpression: errorOutputContainer.errors = [] */ TODO)).push(diag)
				}
				if !errorOutputContainer.skipLogging {
					diagnostics.add(diag)
				}
			}
			return false
		}
	}
	getEffectiveCheckNode := func(argument Expression) Expression {
		argument = skipParentheses(argument)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isSatisfiesExpression(argument):
			return skipParentheses(argument.expression)
		default:
			return argument
		}
	}
	getSignatureApplicabilityError := func(node CallLikeExpression, args []Expression, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain *func() *DiagnosticMessageChain, inferenceContext *InferenceContext) *[]Diagnostic {
		var errorOutputContainer /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any = map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"errors":      nil,
			"skipLogging": true,
		}
		if isJsxOpeningLikeElement(node) {
			if !checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors, containingMessageChain, errorOutputContainer) {
				Debug.assert(!reportErrors || !!errorOutputContainer.errors, "jsx should have errors when reporting errors")
				return errorOutputContainer.errors || emptyArray
			}
			return nil
		}
		thisType := getThisTypeOfSignature(signature)
		if thisType && thisType != voidType && !(isNewExpression(node) || isCallExpression(node) && isSuperProperty(node.expression)) {
			// If the called expression is not of the form `x.f` or `x["f"]`, then sourceType = voidType
			// If the signature's 'this' type is voidType, then the check is skipped -- anything is compatible.
			// If the expression is a new expression or super call expression, then the check is skipped.
			thisArgumentNode := getThisArgumentOfCall(node)
			thisArgumentType := getThisArgumentType(thisArgumentNode)
			var errorNode * /* TODO(TS-TO-GO) inferred type Expression | Decorator */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case reportErrors:
				errorNode = (thisArgumentNode || node)
			default:
				errorNode = nil
			}
			headMessage := Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1
			if !checkTypeRelatedTo(thisArgumentType, thisType, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer) {
				Debug.assert(!reportErrors || !!errorOutputContainer.errors, "this parameter should have errors when reporting errors")
				return errorOutputContainer.errors || emptyArray
			}
		}
		headMessage := Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1
		restType := getNonArrayRestType(signature)
		var argCount number
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case restType:
			argCount = Math.min(getParameterCount(signature)-1, args.length)
		default:
			argCount = args.length
		}
		for i := 0; i < argCount; i++ {
			arg := args[i]
			if arg.kind != SyntaxKindOmittedExpression {
				paramType := getTypeAtPosition(signature, i)
				argType := checkExpressionWithContextualType(arg, paramType /*inferenceContext*/, nil, checkMode)
				// If one or more arguments are still excluded (as indicated by CheckMode.SkipContextSensitive),
				// we obtain the regular type of any object literal arguments because we may not have inferred complete
				// parameter types yet and therefore excess property checks may yield false positives (see #17041).
				var regularArgType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case checkMode & CheckModeSkipContextSensitive:
					regularArgType = getRegularTypeOfObjectLiteral(argType)
				default:
					regularArgType = argType
				}
				// If this was inferred under a given inference context, we may need to instantiate the expression type to finish resolving
				// the type variables in the expression.
				var checkArgType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case inferenceContext:
					checkArgType = instantiateType(regularArgType, inferenceContext.nonFixingMapper)
				default:
					checkArgType = regularArgType
				}
				effectiveCheckArgumentNode := getEffectiveCheckNode(arg)
				if !checkTypeRelatedToAndOptionallyElaborate(checkArgType, paramType, relation, __COND__(reportErrors, effectiveCheckArgumentNode, nil), effectiveCheckArgumentNode, headMessage, containingMessageChain, errorOutputContainer) {
					Debug.assert(!reportErrors || !!errorOutputContainer.errors, "parameter should have errors when reporting errors")
					maybeAddMissingAwaitInfo(arg, checkArgType, paramType)
					return errorOutputContainer.errors || emptyArray
				}
			}
		}
		if restType {
			spreadType := getSpreadArgumentType(args, argCount, args.length, restType /*context*/, nil, checkMode)
			restArgCount := args.length - argCount
			var errorNode * /* TODO(TS-TO-GO) inferred type Expression | Decorator */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !reportErrors:
				errorNode = nil
			case restArgCount == 0:
				errorNode = node
			case restArgCount == 1:
				errorNode = getEffectiveCheckNode(args[argCount])
			default:
				errorNode = setTextRangePosEnd(createSyntheticExpression(node, spreadType), args[argCount].pos, args[args.length-1].end)
			}
			if !checkTypeRelatedTo(spreadType, restType, relation, errorNode, headMessage /*containingMessageChain*/, nil, errorOutputContainer) {
				Debug.assert(!reportErrors || !!errorOutputContainer.errors, "rest parameter should have errors when reporting errors")
				maybeAddMissingAwaitInfo(errorNode, spreadType, restType)
				return errorOutputContainer.errors || emptyArray
			}
		}
		return nil
		maybeAddMissingAwaitInfo := func(errorNode Node, source Type, target Type) {
			if errorNode && reportErrors && errorOutputContainer.errors && errorOutputContainer.errors.length {
				// Bail if target is Promise-like---something else is wrong
				if getAwaitedTypeOfPromise(target) {
					return
				}
				awaitedTypeOfSource := getAwaitedTypeOfPromise(source)
				if awaitedTypeOfSource && isTypeRelatedTo(awaitedTypeOfSource, target, relation) {
					addRelatedInfo(errorOutputContainer.errors[0], createDiagnosticForNode(errorNode, Diagnostics.Did_you_forget_to_use_await))
				}
			}
		}
	}
	/**
	 * Returns the this argument in calls like x.f(...) and x[f](...). Undefined otherwise.
	 */
	getThisArgumentOfCall := func(node CallLikeExpression) Expression {
		if node.kind == SyntaxKindBinaryExpression {
			return node.right
		}
		var expression *LeftHandSideExpression
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.kind == SyntaxKindCallExpression:
			expression = node.expression
		case node.kind == SyntaxKindTaggedTemplateExpression:
			expression = node.tag
		case node.kind == SyntaxKindDecorator && !legacyDecorators:
			expression = node.expression
		default:
			expression = nil
		}
		if expression {
			callee := skipOuterExpressions(expression)
			if isAccessExpression(callee) {
				return callee.expression
			}
		}
	}
	createSyntheticExpression := func(parent Node, type_ Type, isSpread bool, tupleNameSource /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | NamedTupleMember */ any) SyntheticExpression {
		result := parseNodeFactory.createSyntheticExpression(type_, isSpread, tupleNameSource)
		setTextRangeWorker(result, parent)
		setParent(result, parent)
		return result
	}
	/**
	 * Returns the effective arguments for an expression that works like a function invocation.
	 */
	getEffectiveCallArguments := func(node CallLikeExpression) []Expression {
		if node.kind == SyntaxKindTaggedTemplateExpression {
			template := node.template
			var args []Expression = []SyntheticExpression{createSyntheticExpression(template, getGlobalTemplateStringsArrayType())}
			if template.kind == SyntaxKindTemplateExpression {
				forEach(template.templateSpans, func(span TemplateSpan) {
					args.push(span.expression)
				})
			}
			return args
		}
		if node.kind == SyntaxKindDecorator {
			return getEffectiveDecoratorArguments(node)
		}
		if node.kind == SyntaxKindBinaryExpression {
			return []Expression{node.left}
		}
		if isJsxOpeningLikeElement(node) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node.attributes.properties.length > 0 || (isJsxOpeningElement(node) && node.parent.children.length > 0):
				return []JsxAttributes{node.attributes}
			default:
				return emptyArray
			}
		}
		args := node.arguments || emptyArray
		spreadIndex := getSpreadArgumentIndex(args)
		if spreadIndex >= 0 {
			// Create synthetic arguments from spreads of tuple types.
			effectiveArgs := args.slice(0, spreadIndex)
			for i := spreadIndex; i < args.length; i++ {
				arg := args[i]
				// We can call checkExpressionCached because spread expressions never have a contextual type.
				spreadType := arg.kind == SyntaxKindSpreadElement && (__COND__(flowLoopCount, checkExpression((arg /* as SpreadElement */).expression), checkExpressionCached((arg /* as SpreadElement */).expression)))
				if spreadType && isTupleType(spreadType) {
					forEach(getElementTypes(spreadType), func(t Type, i number) {
						flags := spreadType.target.elementFlags[i]
						syntheticArg := createSyntheticExpression(arg, __COND__(flags&ElementFlagsRest, createArrayType(t), t), !!(flags & ElementFlagsVariable), spreadType.target.labeledElementDeclarations[i])
						effectiveArgs.push(syntheticArg)
					})
				} else {
					effectiveArgs.push(arg)
				}
			}
			return effectiveArgs
		}
		return args
	}
	/**
	 * Returns the synthetic argument list for a decorator invocation.
	 */
	getEffectiveDecoratorArguments := func(node Decorator) []Expression {
		expr := node.expression
		signature := getDecoratorCallSignature(node)
		if signature {
			var args []Expression = []never{}
			for _, param := range signature.parameters {
				type_ := getTypeOfSymbol(param)
				args.push(createSyntheticExpression(expr, type_))
			}
			return args
		}
		return Debug.fail()
	}
	/**
	 * Returns the argument count for a decorator node that works like a function invocation.
	 */
	getDecoratorArgumentCount := func(node Decorator, signature Signature) number {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case compilerOptions.experimentalDecorators:
			return getLegacyDecoratorArgumentCount(node, signature)
		default:
			return Math.min(Math.max(getParameterCount(signature), 1), 2)
		}
	}
	/**
	 * Returns the argument count for a decorator node that works like a function invocation.
	 */
	getLegacyDecoratorArgumentCount := func(node Decorator, signature Signature) /* TODO(TS-TO-GO) inferred type 1 | 3 | 2 */ any {
		switch node.parent.kind {
		case SyntaxKindClassDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindClassExpression:
			return 1
		case SyntaxKindPropertyDeclaration:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case hasAccessorModifier(node.parent):
				return 3
			default:
				return 2
			}
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindSetAccessor:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case signature.parameters.length <= 2:
				return 2
			default:
				return 3
			}
		case SyntaxKindParameter:
			return 3
		default:
			return Debug.fail()
		}
	}
	getDiagnosticSpanForCallNode := func(node CallExpression) /* TODO(TS-TO-GO) inferred type { start: number; length: number; sourceFile: SourceFile; } */ any {
		sourceFile := getSourceFileOfNode(node)
		TODO_IDENTIFIER := getErrorSpanForNode(sourceFile, __COND__(isPropertyAccessExpression(node.expression), node.expression.name, node.expression))
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"start":      start,
			"length":     length,
			"sourceFile": sourceFile,
		}
	}
	getDiagnosticForCallNode := func(node CallLikeExpression, message /* TODO(TS-TO-GO) TypeNode UnionType: DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) DiagnosticWithLocation {
		if isCallExpression(node) {
			TODO_IDENTIFIER := getDiagnosticSpanForCallNode(node)
			if /* TODO(TS-TO-GO) Node BinaryExpression: "message" in message */ TODO {
				return createFileDiagnostic(sourceFile, start, length, message, args...)
			}
			return createDiagnosticForFileFromMessageChain(sourceFile, message)
		} else {
			if /* TODO(TS-TO-GO) Node BinaryExpression: "message" in message */ TODO {
				return createDiagnosticForNode(node, message, args...)
			}
			return createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), node, message)
		}
	}
	getErrorNodeForCallNode := func(callLike CallLikeExpression) Node {
		if isCallOrNewExpression(callLike) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isPropertyAccessExpression(callLike.expression):
				return callLike.expression.name
			default:
				return callLike.expression
			}
		}
		if isTaggedTemplateExpression(callLike) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isPropertyAccessExpression(callLike.tag):
				return callLike.tag.name
			default:
				return callLike.tag
			}
		}
		if isJsxOpeningLikeElement(callLike) {
			return callLike.tagName
		}
		return callLike
	}
	isPromiseResolveArityError := func(node CallLikeExpression) bool {
		if !isCallExpression(node) || !isIdentifier(node.expression) {
			return false
		}
		symbol := resolveName(node.expression, node.expression.escapedText, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, false)
		decl := symbol. /* TODO(TS-TO-GO): was ? */ valueDeclaration
		if !decl || !isParameter(decl) || !isFunctionExpressionOrArrowFunction(decl.parent) || !isNewExpression(decl.parent.parent) || !isIdentifier(decl.parent.parent.expression) {
			return false
		}
		globalPromiseSymbol := getGlobalPromiseConstructorSymbol(false)
		if !globalPromiseSymbol {
			return false
		}
		constructorSymbol := getSymbolAtLocation(decl.parent.parent.expression /*ignoreErrors*/, true)
		return constructorSymbol == globalPromiseSymbol
	}
	getArgumentArityError := func(node CallLikeExpression, signatures []Signature, args []Expression, headMessage DiagnosticMessage) Diagnostic {
		spreadIndex := getSpreadArgumentIndex(args)
		if spreadIndex > -1 {
			return createDiagnosticForNode(args[spreadIndex], Diagnostics.A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter)
		}
		min := Number.POSITIVE_INFINITY
		// smallest parameter count
		max := Number.NEGATIVE_INFINITY
		// largest parameter count
		maxBelow := Number.NEGATIVE_INFINITY
		// largest parameter count that is smaller than the number of arguments
		minAbove := Number.POSITIVE_INFINITY
		// smallest parameter count that is larger than the number of arguments
		var closestSignature *Signature
		for _, sig := range signatures {
			minParameter := getMinArgumentCount(sig)
			maxParameter := getParameterCount(sig)
			// smallest/largest parameter counts
			if minParameter < min {
				min = minParameter
				closestSignature = sig
			}
			max = Math.max(max, maxParameter)
			// shortest parameter count *longer than the call*/longest parameter count *shorter than the call*
			if minParameter < args.length && minParameter > maxBelow {
				maxBelow = minParameter
			}
			if args.length < maxParameter && maxParameter < minAbove {
				minAbove = maxParameter
			}
		}
		hasRestParameter := some(signatures, hasEffectiveRestParameter)
		var parameterRange /* TODO(TS-TO-GO) inferred type string | number */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case hasRestParameter:
			parameterRange = min
		case min < max:
			parameterRange = min + "-" + max
		default:
			parameterRange = min
		}
		isVoidPromiseError := !hasRestParameter && parameterRange == 1 && args.length == 0 && isPromiseResolveArityError(node)
		if isVoidPromiseError && isInJSFile(node) {
			return getDiagnosticForCallNode(node, Diagnostics.Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments)
		}
		var error DiagnosticMessage
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isDecorator(node):
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case hasRestParameter:
				error = Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0
			default:
				error = Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0
			}
		case hasRestParameter:
			error = Diagnostics.Expected_at_least_0_arguments_but_got_1
		case isVoidPromiseError:
			error = Diagnostics.Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise
		default:
			error = Diagnostics.Expected_0_arguments_but_got_1
		}
		if min < args.length && args.length < max {
			// between min and max, but with no matching overload
			if headMessage {
				chain := chainDiagnosticMessages(nil, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove)
				chain = chainDiagnosticMessages(chain, headMessage)
				return getDiagnosticForCallNode(node, chain)
			}
			return getDiagnosticForCallNode(node, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove)
		} else if args.length < min {
			// too short: put the error span on the call expression, not any of the args
			var diagnostic Diagnostic
			if headMessage {
				chain := chainDiagnosticMessages(nil, error, parameterRange, args.length)
				chain = chainDiagnosticMessages(chain, headMessage)
				diagnostic = getDiagnosticForCallNode(node, chain)
			} else {
				diagnostic = getDiagnosticForCallNode(node, error, parameterRange, args.length)
			}
			parameter := closestSignature. /* TODO(TS-TO-GO): was ? */ declaration. /* TODO(TS-TO-GO): was ? */ parameters[__COND__(closestSignature.thisParameter, args.length+1, args.length)]
			if parameter {
				var messageAndArgs DiagnosticAndArguments
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isBindingPattern(parameter.name):
					messageAndArgs = []any{Diagnostics.An_argument_matching_this_binding_pattern_was_not_provided}
				case isRestParameter(parameter):
					messageAndArgs = []any{Diagnostics.Arguments_for_the_rest_parameter_0_were_not_provided, idText(getFirstIdentifier(parameter.name))}
				default:
					messageAndArgs = []any{Diagnostics.An_argument_for_0_was_not_provided, __COND__(!parameter.name, args.length, idText(getFirstIdentifier(parameter.name)))}
				}
				parameterError := createDiagnosticForNode(parameter, messageAndArgs...)
				return addRelatedInfo(diagnostic, parameterError)
			}
			return diagnostic
		} else {
			// too long; error goes on the excess parameters
			errorSpan := factory.createNodeArray(args.slice(max))
			pos := first(errorSpan).pos
			end := last(errorSpan).end
			if end == pos {
				end++
			}
			setTextRangePosEnd(errorSpan, pos, end)
			if headMessage {
				chain := chainDiagnosticMessages(nil, error, parameterRange, args.length)
				chain = chainDiagnosticMessages(chain, headMessage)
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), errorSpan, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), errorSpan, error, parameterRange, args.length)
		}
	}
	getTypeArgumentArityError := func(node Node, signatures []Signature, typeArguments NodeArray[TypeNode], headMessage DiagnosticMessage) DiagnosticWithLocation {
		argCount := typeArguments.length
		// No overloads exist
		if signatures.length == 1 {
			sig := signatures[0]
			min := getMinTypeArgumentCount(sig.typeParameters)
			max := length(sig.typeParameters)
			if headMessage {
				chain := chainDiagnosticMessages(nil, Diagnostics.Expected_0_type_arguments_but_got_1, __COND__(min < max, min+"-"+max, min), argCount)
				chain = chainDiagnosticMessages(chain, headMessage)
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, __COND__(min < max, min+"-"+max, min), argCount)
		}
		// Overloads exist
		belowArgCount := -Infinity
		aboveArgCount := Infinity
		for _, sig := range signatures {
			min := getMinTypeArgumentCount(sig.typeParameters)
			max := length(sig.typeParameters)
			if min > argCount {
				aboveArgCount = Math.min(aboveArgCount, min)
			} else if max < argCount {
				belowArgCount = Math.max(belowArgCount, max)
			}
		}
		if belowArgCount != -Infinity && aboveArgCount != Infinity {
			if headMessage {
				chain := chainDiagnosticMessages(nil, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount)
				chain = chainDiagnosticMessages(chain, headMessage)
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount)
		}
		if headMessage {
			chain := chainDiagnosticMessages(nil, Diagnostics.Expected_0_type_arguments_but_got_1, __COND__(belowArgCount == -Infinity, aboveArgCount, belowArgCount), argCount)
			chain = chainDiagnosticMessages(chain, headMessage)
			return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
		}
		return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, __COND__(belowArgCount == -Infinity, aboveArgCount, belowArgCount), argCount)
	}
	resolveCall := func(node CallLikeExpression, signatures []Signature, candidatesOutArray *[]Signature, checkMode CheckMode, callChainFlags SignatureFlags, headMessage DiagnosticMessage) Signature {
		isTaggedTemplate := node.kind == SyntaxKindTaggedTemplateExpression
		isDecorator := node.kind == SyntaxKindDecorator
		isJsxOpeningOrSelfClosingElement := isJsxOpeningLikeElement(node)
		isInstanceof := node.kind == SyntaxKindBinaryExpression
		reportErrors := !isInferencePartiallyBlocked && !candidatesOutArray
		var typeArguments *NodeArray[TypeNode]
		if !isDecorator && !isInstanceof && !isSuperCall(node) {
			typeArguments = (node /* as CallExpression */).typeArguments
			// We already perform checking on the type arguments on the class declaration itself.
			if isTaggedTemplate || isJsxOpeningOrSelfClosingElement || (node /* as CallExpression */).expression.kind != SyntaxKindSuperKeyword {
				forEach(typeArguments, checkSourceElement)
			}
		}
		candidates := candidatesOutArray || []never{}
		// reorderCandidates fills up the candidates array directly
		reorderCandidates(signatures, candidates, callChainFlags)
		Debug.assert(candidates.length, "Revert #54442 and add a testcase with whatever triggered this")
		args := getEffectiveCallArguments(node)
		// The excludeArgument array contains true for each context sensitive argument (an argument
		// is context sensitive it is susceptible to a one-time permanent contextual typing).
		//
		// The idea is that we will perform type argument inference & assignability checking once
		// without using the susceptible parameters that are functions, and once more for those
		// parameters, contextually typing each as we go along.
		//
		// For a tagged template, then the first argument be 'undefined' if necessary because it
		// represents a TemplateStringsArray.
		//
		// For a decorator, no arguments are susceptible to contextual typing due to the fact
		// decorators are applied to a declaration by the emitter, and not to an expression.
		isSingleNonGenericCandidate := candidates.length == 1 && !candidates[0].typeParameters
		var argCheckMode CheckMode
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case !isDecorator && !isSingleNonGenericCandidate && some(args, isContextSensitive):
			argCheckMode = CheckModeSkipContextSensitive
		default:
			argCheckMode = CheckModeNormal
		}
		// The following variables are captured and modified by calls to chooseOverload.
		// If overload resolution or type argument inference fails, we want to report the
		// best error possible. The best error is one which says that an argument was not
		// assignable to a parameter. This implies that everything else about the overload
		// was fine. So if there is any overload that is only incorrect because of an
		// argument, we will report an error on that one.
		//
		//     function foo(s: string): void;
		//     function foo(n: number): void; // Report argument error on this overload
		//     function foo(): void;
		//     foo(true);
		//
		// If none of the overloads even made it that far, there are two possibilities.
		// There was a problem with type arguments for some overload, in which case
		// report an error on that. Or none of the overloads even had correct arity,
		// in which case give an arity error.
		//
		//     function foo<T extends string>(x: T): void; // Report type argument error
		//     function foo(): void;
		//     foo<number>(0);
		//
		var candidatesForArgumentError *[]Signature
		var candidateForArgumentArityError *Signature
		var candidateForTypeArgumentError *Signature
		var result *Signature
		// If we are in signature help, a trailing comma indicates that we intend to provide another argument,
		// so we will only accept overloads with arity at least 1 higher than the current number of provided arguments.
		signatureHelpTrailingComma := !!(checkMode & CheckModeIsForSignatureHelp) && node.kind == SyntaxKindCallExpression && node.arguments.hasTrailingComma
		// Section 4.12.1:
		// if the candidate list contains one or more signatures for which the type of each argument
		// expression is a subtype of each corresponding parameter type, the return type of the first
		// of those signatures becomes the return type of the function call.
		// Otherwise, the return type of the first signature in the candidate list becomes the return
		// type of the function call.
		//
		// Whether the call is an error is determined by assignability of the arguments. The subtype pass
		// is just important for choosing the best signature. So in the case where there is only one
		// signature, the subtype pass is useless. So skipping it is an optimization.
		if candidates.length > 1 {
			result = chooseOverload(candidates, subtypeRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma)
		}
		if !result {
			result = chooseOverload(candidates, assignableRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma)
		}
		if result {
			return result
		}
		result = getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray, checkMode)
		// Preemptively cache the result; getResolvedSignature will do this after we return, but
		// we need to ensure that the result is present for the error checks below so that if
		// this signature is encountered again, we handle the circularity (rather than producing a
		// different result which may produce no errors and assert). Callers of getResolvedSignature
		// don't hit this issue because they only observe this result after it's had a chance to
		// be cached, but the error reporting code below executes before getResolvedSignature sets
		// resolvedSignature.
		getNodeLinks(node).resolvedSignature = result
		// No signatures were applicable. Now report errors based on the last applicable signature with
		// no arguments excluded from assignability checks.
		// If candidate is undefined, it means that no candidates had a suitable arity. In that case,
		// skip the checkApplicableSignature check.
		if reportErrors {
			// If the call expression is a synthetic call to a `[Symbol.hasInstance]` method then we will produce a head
			// message when reporting diagnostics that explains how we got to `right[Symbol.hasInstance](left)` from
			// `left instanceof right`, as it pertains to "Argument" related messages reported for the call.
			if !headMessage && isInstanceof {
				headMessage = Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_hand_side_s_Symbol_hasInstance_method
			}
			if candidatesForArgumentError {
				if candidatesForArgumentError.length == 1 || candidatesForArgumentError.length > 3 {
					last := candidatesForArgumentError[candidatesForArgumentError.length-1]
					var chain *DiagnosticMessageChain
					if candidatesForArgumentError.length > 3 {
						chain = chainDiagnosticMessages(chain, Diagnostics.The_last_overload_gave_the_following_error)
						chain = chainDiagnosticMessages(chain, Diagnostics.No_overload_matches_this_call)
					}
					if headMessage {
						chain = chainDiagnosticMessages(chain, headMessage)
					}
					diags := getSignatureApplicabilityError(node, args, last, assignableRelation, CheckModeNormal /*reportErrors*/, true, func() *DiagnosticMessageChain {
						return chain
					}, /*inferenceContext*/ nil)
					if diags {
						for _, d := range diags {
							if last.declaration && candidatesForArgumentError.length > 3 {
								addRelatedInfo(d, createDiagnosticForNode(last.declaration, Diagnostics.The_last_overload_is_declared_here))
							}
							addImplementationSuccessElaboration(last, d)
							diagnostics.add(d)
						}
					} else {
						Debug.fail("No error for last overload signature")
					}
				} else {
					var allDiagnostics [][]DiagnosticRelatedInformation = []never{}
					max := 0
					min := Number.MAX_VALUE
					minIndex := 0
					i := 0
					for _, c := range candidatesForArgumentError {
						chain := func() DiagnosticMessageChain {
							return chainDiagnosticMessages(nil, Diagnostics.Overload_0_of_1_2_gave_the_following_error, i+1, candidates.length, signatureToString(c))
						}
						diags := getSignatureApplicabilityError(node, args, c, assignableRelation, CheckModeNormal /*reportErrors*/, true, chain /*inferenceContext*/, nil)
						if diags {
							if diags.length <= min {
								min = diags.length
								minIndex = i
							}
							max = Math.max(max, diags.length)
							allDiagnostics.push(diags)
						} else {
							Debug.fail("No error for 3 or fewer overload signatures")
						}
						i++
					}
					var diags []DiagnosticRelatedInformation
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case max > 1:
						diags = allDiagnostics[minIndex]
					default:
						diags = flatten(allDiagnostics)
					}
					Debug.assert(diags.length > 0, "No errors reported for 3 or fewer overload signatures")
					chain := chainDiagnosticMessages(map_(diags, createDiagnosticMessageChainFromDiagnostic), Diagnostics.No_overload_matches_this_call)
					if headMessage {
						chain = chainDiagnosticMessages(chain, headMessage)
					}
					// The below is a spread to guarantee we get a new (mutable) array - our `flatMap` helper tries to do "smart" optimizations where it reuses input
					// arrays and the emptyArray singleton where possible, which is decidedly not what we want while we're still constructing this diagnostic
					related := []DiagnosticRelatedInformation{ /* TODO(TS-TO-GO) Node SpreadElement: ...flatMap(diags, d => (d as Diagnostic).relatedInformation) as DiagnosticRelatedInformation[] */ }
					var diag Diagnostic
					if every(diags, func(d DiagnosticRelatedInformation) bool {
						return d.start == diags[0].start && d.length == diags[0].length && d.file == diags[0].file
					}) {
						TODO_IDENTIFIER := diags[0]
						diag = map[any]any{ /* TODO(TS-TO-GO): was object literal */
							"file":               file,
							"start":              start,
							"length":             length,
							"code":               chain.code,
							"category":           chain.category,
							"messageText":        chain,
							"relatedInformation": related,
						}
					} else {
						diag = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), getErrorNodeForCallNode(node), chain, related)
					}
					addImplementationSuccessElaboration(candidatesForArgumentError[0], diag)
					diagnostics.add(diag)
				}
			} else if candidateForArgumentArityError {
				diagnostics.add(getArgumentArityError(node, []Signature{candidateForArgumentArityError}, args, headMessage))
			} else if candidateForTypeArgumentError {
				checkTypeArguments(candidateForTypeArgumentError, (node /* as CallExpression | TaggedTemplateExpression | JsxOpeningLikeElement */).typeArguments /*reportErrors*/, true, headMessage)
			} else {
				signaturesWithCorrectTypeArgumentArity := filter(signatures, func(s Signature) bool {
					return hasCorrectTypeArgumentArity(s, typeArguments)
				})
				if signaturesWithCorrectTypeArgumentArity.length == 0 {
					diagnostics.add(getTypeArgumentArityError(node, signatures, typeArguments, headMessage))
				} else {
					diagnostics.add(getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args, headMessage))
				}
			}
		}
		return result
		addImplementationSuccessElaboration := func(failed Signature, diagnostic Diagnostic) {
			oldCandidatesForArgumentError := candidatesForArgumentError
			oldCandidateForArgumentArityError := candidateForArgumentArityError
			oldCandidateForTypeArgumentError := candidateForTypeArgumentError
			failedSignatureDeclarations := failed.declaration. /* TODO(TS-TO-GO): was ? */ symbol. /* TODO(TS-TO-GO): was ? */ declarations || emptyArray
			isOverload := failedSignatureDeclarations.length > 1
			var implDecl Declaration
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isOverload:
				implDecl = find(failedSignatureDeclarations, func(d Declaration) bool {
					return isFunctionLikeDeclaration(d) && nodeIsPresent(d.body)
				})
			default:
				implDecl = nil
			}
			if implDecl {
				candidate := getSignatureFromDeclaration(implDecl /* as FunctionLikeDeclaration */)
				isSingleNonGenericCandidate := !candidate.typeParameters
				if chooseOverload([]Signature{candidate}, assignableRelation, isSingleNonGenericCandidate) {
					addRelatedInfo(diagnostic, createDiagnosticForNode(implDecl, Diagnostics.The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible))
				}
			}
			candidatesForArgumentError = oldCandidatesForArgumentError
			candidateForArgumentArityError = oldCandidateForArgumentArityError
			candidateForTypeArgumentError = oldCandidateForTypeArgumentError
		}
		chooseOverload := func(candidates []Signature, relation Map[string, RelationComparisonResult], isSingleNonGenericCandidate bool, signatureHelpTrailingComma bool /*  = false */) *Signature {
			candidatesForArgumentError = nil
			candidateForArgumentArityError = nil
			candidateForTypeArgumentError = nil
			if isSingleNonGenericCandidate {
				candidate := candidates[0]
				if some(typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma) {
					return nil
				}
				if getSignatureApplicabilityError(node, args, candidate, relation, CheckModeNormal /*reportErrors*/, false /*containingMessageChain*/, nil /*inferenceContext*/, nil) {
					candidatesForArgumentError = []Signature{candidate}
					return nil
				}
				return candidate
			}
			for candidateIndex := 0; candidateIndex < candidates.length; candidateIndex++ {
				candidate := candidates[candidateIndex]
				if !hasCorrectTypeArgumentArity(candidate, typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma) {
					continue
				}
				var checkCandidate Signature
				var inferenceContext *InferenceContext
				if candidate.typeParameters {
					// If we are *inside the body of candidate*, we need to create a clone of `candidate` with differing type parameter identities,
					// so our inference results for this call doesn't pollute expression types referencing the outer type parameter!
					paramLocation := candidate.typeParameters[0].symbol.declarations[0]. /* TODO(TS-TO-GO): was ? */ parent
					candidateParameterContext := paramLocation || (__COND__(candidate.declaration && isConstructorDeclaration(candidate.declaration), candidate.declaration.parent, candidate.declaration))
					if candidateParameterContext && findAncestor(node, func(a Node) bool {
						return a == candidateParameterContext
					}) {
						candidate = getImplementationSignature(candidate)
					}
					var typeArgumentTypes *[]Type
					if some(typeArguments) {
						typeArgumentTypes = checkTypeArguments(candidate, typeArguments /*reportErrors*/, false)
						if !typeArgumentTypes {
							candidateForTypeArgumentError = candidate
							continue
						}
					} else {
						inferenceContext = createInferenceContext(candidate.typeParameters, candidate /*flags*/, __COND__(isInJSFile(node), InferenceFlagsAnyDefault, InferenceFlagsNone))
						// The resulting type arguments are instantiated with the inference context mapper, as the inferred types may still contain references to the inference context's
						//  type variables via contextual projection. These are kept generic until all inferences are locked in, so the dependencies expressed can pass constraint checks.
						typeArgumentTypes = instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode|CheckModeSkipGenericFunctions, inferenceContext), inferenceContext.nonFixingMapper)
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case inferenceContext.flags & InferenceFlagsSkippedGenericFunction:
							argCheckMode |= CheckModeSkipGenericFunctions
						default:
							argCheckMode |= CheckModeNormal
						}
					}
					checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters)
					// If the original signature has a generic rest type, instantiation may produce a
					// signature with different arity and we need to perform another arity check.
					if getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma) {
						candidateForArgumentArityError = checkCandidate
						continue
					}
				} else {
					checkCandidate = candidate
				}
				if getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode /*reportErrors*/, false /*containingMessageChain*/, nil, inferenceContext) {
					// Give preference to error candidates that have no rest parameters (as they are more specific)
					(candidatesForArgumentError || ( /* TODO(TS-TO-GO) Node BinaryExpression: candidatesForArgumentError = [] */ TODO)).push(checkCandidate)
					continue
				}
				if argCheckMode {
					// If one or more context sensitive arguments were excluded, we start including
					// them now (and keeping do so for any subsequent candidates) and perform a second
					// round of type inference and applicability checking for this particular candidate.
					argCheckMode = CheckModeNormal
					if inferenceContext {
						typeArgumentTypes := instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode, inferenceContext), inferenceContext.mapper)
						checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext.inferredTypeParameters)
						// If the original signature has a generic rest type, instantiation may produce a
						// signature with different arity and we need to perform another arity check.
						if getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma) {
							candidateForArgumentArityError = checkCandidate
							continue
						}
					}
					if getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode /*reportErrors*/, false /*containingMessageChain*/, nil, inferenceContext) {
						// Give preference to error candidates that have no rest parameters (as they are more specific)
						(candidatesForArgumentError || ( /* TODO(TS-TO-GO) Node BinaryExpression: candidatesForArgumentError = [] */ TODO)).push(checkCandidate)
						continue
					}
				}
				candidates[candidateIndex] = checkCandidate
				return checkCandidate
			}
			return nil
		}
	}
	// No signature was applicable. We have already reported the errors for the invalid signature.
	getCandidateForOverloadFailure := func(node CallLikeExpression, candidates []Signature, args []Expression, hasCandidatesOutArray bool, checkMode CheckMode) Signature {
		Debug.assert(candidates.length > 0)
		// Else should not have called this.
		checkNodeDeferred(node)
		// Normally we will combine overloads. Skip this if they have type parameters since that's hard to combine.
		// Don't do this if there is a `candidatesOutArray`,
		// because then we want the chosen best candidate to be one of the overloads, not a combination.
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case hasCandidatesOutArray || candidates.length == 1 || candidates.some(func(c Signature) bool {
			return !!c.typeParameters
		}):
			return pickLongestCandidateSignature(node, candidates, args, checkMode)
		default:
			return createUnionOfSignaturesForOverloadFailure(candidates)
		}
	}
	createUnionOfSignaturesForOverloadFailure := func(candidates []Signature) Signature {
		thisParameters := mapDefined(candidates, func(c Signature) Symbol {
			return c.thisParameter
		})
		var thisParameter Symbol
		if thisParameters.length {
			thisParameter = createCombinedSymbolFromTypes(thisParameters, thisParameters.map_(getTypeOfParameter))
		}
		TODO_IDENTIFIER := minAndMax(candidates, getNumNonRestParameters)
		var parameters []Symbol = []never{}
		for i := 0; i < maxNonRestParam; i++ {
			symbols := mapDefined(candidates, func(s Signature) Symbol {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case signatureHasRestParameter(s):
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case i < s.parameters.length-1:
						return s.parameters[i]
					default:
						return last(s.parameters)
					}
				case i < s.parameters.length:
					return s.parameters[i]
				default:
					return nil
				}
			})
			Debug.assert(symbols.length != 0)
			parameters.push(createCombinedSymbolFromTypes(symbols, mapDefined(candidates, func(candidate Signature) Type {
				return tryGetTypeAtPosition(candidate, i)
			})))
		}
		restParameterSymbols := mapDefined(candidates, func(c Signature) Symbol {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case signatureHasRestParameter(c):
				return last(c.parameters)
			default:
				return nil
			}
		})
		flags := SignatureFlagsIsSignatureCandidateForOverloadFailure
		if restParameterSymbols.length != 0 {
			type_ := createArrayType(getUnionType(mapDefined(candidates, tryGetRestTypeOfSignature), UnionReductionSubtype))
			parameters.push(createCombinedSymbolForOverloadFailure(restParameterSymbols, type_))
			flags |= SignatureFlagsHasRestParameter
		}
		if candidates.some(signatureHasLiteralTypes) {
			flags |= SignatureFlagsHasLiteralTypes
		}
		return createSignature(candidates[0].declaration, nil, thisParameter, parameters, getIntersectionType(candidates.map_(getReturnTypeOfSignature)), nil, minArgumentCount, flags)
	}
	getNumNonRestParameters := func(signature Signature) number {
		numParams := signature.parameters.length
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case signatureHasRestParameter(signature):
			return numParams - 1
		default:
			return numParams
		}
	}
	createCombinedSymbolFromTypes := func(sources []Symbol, types []Type) Symbol {
		return createCombinedSymbolForOverloadFailure(sources, getUnionType(types, UnionReductionSubtype))
	}
	createCombinedSymbolForOverloadFailure := func(sources []Symbol, type_ Type) Symbol {
		// This function is currently only used for erroneous overloads, so it's good enough to just use the first source.
		return createSymbolWithType(first(sources), type_)
	}
	pickLongestCandidateSignature := func(node CallLikeExpression, candidates []Signature, args []Expression, checkMode CheckMode) Signature {
		// Pick the longest signature. This way we can get a contextual type for cases like:
		//     declare function f(a: { xa: number; xb: number; }, b: number);
		//     f({ |
		// Also, use explicitly-supplied type arguments if they are provided, so we can get a contextual signature in cases like:
		//     declare function f<T>(k: keyof T);
		//     f<Foo>("
		bestIndex := getLongestCandidateIndex(candidates, __COND__(apparentArgumentCount == nil, args.length, apparentArgumentCount))
		candidate := candidates[bestIndex]
		TODO_IDENTIFIER := candidate
		if !typeParameters {
			return candidate
		}
		var typeArgumentNodes *[]TypeNode
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case callLikeExpressionMayHaveTypeArguments(node):
			typeArgumentNodes = node.typeArguments
		default:
			typeArgumentNodes = nil
		}
		var instantiated Signature
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case typeArgumentNodes:
			instantiated = createSignatureInstantiation(candidate, getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isInJSFile(node)))
		default:
			instantiated = inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args, checkMode)
		}
		candidates[bestIndex] = instantiated
		return instantiated
	}
	getTypeArgumentsFromNodes := func(typeArgumentNodes []TypeNode, typeParameters []TypeParameter, isJs bool) []Type {
		typeArguments := typeArgumentNodes.map_(getTypeOfNode)
		for typeArguments.length > typeParameters.length {
			typeArguments.pop()
		}
		for typeArguments.length < typeParameters.length {
			typeArguments.push(getDefaultFromTypeParameter(typeParameters[typeArguments.length]) || getConstraintOfTypeParameter(typeParameters[typeArguments.length]) || getDefaultTypeArgumentType(isJs))
		}
		return typeArguments
	}
	inferSignatureInstantiationForOverloadFailure := func(node CallLikeExpression, typeParameters []TypeParameter, candidate Signature, args []Expression, checkMode CheckMode) Signature {
		inferenceContext := createInferenceContext(typeParameters, candidate /*flags*/, __COND__(isInJSFile(node), InferenceFlagsAnyDefault, InferenceFlagsNone))
		typeArgumentTypes := inferTypeArguments(node, candidate, args, checkMode|CheckModeSkipContextSensitive|CheckModeSkipGenericFunctions, inferenceContext)
		return createSignatureInstantiation(candidate, typeArgumentTypes)
	}
	getLongestCandidateIndex := func(candidates []Signature, argsCount number) number {
		maxParamsIndex := -1
		maxParams := -1
		for i := 0; i < candidates.length; i++ {
			candidate := candidates[i]
			paramCount := getParameterCount(candidate)
			if hasEffectiveRestParameter(candidate) || paramCount >= argsCount {
				return i
			}
			if paramCount > maxParams {
				maxParams = paramCount
				maxParamsIndex = i
			}
		}
		return maxParamsIndex
	}
	resolveCallExpression := func(node CallExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		if node.expression.kind == SyntaxKindSuperKeyword {
			superType := checkSuperExpression(node.expression)
			if isTypeAny(superType) {
				for _, arg := range node.arguments {
					checkExpression(arg)
					// Still visit arguments so they get marked for visibility, etc
				}
				return anySignature
			}
			if !isErrorType(superType) {
				// In super call, the candidate signatures are the matching arity signatures of the base constructor function instantiated
				// with the type arguments specified in the extends clause.
				baseTypeNode := getEffectiveBaseTypeNode(getContainingClass(node))
				if baseTypeNode {
					baseConstructors := getInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.typeArguments, baseTypeNode)
					return resolveCall(node, baseConstructors, candidatesOutArray, checkMode, SignatureFlagsNone)
				}
			}
			return resolveUntypedCall(node)
		}
		var callChainFlags SignatureFlags
		funcType := checkExpression(node.expression)
		if isCallChain(node) {
			nonOptionalType := getOptionalExpressionType(funcType, node.expression)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case nonOptionalType == funcType:
				callChainFlags = SignatureFlagsNone
			case isOutermostOptionalChain(node):
				callChainFlags = SignatureFlagsIsOuterCallChain
			default:
				callChainFlags = SignatureFlagsIsInnerCallChain
			}
			funcType = nonOptionalType
		} else {
			callChainFlags = SignatureFlagsNone
		}
		funcType = checkNonNullTypeWithReporter(funcType, node.expression, reportCannotInvokePossiblyNullOrUndefinedError)
		if funcType == silentNeverType {
			return silentNeverSignature
		}
		apparentType := getApparentType(funcType)
		if isErrorType(apparentType) {
			// Another error has already been reported
			return resolveErrorCall(node)
		}
		// Technically, this signatures list may be incomplete. We are taking the apparent type,
		// but we are not including call signatures that may have been added to the Object or
		// Function interface, since they have none by default. This is a bit of a leap of faith
		// that the user will not add any.
		callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
		numConstructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct).length
		// TS 1.0 Spec: 4.12
		// In an untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual
		// types are provided for the argument expressions, and the result is always of type Any.
		if isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures) {
			// The unknownType indicates that an error already occurred (and was reported).  No
			// need to report another error in this case.
			if !isErrorType(funcType) && node.typeArguments {
				error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments)
			}
			return resolveUntypedCall(node)
		}
		// If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.
		// TypeScript employs overload resolution in typed function calls in order to support functions
		// with multiple call signatures.
		if !callSignatures.length {
			if numConstructSignatures {
				error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType))
			} else {
				var relatedInformation *DiagnosticRelatedInformation
				if node.arguments.length == 1 {
					text := getSourceFileOfNode(node).text
					if isLineBreak(text.charCodeAt(skipTrivia(text, node.expression.end /*stopAfterLineBreak*/, true) - 1)) {
						relatedInformation = createDiagnosticForNode(node.expression, Diagnostics.Are_you_missing_a_semicolon)
					}
				}
				invocationError(node.expression, apparentType, SignatureKindCall, relatedInformation)
			}
			return resolveErrorCall(node)
		}
		// When a call to a generic function is an argument to an outer call to a generic function for which
		// inference is in process, we have a choice to make. If the inner call relies on inferences made from
		// its contextual type to its return type, deferring the inner call processing allows the best possible
		// contextual type to accumulate. But if the outer call relies on inferences made from the return type of
		// the inner call, the inner call should be processed early. There's no sure way to know which choice is
		// right (only a full unification algorithm can determine that), so we resort to the following heuristic:
		// If no type arguments are specified in the inner call and at least one call signature is generic and
		// returns a function type, we choose to defer processing. This narrowly permits function composition
		// operators to flow inferences through return types, but otherwise processes calls right away. We
		// use the resolvingSignature singleton to indicate that we deferred processing. This result will be
		// propagated out and eventually turned into silentNeverType (a type that is assignable to anything and
		// from which we never make inferences).
		if checkMode&CheckModeSkipGenericFunctions && !node.typeArguments && callSignatures.some(isGenericFunctionReturningFunction) {
			skippedGenericFunction(node, checkMode)
			return resolvingSignature
		}
		// If the function is explicitly marked with `@class`, then it must be constructed.
		if callSignatures.some(func(sig Signature) bool {
			return isInJSFile(sig.declaration) && !!getJSDocClassTag(sig.declaration)
		}) {
			error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType))
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode, callChainFlags)
	}
	isGenericFunctionReturningFunction := func(signature Signature) bool {
		return !!(signature.typeParameters && isFunctionType(getReturnTypeOfSignature(signature)))
	}
	/**
	 * TS 1.0 spec: 4.12
	 * If FuncExpr is of type Any, or of an object type that has no call or construct signatures
	 * but is a subtype of the Function interface, the call is an untyped function call.
	 */
	isUntypedFunctionCall := func(funcType Type, apparentFuncType Type, numCallSignatures number, numConstructSignatures number) bool {
		// We exclude union types because we may have a union of function types that happen to have no common signatures.
		return isTypeAny(funcType) || isTypeAny(apparentFuncType) && !!(funcType.flags&TypeFlagsTypeParameter) || !numCallSignatures && !numConstructSignatures && !(apparentFuncType.flags&TypeFlagsUnion) && !(getReducedType(apparentFuncType).flags&TypeFlagsNever) && isTypeAssignableTo(funcType, globalFunctionType)
	}
	resolveNewExpression := func(node NewExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		expressionType := checkNonNullExpression(node.expression)
		if expressionType == silentNeverType {
			return silentNeverSignature
		}
		// If expressionType's apparent type(section 3.8.1) is an object type with one or
		// more construct signatures, the expression is processed in the same manner as a
		// function call, but using the construct signatures as the initial set of candidate
		// signatures for overload resolution. The result type of the function call becomes
		// the result type of the operation.
		expressionType = getApparentType(expressionType)
		if isErrorType(expressionType) {
			// Another error has already been reported
			return resolveErrorCall(node)
		}
		// TS 1.0 spec: 4.11
		// If expressionType is of type Any, Args can be any argument
		// list and the result of the operation is of type Any.
		if isTypeAny(expressionType) {
			if node.typeArguments {
				error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments)
			}
			return resolveUntypedCall(node)
		}
		// Technically, this signatures list may be incomplete. We are taking the apparent type,
		// but we are not including construct signatures that may have been added to the Object or
		// Function interface, since they have none by default. This is a bit of a leap of faith
		// that the user will not add any.
		constructSignatures := getSignaturesOfType(expressionType, SignatureKindConstruct)
		if constructSignatures.length {
			if !isConstructorAccessible(node, constructSignatures[0]) {
				return resolveErrorCall(node)
			}
			// If the expression is a class of abstract type, or an abstract construct signature,
			// then it cannot be instantiated.
			// In the case of a merged class-module or class-interface declaration,
			// only the class declaration node will have the Abstract flag set.
			if someSignature(constructSignatures, func(signature Signature) bool {
				return !!(signature.flags & SignatureFlagsAbstract)
			}) {
				error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class)
				return resolveErrorCall(node)
			}
			valueDecl := expressionType.symbol && getClassLikeDeclarationOfSymbol(expressionType.symbol)
			if valueDecl && hasSyntacticModifier(valueDecl, ModifierFlagsAbstract) {
				error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class)
				return resolveErrorCall(node)
			}
			return resolveCall(node, constructSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
		}
		// If expressionType's apparent type is an object type with no construct signatures but
		// one or more call signatures, the expression is processed as a function call. A compile-time
		// error occurs if the result of the function call is not Void. The type of the result of the
		// operation is Any. It is an error to have a Void this type.
		callSignatures := getSignaturesOfType(expressionType, SignatureKindCall)
		if callSignatures.length {
			signature := resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
			if !noImplicitAny {
				if signature.declaration && !isJSConstructor(signature.declaration) && getReturnTypeOfSignature(signature) != voidType {
					error(node, Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword)
				}
				if getThisTypeOfSignature(signature) == voidType {
					error(node, Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void)
				}
			}
			return signature
		}
		invocationError(node.expression, expressionType, SignatureKindConstruct)
		return resolveErrorCall(node)
	}
	someSignature := func(signatures /* TODO(TS-TO-GO) TypeNode UnionType: Signature | readonly Signature[] */ any, f func(s Signature) bool) bool {
		if isArray(signatures) {
			return some(signatures, func(signature Signature) bool {
				return someSignature(signature, f)
			})
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case signatures.compositeKind == TypeFlagsUnion:
			return some(signatures.compositeSignatures, f)
		default:
			return f(signatures)
		}
	}
	typeHasProtectedAccessibleBase := func(target Symbol, type_ InterfaceType) bool {
		baseTypes := getBaseTypes(type_)
		if !length(baseTypes) {
			return false
		}
		firstBase := baseTypes[0]
		if firstBase.flags & TypeFlagsIntersection {
			types := (firstBase /* as IntersectionType */).types
			mixinFlags := findMixins(types)
			i := 0
			for _, intersectionMember := range (firstBase /* as IntersectionType */).types {
				// We want to ignore mixin ctors
				if !mixinFlags[i] {
					if getObjectFlags(intersectionMember) & (ObjectFlagsClass | ObjectFlagsInterface) {
						if intersectionMember.symbol == target {
							return true
						}
						if typeHasProtectedAccessibleBase(target, intersectionMember /* as InterfaceType */) {
							return true
						}
					}
				}
				i++
			}
			return false
		}
		if firstBase.symbol == target {
			return true
		}
		return typeHasProtectedAccessibleBase(target, firstBase /* as InterfaceType */)
	}
	isConstructorAccessible := func(node NewExpression, signature Signature) bool {
		if !signature || !signature.declaration {
			return true
		}
		declaration := signature.declaration
		modifiers := getSelectedEffectiveModifierFlags(declaration, ModifierFlagsNonPublicAccessibilityModifier)
		// (1) Public constructors and (2) constructor functions are always accessible.
		if !modifiers || declaration.kind != SyntaxKindConstructor {
			return true
		}
		declaringClassDeclaration := getClassLikeDeclarationOfSymbol(declaration.parent.symbol)
		declaringClass := getDeclaredTypeOfSymbol(declaration.parent.symbol) /* as InterfaceType */
		// A private or protected constructor can only be instantiated within its own class (or a subclass, for protected)
		if !isNodeWithinClass(node, declaringClassDeclaration) {
			containingClass := getContainingClass(node)
			if containingClass && modifiers&ModifierFlagsProtected {
				containingType := getTypeOfNode(containingClass)
				if typeHasProtectedAccessibleBase(declaration.parent.symbol, containingType /* as InterfaceType */) {
					return true
				}
			}
			if modifiers & ModifierFlagsPrivate {
				error(node, Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, typeToString(declaringClass))
			}
			if modifiers & ModifierFlagsProtected {
				error(node, Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, typeToString(declaringClass))
			}
			return false
		}
		return true
	}
	invocationErrorDetails := func(errorTarget Node, apparentType Type, kind SignatureKind) /* TODO(TS-TO-GO) TypeNode TypeLiteral: { messageChain: DiagnosticMessageChain; relatedMessage: DiagnosticMessage | undefined; } */ any {
		var errorInfo *DiagnosticMessageChain
		isCall := kind == SignatureKindCall
		awaitedType := getAwaitedType(apparentType)
		maybeMissingAwait := awaitedType && getSignaturesOfType(awaitedType, kind).length > 0
		if apparentType.flags & TypeFlagsUnion {
			types := (apparentType /* as UnionType */).types
			hasSignatures := false
			for _, constituent := range types {
				signatures := getSignaturesOfType(constituent, kind)
				if signatures.length != 0 {
					hasSignatures = true
					if errorInfo {
						// Bail early if we already have an error, no chance of "No constituent of type is callable"
						break
					}
				} else {
					// Error on the first non callable constituent only
					if !errorInfo {
						errorInfo = chainDiagnosticMessages(errorInfo, __COND__(isCall, Diagnostics.Type_0_has_no_call_signatures, Diagnostics.Type_0_has_no_construct_signatures), typeToString(constituent))
						errorInfo = chainDiagnosticMessages(errorInfo, __COND__(isCall, Diagnostics.Not_all_constituents_of_type_0_are_callable, Diagnostics.Not_all_constituents_of_type_0_are_constructable), typeToString(apparentType))
					}
					if hasSignatures {
						// Bail early if we already found a siganture, no chance of "No constituent of type is callable"
						break
					}
				}
			}
			if !hasSignatures {
				errorInfo = chainDiagnosticMessages(nil, __COND__(isCall, Diagnostics.No_constituent_of_type_0_is_callable, Diagnostics.No_constituent_of_type_0_is_constructable), typeToString(apparentType))
			}
			if !errorInfo {
				errorInfo = chainDiagnosticMessages(errorInfo, __COND__(isCall, Diagnostics.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other, Diagnostics.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other), typeToString(apparentType))
			}
		} else {
			errorInfo = chainDiagnosticMessages(errorInfo, __COND__(isCall, Diagnostics.Type_0_has_no_call_signatures, Diagnostics.Type_0_has_no_construct_signatures), typeToString(apparentType))
		}
		var headMessage DiagnosticMessage
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isCall:
			headMessage = Diagnostics.This_expression_is_not_callable
		default:
			headMessage = Diagnostics.This_expression_is_not_constructable
		}
		// Diagnose get accessors incorrectly called as functions
		if isCallExpression(errorTarget.parent) && errorTarget.parent.arguments.length == 0 {
			TODO_IDENTIFIER := getNodeLinks(errorTarget)
			if resolvedSymbol && resolvedSymbol.flags&SymbolFlagsGetAccessor {
				headMessage = Diagnostics.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without
			}
		}
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"messageChain":   chainDiagnosticMessages(errorInfo, headMessage),
			"relatedMessage": __COND__(maybeMissingAwait, Diagnostics.Did_you_forget_to_use_await, nil),
		}
	}
	invocationError := func(errorTarget Node, apparentType Type, kind SignatureKind, relatedInformation DiagnosticRelatedInformation) {
		TODO_IDENTIFIER := invocationErrorDetails(errorTarget, apparentType, kind)
		diagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorTarget), errorTarget, messageChain)
		if relatedInfo {
			addRelatedInfo(diagnostic, createDiagnosticForNode(errorTarget, relatedInfo))
		}
		if isCallExpression(errorTarget.parent) {
			TODO_IDENTIFIER := getDiagnosticSpanForCallNode(errorTarget.parent)
			diagnostic.start = start
			diagnostic.length = length
		}
		diagnostics.add(diagnostic)
		invocationErrorRecovery(apparentType, kind, __COND__(relatedInformation, addRelatedInfo(diagnostic, relatedInformation), diagnostic))
	}
	invocationErrorRecovery := func(apparentType Type, kind SignatureKind, diagnostic Diagnostic) {
		if !apparentType.symbol {
			return
		}
		importNode := getSymbolLinks(apparentType.symbol).originatingImport
		// Create a diagnostic on the originating import if possible onto which we can attach a quickfix
		//  An import call expression cannot be rewritten into another form to correct the error - the only solution is to use `.default` at the use-site
		if importNode && !isImportCall(importNode) {
			sigs := getSignaturesOfType(getTypeOfSymbol(getSymbolLinks(apparentType.symbol).target), kind)
			if !sigs || !sigs.length {
				return
			}
			addRelatedInfo(diagnostic, createDiagnosticForNode(importNode, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead))
		}
	}
	resolveTaggedTemplateExpression := func(node TaggedTemplateExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		tagType := checkExpression(node.tag)
		apparentType := getApparentType(tagType)
		if isErrorType(apparentType) {
			// Another error has already been reported
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
		numConstructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct).length
		if isUntypedFunctionCall(tagType, apparentType, callSignatures.length, numConstructSignatures) {
			return resolveUntypedCall(node)
		}
		if !callSignatures.length {
			if isArrayLiteralExpression(node.parent) {
				diagnostic := createDiagnosticForNode(node.tag, Diagnostics.It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked)
				diagnostics.add(diagnostic)
				return resolveErrorCall(node)
			}
			invocationError(node.tag, apparentType, SignatureKindCall)
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
	}
	/**
	 * Gets the localized diagnostic head message to use for errors when resolving a decorator as a call expression.
	 */
	getDiagnosticHeadMessageForDecoratorResolution := func(node Decorator) DiagnosticMessage {
		switch node.parent.kind {
		case SyntaxKindClassDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindClassExpression:
			return Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression
		case SyntaxKindParameter:
			return Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression
		case SyntaxKindPropertyDeclaration:
			return Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindSetAccessor:
			return Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression
		default:
			return Debug.fail()
		}
	}
	/**
	 * Resolves a decorator as if it were a call expression.
	 */
	resolveDecorator := func(node Decorator, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		funcType := checkExpression(node.expression)
		apparentType := getApparentType(funcType)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
		numConstructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct).length
		if isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures) {
			return resolveUntypedCall(node)
		}
		if isPotentiallyUncalledDecorator(node, callSignatures) && !isParenthesizedExpression(node.expression) {
			nodeStr := getTextOfNode(node.expression /*includeTrivia*/, false)
			error(node, Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0, nodeStr)
			return resolveErrorCall(node)
		}
		headMessage := getDiagnosticHeadMessageForDecoratorResolution(node)
		if !callSignatures.length {
			errorDetails := invocationErrorDetails(node.expression, apparentType, SignatureKindCall)
			messageChain := chainDiagnosticMessages(errorDetails.messageChain, headMessage)
			diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node.expression), node.expression, messageChain)
			if errorDetails.relatedMessage {
				addRelatedInfo(diag, createDiagnosticForNode(node.expression, errorDetails.relatedMessage))
			}
			diagnostics.add(diag)
			invocationErrorRecovery(apparentType, SignatureKindCall, diag)
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone, headMessage)
	}
	createSignatureForJSXIntrinsic := func(node JsxOpeningLikeElement, result Type) Signature {
		namespace := getJsxNamespaceAt(node)
		exports := namespace && getExportsOfSymbol(namespace)
		// We fake up a SFC signature for each intrinsic, however a more specific per-element signature drawn from the JSX declaration
		// file would probably be preferable.
		typeSymbol := exports && getSymbol(exports, JsxNames.Element, SymbolFlagsType)
		returnNode := typeSymbol && nodeBuilder.symbolToEntityName(typeSymbol, SymbolFlagsType, node)
		declaration := factory.createFunctionTypeNode(nil, []ParameterDeclaration{factory.createParameterDeclaration(nil /*dotDotDotToken*/, nil, "props" /*questionToken*/, nil, nodeBuilder.typeToTypeNode(result, node))}, __COND__(returnNode, factory.createTypeReferenceNode(returnNode /*typeArguments*/, nil), factory.createKeywordTypeNode(SyntaxKindAnyKeyword)))
		parameterSymbol := createSymbol(SymbolFlagsFunctionScopedVariable, "props" /* as __String */)
		parameterSymbol.links.type_ = result
		return createSignature(declaration, nil, nil, []TransientSymbol{parameterSymbol}, __COND__(typeSymbol, getDeclaredTypeOfSymbol(typeSymbol), errorType), nil, 1, SignatureFlagsNone)
	}
	resolveJsxOpeningLikeElement := func(node JsxOpeningLikeElement, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		if isJsxIntrinsicTagName(node.tagName) {
			result := getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node)
			fakeSignature := createSignatureForJSXIntrinsic(node, result)
			checkTypeAssignableToAndOptionallyElaborate(checkExpressionWithContextualType(node.attributes, getEffectiveFirstArgumentForJsxSignature(fakeSignature, node) /*inferenceContext*/, nil, CheckModeNormal), result, node.tagName, node.attributes)
			if length(node.typeArguments) {
				forEach(node.typeArguments, checkSourceElement)
				diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), node.typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, 0, length(node.typeArguments)))
			}
			return fakeSignature
		}
		exprTypes := checkExpression(node.tagName)
		apparentType := getApparentType(exprTypes)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		signatures := getUninstantiatedJsxSignaturesOfType(exprTypes, node)
		if isUntypedFunctionCall(exprTypes, apparentType, signatures.length /*constructSignatures*/, 0) {
			return resolveUntypedCall(node)
		}
		if signatures.length == 0 {
			// We found no signatures at all, which is an error
			error(node.tagName, Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, getTextOfNode(node.tagName))
			return resolveErrorCall(node)
		}
		return resolveCall(node, signatures, candidatesOutArray, checkMode, SignatureFlagsNone)
	}
	resolveInstanceofExpression := func(node InstanceofExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		// if rightType is an object type with a custom `[Symbol.hasInstance]` method, then it is potentially
		// valid on the right-hand side of the `instanceof` operator. This allows normal `object` types to
		// participate in `instanceof`, as per Step 2 of https://tc39.es/ecma262/#sec-instanceofoperator.
		rightType := checkExpression(node.right)
		if !isTypeAny(rightType) {
			hasInstanceMethodType := getSymbolHasInstanceMethodOfObjectType(rightType)
			if hasInstanceMethodType {
				apparentType := getApparentType(hasInstanceMethodType)
				if isErrorType(apparentType) {
					return resolveErrorCall(node)
				}
				callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
				constructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct)
				if isUntypedFunctionCall(hasInstanceMethodType, apparentType, callSignatures.length, constructSignatures.length) {
					return resolveUntypedCall(node)
				}
				if callSignatures.length {
					return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
				}
			} else if !(typeHasCallOrConstructSignatures(rightType) || isTypeSubtypeOf(rightType, globalFunctionType)) {
				error(node.right, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_either_of_type_any_a_class_function_or_other_type_assignable_to_the_Function_interface_type_or_an_object_type_with_a_Symbol_hasInstance_method)
				return resolveErrorCall(node)
			}
		}
		// fall back to a default signature
		return anySignature
	}
	/**
	 * Sometimes, we have a decorator that could accept zero arguments,
	 * but is receiving too many arguments as part of the decorator invocation.
	 * In those cases, a user may have meant to *call* the expression before using it as a decorator.
	 */
	isPotentiallyUncalledDecorator := func(decorator Decorator, signatures []Signature) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
		return signatures.length && every(signatures, func(signature Signature) bool {
			return signature.minArgumentCount == 0 && !signatureHasRestParameter(signature) && signature.parameters.length < getDecoratorArgumentCount(decorator, signature)
		})
	}
	resolveSignature := func(node CallLikeExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		switch node.kind {
		case SyntaxKindCallExpression:
			return resolveCallExpression(node, candidatesOutArray, checkMode)
		case SyntaxKindNewExpression:
			return resolveNewExpression(node, candidatesOutArray, checkMode)
		case SyntaxKindTaggedTemplateExpression:
			return resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode)
		case SyntaxKindDecorator:
			return resolveDecorator(node, candidatesOutArray, checkMode)
		case SyntaxKindJsxOpeningElement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJsxSelfClosingElement:
			return resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode)
		case SyntaxKindBinaryExpression:
			return resolveInstanceofExpression(node, candidatesOutArray, checkMode)
		}
		Debug.assertNever(node, "Branch in 'resolveSignature' should be unreachable.")
	}
	/**
	 * Resolve a signature of a given call-like expression.
	 * @param node a call-like expression to try resolve a signature for
	 * @param candidatesOutArray an array of signature to be filled in by the function. It is passed by signature help in the language service;
	 *                           the function will fill it up with appropriate candidate signatures
	 * @return a signature of the call-like expression or undefined if one can't be found
	 */
	getResolvedSignature := func(node CallLikeExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		links := getNodeLinks(node)
		// If getResolvedSignature has already been called, we will have cached the resolvedSignature.
		// However, it is possible that either candidatesOutArray was not passed in the first time,
		// or that a different candidatesOutArray was passed in. Therefore, we need to redo the work
		// to correctly fill the candidatesOutArray.
		cached := links.resolvedSignature
		if cached && cached != resolvingSignature && !candidatesOutArray {
			return cached
		}
		saveResolutionStart := resolutionStart
		if !cached {
			// If we haven't already done so, temporarily reset the resolution stack. This allows us to
			// handle "inverted" situations where, for example, an API client asks for the type of a symbol
			// containined in a function call argument whose contextual type depends on the symbol itself
			// through resolution of the containing function call. By resetting the resolution stack we'll
			// retry the symbol type resolution with the resolvingSignature marker in place to suppress
			// the contextual type circularity.
			resolutionStart = resolutionTargets.length
		}
		links.resolvedSignature = resolvingSignature
		result := resolveSignature(node, candidatesOutArray, checkMode || CheckModeNormal)
		resolutionStart = saveResolutionStart
		// When CheckMode.SkipGenericFunctions is set we use resolvingSignature to indicate that call
		// resolution should be deferred.
		if result != resolvingSignature {
			// if the signature resolution originated on a node that itself depends on the contextual type
			// then it's possible that the resolved signature might not be the same as the one that would be computed in source order
			// since resolving such signature leads to resolving the potential outer signature, its arguments and thus the very same signature
			// it's possible that this inner resolution sets the resolvedSignature first.
			// In such a case we ignore the local result and reuse the correct one that was cached.
			if links.resolvedSignature != resolvingSignature {
				result = links.resolvedSignature
			}
			// If signature resolution originated in control flow type analysis (for example to compute the
			// assigned type in a flow assignment) we don't cache the result as it may be based on temporary
			// types from the control flow analysis.
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case flowLoopStart == flowLoopCount:
				links.resolvedSignature = result
			default:
				links.resolvedSignature = cached
			}
		}
		return result
	}
	/**
	 * Indicates whether a declaration can be treated as a constructor in a JavaScript
	 * file.
	 */
	isJSConstructor := func(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is FunctionDeclaration | FunctionExpression */ any {
		if !node || !isInJSFile(node) {
			return false
		}
		var func_ * /* TODO(TS-TO-GO) inferred type FunctionDeclaration | FunctionExpression */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isFunctionDeclaration(node) || isFunctionExpression(node):
			func_ = node
		case (isVariableDeclaration(node) || isPropertyAssignment(node)) && node.initializer && isFunctionExpression(node.initializer):
			func_ = node.initializer
		default:
			func_ = nil
		}
		if func_ {
			// If the node has a @class or @constructor tag, treat it like a constructor.
			if getJSDocClassTag(node) {
				return true
			}
			// If the node is a property of an object literal.
			if isPropertyAssignment(walkUpParenthesizedExpressions(func_.parent)) {
				return false
			}
			// If the symbol of the node has members, treat it like a constructor.
			symbol := getSymbolOfDeclaration(func_)
			return !!symbol. /* TODO(TS-TO-GO): was ? */ members. /* TODO(TS-TO-GO): was ? */ size
		}
		return false
	}
	mergeJSSymbols := func(target Symbol, source Symbol) *TransientSymbol {
		if source {
			links := getSymbolLinks(source)
			if !links.inferredClassSymbol || !links.inferredClassSymbol.has(getSymbolId(target)) {
				var inferred TransientSymbol
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isTransientSymbol(target):
					inferred = target
				default:
					inferred = cloneSymbol(target)
				}
				inferred.exports = inferred.exports || createSymbolTable()
				inferred.members = inferred.members || createSymbolTable()
				inferred.flags |= source.flags & SymbolFlagsClass
				if source.exports. /* TODO(TS-TO-GO): was ? */ size {
					mergeSymbolTable(inferred.exports, source.exports)
				}
				if source.members. /* TODO(TS-TO-GO): was ? */ size {
					mergeSymbolTable(inferred.members, source.members)
				}
				(links.inferredClassSymbol || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.inferredClassSymbol = new Map() */ TODO)).set(getSymbolId(inferred), inferred)
				return inferred
			}
			return links.inferredClassSymbol.get(getSymbolId(target))
		}
	}
	getAssignedClassSymbol := func(decl Declaration) Symbol {
		assignmentSymbol := decl && getSymbolOfExpando(decl /*allowDeclaration*/, true)
		prototype := assignmentSymbol. /* TODO(TS-TO-GO): was ? */ exports. /* TODO(TS-TO-GO): was ? */ get("prototype" /* as __String */)
		init := prototype. /* TODO(TS-TO-GO): was ? */ valueDeclaration && getAssignedJSPrototype(prototype.valueDeclaration)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case init:
			return getSymbolOfDeclaration(init)
		default:
			return nil
		}
	}
	getSymbolOfExpando := func(node Node, allowDeclaration bool) Symbol {
		if !node.parent {
			return nil
		}
		var name /* TODO(TS-TO-GO) TypeNode UnionType: Expression | BindingName | undefined */ any
		var decl Node
		if isVariableDeclaration(node.parent) && node.parent.initializer == node {
			if !isInJSFile(node) && !(isVarConstLike(node.parent) && isFunctionLikeDeclaration(node)) {
				return nil
			}
			name = node.parent.name
			decl = node.parent
		} else if isBinaryExpression(node.parent) {
			parentNode := node.parent
			parentNodeOperator := node.parent.operatorToken.kind
			if parentNodeOperator == SyntaxKindEqualsToken && (allowDeclaration || parentNode.right == node) {
				name = parentNode.left
				decl = name
			} else if parentNodeOperator == SyntaxKindBarBarToken || parentNodeOperator == SyntaxKindQuestionQuestionToken {
				if isVariableDeclaration(parentNode.parent) && parentNode.parent.initializer == parentNode {
					name = parentNode.parent.name
					decl = parentNode.parent
				} else if isBinaryExpression(parentNode.parent) && parentNode.parent.operatorToken.kind == SyntaxKindEqualsToken && (allowDeclaration || parentNode.parent.right == parentNode) {
					name = parentNode.parent.left
					decl = name
				}
				if !name || !isBindableStaticNameExpression(name) || !isSameEntityName(name, parentNode.left) {
					return nil
				}
			}
		} else if allowDeclaration && isFunctionDeclaration(node) {
			name = node.name
			decl = node
		}
		if !decl || !name || (!allowDeclaration && !getExpandoInitializer(node, isPrototypeAccess(name))) {
			return nil
		}
		return getSymbolOfNode(decl)
	}
	getAssignedJSPrototype := func(node Node) * /* TODO(TS-TO-GO) inferred type false | ObjectLiteralExpression */ any {
		if !node.parent {
			return false
		}
		var parent Node = node.parent
		for parent && parent.kind == SyntaxKindPropertyAccessExpression {
			parent = parent.parent
		}
		if parent && isBinaryExpression(parent) && isPrototypeAccess(parent.left) && parent.operatorToken.kind == SyntaxKindEqualsToken {
			right := getInitializerOfBinaryExpression(parent)
			return isObjectLiteralExpression(right) && right
		}
	}
	/**
	 * Syntactically and semantically checks a call or new expression.
	 * @param node The call/new expression to be checked.
	 * @returns On success, the expression's signature's return type. On failure, anyType.
	 */
	checkCallExpression := func(node /* TODO(TS-TO-GO) TypeNode UnionType: CallExpression | NewExpression */ any, checkMode CheckMode) Type {
		checkGrammarTypeArguments(node, node.typeArguments)
		signature := getResolvedSignature(node /*candidatesOutArray*/, nil, checkMode)
		if signature == resolvingSignature {
			// CheckMode.SkipGenericFunctions is enabled and this is a call to a generic function that
			// returns a function type. We defer checking and return silentNeverType.
			return silentNeverType
		}
		checkDeprecatedSignature(signature, node)
		if node.expression.kind == SyntaxKindSuperKeyword {
			return voidType
		}
		if node.kind == SyntaxKindNewExpression {
			declaration := signature.declaration
			if declaration && declaration.kind != SyntaxKindConstructor && declaration.kind != SyntaxKindConstructSignature && declaration.kind != SyntaxKindConstructorType && !(isJSDocSignature(declaration) && getJSDocRoot(declaration). /* TODO(TS-TO-GO): was ? */ parent. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindConstructor) && !isJSDocConstructSignature(declaration) && !isJSConstructor(declaration) {
				// When resolved signature is a call signature (and not a construct signature) the result type is any
				if noImplicitAny {
					error(node, Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type)
				}
				return anyType
			}
		}
		// In JavaScript files, calls to any identifier 'require' are treated as external module imports
		if isInJSFile(node) && isCommonJsRequire(node) {
			return resolveExternalModuleTypeByLiteral(node.arguments[0] /* as StringLiteral */)
		}
		returnType := getReturnTypeOfSignature(signature)
		// Treat any call to the global 'Symbol' function that is part of a const variable or readonly property
		// as a fresh unique symbol literal type.
		if returnType.flags&TypeFlagsESSymbolLike && isSymbolOrSymbolForCall(node) {
			return getESSymbolLikeTypeForNode(walkUpParenthesizedExpressions(node.parent))
		}
		if node.kind == SyntaxKindCallExpression && !node.questionDotToken && node.parent.kind == SyntaxKindExpressionStatement && returnType.flags&TypeFlagsVoid && getTypePredicateOfSignature(signature) {
			if !isDottedName(node.expression) {
				error(node.expression, Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name)
			} else if !getEffectsSignature(node) {
				diagnostic := error(node.expression, Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation)
				getTypeOfDottedName(node.expression, diagnostic)
			}
		}
		if isInJSFile(node) {
			jsSymbol := getSymbolOfExpando(node /*allowDeclaration*/, false)
			if jsSymbol. /* TODO(TS-TO-GO): was ? */ exports. /* TODO(TS-TO-GO): was ? */ size {
				jsAssignmentType := createAnonymousType(jsSymbol, jsSymbol.exports, emptyArray, emptyArray, emptyArray)
				jsAssignmentType.objectFlags |= ObjectFlagsJSLiteral
				return getIntersectionType([]Type{returnType, jsAssignmentType})
			}
		}
		return returnType
	}
	checkDeprecatedSignature := func(signature Signature, node CallLikeExpression) {
		if signature.flags & SignatureFlagsIsSignatureCandidateForOverloadFailure {
			return
		}
		if signature.declaration && signature.declaration.flags&NodeFlagsDeprecated {
			suggestionNode := getDeprecatedSuggestionNode(node)
			name := tryGetPropertyAccessOrIdentifierToString(getInvokedExpression(node))
			addDeprecatedSuggestionWithSignature(suggestionNode, signature.declaration, name, signatureToString(signature))
		}
	}
	getDeprecatedSuggestionNode := func(node Node) Node {
		node = skipParentheses(node)
		switch node.kind {
		case SyntaxKindCallExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindDecorator:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNewExpression:
			return getDeprecatedSuggestionNode((node /* as Decorator | CallExpression | NewExpression */).expression)
		case SyntaxKindTaggedTemplateExpression:
			return getDeprecatedSuggestionNode((node /* as TaggedTemplateExpression */).tag)
		case SyntaxKindJsxOpeningElement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJsxSelfClosingElement:
			return getDeprecatedSuggestionNode((node /* as JsxOpeningLikeElement */).tagName)
		case SyntaxKindElementAccessExpression:
			return (node /* as ElementAccessExpression */).argumentExpression
		case SyntaxKindPropertyAccessExpression:
			return (node /* as PropertyAccessExpression */).name
		case SyntaxKindTypeReference:
			typeReference := node /* as TypeReferenceNode */
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isQualifiedName(typeReference.typeName):
				return typeReference.typeName.right
			default:
				return typeReference
			}
		default:
			return node
		}
	}
	isSymbolOrSymbolForCall := func(node Node) bool {
		if !isCallExpression(node) {
			return false
		}
		left := node.expression
		if isPropertyAccessExpression(left) && left.name.escapedText == "for" {
			left = left.expression
		}
		if !isIdentifier(left) || left.escapedText != "Symbol" {
			return false
		}
		// make sure `Symbol` is the global symbol
		globalESSymbol := getGlobalESSymbolConstructorSymbol(false)
		if !globalESSymbol {
			return false
		}
		return globalESSymbol == resolveName(left, "Symbol" /* as __String */, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, false)
	}
	checkImportCallExpression := func(node ImportCall) Type {
		// Check grammar of dynamic import
		checkGrammarImportCallExpression(node)
		if node.arguments.length == 0 {
			return createPromiseReturnType(node, anyType)
		}
		specifier := node.arguments[0]
		specifierType := checkExpressionCached(specifier)
		var optionsType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.arguments.length > 1:
			optionsType = checkExpressionCached(node.arguments[1])
		default:
			optionsType = nil
		}
		// Even though multiple arguments is grammatically incorrect, type-check extra arguments for completion
		for i := 2; i < node.arguments.length; i++ {
			checkExpressionCached(node.arguments[i])
		}
		if specifierType.flags&TypeFlagsUndefined || specifierType.flags&TypeFlagsNull || !isTypeAssignableTo(specifierType, stringType) {
			error(specifier, Diagnostics.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0, typeToString(specifierType))
		}
		if optionsType {
			importCallOptionsType := getGlobalImportCallOptionsType(true)
			if importCallOptionsType != emptyObjectType {
				checkTypeAssignableTo(optionsType, getNullableType(importCallOptionsType, TypeFlagsUndefined), node.arguments[1])
			}
		}
		// resolveExternalModuleName will return undefined if the moduleReferenceExpression is not a string literal
		moduleSymbol := resolveExternalModuleName(node, specifier)
		if moduleSymbol {
			esModuleSymbol := resolveESModuleSymbol(moduleSymbol, specifier /*dontResolveAlias*/, true /*suppressInteropError*/, false)
			if esModuleSymbol {
				return createPromiseReturnType(node, getTypeWithSyntheticDefaultOnly(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier) || getTypeWithSyntheticDefaultImportType(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier))
			}
		}
		return createPromiseReturnType(node, anyType)
	}
	createDefaultPropertyWrapperForModule := func(symbol Symbol, originalSymbol Symbol, anonymousSymbol Symbol) ResolvedType {
		memberTable := createSymbolTable()
		newSymbol := createSymbol(SymbolFlagsAlias, InternalSymbolNameDefault)
		newSymbol.parent = originalSymbol
		newSymbol.links.nameType = getStringLiteralType("default")
		newSymbol.links.aliasTarget = resolveSymbol(symbol)
		memberTable.set(InternalSymbolNameDefault, newSymbol)
		return createAnonymousType(anonymousSymbol, memberTable, emptyArray, emptyArray, emptyArray)
	}
	getTypeWithSyntheticDefaultOnly := func(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) Type {
		hasDefaultOnly := isOnlyImportableAsDefault(moduleSpecifier)
		if hasDefaultOnly && type_ && !isErrorType(type_) {
			synthType := type_ /* as SyntheticDefaultModuleType */
			if !synthType.defaultOnlyType {
				type_ := createDefaultPropertyWrapperForModule(symbol, originalSymbol)
				synthType.defaultOnlyType = type_
			}
			return synthType.defaultOnlyType
		}
		return nil
	}
	getTypeWithSyntheticDefaultImportType := func(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) Type {
		if allowSyntheticDefaultImports && type_ && !isErrorType(type_) {
			synthType := type_ /* as SyntheticDefaultModuleType */
			if !synthType.syntheticType {
				file := originalSymbol.declarations. /* TODO(TS-TO-GO): was ? */ find(isSourceFile)
				hasSyntheticDefault := canHaveSyntheticDefault(file, originalSymbol /*dontResolveAlias*/, false, moduleSpecifier)
				if hasSyntheticDefault {
					anonymousSymbol := createSymbol(SymbolFlagsTypeLiteral, InternalSymbolNameType)
					defaultContainingObject := createDefaultPropertyWrapperForModule(symbol, originalSymbol, anonymousSymbol)
					anonymousSymbol.links.type_ = defaultContainingObject
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isValidSpreadType(type_):
						synthType.syntheticType = getSpreadType(type_, defaultContainingObject, anonymousSymbol /*objectFlags*/, 0 /*readonly*/, false)
					default:
						synthType.syntheticType = defaultContainingObject
					}
				} else {
					synthType.syntheticType = type_
				}
			}
			return synthType.syntheticType
		}
		return type_
	}
	isCommonJsRequire := func(node Node) bool {
		if !isRequireCall(node /*requireStringLiteralLikeArgument*/, true) {
			return false
		}
		// Make sure require is not a local function
		if !isIdentifier(node.expression) {
			return Debug.fail()
		}
		resolvedRequire := resolveName(node.expression, node.expression.escapedText, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, true)
		// TODO: GH#18217
		if resolvedRequire == requireSymbol {
			return true
		}
		// project includes symbol named 'require' - make sure that it is ambient and local non-alias
		if resolvedRequire.flags & SymbolFlagsAlias {
			return false
		}
		var targetDeclarationKind /* TODO(TS-TO-GO) inferred type SyntaxKind.Unknown | SyntaxKind.VariableDeclaration | SyntaxKind.FunctionDeclaration */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case resolvedRequire.flags & SymbolFlagsFunction:
			targetDeclarationKind = SyntaxKindFunctionDeclaration
		case resolvedRequire.flags & SymbolFlagsVariable:
			targetDeclarationKind = SyntaxKindVariableDeclaration
		default:
			targetDeclarationKind = SyntaxKindUnknown
		}
		if targetDeclarationKind != SyntaxKindUnknown {
			decl := getDeclarationOfKind(resolvedRequire, targetDeclarationKind)
			// function/variable declaration should be ambient
			return !!decl && !!(decl.flags & NodeFlagsAmbient)
		}
		return false
	}
	checkTaggedTemplateExpression := func(node TaggedTemplateExpression) Type {
		if !checkGrammarTaggedTemplateChain(node) {
			checkGrammarTypeArguments(node, node.typeArguments)
		}
		if languageVersion < LanguageFeatureMinimumTargetTaggedTemplates {
			checkExternalEmitHelpers(node, ExternalEmitHelpersMakeTemplateObject)
		}
		signature := getResolvedSignature(node)
		checkDeprecatedSignature(signature, node)
		return getReturnTypeOfSignature(signature)
	}
	checkAssertion := func(node AssertionExpression, checkMode *CheckMode) Type {
		if node.kind == SyntaxKindTypeAssertionExpression {
			file := getSourceFileOfNode(node)
			if file && fileExtensionIsOneOf(file.fileName, []Extension{ExtensionCts, ExtensionMts}) {
				grammarErrorOnNode(node, Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead)
			}
		}
		return checkAssertionWorker(node, checkMode)
	}
	isValidConstAssertionArgument := func(node Node) bool {
		switch node.kind {
		case SyntaxKindStringLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNumericLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBigIntLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTrueKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFalseKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrayLiteralExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindObjectLiteralExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTemplateExpression:
			return true
		case SyntaxKindParenthesizedExpression:
			return isValidConstAssertionArgument((node /* as ParenthesizedExpression */).expression)
		case SyntaxKindPrefixUnaryExpression:
			op := (node /* as PrefixUnaryExpression */).operator
			arg := (node /* as PrefixUnaryExpression */).operand
			return op == SyntaxKindMinusToken && (arg.kind == SyntaxKindNumericLiteral || arg.kind == SyntaxKindBigIntLiteral) || op == SyntaxKindPlusToken && arg.kind == SyntaxKindNumericLiteral
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindElementAccessExpression:
			expr := skipParentheses((node /* as PropertyAccessExpression | ElementAccessExpression */).expression)
			var symbol Symbol
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isEntityNameExpression(expr):
				symbol = resolveEntityName(expr, SymbolFlagsValue /*ignoreErrors*/, true)
			default:
				symbol = nil
			}
			return !!(symbol && symbol.flags&SymbolFlagsEnum)
		}
		return false
	}
	checkAssertionWorker := func(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypeAssertion | AssertionExpression */ any, checkMode *CheckMode) Type {
		TODO_IDENTIFIER := getAssertionTypeAndExpression(node)
		exprType := checkExpression(expression, checkMode)
		if isConstTypeReference(type_) {
			if !isValidConstAssertionArgument(expression) {
				error(expression, Diagnostics.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals)
			}
			return getRegularTypeOfLiteralType(exprType)
		}
		links := getNodeLinks(node)
		links.assertionExpressionType = exprType
		checkSourceElement(type_)
		checkNodeDeferred(node)
		return getTypeFromTypeNode(type_)
	}
	getAssertionTypeAndExpression := func(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypeAssertion | AssertionExpression */ any) /* TODO(TS-TO-GO) inferred type { type: TypeNode; expression: Expression; } */ any {
		var type_ TypeNode
		var expression Expression
		switch node.kind {
		case SyntaxKindAsExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTypeAssertionExpression:
			type_ = node.type_
			expression = node.expression
			break
		case SyntaxKindParenthesizedExpression:
			type_ = getJSDocTypeAssertionType(node)
			expression = node.expression
			break
		}
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"type_":      type_,
			"expression": expression,
		}
	}
	checkAssertionDeferred := func(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypeAssertion | AssertionExpression */ any) {
		TODO_IDENTIFIER := getAssertionTypeAndExpression(node)
		var errNode /* TODO(TS-TO-GO) inferred type TypeNode | AssertionExpression */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isParenthesizedExpression(node):
			errNode = type_
		default:
			errNode = node
		}
		links := getNodeLinks(node)
		Debug.assertIsDefined(links.assertionExpressionType)
		exprType := getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(links.assertionExpressionType))
		targetType := getTypeFromTypeNode(type_)
		if !isErrorType(targetType) {
			addLazyDiagnostic(func() {
				widenedType := getWidenedType(exprType)
				if !isTypeComparableTo(targetType, widenedType) {
					checkTypeComparableTo(exprType, targetType, errNode, Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first)
				}
			})
		}
	}
	checkNonNullChain := func(node NonNullChain) Type {
		leftType := checkExpression(node.expression)
		nonOptionalType := getOptionalExpressionType(leftType, node.expression)
		return propagateOptionalTypeMarker(getNonNullableType(nonOptionalType), node, nonOptionalType != leftType)
	}
	checkNonNullAssertion := func(node NonNullExpression) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.flags & NodeFlagsOptionalChain:
			return checkNonNullChain(node /* as NonNullChain */)
		default:
			return getNonNullableType(checkExpression(node.expression))
		}
	}
	checkExpressionWithTypeArguments := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ExpressionWithTypeArguments | TypeQueryNode */ any) Type {
		checkGrammarExpressionWithTypeArguments(node)
		forEach(node.typeArguments, checkSourceElement)
		if node.kind == SyntaxKindExpressionWithTypeArguments {
			parent := walkUpParenthesizedExpressions(node.parent)
			if parent.kind == SyntaxKindBinaryExpression && (parent /* as BinaryExpression */).operatorToken.kind == SyntaxKindInstanceOfKeyword && isNodeDescendantOf(node, (parent /* as BinaryExpression */).right) {
				error(node, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_not_be_an_instantiation_expression)
			}
		}
		var exprType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.kind == SyntaxKindExpressionWithTypeArguments:
			exprType = checkExpression(node.expression)
		case isThisIdentifier(node.exprName):
			exprType = checkThisExpression(node.exprName)
		default:
			exprType = checkExpression(node.exprName)
		}
		return getInstantiationExpressionType(exprType, node)
	}
	getInstantiationExpressionType := func(exprType Type, node NodeWithTypeArguments) Type {
		typeArguments := node.typeArguments
		if exprType == silentNeverType || isErrorType(exprType) || !some(typeArguments) {
			return exprType
		}
		hasSomeApplicableSignature := false
		var nonApplicableType Type
		result := getInstantiatedType(exprType)
		var errorType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case hasSomeApplicableSignature:
			errorType = nonApplicableType
		default:
			errorType = exprType
		}
		if errorType {
			diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable, typeToString(errorType)))
		}
		return result
		getInstantiatedType := func(type_ Type) Type {
			hasSignatures := false
			hasApplicableSignature := false
			result := getInstantiatedTypePart(type_)
			/* TODO(TS-TO-GO) Node BinaryExpression: hasSomeApplicableSignature ||= hasApplicableSignature */ TODO
			if hasSignatures && !hasApplicableSignature {
				/* TODO(TS-TO-GO) Node BinaryExpression: nonApplicableType ??= type */ TODO
			}
			return result
			getInstantiatedTypePart := func(type_ Type) Type {
				if type_.flags & TypeFlagsObject {
					resolved := resolveStructuredTypeMembers(type_ /* as ObjectType */)
					callSignatures := getInstantiatedSignatures(resolved.callSignatures)
					constructSignatures := getInstantiatedSignatures(resolved.constructSignatures)
					/* TODO(TS-TO-GO) Node BinaryExpression: hasSignatures ||= resolved.callSignatures.length !== 0 || resolved.constructSignatures.length !== 0 */ TODO
					/* TODO(TS-TO-GO) Node BinaryExpression: hasApplicableSignature ||= callSignatures.length !== 0 || constructSignatures.length !== 0 */ TODO
					if callSignatures != resolved.callSignatures || constructSignatures != resolved.constructSignatures {
						result := createAnonymousType(createSymbol(SymbolFlagsNone, InternalSymbolNameInstantiationExpression), resolved.members, callSignatures, constructSignatures, resolved.indexInfos) /* as ResolvedType & InstantiationExpressionType */
						result.objectFlags |= ObjectFlagsInstantiationExpressionType
						result.node = node
						return result
					}
				} else if type_.flags & TypeFlagsInstantiableNonPrimitive {
					constraint := getBaseConstraintOfType(type_)
					if constraint {
						instantiated := getInstantiatedTypePart(constraint)
						if instantiated != constraint {
							return instantiated
						}
					}
				} else if type_.flags & TypeFlagsUnion {
					return mapType(type_, getInstantiatedType)
				} else if type_.flags & TypeFlagsIntersection {
					return getIntersectionType(sameMap((type_ /* as IntersectionType */).types, getInstantiatedTypePart))
				}
				return type_
			}
		}
		getInstantiatedSignatures := func(signatures []Signature) []Signature {
			applicableSignatures := filter(signatures, func(sig Signature) bool {
				return !!sig.typeParameters && hasCorrectTypeArgumentArity(sig, typeArguments)
			})
			return sameMap(applicableSignatures, func(sig Signature) Signature {
				typeArgumentTypes := checkTypeArguments(sig, typeArguments /*reportErrors*/, true)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case typeArgumentTypes:
					return getSignatureInstantiation(sig, typeArgumentTypes, isInJSFile(sig.declaration))
				default:
					return sig
				}
			})
		}
	}
	checkSatisfiesExpression := func(node SatisfiesExpression) Type {
		checkSourceElement(node.type_)
		return checkSatisfiesExpressionWorker(node.expression, node.type_)
	}
	checkSatisfiesExpressionWorker := func(expression Expression, target TypeNode, checkMode CheckMode) Type {
		exprType := checkExpression(expression, checkMode)
		targetType := getTypeFromTypeNode(target)
		if isErrorType(targetType) {
			return targetType
		}
		errorNode := findAncestor(target.parent, func(n Node) bool {
			return n.kind == SyntaxKindSatisfiesExpression || n.kind == SyntaxKindJSDocSatisfiesTag
		})
		checkTypeAssignableToAndOptionallyElaborate(exprType, targetType, errorNode, expression, Diagnostics.Type_0_does_not_satisfy_the_expected_type_1)
		return exprType
	}
	checkMetaProperty := func(node MetaProperty) Type {
		checkGrammarMetaProperty(node)
		if node.keywordToken == SyntaxKindNewKeyword {
			return checkNewTargetMetaProperty(node)
		}
		if node.keywordToken == SyntaxKindImportKeyword {
			return checkImportMetaProperty(node)
		}
		return Debug.assertNever(node.keywordToken)
	}
	checkMetaPropertyKeyword := func(node MetaProperty) Type {
		switch node.keywordToken {
		case SyntaxKindImportKeyword:
			return getGlobalImportMetaExpressionType()
		case SyntaxKindNewKeyword:
			type_ := checkNewTargetMetaProperty(node)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isErrorType(type_):
				return errorType
			default:
				return createNewTargetExpressionType(type_)
			}
		default:
			Debug.assertNever(node.keywordToken)
		}
	}
	checkNewTargetMetaProperty := func(node MetaProperty) Type {
		container := getNewTargetContainer(node)
		if !container {
			error(node, Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor, "new.target")
			return errorType
		} else if container.kind == SyntaxKindConstructor {
			symbol := getSymbolOfDeclaration(container.parent)
			return getTypeOfSymbol(symbol)
		} else {
			symbol := getSymbolOfDeclaration(container)
			return getTypeOfSymbol(symbol)
		}
	}
	checkImportMetaProperty := func(node MetaProperty) /* TODO(TS-TO-GO) inferred type IntrinsicType | ObjectType */ any {
		if moduleKind == ModuleKindNode16 || moduleKind == ModuleKindNodeNext {
			if getSourceFileOfNode(node).impliedNodeFormat != ModuleKindESNext {
				error(node, Diagnostics.The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output)
			}
		} else if moduleKind < ModuleKindES2020 && moduleKind != ModuleKindSystem {
			error(node, Diagnostics.The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext)
		}
		file := getSourceFileOfNode(node)
		Debug.assert(!!(file.flags & NodeFlagsPossiblyContainsImportMeta), "Containing file is missing import meta node flag.")
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.name.escapedText == "meta":
			return getGlobalImportMetaType()
		default:
			return errorType
		}
	}
	getTypeOfParameter := func(symbol Symbol) Type {
		declaration := symbol.valueDeclaration
		return addOptionality(getTypeOfSymbol(symbol), false, !!declaration && (hasInitializer(declaration) || isOptionalDeclaration(declaration)))
	}
	/**
	 * Gets a tuple element label by recursively walking `ArrayBindingPattern` nodes in a `BindingName`.
	 * @param node The source node from which to derive a label
	 * @param index The index into the tuple
	 * @param elementFlags The {@see ElementFlags} of the tuple element
	 */
	getTupleElementLabelFromBindingElement := func(node /* TODO(TS-TO-GO) TypeNode UnionType: BindingElement | ParameterDeclaration */ any, index number, elementFlags ElementFlags) __String {
		switch node.name.kind {
		case SyntaxKindIdentifier:
			name := node.name.escapedText
			if node.dotDotDotToken {
				// given
				//   (...[x, y, ...z]: [number, number, ...number[]]) => ...
				// this produces
				//   (x: number, y: number, ...z: number[]) => ...
				// which preserves rest elements of 'z'
				// given
				//   (...[x, y, ...z]: [number, number, ...[...number[], number]]) => ...
				// this produces
				//   (x: number, y: number, ...z: number[], z_1: number) => ...
				// which preserves rest elements of z but gives distinct numbers to fixed elements of 'z'
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case elementFlags & ElementFlagsVariable:
					return name
				default:
					return __TEMPLATE__(name, "_", index) /* as __String */
				}
			} else {
				// given
				//   (...[x]: [number]) => ...
				// this produces
				//   (x: number) => ...
				// which preserves fixed elements of 'x'
				// given
				//   (...[x]: ...number[]) => ...
				// this produces
				//   (x_0: number) => ...
				// which which numbers fixed elements of 'x' whose tuple element type is variable
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case elementFlags & ElementFlagsFixed:
					return name
				default:
					return __TEMPLATE__(name, "_n") /* as __String */
				}
			}
			fallthrough
		case SyntaxKindArrayBindingPattern:
			if node.dotDotDotToken {
				elements := node.name.elements
				lastElement := tryCast(lastOrUndefined(elements), isBindingElement)
				elementCount := elements.length - (__COND__(lastElement. /* TODO(TS-TO-GO): was ? */ dotDotDotToken, 1, 0))
				if index < elementCount {
					element := elements[index]
					if isBindingElement(element) {
						return getTupleElementLabelFromBindingElement(element, index, elementFlags)
					}
				} else if lastElement. /* TODO(TS-TO-GO): was ? */ dotDotDotToken {
					return getTupleElementLabelFromBindingElement(lastElement, index-elementCount, elementFlags)
				}
			}
			break
		}
		return __TEMPLATE__("arg_", index) /* as __String */
	}
	/* TODO(TS-TO-GO): function getTupleElementLabel(d: ParameterDeclaration | NamedTupleMember): __String; */
	/* TODO(TS-TO-GO): function getTupleElementLabel(d: ParameterDeclaration | NamedTupleMember | undefined, index: number, elementFlags: ElementFlags, restSymbol?: Symbol): __String; */
	getTupleElementLabel := func(d /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | NamedTupleMember | undefined */ any, index number /*  = 0 */, elementFlags ElementFlags /*  = ElementFlags.Fixed */, restSymbol Symbol) __String {
		if !d {
			restParameter := tryCast(restSymbol. /* TODO(TS-TO-GO): was ? */ valueDeclaration, isParameter)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case restParameter:
				return getTupleElementLabelFromBindingElement(restParameter, index, elementFlags)
			default:
				return __TEMPLATE__( /* TODO(TS-TO-GO) Node BinaryExpression: restSymbol?.escapedName ?? "arg" */ TODO, "_", index) /* as __String */
			}
		}
		Debug.assert(isIdentifier(d.name))
		// Parameter declarations could be binding patterns, but we only allow identifier names
		return d.name.escapedText
	}
	getParameterNameAtPosition := func(signature Signature, pos number, overrideRestType Type) __String {
		paramCount := signature.parameters.length - (__COND__(signatureHasRestParameter(signature), 1, 0))
		if pos < paramCount {
			return signature.parameters[pos].escapedName
		}
		restParameter := signature.parameters[paramCount] || unknownSymbol
		restType := overrideRestType || getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			tupleType := (restType /* as TypeReference */).target /* as TupleType */
			index := pos - paramCount
			associatedName := tupleType.labeledElementDeclarations[index]
			elementFlags := tupleType.elementFlags[index]
			return getTupleElementLabel(associatedName, index, elementFlags, restParameter)
		}
		return restParameter.escapedName
	}
	getParameterIdentifierInfoAtPosition := func(signature Signature, pos number) * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { parameter: Identifier; parameterName: __String; isRestParameter: boolean; } */ any {
		if signature.declaration. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindJSDocFunctionType {
			return nil
		}
		paramCount := signature.parameters.length - (__COND__(signatureHasRestParameter(signature), 1, 0))
		if pos < paramCount {
			param := signature.parameters[pos]
			paramIdent := getParameterDeclarationIdentifier(param)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case paramIdent:
				return map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"parameter":       paramIdent,
					"parameterName":   param.escapedName,
					"isRestParameter": false,
				}
			default:
				return nil
			}
		}
		restParameter := signature.parameters[paramCount] || unknownSymbol
		restIdent := getParameterDeclarationIdentifier(restParameter)
		if !restIdent {
			return nil
		}
		restType := getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			associatedNames := ((restType /* as TypeReference */).target /* as TupleType */).labeledElementDeclarations
			index := pos - paramCount
			associatedName := associatedNames[index]
			isRestTupleElement := !!associatedName. /* TODO(TS-TO-GO): was ? */ dotDotDotToken
			if associatedName {
				Debug.assert(isIdentifier(associatedName.name))
				return map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"parameter":       associatedName.name,
					"parameterName":   associatedName.name.escapedText,
					"isRestParameter": isRestTupleElement,
				}
			}
			return nil
		}
		if pos == paramCount {
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"parameter":       restIdent,
				"parameterName":   restParameter.escapedName,
				"isRestParameter": true,
			}
		}
		return nil
	}
	getParameterDeclarationIdentifier := func(symbol Symbol) * /* TODO(TS-TO-GO) inferred type false | Identifier */ any {
		return symbol.valueDeclaration && isParameter(symbol.valueDeclaration) && isIdentifier(symbol.valueDeclaration.name) && symbol.valueDeclaration.name
	}
	isValidDeclarationForTupleLabel := func(d Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: d is NamedTupleMember | (ParameterDeclaration & { name: Identifier; }) */ any {
		return d.kind == SyntaxKindNamedTupleMember || (isParameter(d) && d.name && isIdentifier(d.name))
	}
	getNameableDeclarationAtPosition := func(signature Signature, pos number) * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | NamedTupleMember */ any {
		paramCount := signature.parameters.length - (__COND__(signatureHasRestParameter(signature), 1, 0))
		if pos < paramCount {
			decl := signature.parameters[pos].valueDeclaration
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case decl && isValidDeclarationForTupleLabel(decl):
				return decl
			default:
				return nil
			}
		}
		restParameter := signature.parameters[paramCount] || unknownSymbol
		restType := getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			associatedNames := ((restType /* as TypeReference */).target /* as TupleType */).labeledElementDeclarations
			index := pos - paramCount
			return associatedNames && associatedNames[index]
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case restParameter.valueDeclaration && isValidDeclarationForTupleLabel(restParameter.valueDeclaration):
			return restParameter.valueDeclaration
		default:
			return nil
		}
	}
	getTypeAtPosition := func(signature Signature, pos number) Type {
		return tryGetTypeAtPosition(signature, pos) || anyType
	}
	tryGetTypeAtPosition := func(signature Signature, pos number) Type {
		paramCount := signature.parameters.length - (__COND__(signatureHasRestParameter(signature), 1, 0))
		if pos < paramCount {
			return getTypeOfParameter(signature.parameters[pos])
		}
		if signatureHasRestParameter(signature) {
			// We want to return the value undefined for an out of bounds parameter position,
			// so we need to check bounds here before calling getIndexedAccessType (which
			// otherwise would return the type 'undefined').
			restType := getTypeOfSymbol(signature.parameters[paramCount])
			index := pos - paramCount
			if !isTupleType(restType) || restType.target.combinedFlags&ElementFlagsVariable || index < restType.target.fixedLength {
				return getIndexedAccessType(restType, getNumberLiteralType(index))
			}
		}
		return nil
	}
	getRestTypeAtPosition := func(source Signature, pos number, readonly bool) Type {
		parameterCount := getParameterCount(source)
		minArgumentCount := getMinArgumentCount(source)
		restType := getEffectiveRestType(source)
		if restType && pos >= parameterCount-1 {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case pos == parameterCount-1:
				return restType
			default:
				return createArrayType(getIndexedAccessType(restType, numberType))
			}
		}
		types := []never{}
		flags := []never{}
		names := []never{}
		for i := pos; i < parameterCount; i++ {
			if !restType || i < parameterCount-1 {
				types.push(getTypeAtPosition(source, i))
				flags.push(__COND__(i < minArgumentCount, ElementFlagsRequired, ElementFlagsOptional))
			} else {
				types.push(restType)
				flags.push(ElementFlagsVariadic)
			}
			names.push(getNameableDeclarationAtPosition(source, i))
		}
		return createTupleType(types, flags, readonly, names)
	}
	// Return the rest type at the given position, transforming `any[]` into just `any`. We do this because
	// in signatures we want `any[]` in a rest position to be compatible with anything, but `any[]` isn't
	// assignable to tuple types with required elements.
	getRestOrAnyTypeAtPosition := func(source Signature, pos number) Type {
		restType := getRestTypeAtPosition(source, pos)
		elementType := restType && getElementTypeOfArrayType(restType)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case elementType && isTypeAny(elementType):
			return anyType
		default:
			return restType
		}
	}
	// Return the number of parameters in a signature. The rest parameter, if present, counts as one
	// parameter. For example, the parameter count of (x: number, y: number, ...z: string[]) is 3 and
	// the parameter count of (x: number, ...args: [number, ...string[], boolean])) is also 3. In the
	// latter example, the effective rest type is [...string[], boolean].
	getParameterCount := func(signature Signature) number {
		length := signature.parameters.length
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol(signature.parameters[length-1])
			if isTupleType(restType) {
				return length + restType.target.fixedLength - (__COND__(restType.target.combinedFlags&ElementFlagsVariable, 0, 1))
			}
		}
		return length
	}
	getMinArgumentCount := func(signature Signature, flags MinArgumentCountFlags) number {
		strongArityForUntypedJS := flags & MinArgumentCountFlagsStrongArityForUntypedJS
		voidIsNonOptional := flags & MinArgumentCountFlagsVoidIsNonOptional
		if voidIsNonOptional || signature.resolvedMinArgumentCount == nil {
			var minArgumentCount *number
			if signatureHasRestParameter(signature) {
				restType := getTypeOfSymbol(signature.parameters[signature.parameters.length-1])
				if isTupleType(restType) {
					firstOptionalIndex := findIndex(restType.target.elementFlags, func(f ElementFlags) bool {
						return !(f & ElementFlagsRequired)
					})
					var requiredCount number
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case firstOptionalIndex < 0:
						requiredCount = restType.target.fixedLength
					default:
						requiredCount = firstOptionalIndex
					}
					if requiredCount > 0 {
						minArgumentCount = signature.parameters.length - 1 + requiredCount
					}
				}
			}
			if minArgumentCount == nil {
				if !strongArityForUntypedJS && signature.flags&SignatureFlagsIsUntypedSignatureInJSFile {
					return 0
				}
				minArgumentCount = signature.minArgumentCount
			}
			if voidIsNonOptional {
				return minArgumentCount
			}
			for i := minArgumentCount - 1; i >= 0; i-- {
				type_ := getTypeAtPosition(signature, i)
				if filterType(type_, acceptsVoid).flags & TypeFlagsNever {
					break
				}
				minArgumentCount = i
			}
			signature.resolvedMinArgumentCount = minArgumentCount
		}
		return signature.resolvedMinArgumentCount
	}
	hasEffectiveRestParameter := func(signature Signature) bool {
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol(signature.parameters[signature.parameters.length-1])
			return !isTupleType(restType) || !!(restType.target.combinedFlags & ElementFlagsVariable)
		}
		return false
	}
	getEffectiveRestType := func(signature Signature) Type {
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol(signature.parameters[signature.parameters.length-1])
			if !isTupleType(restType) {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isTypeAny(restType):
					return anyArrayType
				default:
					return restType
				}
			}
			if restType.target.combinedFlags & ElementFlagsVariable {
				return sliceTupleType(restType, restType.target.fixedLength)
			}
		}
		return nil
	}
	getNonArrayRestType := func(signature Signature) Type {
		restType := getEffectiveRestType(signature)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case restType && !isArrayType(restType) && !isTypeAny(restType):
			return restType
		default:
			return nil
		}
	}
	getTypeOfFirstParameterOfSignature := func(signature Signature) Type {
		return getTypeOfFirstParameterOfSignatureWithFallback(signature, neverType)
	}
	getTypeOfFirstParameterOfSignatureWithFallback := func(signature Signature, fallbackType Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case signature.parameters.length > 0:
			return getTypeAtPosition(signature, 0)
		default:
			return fallbackType
		}
	}
	inferFromAnnotatedParameters := func(signature Signature, context Signature, inferenceContext InferenceContext) {
		len := signature.parameters.length - (__COND__(signatureHasRestParameter(signature), 1, 0))
		for i := 0; i < len; i++ {
			declaration := signature.parameters[i].valueDeclaration /* as ParameterDeclaration */
			typeNode := getEffectiveTypeAnnotationNode(declaration)
			if typeNode {
				source := addOptionality(getTypeFromTypeNode(typeNode) /*isProperty*/, false, isOptionalDeclaration(declaration))
				target := getTypeAtPosition(context, i)
				inferTypes(inferenceContext.inferences, source, target)
			}
		}
	}
	assignContextualParameterTypes := func(signature Signature, context Signature) {
		if context.typeParameters {
			if !signature.typeParameters {
				signature.typeParameters = context.typeParameters
			} else {
				return
				// This signature has already has a contextual inference performed and cached on it!
			}
		}
		if context.thisParameter {
			parameter := signature.thisParameter
			if !parameter || parameter.valueDeclaration && !(parameter.valueDeclaration /* as ParameterDeclaration */).type_ {
				if !parameter {
					signature.thisParameter = createSymbolWithType(context.thisParameter /*type*/, nil)
				}
				assignParameterType(signature.thisParameter, getTypeOfSymbol(context.thisParameter))
			}
		}
		len := signature.parameters.length - (__COND__(signatureHasRestParameter(signature), 1, 0))
		for i := 0; i < len; i++ {
			parameter := signature.parameters[i]
			declaration := parameter.valueDeclaration /* as ParameterDeclaration */
			if !getEffectiveTypeAnnotationNode(declaration) {
				type_ := tryGetTypeAtPosition(context, i)
				if type_ && declaration.initializer {
					initializerType := checkDeclarationInitializer(declaration, CheckModeNormal)
					if !isTypeAssignableTo(initializerType, type_) && isTypeAssignableTo(type_ /* TODO(TS-TO-GO) Node BinaryExpression: initializerType = widenTypeInferredFromInitializer(declaration, initializerType) */, TODO) {
						type_ = initializerType
					}
				}
				assignParameterType(parameter, type_)
			}
		}
		if signatureHasRestParameter(signature) {
			// parameter might be a transient symbol generated by use of `arguments` in the function body.
			parameter := last(signature.parameters)
			if __COND__(parameter.valueDeclaration, !getEffectiveTypeAnnotationNode(parameter.valueDeclaration /* as ParameterDeclaration */), !!(getCheckFlags(parameter) & CheckFlagsDeferredType)) {
				contextualParameterType := getRestTypeAtPosition(context, len)
				assignParameterType(parameter, contextualParameterType)
			}
		}
	}
	assignNonContextualParameterTypes := func(signature Signature) {
		if signature.thisParameter {
			assignParameterType(signature.thisParameter)
		}
		for _, parameter := range signature.parameters {
			assignParameterType(parameter)
		}
	}
	assignParameterType := func(parameter Symbol, contextualType Type) {
		links := getSymbolLinks(parameter)
		if !links.type_ {
			declaration := parameter.valueDeclaration /* as ParameterDeclaration | undefined */
			links.type_ = addOptionality(contextualType || (__COND__(declaration, getWidenedTypeForVariableLikeDeclaration(declaration /*reportErrors*/, true), getTypeOfSymbol(parameter))), false, !!declaration && !declaration.initializer && isOptionalDeclaration(declaration))
			if declaration && declaration.name.kind != SyntaxKindIdentifier {
				// if inference didn't come up with anything but unknown, fall back to the binding pattern if present.
				if links.type_ == unknownType {
					links.type_ = getTypeFromBindingPattern(declaration.name)
				}
				assignBindingElementTypes(declaration.name, links.type_)
			}
		} else if contextualType {
			Debug.assertEqual(links.type_, contextualType, "Parameter symbol already has a cached type which differs from newly assigned type")
		}
	}
	// When contextual typing assigns a type to a parameter that contains a binding pattern, we also need to push
	// the destructured type into the contained binding elements.
	assignBindingElementTypes := func(pattern BindingPattern, parentType Type) {
		for _, element := range pattern.elements {
			if !isOmittedExpression(element) {
				type_ := getBindingElementTypeFromParentType(element, parentType /*noTupleBoundsCheck*/, false)
				if element.name.kind == SyntaxKindIdentifier {
					getSymbolLinks(getSymbolOfDeclaration(element)).type_ = type_
				} else {
					assignBindingElementTypes(element.name, type_)
				}
			}
		}
	}
	createClassDecoratorContextType := func(classType Type) Type {
		return tryCreateTypeReference(getGlobalClassDecoratorContextType(true), []Type{classType})
	}
	createClassMethodDecoratorContextType := func(thisType Type, valueType Type) Type {
		return tryCreateTypeReference(getGlobalClassMethodDecoratorContextType(true), []Type{thisType, valueType})
	}
	createClassGetterDecoratorContextType := func(thisType Type, valueType Type) Type {
		return tryCreateTypeReference(getGlobalClassGetterDecoratorContextType(true), []Type{thisType, valueType})
	}
	createClassSetterDecoratorContextType := func(thisType Type, valueType Type) Type {
		return tryCreateTypeReference(getGlobalClassSetterDecoratorContextType(true), []Type{thisType, valueType})
	}
	createClassAccessorDecoratorContextType := func(thisType Type, valueType Type) Type {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorContextType(true), []Type{thisType, valueType})
	}
	createClassFieldDecoratorContextType := func(thisType Type, valueType Type) Type {
		return tryCreateTypeReference(getGlobalClassFieldDecoratorContextType(true), []Type{thisType, valueType})
	}
	/**
	 * Gets a type like `{ name: "foo", private: false, static: true }` that is used to provided member-specific
	 * details that will be intersected with a decorator context type.
	 */
	getClassMemberDecoratorContextOverrideType := func(nameType Type, isPrivate bool, isStatic bool) Type {
		key := __TEMPLATE__(__COND__(isPrivate, "p", "P"), __COND__(isStatic, "s", "S"), nameType.id) /* as const */
		overrideType := decoratorContextOverrideTypeCache.get(key)
		if !overrideType {
			members := createSymbolTable()
			members.set("name" /* as __String */, createProperty("name" /* as __String */, nameType))
			members.set("private" /* as __String */, createProperty("private" /* as __String */, __COND__(isPrivate, trueType, falseType)))
			members.set("static" /* as __String */, createProperty("static" /* as __String */, __COND__(isStatic, trueType, falseType)))
			overrideType = createAnonymousType(nil, members, emptyArray, emptyArray, emptyArray)
			decoratorContextOverrideTypeCache.set(key, overrideType)
		}
		return overrideType
	}
	createClassMemberDecoratorContextTypeForNode := func(node /* TODO(TS-TO-GO) TypeNode UnionType: MethodDeclaration | AccessorDeclaration | PropertyDeclaration */ any, thisType Type, valueType Type) Type {
		isStatic := hasStaticModifier(node)
		isPrivate := isPrivateIdentifier(node.name)
		var nameType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isPrivate:
			nameType = getStringLiteralType(idText(node.name))
		default:
			nameType = getLiteralTypeFromPropertyName(node.name)
		}
		var contextType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isMethodDeclaration(node):
			contextType = createClassMethodDecoratorContextType(thisType, valueType)
		case isGetAccessorDeclaration(node):
			contextType = createClassGetterDecoratorContextType(thisType, valueType)
		case isSetAccessorDeclaration(node):
			contextType = createClassSetterDecoratorContextType(thisType, valueType)
		case isAutoAccessorPropertyDeclaration(node):
			contextType = createClassAccessorDecoratorContextType(thisType, valueType)
		case isPropertyDeclaration(node):
			contextType = createClassFieldDecoratorContextType(thisType, valueType)
		default:
			contextType = Debug.failBadSyntaxKind(node)
		}
		overrideType := getClassMemberDecoratorContextOverrideType(nameType, isPrivate, isStatic)
		return getIntersectionType([]Type{contextType, overrideType})
	}
	createClassAccessorDecoratorTargetType := func(thisType Type, valueType Type) Type {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorTargetType(true), []Type{thisType, valueType})
	}
	createClassAccessorDecoratorResultType := func(thisType Type, valueType Type) Type {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorResultType(true), []Type{thisType, valueType})
	}
	createClassFieldDecoratorInitializerMutatorType := func(thisType Type, valueType Type) ObjectType {
		thisParam := createParameter("this" /* as __String */, thisType)
		valueParam := createParameter("value" /* as __String */, valueType)
		return createFunctionType(nil, thisParam, []TransientSymbol{valueParam}, valueType /*typePredicate*/, nil, 1)
	}
	/**
	 * Creates a call signature for an ES Decorator. This method is used by the semantics of
	 * `getESDecoratorCallSignature`, which you should probably be using instead.
	 */
	createESDecoratorCallSignature := func(targetType Type, contextType Type, nonOptionalReturnType Type) Signature {
		targetParam := createParameter("target" /* as __String */, targetType)
		contextParam := createParameter("context" /* as __String */, contextType)
		returnType := getUnionType([]Type{nonOptionalReturnType, voidType})
		return createCallSignature(nil /*thisParameter*/, nil, []TransientSymbol{targetParam, contextParam}, returnType)
	}
	/**
	 * Gets a call signature that should be used when resolving `decorator` as a call. This does not use the value
	 * of the decorator itself, but instead uses the declaration on which it is placed along with its relative
	 * position amongst other decorators on the same declaration to determine the applicable signature. The
	 * resulting signature can be used for call resolution, inference, and contextual typing.
	 */
	getESDecoratorCallSignature := func(decorator Decorator) *Signature {
		// We are considering a future change that would allow the type of a decorator to affect the type of the
		// class and its members, such as a `@Stringify` decorator changing the type of a `number` field to `string`, or
		// a `@Callable` decorator adding a call signature to a `class`. The type arguments for the various context
		// types may eventually change to reflect such mutations.
		//
		// In some cases we describe such potential mutations as coming from a "prior decorator application". It is
		// important to note that, while decorators are *evaluated* left to right, they are *applied* right to left
		// to preserve f ৹ g -> f(g(x)) application order. In these cases, a "prior" decorator usually means the
		// next decorator following this one in document order.
		//
		// The "original type" of a class or member is the type it was declared as, or the type we infer from
		// initializers, before _any_ decorators are applied.
		//
		// The type of a class or member that is a result of a prior decorator application represents the
		// "current type", i.e., the type for the declaration at the time the decorator is _applied_.
		//
		// The type of a class or member that is the result of the application of *all* relevant decorators is the
		// "final type".
		//
		// Any decorator that allows mutation or replacement will also refer to an "input type" and an
		// "output type". The "input type" corresponds to the "current type" of the declaration, while the
		// "output type" will become either the "input type/current type" for a subsequent decorator application,
		// or the "final type" for the decorated declaration.
		//
		// It is important to understand decorator application order as it relates to how the "current", "input",
		// "output", and "final" types will be determined:
		//
		//  @E2 @E1 class SomeClass {
		//      @A2 @A1 static f() {}
		//      @B2 @B1 g() {}
		//      @C2 @C1 static x;
		//      @D2 @D1 y;
		//  }
		//
		// Per [the specification][1], decorators are applied in the following order:
		//
		// 1. For each static method (incl. get/set methods and `accessor` fields), in document order:
		//    a. Apply each decorator for that method, in reverse order (`A1`, `A2`).
		// 2. For each instance method (incl. get/set methods and `accessor` fields), in document order:
		//    a. Apply each decorator for that method, in reverse order (`B1`, `B2`).
		// 3. For each static field (excl. auto-accessors), in document order:
		//    a. Apply each decorator for that field, in reverse order (`C1`, `C2`).
		// 4. For each instance field (excl. auto-accessors), in document order:
		//    a. Apply each decorator for that field, in reverse order (`D1`, `D2`).
		// 5. Apply each decorator for the class, in reverse order (`E1`, `E2`).
		//
		// As a result, "current" types at each decorator application are as follows:
		// - For `A1`, the "current" types of the class and method are their "original" types.
		// - For `A2`, the "current type" of the method is the "output type" of `A1`, and the "current type" of the
		//   class is the type of `SomeClass` where `f` is the "output type" of `A1`. This becomes the "final type"
		//   of `f`.
		// - For `B1`, the "current type" of the method is its "original type", and the "current type" of the class
		//   is the type of `SomeClass` where `f` now has its "final type".
		// - etc.
		//
		// [1]: https://arai-a.github.io/ecma262-compare/?pr=2417&id=sec-runtime-semantics-classdefinitionevaluation
		//
		// This seems complicated at first glance, but is not unlike our existing inference for functions:
		//
		//  declare function pipe<Original, A1, A2, B1, B2, C1, C2, D1, D2, E1, E2>(
		//      original: Original,
		//      a1: (input: Original, context: Context<E2>) => A1,
		//      a2: (input: A1, context: Context<E2>) => A2,
		//      b1: (input: A2, context: Context<E2>) => B1,
		//      b2: (input: B1, context: Context<E2>) => B2,
		//      c1: (input: B2, context: Context<E2>) => C1,
		//      c2: (input: C1, context: Context<E2>) => C2,
		//      d1: (input: C2, context: Context<E2>) => D1,
		//      d2: (input: D1, context: Context<E2>) => D2,
		//      e1: (input: D2, context: Context<E2>) => E1,
		//      e2: (input: E1, context: Context<E2>) => E2,
		//  ): E2;
		// When a decorator is applied, it is passed two arguments: "target", which is a value representing the
		// thing being decorated (constructors for classes, functions for methods/accessors, `undefined` for fields,
		// and a `{ get, set }` object for auto-accessors), and "context", which is an object that provides
		// reflection information about the decorated element, as well as the ability to add additional "extra"
		// initializers. In most cases, the "target" argument corresponds to the "input type" in some way, and the
		// return value similarly corresponds to the "output type" (though if the "output type" is `void` or
		// `undefined` then the "output type" is the "input type").
		TODO_IDENTIFIER := decorator
		links := getNodeLinks(parent)
		if !links.decoratorSignature {
			links.decoratorSignature = anySignature
			switch parent.kind {
			case SyntaxKindClassDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindClassExpression:
				// Class decorators have a `context` of `ClassDecoratorContext<Class>`, where the `Class` type
				// argument will be the "final type" of the class after all decorators are applied.
				node := parent /* as ClassDeclaration | ClassExpression */
				targetType := getTypeOfSymbol(getSymbolOfDeclaration(node))
				contextType := createClassDecoratorContextType(targetType)
				links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, targetType)
				break
				fallthrough
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindSetAccessor:
				node := parent /* as MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration */
				if !isClassLike(node.parent) {
					break
				}
				// Method decorators have a `context` of `ClassMethodDecoratorContext<This, Value>`, where the
				// `Value` type argument corresponds to the "final type" of the method.
				//
				// Getter decorators have a `context` of `ClassGetterDecoratorContext<This, Value>`, where the
				// `Value` type argument corresponds to the "final type" of the value returned by the getter.
				//
				// Setter decorators have a `context` of `ClassSetterDecoratorContext<This, Value>`, where the
				// `Value` type argument corresponds to the "final type" of the parameter of the setter.
				//
				// In all three cases, the `This` type argument is the "final type" of either the class or
				// instance, depending on whether the member was `static`.
				var valueType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isMethodDeclaration(node):
					valueType = getOrCreateTypeFromSignature(getSignatureFromDeclaration(node))
				default:
					valueType = getTypeOfNode(node)
				}
				var thisType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case hasStaticModifier(node):
					thisType = getTypeOfSymbol(getSymbolOfDeclaration(node.parent))
				default:
					thisType = getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent))
				}
				// We wrap the "input type", if necessary, to match the decoration target. For getters this is
				// something like `() => inputType`, for setters it's `(value: inputType) => void` and for
				// methods it is just the input type.
				var targetType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isGetAccessorDeclaration(node):
					targetType = createGetterFunctionType(valueType)
				case isSetAccessorDeclaration(node):
					targetType = createSetterFunctionType(valueType)
				default:
					targetType = valueType
				}
				contextType := createClassMemberDecoratorContextTypeForNode(node, thisType, valueType)
				// We also wrap the "output type", as needed.
				var returnType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isGetAccessorDeclaration(node):
					returnType = createGetterFunctionType(valueType)
				case isSetAccessorDeclaration(node):
					returnType = createSetterFunctionType(valueType)
				default:
					returnType = valueType
				}
				links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType)
				break
				fallthrough
			case SyntaxKindPropertyDeclaration:
				node := parent /* as PropertyDeclaration */
				if !isClassLike(node.parent) {
					break
				}
				// Field decorators have a `context` of `ClassFieldDecoratorContext<This, Value>` and
				// auto-accessor decorators have a `context` of `ClassAccessorDecoratorContext<This, Value>. In
				// both cases, the `This` type argument is the "final type" of either the class or instance,
				// depending on whether the member was `static`, and the `Value` type argument corresponds to
				// the "final type" of the value stored in the field.
				valueType := getTypeOfNode(node)
				var thisType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case hasStaticModifier(node):
					thisType = getTypeOfSymbol(getSymbolOfDeclaration(node.parent))
				default:
					thisType = getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent))
				}
				// The `target` of an auto-accessor decorator is a `{ get, set }` object, representing the
				// runtime-generated getter and setter that are added to the class/prototype. The `target` of a
				// regular field decorator is always `undefined` as it isn't installed until it is initialized.
				var targetType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case hasAccessorModifier(node):
					targetType = createClassAccessorDecoratorTargetType(thisType, valueType)
				default:
					targetType = undefinedType
				}
				contextType := createClassMemberDecoratorContextTypeForNode(node, thisType, valueType)
				// We wrap the "output type" depending on the declaration. For auto-accessors, we wrap the
				// "output type" in a `ClassAccessorDecoratorResult<This, In, Out>` type, which allows for
				// mutation of the runtime-generated getter and setter, as well as the injection of an
				// initializer mutator. For regular fields, we wrap the "output type" in an initializer mutator.
				var returnType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case hasAccessorModifier(node):
					returnType = createClassAccessorDecoratorResultType(thisType, valueType)
				default:
					returnType = createClassFieldDecoratorInitializerMutatorType(thisType, valueType)
				}
				links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType)
				break
			}
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case links.decoratorSignature == anySignature:
			return nil
		default:
			return links.decoratorSignature
		}
	}
	getLegacyDecoratorCallSignature := func(decorator Decorator) *Signature {
		TODO_IDENTIFIER := decorator
		links := getNodeLinks(parent)
		if !links.decoratorSignature {
			links.decoratorSignature = anySignature
			switch parent.kind {
			case SyntaxKindClassDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindClassExpression:
				node := parent /* as ClassDeclaration | ClassExpression */
				// For a class decorator, the `target` is the type of the class (e.g. the
				// "static" or "constructor" side of the class).
				targetType := getTypeOfSymbol(getSymbolOfDeclaration(node))
				targetParam := createParameter("target" /* as __String */, targetType)
				links.decoratorSignature = createCallSignature(nil, nil, []TransientSymbol{targetParam}, getUnionType([]Type{targetType, voidType}))
				break
				fallthrough
			case SyntaxKindParameter:
				node := parent /* as ParameterDeclaration */
				if !isConstructorDeclaration(node.parent) && !(isMethodDeclaration(node.parent) || isSetAccessorDeclaration(node.parent) && isClassLike(node.parent.parent)) {
					break
				}
				if getThisParameter(node.parent) == node {
					break
				}
				var index number
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case getThisParameter(node.parent):
					index = node.parent.parameters.indexOf(node) - 1
				default:
					index = node.parent.parameters.indexOf(node)
				}
				Debug.assert(index >= 0)
				// A parameter declaration decorator will have three arguments (see `ParameterDecorator` in
				// core.d.ts).
				var targetType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isConstructorDeclaration(node.parent):
					targetType = getTypeOfSymbol(getSymbolOfDeclaration(node.parent.parent))
				default:
					targetType = getParentTypeOfClassElement(node.parent)
				}
				var keyType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isConstructorDeclaration(node.parent):
					keyType = undefinedType
				default:
					keyType = getClassElementPropertyKeyType(node.parent)
				}
				indexType := getNumberLiteralType(index)
				targetParam := createParameter("target" /* as __String */, targetType)
				keyParam := createParameter("propertyKey" /* as __String */, keyType)
				indexParam := createParameter("parameterIndex" /* as __String */, indexType)
				links.decoratorSignature = createCallSignature(nil, nil, []TransientSymbol{targetParam, keyParam, indexParam}, voidType)
				break
				fallthrough
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindSetAccessor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindPropertyDeclaration:
				node := parent /* as MethodDeclaration | AccessorDeclaration | PropertyDeclaration */
				if !isClassLike(node.parent) {
					break
				}
				// A method or accessor declaration decorator will have either two or three arguments (see
				// `PropertyDecorator` and `MethodDecorator` in core.d.ts).
				targetType := getParentTypeOfClassElement(node)
				targetParam := createParameter("target" /* as __String */, targetType)
				keyType := getClassElementPropertyKeyType(node)
				keyParam := createParameter("propertyKey" /* as __String */, keyType)
				var returnType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isPropertyDeclaration(node):
					returnType = voidType
				default:
					returnType = createTypedPropertyDescriptorType(getTypeOfNode(node))
				}
				hasPropDesc := !isPropertyDeclaration(parent) || hasAccessorModifier(parent)
				if hasPropDesc {
					descriptorType := createTypedPropertyDescriptorType(getTypeOfNode(node))
					descriptorParam := createParameter("descriptor" /* as __String */, descriptorType)
					links.decoratorSignature = createCallSignature(nil, nil, []TransientSymbol{targetParam, keyParam, descriptorParam}, getUnionType([]Type{returnType, voidType}))
				} else {
					links.decoratorSignature = createCallSignature(nil, nil, []TransientSymbol{targetParam, keyParam}, getUnionType([]Type{returnType, voidType}))
				}
				break
			}
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case links.decoratorSignature == anySignature:
			return nil
		default:
			return links.decoratorSignature
		}
	}
	getDecoratorCallSignature := func(decorator Decorator) *Signature {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case legacyDecorators:
			return getLegacyDecoratorCallSignature(decorator)
		default:
			return getESDecoratorCallSignature(decorator)
		}
	}
	createPromiseType := func(promisedType Type) Type {
		// creates a `Promise<T>` type where `T` is the promisedType argument
		globalPromiseType := getGlobalPromiseType(true)
		if globalPromiseType != emptyGenericType {
			// if the promised type is itself a promise, get the underlying type; otherwise, fallback to the promised type
			// Unwrap an `Awaited<T>` to `T` to improve inference.
			promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType
			return createTypeReference(globalPromiseType, []Type{promisedType})
		}
		return unknownType
	}
	createPromiseLikeType := func(promisedType Type) Type {
		// creates a `PromiseLike<T>` type where `T` is the promisedType argument
		globalPromiseLikeType := getGlobalPromiseLikeType(true)
		if globalPromiseLikeType != emptyGenericType {
			// if the promised type is itself a promise, get the underlying type; otherwise, fallback to the promised type
			// Unwrap an `Awaited<T>` to `T` to improve inference.
			promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType
			return createTypeReference(globalPromiseLikeType, []Type{promisedType})
		}
		return unknownType
	}
	createPromiseReturnType := func(func_ /* TODO(TS-TO-GO) TypeNode UnionType: FunctionLikeDeclaration | ImportCall */ any, promisedType Type) Type {
		promiseType := createPromiseType(promisedType)
		if promiseType == unknownType {
			error(func_, __COND__(isImportCall(func_), Diagnostics.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option, Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option))
			return errorType
		} else if !getGlobalPromiseConstructorSymbol(true) {
			error(func_, __COND__(isImportCall(func_), Diagnostics.A_dynamic_import_call_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option, Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option))
		}
		return promiseType
	}
	createNewTargetExpressionType := func(targetType Type) Type {
		// Create a synthetic type `NewTargetExpression { target: TargetType; }`
		symbol := createSymbol(SymbolFlagsNone, "NewTargetExpression" /* as __String */)
		targetPropertySymbol := createSymbol(SymbolFlagsProperty, "target" /* as __String */, CheckFlagsReadonly)
		targetPropertySymbol.parent = symbol
		targetPropertySymbol.links.type_ = targetType
		members := createSymbolTable([]TransientSymbol{targetPropertySymbol})
		symbol.members = members
		return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
	}
	getReturnTypeFromBody := func(func_ FunctionLikeDeclaration, checkMode CheckMode) Type {
		if !func_.body {
			return errorType
		}
		functionFlags := getFunctionFlags(func_)
		isAsync := (functionFlags & FunctionFlagsAsync) != 0
		isGenerator := (functionFlags & FunctionFlagsGenerator) != 0
		var returnType Type
		var yieldType Type
		var nextType Type
		var fallbackReturnType Type = voidType
		if func_.body.kind != SyntaxKindBlock {
			returnType = checkExpressionCached(func_.body, checkMode && checkMode&~CheckModeSkipGenericFunctions)
			if isAsync {
				// From within an async function you can return either a non-promise value or a promise. Any
				// Promise/A+ compatible implementation will always assimilate any foreign promise, so the
				// return type of the body should be unwrapped to its awaited type, which we will wrap in
				// the native Promise<T> type later in this function.
				returnType = unwrapAwaitedType(checkAwaitedType(returnType /*withAlias*/, false /*errorNode*/, func_, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member))
			}
		} else if isGenerator {
			returnTypes := checkAndAggregateReturnExpressionTypes(func_, checkMode)
			if !returnTypes {
				fallbackReturnType = neverType
			} else if returnTypes.length > 0 {
				returnType = getUnionType(returnTypes, UnionReductionSubtype)
			}
			TODO_IDENTIFIER := checkAndAggregateYieldOperandTypes(func_, checkMode)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case some(yieldTypes):
				yieldType = getUnionType(yieldTypes, UnionReductionSubtype)
			default:
				yieldType = nil
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case some(nextTypes):
				nextType = getIntersectionType(nextTypes)
			default:
				nextType = nil
			}
		} else {
			types := checkAndAggregateReturnExpressionTypes(func_, checkMode)
			if !types {
				// For an async function, the return type will not be never, but rather a Promise for never.
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case functionFlags & FunctionFlagsAsync:
					return createPromiseReturnType(func_, neverType)
				default:
					return neverType
				}
				// Normal function
			}
			if types.length == 0 {
				// For an async function, the return type will not be void/undefined, but rather a Promise for void/undefined.
				contextualReturnType := getContextualReturnType(func_ /*contextFlags*/, nil)
				var returnType IntrinsicType
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case contextualReturnType && (unwrapReturnType(contextualReturnType, functionFlags) || voidType).flags&TypeFlagsUndefined:
					returnType = undefinedType
				default:
					returnType = voidType
				}
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case functionFlags & FunctionFlagsAsync:
					return createPromiseReturnType(func_, returnType)
				default:
					return returnType
				}
				// Normal function
			}
			// Return a union of the return expression types.
			returnType = getUnionType(types, UnionReductionSubtype)
		}
		if returnType || yieldType || nextType {
			if yieldType {
				reportErrorsFromWidening(func_, yieldType, WideningKindGeneratorYield)
			}
			if returnType {
				reportErrorsFromWidening(func_, returnType, WideningKindFunctionReturn)
			}
			if nextType {
				reportErrorsFromWidening(func_, nextType, WideningKindGeneratorNext)
			}
			if returnType && isUnitType(returnType) || yieldType && isUnitType(yieldType) || nextType && isUnitType(nextType) {
				contextualSignature := getContextualSignatureForFunctionLikeDeclaration(func_)
				var contextualType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case !contextualSignature:
					contextualType = nil
				case contextualSignature == getSignatureFromDeclaration(func_):
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isGenerator:
						contextualType = nil
					default:
						contextualType = returnType
					}
				default:
					contextualType = instantiateContextualType(getReturnTypeOfSignature(contextualSignature), func_ /*contextFlags*/, nil)
				}
				if isGenerator {
					yieldType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(yieldType, contextualType, IterationTypeKindYield, isAsync)
					returnType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(returnType, contextualType, IterationTypeKindReturn, isAsync)
					nextType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(nextType, contextualType, IterationTypeKindNext, isAsync)
				} else {
					returnType = getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(returnType, contextualType, isAsync)
				}
			}
			if yieldType {
				yieldType = getWidenedType(yieldType)
			}
			if returnType {
				returnType = getWidenedType(returnType)
			}
			if nextType {
				nextType = getWidenedType(nextType)
			}
		}
		if isGenerator {
			return createGeneratorType(yieldType || neverType, returnType || fallbackReturnType, nextType || getContextualIterationType(IterationTypeKindNext, func_) || unknownType, isAsync)
		} else {
			// From within an async function you can return either a non-promise value or a promise. Any
			// Promise/A+ compatible implementation will always assimilate any foreign promise, so the
			// return type of the body is awaited type of the body, wrapped in a native Promise<T> type.
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isAsync:
				return createPromiseType(returnType || fallbackReturnType)
			default:
				return returnType || fallbackReturnType
			}
		}
	}
	createGeneratorType := func(yieldType Type, returnType Type, nextType Type, isAsyncGenerator bool) ObjectType {
		var resolver IterationTypesResolver
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isAsyncGenerator:
			resolver = asyncIterationTypesResolver
		default:
			resolver = syncIterationTypesResolver
		}
		globalGeneratorType := resolver.getGlobalGeneratorType(false)
		yieldType = resolver.resolveIterationType(yieldType /*errorNode*/, nil) || unknownType
		returnType = resolver.resolveIterationType(returnType /*errorNode*/, nil) || unknownType
		if globalGeneratorType == emptyGenericType {
			// Fall back to the global IterableIterator type.
			globalIterableIteratorType := resolver.getGlobalIterableIteratorType(false)
			if globalIterableIteratorType != emptyGenericType {
				return createTypeFromGenericGlobalType(globalIterableIteratorType, []Type{yieldType, returnType, nextType})
			}
			// The global Generator type doesn't exist, so report an error
			resolver.getGlobalIterableIteratorType(true)
			return emptyObjectType
		}
		return createTypeFromGenericGlobalType(globalGeneratorType, []Type{yieldType, returnType, nextType})
	}
	checkAndAggregateYieldOperandTypes := func(func_ FunctionLikeDeclaration, checkMode *CheckMode) /* TODO(TS-TO-GO) inferred type { yieldTypes: Type[]; nextTypes: Type[]; } */ any {
		var yieldTypes []Type = []never{}
		var nextTypes []Type = []never{}
		isAsync := (getFunctionFlags(func_) & FunctionFlagsAsync) != 0
		forEachYieldExpression(func_.body /* as Block */, func(yieldExpression YieldExpression) {
			var yieldExpressionType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case yieldExpression.expression:
				yieldExpressionType = checkExpression(yieldExpression.expression, checkMode)
			default:
				yieldExpressionType = undefinedWideningType
			}
			pushIfUnique(yieldTypes, getYieldedTypeOfYieldExpression(yieldExpression, yieldExpressionType, anyType, isAsync))
			var nextType Type
			if yieldExpression.asteriskToken {
				iterationTypes := getIterationTypesOfIterable(yieldExpressionType, __COND__(isAsync, IterationUseAsyncYieldStar, IterationUseYieldStar), yieldExpression.expression)
				nextType = iterationTypes && iterationTypes.nextType
			} else {
				nextType = getContextualType(yieldExpression /*contextFlags*/, nil)
			}
			if nextType {
				pushIfUnique(nextTypes, nextType)
			}
		})
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"yieldTypes": yieldTypes,
			"nextTypes":  nextTypes,
		}
	}
	getYieldedTypeOfYieldExpression := func(node YieldExpression, expressionType Type, sentType Type, isAsync bool) Type {
		errorNode := node.expression || node
		// A `yield*` expression effectively yields everything that its operand yields
		var yieldedType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.asteriskToken:
			yieldedType = checkIteratedTypeOrElementType(__COND__(isAsync, IterationUseAsyncYieldStar, IterationUseYieldStar), expressionType, sentType, errorNode)
		default:
			yieldedType = expressionType
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case !isAsync:
			return yieldedType
		default:
			return getAwaitedType(yieldedType, errorNode, __COND__(node.asteriskToken, Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member, Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member))
		}
	}
	// Return the combined not-equal type facts for all cases except those between the start and end indices.
	getNotEqualFactsFromTypeofSwitch := func(start number, end number, witnesses []*string) TypeFacts {
		var facts TypeFacts = TypeFactsNone
		for i := 0; i < witnesses.length; i++ {
			var witness *string
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case i < start || i >= end:
				witness = witnesses[i]
			default:
				witness = nil
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case witness != nil:
				facts |= typeofNEFacts.get(witness) || TypeFactsTypeofNEHostObject
			default:
				facts |= 0
			}
		}
		return facts
	}
	isExhaustiveSwitchStatement := func(node SwitchStatement) bool {
		links := getNodeLinks(node)
		if links.isExhaustive == nil {
			links.isExhaustive = 0
			// Indicate resolution is in process
			exhaustive := computeExhaustiveSwitchStatement(node)
			if links.isExhaustive == 0 {
				links.isExhaustive = exhaustive
			}
		} else if links.isExhaustive == 0 {
			links.isExhaustive = false
			// Resolve circularity to false
		}
		return links.isExhaustive
	}
	computeExhaustiveSwitchStatement := func(node SwitchStatement) bool {
		if node.expression.kind == SyntaxKindTypeOfExpression {
			witnesses := getSwitchClauseTypeOfWitnesses(node)
			if !witnesses {
				return false
			}
			operandConstraint := getBaseConstraintOrType(checkExpressionCached((node.expression /* as TypeOfExpression */).expression))
			// Get the not-equal flags for all handled cases.
			notEqualFacts := getNotEqualFactsFromTypeofSwitch(0, 0, witnesses)
			if operandConstraint.flags & TypeFlagsAnyOrUnknown {
				// We special case the top types to be exhaustive when all cases are handled.
				return (TypeFactsAllTypeofNE & notEqualFacts) == TypeFactsAllTypeofNE
			}
			// A missing not-equal flag indicates that the type wasn't handled by some case.
			return !someType(operandConstraint, func(t Type) bool {
				return getTypeFacts(t, notEqualFacts) == notEqualFacts
			})
		}
		type_ := checkExpressionCached(node.expression)
		if !isLiteralType(type_) {
			return false
		}
		switchTypes := getSwitchClauseTypes(node)
		if !switchTypes.length || some(switchTypes, isNeitherUnitTypeNorNever) {
			return false
		}
		return eachTypeContainedIn(mapType(type_, getRegularTypeOfLiteralType), switchTypes)
	}
	functionHasImplicitReturn := func(func_ FunctionLikeDeclaration) *bool {
		return func_.endFlowNode && isReachableFlowNode(func_.endFlowNode)
	}
	/** NOTE: Return value of `[]` means a different thing than `undefined`. `[]` means func returns `void`, `undefined` means it returns `never`. */
	checkAndAggregateReturnExpressionTypes := func(func_ FunctionLikeDeclaration, checkMode *CheckMode) *[]Type {
		functionFlags := getFunctionFlags(func_)
		var aggregatedTypes []Type = []never{}
		hasReturnWithNoExpression := functionHasImplicitReturn(func_)
		hasReturnOfTypeNever := false
		forEachReturnStatement(func_.body /* as Block */, func(returnStatement ReturnStatement) {
			expr := returnStatement.expression
			if expr {
				expr = skipParentheses(expr /*excludeJSDocTypeAssertions*/, true)
				// Bare calls to this same function don't contribute to inference
				// and `return await` is also safe to unwrap here
				if functionFlags&FunctionFlagsAsync && expr.kind == SyntaxKindAwaitExpression {
					expr = skipParentheses((expr /* as AwaitExpression */).expression /*excludeJSDocTypeAssertions*/, true)
				}
				if expr.kind == SyntaxKindCallExpression && (expr /* as CallExpression */).expression.kind == SyntaxKindIdentifier && checkExpressionCached((expr /* as CallExpression */).expression).symbol == getMergedSymbol(func_.symbol) && (!isFunctionExpressionOrArrowFunction(func_.symbol.valueDeclaration) || isConstantReference((expr /* as CallExpression */).expression)) {
					hasReturnOfTypeNever = true
					return
				}
				type_ := checkExpressionCached(expr, checkMode && checkMode&~CheckModeSkipGenericFunctions)
				if functionFlags & FunctionFlagsAsync {
					// From within an async function you can return either a non-promise value or a promise. Any
					// Promise/A+ compatible implementation will always assimilate any foreign promise, so the
					// return type of the body should be unwrapped to its awaited type, which should be wrapped in
					// the native Promise<T> type by the caller.
					type_ = unwrapAwaitedType(checkAwaitedType(type_ /*withAlias*/, false, func_, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member))
				}
				if type_.flags & TypeFlagsNever {
					hasReturnOfTypeNever = true
				}
				pushIfUnique(aggregatedTypes, type_)
			} else {
				hasReturnWithNoExpression = true
			}
		})
		if aggregatedTypes.length == 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever || mayReturnNever(func_)) {
			return nil
		}
		if strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression && !(isJSConstructor(func_) && aggregatedTypes.some(func(t Type) bool {
			return t.symbol == func_.symbol
		})) {
			// Javascript "callable constructors", containing eg `if (!(this instanceof A)) return new A()` should not add undefined
			pushIfUnique(aggregatedTypes, undefinedType)
		}
		return aggregatedTypes
	}
	mayReturnNever := func(func_ FunctionLikeDeclaration) bool {
		switch func_.kind {
		case SyntaxKindFunctionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrowFunction:
			return true
		case SyntaxKindMethodDeclaration:
			return func_.parent.kind == SyntaxKindObjectLiteralExpression
		default:
			return false
		}
	}
	getTypePredicateFromBody := func(func_ FunctionLikeDeclaration) *TypePredicate {
		switch func_.kind {
		case SyntaxKindConstructor:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindSetAccessor:
			return nil
		}
		functionFlags := getFunctionFlags(func_)
		if functionFlags != FunctionFlagsNormal {
			return nil
		}
		// Only attempt to infer a type predicate if there's exactly one return.
		var singleReturn Expression
		if func_.body && func_.body.kind != SyntaxKindBlock {
			singleReturn = func_.body
			// arrow function
		} else {
			bailedEarly := forEachReturnStatement(func_.body /* as Block */, func(returnStatement ReturnStatement) *true {
				if singleReturn || !returnStatement.expression {
					return true
				}
				singleReturn = returnStatement.expression
			})
			if bailedEarly || !singleReturn || functionHasImplicitReturn(func_) {
				return nil
			}
		}
		return checkIfExpressionRefinesAnyParameter(func_, singleReturn)
	}
	checkIfExpressionRefinesAnyParameter := func(func_ FunctionLikeDeclaration, expr Expression) *TypePredicate {
		expr = skipParentheses(expr /*excludeJSDocTypeAssertions*/, true)
		returnType := checkExpressionCached(expr)
		if !(returnType.flags & TypeFlagsBoolean) {
			return nil
		}
		return forEach(func_.parameters, func(param ParameterDeclaration, i number) *TypePredicate {
			initType := getTypeOfSymbol(param.symbol)
			if !initType || initType.flags&TypeFlagsBoolean || !isIdentifier(param.name) || isSymbolAssigned(param.symbol) || isRestParameter(param) {
				// Refining "x: boolean" to "x is true" or "x is false" isn't useful.
				return
			}
			trueType := checkIfExpressionRefinesParameter(func_, expr, param, initType)
			if trueType {
				return createTypePredicate(TypePredicateKindIdentifier, unescapeLeadingUnderscores(param.name.escapedText), i, trueType)
			}
		})
	}
	checkIfExpressionRefinesParameter := func(func_ FunctionLikeDeclaration, expr Expression, param ParameterDeclaration, initType Type) Type {
		antecedent := (expr /* as Expression & { flowNode?: FlowNode; } */).flowNode || expr.parent.kind == SyntaxKindReturnStatement && (expr.parent /* as ReturnStatement */).flowNode || createFlowNode(FlowFlagsStart /*node*/, nil /*antecedent*/, nil)
		trueCondition := createFlowNode(FlowFlagsTrueCondition, expr, antecedent)
		trueType := getFlowTypeOfReference(param.name, initType, initType, func_, trueCondition)
		if trueType == initType {
			return nil
		}
		// "x is T" means that x is T if and only if it returns true. If it returns false then x is not T.
		// This means that if the function is called with an argument of type trueType, there can't be anything left in the `else` branch. It must reduce to `never`.
		falseCondition := createFlowNode(FlowFlagsFalseCondition, expr, antecedent)
		falseSubtype := getFlowTypeOfReference(param.name, initType, trueType, func_, falseCondition)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case falseSubtype.flags & TypeFlagsNever:
			return trueType
		default:
			return nil
		}
	}
	/**
	 * TypeScript Specification 1.0 (6.3) - July 2014
	 *   An explicitly typed function whose return type isn't the Void type,
	 *   the Any type, or a union type containing the Void or Any type as a constituent
	 *   must have at least one return statement somewhere in its body.
	 *   An exception to this rule is if the function implementation consists of a single 'throw' statement.
	 *
	 * @param returnType - return type of the function, can be undefined if return type is not explicitly specified
	 */
	checkAllCodePathsInNonVoidFunctionReturnOrThrow := func(func_ /* TODO(TS-TO-GO) TypeNode UnionType: FunctionLikeDeclaration | MethodSignature */ any, returnType Type) {
		addLazyDiagnostic(checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics)
		return
		checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics := func() {
			functionFlags := getFunctionFlags(func_)
			type_ := returnType && unwrapReturnType(returnType, functionFlags)
			// Functions with an explicitly specified return type that includes `void` or is exactly `any` or `undefined` don't
			// need any return statements.
			if type_ && (maybeTypeOfKind(type_, TypeFlagsVoid) || type_.flags&(TypeFlagsAny|TypeFlagsUndefined)) {
				return
			}
			// If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check.
			// also if HasImplicitReturn flag is not set this means that all codepaths in function body end with return or throw
			if func_.kind == SyntaxKindMethodSignature || nodeIsMissing(func_.body) || func_.body.kind != SyntaxKindBlock || !functionHasImplicitReturn(func_) {
				return
			}
			hasExplicitReturn := func_.flags & NodeFlagsHasExplicitReturn
			errorNode := getEffectiveReturnTypeNode(func_) || func_
			if type_ && type_.flags&TypeFlagsNever {
				error(errorNode, Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point)
			} else if type_ && !hasExplicitReturn {
				// minimal check: function has syntactic return type annotation and no explicit return statements in the body
				// this function does not conform to the specification.
				error(errorNode, Diagnostics.A_function_whose_declared_type_is_neither_undefined_void_nor_any_must_return_a_value)
			} else if type_ && strictNullChecks && !isTypeAssignableTo(undefinedType, type_) {
				error(errorNode, Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined)
			} else if compilerOptions.noImplicitReturns {
				if !type_ {
					// If return type annotation is omitted check if function has any explicit return statements.
					// If it does not have any - its inferred return type is void - don't do any checks.
					// Otherwise get inferred return type from function body and report error only if it is not void / anytype
					if !hasExplicitReturn {
						return
					}
					inferredReturnType := getReturnTypeOfSignature(getSignatureFromDeclaration(func_))
					if isUnwrappedReturnTypeUndefinedVoidOrAny(func_, inferredReturnType) {
						return
					}
				}
				error(errorNode, Diagnostics.Not_all_code_paths_return_a_value)
			}
		}
	}
	checkFunctionExpressionOrObjectLiteralMethod := func(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) Type {
		Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
		checkNodeDeferred(node)
		if isFunctionExpression(node) {
			checkCollisionsForDeclarationName(node, node.name)
		}
		// The identityMapper object is used to indicate that function expressions are wildcards
		if checkMode && checkMode&CheckModeSkipContextSensitive && isContextSensitive(node) {
			// Skip parameters, return signature with return type that retains noncontextual parts so inferences can still be drawn in an early stage
			if !getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(node) {
				// Return plain anyFunctionType if there is no possibility we'll make inferences from the return type
				contextualSignature := getContextualSignature(node)
				if contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature)) {
					links := getNodeLinks(node)
					if links.contextFreeType {
						return links.contextFreeType
					}
					returnType := getReturnTypeFromBody(node, checkMode)
					returnOnlySignature := createSignature(nil /*typeParameters*/, nil /*thisParameter*/, nil, emptyArray, returnType /*resolvedTypePredicate*/, nil, 0, SignatureFlagsIsNonInferrable)
					returnOnlyType := createAnonymousType(node.symbol, emptySymbols, []Signature{returnOnlySignature}, emptyArray, emptyArray)
					returnOnlyType.objectFlags |= ObjectFlagsNonInferrableType
					links.contextFreeType = returnOnlyType
					return links.contextFreeType
				}
			}
			return anyFunctionType
		}
		// Grammar checking
		hasGrammarError := checkGrammarFunctionLikeDeclaration(node)
		if !hasGrammarError && node.kind == SyntaxKindFunctionExpression {
			checkGrammarForGenerator(node)
		}
		contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode)
		return getTypeOfSymbol(getSymbolOfDeclaration(node))
	}
	contextuallyCheckFunctionExpressionOrObjectLiteralMethod := func(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) {
		links := getNodeLinks(node)
		// Check if function expression is contextually typed and assign parameter types if so.
		if !(links.flags & NodeCheckFlagsContextChecked) {
			contextualSignature := getContextualSignature(node)
			// If a type check is started at a function expression that is an argument of a function call, obtaining the
			// contextual type may recursively get back to here during overload resolution of the call. If so, we will have
			// already assigned contextual types.
			if !(links.flags & NodeCheckFlagsContextChecked) {
				links.flags |= NodeCheckFlagsContextChecked
				signature := firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node)), SignatureKindCall))
				if !signature {
					return
				}
				if isContextSensitive(node) {
					if contextualSignature {
						inferenceContext := getInferenceContext(node)
						var instantiatedContextualSignature *Signature
						if checkMode && checkMode&CheckModeInferential {
							inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext)
							restType := getEffectiveRestType(contextualSignature)
							if restType && restType.flags&TypeFlagsTypeParameter {
								instantiatedContextualSignature = instantiateSignature(contextualSignature, inferenceContext.nonFixingMapper)
							}
						}
						/* TODO(TS-TO-GO) Node BinaryExpression: instantiatedContextualSignature ||= inferenceContext ? instantiateSignature(contextualSignature, inferenceContext.mapper) : contextualSignature */ TODO
						assignContextualParameterTypes(signature, instantiatedContextualSignature)
					} else {
						// Force resolution of all parameter types such that the absence of a contextual type is consistently reflected.
						assignNonContextualParameterTypes(signature)
					}
				} else if contextualSignature && !node.typeParameters && contextualSignature.parameters.length > node.parameters.length {
					inferenceContext := getInferenceContext(node)
					if checkMode && checkMode&CheckModeInferential {
						inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext)
					}
				}
				if contextualSignature && !getReturnTypeFromAnnotation(node) && !signature.resolvedReturnType {
					returnType := getReturnTypeFromBody(node, checkMode)
					if !signature.resolvedReturnType {
						signature.resolvedReturnType = returnType
					}
				}
				checkSignatureDeclaration(node)
			}
		}
	}
	checkFunctionExpressionOrObjectLiteralMethodDeferred := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ArrowFunction | FunctionExpression | MethodDeclaration */ any) {
		Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
		functionFlags := getFunctionFlags(node)
		returnType := getReturnTypeFromAnnotation(node)
		checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType)
		if node.body {
			if !getEffectiveReturnTypeNode(node) {
				// There are some checks that are only performed in getReturnTypeFromBody, that may produce errors
				// we need. An example is the noImplicitAny errors resulting from widening the return expression
				// of a function. Because checking of function expression bodies is deferred, there was never an
				// appropriate time to do this during the main walk of the file (see the comment at the top of
				// checkFunctionExpressionBodies). So it must be done now.
				getReturnTypeOfSignature(getSignatureFromDeclaration(node))
			}
			if node.body.kind == SyntaxKindBlock {
				checkSourceElement(node.body)
			} else {
				// From within an async function you can return either a non-promise value or a promise. Any
				// Promise/A+ compatible implementation will always assimilate any foreign promise, so we
				// should not be checking assignability of a promise to the return type. Instead, we need to
				// check assignability of the awaited type of the expression body against the promised type of
				// its return type annotation.
				exprType := checkExpression(node.body)
				returnOrPromisedType := returnType && unwrapReturnType(returnType, functionFlags)
				if returnOrPromisedType {
					effectiveCheckNode := getEffectiveCheckNode(node.body)
					if (functionFlags & FunctionFlagsAsyncGenerator) == FunctionFlagsAsync {
						awaitedType := checkAwaitedType(exprType /*withAlias*/, false, effectiveCheckNode, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
						checkTypeAssignableToAndOptionallyElaborate(awaitedType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode)
					} else {
						checkTypeAssignableToAndOptionallyElaborate(exprType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode)
					}
				}
			}
		}
	}
	checkArithmeticOperandType := func(operand Node, type_ Type, diagnostic DiagnosticMessage, isAwaitValid bool /*  = false */) bool {
		if !isTypeAssignableTo(type_, numberOrBigIntType) {
			awaitedType := isAwaitValid && getAwaitedTypeOfPromise(type_)
			errorAndMaybeSuggestAwait(operand, !!awaitedType && isTypeAssignableTo(awaitedType, numberOrBigIntType), diagnostic)
			return false
		}
		return true
	}
	isReadonlyAssignmentDeclaration := func(d Declaration) bool {
		if !isCallExpression(d) {
			return false
		}
		if !isBindableObjectDefinePropertyCall(d) {
			return false
		}
		objectLitType := checkExpressionCached(d.arguments[2])
		valueType := getTypeOfPropertyOfType(objectLitType, "value" /* as __String */)
		if valueType {
			writableProp := getPropertyOfType(objectLitType, "writable" /* as __String */)
			writableType := writableProp && getTypeOfSymbol(writableProp)
			if !writableType || writableType == falseType || writableType == regularFalseType {
				return true
			}
			// We include this definition whereupon we walk back and check the type at the declaration because
			// The usual definition of `Object.defineProperty` will _not_ cause literal types to be preserved in the
			// argument types, should the type be contextualized by the call itself.
			if writableProp && writableProp.valueDeclaration && isPropertyAssignment(writableProp.valueDeclaration) {
				initializer := writableProp.valueDeclaration.initializer
				rawOriginalType := checkExpression(initializer)
				if rawOriginalType == falseType || rawOriginalType == regularFalseType {
					return true
				}
			}
			return false
		}
		setProp := getPropertyOfType(objectLitType, "set" /* as __String */)
		return !setProp
	}
	isReadonlySymbol := func(symbol Symbol) bool {
		// The following symbols are considered read-only:
		// Properties with a 'readonly' modifier
		// Variables declared with 'const'
		// Get accessors without matching set accessors
		// Enum members
		// Object.defineProperty assignments with writable false or no setter
		// Unions and intersections of the above (unions and intersections eagerly set isReadonly on creation)
		return !!(getCheckFlags(symbol)&CheckFlagsReadonly || symbol.flags&SymbolFlagsProperty && getDeclarationModifierFlagsFromSymbol(symbol)&ModifierFlagsReadonly || symbol.flags&SymbolFlagsVariable && getDeclarationNodeFlagsFromSymbol(symbol)&NodeFlagsConstant || symbol.flags&SymbolFlagsAccessor && !(symbol.flags&SymbolFlagsSetAccessor) || symbol.flags&SymbolFlagsEnumMember || some(symbol.declarations, isReadonlyAssignmentDeclaration))
	}
	isAssignmentToReadonlyEntity := func(expr Expression, symbol Symbol, assignmentKind AssignmentKind) bool {
		if assignmentKind == AssignmentKindNone {
			// no assigment means it doesn't matter whether the entity is readonly
			return false
		}
		if isReadonlySymbol(symbol) {
			// Allow assignments to readonly properties within constructors of the same class declaration.
			if symbol.flags&SymbolFlagsProperty && isAccessExpression(expr) && expr.expression.kind == SyntaxKindThisKeyword {
				// Look for if this is the constructor for the class that `symbol` is a property of.
				ctor := getContainingFunction(expr)
				if !(ctor && (ctor.kind == SyntaxKindConstructor || isJSConstructor(ctor))) {
					return true
				}
				if symbol.valueDeclaration {
					isAssignmentDeclaration := isBinaryExpression(symbol.valueDeclaration)
					isLocalPropertyDeclaration := ctor.parent == symbol.valueDeclaration.parent
					isLocalParameterProperty := ctor == symbol.valueDeclaration.parent
					isLocalThisPropertyAssignment := isAssignmentDeclaration && symbol.parent. /* TODO(TS-TO-GO): was ? */ valueDeclaration == ctor.parent
					isLocalThisPropertyAssignmentConstructorFunction := isAssignmentDeclaration && symbol.parent. /* TODO(TS-TO-GO): was ? */ valueDeclaration == ctor
					isWriteableSymbol := isLocalPropertyDeclaration || isLocalParameterProperty || isLocalThisPropertyAssignment || isLocalThisPropertyAssignmentConstructorFunction
					return !isWriteableSymbol
				}
			}
			return true
		}
		if isAccessExpression(expr) {
			// references through namespace import should be readonly
			node := skipParentheses(expr.expression)
			if node.kind == SyntaxKindIdentifier {
				symbol := getNodeLinks(node).resolvedSymbol
				if symbol.flags & SymbolFlagsAlias {
					declaration := getDeclarationOfAliasSymbol(symbol)
					return !!declaration && declaration.kind == SyntaxKindNamespaceImport
				}
			}
		}
		return false
	}
	checkReferenceExpression := func(expr Expression, invalidReferenceMessage DiagnosticMessage, invalidOptionalChainMessage DiagnosticMessage) bool {
		// References are combinations of identifiers, parentheses, and property accesses.
		node := skipOuterExpressions(expr, OuterExpressionKindsAssertions|OuterExpressionKindsParentheses)
		if node.kind != SyntaxKindIdentifier && !isAccessExpression(node) {
			error(expr, invalidReferenceMessage)
			return false
		}
		if node.flags & NodeFlagsOptionalChain {
			error(expr, invalidOptionalChainMessage)
			return false
		}
		return true
	}
	checkDeleteExpression := func(node DeleteExpression) Type {
		checkExpression(node.expression)
		expr := skipParentheses(node.expression)
		if !isAccessExpression(expr) {
			error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference)
			return booleanType
		}
		if isPropertyAccessExpression(expr) && isPrivateIdentifier(expr.name) {
			error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_private_identifier)
		}
		links := getNodeLinks(expr)
		symbol := getExportSymbolOfValueSymbolIfExported(links.resolvedSymbol)
		if symbol {
			if isReadonlySymbol(symbol) {
				error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property)
			} else {
				checkDeleteExpressionMustBeOptional(expr, symbol)
			}
		}
		return booleanType
	}
	checkDeleteExpressionMustBeOptional := func(expr AccessExpression, symbol Symbol) {
		type_ := getTypeOfSymbol(symbol)
		if strictNullChecks && !(type_.flags & (TypeFlagsAnyOrUnknown | TypeFlagsNever)) && !(__COND__(exactOptionalPropertyTypes, symbol.flags&SymbolFlagsOptional, hasTypeFacts(type_, TypeFactsIsUndefined))) {
			error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_optional)
		}
	}
	checkTypeOfExpression := func(node TypeOfExpression) Type {
		checkExpression(node.expression)
		return typeofType
	}
	checkVoidExpression := func(node VoidExpression) Type {
		checkNodeDeferred(node)
		return undefinedWideningType
	}
	checkAwaitGrammar := func(node /* TODO(TS-TO-GO) TypeNode UnionType: AwaitExpression | VariableDeclarationList */ any) bool {
		// Grammar checking
		hasError := false
		container := getContainingFunctionOrClassStaticBlock(node)
		if container && isClassStaticBlockDeclaration(container) {
			// NOTE: We report this regardless as to whether there are parse diagnostics.
			var message DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isAwaitExpression(node):
				message = Diagnostics.await_expression_cannot_be_used_inside_a_class_static_block
			default:
				message = Diagnostics.await_using_statements_cannot_be_used_inside_a_class_static_block
			}
			error(node, message)
			hasError = true
		} else if !(node.flags & NodeFlagsAwaitContext) {
			if isInTopLevelContext(node) {
				sourceFile := getSourceFileOfNode(node)
				if !hasParseDiagnostics(sourceFile) {
					var span *TextSpan
					if !isEffectiveExternalModule(sourceFile, compilerOptions) {
						/* TODO(TS-TO-GO) Node BinaryExpression: span ??= getSpanOfTokenAtPosition(sourceFile, node.pos) */ TODO
						var message DiagnosticMessage
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isAwaitExpression(node):
							message = Diagnostics.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module
						default:
							message = Diagnostics.await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module
						}
						diagnostic := createFileDiagnostic(sourceFile, span.start, span.length, message)
						diagnostics.add(diagnostic)
						hasError = true
					}
					switch moduleKind {
					case ModuleKindNode16:
						fallthrough // TODO(TS-TO-GO): merge cases
					case ModuleKindNodeNext:
						if sourceFile.impliedNodeFormat == ModuleKindCommonJS {
							/* TODO(TS-TO-GO) Node BinaryExpression: span ??= getSpanOfTokenAtPosition(sourceFile, node.pos) */ TODO
							diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level))
							hasError = true
							break
						}
						fallthrough
					case ModuleKindES2022:
						fallthrough // TODO(TS-TO-GO): merge cases
					case ModuleKindESNext:
						fallthrough // TODO(TS-TO-GO): merge cases
					case ModuleKindPreserve:
						fallthrough // TODO(TS-TO-GO): merge cases
					case ModuleKindSystem:
						if languageVersion >= ScriptTargetES2017 {
							break
						}
						fallthrough
					default:
						/* TODO(TS-TO-GO) Node BinaryExpression: span ??= getSpanOfTokenAtPosition(sourceFile, node.pos) */ TODO
						var message DiagnosticMessage
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case isAwaitExpression(node):
							message = Diagnostics.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher
						default:
							message = Diagnostics.Top_level_await_using_statements_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher
						}
						diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message))
						hasError = true
						break
					}
				}
			} else {
				// use of 'await' in non-async function
				sourceFile := getSourceFileOfNode(node)
				if !hasParseDiagnostics(sourceFile) {
					span := getSpanOfTokenAtPosition(sourceFile, node.pos)
					var message DiagnosticMessage
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isAwaitExpression(node):
						message = Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules
					default:
						message = Diagnostics.await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules
					}
					diagnostic := createFileDiagnostic(sourceFile, span.start, span.length, message)
					if container && container.kind != SyntaxKindConstructor && (getFunctionFlags(container)&FunctionFlagsAsync) == 0 {
						relatedInfo := createDiagnosticForNode(container, Diagnostics.Did_you_mean_to_mark_this_function_as_async)
						addRelatedInfo(diagnostic, relatedInfo)
					}
					diagnostics.add(diagnostic)
					hasError = true
				}
			}
		}
		if isAwaitExpression(node) && isInParameterInitializerBeforeContainingFunction(node) {
			// NOTE: We report this regardless as to whether there are parse diagnostics.
			error(node, Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer)
			hasError = true
		}
		return hasError
	}
	checkAwaitExpression := func(node AwaitExpression) Type {
		addLazyDiagnostic(func() bool {
			return checkAwaitGrammar(node)
		})
		operandType := checkExpression(node.expression)
		awaitedType := checkAwaitedType(operandType /*withAlias*/, true, node, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
		if awaitedType == operandType && !isErrorType(awaitedType) && !(operandType.flags & TypeFlagsAnyOrUnknown) {
			addErrorOrSuggestion(false, createDiagnosticForNode(node, Diagnostics.await_has_no_effect_on_the_type_of_this_expression))
		}
		return awaitedType
	}
	checkPrefixUnaryExpression := func(node PrefixUnaryExpression) Type {
		operandType := checkExpression(node.operand)
		if operandType == silentNeverType {
			return silentNeverType
		}
		switch node.operand.kind {
		case SyntaxKindNumericLiteral:
			switch node.operator {
			case SyntaxKindMinusToken:
				return getFreshTypeOfLiteralType(getNumberLiteralType(-(node.operand /* as NumericLiteral */).text))
			case SyntaxKindPlusToken:
				return getFreshTypeOfLiteralType(getNumberLiteralType(+(node.operand /* as NumericLiteral */).text))
			}
			break
		case SyntaxKindBigIntLiteral:
			if node.operator == SyntaxKindMinusToken {
				return getFreshTypeOfLiteralType(getBigIntLiteralType(map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"negative":    true,
					"base10Value": parsePseudoBigInt((node.operand /* as BigIntLiteral */).text),
				}))
			}
		}
		switch node.operator {
		case SyntaxKindPlusToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMinusToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTildeToken:
			checkNonNullType(operandType, node.operand)
			if maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlagsESSymbolLike) {
				error(node.operand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(node.operator))
			}
			if node.operator == SyntaxKindPlusToken {
				if maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlagsBigIntLike) {
					error(node.operand, Diagnostics.Operator_0_cannot_be_applied_to_type_1, tokenToString(node.operator), typeToString(getBaseTypeOfLiteralType(operandType)))
				}
				return numberType
			}
			return getUnaryResultType(operandType)
		case SyntaxKindExclamationToken:
			checkTruthinessOfType(operandType, node.operand)
			facts := getTypeFacts(operandType, TypeFactsTruthy|TypeFactsFalsy)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case facts == TypeFactsTruthy:
				return falseType
			case facts == TypeFactsFalsy:
				return trueType
			default:
				return booleanType
			}
		case SyntaxKindPlusPlusToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMinusMinusToken:
			ok := checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type)
			if ok {
				// run check only if former checks succeeded to avoid reporting cascading errors
				checkReferenceExpression(node.operand, Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access)
			}
			return getUnaryResultType(operandType)
		}
		return errorType
	}
	checkPostfixUnaryExpression := func(node PostfixUnaryExpression) Type {
		operandType := checkExpression(node.operand)
		if operandType == silentNeverType {
			return silentNeverType
		}
		ok := checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type)
		if ok {
			// run check only if former checks succeeded to avoid reporting cascading errors
			checkReferenceExpression(node.operand, Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access)
		}
		return getUnaryResultType(operandType)
	}
	getUnaryResultType := func(operandType Type) Type {
		if maybeTypeOfKind(operandType, TypeFlagsBigIntLike) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isTypeAssignableToKind(operandType, TypeFlagsAnyOrUnknown) || maybeTypeOfKind(operandType, TypeFlagsNumberLike):
				return numberOrBigIntType
			default:
				return bigintType
			}
		}
		// If it's not a bigint type, implicit coercion will result in a number
		return numberType
	}
	maybeTypeOfKindConsideringBaseConstraint := func(type_ Type, kind TypeFlags) bool {
		if maybeTypeOfKind(type_, kind) {
			return true
		}
		baseConstraint := getBaseConstraintOrType(type_)
		return !!baseConstraint && maybeTypeOfKind(baseConstraint, kind)
	}
	// Return true if type might be of the given kind. A union or intersection type might be of a given
	// kind if at least one constituent type is of the given kind.
	maybeTypeOfKind := func(type_ Type, kind TypeFlags) bool {
		if type_.flags & kind {
			return true
		}
		if type_.flags & TypeFlagsUnionOrIntersection {
			types := (type_ /* as UnionOrIntersectionType */).types
			for _, t := range types {
				if maybeTypeOfKind(t, kind) {
					return true
				}
			}
		}
		return false
	}
	isTypeAssignableToKind := func(source Type, kind TypeFlags, strict bool) bool {
		if source.flags & kind {
			return true
		}
		if strict && source.flags&(TypeFlagsAnyOrUnknown|TypeFlagsVoid|TypeFlagsUndefined|TypeFlagsNull) {
			return false
		}
		return !!(kind&TypeFlagsNumberLike) && isTypeAssignableTo(source, numberType) || !!(kind&TypeFlagsBigIntLike) && isTypeAssignableTo(source, bigintType) || !!(kind&TypeFlagsStringLike) && isTypeAssignableTo(source, stringType) || !!(kind&TypeFlagsBooleanLike) && isTypeAssignableTo(source, booleanType) || !!(kind&TypeFlagsVoid) && isTypeAssignableTo(source, voidType) || !!(kind&TypeFlagsNever) && isTypeAssignableTo(source, neverType) || !!(kind&TypeFlagsNull) && isTypeAssignableTo(source, nullType) || !!(kind&TypeFlagsUndefined) && isTypeAssignableTo(source, undefinedType) || !!(kind&TypeFlagsESSymbol) && isTypeAssignableTo(source, esSymbolType) || !!(kind&TypeFlagsNonPrimitive) && isTypeAssignableTo(source, nonPrimitiveType)
	}
	allTypesAssignableToKind := func(source Type, kind TypeFlags, strict bool) bool {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case source.flags & TypeFlagsUnion:
			return every((source /* as UnionType */).types, func(subType Type) bool {
				return allTypesAssignableToKind(subType, kind, strict)
			})
		default:
			return isTypeAssignableToKind(source, kind, strict)
		}
	}
	isConstEnumObjectType := func(type_ Type) bool {
		return !!(getObjectFlags(type_) & ObjectFlagsAnonymous) && !!type_.symbol && isConstEnumSymbol(type_.symbol)
	}
	isConstEnumSymbol := func(symbol Symbol) bool {
		return (symbol.flags & SymbolFlagsConstEnum) != 0
	}
	/**
	 * Get the type of the `[Symbol.hasInstance]` method of an object type.
	 */
	getSymbolHasInstanceMethodOfObjectType := func(type_ Type) Type {
		hasInstancePropertyName := getPropertyNameForKnownSymbolName("hasInstance")
		if allTypesAssignableToKind(type_, TypeFlagsNonPrimitive) {
			hasInstanceProperty := getPropertyOfType(type_, hasInstancePropertyName)
			if hasInstanceProperty {
				hasInstancePropertyType := getTypeOfSymbol(hasInstanceProperty)
				if hasInstancePropertyType && getSignaturesOfType(hasInstancePropertyType, SignatureKindCall).length != 0 {
					return hasInstancePropertyType
				}
			}
		}
	}
	checkInstanceOfExpression := func(left Expression, right Expression, leftType Type, rightType Type, checkMode CheckMode) Type {
		if leftType == silentNeverType || rightType == silentNeverType {
			return silentNeverType
		}
		// TypeScript 1.0 spec (April 2014): 4.15.4
		// The instanceof operator requires the left operand to be of type Any, an object type, or a type parameter type,
		// and the right operand to be of type Any, a subtype of the 'Function' interface type, or have a call or construct signature.
		// The result is always of the Boolean primitive type.
		// NOTE: do not raise error if leftType is unknown as related error was already reported
		if !isTypeAny(leftType) && allTypesAssignableToKind(leftType, TypeFlagsPrimitive) {
			error(left, Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter)
		}
		Debug.assert(isInstanceOfExpression(left.parent))
		signature := getResolvedSignature(left.parent /*candidatesOutArray*/, nil, checkMode)
		if signature == resolvingSignature {
			// CheckMode.SkipGenericFunctions is enabled and this is a call to a generic function that
			// returns a function type. We defer checking and return silentNeverType.
			return silentNeverType
		}
		// If rightType has a `[Symbol.hasInstance]` method that is not `(value: unknown) => boolean`, we
		// must check the expression as if it were a call to `right[Symbol.hasInstance](left)`. The call to
		// `getResolvedSignature`, below, will check that leftType is assignable to the type of the first
		// parameter.
		returnType := getReturnTypeOfSignature(signature)
		// We also verify that the return type of the `[Symbol.hasInstance]` method is assignable to
		// `boolean`. According to the spec, the runtime will actually perform `ToBoolean` on the result,
		// but this is more type-safe.
		checkTypeAssignableTo(returnType, booleanType, right, Diagnostics.An_object_s_Symbol_hasInstance_method_must_return_a_boolean_value_for_it_to_be_used_on_the_right_hand_side_of_an_instanceof_expression)
		return booleanType
	}
	hasEmptyObjectIntersection := func(type_ Type) bool {
		return someType(type_, func(t Type) bool {
			return t == unknownEmptyObjectType || !!(t.flags&TypeFlagsIntersection) && isEmptyAnonymousObjectType(getBaseConstraintOrType(t))
		})
	}
	checkInExpression := func(left Expression, right Expression, leftType Type, rightType Type) Type {
		if leftType == silentNeverType || rightType == silentNeverType {
			return silentNeverType
		}
		if isPrivateIdentifier(left) {
			if languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !useDefineForClassFields {
				checkExternalEmitHelpers(left, ExternalEmitHelpersClassPrivateFieldIn)
			}
			// Unlike in 'checkPrivateIdentifierExpression' we now have access to the RHS type
			// which provides us with the opportunity to emit more detailed errors
			if !getNodeLinks(left).resolvedSymbol && getContainingClass(left) {
				isUncheckedJS := isUncheckedJSSuggestion(left, rightType.symbol /*excludeClasses*/, true)
				reportNonexistentProperty(left, rightType, isUncheckedJS)
			}
		} else {
			// The type of the lef operand must be assignable to string, number, or symbol.
			checkTypeAssignableTo(checkNonNullType(leftType, left), stringNumberSymbolType, left)
		}
		// The type of the right operand must be assignable to 'object'.
		if checkTypeAssignableTo(checkNonNullType(rightType, right), nonPrimitiveType, right) {
			// The {} type is assignable to the object type, yet {} might represent a primitive type. Here we
			// detect and error on {} that results from narrowing the unknown type, as well as intersections
			// that include {} (we know that the other types in such intersections are assignable to object
			// since we already checked for that).
			if hasEmptyObjectIntersection(rightType) {
				error(right, Diagnostics.Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator, typeToString(rightType))
			}
		}
		// The result is always of the Boolean primitive type.
		return booleanType
	}
	checkObjectLiteralAssignment := func(node ObjectLiteralExpression, sourceType Type, rightIsThis bool) Type {
		properties := node.properties
		if strictNullChecks && properties.length == 0 {
			return checkNonNullType(sourceType, node)
		}
		for i := 0; i < properties.length; i++ {
			checkObjectLiteralDestructuringPropertyAssignment(node, sourceType, i, properties, rightIsThis)
		}
		return sourceType
	}
	/** Note: If property cannot be a SpreadAssignment, then allProperties does not need to be provided */
	checkObjectLiteralDestructuringPropertyAssignment := func(node ObjectLiteralExpression, objectLiteralType Type, propertyIndex number, allProperties NodeArray[ObjectLiteralElementLike], rightIsThis bool /*  = false */) Type {
		properties := node.properties
		property := properties[propertyIndex]
		if property.kind == SyntaxKindPropertyAssignment || property.kind == SyntaxKindShorthandPropertyAssignment {
			name := property.name
			exprType := getLiteralTypeFromPropertyName(name)
			if isTypeUsableAsPropertyName(exprType) {
				text := getPropertyNameFromType(exprType)
				prop := getPropertyOfType(objectLiteralType, text)
				if prop {
					markPropertyAsReferenced(prop, property, rightIsThis)
					checkPropertyAccessibility(property /*isSuper*/, false /*writing*/, true, objectLiteralType, prop)
				}
			}
			elementType := getIndexedAccessType(objectLiteralType, exprType, AccessFlagsExpressionPosition|(__COND__(hasDefaultValue(property), AccessFlagsAllowMissing, 0)), name)
			type_ := getFlowTypeOfDestructuring(property, elementType)
			return checkDestructuringAssignment(__COND__(property.kind == SyntaxKindShorthandPropertyAssignment, property, property.initializer), type_)
		} else if property.kind == SyntaxKindSpreadAssignment {
			if propertyIndex < properties.length-1 {
				error(property, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
			} else {
				if languageVersion < LanguageFeatureMinimumTargetObjectSpreadRest {
					checkExternalEmitHelpers(property, ExternalEmitHelpersRest)
				}
				var nonRestNames []PropertyName = []never{}
				if allProperties {
					for _, otherProperty := range allProperties {
						if !isSpreadAssignment(otherProperty) {
							nonRestNames.push(otherProperty.name)
						}
					}
				}
				type_ := getRestType(objectLiteralType, nonRestNames, objectLiteralType.symbol)
				checkGrammarForDisallowedTrailingComma(allProperties, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
				return checkDestructuringAssignment(property.expression, type_)
			}
		} else {
			error(property, Diagnostics.Property_assignment_expected)
		}
	}
	checkArrayLiteralAssignment := func(node ArrayLiteralExpression, sourceType Type, checkMode CheckMode) Type {
		elements := node.elements
		if languageVersion < LanguageFeatureMinimumTargetDestructuringAssignment && compilerOptions.downlevelIteration {
			checkExternalEmitHelpers(node, ExternalEmitHelpersRead)
		}
		// This elementType will be used if the specific property corresponding to this index is not
		// present (aka the tuple element property). This call also checks that the parentType is in
		// fact an iterable or array (depending on target language).
		possiblyOutOfBoundsType := checkIteratedTypeOrElementType(IterationUseDestructuring|IterationUsePossiblyOutOfBounds, sourceType, undefinedType, node) || errorType
		var inBoundsType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case compilerOptions.noUncheckedIndexedAccess:
			inBoundsType = nil
		default:
			inBoundsType = possiblyOutOfBoundsType
		}
		for i := 0; i < elements.length; i++ {
			type_ := possiblyOutOfBoundsType
			if node.elements[i].kind == SyntaxKindSpreadElement {
				type_ = /* TODO(TS-TO-GO) Node BinaryExpression: inBoundsType = inBoundsType ?? (checkIteratedTypeOrElementType(IterationUse.Destructuring, sourceType, undefinedType, node) || errorType) */ TODO
			}
			checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, type_, checkMode)
		}
		return sourceType
	}
	checkArrayLiteralDestructuringElementAssignment := func(node ArrayLiteralExpression, sourceType Type, elementIndex number, elementType Type, checkMode CheckMode) Type {
		elements := node.elements
		element := elements[elementIndex]
		if element.kind != SyntaxKindOmittedExpression {
			if element.kind != SyntaxKindSpreadElement {
				indexType := getNumberLiteralType(elementIndex)
				if isArrayLikeType(sourceType) {
					// We create a synthetic expression so that getIndexedAccessType doesn't get confused
					// when the element is a SyntaxKind.ElementAccessExpression.
					accessFlags := AccessFlagsExpressionPosition | (__COND__(hasDefaultValue(element), AccessFlagsAllowMissing, 0))
					elementType := getIndexedAccessTypeOrUndefined(sourceType, indexType, accessFlags, createSyntheticExpression(element, indexType)) || errorType
					var assignedType Type
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case hasDefaultValue(element):
						assignedType = getTypeWithFacts(elementType, TypeFactsNEUndefined)
					default:
						assignedType = elementType
					}
					type_ := getFlowTypeOfDestructuring(element, assignedType)
					return checkDestructuringAssignment(element, type_, checkMode)
				}
				return checkDestructuringAssignment(element, elementType, checkMode)
			}
			if elementIndex < elements.length-1 {
				error(element, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
			} else {
				restExpression := (element /* as SpreadElement */).expression
				if restExpression.kind == SyntaxKindBinaryExpression && (restExpression /* as BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken {
					error((restExpression /* as BinaryExpression */).operatorToken, Diagnostics.A_rest_element_cannot_have_an_initializer)
				} else {
					checkGrammarForDisallowedTrailingComma(node.elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
					var type_ Type
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case everyType(sourceType, isTupleType):
						type_ = mapType(sourceType, func(t Type) Type {
							return sliceTupleType(t /* as TupleTypeReference */, elementIndex)
						})
					default:
						type_ = createArrayType(elementType)
					}
					return checkDestructuringAssignment(restExpression, type_, checkMode)
				}
			}
		}
		return nil
	}
	checkDestructuringAssignment := func(exprOrAssignment /* TODO(TS-TO-GO) TypeNode UnionType: Expression | ShorthandPropertyAssignment */ any, sourceType Type, checkMode CheckMode, rightIsThis bool) Type {
		var target Expression
		if exprOrAssignment.kind == SyntaxKindShorthandPropertyAssignment {
			prop := exprOrAssignment /* as ShorthandPropertyAssignment */
			if prop.objectAssignmentInitializer {
				// In strict null checking mode, if a default value of a non-undefined type is specified, remove
				// undefined from the final type.
				if strictNullChecks && !(hasTypeFacts(checkExpression(prop.objectAssignmentInitializer), TypeFactsIsUndefined)) {
					sourceType = getTypeWithFacts(sourceType, TypeFactsNEUndefined)
				}
				checkBinaryLikeExpression(prop.name, prop.equalsToken, prop.objectAssignmentInitializer, checkMode)
			}
			target = (exprOrAssignment /* as ShorthandPropertyAssignment */).name
		} else {
			target = exprOrAssignment
		}
		if target.kind == SyntaxKindBinaryExpression && (target /* as BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken {
			checkBinaryExpression(target /* as BinaryExpression */, checkMode)
			target = (target /* as BinaryExpression */).left
			// A default value is specified, so remove undefined from the final type.
			if strictNullChecks {
				sourceType = getTypeWithFacts(sourceType, TypeFactsNEUndefined)
			}
		}
		if target.kind == SyntaxKindObjectLiteralExpression {
			return checkObjectLiteralAssignment(target /* as ObjectLiteralExpression */, sourceType, rightIsThis)
		}
		if target.kind == SyntaxKindArrayLiteralExpression {
			return checkArrayLiteralAssignment(target /* as ArrayLiteralExpression */, sourceType, checkMode)
		}
		return checkReferenceAssignment(target, sourceType, checkMode)
	}
	checkReferenceAssignment := func(target Expression, sourceType Type, checkMode CheckMode) Type {
		targetType := checkExpression(target, checkMode)
		var error DiagnosticMessage
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case target.parent.kind == SyntaxKindSpreadAssignment:
			error = Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access
		default:
			error = Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access
		}
		var optionalError DiagnosticMessage
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case target.parent.kind == SyntaxKindSpreadAssignment:
			optionalError = Diagnostics.The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access
		default:
			optionalError = Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access
		}
		if checkReferenceExpression(target, error, optionalError) {
			checkTypeAssignableToAndOptionallyElaborate(sourceType, targetType, target, target)
		}
		if isPrivateIdentifierPropertyAccessExpression(target) {
			// NOTE: we do not limit this to LanguageFeatureTargets.PrivateNames as some other feature downleveling still requires this.
			checkExternalEmitHelpers(target.parent, ExternalEmitHelpersClassPrivateFieldSet)
		}
		return sourceType
	}
	/**
	 * This is a *shallow* check: An expression is side-effect-free if the
	 * evaluation of the expression *itself* cannot produce side effects.
	 * For example, x++ / 3 is side-effect free because the / operator
	 * does not have side effects.
	 * The intent is to "smell test" an expression for correctness in positions where
	 * its value is discarded (e.g. the left side of the comma operator).
	 */
	isSideEffectFree := func(node Node) bool {
		node = skipParentheses(node)
		switch node.kind {
		case SyntaxKindIdentifier:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindStringLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindRegularExpressionLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTaggedTemplateExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTemplateExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNumericLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBigIntLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTrueKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFalseKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNullKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindUndefinedKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindClassExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrayLiteralExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindObjectLiteralExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTypeOfExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNonNullExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJsxSelfClosingElement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJsxElement:
			return true
		case SyntaxKindConditionalExpression:
			return isSideEffectFree((node /* as ConditionalExpression */).whenTrue) && isSideEffectFree((node /* as ConditionalExpression */).whenFalse)
		case SyntaxKindBinaryExpression:
			if isAssignmentOperator((node /* as BinaryExpression */).operatorToken.kind) {
				return false
			}
			return isSideEffectFree((node /* as BinaryExpression */).left) && isSideEffectFree((node /* as BinaryExpression */).right)
		case SyntaxKindPrefixUnaryExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPostfixUnaryExpression:
			switch (node /* as PrefixUnaryExpression */).operator {
			case SyntaxKindExclamationToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindPlusToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindMinusToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindTildeToken:
				return true
			}
			return false
		case SyntaxKindVoidExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTypeAssertionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindAsExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		default:
			return false
		}
	}
	isTypeEqualityComparableTo := func(source Type, target Type) bool {
		return (target.flags&TypeFlagsNullable) != 0 || isTypeComparableTo(source, target)
	}
	createCheckBinaryExpression := func() /* TODO(TS-TO-GO) inferred type (node: BinaryExpression, checkMode: CheckMode | undefined) => Type */ any {
		type WorkArea struct {
			checkMode  *CheckMode
			skip       bool
			stackIndex number
			typeStack  []Type
		}
		trampoline := createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState)
		return func(node BinaryExpression, checkMode *CheckMode) Type {
			result := trampoline(node, checkMode)
			Debug.assertIsDefined(result)
			return result
		}
		onEnter := func(node BinaryExpression, state *WorkArea, checkMode *CheckMode) WorkArea {
			if state {
				state.stackIndex++
				state.skip = false
				setLeftType(state /*type*/, nil)
				setLastResult(state /*type*/, nil)
			} else {
				state = map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"checkMode":  checkMode,
					"skip":       false,
					"stackIndex": 0,
					"typeStack":  []undefined{nil, nil},
				}
			}
			if isInJSFile(node) && getAssignedExpandoInitializer(node) {
				state.skip = true
				setLastResult(state, checkExpression(node.right, checkMode))
				return state
			}
			checkNullishCoalesceOperands(node)
			operator := node.operatorToken.kind
			if operator == SyntaxKindEqualsToken && (node.left.kind == SyntaxKindObjectLiteralExpression || node.left.kind == SyntaxKindArrayLiteralExpression) {
				state.skip = true
				setLastResult(state, checkDestructuringAssignment(node.left, checkExpression(node.right, checkMode), checkMode, node.right.kind == SyntaxKindThisKeyword))
				return state
			}
			return state
		}
		onLeft := func(left Expression, state WorkArea, _node BinaryExpression) *BinaryExpression {
			if !state.skip {
				return maybeCheckExpression(state, left)
			}
		}
		onOperator := func(operatorToken BinaryOperatorToken, state WorkArea, node BinaryExpression) {
			if !state.skip {
				leftType := getLastResult(state)
				Debug.assertIsDefined(leftType)
				setLeftType(state, leftType)
				setLastResult(state /*type*/, nil)
				operator := operatorToken.kind
				if isLogicalOrCoalescingBinaryOperator(operator) {
					parent := node.parent
					for parent.kind == SyntaxKindParenthesizedExpression || isLogicalOrCoalescingBinaryExpression(parent) {
						parent = parent.parent
					}
					if operator == SyntaxKindAmpersandAmpersandToken || isIfStatement(parent) {
						checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.left, leftType, __COND__(isIfStatement(parent), parent.thenStatement, nil))
					}
					if isBinaryLogicalOperator(operator) {
						checkTruthinessOfType(leftType, node.left)
					}
				}
			}
		}
		onRight := func(right Expression, state WorkArea, _node BinaryExpression) *BinaryExpression {
			if !state.skip {
				return maybeCheckExpression(state, right)
			}
		}
		onExit := func(node BinaryExpression, state WorkArea) Type {
			var result Type
			if state.skip {
				result = getLastResult(state)
			} else {
				leftType := getLeftType(state)
				Debug.assertIsDefined(leftType)
				rightType := getLastResult(state)
				Debug.assertIsDefined(rightType)
				result = checkBinaryLikeExpressionWorker(node.left, node.operatorToken, node.right, leftType, rightType, state.checkMode, node)
			}
			state.skip = false
			setLeftType(state /*type*/, nil)
			setLastResult(state /*type*/, nil)
			state.stackIndex--
			return result
		}
		foldState := func(state WorkArea, result Type, _side /* TODO(TS-TO-GO) TypeNode UnionType: "left" | "right" */ any) WorkArea {
			setLastResult(state, result)
			return state
		}
		maybeCheckExpression := func(state WorkArea, node Expression) *BinaryExpression {
			if isBinaryExpression(node) {
				return node
			}
			setLastResult(state, checkExpression(node, state.checkMode))
		}
		getLeftType := func(state WorkArea) Type {
			return state.typeStack[state.stackIndex]
		}
		setLeftType := func(state WorkArea, type_ Type) {
			state.typeStack[state.stackIndex] = type_
		}
		getLastResult := func(state WorkArea) Type {
			return state.typeStack[state.stackIndex+1]
		}
		setLastResult := func(state WorkArea, type_ Type) {
			// To reduce overhead, reuse the next stack entry to store the
			// last result. This avoids the overhead of an additional property
			// on `WorkArea` and reuses empty stack entries as we walk back up
			// the stack.
			state.typeStack[state.stackIndex+1] = type_
		}
	}
	checkNullishCoalesceOperands := func(node BinaryExpression) {
		TODO_IDENTIFIER := node
		if operatorToken.kind == SyntaxKindQuestionQuestionToken {
			if isBinaryExpression(left) && (left.operatorToken.kind == SyntaxKindBarBarToken || left.operatorToken.kind == SyntaxKindAmpersandAmpersandToken) {
				grammarErrorOnNode(left, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(left.operatorToken.kind), tokenToString(operatorToken.kind))
			}
			if isBinaryExpression(right) && (right.operatorToken.kind == SyntaxKindBarBarToken || right.operatorToken.kind == SyntaxKindAmpersandAmpersandToken) {
				grammarErrorOnNode(right, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(right.operatorToken.kind), tokenToString(operatorToken.kind))
			}
			leftTarget := skipOuterExpressions(left, OuterExpressionKindsAll)
			nullishSemantics := getSyntacticNullishnessSemantics(leftTarget)
			if nullishSemantics != PredicateSemanticsSometimes {
				if node.parent.kind == SyntaxKindBinaryExpression {
					error(leftTarget, Diagnostics.This_binary_expression_is_never_nullish_Are_you_missing_parentheses)
				} else {
					if nullishSemantics == PredicateSemanticsAlways {
						error(leftTarget, Diagnostics.This_expression_is_always_nullish)
					} else {
						error(leftTarget, Diagnostics.Right_operand_of_is_unreachable_because_the_left_operand_is_never_nullish)
					}
				}
			}
		}
	}
	getSyntacticNullishnessSemantics := func(node Node) PredicateSemantics {
		node = skipOuterExpressions(node)
		switch node.kind {
		case SyntaxKindAwaitExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindCallExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindElementAccessExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNewExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindYieldExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindThisKeyword:
			return PredicateSemanticsSometimes
		case SyntaxKindBinaryExpression:
			switch (node /* as BinaryExpression */).operatorToken.kind {
			case SyntaxKindEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindQuestionQuestionToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindQuestionQuestionEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindBarBarToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindBarBarEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindAmpersandAmpersandToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindAmpersandAmpersandEqualsToken:
				return PredicateSemanticsSometimes
			}
			return PredicateSemanticsNever
		case SyntaxKindConditionalExpression:
			return getSyntacticNullishnessSemantics((node /* as ConditionalExpression */).whenTrue) | getSyntacticNullishnessSemantics((node /* as ConditionalExpression */).whenFalse)
		case SyntaxKindNullKeyword:
			return PredicateSemanticsAlways
		case SyntaxKindIdentifier:
			if getResolvedSymbol(node /* as Identifier */) == undefinedSymbol {
				return PredicateSemanticsAlways
			}
			return PredicateSemanticsSometimes
		}
		return PredicateSemanticsNever
	}
	// Note that this and `checkBinaryExpression` above should behave mostly the same, except this elides some
	// expression-wide checks and does not use a work stack to fold nested binary expressions into the same callstack frame
	checkBinaryLikeExpression := func(left Expression, operatorToken BinaryOperatorToken, right Expression, checkMode CheckMode, errorNode Node) Type {
		operator := operatorToken.kind
		if operator == SyntaxKindEqualsToken && (left.kind == SyntaxKindObjectLiteralExpression || left.kind == SyntaxKindArrayLiteralExpression) {
			return checkDestructuringAssignment(left, checkExpression(right, checkMode), checkMode, right.kind == SyntaxKindThisKeyword)
		}
		var leftType Type
		if isBinaryLogicalOperator(operator) {
			leftType = checkTruthinessExpression(left, checkMode)
		} else {
			leftType = checkExpression(left, checkMode)
		}
		rightType := checkExpression(right, checkMode)
		return checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, checkMode, errorNode)
	}
	checkBinaryLikeExpressionWorker := func(left Expression, operatorToken BinaryOperatorToken, right Expression, leftType Type, rightType Type, checkMode CheckMode, errorNode Node) Type {
		operator := operatorToken.kind
		switch operator {
		case SyntaxKindAsteriskToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindAsteriskAsteriskToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindAsteriskEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindAsteriskAsteriskEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindSlashToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindSlashEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPercentToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPercentEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMinusToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMinusEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindLessThanLessThanToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindLessThanLessThanEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindGreaterThanGreaterThanToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindGreaterThanGreaterThanEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindGreaterThanGreaterThanGreaterThanToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBarToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBarEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindCaretToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindCaretEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindAmpersandToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindAmpersandEqualsToken:
			if leftType == silentNeverType || rightType == silentNeverType {
				return silentNeverType
			}
			leftType = checkNonNullType(leftType, left)
			rightType = checkNonNullType(rightType, right)
			var suggestedOperator *PunctuationSyntaxKind
			if (leftType.flags & TypeFlagsBooleanLike) && (rightType.flags & TypeFlagsBooleanLike) && ( /* TODO(TS-TO-GO) Node BinaryExpression: suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind) */ TODO) != nil {
				error(errorNode || operatorToken, Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, tokenToString(operatorToken.kind), tokenToString(suggestedOperator))
				return numberType
			} else {
				// otherwise just check each operand separately and report errors as normal
				leftOk := checkArithmeticOperandType(left, leftType, Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type /*isAwaitValid*/, true)
				rightOk := checkArithmeticOperandType(right, rightType, Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type /*isAwaitValid*/, true)
				var resultType Type
				// If both are any or unknown, allow operation; assume it will resolve to number
				if (isTypeAssignableToKind(leftType, TypeFlagsAnyOrUnknown) && isTypeAssignableToKind(rightType, TypeFlagsAnyOrUnknown)) || !(maybeTypeOfKind(leftType, TypeFlagsBigIntLike) || maybeTypeOfKind(rightType, TypeFlagsBigIntLike)) {
					resultType = numberType
				} else if bothAreBigIntLike(leftType, rightType) {
					switch operator {
					case SyntaxKindGreaterThanGreaterThanGreaterThanToken:
						fallthrough // TODO(TS-TO-GO): merge cases
					case SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken:
						reportOperatorError()
						break
					case SyntaxKindAsteriskAsteriskToken:
						fallthrough // TODO(TS-TO-GO): merge cases
					case SyntaxKindAsteriskAsteriskEqualsToken:
						if languageVersion < ScriptTargetES2016 {
							error(errorNode, Diagnostics.Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later)
						}
					}
					resultType = bigintType
				} else {
					reportOperatorError(bothAreBigIntLike)
					resultType = errorType
				}
				if leftOk && rightOk {
					checkAssignmentOperator(resultType)
					switch operator {
					case SyntaxKindLessThanLessThanToken:
						fallthrough // TODO(TS-TO-GO): merge cases
					case SyntaxKindLessThanLessThanEqualsToken:
						fallthrough // TODO(TS-TO-GO): merge cases
					case SyntaxKindGreaterThanGreaterThanToken:
						fallthrough // TODO(TS-TO-GO): merge cases
					case SyntaxKindGreaterThanGreaterThanEqualsToken:
						fallthrough // TODO(TS-TO-GO): merge cases
					case SyntaxKindGreaterThanGreaterThanGreaterThanToken:
						fallthrough // TODO(TS-TO-GO): merge cases
					case SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken:
						rhsEval := evaluate(right)
						if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof rhsEval.value */ TODO == "number" && Math.abs(rhsEval.value) >= 32 {
							errorOrSuggestion(isEnumMember(walkUpParenthesizedExpressions(right.parent.parent)), errorNode || operatorToken, Diagnostics.This_operation_can_be_simplified_This_shift_is_identical_to_0_1_2, getTextOfNode(left), tokenToString(operator) /* TODO(TS-TO-GO) Node BinaryExpression: rhsEval.value % 32 */, TODO)
						}
						break
					default:
						break
					}
				}
				return resultType
			}
			fallthrough
		case SyntaxKindPlusToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPlusEqualsToken:
			if leftType == silentNeverType || rightType == silentNeverType {
				return silentNeverType
			}
			if !isTypeAssignableToKind(leftType, TypeFlagsStringLike) && !isTypeAssignableToKind(rightType, TypeFlagsStringLike) {
				leftType = checkNonNullType(leftType, left)
				rightType = checkNonNullType(rightType, right)
			}
			var resultType Type
			if isTypeAssignableToKind(leftType, TypeFlagsNumberLike /*strict*/, true) && isTypeAssignableToKind(rightType, TypeFlagsNumberLike /*strict*/, true) {
				// Operands of an enum type are treated as having the primitive type Number.
				// If both operands are of the Number primitive type, the result is of the Number primitive type.
				resultType = numberType
			} else if isTypeAssignableToKind(leftType, TypeFlagsBigIntLike /*strict*/, true) && isTypeAssignableToKind(rightType, TypeFlagsBigIntLike /*strict*/, true) {
				// If both operands are of the BigInt primitive type, the result is of the BigInt primitive type.
				resultType = bigintType
			} else if isTypeAssignableToKind(leftType, TypeFlagsStringLike /*strict*/, true) || isTypeAssignableToKind(rightType, TypeFlagsStringLike /*strict*/, true) {
				// If one or both operands are of the String primitive type, the result is of the String primitive type.
				resultType = stringType
			} else if isTypeAny(leftType) || isTypeAny(rightType) {
				// Otherwise, the result is of type Any.
				// NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isErrorType(leftType) || isErrorType(rightType):
					resultType = errorType
				default:
					resultType = anyType
				}
			}
			if resultType && !checkForDisallowedESSymbolOperand(operator) {
				return resultType
			}
			if !resultType {
				// Types that have a reasonably good chance of being a valid operand type.
				// If both types have an awaited type of one of these, we'll assume the user
				// might be missing an await without doing an exhaustive check that inserting
				// await(s) will actually be a completely valid binary expression.
				closeEnoughKind := TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsAnyOrUnknown
				reportOperatorError(func(left Type, right Type) bool {
					return isTypeAssignableToKind(left, closeEnoughKind) && isTypeAssignableToKind(right, closeEnoughKind)
				})
				return anyType
			}
			if operator == SyntaxKindPlusEqualsToken {
				checkAssignmentOperator(resultType)
			}
			return resultType
		case SyntaxKindLessThanToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindGreaterThanToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindLessThanEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindGreaterThanEqualsToken:
			if checkForDisallowedESSymbolOperand(operator) {
				leftType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(leftType, left))
				rightType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(rightType, right))
				reportOperatorErrorUnless(func(left Type, right Type) bool {
					if isTypeAny(left) || isTypeAny(right) {
						return true
					}
					leftAssignableToNumber := isTypeAssignableTo(left, numberOrBigIntType)
					rightAssignableToNumber := isTypeAssignableTo(right, numberOrBigIntType)
					return leftAssignableToNumber && rightAssignableToNumber || !leftAssignableToNumber && !rightAssignableToNumber && areTypesComparable(left, right)
				})
			}
			return booleanType
		case SyntaxKindEqualsEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindExclamationEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindEqualsEqualsEqualsToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindExclamationEqualsEqualsToken:
			if !(checkMode && checkMode&CheckModeTypeOnly) {
				if (isLiteralExpressionOfObject(left) || isLiteralExpressionOfObject(right)) && (!isInJSFile(left) || (operator == SyntaxKindEqualsEqualsEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken)) {
					eqType := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindEqualsEqualsEqualsToken
					error(errorNode, Diagnostics.This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value, __COND__(eqType, "false", "true"))
				}
				checkNaNEquality(errorNode, operator, left, right)
				reportOperatorErrorUnless(func(left Type, right Type) bool {
					return isTypeEqualityComparableTo(left, right) || isTypeEqualityComparableTo(right, left)
				})
			}
			return booleanType
		case SyntaxKindInstanceOfKeyword:
			return checkInstanceOfExpression(left, right, leftType, rightType, checkMode)
		case SyntaxKindInKeyword:
			return checkInExpression(left, right, leftType, rightType)
		case SyntaxKindAmpersandAmpersandToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindAmpersandAmpersandEqualsToken:
			var resultType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case hasTypeFacts(leftType, TypeFactsTruthy):
				resultType = getUnionType([]Type{extractDefinitelyFalsyTypes(__COND__(strictNullChecks, leftType, getBaseTypeOfLiteralType(rightType))), rightType})
			default:
				resultType = leftType
			}
			if operator == SyntaxKindAmpersandAmpersandEqualsToken {
				checkAssignmentOperator(rightType)
			}
			return resultType
			fallthrough
		case SyntaxKindBarBarToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBarBarEqualsToken:
			var resultType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case hasTypeFacts(leftType, TypeFactsFalsy):
				resultType = getUnionType([]Type{getNonNullableType(removeDefinitelyFalsyTypes(leftType)), rightType}, UnionReductionSubtype)
			default:
				resultType = leftType
			}
			if operator == SyntaxKindBarBarEqualsToken {
				checkAssignmentOperator(rightType)
			}
			return resultType
			fallthrough
		case SyntaxKindQuestionQuestionToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindQuestionQuestionEqualsToken:
			var resultType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case hasTypeFacts(leftType, TypeFactsEQUndefinedOrNull):
				resultType = getUnionType([]Type{getNonNullableType(leftType), rightType}, UnionReductionSubtype)
			default:
				resultType = leftType
			}
			if operator == SyntaxKindQuestionQuestionEqualsToken {
				checkAssignmentOperator(rightType)
			}
			return resultType
			fallthrough
		case SyntaxKindEqualsToken:
			var declKind AssignmentDeclarationKind
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isBinaryExpression(left.parent):
				declKind = getAssignmentDeclarationKind(left.parent)
			default:
				declKind = AssignmentDeclarationKindNone
			}
			checkAssignmentDeclaration(declKind, rightType)
			if isAssignmentDeclaration(declKind) {
				if !(rightType.flags & TypeFlagsObject) || declKind != AssignmentDeclarationKindModuleExports && declKind != AssignmentDeclarationKindPrototype && !isEmptyObjectType(rightType) && !isFunctionObjectType(rightType /* as ObjectType */) && !(getObjectFlags(rightType)&ObjectFlagsClass) {
					// don't check assignability of module.exports=, C.prototype=, or expando types because they will necessarily be incomplete
					checkAssignmentOperator(rightType)
				}
				return leftType
			} else {
				checkAssignmentOperator(rightType)
				return rightType
			}
			fallthrough
		case SyntaxKindCommaToken:
			if !compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isIndirectCall(left.parent /* as BinaryExpression */) {
				sf := getSourceFileOfNode(left)
				sourceText := sf.text
				start := skipTrivia(sourceText, left.pos)
				isInDiag2657 := sf.parseDiagnostics.some(func(diag DiagnosticWithLocation) bool {
					if diag.code != Diagnostics.JSX_expressions_must_have_one_parent_element.code {
						return false
					}
					return textSpanContainsPosition(diag, start)
				})
				if !isInDiag2657 {
					error(left, Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects)
				}
			}
			return rightType
		default:
			return Debug.fail()
		}
		bothAreBigIntLike := func(left Type, right Type) bool {
			return isTypeAssignableToKind(left, TypeFlagsBigIntLike) && isTypeAssignableToKind(right, TypeFlagsBigIntLike)
		}
		checkAssignmentDeclaration := func(kind AssignmentDeclarationKind, rightType Type) {
			if kind == AssignmentDeclarationKindModuleExports {
				for _, prop := range getPropertiesOfObjectType(rightType) {
					propType := getTypeOfSymbol(prop)
					if propType.symbol && propType.symbol.flags&SymbolFlagsClass {
						name := prop.escapedName
						symbol := resolveName(prop.valueDeclaration, name, SymbolFlagsType /*nameNotFoundMessage*/, nil /*isUse*/, false)
						if symbol. /* TODO(TS-TO-GO): was ? */ declarations && symbol.declarations.some(isJSDocTypedefTag) {
							addDuplicateDeclarationErrorsForSymbols(symbol, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), prop)
							addDuplicateDeclarationErrorsForSymbols(prop, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), symbol)
						}
					}
				}
			}
		}
		// Return true for "indirect calls", (i.e. `(0, x.f)(...)` or `(0, eval)(...)`), which prevents passing `this`.
		isIndirectCall := func(node BinaryExpression) bool {
			return node.parent.kind == SyntaxKindParenthesizedExpression && isNumericLiteral(node.left) && node.left.text == "0" && (isCallExpression(node.parent.parent) && node.parent.parent.expression == node.parent || node.parent.parent.kind == SyntaxKindTaggedTemplateExpression) && (isAccessExpression(node.right) || isIdentifier(node.right) && node.right.escapedText == "eval")
		}
		// Return true if there was no error, false if there was an error.
		checkForDisallowedESSymbolOperand := func(operator PunctuationSyntaxKind) bool {
			var offendingSymbolOperand Expression
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case maybeTypeOfKindConsideringBaseConstraint(leftType, TypeFlagsESSymbolLike):
				offendingSymbolOperand = left
			case maybeTypeOfKindConsideringBaseConstraint(rightType, TypeFlagsESSymbolLike):
				offendingSymbolOperand = right
			default:
				offendingSymbolOperand = nil
			}
			if offendingSymbolOperand {
				error(offendingSymbolOperand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(operator))
				return false
			}
			return true
		}
		getSuggestedBooleanOperator := func(operator SyntaxKind) *PunctuationSyntaxKind {
			switch operator {
			case SyntaxKindBarToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindBarEqualsToken:
				return SyntaxKindBarBarToken
			case SyntaxKindCaretToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindCaretEqualsToken:
				return SyntaxKindExclamationEqualsEqualsToken
			case SyntaxKindAmpersandToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindAmpersandEqualsToken:
				return SyntaxKindAmpersandAmpersandToken
			default:
				return nil
			}
		}
		checkAssignmentOperator := func(valueType Type) {
			if isAssignmentOperator(operator) {
				addLazyDiagnostic(checkAssignmentOperatorWorker)
			}
			checkAssignmentOperatorWorker := func() {
				assigneeType := leftType
				// getters can be a subtype of setters, so to check for assignability we use the setter's type instead
				if isCompoundAssignment(operatorToken.kind) && left.kind == SyntaxKindPropertyAccessExpression {
					assigneeType = checkPropertyAccessExpression(left /* as PropertyAccessExpression */ /*checkMode*/, nil /*writeOnly*/, true)
				}
				// TypeScript 1.0 spec (April 2014): 4.17
				// An assignment of the form
				//    VarExpr = ValueExpr
				// requires VarExpr to be classified as a reference
				// A compound assignment furthermore requires VarExpr to be classified as a reference (section 4.1)
				// and the type of the non-compound operation to be assignable to the type of VarExpr.
				if checkReferenceExpression(left, Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access) {
					var headMessage *DiagnosticMessage
					if exactOptionalPropertyTypes && isPropertyAccessExpression(left) && maybeTypeOfKind(valueType, TypeFlagsUndefined) {
						target := getTypeOfPropertyOfType(getTypeOfExpression(left.expression), left.name.escapedText)
						if isExactOptionalPropertyMismatch(valueType, target) {
							headMessage = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target
						}
					}
					// to avoid cascading errors check assignability only if 'isReference' check succeeded and no errors were reported
					checkTypeAssignableToAndOptionallyElaborate(valueType, assigneeType, left, right, headMessage)
				}
			}
		}
		isAssignmentDeclaration := func(kind AssignmentDeclarationKind) bool {
			switch kind {
			case AssignmentDeclarationKindModuleExports:
				return true
			case AssignmentDeclarationKindExportsProperty:
				fallthrough // TODO(TS-TO-GO): merge cases
			case AssignmentDeclarationKindProperty:
				fallthrough // TODO(TS-TO-GO): merge cases
			case AssignmentDeclarationKindPrototype:
				fallthrough // TODO(TS-TO-GO): merge cases
			case AssignmentDeclarationKindPrototypeProperty:
				fallthrough // TODO(TS-TO-GO): merge cases
			case AssignmentDeclarationKindThisProperty:
				symbol := getSymbolOfNode(left)
				init := getAssignedExpandoInitializer(right)
				return !!init && isObjectLiteralExpression(init) && !!symbol. /* TODO(TS-TO-GO): was ? */ exports. /* TODO(TS-TO-GO): was ? */ size
			default:
				return false
			}
		}
		/**
		 * Returns true if an error is reported
		 */
		reportOperatorErrorUnless := func(typesAreCompatible func(left Type, right Type) bool) bool {
			if !typesAreCompatible(leftType, rightType) {
				reportOperatorError(typesAreCompatible)
				return true
			}
			return false
		}
		reportOperatorError := func(isRelated func(left Type, right Type) bool) {
			wouldWorkWithAwait := false
			errNode := errorNode || operatorToken
			if isRelated {
				awaitedLeftType := getAwaitedTypeNoAlias(leftType)
				awaitedRightType := getAwaitedTypeNoAlias(rightType)
				wouldWorkWithAwait = !(awaitedLeftType == leftType && awaitedRightType == rightType) && !!(awaitedLeftType && awaitedRightType) && isRelated(awaitedLeftType, awaitedRightType)
			}
			effectiveLeft := leftType
			effectiveRight := rightType
			if !wouldWorkWithAwait && isRelated {
				[]any{effectiveLeft, effectiveRight} = getBaseTypesIfUnrelated(leftType, rightType, isRelated)
			}
			TODO_IDENTIFIER := getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight)
			if !tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr) {
				errorAndMaybeSuggestAwait(errNode, wouldWorkWithAwait, Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, tokenToString(operatorToken.kind), leftStr, rightStr)
			}
		}
		tryGiveBetterPrimaryError := func(errNode Node, maybeMissingAwait bool, leftStr string, rightStr string) *Diagnostic {
			switch operatorToken.kind {
			case SyntaxKindEqualsEqualsEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindEqualsEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindExclamationEqualsEqualsToken:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindExclamationEqualsToken:
				return errorAndMaybeSuggestAwait(errNode, maybeMissingAwait, Diagnostics.This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap, leftStr, rightStr)
			default:
				return nil
			}
		}
		checkNaNEquality := func(errorNode Node, operator SyntaxKind, left Expression, right Expression) {
			isLeftNaN := isGlobalNaN(skipParentheses(left))
			isRightNaN := isGlobalNaN(skipParentheses(right))
			if isLeftNaN || isRightNaN {
				err := error(errorNode, Diagnostics.This_condition_will_always_return_0, tokenToString(__COND__(operator == SyntaxKindEqualsEqualsEqualsToken || operator == SyntaxKindEqualsEqualsToken, SyntaxKindFalseKeyword, SyntaxKindTrueKeyword)))
				if isLeftNaN && isRightNaN {
					return
				}
				var operatorString string
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case operator == SyntaxKindExclamationEqualsEqualsToken || operator == SyntaxKindExclamationEqualsToken:
					operatorString = tokenToString(SyntaxKindExclamationToken)
				default:
					operatorString = ""
				}
				var location Expression
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isLeftNaN:
					location = right
				default:
					location = left
				}
				expression := skipParentheses(location)
				addRelatedInfo(err, createDiagnosticForNode(location, Diagnostics.Did_you_mean_0, __TEMPLATE__(operatorString, "Number.isNaN(", __COND__(isEntityNameExpression(expression), entityNameToString(expression), "..."), ")")))
			}
		}
		isGlobalNaN := func(expr Expression) bool {
			if isIdentifier(expr) && expr.escapedText == "NaN" {
				globalNaNSymbol := getGlobalNaNSymbol()
				return !!globalNaNSymbol && globalNaNSymbol == getResolvedSymbol(expr)
			}
			return false
		}
	}
	getBaseTypesIfUnrelated := func(leftType Type, rightType Type, isRelated func(left Type, right Type) bool) /* TODO(TS-TO-GO) TypeNode TupleType: [Type, Type] */ any {
		effectiveLeft := leftType
		effectiveRight := rightType
		leftBase := getBaseTypeOfLiteralType(leftType)
		rightBase := getBaseTypeOfLiteralType(rightType)
		if !isRelated(leftBase, rightBase) {
			effectiveLeft = leftBase
			effectiveRight = rightBase
		}
		return []any{effectiveLeft, effectiveRight}
	}
	checkYieldExpression := func(node YieldExpression) Type {
		addLazyDiagnostic(checkYieldExpressionGrammar)
		func_ := getContainingFunction(node)
		if !func_ {
			return anyType
		}
		functionFlags := getFunctionFlags(func_)
		if !(functionFlags & FunctionFlagsGenerator) {
			// If the user's code is syntactically correct, the func should always have a star. After all, we are in a yield context.
			return anyType
		}
		isAsync := (functionFlags & FunctionFlagsAsync) != 0
		if node.asteriskToken {
			// Async generator functions prior to ES2018 require the __await, __asyncDelegator,
			// and __asyncValues helpers
			if isAsync && languageVersion < LanguageFeatureMinimumTargetAsyncGenerators {
				checkExternalEmitHelpers(node, ExternalEmitHelpersAsyncDelegatorIncludes)
			}
			// Generator functions prior to ES2015 require the __values helper
			if !isAsync && languageVersion < LanguageFeatureMinimumTargetGenerators && compilerOptions.downlevelIteration {
				checkExternalEmitHelpers(node, ExternalEmitHelpersValues)
			}
		}
		// There is no point in doing an assignability check if the function
		// has no explicit return type because the return type is directly computed
		// from the yield expressions.
		returnType := getReturnTypeFromAnnotation(func_)
		if returnType && returnType.flags&TypeFlagsUnion {
			returnType = filterType(returnType, func(t Type) bool {
				return checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags /*errorNode*/, nil)
			})
		}
		iterationTypes := returnType && getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsync)
		signatureYieldType := iterationTypes && iterationTypes.yieldType || anyType
		signatureNextType := iterationTypes && iterationTypes.nextType || anyType
		var yieldExpressionType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.expression:
			yieldExpressionType = checkExpression(node.expression)
		default:
			yieldExpressionType = undefinedWideningType
		}
		yieldedType := getYieldedTypeOfYieldExpression(node, yieldExpressionType, signatureNextType, isAsync)
		if returnType && yieldedType {
			checkTypeAssignableToAndOptionallyElaborate(yieldedType, signatureYieldType, node.expression || node, node.expression)
		}
		if node.asteriskToken {
			var use /* TODO(TS-TO-GO) inferred type IterationUse.YieldStar | IterationUse.AsyncYieldStar */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isAsync:
				use = IterationUseAsyncYieldStar
			default:
				use = IterationUseYieldStar
			}
			return getIterationTypeOfIterable(use, IterationTypeKindReturn, yieldExpressionType, node.expression) || anyType
		} else if returnType {
			return getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindNext, returnType, isAsync) || anyType
		}
		type_ := getContextualIterationType(IterationTypeKindNext, func_)
		if !type_ {
			type_ = anyType
			addLazyDiagnostic(func() {
				if noImplicitAny && !expressionResultIsUnused(node) {
					contextualType := getContextualType(node /*contextFlags*/, nil)
					if !contextualType || isTypeAny(contextualType) {
						error(node, Diagnostics.yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation)
					}
				}
			})
		}
		return type_
		checkYieldExpressionGrammar := func() {
			if !(node.flags & NodeFlagsYieldContext) {
				grammarErrorOnFirstToken(node, Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body)
			}
			if isInParameterInitializerBeforeContainingFunction(node) {
				error(node, Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer)
			}
		}
	}
	checkConditionalExpression := func(node ConditionalExpression, checkMode CheckMode) Type {
		type_ := checkTruthinessExpression(node.condition, checkMode)
		checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.condition, type_, node.whenTrue)
		type1 := checkExpression(node.whenTrue, checkMode)
		type2 := checkExpression(node.whenFalse, checkMode)
		return getUnionType([]Type{type1, type2}, UnionReductionSubtype)
	}
	isTemplateLiteralContext := func(node Node) bool {
		parent := node.parent
		return isParenthesizedExpression(parent) && isTemplateLiteralContext(parent) || isElementAccessExpression(parent) && parent.argumentExpression == node
	}
	checkTemplateExpression := func(node TemplateExpression) Type {
		texts := []string{node.head.text}
		types := []never{}
		for _, span := range node.templateSpans {
			type_ := checkExpression(span.expression)
			if maybeTypeOfKindConsideringBaseConstraint(type_, TypeFlagsESSymbolLike) {
				error(span.expression, Diagnostics.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String)
			}
			texts.push(span.literal.text)
			types.push(__COND__(isTypeAssignableTo(type_, templateConstraintType), type_, stringType))
		}
		evaluated := node.parent.kind != SyntaxKindTaggedTemplateExpression && evaluate(node).value
		if evaluated {
			return getFreshTypeOfLiteralType(getStringLiteralType(evaluated))
		}
		if isConstContext(node) || isTemplateLiteralContext(node) || someType(getContextualType(node /*contextFlags*/, nil) || unknownType, isTemplateLiteralContextualType) {
			return getTemplateLiteralType(texts, types)
		}
		return stringType
	}
	isTemplateLiteralContextualType := func(type_ Type) bool {
		return !!(type_.flags&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral) || type_.flags&TypeFlagsInstantiableNonPrimitive && maybeTypeOfKind(getBaseConstraintOfType(type_) || unknownType, TypeFlagsStringLike))
	}
	getContextNode := func(node Expression) Expression {
		if isJsxAttributes(node) && !isJsxSelfClosingElement(node.parent) {
			return node.parent.parent
			// Needs to be the root JsxElement, so it encompasses the attributes _and_ the children (which are essentially part of the attributes)
		}
		return node
	}
	checkExpressionWithContextualType := func(node Expression, contextualType Type, inferenceContext *InferenceContext, checkMode CheckMode) Type {
		contextNode := getContextNode(node)
		pushContextualType(contextNode, contextualType /*isCache*/, false)
		pushInferenceContext(contextNode, inferenceContext)
		type_ := checkExpression(node, checkMode|CheckModeContextual|(__COND__(inferenceContext, CheckModeInferential, 0)))
		// In CheckMode.Inferential we collect intra-expression inference sites to process before fixing any type
		// parameters. This information is no longer needed after the call to checkExpression.
		if inferenceContext && inferenceContext.intraExpressionInferenceSites {
			inferenceContext.intraExpressionInferenceSites = nil
		}
		// We strip literal freshness when an appropriate contextual type is present such that contextually typed
		// literals always preserve their literal types (otherwise they might widen during type inference). An alternative
		// here would be to not mark contextually typed literals as fresh in the first place.
		var result Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case maybeTypeOfKind(type_, TypeFlagsLiteral) && isLiteralOfContextualType(type_, instantiateContextualType(contextualType, node /*contextFlags*/, nil)):
			result = getRegularTypeOfLiteralType(type_)
		default:
			result = type_
		}
		popInferenceContext()
		popContextualType()
		return result
	}
	checkExpressionCached := func(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any, checkMode CheckMode) Type {
		if checkMode {
			return checkExpression(node, checkMode)
		}
		links := getNodeLinks(node)
		if !links.resolvedType {
			// When computing a type that we're going to cache, we need to ignore any ongoing control flow
			// analysis because variables may have transient types in indeterminable states. Moving flowLoopStart
			// to the top of the stack ensures all transient types are computed from a known point.
			saveFlowLoopStart := flowLoopStart
			saveFlowTypeCache := flowTypeCache
			flowLoopStart = flowLoopCount
			flowTypeCache = nil
			links.resolvedType = checkExpression(node, checkMode)
			flowTypeCache = saveFlowTypeCache
			flowLoopStart = saveFlowLoopStart
		}
		return links.resolvedType
	}
	isTypeAssertion := func(node Expression) bool {
		node = skipParentheses(node /*excludeJSDocTypeAssertions*/, true)
		return node.kind == SyntaxKindTypeAssertionExpression || node.kind == SyntaxKindAsExpression || isJSDocTypeAssertion(node)
	}
	checkDeclarationInitializer := func(declaration HasExpressionInitializer, checkMode CheckMode, contextualType Type) Type {
		initializer := getEffectiveInitializer(declaration)
		if isInJSFile(declaration) {
			typeNode := tryGetJSDocSatisfiesTypeNode(declaration)
			if typeNode {
				return checkSatisfiesExpressionWorker(initializer, typeNode, checkMode)
			}
		}
		type_ := getQuickTypeOfExpression(initializer) || (__COND__(contextualType, checkExpressionWithContextualType(initializer, contextualType /*inferenceContext*/, nil, checkMode || CheckModeNormal), checkExpressionCached(initializer, checkMode)))
		if isParameter(__COND__(isBindingElement(declaration), walkUpBindingElementsAndPatterns(declaration), declaration)) {
			if declaration.name.kind == SyntaxKindObjectBindingPattern && isObjectLiteralType(type_) {
				return padObjectLiteralType(type_ /* as ObjectType */, declaration.name)
			}
			if declaration.name.kind == SyntaxKindArrayBindingPattern && isTupleType(type_) {
				return padTupleType(type_, declaration.name)
			}
		}
		return type_
	}
	padObjectLiteralType := func(type_ ObjectType, pattern ObjectBindingPattern) Type {
		var missingElements *[]BindingElement
		for _, e := range pattern.elements {
			if e.initializer {
				name := getPropertyNameFromBindingElement(e)
				if name && !getPropertyOfType(type_, name) {
					missingElements = append(missingElements, e)
				}
			}
		}
		if !missingElements {
			return type_
		}
		members := createSymbolTable()
		for _, prop := range getPropertiesOfObjectType(type_) {
			members.set(prop.escapedName, prop)
		}
		for _, e := range missingElements {
			symbol := createSymbol(SymbolFlagsProperty|SymbolFlagsOptional, getPropertyNameFromBindingElement(e))
			symbol.links.type_ = getTypeFromBindingElement(e /*includePatternInType*/, false /*reportErrors*/, false)
			members.set(symbol.escapedName, symbol)
		}
		result := createAnonymousType(type_.symbol, members, emptyArray, emptyArray, getIndexInfosOfType(type_))
		result.objectFlags = type_.objectFlags
		return result
	}
	getPropertyNameFromBindingElement := func(e BindingElement) *__String {
		exprType := getLiteralTypeFromPropertyName(e.propertyName || e.name /* as Identifier */)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isTypeUsableAsPropertyName(exprType):
			return getPropertyNameFromType(exprType)
		default:
			return nil
		}
	}
	padTupleType := func(type_ TupleTypeReference, pattern ArrayBindingPattern) Type {
		if type_.target.combinedFlags&ElementFlagsVariable || getTypeReferenceArity(type_) >= pattern.elements.length {
			return type_
		}
		patternElements := pattern.elements
		elementTypes := getElementTypes(type_).slice()
		elementFlags := type_.target.elementFlags.slice()
		for i := getTypeReferenceArity(type_); i < patternElements.length; i++ {
			e := patternElements[i]
			if i < patternElements.length-1 || !(e.kind == SyntaxKindBindingElement && e.dotDotDotToken) {
				elementTypes.push(__COND__(!isOmittedExpression(e) && hasDefaultValue(e), getTypeFromBindingElement(e /*includePatternInType*/, false /*reportErrors*/, false), anyType))
				elementFlags.push(ElementFlagsOptional)
				if !isOmittedExpression(e) && !hasDefaultValue(e) {
					reportImplicitAny(e, anyType)
				}
			}
		}
		return createTupleType(elementTypes, elementFlags, type_.target.readonly)
	}
	widenTypeInferredFromInitializer := func(declaration HasExpressionInitializer, type_ Type) Type {
		var widened Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getCombinedNodeFlagsCached(declaration)&NodeFlagsConstant || isDeclarationReadonly(declaration):
			widened = type_
		default:
			widened = getWidenedLiteralType(type_)
		}
		if isInJSFile(declaration) {
			if isEmptyLiteralType(widened) {
				reportImplicitAny(declaration, anyType)
				return anyType
			} else if isEmptyArrayLiteralType(widened) {
				reportImplicitAny(declaration, anyArrayType)
				return anyArrayType
			}
		}
		return widened
	}
	isLiteralOfContextualType := func(candidateType Type, contextualType Type) bool {
		if contextualType {
			if contextualType.flags & TypeFlagsUnionOrIntersection {
				types := (contextualType /* as UnionType */).types
				return some(types, func(t Type) bool {
					return isLiteralOfContextualType(candidateType, t)
				})
			}
			if contextualType.flags & TypeFlagsInstantiableNonPrimitive {
				// If the contextual type is a type variable constrained to a primitive type, consider
				// this a literal context for literals of that primitive type. For example, given a
				// type parameter 'T extends string', infer string literal types for T.
				constraint := getBaseConstraintOfType(contextualType) || unknownType
				return maybeTypeOfKind(constraint, TypeFlagsString) && maybeTypeOfKind(candidateType, TypeFlagsStringLiteral) || maybeTypeOfKind(constraint, TypeFlagsNumber) && maybeTypeOfKind(candidateType, TypeFlagsNumberLiteral) || maybeTypeOfKind(constraint, TypeFlagsBigInt) && maybeTypeOfKind(candidateType, TypeFlagsBigIntLiteral) || maybeTypeOfKind(constraint, TypeFlagsESSymbol) && maybeTypeOfKind(candidateType, TypeFlagsUniqueESSymbol) || isLiteralOfContextualType(candidateType, constraint)
			}
			// If the contextual type is a literal of a particular primitive type, we consider this a
			// literal context for all literals of that primitive type.
			return !!(contextualType.flags&(TypeFlagsStringLiteral|TypeFlagsIndex|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && maybeTypeOfKind(candidateType, TypeFlagsStringLiteral) || contextualType.flags&TypeFlagsNumberLiteral && maybeTypeOfKind(candidateType, TypeFlagsNumberLiteral) || contextualType.flags&TypeFlagsBigIntLiteral && maybeTypeOfKind(candidateType, TypeFlagsBigIntLiteral) || contextualType.flags&TypeFlagsBooleanLiteral && maybeTypeOfKind(candidateType, TypeFlagsBooleanLiteral) || contextualType.flags&TypeFlagsUniqueESSymbol && maybeTypeOfKind(candidateType, TypeFlagsUniqueESSymbol))
		}
		return false
	}
	isConstContext := func(node Expression) bool {
		parent := node.parent
		return isAssertionExpression(parent) && isConstTypeReference(parent.type_) || isJSDocTypeAssertion(parent) && isConstTypeReference(getJSDocTypeAssertionType(parent)) || isValidConstAssertionArgument(node) && isConstTypeVariable(getContextualType(node, ContextFlagsNone)) || (isParenthesizedExpression(parent) || isArrayLiteralExpression(parent) || isSpreadElement(parent)) && isConstContext(parent) || (isPropertyAssignment(parent) || isShorthandPropertyAssignment(parent) || isTemplateSpan(parent)) && isConstContext(parent.parent)
	}
	checkExpressionForMutableLocation := func(node Expression, checkMode *CheckMode, forceTuple bool) Type {
		type_ := checkExpression(node, checkMode, forceTuple)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isConstContext(node) || isCommonJsExportedExpression(node):
			return getRegularTypeOfLiteralType(type_)
		case isTypeAssertion(node):
			return type_
		default:
			return getWidenedLiteralLikeTypeForContextualType(type_, instantiateContextualType(getContextualType(node /*contextFlags*/, nil), node /*contextFlags*/, nil))
		}
	}
	checkPropertyAssignment := func(node PropertyAssignment, checkMode CheckMode) Type {
		// Do not use hasDynamicName here, because that returns false for well known symbols.
		// We want to perform checkComputedPropertyName for all computed properties, including
		// well known symbols.
		if node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
		}
		return checkExpressionForMutableLocation(node.initializer, checkMode)
	}
	checkObjectLiteralMethod := func(node MethodDeclaration, checkMode CheckMode) Type {
		// Grammar checking
		checkGrammarMethod(node)
		// Do not use hasDynamicName here, because that returns false for well known symbols.
		// We want to perform checkComputedPropertyName for all computed properties, including
		// well known symbols.
		if node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
		}
		uninstantiatedType := checkFunctionExpressionOrObjectLiteralMethod(node, checkMode)
		return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
	}
	instantiateTypeWithSingleGenericCallSignature := func(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | MethodDeclaration | QualifiedName */ any, type_ Type, checkMode CheckMode) Type {
		if checkMode && checkMode&(CheckModeInferential|CheckModeSkipGenericFunctions) {
			callSignature := getSingleSignature(type_, SignatureKindCall /*allowMembers*/, true)
			constructSignature := getSingleSignature(type_, SignatureKindConstruct /*allowMembers*/, true)
			signature := callSignature || constructSignature
			if signature && signature.typeParameters {
				contextualType := getApparentTypeOfContextualType(node /* as Expression */, ContextFlagsNoConstraints)
				if contextualType {
					contextualSignature := getSingleSignature(getNonNullableType(contextualType), __COND__(callSignature, SignatureKindCall, SignatureKindConstruct) /*allowMembers*/, false)
					if contextualSignature && !contextualSignature.typeParameters {
						if checkMode & CheckModeSkipGenericFunctions {
							skippedGenericFunction(node, checkMode)
							return anyFunctionType
						}
						context := getInferenceContext(node)
						// We have an expression that is an argument of a generic function for which we are performing
						// type argument inference. The expression is of a function type with a single generic call
						// signature and a contextual function type with a single non-generic call signature. Now check
						// if the outer function returns a function type with a single non-generic call signature and
						// if some of the outer function type parameters have no inferences so far. If so, we can
						// potentially add inferred type parameters to the outer function return type.
						returnType := context.signature && getReturnTypeOfSignature(context.signature)
						returnSignature := returnType && getSingleCallOrConstructSignature(returnType)
						if returnSignature && !returnSignature.typeParameters && !every(context.inferences, hasInferenceCandidates) {
							// Instantiate the signature with its own type parameters as type arguments, possibly
							// renaming the type parameters to ensure they have unique names.
							uniqueTypeParameters := getUniqueTypeParameters(context, signature.typeParameters)
							instantiatedSignature := getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters)
							// Infer from the parameters of the instantiated signature to the parameters of the
							// contextual signature starting with an empty set of inference candidates.
							inferences := map_(context.inferences, func(info InferenceInfo) InferenceInfo {
								return createInferenceInfo(info.typeParameter)
							})
							applyToParameterTypes(instantiatedSignature, contextualSignature, func(source Type, target Type) {
								inferTypes(inferences, source, target /*priority*/, 0 /*contravariant*/, true)
							})
							if some(inferences, hasInferenceCandidates) {
								// We have inference candidates, indicating that one or more type parameters are referenced
								// in the parameter types of the contextual signature. Now also infer from the return type.
								applyToReturnTypes(instantiatedSignature, contextualSignature, func(source Type, target Type) {
									inferTypes(inferences, source, target)
								})
								// If the type parameters for which we produced candidates do not have any inferences yet,
								// we adopt the new inference candidates and add the type parameters of the expression type
								// to the set of inferred type parameters for the outer function return type.
								if !hasOverlappingInferences(context.inferences, inferences) {
									mergeInferences(context.inferences, inferences)
									context.inferredTypeParameters = concatenate(context.inferredTypeParameters, uniqueTypeParameters)
									return getOrCreateTypeFromSignature(instantiatedSignature)
								}
							}
						}
						// TODO: The signature may reference any outer inference contexts, but we map pop off and then apply new inference contexts, and thus get different inferred types.
						// That this is cached on the *first* such attempt is not currently an issue, since expression types *also* get cached on the first pass. If we ever properly speculate, though,
						// the cached "isolatedSignatureType" signature field absolutely needs to be included in the list of speculative caches.
						return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context), flatMap(inferenceContexts, func(c *InferenceContext) *[]TypeParameter {
							return c && map_(c.inferences, func(i InferenceInfo) TypeParameter {
								return i.typeParameter
							})
						}).slice())
					}
				}
			}
		}
		return type_
	}
	skippedGenericFunction := func(node Node, checkMode CheckMode) {
		if checkMode & CheckModeInferential {
			// We have skipped a generic function during inferential typing. Obtain the inference context and
			// indicate this has occurred such that we know a second pass of inference is be needed.
			context := getInferenceContext(node)
			context.flags |= InferenceFlagsSkippedGenericFunction
		}
	}
	hasInferenceCandidates := func(info InferenceInfo) bool {
		return !!(info.candidates || info.contraCandidates)
	}
	hasInferenceCandidatesOrDefault := func(info InferenceInfo) bool {
		return !!(info.candidates || info.contraCandidates || hasTypeParameterDefault(info.typeParameter))
	}
	hasOverlappingInferences := func(a []InferenceInfo, b []InferenceInfo) bool {
		for i := 0; i < a.length; i++ {
			if hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i]) {
				return true
			}
		}
		return false
	}
	mergeInferences := func(target []InferenceInfo, source []InferenceInfo) {
		for i := 0; i < target.length; i++ {
			if !hasInferenceCandidates(target[i]) && hasInferenceCandidates(source[i]) {
				target[i] = source[i]
			}
		}
	}
	getUniqueTypeParameters := func(context InferenceContext, typeParameters []TypeParameter) []TypeParameter {
		var result []TypeParameter = []never{}
		var oldTypeParameters *[]TypeParameter
		var newTypeParameters *[]TypeParameter
		for _, tp := range typeParameters {
			name := tp.symbol.escapedName
			if hasTypeParameterByName(context.inferredTypeParameters, name) || hasTypeParameterByName(result, name) {
				newName := getUniqueTypeParameterName(concatenate(context.inferredTypeParameters, result), name)
				symbol := createSymbol(SymbolFlagsTypeParameter, newName)
				newTypeParameter := createTypeParameter(symbol)
				newTypeParameter.target = tp
				oldTypeParameters = append(oldTypeParameters, tp)
				newTypeParameters = append(newTypeParameters, newTypeParameter)
				result.push(newTypeParameter)
			} else {
				result.push(tp)
			}
		}
		if newTypeParameters {
			mapper := createTypeMapper(oldTypeParameters, newTypeParameters)
			for _, tp := range newTypeParameters {
				tp.mapper = mapper
			}
		}
		return result
	}
	hasTypeParameterByName := func(typeParameters *[]TypeParameter, name __String) bool {
		return some(typeParameters, func(tp TypeParameter) bool {
			return tp.symbol.escapedName == name
		})
	}
	getUniqueTypeParameterName := func(typeParameters []TypeParameter, baseName __String) __String {
		len := (baseName /* as string */).length
		for len > 1 && (baseName /* as string */).charCodeAt(len-1) >= CharacterCodes_0 && (baseName /* as string */).charCodeAt(len-1) <= CharacterCodes_9 {
			len--
		}
		s := (baseName /* as string */).slice(0, len)
		for index := 1; true; index++ {
			augmentedName := s + index /* as __String */
			if !hasTypeParameterByName(typeParameters, augmentedName) {
				return augmentedName
			}
		}
	}
	getReturnTypeOfSingleNonGenericCallSignature := func(funcType Type) Type {
		signature := getSingleCallSignature(funcType)
		if signature && !signature.typeParameters {
			return getReturnTypeOfSignature(signature)
		}
	}
	getReturnTypeOfSingleNonGenericSignatureOfCallChain := func(expr CallChain) Type {
		funcType := checkExpression(expr.expression)
		nonOptionalType := getOptionalExpressionType(funcType, expr.expression)
		returnType := getReturnTypeOfSingleNonGenericCallSignature(funcType)
		return returnType && propagateOptionalTypeMarker(returnType, expr, nonOptionalType != funcType)
	}
	/**
	 * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
	 * with computing the type and may not fully check all contained sub-expressions for errors.
	 */
	getTypeOfExpression := func(node Expression) Type {
		// Don't bother caching types that require no flow analysis and are quick to compute.
		quickType := getQuickTypeOfExpression(node)
		if quickType {
			return quickType
		}
		// If a type has been cached for the node, return it.
		if node.flags&NodeFlagsTypeCached && flowTypeCache {
			cachedType := flowTypeCache[getNodeId(node)]
			if cachedType {
				return cachedType
			}
		}
		startInvocationCount := flowInvocationCount
		type_ := checkExpression(node, CheckModeTypeOnly)
		// If control flow analysis was required to determine the type, it is worth caching.
		if flowInvocationCount != startInvocationCount {
			cache := flowTypeCache || ( /* TODO(TS-TO-GO) Node BinaryExpression: flowTypeCache = [] */ TODO)
			cache[getNodeId(node)] = type_
			setNodeFlags(node, node.flags|NodeFlagsTypeCached)
		}
		return type_
	}
	getQuickTypeOfExpression := func(node Expression) Type {
		expr := skipParentheses(node /*excludeJSDocTypeAssertions*/, true)
		if isJSDocTypeAssertion(expr) {
			type_ := getJSDocTypeAssertionType(expr)
			if !isConstTypeReference(type_) {
				return getTypeFromTypeNode(type_)
			}
		}
		expr = skipParentheses(node)
		if isAwaitExpression(expr) {
			type_ := getQuickTypeOfExpression(expr.expression)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case type_:
				return getAwaitedType(type_)
			default:
				return nil
			}
		}
		// Optimize for the common case of a call to a function with a single non-generic call
		// signature where we can just fetch the return type without checking the arguments.
		if isCallExpression(expr) && expr.expression.kind != SyntaxKindSuperKeyword && !isRequireCall(expr /*requireStringLiteralLikeArgument*/, true) && !isSymbolOrSymbolForCall(expr) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isCallChain(expr):
				return getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr)
			default:
				return getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(expr.expression))
			}
		} else if isAssertionExpression(expr) && !isConstTypeReference(expr.type_) {
			return getTypeFromTypeNode((expr /* as TypeAssertion */).type_)
		} else if isLiteralExpression(node) || isBooleanLiteral(node) {
			return checkExpression(node)
		}
		return nil
	}
	/**
	 * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
	 * with computing the type and may not fully check all contained sub-expressions for errors.
	 * It is intended for uses where you know there is no contextual type,
	 * and requesting the contextual type might cause a circularity or other bad behaviour.
	 * It sets the contextual type of the node to any before calling getTypeOfExpression.
	 */
	getContextFreeTypeOfExpression := func(node Expression) Type {
		links := getNodeLinks(node)
		if links.contextFreeType {
			return links.contextFreeType
		}
		pushContextualType(node, anyType /*isCache*/, false)
		type_ := /* TODO(TS-TO-GO) Node BinaryExpression: links.contextFreeType = checkExpression(node, CheckMode.SkipContextSensitive) */ TODO
		popContextualType()
		return type_
	}
	checkExpression := func(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any, checkMode CheckMode, forceTuple bool) Type {
		tracing. /* TODO(TS-TO-GO): was ? */ push(tracing.Phase.Check, "checkExpression", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"kind": node.kind,
			"pos":  node.pos,
			"end":  node.end,
			"path": (node /* as TracingNode */).tracingPath,
		})
		saveCurrentNode := currentNode
		currentNode = node
		instantiationCount = 0
		uninstantiatedType := checkExpressionWorker(node, checkMode, forceTuple)
		type_ := instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
		if isConstEnumObjectType(type_) {
			checkConstEnumAccess(node, type_)
		}
		currentNode = saveCurrentNode
		tracing. /* TODO(TS-TO-GO): was ? */ pop()
		return type_
	}
	checkConstEnumAccess := func(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any, type_ Type) {
		// enum object type for const enums are only permitted in:
		// - 'left' in property access
		// - 'object' in indexed access
		// - target in rhs of import statement
		ok := (node.parent.kind == SyntaxKindPropertyAccessExpression && (node.parent /* as PropertyAccessExpression */).expression == node) || (node.parent.kind == SyntaxKindElementAccessExpression && (node.parent /* as ElementAccessExpression */).expression == node) || ((node.kind == SyntaxKindIdentifier || node.kind == SyntaxKindQualifiedName) && isInRightSideOfImportOrExportAssignment(node /* as Identifier */) || (node.parent.kind == SyntaxKindTypeQuery && (node.parent /* as TypeQueryNode */).exprName == node)) || (node.parent.kind == SyntaxKindExportSpecifier)
		// We allow reexporting const enums
		if !ok {
			error(node, Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query)
		}
		// --verbatimModuleSyntax only gets checked here when the enum usage does not
		// resolve to an import, because imports of ambient const enums get checked
		// separately in `checkAliasSymbol`.
		if compilerOptions.isolatedModules || compilerOptions.verbatimModuleSyntax && ok && !resolveName(node, getFirstIdentifier(node /* as EntityNameOrEntityNameExpression */), SymbolFlagsAlias, nil, false, true) {
			Debug.assert(!!(type_.symbol.flags & SymbolFlagsConstEnum))
			constEnumDeclaration := type_.symbol.valueDeclaration /* as EnumDeclaration */
			redirect := host.getRedirectReferenceForResolutionFromSourceOfProject(getSourceFileOfNode(constEnumDeclaration).resolvedPath)
			if constEnumDeclaration.flags&NodeFlagsAmbient && !isValidTypeOnlyAliasUseSite(node) && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) {
				error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName)
			}
		}
	}
	checkParenthesizedExpression := func(node ParenthesizedExpression, checkMode CheckMode) Type {
		if hasJSDocNodes(node) {
			if isJSDocSatisfiesExpression(node) {
				return checkSatisfiesExpressionWorker(node.expression, getJSDocSatisfiesExpressionType(node), checkMode)
			}
			if isJSDocTypeAssertion(node) {
				return checkAssertionWorker(node, checkMode)
			}
		}
		return checkExpression(node.expression, checkMode)
	}
	checkExpressionWorker := func(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any, checkMode *CheckMode, forceTuple bool) Type {
		kind := node.kind
		if cancellationToken {
			// Only bother checking on a few construct kinds.  We don't want to be excessively
			// hitting the cancellation token on every node we check.
			switch kind {
			case SyntaxKindClassExpression:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindFunctionExpression:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindArrowFunction:
				cancellationToken.throwIfCancellationRequested()
			}
		}
		switch kind {
		case SyntaxKindIdentifier:
			return checkIdentifier(node /* as Identifier */, checkMode)
		case SyntaxKindPrivateIdentifier:
			return checkPrivateIdentifierExpression(node /* as PrivateIdentifier */)
		case SyntaxKindThisKeyword:
			return checkThisExpression(node)
		case SyntaxKindSuperKeyword:
			return checkSuperExpression(node)
		case SyntaxKindNullKeyword:
			return nullWideningType
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindStringLiteral:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case hasSkipDirectInferenceFlag(node):
				return blockedStringType
			default:
				return getFreshTypeOfLiteralType(getStringLiteralType((node /* as StringLiteralLike */).text))
			}
		case SyntaxKindNumericLiteral:
			checkGrammarNumericLiteral(node /* as NumericLiteral */)
			return getFreshTypeOfLiteralType(getNumberLiteralType(+(node /* as NumericLiteral */).text))
		case SyntaxKindBigIntLiteral:
			checkGrammarBigIntLiteral(node /* as BigIntLiteral */)
			return getFreshTypeOfLiteralType(getBigIntLiteralType(map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"negative":    false,
				"base10Value": parsePseudoBigInt((node /* as BigIntLiteral */).text),
			}))
		case SyntaxKindTrueKeyword:
			return trueType
		case SyntaxKindFalseKeyword:
			return falseType
		case SyntaxKindTemplateExpression:
			return checkTemplateExpression(node /* as TemplateExpression */)
		case SyntaxKindRegularExpressionLiteral:
			return checkRegularExpressionLiteral(node /* as RegularExpressionLiteral */)
		case SyntaxKindArrayLiteralExpression:
			return checkArrayLiteral(node /* as ArrayLiteralExpression */, checkMode, forceTuple)
		case SyntaxKindObjectLiteralExpression:
			return checkObjectLiteral(node /* as ObjectLiteralExpression */, checkMode)
		case SyntaxKindPropertyAccessExpression:
			return checkPropertyAccessExpression(node /* as PropertyAccessExpression */, checkMode)
		case SyntaxKindQualifiedName:
			return checkQualifiedName(node /* as QualifiedName */, checkMode)
		case SyntaxKindElementAccessExpression:
			return checkIndexedAccess(node /* as ElementAccessExpression */, checkMode)
		case SyntaxKindCallExpression:
			if (node /* as CallExpression */).expression.kind == SyntaxKindImportKeyword {
				return checkImportCallExpression(node /* as ImportCall */)
			}
			fallthrough
		case SyntaxKindNewExpression:
			return checkCallExpression(node /* as CallExpression */, checkMode)
		case SyntaxKindTaggedTemplateExpression:
			return checkTaggedTemplateExpression(node /* as TaggedTemplateExpression */)
		case SyntaxKindParenthesizedExpression:
			return checkParenthesizedExpression(node /* as ParenthesizedExpression */, checkMode)
		case SyntaxKindClassExpression:
			return checkClassExpression(node /* as ClassExpression */)
		case SyntaxKindFunctionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrowFunction:
			return checkFunctionExpressionOrObjectLiteralMethod(node /* as FunctionExpression | ArrowFunction */, checkMode)
		case SyntaxKindTypeOfExpression:
			return checkTypeOfExpression(node /* as TypeOfExpression */)
		case SyntaxKindTypeAssertionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindAsExpression:
			return checkAssertion(node /* as AssertionExpression */, checkMode)
		case SyntaxKindNonNullExpression:
			return checkNonNullAssertion(node /* as NonNullExpression */)
		case SyntaxKindExpressionWithTypeArguments:
			return checkExpressionWithTypeArguments(node /* as ExpressionWithTypeArguments */)
		case SyntaxKindSatisfiesExpression:
			return checkSatisfiesExpression(node /* as SatisfiesExpression */)
		case SyntaxKindMetaProperty:
			return checkMetaProperty(node /* as MetaProperty */)
		case SyntaxKindDeleteExpression:
			return checkDeleteExpression(node /* as DeleteExpression */)
		case SyntaxKindVoidExpression:
			return checkVoidExpression(node /* as VoidExpression */)
		case SyntaxKindAwaitExpression:
			return checkAwaitExpression(node /* as AwaitExpression */)
		case SyntaxKindPrefixUnaryExpression:
			return checkPrefixUnaryExpression(node /* as PrefixUnaryExpression */)
		case SyntaxKindPostfixUnaryExpression:
			return checkPostfixUnaryExpression(node /* as PostfixUnaryExpression */)
		case SyntaxKindBinaryExpression:
			return checkBinaryExpression(node /* as BinaryExpression */, checkMode)
		case SyntaxKindConditionalExpression:
			return checkConditionalExpression(node /* as ConditionalExpression */, checkMode)
		case SyntaxKindSpreadElement:
			return checkSpreadExpression(node /* as SpreadElement */, checkMode)
		case SyntaxKindOmittedExpression:
			return undefinedWideningType
		case SyntaxKindYieldExpression:
			return checkYieldExpression(node /* as YieldExpression */)
		case SyntaxKindSyntheticExpression:
			return checkSyntheticExpression(node /* as SyntheticExpression */)
		case SyntaxKindJsxExpression:
			return checkJsxExpression(node /* as JsxExpression */, checkMode)
		case SyntaxKindJsxElement:
			return checkJsxElement(node /* as JsxElement */, checkMode)
		case SyntaxKindJsxSelfClosingElement:
			return checkJsxSelfClosingElement(node /* as JsxSelfClosingElement */, checkMode)
		case SyntaxKindJsxFragment:
			return checkJsxFragment(node /* as JsxFragment */)
		case SyntaxKindJsxAttributes:
			return checkJsxAttributes(node /* as JsxAttributes */, checkMode)
		case SyntaxKindJsxOpeningElement:
			Debug.fail("Shouldn't ever directly check a JsxOpeningElement")
		}
		return errorType
	}
	// DECLARATION AND STATEMENT TYPE CHECKING
	checkTypeParameter := func(node TypeParameterDeclaration) {
		// Grammar Checking
		checkGrammarModifiers(node)
		if node.expression {
			grammarErrorOnFirstToken(node.expression, Diagnostics.Type_expected)
		}
		checkSourceElement(node.constraint)
		checkSourceElement(node.default_)
		typeParameter := getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node))
		// Resolve base constraint to reveal circularity errors
		getBaseConstraintOfType(typeParameter)
		if !hasNonCircularTypeParameterDefault(typeParameter) {
			error(node.default_, Diagnostics.Type_parameter_0_has_a_circular_default, typeToString(typeParameter))
		}
		constraintType := getConstraintOfTypeParameter(typeParameter)
		defaultType := getDefaultFromTypeParameter(typeParameter)
		if constraintType && defaultType {
			checkTypeAssignableTo(defaultType, getTypeWithThisArgument(instantiateType(constraintType, makeUnaryTypeMapper(typeParameter, defaultType)), defaultType), node.default_, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)
		}
		checkNodeDeferred(node)
		addLazyDiagnostic(func() {
			return checkTypeNameIsReserved(node.name, Diagnostics.Type_parameter_name_cannot_be_0)
		})
	}
	checkTypeParameterDeferred := func(node TypeParameterDeclaration) {
		if isInterfaceDeclaration(node.parent) || isClassLike(node.parent) || isTypeAliasDeclaration(node.parent) {
			typeParameter := getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node))
			modifiers := getTypeParameterModifiers(typeParameter) & (ModifierFlagsIn | ModifierFlagsOut)
			if modifiers {
				symbol := getSymbolOfDeclaration(node.parent)
				if isTypeAliasDeclaration(node.parent) && !(getObjectFlags(getDeclaredTypeOfSymbol(symbol)) & (ObjectFlagsReference | ObjectFlagsAnonymous | ObjectFlagsMapped)) {
					error(node, Diagnostics.Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types)
				} else if modifiers == ModifierFlagsIn || modifiers == ModifierFlagsOut {
					tracing. /* TODO(TS-TO-GO): was ? */ push(tracing.Phase.CheckTypes, "checkTypeParameterDeferred", map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"parent": getTypeId(getDeclaredTypeOfSymbol(symbol)),
						"id":     getTypeId(typeParameter),
					})
					source := createMarkerType(symbol, typeParameter, __COND__(modifiers == ModifierFlagsOut, markerSubTypeForCheck, markerSuperTypeForCheck))
					target := createMarkerType(symbol, typeParameter, __COND__(modifiers == ModifierFlagsOut, markerSuperTypeForCheck, markerSubTypeForCheck))
					saveVarianceTypeParameter := typeParameter
					varianceTypeParameter = typeParameter
					checkTypeAssignableTo(source, target, node, Diagnostics.Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation)
					varianceTypeParameter = saveVarianceTypeParameter
					tracing. /* TODO(TS-TO-GO): was ? */ pop()
				}
			}
		}
	}
	checkParameter := func(node ParameterDeclaration) {
		// Grammar checking
		// It is a SyntaxError if the Identifier "eval" or the Identifier "arguments" occurs as the
		// Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in strict code
		// or if its FunctionBody is strict code(11.1.5).
		checkGrammarModifiers(node)
		checkVariableLikeDeclaration(node)
		func_ := getContainingFunction(node)
		if hasSyntacticModifier(node, ModifierFlagsParameterPropertyModifier) {
			if !(func_.kind == SyntaxKindConstructor && nodeIsPresent(func_.body)) {
				error(node, Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation)
			}
			if func_.kind == SyntaxKindConstructor && isIdentifier(node.name) && node.name.escapedText == "constructor" {
				error(node.name, Diagnostics.constructor_cannot_be_used_as_a_parameter_property_name)
			}
		}
		if !node.initializer && isOptionalDeclaration(node) && isBindingPattern(node.name) && (func_ /* as FunctionLikeDeclaration */).body {
			error(node, Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature)
		}
		if node.name && isIdentifier(node.name) && (node.name.escapedText == "this" || node.name.escapedText == "new") {
			if func_.parameters.indexOf(node) != 0 {
				error(node, Diagnostics.A_0_parameter_must_be_the_first_parameter, node.name.escapedText /* as string */)
			}
			if func_.kind == SyntaxKindConstructor || func_.kind == SyntaxKindConstructSignature || func_.kind == SyntaxKindConstructorType {
				error(node, Diagnostics.A_constructor_cannot_have_a_this_parameter)
			}
			if func_.kind == SyntaxKindArrowFunction {
				error(node, Diagnostics.An_arrow_function_cannot_have_a_this_parameter)
			}
			if func_.kind == SyntaxKindGetAccessor || func_.kind == SyntaxKindSetAccessor {
				error(node, Diagnostics.get_and_set_accessors_cannot_declare_this_parameters)
			}
		}
		// Only check rest parameter type if it's not a binding pattern. Since binding patterns are
		// not allowed in a rest parameter, we already have an error from checkGrammarParameterList.
		if node.dotDotDotToken && !isBindingPattern(node.name) && !isTypeAssignableTo(getReducedType(getTypeOfSymbol(node.symbol)), anyReadonlyArrayType) {
			error(node, Diagnostics.A_rest_parameter_must_be_of_an_array_type)
		}
	}
	checkTypePredicate := func(node TypePredicateNode) {
		parent := getTypePredicateParent(node)
		if !parent {
			// The parent must not be valid.
			error(node, Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods)
			return
		}
		signature := getSignatureFromDeclaration(parent)
		typePredicate := getTypePredicateOfSignature(signature)
		if !typePredicate {
			return
		}
		checkSourceElement(node.type_)
		TODO_IDENTIFIER := node
		if typePredicate.kind != TypePredicateKindThis && typePredicate.kind != TypePredicateKindAssertsThis {
			if typePredicate.parameterIndex >= 0 {
				if signatureHasRestParameter(signature) && typePredicate.parameterIndex == signature.parameters.length-1 {
					error(parameterName, Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter)
				} else {
					if typePredicate.type_ {
						leadingError := func() DiagnosticMessageChain {
							return chainDiagnosticMessages(nil, Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type)
						}
						checkTypeAssignableTo(typePredicate.type_, getTypeOfSymbol(signature.parameters[typePredicate.parameterIndex]), node.type_ /*headMessage*/, nil, leadingError)
					}
				}
			} else if parameterName {
				hasReportedError := false
				for _, TODO_IDENTIFIER := range parent.parameters {
					if isBindingPattern(name) && checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName) {
						hasReportedError = true
						break
					}
				}
				if !hasReportedError {
					error(node.parameterName, Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName)
				}
			}
		}
	}
	getTypePredicateParent := func(node Node) *SignatureDeclaration {
		switch node.parent.kind {
		case SyntaxKindArrowFunction:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindCallSignature:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMethodSignature:
			parent := node.parent /* as SignatureDeclaration */
			if node == parent.type_ {
				return parent
			}
		}
	}
	checkIfTypePredicateVariableIsDeclaredInBindingPattern := func(pattern BindingPattern, predicateVariableNode Node, predicateVariableName string) *true {
		for _, element := range pattern.elements {
			if isOmittedExpression(element) {
				continue
			}
			name := element.name
			if name.kind == SyntaxKindIdentifier && name.escapedText == predicateVariableName {
				error(predicateVariableNode, Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName)
				return true
			} else if name.kind == SyntaxKindArrayBindingPattern || name.kind == SyntaxKindObjectBindingPattern {
				if checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, predicateVariableNode, predicateVariableName) {
					return true
				}
			}
		}
	}
	checkSignatureDeclaration := func(node SignatureDeclaration) {
		// Grammar checking
		if node.kind == SyntaxKindIndexSignature {
			checkGrammarIndexSignature(node)
		} else if node.kind == SyntaxKindFunctionType || node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindConstructorType || node.kind == SyntaxKindCallSignature || node.kind == SyntaxKindConstructor || node.kind == SyntaxKindConstructSignature {
			checkGrammarFunctionLikeDeclaration(node /* as FunctionLikeDeclaration */)
		}
		functionFlags := getFunctionFlags(node /* as FunctionLikeDeclaration */)
		if !(functionFlags & FunctionFlagsInvalid) {
			// Async generators prior to ES2018 require the __await and __asyncGenerator helpers
			if (functionFlags&FunctionFlagsAsyncGenerator) == FunctionFlagsAsyncGenerator && languageVersion < LanguageFeatureMinimumTargetAsyncGenerators {
				checkExternalEmitHelpers(node, ExternalEmitHelpersAsyncGeneratorIncludes)
			}
			// Async functions prior to ES2017 require the __awaiter helper
			if (functionFlags&FunctionFlagsAsyncGenerator) == FunctionFlagsAsync && languageVersion < LanguageFeatureMinimumTargetAsyncFunctions {
				checkExternalEmitHelpers(node, ExternalEmitHelpersAwaiter)
			}
			// Generator functions, Async functions, and Async Generator functions prior to
			// ES2015 require the __generator helper
			if (functionFlags&FunctionFlagsAsyncGenerator) != FunctionFlagsNormal && languageVersion < LanguageFeatureMinimumTargetGenerators {
				checkExternalEmitHelpers(node, ExternalEmitHelpersGenerator)
			}
		}
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
		checkUnmatchedJSDocParameters(node)
		forEach(node.parameters, checkParameter)
		// TODO(rbuckton): Should we start checking JSDoc types?
		if node.type_ {
			checkSourceElement(node.type_)
		}
		addLazyDiagnostic(checkSignatureDeclarationDiagnostics)
		checkSignatureDeclarationDiagnostics := func() {
			checkCollisionWithArgumentsInGeneratedCode(node)
			returnTypeNode := getEffectiveReturnTypeNode(node)
			returnTypeErrorLocation := returnTypeNode
			if isInJSFile(node) {
				typeTag := getJSDocTypeTag(node)
				if typeTag && typeTag.typeExpression && isTypeReferenceNode(typeTag.typeExpression.type_) {
					signature := getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression))
					if signature && signature.declaration {
						returnTypeNode = getEffectiveReturnTypeNode(signature.declaration)
						returnTypeErrorLocation = typeTag.typeExpression.type_
					}
				}
			}
			if noImplicitAny && !returnTypeNode {
				switch node.kind {
				case SyntaxKindConstructSignature:
					error(node, Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type)
					break
				case SyntaxKindCallSignature:
					error(node, Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type)
					break
				}
			}
			if returnTypeNode && returnTypeErrorLocation {
				functionFlags := getFunctionFlags(node /* as FunctionDeclaration */)
				if (functionFlags & (FunctionFlagsInvalid | FunctionFlagsGenerator)) == FunctionFlagsGenerator {
					returnType := getTypeFromTypeNode(returnTypeNode)
					if returnType == voidType {
						error(returnTypeErrorLocation, Diagnostics.A_generator_cannot_have_a_void_type_annotation)
					} else {
						checkGeneratorInstantiationAssignabilityToReturnType(returnType, functionFlags, returnTypeErrorLocation)
					}
				} else if (functionFlags & FunctionFlagsAsyncGenerator) == FunctionFlagsAsync {
					checkAsyncFunctionReturnType(node /* as FunctionLikeDeclaration */, returnTypeNode, returnTypeErrorLocation)
				}
			}
			if node.kind != SyntaxKindIndexSignature && node.kind != SyntaxKindJSDocFunctionType {
				registerForUnusedIdentifiersCheck(node)
			}
		}
	}
	checkGeneratorInstantiationAssignabilityToReturnType := func(returnType Type, functionFlags FunctionFlags, errorNode TypeNode) bool {
		// Naively, one could check that Generator<any, any, any> is assignable to the return type annotation.
		// However, that would not catch the error in the following case.
		//
		//    interface BadGenerator extends Iterable<number>, Iterator<string> { }
		//    function* g(): BadGenerator { } // Iterable and Iterator have different types!
		//
		generatorYieldType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindYield, returnType, (functionFlags&FunctionFlagsAsync) != 0) || anyType
		generatorReturnType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, returnType, (functionFlags&FunctionFlagsAsync) != 0) || generatorYieldType
		generatorNextType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindNext, returnType, (functionFlags&FunctionFlagsAsync) != 0) || unknownType
		generatorInstantiation := createGeneratorType(generatorYieldType, generatorReturnType, generatorNextType, !!(functionFlags & FunctionFlagsAsync))
		return checkTypeAssignableTo(generatorInstantiation, returnType, errorNode)
	}
	checkClassForDuplicateDeclarations := func(node ClassLikeDeclaration) {
		instanceNames := NewMap[__String, DeclarationMeaning]()
		staticNames := NewMap[__String, DeclarationMeaning]()
		// instance and static private identifiers share the same scope
		privateIdentifiers := NewMap[__String, DeclarationMeaning]()
		for _, member := range node.members {
			if member.kind == SyntaxKindConstructor {
				for _, param := range (member /* as ConstructorDeclaration */).parameters {
					if isParameterPropertyDeclaration(param, member) && !isBindingPattern(param.name) {
						addName(instanceNames, param.name, param.name.escapedText, DeclarationMeaningGetOrSetAccessor)
					}
				}
			} else {
				isStaticMember := isStatic(member)
				name := member.name
				if !name {
					continue
				}
				isPrivate := isPrivateIdentifier(name)
				var privateStaticFlags /* TODO(TS-TO-GO) inferred type 0 | DeclarationMeaning.PrivateStatic */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isPrivate && isStaticMember:
					privateStaticFlags = DeclarationMeaningPrivateStatic
				default:
					privateStaticFlags = 0
				}
				var names Map[__String, DeclarationMeaning]
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isPrivate:
					names = privateIdentifiers
				case isStaticMember:
					names = staticNames
				default:
					names = instanceNames
				}
				memberName := name && getEffectivePropertyNameForPropertyNameNode(name)
				if memberName {
					switch member.kind {
					case SyntaxKindGetAccessor:
						addName(names, name, memberName, DeclarationMeaningGetAccessor|privateStaticFlags)
						break
					case SyntaxKindSetAccessor:
						addName(names, name, memberName, DeclarationMeaningSetAccessor|privateStaticFlags)
						break
					case SyntaxKindPropertyDeclaration:
						addName(names, name, memberName, DeclarationMeaningGetOrSetAccessor|privateStaticFlags)
						break
					case SyntaxKindMethodDeclaration:
						addName(names, name, memberName, DeclarationMeaningMethod|privateStaticFlags)
						break
					}
				}
			}
		}
		addName := func(names Map[__String, DeclarationMeaning], location Node, name __String, meaning DeclarationMeaning) {
			prev := names.get(name)
			if prev {
				// For private identifiers, do not allow mixing of static and instance members with the same name
				if (prev & DeclarationMeaningPrivateStatic) != (meaning & DeclarationMeaningPrivateStatic) {
					error(location, Diagnostics.Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name, getTextOfNode(location))
				} else {
					prevIsMethod := !!(prev & DeclarationMeaningMethod)
					isMethod := !!(meaning & DeclarationMeaningMethod)
					if prevIsMethod || isMethod {
						if prevIsMethod != isMethod {
							error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location))
						}
						// If this is a method/method duplication is might be an overload, so this will be handled when overloads are considered
					} else if prev & meaning & ~DeclarationMeaningPrivateStatic {
						error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location))
					} else {
						names.set(name, prev|meaning)
					}
				}
			} else {
				names.set(name, meaning)
			}
		}
	}
	/**
	 * Static members being set on a constructor function may conflict with built-in properties
	 * of Function. Esp. in ECMAScript 5 there are non-configurable and non-writable
	 * built-in properties. This check issues a transpile error when a class has a static
	 * member with the same name as a non-writable built-in property.
	 *
	 * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.3
	 * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.5
	 * @see http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-the-function-constructor
	 * @see http://www.ecma-international.org/ecma-262/6.0/#sec-function-instances
	 */
	checkClassForStaticPropertyNameConflicts := func(node ClassLikeDeclaration) {
		for _, member := range node.members {
			memberNameNode := member.name
			isStaticMember := isStatic(member)
			if isStaticMember && memberNameNode {
				memberName := getEffectivePropertyNameForPropertyNameNode(memberNameNode)
				switch memberName {
				case "name":
					fallthrough // TODO(TS-TO-GO): merge cases
				case "length":
					fallthrough // TODO(TS-TO-GO): merge cases
				case "caller":
					fallthrough // TODO(TS-TO-GO): merge cases
				case "arguments":
					if useDefineForClassFields {
						break
					}
					fallthrough
				case "prototype":
					message := Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1
					className := getNameOfSymbolAsWritten(getSymbolOfDeclaration(node))
					error(memberNameNode, message, memberName, className)
					break
				}
			}
		}
	}
	checkObjectTypeForDuplicateDeclarations := func(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeLiteralNode | InterfaceDeclaration */ any) {
		names := NewMap[string, bool]()
		for _, member := range node.members {
			if member.kind == SyntaxKindPropertySignature {
				var memberName string
				name := member.name
				switch name.kind {
				case SyntaxKindStringLiteral:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindNumericLiteral:
					memberName = name.text
					break
				case SyntaxKindIdentifier:
					memberName = idText(name)
					break
				default:
					continue
				}
				if names.get(memberName) {
					error(getNameOfDeclaration(member.symbol.valueDeclaration), Diagnostics.Duplicate_identifier_0, memberName)
					error(member.name, Diagnostics.Duplicate_identifier_0, memberName)
				} else {
					names.set(memberName, true)
				}
			}
		}
	}
	checkTypeForDuplicateIndexSignatures := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode */ any) {
		if node.kind == SyntaxKindInterfaceDeclaration {
			nodeSymbol := getSymbolOfDeclaration(node)
			// in case of merging interface declaration it is possible that we'll enter this check procedure several times for every declaration
			// to prevent this run check only for the first declaration of a given kind
			if nodeSymbol.declarations && nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] != node {
				return
			}
		}
		// TypeScript 1.0 spec (April 2014)
		// 3.7.4: An object type can contain at most one string index signature and one numeric index signature.
		// 8.5: A class declaration can have at most one string index member declaration and one numeric index member declaration
		indexSymbol := getIndexSymbol(getSymbolOfDeclaration(node))
		if indexSymbol. /* TODO(TS-TO-GO): was ? */ declarations {
			indexSignatureMap := NewMap[TypeId /* TODO(TS-TO-GO) TypeNode TypeLiteral: { type: Type; declarations: IndexSignatureDeclaration[]; } */, any]()
			for _, declaration := range indexSymbol.declarations /* as IndexSignatureDeclaration[] */ {
				if declaration.parameters.length == 1 && declaration.parameters[0].type_ {
					forEachType(getTypeFromTypeNode(declaration.parameters[0].type_), func(type_ Type) {
						entry := indexSignatureMap.get(getTypeId(type_))
						if entry {
							entry.declarations.push(declaration)
						} else {
							indexSignatureMap.set(getTypeId(type_), map[any]any{ /* TODO(TS-TO-GO): was object literal */
								"type_":        type_,
								"declarations": []IndexSignatureDeclaration{declaration},
							})
						}
					})
				}
			}
			indexSignatureMap.forEach(func(entry /* TODO(TS-TO-GO) inferred type { type: Type; declarations: IndexSignatureDeclaration[]; } */ any) {
				if entry.declarations.length > 1 {
					for _, declaration := range entry.declarations {
						error(declaration, Diagnostics.Duplicate_index_signature_for_type_0, typeToString(entry.type_))
					}
				}
			})
		}
	}
	checkPropertyDeclaration := func(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyDeclaration | PropertySignature */ any) {
		// Grammar checking
		if !checkGrammarModifiers(node) && !checkGrammarProperty(node) {
			checkGrammarComputedPropertyName(node.name)
		}
		checkVariableLikeDeclaration(node)
		setNodeLinksForPrivateIdentifierScope(node)
		// property signatures already report "initializer not allowed in ambient context" elsewhere
		if hasSyntacticModifier(node, ModifierFlagsAbstract) && node.kind == SyntaxKindPropertyDeclaration && node.initializer {
			error(node, Diagnostics.Property_0_cannot_have_an_initializer_because_it_is_marked_abstract, declarationNameToString(node.name))
		}
	}
	checkPropertySignature := func(node PropertySignature) {
		if isPrivateIdentifier(node.name) {
			error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		}
		return checkPropertyDeclaration(node)
	}
	checkMethodDeclaration := func(node /* TODO(TS-TO-GO) TypeNode UnionType: MethodDeclaration | MethodSignature */ any) {
		// Grammar checking
		if !checkGrammarMethod(node) {
			checkGrammarComputedPropertyName(node.name)
		}
		if isMethodDeclaration(node) && node.asteriskToken && isIdentifier(node.name) && idText(node.name) == "constructor" {
			error(node.name, Diagnostics.Class_constructor_may_not_be_a_generator)
		}
		// Grammar checking for modifiers is done inside the function checkGrammarFunctionLikeDeclaration
		checkFunctionOrMethodDeclaration(node)
		// method signatures already report "implementation not allowed in ambient context" elsewhere
		if hasSyntacticModifier(node, ModifierFlagsAbstract) && node.kind == SyntaxKindMethodDeclaration && node.body {
			error(node, Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, declarationNameToString(node.name))
		}
		// Private named methods are only allowed in class declarations
		if isPrivateIdentifier(node.name) && !getContainingClass(node) {
			error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		}
		setNodeLinksForPrivateIdentifierScope(node)
	}
	setNodeLinksForPrivateIdentifierScope := func(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration */ any) {
		if isPrivateIdentifier(node.name) {
			if languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !useDefineForClassFields {
				for lexicalScope := getEnclosingBlockScopeContainer(node); !!lexicalScope; lexicalScope = getEnclosingBlockScopeContainer(lexicalScope) {
					getNodeLinks(lexicalScope).flags |= NodeCheckFlagsContainsClassWithPrivateIdentifiers
				}
				// If this is a private element in a class expression inside the body of a loop,
				// then we must use a block-scoped binding to store the additional variables required
				// to transform private elements.
				if isClassExpression(node.parent) {
					enclosingIterationStatement := getEnclosingIterationStatement(node.parent)
					if enclosingIterationStatement {
						getNodeLinks(node.name).flags |= NodeCheckFlagsBlockScopedBindingInLoop
						getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
					}
				}
			}
		}
	}
	checkClassStaticBlockDeclaration := func(node ClassStaticBlockDeclaration) {
		checkGrammarModifiers(node)
		forEachChild(node, checkSourceElement)
	}
	checkConstructorDeclaration := func(node ConstructorDeclaration) {
		// Grammar check on signature of constructor and modifier of the constructor is done in checkSignatureDeclaration function.
		checkSignatureDeclaration(node)
		// Grammar check for checking only related to constructorDeclaration
		if !checkGrammarConstructorTypeParameters(node) {
			checkGrammarConstructorTypeAnnotation(node)
		}
		checkSourceElement(node.body)
		symbol := getSymbolOfDeclaration(node)
		firstDeclaration := getDeclarationOfKind(symbol, node.kind)
		// Only type check the symbol once
		if node == firstDeclaration {
			checkFunctionOrConstructorSymbol(symbol)
		}
		// exit early in the case of signature - super checks are not relevant to them
		if nodeIsMissing(node.body) {
			return
		}
		addLazyDiagnostic(checkConstructorDeclarationDiagnostics)
		return
		isInstancePropertyWithInitializerOrPrivateIdentifierProperty := func(n Node) bool {
			if isPrivateIdentifierClassElementDeclaration(n) {
				return true
			}
			return n.kind == SyntaxKindPropertyDeclaration && !isStatic(n) && !!(n /* as PropertyDeclaration */).initializer
		}
		checkConstructorDeclarationDiagnostics := func() {
			// TS 1.0 spec (April 2014): 8.3.2
			// Constructors of classes with no extends clause may not contain super calls, whereas
			// constructors of derived classes must contain at least one super call somewhere in their function body.
			containingClassDecl := node.parent
			if getClassExtendsHeritageElement(containingClassDecl) {
				captureLexicalThis(node.parent, containingClassDecl)
				classExtendsNull := classDeclarationExtendsNull(containingClassDecl)
				superCall := findFirstSuperCall(node.body)
				if superCall {
					if classExtendsNull {
						error(superCall, Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null)
					}
					// A super call must be root-level in a constructor if both of the following are true:
					// - The containing class is a derived class.
					// - The constructor declares parameter properties
					//   or the containing class declares instance member variables with initializers.
					superCallShouldBeRootLevel := !emitStandardClassFields && (some(node.parent.members, isInstancePropertyWithInitializerOrPrivateIdentifierProperty) || some(node.parameters, func(p ParameterDeclaration) bool {
						return hasSyntacticModifier(p, ModifierFlagsParameterPropertyModifier)
					}))
					if superCallShouldBeRootLevel {
						// Until we have better flow analysis, it is an error to place the super call within any kind of block or conditional
						// See GH #8277
						if !superCallIsRootLevelInConstructor(superCall, node.body) {
							error(superCall, Diagnostics.A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers)
						} else {
							var superCallStatement *ExpressionStatement
							for _, statement := range node.body.statements {
								if isExpressionStatement(statement) && isSuperCall(skipOuterExpressions(statement.expression)) {
									superCallStatement = statement
									break
								}
								if nodeImmediatelyReferencesSuperOrThis(statement) {
									break
								}
							}
							// Until we have better flow analysis, it is an error to place the super call within any kind of block or conditional
							// See GH #8277
							if superCallStatement == nil {
								error(node, Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers)
							}
						}
					}
				} else if !classExtendsNull {
					error(node, Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call)
				}
			}
		}
	}
	superCallIsRootLevelInConstructor := func(superCall Node, body Block) bool {
		superCallParent := walkUpParenthesizedExpressions(superCall.parent)
		return isExpressionStatement(superCallParent) && superCallParent.parent == body
	}
	nodeImmediatelyReferencesSuperOrThis := func(node Node) bool {
		if node.kind == SyntaxKindSuperKeyword || node.kind == SyntaxKindThisKeyword {
			return true
		}
		if isThisContainerOrFunctionBlock(node) {
			return false
		}
		return !!forEachChild(node, nodeImmediatelyReferencesSuperOrThis)
	}
	checkAccessorDeclaration := func(node AccessorDeclaration) {
		if isIdentifier(node.name) && idText(node.name) == "constructor" && isClassLike(node.parent) {
			error(node.name, Diagnostics.Class_constructor_may_not_be_an_accessor)
		}
		addLazyDiagnostic(checkAccessorDeclarationDiagnostics)
		checkSourceElement(node.body)
		setNodeLinksForPrivateIdentifierScope(node)
		checkAccessorDeclarationDiagnostics := func() {
			// Grammar checking accessors
			if !checkGrammarFunctionLikeDeclaration(node) && !checkGrammarAccessor(node) {
				checkGrammarComputedPropertyName(node.name)
			}
			checkDecorators(node)
			checkSignatureDeclaration(node)
			if node.kind == SyntaxKindGetAccessor {
				if !(node.flags & NodeFlagsAmbient) && nodeIsPresent(node.body) && (node.flags & NodeFlagsHasImplicitReturn) {
					if !(node.flags & NodeFlagsHasExplicitReturn) {
						error(node.name, Diagnostics.A_get_accessor_must_return_a_value)
					}
				}
			}
			// Do not use hasDynamicName here, because that returns false for well known symbols.
			// We want to perform checkComputedPropertyName for all computed properties, including
			// well known symbols.
			if node.name.kind == SyntaxKindComputedPropertyName {
				checkComputedPropertyName(node.name)
			}
			if hasBindableName(node) {
				// TypeScript 1.0 spec (April 2014): 8.4.3
				// Accessors for the same member name must specify the same accessibility.
				symbol := getSymbolOfDeclaration(node)
				getter := getDeclarationOfKind(symbol, SyntaxKindGetAccessor)
				setter := getDeclarationOfKind(symbol, SyntaxKindSetAccessor)
				if getter && setter && !(getNodeCheckFlags(getter) & NodeCheckFlagsTypeChecked) {
					getNodeLinks(getter).flags |= NodeCheckFlagsTypeChecked
					getterFlags := getEffectiveModifierFlags(getter)
					setterFlags := getEffectiveModifierFlags(setter)
					if (getterFlags & ModifierFlagsAbstract) != (setterFlags & ModifierFlagsAbstract) {
						error(getter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract)
						error(setter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract)
					}
					if ((getterFlags & ModifierFlagsProtected) && !(setterFlags & (ModifierFlagsProtected | ModifierFlagsPrivate))) || ((getterFlags & ModifierFlagsPrivate) && !(setterFlags & ModifierFlagsPrivate)) {
						error(getter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter)
						error(setter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter)
					}
				}
			}
			returnType := getTypeOfAccessors(getSymbolOfDeclaration(node))
			if node.kind == SyntaxKindGetAccessor {
				checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType)
			}
		}
	}
	checkMissingDeclaration := func(node Node) {
		checkDecorators(node)
	}
	getEffectiveTypeArgumentAtIndex := func(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ExpressionWithTypeArguments */ any, typeParameters []TypeParameter, index number) Type {
		if node.typeArguments && index < node.typeArguments.length {
			return getTypeFromTypeNode(node.typeArguments[index])
		}
		return getEffectiveTypeArguments(node, typeParameters)[index]
	}
	getEffectiveTypeArguments := func(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) []Type {
		return fillMissingTypeArguments(map_(node.typeArguments, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(node))
	}
	checkTypeArgumentConstraints := func(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) bool {
		var typeArguments *[]Type
		var mapper *TypeMapper
		result := true
		for i := 0; i < typeParameters.length; i++ {
			constraint := getConstraintOfTypeParameter(typeParameters[i])
			if constraint {
				if !typeArguments {
					typeArguments = getEffectiveTypeArguments(node, typeParameters)
					mapper = createTypeMapper(typeParameters, typeArguments)
				}
				result = result && checkTypeAssignableTo(typeArguments[i], instantiateType(constraint, mapper), node.typeArguments[i], Diagnostics.Type_0_does_not_satisfy_the_constraint_1)
			}
		}
		return result
	}
	getTypeParametersForTypeAndSymbol := func(type_ Type, symbol Symbol) *[]TypeParameter {
		if !isErrorType(type_) {
			return symbol.flags&SymbolFlagsTypeAlias && getSymbolLinks(symbol).typeParameters || (__COND__(getObjectFlags(type_)&ObjectFlagsReference, (type_ /* as TypeReference */).target.localTypeParameters, nil))
		}
		return nil
	}
	getTypeParametersForTypeReferenceOrImport := func(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) *[]TypeParameter {
		type_ := getTypeFromTypeNode(node)
		if !isErrorType(type_) {
			symbol := getNodeLinks(node).resolvedSymbol
			if symbol {
				return getTypeParametersForTypeAndSymbol(type_, symbol)
			}
		}
		return nil
	}
	checkTypeReferenceNode := func(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ExpressionWithTypeArguments */ any) {
		checkGrammarTypeArguments(node, node.typeArguments)
		if node.kind == SyntaxKindTypeReference && !isInJSFile(node) && !isInJSDoc(node) && node.typeArguments && node.typeName.end != node.typeArguments.pos {
			// If there was a token between the type name and the type arguments, check if it was a DotToken
			sourceFile := getSourceFileOfNode(node)
			if scanTokenAtPosition(sourceFile, node.typeName.end) == SyntaxKindDotToken {
				grammarErrorAtPos(node, skipTrivia(sourceFile.text, node.typeName.end), 1, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments)
			}
		}
		forEach(node.typeArguments, checkSourceElement)
		checkTypeReferenceOrImport(node)
	}
	checkTypeReferenceOrImport := func(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) {
		type_ := getTypeFromTypeNode(node)
		if !isErrorType(type_) {
			if node.typeArguments {
				addLazyDiagnostic(func() {
					typeParameters := getTypeParametersForTypeReferenceOrImport(node)
					if typeParameters {
						checkTypeArgumentConstraints(node, typeParameters)
					}
				})
			}
			symbol := getNodeLinks(node).resolvedSymbol
			if symbol {
				if some(symbol.declarations, func(d Declaration) bool {
					return isTypeDeclaration(d) && !!(d.flags & NodeFlagsDeprecated)
				}) {
					addDeprecatedSuggestion(getDeprecatedSuggestionNode(node), symbol.declarations, symbol.escapedName /* as string */)
				}
			}
		}
	}
	getTypeArgumentConstraint := func(node TypeNode) Type {
		typeReferenceNode := tryCast(node.parent, isTypeReferenceType)
		if !typeReferenceNode {
			return nil
		}
		typeParameters := getTypeParametersForTypeReferenceOrImport(typeReferenceNode)
		if !typeParameters {
			return nil
		}
		constraint := getConstraintOfTypeParameter(typeParameters[typeReferenceNode.typeArguments.indexOf(node)])
		return constraint && instantiateType(constraint, createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReferenceNode, typeParameters)))
	}
	checkTypeQuery := func(node TypeQueryNode) {
		getTypeFromTypeQueryNode(node)
	}
	checkTypeLiteral := func(node TypeLiteralNode) {
		forEach(node.members, checkSourceElement)
		addLazyDiagnostic(checkTypeLiteralDiagnostics)
		checkTypeLiteralDiagnostics := func() {
			type_ := getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node)
			checkIndexConstraints(type_, type_.symbol)
			checkTypeForDuplicateIndexSignatures(node)
			checkObjectTypeForDuplicateDeclarations(node)
		}
	}
	checkArrayType := func(node ArrayTypeNode) {
		checkSourceElement(node.elementType)
	}
	checkTupleType := func(node TupleTypeNode) {
		seenOptionalElement := false
		seenRestElement := false
		for _, e := range node.elements {
			flags := getTupleElementFlags(e)
			if flags & ElementFlagsVariadic {
				type_ := getTypeFromTypeNode((e /* as RestTypeNode | NamedTupleMember */).type_)
				if !isArrayLikeType(type_) {
					error(e, Diagnostics.A_rest_element_type_must_be_an_array_type)
					break
				}
				if isArrayType(type_) || isTupleType(type_) && type_.target.combinedFlags&ElementFlagsRest {
					flags |= ElementFlagsRest
				}
			}
			if flags & ElementFlagsRest {
				if seenRestElement {
					grammarErrorOnNode(e, Diagnostics.A_rest_element_cannot_follow_another_rest_element)
					break
				}
				seenRestElement = true
			} else if flags & ElementFlagsOptional {
				if seenRestElement {
					grammarErrorOnNode(e, Diagnostics.An_optional_element_cannot_follow_a_rest_element)
					break
				}
				seenOptionalElement = true
			} else if flags&ElementFlagsRequired && seenOptionalElement {
				grammarErrorOnNode(e, Diagnostics.A_required_element_cannot_follow_an_optional_element)
				break
			}
		}
		forEach(node.elements, checkSourceElement)
		getTypeFromTypeNode(node)
	}
	checkUnionOrIntersectionType := func(node UnionOrIntersectionTypeNode) {
		forEach(node.types, checkSourceElement)
		getTypeFromTypeNode(node)
	}
	checkIndexedAccessIndexType := func(type_ Type, accessNode /* TODO(TS-TO-GO) TypeNode UnionType: IndexedAccessTypeNode | ElementAccessExpression */ any) Type {
		if !(type_.flags & TypeFlagsIndexedAccess) {
			return type_
		}
		// Check if the index type is assignable to 'keyof T' for the object type.
		objectType := (type_ /* as IndexedAccessType */).objectType
		indexType := (type_ /* as IndexedAccessType */).indexType
		// skip index type deferral on remapping mapped types
		var objectIndexType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isGenericMappedType(objectType) && getMappedTypeNameTypeKind(objectType) == MappedTypeNameTypeKindRemapping:
			objectIndexType = getIndexTypeForMappedType(objectType, IndexFlagsNone)
		default:
			objectIndexType = getIndexType(objectType, IndexFlagsNone)
		}
		hasNumberIndexInfo := !!getIndexInfoOfType(objectType, numberType)
		if everyType(indexType, func(t Type) bool {
			return isTypeAssignableTo(t, objectIndexType) || hasNumberIndexInfo && isApplicableIndexType(t, numberType)
		}) {
			if accessNode.kind == SyntaxKindElementAccessExpression && isAssignmentTarget(accessNode) && getObjectFlags(objectType)&ObjectFlagsMapped && getMappedTypeModifiers(objectType /* as MappedType */)&MappedTypeModifiersIncludeReadonly {
				error(accessNode, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType))
			}
			return type_
		}
		if isGenericObjectType(objectType) {
			propertyName := getPropertyNameFromIndex(indexType, accessNode)
			if propertyName {
				propertySymbol := forEachType(getApparentType(objectType), func(t Type) Symbol {
					return getPropertyOfType(t, propertyName)
				})
				if propertySymbol && getDeclarationModifierFlagsFromSymbol(propertySymbol)&ModifierFlagsNonPublicAccessibilityModifier {
					error(accessNode, Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, unescapeLeadingUnderscores(propertyName))
					return errorType
				}
			}
		}
		error(accessNode, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType))
		return errorType
	}
	checkIndexedAccessType := func(node IndexedAccessTypeNode) {
		checkSourceElement(node.objectType)
		checkSourceElement(node.indexType)
		checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node)
	}
	checkMappedType := func(node MappedTypeNode) {
		checkGrammarMappedType(node)
		checkSourceElement(node.typeParameter)
		checkSourceElement(node.nameType)
		checkSourceElement(node.type_)
		if !node.type_ {
			reportImplicitAny(node, anyType)
		}
		type_ := getTypeFromMappedTypeNode(node) /* as MappedType */
		nameType := getNameTypeFromMappedType(type_)
		if nameType {
			checkTypeAssignableTo(nameType, stringNumberSymbolType, node.nameType)
		} else {
			constraintType := getConstraintTypeFromMappedType(type_)
			checkTypeAssignableTo(constraintType, stringNumberSymbolType, getEffectiveConstraintOfTypeParameter(node.typeParameter))
		}
	}
	checkGrammarMappedType := func(node MappedTypeNode) *bool {
		if node.members. /* TODO(TS-TO-GO): was ? */ length {
			return grammarErrorOnNode(node.members[0], Diagnostics.A_mapped_type_may_not_declare_properties_or_methods)
		}
	}
	checkThisType := func(node ThisTypeNode) {
		getTypeFromThisTypeNode(node)
	}
	checkTypeOperator := func(node TypeOperatorNode) {
		checkGrammarTypeOperatorNode(node)
		checkSourceElement(node.type_)
	}
	checkConditionalType := func(node ConditionalTypeNode) {
		forEachChild(node, checkSourceElement)
	}
	checkInferType := func(node InferTypeNode) {
		if !findAncestor(node, func(n Node) bool {
			return n.parent && n.parent.kind == SyntaxKindConditionalType && (n.parent /* as ConditionalTypeNode */).extendsType == n
		}) {
			grammarErrorOnNode(node, Diagnostics.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type)
		}
		checkSourceElement(node.typeParameter)
		symbol := getSymbolOfDeclaration(node.typeParameter)
		if symbol.declarations && symbol.declarations.length > 1 {
			links := getSymbolLinks(symbol)
			if !links.typeParametersChecked {
				links.typeParametersChecked = true
				typeParameter := getDeclaredTypeOfTypeParameter(symbol)
				var declarations []TypeParameterDeclaration = getDeclarationsOfKind(symbol, SyntaxKindTypeParameter)
				if !areTypeParametersIdentical(declarations, []TypeParameter{typeParameter}, func(decl TypeParameterDeclaration) []TypeParameterDeclaration {
					return []TypeParameterDeclaration{decl}
				}) {
					// Report an error on every conflicting declaration.
					name := symbolToString(symbol)
					for _, declaration := range declarations {
						error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_constraints, name)
					}
				}
			}
		}
		registerForUnusedIdentifiersCheck(node)
	}
	checkTemplateLiteralType := func(node TemplateLiteralTypeNode) {
		for _, span := range node.templateSpans {
			checkSourceElement(span.type_)
			type_ := getTypeFromTypeNode(span.type_)
			checkTypeAssignableTo(type_, templateConstraintType, span.type_)
		}
		getTypeFromTypeNode(node)
	}
	checkImportType := func(node ImportTypeNode) {
		checkSourceElement(node.argument)
		if node.attributes {
			getResolutionModeOverride(node.attributes, grammarErrorOnNode)
		}
		checkTypeReferenceOrImport(node)
	}
	checkNamedTupleMember := func(node NamedTupleMember) {
		if node.dotDotDotToken && node.questionToken {
			grammarErrorOnNode(node, Diagnostics.A_tuple_member_cannot_be_both_optional_and_rest)
		}
		if node.type_.kind == SyntaxKindOptionalType {
			grammarErrorOnNode(node.type_, Diagnostics.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type)
		}
		if node.type_.kind == SyntaxKindRestType {
			grammarErrorOnNode(node.type_, Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type)
		}
		checkSourceElement(node.type_)
		getTypeFromTypeNode(node)
	}
	isPrivateWithinAmbient := func(node Node) bool {
		return (hasEffectiveModifier(node, ModifierFlagsPrivate) || isPrivateIdentifierClassElementDeclaration(node)) && !!(node.flags & NodeFlagsAmbient)
	}
	getEffectiveDeclarationFlags := func(n Declaration, flagsToCheck ModifierFlags) ModifierFlags {
		flags := getCombinedModifierFlagsCached(n)
		// children of classes (even ambient classes) should not be marked as ambient or export
		// because those flags have no useful semantics there.
		if n.parent.kind != SyntaxKindInterfaceDeclaration && n.parent.kind != SyntaxKindClassDeclaration && n.parent.kind != SyntaxKindClassExpression && n.flags&NodeFlagsAmbient {
			container := getEnclosingContainer(n)
			if (container && container.flags&NodeFlagsExportContext) && !(flags & ModifierFlagsAmbient) && !(isModuleBlock(n.parent) && isModuleDeclaration(n.parent.parent) && isGlobalScopeAugmentation(n.parent.parent)) {
				// It is nested in an ambient export context, which means it is automatically exported
				flags |= ModifierFlagsExport
			}
			flags |= ModifierFlagsAmbient
		}
		return flags & flagsToCheck
	}
	checkFunctionOrConstructorSymbol := func(symbol Symbol) {
		addLazyDiagnostic(func() {
			return checkFunctionOrConstructorSymbolWorker(symbol)
		})
	}
	checkFunctionOrConstructorSymbolWorker := func(symbol Symbol) {
		getCanonicalOverload := func(overloads []Declaration, implementation *FunctionLikeDeclaration) Declaration {
			// Consider the canonical set of flags to be the flags of the bodyDeclaration or the first declaration
			// Error on all deviations from this canonical set of flags
			// The caveat is that if some overloads are defined in lib.d.ts, we don't want to
			// report the errors on those. To achieve this, we will say that the implementation is
			// the canonical signature only if it is in the same container as the first overload
			implementationSharesContainerWithFirstOverload := implementation != nil && implementation.parent == overloads[0].parent
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case implementationSharesContainerWithFirstOverload:
				return implementation
			default:
				return overloads[0]
			}
		}
		checkFlagAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, flagsToCheck ModifierFlags, someOverloadFlags ModifierFlags, allOverloadFlags ModifierFlags) {
			// Error if some overloads have a flag that is not shared by all overloads. To find the
			// deviations, we XOR someOverloadFlags with allOverloadFlags
			someButNotAllOverloadFlags := /* TODO(TS-TO-GO) Node BinaryExpression: someOverloadFlags ^ allOverloadFlags */ TODO
			if someButNotAllOverloadFlags != 0 {
				canonicalFlags := getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck)
				group(overloads, func(o Declaration) string {
					return getSourceFileOfNode(o).fileName
				}).forEach(func(overloadsInFile []Declaration) {
					canonicalFlagsForFile := getEffectiveDeclarationFlags(getCanonicalOverload(overloadsInFile, implementation), flagsToCheck)
					for _, o := range overloadsInFile {
						deviation := /* TODO(TS-TO-GO) Node BinaryExpression: getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags */ TODO
						deviationInFile := /* TODO(TS-TO-GO) Node BinaryExpression: getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlagsForFile */ TODO
						if deviationInFile & ModifierFlagsExport {
							// Overloads in different files need not all have export modifiers. This is ok:
							//   // lib.d.ts
							//   declare function foo(s: number): string;
							//   declare function foo(s: string): number;
							//   export { foo };
							//
							//   // app.ts
							//   declare module "lib" {
							//     export function foo(s: boolean): boolean;
							//   }
							error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported)
						} else if deviationInFile & ModifierFlagsAmbient {
							// Though rare, a module augmentation (necessarily ambient) is allowed to add overloads
							// to a non-ambient function in an implementation file.
							error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient)
						} else if deviation & (ModifierFlagsPrivate | ModifierFlagsProtected) {
							error(getNameOfDeclaration(o) || o, Diagnostics.Overload_signatures_must_all_be_public_private_or_protected)
						} else if deviation & ModifierFlagsAbstract {
							error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract)
						}
					}
				})
			}
		}
		checkQuestionTokenAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, someHaveQuestionToken bool, allHaveQuestionToken bool) {
			if someHaveQuestionToken != allHaveQuestionToken {
				canonicalHasQuestionToken := hasQuestionToken(getCanonicalOverload(overloads, implementation))
				forEach(overloads, func(o Declaration) {
					deviation := hasQuestionToken(o) != canonicalHasQuestionToken
					if deviation {
						error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_optional_or_required)
					}
				})
			}
		}
		var flagsToCheck ModifierFlags = ModifierFlagsExport | ModifierFlagsAmbient | ModifierFlagsPrivate | ModifierFlagsProtected | ModifierFlagsAbstract
		var someNodeFlags ModifierFlags = ModifierFlagsNone
		allNodeFlags := flagsToCheck
		someHaveQuestionToken := false
		allHaveQuestionToken := true
		hasOverloads := false
		var bodyDeclaration *FunctionLikeDeclaration
		var lastSeenNonAmbientDeclaration *FunctionLikeDeclaration
		var previousDeclaration *SignatureDeclaration
		declarations := symbol.declarations
		isConstructor := (symbol.flags & SymbolFlagsConstructor) != 0
		reportImplementationExpectedError := func(node SignatureDeclaration) {
			if node.name && nodeIsMissing(node.name) {
				return
			}
			seen := false
			subsequentNode := forEachChild(node.parent, func(c Node) Node {
				if seen {
					return c
				} else {
					seen = c == node
				}
			})
			// We may be here because of some extra nodes between overloads that could not be parsed into a valid node.
			// In this case the subsequent node is not really consecutive (.pos !== node.end), and we must ignore it here.
			if subsequentNode && subsequentNode.pos == node.end {
				if subsequentNode.kind == node.kind {
					var errorNode Node = (subsequentNode /* as FunctionLikeDeclaration */).name || subsequentNode
					subsequentName := (subsequentNode /* as FunctionLikeDeclaration */).name
					if node.name && subsequentName && (isPrivateIdentifier(node.name) && isPrivateIdentifier(subsequentName) && node.name.escapedText == subsequentName.escapedText || isComputedPropertyName(node.name) && isComputedPropertyName(subsequentName) && isTypeIdenticalTo(checkComputedPropertyName(node.name), checkComputedPropertyName(subsequentName)) || isPropertyNameLiteral(node.name) && isPropertyNameLiteral(subsequentName) && getEscapedTextOfIdentifierOrLiteral(node.name) == getEscapedTextOfIdentifierOrLiteral(subsequentName)) {
						reportError := (node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature) && isStatic(node) != isStatic(subsequentNode)
						// we can get here in two cases
						// 1. mixed static and instance class members
						// 2. something with the same name was defined before the set of overloads that prevents them from merging
						// here we'll report error only for the first case since for second we should already report error in binder
						if reportError {
							var diagnostic DiagnosticMessage
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case isStatic(node):
								diagnostic = Diagnostics.Function_overload_must_be_static
							default:
								diagnostic = Diagnostics.Function_overload_must_not_be_static
							}
							error(errorNode, diagnostic)
						}
						return
					}
					if nodeIsPresent((subsequentNode /* as FunctionLikeDeclaration */).body) {
						error(errorNode, Diagnostics.Function_implementation_name_must_be_0, declarationNameToString(node.name))
						return
					}
				}
			}
			var errorNode Node = node.name || node
			if isConstructor {
				error(errorNode, Diagnostics.Constructor_implementation_is_missing)
			} else {
				// Report different errors regarding non-consecutive blocks of declarations depending on whether
				// the node in question is abstract.
				if hasSyntacticModifier(node, ModifierFlagsAbstract) {
					error(errorNode, Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive)
				} else {
					error(errorNode, Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration)
				}
			}
		}
		duplicateFunctionDeclaration := false
		multipleConstructorImplementation := false
		hasNonAmbientClass := false
		functionDeclarations := []never{} /* as Declaration[] */
		if declarations {
			for _, current := range declarations {
				node := current /* as SignatureDeclaration | ClassDeclaration | ClassExpression */
				inAmbientContext := node.flags & NodeFlagsAmbient
				inAmbientContextOrInterface := node.parent && (node.parent.kind == SyntaxKindInterfaceDeclaration || node.parent.kind == SyntaxKindTypeLiteral) || inAmbientContext
				if inAmbientContextOrInterface {
					// check if declarations are consecutive only if they are non-ambient
					// 1. ambient declarations can be interleaved
					// i.e. this is legal
					//     declare function foo();
					//     declare function bar();
					//     declare function foo();
					// 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one
					previousDeclaration = nil
				}
				if (node.kind == SyntaxKindClassDeclaration || node.kind == SyntaxKindClassExpression) && !inAmbientContext {
					hasNonAmbientClass = true
				}
				if node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature || node.kind == SyntaxKindConstructor {
					functionDeclarations.push(node)
					currentNodeFlags := getEffectiveDeclarationFlags(node, flagsToCheck)
					someNodeFlags |= currentNodeFlags
					allNodeFlags &= currentNodeFlags
					someHaveQuestionToken = someHaveQuestionToken || hasQuestionToken(node)
					allHaveQuestionToken = allHaveQuestionToken && hasQuestionToken(node)
					bodyIsPresent := nodeIsPresent((node /* as FunctionLikeDeclaration */).body)
					if bodyIsPresent && bodyDeclaration {
						if isConstructor {
							multipleConstructorImplementation = true
						} else {
							duplicateFunctionDeclaration = true
						}
					} else if previousDeclaration. /* TODO(TS-TO-GO): was ? */ parent == node.parent && previousDeclaration.end != node.pos {
						reportImplementationExpectedError(previousDeclaration)
					}
					if bodyIsPresent {
						if !bodyDeclaration {
							bodyDeclaration = node /* as FunctionLikeDeclaration */
						}
					} else {
						hasOverloads = true
					}
					previousDeclaration = node
					if !inAmbientContextOrInterface {
						lastSeenNonAmbientDeclaration = node /* as FunctionLikeDeclaration */
					}
				}
				if isInJSFile(current) && isFunctionLike(current) && current.jsDoc {
					hasOverloads = length(getJSDocOverloadTags(current)) > 0
				}
			}
		}
		if multipleConstructorImplementation {
			forEach(functionDeclarations, func(declaration Declaration) {
				error(declaration, Diagnostics.Multiple_constructor_implementations_are_not_allowed)
			})
		}
		if duplicateFunctionDeclaration {
			forEach(functionDeclarations, func(declaration Declaration) {
				error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Duplicate_function_implementation)
			})
		}
		if hasNonAmbientClass && !isConstructor && symbol.flags&SymbolFlagsFunction && declarations {
			relatedDiagnostics := filter(declarations, func(d Declaration) bool {
				return d.kind == SyntaxKindClassDeclaration
			}).map_(func(d Declaration) DiagnosticWithLocation {
				return createDiagnosticForNode(d, Diagnostics.Consider_adding_a_declare_modifier_to_this_class)
			})
			forEach(declarations, func(declaration Declaration) {
				var diagnostic *DiagnosticMessage
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case declaration.kind == SyntaxKindClassDeclaration:
					diagnostic = Diagnostics.Class_declaration_cannot_implement_overload_list_for_0
				case declaration.kind == SyntaxKindFunctionDeclaration:
					diagnostic = Diagnostics.Function_with_bodies_can_only_merge_with_classes_that_are_ambient
				default:
					diagnostic = nil
				}
				if diagnostic {
					addRelatedInfo(error(getNameOfDeclaration(declaration) || declaration, diagnostic, symbolName(symbol)), relatedDiagnostics...)
				}
			})
		}
		// Abstract methods can't have an implementation -- in particular, they don't need one.
		if lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body && !hasSyntacticModifier(lastSeenNonAmbientDeclaration, ModifierFlagsAbstract) && !lastSeenNonAmbientDeclaration.questionToken {
			reportImplementationExpectedError(lastSeenNonAmbientDeclaration)
		}
		if hasOverloads {
			if declarations {
				checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags)
				checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken)
			}
			if bodyDeclaration {
				signatures := getSignaturesOfSymbol(symbol)
				bodySignature := getSignatureFromDeclaration(bodyDeclaration)
				for _, signature := range signatures {
					if !isImplementationCompatibleWithOverload(bodySignature, signature) {
						var errorNode * /* TODO(TS-TO-GO) inferred type Identifier | SignatureDeclaration */ any
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case signature.declaration && isJSDocSignature(signature.declaration):
							errorNode = (signature.declaration.parent /* as JSDocOverloadTag | JSDocCallbackTag */).tagName
						default:
							errorNode = signature.declaration
						}
						addRelatedInfo(error(errorNode, Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature), createDiagnosticForNode(bodyDeclaration, Diagnostics.The_implementation_signature_is_declared_here))
						break
					}
				}
			}
		}
	}
	checkExportsOnMergedDeclarations := func(node Declaration) {
		addLazyDiagnostic(func() {
			return checkExportsOnMergedDeclarationsWorker(node)
		})
	}
	checkExportsOnMergedDeclarationsWorker := func(node Declaration) {
		// if localSymbol is defined on node then node itself is exported - check is required
		symbol := node.localSymbol
		if !symbol {
			// local symbol is undefined => this declaration is non-exported.
			// however symbol might contain other declarations that are exported
			symbol = getSymbolOfDeclaration(node)
			if !symbol.exportSymbol {
				// this is a pure local symbol (all declarations are non-exported) - no need to check anything
				return
			}
		}
		// run the check only for the first declaration in the list
		if getDeclarationOfKind(symbol, node.kind) != node {
			return
		}
		exportedDeclarationSpaces := DeclarationSpacesNone
		nonExportedDeclarationSpaces := DeclarationSpacesNone
		defaultExportedDeclarationSpaces := DeclarationSpacesNone
		for _, d := range symbol.declarations {
			declarationSpaces := getDeclarationSpaces(d)
			effectiveDeclarationFlags := getEffectiveDeclarationFlags(d, ModifierFlagsExport|ModifierFlagsDefault)
			if effectiveDeclarationFlags & ModifierFlagsExport {
				if effectiveDeclarationFlags & ModifierFlagsDefault {
					defaultExportedDeclarationSpaces |= declarationSpaces
				} else {
					exportedDeclarationSpaces |= declarationSpaces
				}
			} else {
				nonExportedDeclarationSpaces |= declarationSpaces
			}
		}
		// Spaces for anything not declared a 'default export'.
		nonDefaultExportedDeclarationSpaces := exportedDeclarationSpaces | nonExportedDeclarationSpaces
		commonDeclarationSpacesForExportsAndLocals := exportedDeclarationSpaces & nonExportedDeclarationSpaces
		commonDeclarationSpacesForDefaultAndNonDefault := defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces
		if commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault {
			// declaration spaces for exported and non-exported declarations intersect
			for _, d := range symbol.declarations {
				declarationSpaces := getDeclarationSpaces(d)
				name := getNameOfDeclaration(d)
				// Only error on the declarations that contributed to the intersecting spaces.
				if declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault {
					error(name, Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, declarationNameToString(name))
				} else if declarationSpaces & commonDeclarationSpacesForExportsAndLocals {
					error(name, Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, declarationNameToString(name))
				}
			}
		}
		getDeclarationSpaces := func(decl Declaration) DeclarationSpaces {
			d := decl /* as Node */
			switch d.kind {
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindTypeAliasDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJSDocTypedefTag:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJSDocCallbackTag:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindJSDocEnumTag:
				return DeclarationSpacesExportType
			case SyntaxKindModuleDeclaration:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isAmbientModule(d /* as ModuleDeclaration */) || getModuleInstanceState(d /* as ModuleDeclaration */) != ModuleInstanceStateNonInstantiated:
					return DeclarationSpacesExportNamespace | DeclarationSpacesExportValue
				default:
					return DeclarationSpacesExportNamespace
				}
			case SyntaxKindClassDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindEnumDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindEnumMember:
				return DeclarationSpacesExportType | DeclarationSpacesExportValue
			case SyntaxKindSourceFile:
				return DeclarationSpacesExportType | DeclarationSpacesExportValue | DeclarationSpacesExportNamespace
			case SyntaxKindExportAssignment:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindBinaryExpression:
				node := d /* as ExportAssignment | BinaryExpression */
				var expression Expression
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isExportAssignment(node):
					expression = node.expression
				default:
					expression = node.right
				}
				if !isEntityNameExpression(expression) {
					return DeclarationSpacesExportValue
				}
				d = expression
				fallthrough
			case SyntaxKindImportEqualsDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindNamespaceImport:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindImportClause:
				result := DeclarationSpacesNone
				target := resolveAlias(getSymbolOfDeclaration(d /* as ImportEqualsDeclaration | NamespaceImport | ImportClause | ExportAssignment | BinaryExpression */))
				forEach(target.declarations, func(d Declaration) {
					result |= getDeclarationSpaces(d)
				})
				return result
			case SyntaxKindVariableDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindBindingElement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindFunctionDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindImportSpecifier:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindIdentifier:
				return DeclarationSpacesExportValue
			case SyntaxKindMethodSignature:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindPropertySignature:
				return DeclarationSpacesExportType
			default:
				return Debug.failBadSyntaxKind(d)
			}
		}
	}
	getAwaitedTypeOfPromise := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) Type {
		promisedType := getPromisedTypeOfPromise(type_, errorNode)
		return promisedType && getAwaitedType(promisedType, errorNode, diagnosticMessage, args...)
	}
	/**
	 * Gets the "promised type" of a promise.
	 * @param type The type of the promise.
	 * @remarks The "promised type" of a type is the type of the "value" parameter of the "onfulfilled" callback.
	 */
	getPromisedTypeOfPromise := func(type_ Type, errorNode Node, thisTypeForErrorOut /* TODO(TS-TO-GO) TypeNode TypeLiteral: { value?: Type; } */ any) Type {
		//
		//  { // type
		//      then( // thenFunction
		//          onfulfilled: ( // onfulfilledParameterType
		//              value: T // valueParameterType
		//          ) => any
		//      ): any;
		//  }
		//
		if isTypeAny(type_) {
			return nil
		}
		typeAsPromise := type_ /* as PromiseOrAwaitableType */
		if typeAsPromise.promisedTypeOfPromise {
			return typeAsPromise.promisedTypeOfPromise
		}
		if isReferenceToType(type_, getGlobalPromiseType(false)) {
			typeAsPromise.promisedTypeOfPromise = getTypeArguments(type_ /* as GenericType */)[0]
			return typeAsPromise.promisedTypeOfPromise
		}
		// primitives with a `{ then() }` won't be unwrapped/adopted.
		if allTypesAssignableToKind(getBaseConstraintOrType(type_), TypeFlagsPrimitive|TypeFlagsNever) {
			return nil
		}
		thenFunction := getTypeOfPropertyOfType(type_, "then" /* as __String */)
		// TODO: GH#18217
		if isTypeAny(thenFunction) {
			return nil
		}
		var thenSignatures []Signature
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case thenFunction:
			thenSignatures = getSignaturesOfType(thenFunction, SignatureKindCall)
		default:
			thenSignatures = emptyArray
		}
		if thenSignatures.length == 0 {
			if errorNode {
				error(errorNode, Diagnostics.A_promise_must_have_a_then_method)
			}
			return nil
		}
		var thisTypeForError Type
		var candidates *[]Signature
		for _, thenSignature := range thenSignatures {
			thisType := getThisTypeOfSignature(thenSignature)
			if thisType && thisType != voidType && !isTypeRelatedTo(type_, thisType, subtypeRelation) {
				thisTypeForError = thisType
			} else {
				candidates = append(candidates, thenSignature)
			}
		}
		if !candidates {
			Debug.assertIsDefined(thisTypeForError)
			if thisTypeForErrorOut {
				thisTypeForErrorOut.value = thisTypeForError
			}
			if errorNode {
				error(errorNode, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type_), typeToString(thisTypeForError))
			}
			return nil
		}
		onfulfilledParameterType := getTypeWithFacts(getUnionType(map_(candidates, getTypeOfFirstParameterOfSignature)), TypeFactsNEUndefinedOrNull)
		if isTypeAny(onfulfilledParameterType) {
			return nil
		}
		onfulfilledParameterSignatures := getSignaturesOfType(onfulfilledParameterType, SignatureKindCall)
		if onfulfilledParameterSignatures.length == 0 {
			if errorNode {
				error(errorNode, Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback)
			}
			return nil
		}
		typeAsPromise.promisedTypeOfPromise = getUnionType(map_(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature), UnionReductionSubtype)
		return typeAsPromise.promisedTypeOfPromise
	}
	/**
	 * Gets the "awaited type" of a type.
	 * @param type The type to await.
	 * @param withAlias When `true`, wraps the "awaited type" in `Awaited<T>` if needed.
	 * @remarks The "awaited type" of an expression is its "promised type" if the expression is a
	 * Promise-like type; otherwise, it is the type of the expression. This is used to reflect
	 * The runtime behavior of the `await` keyword.
	 */
	checkAwaitedType := func(type_ Type, withAlias bool, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) Type {
		var awaitedType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case withAlias:
			awaitedType = getAwaitedType(type_, errorNode, diagnosticMessage, args...)
		default:
			awaitedType = getAwaitedTypeNoAlias(type_, errorNode, diagnosticMessage, args...)
		}
		return awaitedType || errorType
	}
	/**
	 * Determines whether a type is an object with a callable `then` member.
	 */
	isThenableType := func(type_ Type) bool {
		if allTypesAssignableToKind(getBaseConstraintOrType(type_), TypeFlagsPrimitive|TypeFlagsNever) {
			// primitive types cannot be considered "thenable" since they are not objects.
			return false
		}
		thenFunction := getTypeOfPropertyOfType(type_, "then" /* as __String */)
		return !!thenFunction && getSignaturesOfType(getTypeWithFacts(thenFunction, TypeFactsNEUndefinedOrNull), SignatureKindCall).length > 0
	}
	type AwaitedTypeInstantiation struct {
		_awaitedTypeBrand  never
		aliasSymbol        Symbol
		aliasTypeArguments []Type
	}
	isAwaitedTypeInstantiation := func(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is AwaitedTypeInstantiation */ any {
		if type_.flags & TypeFlagsConditional {
			awaitedSymbol := getGlobalAwaitedSymbol(false)
			return !!awaitedSymbol && type_.aliasSymbol == awaitedSymbol && type_.aliasTypeArguments. /* TODO(TS-TO-GO): was ? */ length == 1
		}
		return false
	}
	/**
	 * For a generic `Awaited<T>`, gets `T`.
	 */
	unwrapAwaitedType := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnion:
			return mapType(type_, unwrapAwaitedType)
		case isAwaitedTypeInstantiation(type_):
			return type_.aliasTypeArguments[0]
		default:
			return type_
		}
	}
	isAwaitedTypeNeeded := func(type_ Type) bool {
		// If this is already an `Awaited<T>`, we shouldn't wrap it. This helps to avoid `Awaited<Awaited<T>>` in higher-order.
		if isTypeAny(type_) || isAwaitedTypeInstantiation(type_) {
			return false
		}
		// We only need `Awaited<T>` if `T` contains possibly non-primitive types.
		if isGenericObjectType(type_) {
			baseConstraint := getBaseConstraintOfType(type_)
			// We only need `Awaited<T>` if `T` is a type variable that has no base constraint, or the base constraint of `T` is `any`, `unknown`, `{}`, `object`,
			// or is promise-like.
			if __COND__(baseConstraint, baseConstraint.flags&TypeFlagsAnyOrUnknown || isEmptyObjectType(baseConstraint) || someType(baseConstraint, isThenableType), maybeTypeOfKind(type_, TypeFlagsTypeVariable)) {
				return true
			}
		}
		return false
	}
	tryCreateAwaitedType := func(type_ Type) Type {
		// Nothing to do if `Awaited<T>` doesn't exist
		awaitedSymbol := getGlobalAwaitedSymbol(true)
		if awaitedSymbol {
			// Unwrap unions that may contain `Awaited<T>`, otherwise its possible to manufacture an `Awaited<Awaited<T> | U>` where
			// an `Awaited<T | U>` would suffice.
			return getTypeAliasInstantiation(awaitedSymbol, []Type{unwrapAwaitedType(type_)})
		}
		return nil
	}
	createAwaitedTypeIfNeeded := func(type_ Type) Type {
		// We wrap type `T` in `Awaited<T>` based on the following conditions:
		// - `T` is not already an `Awaited<U>`, and
		// - `T` is generic, and
		// - One of the following applies:
		//   - `T` has no base constraint, or
		//   - The base constraint of `T` is `any`, `unknown`, `object`, or `{}`, or
		//   - The base constraint of `T` is an object type with a callable `then` method.
		if isAwaitedTypeNeeded(type_) {
			return /* TODO(TS-TO-GO) Node BinaryExpression: tryCreateAwaitedType(type) ?? type */ TODO
		}
		Debug.assert(isAwaitedTypeInstantiation(type_) || getPromisedTypeOfPromise(type_) == nil, "type provided should not be a non-generic 'promise'-like.")
		return type_
	}
	/**
	 * Gets the "awaited type" of a type.
	 *
	 * The "awaited type" of an expression is its "promised type" if the expression is a
	 * Promise-like type; otherwise, it is the type of the expression. If the "promised
	 * type" is itself a Promise-like, the "promised type" is recursively unwrapped until a
	 * non-promise type is found.
	 *
	 * This is used to reflect the runtime behavior of the `await` keyword.
	 */
	getAwaitedType := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) Type {
		awaitedType := getAwaitedTypeNoAlias(type_, errorNode, diagnosticMessage, args...)
		return awaitedType && createAwaitedTypeIfNeeded(awaitedType)
	}
	/**
	 * Gets the "awaited type" of a type without introducing an `Awaited<T>` wrapper.
	 *
	 * @see {@link getAwaitedType}
	 */
	getAwaitedTypeNoAlias := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) Type {
		if isTypeAny(type_) {
			return type_
		}
		// If this is already an `Awaited<T>`, just return it. This avoids `Awaited<Awaited<T>>` in higher-order
		if isAwaitedTypeInstantiation(type_) {
			return type_
		}
		// If we've already cached an awaited type, return a possible `Awaited<T>` for it.
		typeAsAwaitable := type_ /* as PromiseOrAwaitableType */
		if typeAsAwaitable.awaitedTypeOfType {
			return typeAsAwaitable.awaitedTypeOfType
		}
		// For a union, get a union of the awaited types of each constituent.
		if type_.flags & TypeFlagsUnion {
			if awaitedTypeStack.lastIndexOf(type_.id) >= 0 {
				if errorNode {
					error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method)
				}
				return nil
			}
			var mapper * /* TODO(TS-TO-GO) inferred type (type: Type, errorNode?: Node, diagnosticMessage?: DiagnosticMessage, ...args: DiagnosticArguments) => Type */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case errorNode:
				mapper = func(constituentType Type) Type {
					return getAwaitedTypeNoAlias(constituentType, errorNode, diagnosticMessage, args...)
				}
			default:
				mapper = getAwaitedTypeNoAlias
			}
			awaitedTypeStack.push(type_.id)
			mapped := mapType(type_, mapper)
			awaitedTypeStack.pop()
			typeAsAwaitable.awaitedTypeOfType = mapped
			return typeAsAwaitable.awaitedTypeOfType
		}
		// If `type` is generic and should be wrapped in `Awaited<T>`, return it.
		if isAwaitedTypeNeeded(type_) {
			typeAsAwaitable.awaitedTypeOfType = type_
			return typeAsAwaitable.awaitedTypeOfType
		}
		var thisTypeForErrorOut /* TODO(TS-TO-GO) TypeNode TypeLiteral: { value: Type | undefined; } */ any = map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"value": nil,
		}
		promisedType := getPromisedTypeOfPromise(type_ /*errorNode*/, nil, thisTypeForErrorOut)
		if promisedType {
			if type_.id == promisedType.id || awaitedTypeStack.lastIndexOf(promisedType.id) >= 0 {
				// Verify that we don't have a bad actor in the form of a promise whose
				// promised type is the same as the promise type, or a mutually recursive
				// promise. If so, we return undefined as we cannot guess the shape. If this
				// were the actual case in the JavaScript, this Promise would never resolve.
				//
				// An example of a bad actor with a singly-recursive promise type might
				// be:
				//
				//  interface BadPromise {
				//      then(
				//          onfulfilled: (value: BadPromise) => any,
				//          onrejected: (error: any) => any): BadPromise;
				//  }
				//
				// The above interface will pass the PromiseLike check, and return a
				// promised type of `BadPromise`. Since this is a self reference, we
				// don't want to keep recursing ad infinitum.
				//
				// An example of a bad actor in the form of a mutually-recursive
				// promise type might be:
				//
				//  interface BadPromiseA {
				//      then(
				//          onfulfilled: (value: BadPromiseB) => any,
				//          onrejected: (error: any) => any): BadPromiseB;
				//  }
				//
				//  interface BadPromiseB {
				//      then(
				//          onfulfilled: (value: BadPromiseA) => any,
				//          onrejected: (error: any) => any): BadPromiseA;
				//  }
				//
				if errorNode {
					error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method)
				}
				return nil
			}
			// Keep track of the type we're about to unwrap to avoid bad recursive promise types.
			// See the comments above for more information.
			awaitedTypeStack.push(type_.id)
			awaitedType := getAwaitedTypeNoAlias(promisedType, errorNode, diagnosticMessage, args...)
			awaitedTypeStack.pop()
			if !awaitedType {
				return nil
			}
			typeAsAwaitable.awaitedTypeOfType = awaitedType
			return typeAsAwaitable.awaitedTypeOfType
		}
		// The type was not a promise, so it could not be unwrapped any further.
		// As long as the type does not have a callable "then" property, it is
		// safe to return the type; otherwise, an error is reported and we return
		// undefined.
		//
		// An example of a non-promise "thenable" might be:
		//
		//  await { then(): void {} }
		//
		// The "thenable" does not match the minimal definition for a promise. When
		// a Promise/A+-compatible or ES6 promise tries to adopt this value, the promise
		// will never settle. We treat this as an error to help flag an early indicator
		// of a runtime problem. If the user wants to return this value from an async
		// function, they would need to wrap it in some other value. If they want it to
		// be treated as a promise, they can cast to <any>.
		if isThenableType(type_) {
			if errorNode {
				Debug.assertIsDefined(diagnosticMessage)
				var chain *DiagnosticMessageChain
				if thisTypeForErrorOut.value {
					chain = chainDiagnosticMessages(chain, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type_), typeToString(thisTypeForErrorOut.value))
				}
				chain = chainDiagnosticMessages(chain, diagnosticMessage, args...)
				diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chain))
			}
			return nil
		}
		typeAsAwaitable.awaitedTypeOfType = type_
		return typeAsAwaitable.awaitedTypeOfType
	}
	/**
	 * Checks the return type of an async function to ensure it is a compatible
	 * Promise implementation.
	 *
	 * This checks that an async function has a valid Promise-compatible return type.
	 * An async function has a valid Promise-compatible return type if the resolved value
	 * of the return type has a construct signature that takes in an `initializer` function
	 * that in turn supplies a `resolve` function as one of its arguments and results in an
	 * object with a callable `then` signature.
	 *
	 * @param node The signature to check
	 */
	checkAsyncFunctionReturnType := func(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionLikeDeclaration | MethodSignature */ any, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode) {
		// As part of our emit for an async function, we will need to emit the entity name of
		// the return type annotation as an expression. To meet the necessary runtime semantics
		// for __awaiter, we must also check that the type of the declaration (e.g. the static
		// side or "constructor" of the promise type) is compatible `PromiseConstructorLike`.
		//
		// An example might be (from lib.es6.d.ts):
		//
		//  interface Promise<T> { ... }
		//  interface PromiseConstructor {
		//      new <T>(...): Promise<T>;
		//  }
		//  declare var Promise: PromiseConstructor;
		//
		// When an async function declares a return type annotation of `Promise<T>`, we
		// need to get the type of the `Promise` variable declaration above, which would
		// be `PromiseConstructor`.
		//
		// The same case applies to a class:
		//
		//  declare class Promise<T> {
		//      constructor(...);
		//      then<U>(...): Promise<U>;
		//  }
		//
		returnType := getTypeFromTypeNode(returnTypeNode)
		if languageVersion >= ScriptTargetES2015 {
			if isErrorType(returnType) {
				return
			}
			globalPromiseType := getGlobalPromiseType(true)
			if globalPromiseType != emptyGenericType && !isReferenceToType(returnType, globalPromiseType) {
				// The promise type was not a valid type reference to the global promise type, so we
				// report an error and return the unknown type.
				reportErrorForInvalidReturnType(Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0, returnTypeNode, returnTypeErrorLocation, typeToString(getAwaitedTypeNoAlias(returnType) || voidType))
				return
			}
		} else {
			// Always mark the type node as referenced if it points to a value
			markLinkedReferences(node, ReferenceHintAsyncFunction)
			if isErrorType(returnType) {
				return
			}
			promiseConstructorName := getEntityNameFromTypeNode(returnTypeNode)
			if promiseConstructorName == nil {
				reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, typeToString(returnType))
				return
			}
			promiseConstructorSymbol := resolveEntityName(promiseConstructorName, SymbolFlagsValue /*ignoreErrors*/, true)
			var promiseConstructorType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case promiseConstructorSymbol:
				promiseConstructorType = getTypeOfSymbol(promiseConstructorSymbol)
			default:
				promiseConstructorType = errorType
			}
			if isErrorType(promiseConstructorType) {
				if promiseConstructorName.kind == SyntaxKindIdentifier && promiseConstructorName.escapedText == "Promise" && getTargetType(returnType) == getGlobalPromiseType(false) {
					error(returnTypeErrorLocation, Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option)
				} else {
					reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName))
				}
				return
			}
			globalPromiseConstructorLikeType := getGlobalPromiseConstructorLikeType(true)
			if globalPromiseConstructorLikeType == emptyObjectType {
				// If we couldn't resolve the global PromiseConstructorLike type we cannot verify
				// compatibility with __awaiter.
				reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName))
				return
			}
			headMessage := Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value
			errorInfo := func() *DiagnosticMessageChain {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case returnTypeNode == returnTypeErrorLocation:
					return nil
				default:
					return chainDiagnosticMessages(nil, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type)
				}
			}
			if !checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, returnTypeErrorLocation, headMessage, errorInfo) {
				return
			}
			// Verify there is no local declaration that could collide with the promise constructor.
			rootName := promiseConstructorName && getFirstIdentifier(promiseConstructorName)
			collidingSymbol := getSymbol(node.locals, rootName.escapedText, SymbolFlagsValue)
			if collidingSymbol {
				error(collidingSymbol.valueDeclaration, Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions, idText(rootName), entityNameToString(promiseConstructorName))
				return
			}
		}
		checkAwaitedType(returnType /*withAlias*/, false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
		reportErrorForInvalidReturnType := func(message DiagnosticMessage, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode, typeName string) {
			if returnTypeNode == returnTypeErrorLocation {
				error(returnTypeErrorLocation, message, typeName)
			} else {
				diag := error(returnTypeErrorLocation, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type)
				addRelatedInfo(diag, createDiagnosticForNode(returnTypeNode, message, typeName))
			}
		}
	}
	checkGrammarDecorator := func(decorator Decorator) bool {
		sourceFile := getSourceFileOfNode(decorator)
		if !hasParseDiagnostics(sourceFile) {
			var node Expression = decorator.expression
			// DecoratorParenthesizedExpression :
			//   `(` Expression `)`
			if isParenthesizedExpression(node) {
				return false
			}
			canHaveCallExpression := true
			var errorNode Node
			for true {
				// Allow TS syntax such as non-null assertions and instantiation expressions
				if isExpressionWithTypeArguments(node) || isNonNullExpression(node) {
					node = node.expression
					continue
				}
				// DecoratorCallExpression :
				//   DecoratorMemberExpression Arguments
				if isCallExpression(node) {
					if !canHaveCallExpression {
						errorNode = node
					}
					if node.questionDotToken {
						// Even if we already have an error node, error at the `?.` token since it appears earlier.
						errorNode = node.questionDotToken
					}
					node = node.expression
					canHaveCallExpression = false
					continue
				}
				// DecoratorMemberExpression :
				//   IdentifierReference
				//   DecoratorMemberExpression `.` IdentifierName
				//   DecoratorMemberExpression `.` PrivateIdentifier
				if isPropertyAccessExpression(node) {
					if node.questionDotToken {
						// Even if we already have an error node, error at the `?.` token since it appears earlier.
						errorNode = node.questionDotToken
					}
					node = node.expression
					canHaveCallExpression = false
					continue
				}
				if !isIdentifier(node) {
					// Even if we already have an error node, error at this node since it appears earlier.
					errorNode = node
				}
				break
			}
			if errorNode {
				addRelatedInfo(error(decorator.expression, Diagnostics.Expression_must_be_enclosed_in_parentheses_to_be_used_as_a_decorator), createDiagnosticForNode(errorNode, Diagnostics.Invalid_syntax_in_decorator))
				return true
			}
		}
		return false
	}
	/** Check a decorator */
	checkDecorator := func(node Decorator) {
		checkGrammarDecorator(node)
		signature := getResolvedSignature(node)
		checkDeprecatedSignature(signature, node)
		returnType := getReturnTypeOfSignature(signature)
		if returnType.flags & TypeFlagsAny {
			return
		}
		// if we fail to get a signature and return type here, we will have already reported a grammar error in `checkDecorators`.
		decoratorSignature := getDecoratorCallSignature(node)
		if !decoratorSignature. /* TODO(TS-TO-GO): was ? */ resolvedReturnType {
			return
		}
		var headMessage DiagnosticMessage
		expectedReturnType := decoratorSignature.resolvedReturnType
		switch node.parent.kind {
		case SyntaxKindClassDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindClassExpression:
			headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1
			break
		case SyntaxKindPropertyDeclaration:
			if !legacyDecorators {
				headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1
				break
			}
			fallthrough
		case SyntaxKindParameter:
			headMessage = Diagnostics.Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any
			break
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindSetAccessor:
			headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1
			break
		default:
			return Debug.failBadSyntaxKind(node.parent)
		}
		checkTypeAssignableTo(returnType, expectedReturnType, node.expression, headMessage)
	}
	/**
	 * Creates a synthetic `Signature` corresponding to a call signature.
	 */
	createCallSignature := func(typeParameters *[]TypeParameter, thisParameter Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number /*  = parameters.length */, flags SignatureFlags /*  = SignatureFlags.None */) Signature {
		decl := factory.createFunctionTypeNode(nil, emptyArray, factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
		return createSignature(decl, typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
	}
	/**
	 * Creates a synthetic `FunctionType`
	 */
	createFunctionType := func(typeParameters *[]TypeParameter, thisParameter Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number, flags SignatureFlags) ObjectType {
		signature := createCallSignature(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
		return getOrCreateTypeFromSignature(signature)
	}
	createGetterFunctionType := func(type_ Type) ObjectType {
		return createFunctionType(nil /*thisParameter*/, nil, emptyArray, type_)
	}
	createSetterFunctionType := func(type_ Type) ObjectType {
		valueParam := createParameter("value" /* as __String */, type_)
		return createFunctionType(nil /*thisParameter*/, nil, []TransientSymbol{valueParam}, voidType)
	}
	getEntityNameForDecoratorMetadata := func(node *TypeNode) *EntityName {
		if node {
			switch node.kind {
			case SyntaxKindIntersectionType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindUnionType:
				return getEntityNameForDecoratorMetadataFromTypeList((node /* as UnionOrIntersectionTypeNode */).types)
			case SyntaxKindConditionalType:
				return getEntityNameForDecoratorMetadataFromTypeList([]TypeNode{(node /* as ConditionalTypeNode */).trueType, (node /* as ConditionalTypeNode */).falseType})
			case SyntaxKindParenthesizedType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindNamedTupleMember:
				return getEntityNameForDecoratorMetadata((node /* as ParenthesizedTypeNode */).type_)
			case SyntaxKindTypeReference:
				return (node /* as TypeReferenceNode */).typeName
			}
		}
	}
	getEntityNameForDecoratorMetadataFromTypeList := func(types []TypeNode) *EntityName {
		var commonEntityName *EntityName
		for _, typeNode := range types {
			for typeNode.kind == SyntaxKindParenthesizedType || typeNode.kind == SyntaxKindNamedTupleMember {
				typeNode = (typeNode /* as ParenthesizedTypeNode | NamedTupleMember */).type_
				// Skip parens if need be
			}
			if typeNode.kind == SyntaxKindNeverKeyword {
				continue
				// Always elide `never` from the union/intersection if possible
			}
			if !strictNullChecks && (typeNode.kind == SyntaxKindLiteralType && (typeNode /* as LiteralTypeNode */).literal.kind == SyntaxKindNullKeyword || typeNode.kind == SyntaxKindUndefinedKeyword) {
				continue
				// Elide null and undefined from unions for metadata, just like what we did prior to the implementation of strict null checks
			}
			individualEntityName := getEntityNameForDecoratorMetadata(typeNode)
			if !individualEntityName {
				// Individual is something like string number
				// So it would be serialized to either that type or object
				// Safe to return here
				return nil
			}
			if commonEntityName {
				// Note this is in sync with the transformation that happens for type node.
				// Keep this in sync with serializeUnionOrIntersectionType
				// Verify if they refer to same entity and is identifier
				// return undefined if they dont match because we would emit object
				if !isIdentifier(commonEntityName) || !isIdentifier(individualEntityName) || commonEntityName.escapedText != individualEntityName.escapedText {
					return nil
				}
			} else {
				commonEntityName = individualEntityName
			}
		}
		return commonEntityName
	}
	getParameterTypeNodeForDecoratorCheck := func(node ParameterDeclaration) *TypeNode {
		typeNode := getEffectiveTypeAnnotationNode(node)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isRestParameter(node):
			return getRestParameterElementType(typeNode)
		default:
			return typeNode
		}
	}
	/** Check the decorators of a node */
	checkDecorators := func(node Node) {
		// skip this check for nodes that cannot have decorators. These should have already had an error reported by
		// checkGrammarModifiers.
		if !canHaveDecorators(node) || !hasDecorators(node) || !node.modifiers || !nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent) {
			return
		}
		firstDecorator := find(node.modifiers, isDecorator)
		if !firstDecorator {
			return
		}
		if legacyDecorators {
			checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersDecorate)
			if node.kind == SyntaxKindParameter {
				checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersParam)
			}
		} else if languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators {
			checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersESDecorateAndRunInitializers)
			if isClassDeclaration(node) {
				if !node.name {
					checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
				} else {
					member := getFirstTransformableStaticClassElement(node)
					if member {
						checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
					}
				}
			} else if !isClassExpression(node) {
				if isPrivateIdentifier(node.name) && (isMethodDeclaration(node) || isAccessor(node) || isAutoAccessorPropertyDeclaration(node)) {
					checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
				}
				if isComputedPropertyName(node.name) {
					checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersPropKey)
				}
			}
		}
		markLinkedReferences(node, ReferenceHintDecorator)
		for _, modifier := range node.modifiers {
			if isDecorator(modifier) {
				checkDecorator(modifier)
			}
		}
	}
	checkFunctionDeclaration := func(node FunctionDeclaration) {
		addLazyDiagnostic(checkFunctionDeclarationDiagnostics)
		checkFunctionDeclarationDiagnostics := func() {
			checkFunctionOrMethodDeclaration(node)
			checkGrammarForGenerator(node)
			checkCollisionsForDeclarationName(node, node.name)
		}
	}
	checkJSDocTypeAliasTag := func(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypedefTag | JSDocCallbackTag */ any) {
		if !node.typeExpression {
			// If the node had `@property` tags, `typeExpression` would have been set to the first property tag.
			error(node.name, Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags)
		}
		if node.name {
			checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0)
		}
		checkSourceElement(node.typeExpression)
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
	}
	checkJSDocTemplateTag := func(node JSDocTemplateTag) {
		checkSourceElement(node.constraint)
		for _, tp := range node.typeParameters {
			checkSourceElement(tp)
		}
	}
	checkJSDocTypeTag := func(node JSDocTypeTag) {
		checkSourceElement(node.typeExpression)
	}
	checkJSDocSatisfiesTag := func(node JSDocSatisfiesTag) {
		checkSourceElement(node.typeExpression)
		host := getEffectiveJSDocHost(node)
		if host {
			tags := getAllJSDocTags(host, isJSDocSatisfiesTag)
			if length(tags) > 1 {
				for i := 1; i < length(tags); i++ {
					tagName := tags[i].tagName
					error(tagName, Diagnostics._0_tag_already_specified, idText(tagName))
				}
			}
		}
	}
	checkJSDocLinkLikeTag := func(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocLink | JSDocLinkCode | JSDocLinkPlain */ any) {
		if node.name {
			resolveJSDocMemberName(node.name /*ignoreErrors*/, true)
		}
	}
	checkJSDocParameterTag := func(node JSDocParameterTag) {
		checkSourceElement(node.typeExpression)
	}
	checkJSDocPropertyTag := func(node JSDocPropertyTag) {
		checkSourceElement(node.typeExpression)
	}
	checkJSDocFunctionType := func(node JSDocFunctionType) {
		addLazyDiagnostic(checkJSDocFunctionTypeImplicitAny)
		checkSignatureDeclaration(node)
		checkJSDocFunctionTypeImplicitAny := func() {
			if !node.type_ && !isJSDocConstructSignature(node) {
				reportImplicitAny(node, anyType)
			}
		}
	}
	checkJSDocThisTag := func(node JSDocThisTag) {
		host := getEffectiveJSDocHost(node)
		if host && isArrowFunction(host) {
			error(node.tagName, Diagnostics.An_arrow_function_cannot_have_a_this_parameter)
		}
	}
	checkJSDocImportTag := func(node JSDocImportTag) {
		checkImportAttributes(node)
	}
	checkJSDocImplementsTag := func(node JSDocImplementsTag) {
		classLike := getEffectiveJSDocHost(node)
		if !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) {
			error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName))
		}
	}
	checkJSDocAugmentsTag := func(node JSDocAugmentsTag) {
		classLike := getEffectiveJSDocHost(node)
		if !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) {
			error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName))
			return
		}
		augmentsTags := getJSDocTags(classLike).filter(isJSDocAugmentsTag)
		Debug.assert(augmentsTags.length > 0)
		if augmentsTags.length > 1 {
			error(augmentsTags[1], Diagnostics.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag)
		}
		name := getIdentifierFromEntityNameExpression(node.class.expression)
		extend := getClassExtendsHeritageElement(classLike)
		if extend {
			className := getIdentifierFromEntityNameExpression(extend.expression)
			if className && name.escapedText != className.escapedText {
				error(name, Diagnostics.JSDoc_0_1_does_not_match_the_extends_2_clause, idText(node.tagName), idText(name), idText(className))
			}
		}
	}
	checkJSDocAccessibilityModifiers := func(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag */ any) {
		host := getJSDocHost(node)
		if host && isPrivateIdentifierClassElementDeclaration(host) {
			error(node, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier)
		}
	}
	/* TODO(TS-TO-GO): function getIdentifierFromEntityNameExpression(node: Identifier | PropertyAccessExpression): Identifier | PrivateIdentifier; */
	/* TODO(TS-TO-GO): function getIdentifierFromEntityNameExpression(node: Expression): Identifier | PrivateIdentifier | undefined; */
	getIdentifierFromEntityNameExpression := func(node Expression) /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier | undefined */ any {
		switch node.kind {
		case SyntaxKindIdentifier:
			return node /* as Identifier */
		case SyntaxKindPropertyAccessExpression:
			return (node /* as PropertyAccessExpression */).name
		default:
			return nil
		}
	}
	checkFunctionOrMethodDeclaration := func(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionDeclaration | MethodDeclaration | MethodSignature */ any) {
		checkDecorators(node)
		checkSignatureDeclaration(node)
		functionFlags := getFunctionFlags(node)
		// Do not use hasDynamicName here, because that returns false for well known symbols.
		// We want to perform checkComputedPropertyName for all computed properties, including
		// well known symbols.
		if node.name && node.name.kind == SyntaxKindComputedPropertyName {
			// This check will account for methods in class/interface declarations,
			// as well as accessors in classes/object literals
			checkComputedPropertyName(node.name)
		}
		if hasBindableName(node) {
			// first we want to check the local symbol that contain this declaration
			// - if node.localSymbol !== undefined - this is current declaration is exported and localSymbol points to the local symbol
			// - if node.localSymbol === undefined - this node is non-exported so we can just pick the result of getSymbolOfNode
			symbol := getSymbolOfDeclaration(node)
			localSymbol := node.localSymbol || symbol
			// Since the javascript won't do semantic analysis like typescript,
			// if the javascript file comes before the typescript file and both contain same name functions,
			// checkFunctionOrConstructorSymbol wouldn't be called if we didnt ignore javascript function.
			firstDeclaration := localSymbol.declarations. /* TODO(TS-TO-GO): was ? */ find(func(declaration Declaration) bool {
				return declaration.kind == node.kind && !(declaration.flags & NodeFlagsJavaScriptFile)
			})
			// Only type check the symbol once
			if node == firstDeclaration {
				checkFunctionOrConstructorSymbol(localSymbol)
			}
			if symbol.parent {
				// run check on export symbol to check that modifiers agree across all exported declarations
				checkFunctionOrConstructorSymbol(symbol)
			}
		}
		var body *Block
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.kind == SyntaxKindMethodSignature:
			body = nil
		default:
			body = node.body
		}
		checkSourceElement(body)
		checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, getReturnTypeFromAnnotation(node))
		addLazyDiagnostic(checkFunctionOrMethodDeclarationDiagnostics)
		// A js function declaration can have a @type tag instead of a return type node, but that type must have a call signature
		if isInJSFile(node) {
			typeTag := getJSDocTypeTag(node)
			if typeTag && typeTag.typeExpression && !getContextualCallSignature(getTypeFromTypeNode(typeTag.typeExpression), node) {
				error(typeTag.typeExpression.type_, Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature)
			}
		}
		checkFunctionOrMethodDeclarationDiagnostics := func() {
			if !getEffectiveReturnTypeNode(node) {
				// Report an implicit any error if there is no body, no explicit return type, and node is not a private method
				// in an ambient context
				if nodeIsMissing(body) && !isPrivateWithinAmbient(node) {
					reportImplicitAny(node, anyType)
				}
				if functionFlags&FunctionFlagsGenerator && nodeIsPresent(body) {
					// A generator with a body and no type annotation can still cause errors. It can error if the
					// yielded values have no common supertype, or it can give an implicit any error if it has no
					// yielded values. The only way to trigger these errors is to try checking its return type.
					getReturnTypeOfSignature(getSignatureFromDeclaration(node))
				}
			}
		}
	}
	registerForUnusedIdentifiersCheck := func(node PotentiallyUnusedIdentifier) {
		addLazyDiagnostic(registerForUnusedIdentifiersCheckDiagnostics)
		registerForUnusedIdentifiersCheckDiagnostics := func() {
			// May be in a call such as getTypeOfNode that happened to call this. But potentiallyUnusedIdentifiers is only defined in the scope of `checkSourceFile`.
			sourceFile := getSourceFileOfNode(node)
			potentiallyUnusedIdentifiers := allPotentiallyUnusedIdentifiers.get(sourceFile.path)
			if !potentiallyUnusedIdentifiers {
				potentiallyUnusedIdentifiers = []never{}
				allPotentiallyUnusedIdentifiers.set(sourceFile.path, potentiallyUnusedIdentifiers)
			}
			// TODO: GH#22580
			// Debug.assert(addToSeen(seenPotentiallyUnusedIdentifiers, getNodeId(node)), "Adding potentially-unused identifier twice");
			potentiallyUnusedIdentifiers.push(node)
		}
	}
	type PotentiallyUnusedIdentifier /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | ModuleDeclaration | ClassLikeDeclaration | InterfaceDeclaration | Block | CaseBlock | ForStatement | ForInStatement | ForOfStatement | Exclude<SignatureDeclaration, IndexSignatureDeclaration | JSDocFunctionType> | TypeAliasDeclaration | InferTypeNode */ any
	checkUnusedIdentifiers := func(potentiallyUnusedIdentifiers []PotentiallyUnusedIdentifier, addDiagnostic AddUnusedDiagnostic) {
		for _, node := range potentiallyUnusedIdentifiers {
			switch node.kind {
			case SyntaxKindClassDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindClassExpression:
				checkUnusedClassMembers(node, addDiagnostic)
				checkUnusedTypeParameters(node, addDiagnostic)
				break
			case SyntaxKindSourceFile:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindModuleDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindBlock:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindCaseBlock:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindForStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindForInStatement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindForOfStatement:
				checkUnusedLocalsAndParameters(node, addDiagnostic)
				break
			case SyntaxKindConstructor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindFunctionExpression:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindFunctionDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindArrowFunction:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindSetAccessor:
				if node.body {
					checkUnusedLocalsAndParameters(node, addDiagnostic)
				}
				checkUnusedTypeParameters(node, addDiagnostic)
				break
			case SyntaxKindMethodSignature:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindCallSignature:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindConstructSignature:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindFunctionType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindConstructorType:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindTypeAliasDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindInterfaceDeclaration:
				checkUnusedTypeParameters(node, addDiagnostic)
				break
			case SyntaxKindInferType:
				checkUnusedInferTypeParameter(node, addDiagnostic)
				break
			default:
				Debug.assertNever(node, "Node should not have been registered for unused identifiers check")
			}
		}
	}
	errorUnusedLocal := func(declaration Declaration, name string, addDiagnostic AddUnusedDiagnostic) {
		node := getNameOfDeclaration(declaration) || declaration
		var message DiagnosticMessage
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isTypeDeclaration(declaration):
			message = Diagnostics._0_is_declared_but_never_used
		default:
			message = Diagnostics._0_is_declared_but_its_value_is_never_read
		}
		addDiagnostic(declaration, UnusedKindLocal, createDiagnosticForNode(node, message, name))
	}
	isIdentifierThatStartsWithUnderscore := func(node Node) bool {
		return isIdentifier(node) && idText(node).charCodeAt(0) == CharacterCodes_
	}
	checkUnusedClassMembers := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ClassDeclaration | ClassExpression */ any, addDiagnostic AddUnusedDiagnostic) {
		for _, member := range node.members {
			switch member.kind {
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindPropertyDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindSetAccessor:
				if member.kind == SyntaxKindSetAccessor && member.symbol.flags&SymbolFlagsGetAccessor {
					// Already would have reported an error on the getter.
					break
				}
				symbol := getSymbolOfDeclaration(member)
				if !symbol.isReferenced && (hasEffectiveModifier(member, ModifierFlagsPrivate) || isNamedDeclaration(member) && isPrivateIdentifier(member.name)) && !(member.flags & NodeFlagsAmbient) {
					addDiagnostic(member, UnusedKindLocal, createDiagnosticForNode(member.name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolToString(symbol)))
				}
				break
			case SyntaxKindConstructor:
				for _, parameter := range (member /* as ConstructorDeclaration */).parameters {
					if !parameter.symbol.isReferenced && hasSyntacticModifier(parameter, ModifierFlagsPrivate) {
						addDiagnostic(parameter, UnusedKindLocal, createDiagnosticForNode(parameter.name, Diagnostics.Property_0_is_declared_but_its_value_is_never_read, symbolName(parameter.symbol)))
					}
				}
				break
			case SyntaxKindIndexSignature:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindSemicolonClassElement:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindClassStaticBlockDeclaration:
				break
			default:
				Debug.fail("Unexpected class member")
			}
		}
	}
	checkUnusedInferTypeParameter := func(node InferTypeNode, addDiagnostic AddUnusedDiagnostic) {
		TODO_IDENTIFIER := node
		if isTypeParameterUnused(typeParameter) {
			addDiagnostic(node, UnusedKindParameter, createDiagnosticForNode(node, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(typeParameter.name)))
		}
	}
	checkUnusedTypeParameters := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ClassLikeDeclaration | SignatureDeclaration | InterfaceDeclaration | TypeAliasDeclaration */ any, addDiagnostic AddUnusedDiagnostic) {
		// Only report errors on the last declaration for the type parameter container;
		// this ensures that all uses have been accounted for.
		declarations := getSymbolOfDeclaration(node).declarations
		if !declarations || last(declarations) != node {
			return
		}
		typeParameters := getEffectiveTypeParameterDeclarations(node)
		seenParentsWithEveryUnused := NewSet[DeclarationWithTypeParameterChildren]()
		for _, typeParameter := range typeParameters {
			if !isTypeParameterUnused(typeParameter) {
				continue
			}
			name := idText(typeParameter.name)
			TODO_IDENTIFIER := typeParameter
			if parent.kind != SyntaxKindInferType && parent.typeParameters.every(isTypeParameterUnused) {
				if tryAddToSet(seenParentsWithEveryUnused, parent) {
					sourceFile := getSourceFileOfNode(parent)
					var range_ TextRange
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isJSDocTemplateTag(parent):
						range_ = rangeOfNode(parent)
					default:
						range_ = rangeOfTypeParameters(sourceFile, parent.typeParameters)
					}
					only := parent.typeParameters.length == 1
					// TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
					var messageAndArg DiagnosticAndArguments
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case only:
						messageAndArg = []any{Diagnostics._0_is_declared_but_its_value_is_never_read, name}
					default:
						messageAndArg = []any{Diagnostics.All_type_parameters_are_unused}
					}
					addDiagnostic(typeParameter, UnusedKindParameter, createFileDiagnostic(sourceFile, range_.pos, range_.end-range_.pos, messageAndArg...))
				}
			} else {
				// TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
				addDiagnostic(typeParameter, UnusedKindParameter, createDiagnosticForNode(typeParameter, Diagnostics._0_is_declared_but_its_value_is_never_read, name))
			}
		}
	}
	isTypeParameterUnused := func(typeParameter TypeParameterDeclaration) bool {
		return !(getMergedSymbol(typeParameter.symbol).isReferenced & SymbolFlagsTypeParameter) && !isIdentifierThatStartsWithUnderscore(typeParameter.name)
	}
	addToGroup := func(map_ Map[string /* TODO(TS-TO-GO) TypeNode TupleType: [K, V[]] */, any], key K, value V, getKey func(key K) /* TODO(TS-TO-GO) TypeNode UnionType: number | string */ any) {
		keyString := String(getKey(key))
		group := map_.get(keyString)
		if group {
			group[1].push(value)
		} else {
			map_.set(keyString, []any{key, []V{value}})
		}
	}
	tryGetRootParameterDeclaration := func(node Node) *ParameterDeclaration {
		return tryCast(getRootDeclaration(node), isParameter)
	}
	isValidUnusedLocalDeclaration := func(declaration Declaration) bool {
		if isBindingElement(declaration) {
			if isObjectBindingPattern(declaration.parent) {
				/**
				 * ignore starts with underscore names _
				 * const { a: _a } = { a: 1 }
				 */
				return !!(declaration.propertyName && isIdentifierThatStartsWithUnderscore(declaration.name))
			}
			return isIdentifierThatStartsWithUnderscore(declaration.name)
		}
		return isAmbientModule(declaration) || (isVariableDeclaration(declaration) && isForInOrOfStatement(declaration.parent.parent) || isImportedDeclaration(declaration)) && isIdentifierThatStartsWithUnderscore(declaration.name)
	}
	checkUnusedLocalsAndParameters := func(nodeWithLocals HasLocals, addDiagnostic AddUnusedDiagnostic) {
		// Ideally we could use the ImportClause directly as a key, but must wait until we have full ES6 maps. So must store key along with value.
		unusedImports := NewMap[string /* TODO(TS-TO-GO) TypeNode TupleType: [ImportClause, ImportedDeclaration[]] */, any]()
		unusedDestructures := NewMap[string /* TODO(TS-TO-GO) TypeNode TupleType: [BindingPattern, BindingElement[]] */, any]()
		unusedVariables := NewMap[string /* TODO(TS-TO-GO) TypeNode TupleType: [VariableDeclarationList, VariableDeclaration[]] */, any]()
		nodeWithLocals.locals.forEach(func(local Symbol) {
			// If it's purely a type parameter, ignore, will be checked in `checkUnusedTypeParameters`.
			// If it's a type parameter merged with a parameter, check if the parameter-side is used.
			if __COND__(local.flags&SymbolFlagsTypeParameter, !(local.flags&SymbolFlagsVariable && !(local.isReferenced & SymbolFlagsVariable)), local.isReferenced || local.exportSymbol) {
				return
			}
			if local.declarations {
				for _, declaration := range local.declarations {
					if isValidUnusedLocalDeclaration(declaration) {
						continue
					}
					if isImportedDeclaration(declaration) {
						addToGroup(unusedImports, importClauseFromImported(declaration), declaration, getNodeId)
					} else if isBindingElement(declaration) && isObjectBindingPattern(declaration.parent) {
						// In `{ a, ...b }, `a` is considered used since it removes a property from `b`. `b` may still be unused though.
						lastElement := last(declaration.parent.elements)
						if declaration == lastElement || !last(declaration.parent.elements).dotDotDotToken {
							addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId)
						}
					} else if isVariableDeclaration(declaration) {
						blockScopeKind := getCombinedNodeFlagsCached(declaration) & NodeFlagsBlockScoped
						name := getNameOfDeclaration(declaration)
						if blockScopeKind != NodeFlagsUsing && blockScopeKind != NodeFlagsAwaitUsing || !name || !isIdentifierThatStartsWithUnderscore(name) {
							addToGroup(unusedVariables, declaration.parent, declaration, getNodeId)
						}
					} else {
						parameter := local.valueDeclaration && tryGetRootParameterDeclaration(local.valueDeclaration)
						name := local.valueDeclaration && getNameOfDeclaration(local.valueDeclaration)
						if parameter && name {
							if !isParameterPropertyDeclaration(parameter, parameter.parent) && !parameterIsThisKeyword(parameter) && !isIdentifierThatStartsWithUnderscore(name) {
								if isBindingElement(declaration) && isArrayBindingPattern(declaration.parent) {
									addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId)
								} else {
									addDiagnostic(parameter, UnusedKindParameter, createDiagnosticForNode(name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolName(local)))
								}
							}
						} else {
							errorUnusedLocal(declaration, symbolName(local), addDiagnostic)
						}
					}
				}
			}
		})
		unusedImports.forEach(func(TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [ImportClause, (ImportClause | NamespaceImport | ImportSpecifier)[]] */ any) {
			importDecl := importClause.parent
			nDeclarations := (__COND__(importClause.name, 1, 0)) + (__COND__(importClause.namedBindings, (__COND__(importClause.namedBindings.kind == SyntaxKindNamespaceImport, 1, importClause.namedBindings.elements.length)), 0))
			if nDeclarations == unuseds.length {
				addDiagnostic(importDecl, UnusedKindLocal, __COND__(unuseds.length == 1, createDiagnosticForNode(importDecl, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(first(unuseds).name)), createDiagnosticForNode(importDecl, Diagnostics.All_imports_in_import_declaration_are_unused)))
			} else {
				for _, unused := range unuseds {
					errorUnusedLocal(unused, idText(unused.name), addDiagnostic)
				}
			}
		})
		unusedDestructures.forEach(func(TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [BindingPattern, BindingElement[]] */ any) {
			var kind UnusedKind
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case tryGetRootParameterDeclaration(bindingPattern.parent):
				kind = UnusedKindParameter
			default:
				kind = UnusedKindLocal
			}
			if bindingPattern.elements.length == bindingElements.length {
				if bindingElements.length == 1 && bindingPattern.parent.kind == SyntaxKindVariableDeclaration && bindingPattern.parent.parent.kind == SyntaxKindVariableDeclarationList {
					addToGroup(unusedVariables, bindingPattern.parent.parent, bindingPattern.parent, getNodeId)
				} else {
					addDiagnostic(bindingPattern, kind, __COND__(bindingElements.length == 1, createDiagnosticForNode(bindingPattern, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(bindingElements).name)), createDiagnosticForNode(bindingPattern, Diagnostics.All_destructured_elements_are_unused)))
				}
			} else {
				for _, e := range bindingElements {
					addDiagnostic(e, kind, createDiagnosticForNode(e, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(e.name)))
				}
			}
		})
		unusedVariables.forEach(func(TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [VariableDeclarationList, VariableDeclaration[]] */ any) {
			if declarationList.declarations.length == declarations.length {
				addDiagnostic(declarationList, UnusedKindLocal, __COND__(declarations.length == 1, createDiagnosticForNode(first(declarations).name, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(declarations).name)), createDiagnosticForNode(__COND__(declarationList.parent.kind == SyntaxKindVariableStatement, declarationList.parent, declarationList), Diagnostics.All_variables_are_unused)))
			} else {
				for _, decl := range declarations {
					addDiagnostic(decl, UnusedKindLocal, createDiagnosticForNode(decl, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(decl.name)))
				}
			}
		})
	}
	checkPotentialUncheckedRenamedBindingElementsInTypes := func() {
		for _, node := range potentialUnusedRenamedBindingElementsInTypes {
			if !getSymbolOfDeclaration(node). /* TODO(TS-TO-GO): was ? */ isReferenced {
				wrappingDeclaration := walkUpBindingElementsAndPatterns(node)
				Debug.assert(isPartOfParameterDeclaration(wrappingDeclaration), "Only parameter declaration should be checked here")
				diagnostic := createDiagnosticForNode(node.name, Diagnostics._0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation, declarationNameToString(node.name), declarationNameToString(node.propertyName))
				if !wrappingDeclaration.type_ {
					// entire parameter does not have type annotation, suggest adding an annotation
					addRelatedInfo(diagnostic, createFileDiagnostic(getSourceFileOfNode(wrappingDeclaration), wrappingDeclaration.end, 0, Diagnostics.We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here, declarationNameToString(node.propertyName)))
				}
				diagnostics.add(diagnostic)
			}
		}
	}
	bindingNameText := func(name BindingName) string {
		switch name.kind {
		case SyntaxKindIdentifier:
			return idText(name)
		case SyntaxKindArrayBindingPattern:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindObjectBindingPattern:
			return bindingNameText(cast(first(name.elements), isBindingElement).name)
		default:
			return Debug.assertNever(name)
		}
	}
	type ImportedDeclaration /* TODO(TS-TO-GO) TypeNode UnionType: ImportClause | ImportSpecifier | NamespaceImport */ any
	isImportedDeclaration := func(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is ImportedDeclaration */ any {
		return node.kind == SyntaxKindImportClause || node.kind == SyntaxKindImportSpecifier || node.kind == SyntaxKindNamespaceImport
	}
	importClauseFromImported := func(decl ImportedDeclaration) ImportClause {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case decl.kind == SyntaxKindImportClause:
			return decl
		case decl.kind == SyntaxKindNamespaceImport:
			return decl.parent
		default:
			return decl.parent.parent
		}
	}
	checkBlock := func(node Block) {
		// Grammar checking for SyntaxKind.Block
		if node.kind == SyntaxKindBlock {
			checkGrammarStatementInAmbientContext(node)
		}
		if isFunctionOrModuleBlock(node) {
			saveFlowAnalysisDisabled := flowAnalysisDisabled
			forEach(node.statements, checkSourceElement)
			flowAnalysisDisabled = saveFlowAnalysisDisabled
		} else {
			forEach(node.statements, checkSourceElement)
		}
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkCollisionWithArgumentsInGeneratedCode := func(node SignatureDeclaration) {
		// no rest parameters \ declaration context \ overload - no codegen impact
		if languageVersion >= ScriptTargetES2015 || !hasRestParameter(node) || node.flags&NodeFlagsAmbient || nodeIsMissing((node /* as FunctionLikeDeclaration */).body) {
			return
		}
		forEach(node.parameters, func(p ParameterDeclaration) {
			if p.name && !isBindingPattern(p.name) && p.name.escapedText == argumentsSymbol.escapedName {
				errorSkippedOn("noEmit", p, Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters)
			}
		})
	}
	/**
	 * Checks whether an {@link Identifier}, in the context of another {@link Node}, would collide with a runtime value
	 * of {@link name} in an outer scope. This is used to check for collisions for downlevel transformations that
	 * require names like `Object`, `Promise`, `Reflect`, `require`, `exports`, etc.
	 */
	needCollisionCheckForIdentifier := func(node Node, identifier *Identifier, name string) bool {
		if identifier. /* TODO(TS-TO-GO): was ? */ escapedText != name {
			return false
		}
		if node.kind == SyntaxKindPropertyDeclaration || node.kind == SyntaxKindPropertySignature || node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature || node.kind == SyntaxKindGetAccessor || node.kind == SyntaxKindSetAccessor || node.kind == SyntaxKindPropertyAssignment {
			// it is ok to have member named '_super', '_this', `Promise`, etc. - member access is always qualified
			return false
		}
		if node.flags & NodeFlagsAmbient {
			// ambient context - no codegen impact
			return false
		}
		if isImportClause(node) || isImportEqualsDeclaration(node) || isImportSpecifier(node) {
			// type-only imports do not require collision checks against runtime values.
			if isTypeOnlyImportOrExportDeclaration(node) {
				return false
			}
		}
		root := getRootDeclaration(node)
		if isParameter(root) && nodeIsMissing((root.parent /* as FunctionLikeDeclaration */).body) {
			// just an overload - no codegen impact
			return false
		}
		return true
	}
	// this function will run after checking the source file so 'CaptureThis' is correct for all nodes
	checkIfThisIsCapturedInEnclosingScope := func(node Node) {
		findAncestor(node, func(current Node) bool {
			if getNodeCheckFlags(current) & NodeCheckFlagsCaptureThis {
				isDeclaration := node.kind != SyntaxKindIdentifier
				if isDeclaration {
					error(getNameOfDeclaration(node /* as Declaration */), Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference)
				} else {
					error(node, Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference)
				}
				return true
			}
			return false
		})
	}
	checkIfNewTargetIsCapturedInEnclosingScope := func(node Node) {
		findAncestor(node, func(current Node) bool {
			if getNodeCheckFlags(current) & NodeCheckFlagsCaptureNewTarget {
				isDeclaration := node.kind != SyntaxKindIdentifier
				if isDeclaration {
					error(getNameOfDeclaration(node /* as Declaration */), Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference)
				} else {
					error(node, Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference)
				}
				return true
			}
			return false
		})
	}
	checkCollisionWithRequireExportsInGeneratedCode := func(node Node, name *Identifier) {
		// No need to check for require or exports for ES6 modules and later
		if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) >= ModuleKindES2015 {
			return
		}
		if !name || !needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports") {
			return
		}
		// Uninstantiated modules shouldnt do this check
		if isModuleDeclaration(node) && getModuleInstanceState(node) != ModuleInstanceStateInstantiated {
			return
		}
		// In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
		parent := getDeclarationContainer(node)
		if parent.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(parent /* as SourceFile */) {
			// If the declaration happens to be in external module, report error that require and exports are reserved keywords
			errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, declarationNameToString(name), declarationNameToString(name))
		}
	}
	checkCollisionWithGlobalPromiseInGeneratedCode := func(node Node, name *Identifier) {
		if !name || languageVersion >= ScriptTargetES2017 || !needCollisionCheckForIdentifier(node, name, "Promise") {
			return
		}
		// Uninstantiated modules shouldnt do this check
		if isModuleDeclaration(node) && getModuleInstanceState(node) != ModuleInstanceStateInstantiated {
			return
		}
		// In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
		parent := getDeclarationContainer(node)
		if parent.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(parent /* as SourceFile */) && parent.flags&NodeFlagsHasAsyncFunctions {
			// If the declaration happens to be in external module, report error that Promise is a reserved identifier.
			errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions, declarationNameToString(name), declarationNameToString(name))
		}
	}
	recordPotentialCollisionWithWeakMapSetInGeneratedCode := func(node Node, name Identifier) {
		if languageVersion <= ScriptTargetES2021 && (needCollisionCheckForIdentifier(node, name, "WeakMap") || needCollisionCheckForIdentifier(node, name, "WeakSet")) {
			potentialWeakMapSetCollisions.push(node)
		}
	}
	checkWeakMapSetCollision := func(node Node) {
		enclosingBlockScope := getEnclosingBlockScopeContainer(node)
		if getNodeCheckFlags(enclosingBlockScope) & NodeCheckFlagsContainsClassWithPrivateIdentifiers {
			Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name) && /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.name.escapedText */ TODO == "string", "The target of a WeakMap/WeakSet collision check should be an identifier")
			errorSkippedOn("noEmit", node, Diagnostics.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel, node.name.escapedText)
		}
	}
	recordPotentialCollisionWithReflectInGeneratedCode := func(node Node, name *Identifier) {
		if name && languageVersion >= ScriptTargetES2015 && languageVersion <= ScriptTargetES2021 && needCollisionCheckForIdentifier(node, name, "Reflect") {
			potentialReflectCollisions.push(node)
		}
	}
	checkReflectCollision := func(node Node) {
		hasCollision := false
		if isClassExpression(node) {
			// ClassExpression names don't contribute to their containers, but do matter for any of their block-scoped members.
			for _, member := range node.members {
				if getNodeCheckFlags(member) & NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
					hasCollision = true
					break
				}
			}
		} else if isFunctionExpression(node) {
			// FunctionExpression names don't contribute to their containers, but do matter for their contents
			if getNodeCheckFlags(node) & NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
				hasCollision = true
			}
		} else {
			container := getEnclosingBlockScopeContainer(node)
			if container && getNodeCheckFlags(container)&NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
				hasCollision = true
			}
		}
		if hasCollision {
			Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name), "The target of a Reflect collision check should be an identifier")
			errorSkippedOn("noEmit", node, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers, declarationNameToString(node.name), "Reflect")
		}
	}
	checkCollisionsForDeclarationName := func(node Node, name *Identifier) {
		if !name {
			return
		}
		checkCollisionWithRequireExportsInGeneratedCode(node, name)
		checkCollisionWithGlobalPromiseInGeneratedCode(node, name)
		recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name)
		recordPotentialCollisionWithReflectInGeneratedCode(node, name)
		if isClassLike(node) {
			checkTypeNameIsReserved(name, Diagnostics.Class_name_cannot_be_0)
			if !(node.flags & NodeFlagsAmbient) {
				checkClassNameCollisionWithObject(name)
			}
		} else if isEnumDeclaration(node) {
			checkTypeNameIsReserved(name, Diagnostics.Enum_name_cannot_be_0)
		}
	}
	checkVarDeclaredNamesNotShadowed := func(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | BindingElement */ any) undefined {
		// - ScriptBody : StatementList
		// It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
		// also occurs in the VarDeclaredNames of StatementList.
		// - Block : { StatementList }
		// It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
		// also occurs in the VarDeclaredNames of StatementList.
		// Variable declarations are hoisted to the top of their function scope. They can shadow
		// block scoped declarations, which bind tighter. this will not be flagged as duplicate definition
		// by the binder as the declaration scope is different.
		// A non-initialized declaration is a no-op as the block declaration will resolve before the var
		// declaration. the problem is if the declaration has an initializer. this will act as a write to the
		// block declared value. this is fine for let, but not const.
		// Only consider declarations with initializers, uninitialized const declarations will not
		// step on a let/const variable.
		// Do not consider const and const declarations, as duplicate block-scoped declarations
		// are handled by the binder.
		// We are only looking for const declarations that step on let\const declarations from a
		// different scope. e.g.:
		//      {
		//          const x = 0; // localDeclarationSymbol obtained after name resolution will correspond to this declaration
		//          const x = 0; // symbol for this declaration will be 'symbol'
		//      }
		// skip block-scoped variables and parameters
		if (getCombinedNodeFlagsCached(node)&NodeFlagsBlockScoped) != 0 || isPartOfParameterDeclaration(node) {
			return
		}
		// NOTE: in ES6 spec initializer is required in variable declarations where name is binding pattern
		// so we'll always treat binding elements as initialized
		symbol := getSymbolOfDeclaration(node)
		if symbol.flags & SymbolFlagsFunctionScopedVariable {
			if !isIdentifier(node.name) {
				return Debug.fail()
			}
			localDeclarationSymbol := resolveName(node, node.name.escapedText, SymbolFlagsVariable /*nameNotFoundMessage*/, nil /*isUse*/, false)
			if localDeclarationSymbol && localDeclarationSymbol != symbol && localDeclarationSymbol.flags&SymbolFlagsBlockScopedVariable {
				if getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & NodeFlagsBlockScoped {
					varDeclList := getAncestor(localDeclarationSymbol.valueDeclaration, SyntaxKindVariableDeclarationList)
					var container Node
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case varDeclList.parent.kind == SyntaxKindVariableStatement && varDeclList.parent.parent:
						container = varDeclList.parent.parent
					default:
						container = nil
					}
					// names of block-scoped and function scoped variables can collide only
					// if block scoped variable is defined in the function\module\source file scope (because of variable hoisting)
					namesShareScope := container && (container.kind == SyntaxKindBlock && isFunctionLike(container.parent) || container.kind == SyntaxKindModuleBlock || container.kind == SyntaxKindModuleDeclaration || container.kind == SyntaxKindSourceFile)
					// here we know that function scoped variable is "shadowed" by block scoped one
					// a var declatation can't hoist past a lexical declaration and it results in a SyntaxError at runtime
					if !namesShareScope {
						name := symbolToString(localDeclarationSymbol)
						error(node, Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name)
					}
				}
			}
		}
	}
	convertAutoToAny := func(type_ Type) Type {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_ == autoType:
			return anyType
		case type_ == autoArrayType:
			return anyArrayType
		default:
			return type_
		}
	}
	// Check variable, parameter, or property declaration
	checkVariableLikeDeclaration := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement */ any) {
		checkDecorators(node)
		if !isBindingElement(node) {
			checkSourceElement(node.type_)
		}
		// JSDoc `function(string, string): string` syntax results in parameters with no name
		if !node.name {
			return
		}
		// For a computed property, just check the initializer and exit
		// Do not use hasDynamicName here, because that returns false for well known symbols.
		// We want to perform checkComputedPropertyName for all computed properties, including
		// well known symbols.
		if node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
			if hasOnlyExpressionInitializer(node) && node.initializer {
				checkExpressionCached(node.initializer)
			}
		}
		if isBindingElement(node) {
			if node.propertyName && isIdentifier(node.name) && isPartOfParameterDeclaration(node) && nodeIsMissing((getContainingFunction(node) /* as FunctionLikeDeclaration */).body) {
				// type F = ({a: string}) => void;
				//               ^^^^^^
				// variable renaming in function type notation is confusing,
				// so we forbid it even if noUnusedLocals is not enabled
				potentialUnusedRenamedBindingElementsInTypes.push(node)
				return
			}
			if isObjectBindingPattern(node.parent) && node.dotDotDotToken && languageVersion < LanguageFeatureMinimumTargetObjectSpreadRest {
				checkExternalEmitHelpers(node, ExternalEmitHelpersRest)
			}
			// check computed properties inside property names of binding elements
			if node.propertyName && node.propertyName.kind == SyntaxKindComputedPropertyName {
				checkComputedPropertyName(node.propertyName)
			}
			// check private/protected variable access
			parent := node.parent.parent
			var parentCheckMode /* TODO(TS-TO-GO) inferred type CheckMode.Normal | CheckMode.RestBindingElement */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node.dotDotDotToken:
				parentCheckMode = CheckModeRestBindingElement
			default:
				parentCheckMode = CheckModeNormal
			}
			parentType := getTypeForBindingElementParent(parent, parentCheckMode)
			name := node.propertyName || node.name
			if parentType && !isBindingPattern(name) {
				exprType := getLiteralTypeFromPropertyName(name)
				if isTypeUsableAsPropertyName(exprType) {
					nameText := getPropertyNameFromType(exprType)
					property := getPropertyOfType(parentType, nameText)
					if property {
						markPropertyAsReferenced(property /*nodeForCheckWriteOnly*/, nil /*isSelfTypeAccess*/, false)
						// A destructuring is never a write-only reference.
						checkPropertyAccessibility(node, !!parent.initializer && parent.initializer.kind == SyntaxKindSuperKeyword /*writing*/, false, parentType, property)
					}
				}
			}
		}
		// For a binding pattern, check contained binding elements
		if isBindingPattern(node.name) {
			if node.name.kind == SyntaxKindArrayBindingPattern && languageVersion < LanguageFeatureMinimumTargetBindingPatterns && compilerOptions.downlevelIteration {
				checkExternalEmitHelpers(node, ExternalEmitHelpersRead)
			}
			forEach(node.name.elements, checkSourceElement)
		}
		// For a parameter declaration with an initializer, error and exit if the containing function doesn't have a body
		if node.initializer && isPartOfParameterDeclaration(node) && nodeIsMissing((getContainingFunction(node) /* as FunctionLikeDeclaration */).body) {
			error(node, Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation)
			return
		}
		// For a binding pattern, validate the initializer and exit
		if isBindingPattern(node.name) {
			if isInAmbientOrTypeNode(node) {
				return
			}
			needCheckInitializer := hasOnlyExpressionInitializer(node) && node.initializer && node.parent.parent.kind != SyntaxKindForInStatement
			needCheckWidenedType := !some(node.name.elements, not(isOmittedExpression))
			if needCheckInitializer || needCheckWidenedType {
				// Don't validate for-in initializer as it is already an error
				widenedType := getWidenedTypeForVariableLikeDeclaration(node)
				if needCheckInitializer {
					initializerType := checkExpressionCached(node.initializer)
					if strictNullChecks && needCheckWidenedType {
						checkNonNullNonVoidType(initializerType, node)
					} else {
						checkTypeAssignableToAndOptionallyElaborate(initializerType, getWidenedTypeForVariableLikeDeclaration(node), node, node.initializer)
					}
				}
				// check the binding pattern with empty elements
				if needCheckWidenedType {
					if isArrayBindingPattern(node.name) {
						checkIteratedTypeOrElementType(IterationUseDestructuring, widenedType, undefinedType, node)
					} else if strictNullChecks {
						checkNonNullNonVoidType(widenedType, node)
					}
				}
			}
			return
		}
		// For a commonjs `const x = require`, validate the alias and exit
		symbol := getSymbolOfDeclaration(node)
		if symbol.flags&SymbolFlagsAlias && (isVariableDeclarationInitializedToBareOrAccessedRequire(node) || isBindingElementOfBareOrAccessedRequire(node)) {
			checkAliasSymbol(node)
			return
		}
		if node.name.kind == SyntaxKindBigIntLiteral {
			error(node.name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name)
		}
		type_ := convertAutoToAny(getTypeOfSymbol(symbol))
		if node == symbol.valueDeclaration {
			// Node is the primary declaration of the symbol, just validate the initializer
			// Don't validate for-in initializer as it is already an error
			initializer := hasOnlyExpressionInitializer(node) && getEffectiveInitializer(node)
			if initializer {
				isJSObjectLiteralInitializer := isInJSFile(node) && isObjectLiteralExpression(initializer) && (initializer.properties.length == 0 || isPrototypeAccess(node.name)) && !!symbol.exports. /* TODO(TS-TO-GO): was ? */ size
				if !isJSObjectLiteralInitializer && node.parent.parent.kind != SyntaxKindForInStatement {
					initializerType := checkExpressionCached(initializer)
					checkTypeAssignableToAndOptionallyElaborate(initializerType, type_, node, initializer /*headMessage*/, nil)
					blockScopeKind := getCombinedNodeFlagsCached(node) & NodeFlagsBlockScoped
					if blockScopeKind == NodeFlagsAwaitUsing {
						globalAsyncDisposableType := getGlobalAsyncDisposableType(true)
						globalDisposableType := getGlobalDisposableType(true)
						if globalAsyncDisposableType != emptyObjectType && globalDisposableType != emptyObjectType {
							optionalDisposableType := getUnionType([] /* TODO(TS-TO-GO) inferred type IntrinsicType | ObjectType */ any{globalAsyncDisposableType, globalDisposableType, nullType, undefinedType})
							checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_Symbol_dispose_method_or_be_null_or_undefined)
						}
					} else if blockScopeKind == NodeFlagsUsing {
						globalDisposableType := getGlobalDisposableType(true)
						if globalDisposableType != emptyObjectType {
							optionalDisposableType := getUnionType([] /* TODO(TS-TO-GO) inferred type IntrinsicType | ObjectType */ any{globalDisposableType, nullType, undefinedType})
							checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_a_using_declaration_must_be_either_an_object_with_a_Symbol_dispose_method_or_be_null_or_undefined)
						}
					}
				}
			}
			if symbol.declarations && symbol.declarations.length > 1 {
				if some(symbol.declarations, func(d Declaration) bool {
					return d != node && isVariableLike(d) && !areDeclarationFlagsIdentical(d, node)
				}) {
					error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name))
				}
			}
		} else {
			// Node is a secondary declaration, check that type is identical to primary declaration and check that
			// initializer is consistent with type associated with the node
			declarationType := convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node))
			if !isErrorType(type_) && !isErrorType(declarationType) && !isTypeIdenticalTo(type_, declarationType) && !(symbol.flags & SymbolFlagsAssignment) {
				errorNextVariableOrPropertyDeclarationMustHaveSameType(symbol.valueDeclaration, type_, node, declarationType)
			}
			if hasOnlyExpressionInitializer(node) && node.initializer {
				checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(node.initializer), declarationType, node, node.initializer /*headMessage*/, nil)
			}
			if symbol.valueDeclaration && !areDeclarationFlagsIdentical(node, symbol.valueDeclaration) {
				error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name))
			}
		}
		if node.kind != SyntaxKindPropertyDeclaration && node.kind != SyntaxKindPropertySignature {
			// We know we don't have a binding pattern or computed name here
			checkExportsOnMergedDeclarations(node)
			if node.kind == SyntaxKindVariableDeclaration || node.kind == SyntaxKindBindingElement {
				checkVarDeclaredNamesNotShadowed(node)
			}
			checkCollisionsForDeclarationName(node, node.name)
		}
	}
	errorNextVariableOrPropertyDeclarationMustHaveSameType := func(firstDeclaration Declaration, firstType Type, nextDeclaration Declaration, nextType Type) {
		nextDeclarationName := getNameOfDeclaration(nextDeclaration)
		var message DiagnosticMessage
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case nextDeclaration.kind == SyntaxKindPropertyDeclaration || nextDeclaration.kind == SyntaxKindPropertySignature:
			message = Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2
		default:
			message = Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2
		}
		declName := declarationNameToString(nextDeclarationName)
		err := error(nextDeclarationName, message, declName, typeToString(firstType), typeToString(nextType))
		if firstDeclaration {
			addRelatedInfo(err, createDiagnosticForNode(firstDeclaration, Diagnostics._0_was_also_declared_here, declName))
		}
	}
	areDeclarationFlagsIdentical := func(left Declaration, right Declaration) bool {
		if (left.kind == SyntaxKindParameter && right.kind == SyntaxKindVariableDeclaration) || (left.kind == SyntaxKindVariableDeclaration && right.kind == SyntaxKindParameter) {
			// Differences in optionality between parameters and variables are allowed.
			return true
		}
		if hasQuestionToken(left) != hasQuestionToken(right) {
			return false
		}
		interestingFlags := ModifierFlagsPrivate | ModifierFlagsProtected | ModifierFlagsAsync | ModifierFlagsAbstract | ModifierFlagsReadonly | ModifierFlagsStatic
		return getSelectedEffectiveModifierFlags(left, interestingFlags) == getSelectedEffectiveModifierFlags(right, interestingFlags)
	}
	checkVariableDeclaration := func(node VariableDeclaration) {
		tracing. /* TODO(TS-TO-GO): was ? */ push(tracing.Phase.Check, "checkVariableDeclaration", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"kind": node.kind,
			"pos":  node.pos,
			"end":  node.end,
			"path": (node /* as TracingNode */).tracingPath,
		})
		checkGrammarVariableDeclaration(node)
		checkVariableLikeDeclaration(node)
		tracing. /* TODO(TS-TO-GO): was ? */ pop()
	}
	checkBindingElement := func(node BindingElement) {
		checkGrammarBindingElement(node)
		return checkVariableLikeDeclaration(node)
	}
	checkVariableDeclarationList := func(node VariableDeclarationList) {
		blockScopeKind := getCombinedNodeFlags(node) & NodeFlagsBlockScoped
		if (blockScopeKind == NodeFlagsUsing || blockScopeKind == NodeFlagsAwaitUsing) && languageVersion < LanguageFeatureMinimumTargetUsingAndAwaitUsing {
			checkExternalEmitHelpers(node, ExternalEmitHelpersAddDisposableResourceAndDisposeResources)
		}
		forEach(node.declarations, checkSourceElement)
	}
	checkVariableStatement := func(node VariableStatement) {
		// Grammar checking
		if !checkGrammarModifiers(node) && !checkGrammarVariableDeclarationList(node.declarationList) {
			checkGrammarForDisallowedBlockScopedVariableStatement(node)
		}
		checkVariableDeclarationList(node.declarationList)
	}
	checkExpressionStatement := func(node ExpressionStatement) {
		// Grammar checking
		checkGrammarStatementInAmbientContext(node)
		checkExpression(node.expression)
	}
	checkIfStatement := func(node IfStatement) {
		// Grammar checking
		checkGrammarStatementInAmbientContext(node)
		type_ := checkTruthinessExpression(node.expression)
		checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.expression, type_, node.thenStatement)
		checkSourceElement(node.thenStatement)
		if node.thenStatement.kind == SyntaxKindEmptyStatement {
			error(node.thenStatement, Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement)
		}
		checkSourceElement(node.elseStatement)
	}
	checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType := func(condExpr Expression, condType Type, body /* TODO(TS-TO-GO) TypeNode UnionType: Statement | Expression */ any) {
		if !strictNullChecks {
			return
		}
		bothHelper(condExpr, body)
		bothHelper := func(condExpr Expression, body /* TODO(TS-TO-GO) TypeNode UnionType: Expression | Statement | undefined */ any) {
			condExpr = skipParentheses(condExpr)
			helper(condExpr, body)
			for isBinaryExpression(condExpr) && (condExpr.operatorToken.kind == SyntaxKindBarBarToken || condExpr.operatorToken.kind == SyntaxKindQuestionQuestionToken) {
				condExpr = skipParentheses(condExpr.left)
				helper(condExpr, body)
			}
		}
		helper := func(condExpr Expression, body /* TODO(TS-TO-GO) TypeNode UnionType: Expression | Statement | undefined */ any) {
			var location Expression
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isLogicalOrCoalescingBinaryExpression(condExpr):
				location = skipParentheses(condExpr.right)
			default:
				location = condExpr
			}
			if isModuleExportsAccessExpression(location) {
				return
			}
			if isLogicalOrCoalescingBinaryExpression(location) {
				bothHelper(location, body)
				return
			}
			var type_ Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case location == condExpr:
				type_ = condType
			default:
				type_ = checkExpression(location)
			}
			if type_.flags&TypeFlagsEnumLiteral && isPropertyAccessExpression(location) && ( /* TODO(TS-TO-GO) Node BinaryExpression: getNodeLinks(location.expression).resolvedSymbol ?? unknownSymbol */ TODO).flags&SymbolFlagsEnum {
				// EnumLiteral type at condition with known value is always truthy or always falsy, likely an error
				error(location, Diagnostics.This_condition_will_always_return_0, __COND__(!!(type_ /* as LiteralType */).value, "true", "false"))
				return
			}
			isPropertyExpressionCast := isPropertyAccessExpression(location) && isTypeAssertion(location.expression)
			if !hasTypeFacts(type_, TypeFactsTruthy) || isPropertyExpressionCast {
				return
			}
			// While it technically should be invalid for any known-truthy value
			// to be tested, we de-scope to functions and Promises unreferenced in
			// the block as a heuristic to identify the most common bugs. There
			// are too many false positives for values sourced from type
			// definitions without strictNullChecks otherwise.
			callSignatures := getSignaturesOfType(type_, SignatureKindCall)
			isPromise := !!getAwaitedTypeOfPromise(type_)
			if callSignatures.length == 0 && !isPromise {
				return
			}
			var testedNode *MemberName
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isIdentifier(location):
				testedNode = location
			case isPropertyAccessExpression(location):
				testedNode = location.name
			default:
				testedNode = nil
			}
			testedSymbol := testedNode && getSymbolAtLocation(testedNode)
			if !testedSymbol && !isPromise {
				return
			}
			isUsed := testedSymbol && isBinaryExpression(condExpr.parent) && isSymbolUsedInBinaryExpressionChain(condExpr.parent, testedSymbol) || testedSymbol && body && isSymbolUsedInConditionBody(condExpr, body, testedNode, testedSymbol)
			if !isUsed {
				if isPromise {
					errorAndMaybeSuggestAwait(location, true, Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined, getTypeNameForErrorDisplay(type_))
				} else {
					error(location, Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead)
				}
			}
		}
	}
	isSymbolUsedInConditionBody := func(expr Expression, body /* TODO(TS-TO-GO) TypeNode UnionType: Statement | Expression */ any, testedNode Node, testedSymbol Symbol) bool {
		return !!forEachChild(body, func /* check */ (childNode Node) *bool {
			if isIdentifier(childNode) {
				childSymbol := getSymbolAtLocation(childNode)
				if childSymbol && childSymbol == testedSymbol {
					// If the test was a simple identifier, the above check is sufficient
					if isIdentifier(expr) || isIdentifier(testedNode) && isBinaryExpression(testedNode.parent) {
						return true
					}
					// Otherwise we need to ensure the symbol is called on the same target
					testedExpression := testedNode.parent
					childExpression := childNode.parent
					for testedExpression && childExpression {
						if isIdentifier(testedExpression) && isIdentifier(childExpression) || testedExpression.kind == SyntaxKindThisKeyword && childExpression.kind == SyntaxKindThisKeyword {
							return getSymbolAtLocation(testedExpression) == getSymbolAtLocation(childExpression)
						} else if isPropertyAccessExpression(testedExpression) && isPropertyAccessExpression(childExpression) {
							if getSymbolAtLocation(testedExpression.name) != getSymbolAtLocation(childExpression.name) {
								return false
							}
							childExpression = childExpression.expression
							testedExpression = testedExpression.expression
						} else if isCallExpression(testedExpression) && isCallExpression(childExpression) {
							childExpression = childExpression.expression
							testedExpression = testedExpression.expression
						} else {
							return false
						}
					}
				}
			}
			return forEachChild(childNode, check)
		})
	}
	isSymbolUsedInBinaryExpressionChain := func(node Node, testedSymbol Symbol) bool {
		for isBinaryExpression(node) && node.operatorToken.kind == SyntaxKindAmpersandAmpersandToken {
			isUsed := forEachChild(node.right, func /* visit */ (child Node) *bool {
				if isIdentifier(child) {
					symbol := getSymbolAtLocation(child)
					if symbol && symbol == testedSymbol {
						return true
					}
				}
				return forEachChild(child, visit)
			})
			if isUsed {
				return true
			}
			node = node.parent
		}
		return false
	}
	checkDoStatement := func(node DoStatement) {
		// Grammar checking
		checkGrammarStatementInAmbientContext(node)
		checkSourceElement(node.statement)
		checkTruthinessExpression(node.expression)
	}
	checkWhileStatement := func(node WhileStatement) {
		// Grammar checking
		checkGrammarStatementInAmbientContext(node)
		checkTruthinessExpression(node.expression)
		checkSourceElement(node.statement)
	}
	checkTruthinessOfType := func(type_ Type, node Node) Type {
		if type_.flags & TypeFlagsVoid {
			error(node, Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness)
		} else {
			semantics := getSyntacticTruthySemantics(node)
			if semantics != PredicateSemanticsSometimes {
				error(node, __COND__(semantics == PredicateSemanticsAlways, Diagnostics.This_kind_of_expression_is_always_truthy, Diagnostics.This_kind_of_expression_is_always_falsy))
			}
		}
		return type_
	}
	getSyntacticTruthySemantics := func(node Node) PredicateSemantics {
		node = skipOuterExpressions(node)
		switch node.kind {
		case SyntaxKindNumericLiteral:
			if (node /* as NumericLiteral */).text == "0" || (node /* as NumericLiteral */).text == "1" {
				return PredicateSemanticsSometimes
			}
			return PredicateSemanticsAlways
		case SyntaxKindArrayLiteralExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBigIntLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindClassExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJsxElement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJsxSelfClosingElement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindObjectLiteralExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindRegularExpressionLiteral:
			return PredicateSemanticsAlways
		case SyntaxKindVoidExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNullKeyword:
			return PredicateSemanticsNever
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindStringLiteral:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case !!(node /* as StringLiteral | NoSubstitutionTemplateLiteral */).text:
				return PredicateSemanticsAlways
			default:
				return PredicateSemanticsNever
			}
		case SyntaxKindConditionalExpression:
			return getSyntacticTruthySemantics((node /* as ConditionalExpression */).whenTrue) | getSyntacticTruthySemantics((node /* as ConditionalExpression */).whenFalse)
		case SyntaxKindIdentifier:
			if getResolvedSymbol(node /* as Identifier */) == undefinedSymbol {
				return PredicateSemanticsNever
			}
			return PredicateSemanticsSometimes
		}
		return PredicateSemanticsSometimes
	}
	checkTruthinessExpression := func(node Expression, checkMode CheckMode) Type {
		return checkTruthinessOfType(checkExpression(node, checkMode), node)
	}
	checkForStatement := func(node ForStatement) {
		// Grammar checking
		if !checkGrammarStatementInAmbientContext(node) {
			if node.initializer && node.initializer.kind == SyntaxKindVariableDeclarationList {
				checkGrammarVariableDeclarationList(node.initializer /* as VariableDeclarationList */)
			}
		}
		if node.initializer {
			if node.initializer.kind == SyntaxKindVariableDeclarationList {
				checkVariableDeclarationList(node.initializer /* as VariableDeclarationList */)
			} else {
				checkExpression(node.initializer)
			}
		}
		if node.condition {
			checkTruthinessExpression(node.condition)
		}
		if node.incrementor {
			checkExpression(node.incrementor)
		}
		checkSourceElement(node.statement)
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkForOfStatement := func(node ForOfStatement) {
		checkGrammarForInOrForOfStatement(node)
		container := getContainingFunctionOrClassStaticBlock(node)
		if node.awaitModifier {
			if container && isClassStaticBlockDeclaration(container) {
				grammarErrorOnNode(node.awaitModifier, Diagnostics.for_await_loops_cannot_be_used_inside_a_class_static_block)
			} else {
				functionFlags := getFunctionFlags(container)
				if (functionFlags&(FunctionFlagsInvalid|FunctionFlagsAsync)) == FunctionFlagsAsync && languageVersion < LanguageFeatureMinimumTargetForAwaitOf {
					// for..await..of in an async function or async generator function prior to ESNext requires the __asyncValues helper
					checkExternalEmitHelpers(node, ExternalEmitHelpersForAwaitOfIncludes)
				}
			}
		} else if compilerOptions.downlevelIteration && languageVersion < LanguageFeatureMinimumTargetForOf {
			// for..of prior to ES2015 requires the __values helper when downlevelIteration is enabled
			checkExternalEmitHelpers(node, ExternalEmitHelpersForOfIncludes)
		}
		// Check the LHS and RHS
		// If the LHS is a declaration, just check it as a variable declaration, which will in turn check the RHS
		// via checkRightHandSideOfForOf.
		// If the LHS is an expression, check the LHS, as a destructuring assignment or as a reference.
		// Then check that the RHS is assignable to it.
		if node.initializer.kind == SyntaxKindVariableDeclarationList {
			checkVariableDeclarationList(node.initializer /* as VariableDeclarationList */)
		} else {
			varExpr := node.initializer
			iteratedType := checkRightHandSideOfForOf(node)
			// There may be a destructuring assignment on the left side
			if varExpr.kind == SyntaxKindArrayLiteralExpression || varExpr.kind == SyntaxKindObjectLiteralExpression {
				// iteratedType may be undefined. In this case, we still want to check the structure of
				// varExpr, in particular making sure it's a valid LeftHandSideExpression. But we'd like
				// to short circuit the type relation checking as much as possible, so we pass the unknownType.
				checkDestructuringAssignment(varExpr, iteratedType || errorType)
			} else {
				leftType := checkExpression(varExpr)
				checkReferenceExpression(varExpr, Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access)
				// iteratedType will be undefined if the rightType was missing properties/signatures
				// required to get its iteratedType (like [Symbol.iterator] or next). This may be
				// because we accessed properties from anyType, or it may have led to an error inside
				// getElementTypeOfIterable.
				if iteratedType {
					checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr, node.expression)
				}
			}
		}
		checkSourceElement(node.statement)
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkForInStatement := func(node ForInStatement) {
		// Grammar checking
		checkGrammarForInOrForOfStatement(node)
		rightType := getNonNullableTypeIfNeeded(checkExpression(node.expression))
		// TypeScript 1.0 spec (April 2014): 5.4
		// In a 'for-in' statement of the form
		// for (let VarDecl in Expr) Statement
		//   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,
		//   and Expr must be an expression of type Any, an object type, or a type parameter type.
		if node.initializer.kind == SyntaxKindVariableDeclarationList {
			variable := (node.initializer /* as VariableDeclarationList */).declarations[0]
			if variable && isBindingPattern(variable.name) {
				error(variable.name, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern)
			}
			checkVariableDeclarationList(node.initializer /* as VariableDeclarationList */)
		} else {
			// In a 'for-in' statement of the form
			// for (Var in Expr) Statement
			//   Var must be an expression classified as a reference of type Any or the String primitive type,
			//   and Expr must be an expression of type Any, an object type, or a type parameter type.
			varExpr := node.initializer
			leftType := checkExpression(varExpr)
			if varExpr.kind == SyntaxKindArrayLiteralExpression || varExpr.kind == SyntaxKindObjectLiteralExpression {
				error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern)
			} else if !isTypeAssignableTo(getIndexTypeOrString(rightType), leftType) {
				error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any)
			} else {
				// run check only former check succeeded to avoid cascading errors
				checkReferenceExpression(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access)
			}
		}
		// unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved
		// in this case error about missing name is already reported - do not report extra one
		if rightType == neverType || !isTypeAssignableToKind(rightType, TypeFlagsNonPrimitive|TypeFlagsInstantiableNonPrimitive) {
			error(node.expression, Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0, typeToString(rightType))
		}
		checkSourceElement(node.statement)
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkRightHandSideOfForOf := func(statement ForOfStatement) Type {
		var use /* TODO(TS-TO-GO) inferred type IterationUse.ForOf | IterationUse.ForAwaitOf */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case statement.awaitModifier:
			use = IterationUseForAwaitOf
		default:
			use = IterationUseForOf
		}
		return checkIteratedTypeOrElementType(use, checkNonNullExpression(statement.expression), undefinedType, statement.expression)
	}
	checkIteratedTypeOrElementType := func(use IterationUse, inputType Type, sentType Type, errorNode Node) Type {
		if isTypeAny(inputType) {
			return inputType
		}
		return getIteratedTypeOrElementType(use, inputType, sentType, errorNode /*checkAssignability*/, true) || anyType
	}
	/**
	 * When consuming an iterable type in a for..of, spread, or iterator destructuring assignment
	 * we want to get the iterated type of an iterable for ES2015 or later, or the iterated type
	 * of a iterable (if defined globally) or element type of an array like for ES2015 or earlier.
	 */
	getIteratedTypeOrElementType := func(use IterationUse, inputType Type, sentType Type, errorNode Node, checkAssignability bool) Type {
		allowAsyncIterables := (use & IterationUseAllowsAsyncIterablesFlag) != 0
		if inputType == neverType {
			if errorNode {
				reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables)
			}
			return nil
		}
		uplevelIteration := languageVersion >= ScriptTargetES2015
		downlevelIteration := !uplevelIteration && compilerOptions.downlevelIteration
		possibleOutOfBounds := compilerOptions.noUncheckedIndexedAccess && !!(use & IterationUsePossiblyOutOfBounds)
		// Get the iterated type of an `Iterable<T>` or `IterableIterator<T>` only in ES2015
		// or higher, when inside of an async generator or for-await-if, or when
		// downlevelIteration is requested.
		if uplevelIteration || downlevelIteration || allowAsyncIterables {
			// We only report errors for an invalid iterable type in ES2015 or higher.
			iterationTypes := getIterationTypesOfIterable(inputType, use, __COND__(uplevelIteration, errorNode, nil))
			if checkAssignability {
				if iterationTypes {
					var diagnostic *DiagnosticMessage
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case use & IterationUseForOfFlag:
						diagnostic = Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0
					case use & IterationUseSpreadFlag:
						diagnostic = Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0
					case use & IterationUseDestructuringFlag:
						diagnostic = Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0
					case use & IterationUseYieldStarFlag:
						diagnostic = Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0
					default:
						diagnostic = nil
					}
					if diagnostic {
						checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic)
					}
				}
			}
			if iterationTypes || uplevelIteration {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case possibleOutOfBounds:
					return includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType)
				default:
					return (iterationTypes && iterationTypes.yieldType)
				}
			}
		}
		arrayType := inputType
		hasStringConstituent := false
		// If strings are permitted, remove any string-like constituents from the array type.
		// This allows us to find other non-string element types from an array unioned with
		// a string.
		if use & IterationUseAllowsStringInputFlag {
			if arrayType.flags & TypeFlagsUnion {
				// After we remove all types that are StringLike, we will know if there was a string constituent
				// based on whether the result of filter is a new array.
				arrayTypes := (inputType /* as UnionType */).types
				filteredTypes := filter(arrayTypes, func(t Type) bool {
					return !(t.flags & TypeFlagsStringLike)
				})
				if filteredTypes != arrayTypes {
					arrayType = getUnionType(filteredTypes, UnionReductionSubtype)
				}
			} else if arrayType.flags & TypeFlagsStringLike {
				arrayType = neverType
			}
			hasStringConstituent = arrayType != inputType
			if hasStringConstituent {
				// Now that we've removed all the StringLike types, if no constituents remain, then the entire
				// arrayOrStringType was a string.
				if arrayType.flags & TypeFlagsNever {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case possibleOutOfBounds:
						return includeUndefinedInIndexSignature(stringType)
					default:
						return stringType
					}
				}
			}
		}
		if !isArrayLikeType(arrayType) {
			if errorNode {
				// Which error we report depends on whether we allow strings or if there was a
				// string constituent. For example, if the input type is number | string, we
				// want to say that number is not an array type. But if the input was just
				// number and string input is allowed, we want to say that number is not an
				// array type or a string type.
				allowsStrings := !!(use & IterationUseAllowsStringInputFlag) && !hasStringConstituent
				TODO_IDENTIFIER := getIterationDiagnosticDetails(allowsStrings, downlevelIteration)
				errorAndMaybeSuggestAwait(errorNode, maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType), defaultDiagnostic, typeToString(arrayType))
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case hasStringConstituent:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case possibleOutOfBounds:
					return includeUndefinedInIndexSignature(stringType)
				default:
					return stringType
				}
			default:
				return nil
			}
		}
		arrayElementType := getIndexTypeOfType(arrayType, numberType)
		if hasStringConstituent && arrayElementType {
			// This is just an optimization for the case where arrayOrStringType is string | string[]
			if arrayElementType.flags&TypeFlagsStringLike && !compilerOptions.noUncheckedIndexedAccess {
				return stringType
			}
			return getUnionType(__COND__(possibleOutOfBounds, []Type{arrayElementType, stringType, undefinedType}, []Type{arrayElementType, stringType}), UnionReductionSubtype)
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case (use & IterationUsePossiblyOutOfBounds):
			return includeUndefinedInIndexSignature(arrayElementType)
		default:
			return arrayElementType
		}
		getIterationDiagnosticDetails := func(allowsStrings bool, downlevelIteration *bool) /* TODO(TS-TO-GO) TypeNode TupleType: [error: DiagnosticMessage, maybeMissingAwait: boolean] */ any {
			if downlevelIteration {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case allowsStrings:
					return []any{Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true}
				default:
					return []any{Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true}
				}
			}
			yieldType := getIterationTypeOfIterable(use, IterationTypeKindYield, inputType /*errorNode*/, nil)
			if yieldType {
				return []any{Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, false}
			}
			if isES2015OrLaterIterable(inputType.symbol. /* TODO(TS-TO-GO): was ? */ escapedName) {
				return []any{Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, true}
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case allowsStrings:
				return []any{Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true}
			default:
				return []any{Diagnostics.Type_0_is_not_an_array_type, true}
			}
		}
	}
	isES2015OrLaterIterable := func(n __String) bool {
		switch n {
		case "Float32Array":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Float64Array":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Int16Array":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Int32Array":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Int8Array":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "NodeList":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Uint16Array":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Uint32Array":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Uint8Array":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "Uint8ClampedArray":
			return true
		}
		return false
	}
	/**
	 * Gets the requested "iteration type" from an `Iterable`-like or `AsyncIterable`-like type.
	 */
	getIterationTypeOfIterable := func(use IterationUse, typeKind IterationTypeKind, inputType Type, errorNode Node) Type {
		if isTypeAny(inputType) {
			return nil
		}
		iterationTypes := getIterationTypesOfIterable(inputType, use, errorNode)
		return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(typeKind)]
	}
	createIterationTypes := func(yieldType Type /*  = neverType */, returnType Type /*  = neverType */, nextType Type /*  = unknownType */) IterationTypes {
		// `yieldType` and `returnType` are defaulted to `neverType` they each will be combined
		// via `getUnionType` when merging iteration types. `nextType` is defined as `unknownType`
		// as it is combined via `getIntersectionType` when merging iteration types.
		// Use the cache only for intrinsic types to keep it small as they are likely to be
		// more frequently created (i.e. `Iterator<number, void, unknown>`). Iteration types
		// are also cached on the type they are requested for, so we shouldn't need to maintain
		// the cache for less-frequently used types.
		if yieldType.flags&TypeFlagsIntrinsic && returnType.flags&(TypeFlagsAny|TypeFlagsNever|TypeFlagsUnknown|TypeFlagsVoid|TypeFlagsUndefined) && nextType.flags&(TypeFlagsAny|TypeFlagsNever|TypeFlagsUnknown|TypeFlagsVoid|TypeFlagsUndefined) {
			id := getTypeListId([]Type{yieldType, returnType, nextType})
			iterationTypes := iterationTypesCache.get(id)
			if !iterationTypes {
				iterationTypes = map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"yieldType":  yieldType,
					"returnType": returnType,
					"nextType":   nextType,
				}
				iterationTypesCache.set(id, iterationTypes)
			}
			return iterationTypes
		}
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"yieldType":  yieldType,
			"returnType": returnType,
			"nextType":   nextType,
		}
	}
	/**
	 * Combines multiple `IterationTypes` records.
	 *
	 * If `array` is empty or all elements are missing or are references to `noIterationTypes`,
	 * then `noIterationTypes` is returned. Otherwise, an `IterationTypes` record is returned
	 * for the combined iteration types.
	 */
	combineIterationTypes := func(array []*IterationTypes) IterationTypes {
		var yieldTypes *[]Type
		var returnTypes *[]Type
		var nextTypes *[]Type
		for _, iterationTypes := range array {
			if iterationTypes == nil || iterationTypes == noIterationTypes {
				continue
			}
			if iterationTypes == anyIterationTypes {
				return anyIterationTypes
			}
			yieldTypes = append(yieldTypes, iterationTypes.yieldType)
			returnTypes = append(returnTypes, iterationTypes.returnType)
			nextTypes = append(nextTypes, iterationTypes.nextType)
		}
		if yieldTypes || returnTypes || nextTypes {
			return createIterationTypes(yieldTypes && getUnionType(yieldTypes), returnTypes && getUnionType(returnTypes), nextTypes && getIntersectionType(nextTypes))
		}
		return noIterationTypes
	}
	getCachedIterationTypes := func(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes]) *IterationTypes {
		return (type_ /* as IterableOrIteratorType */)[cacheKey]
	}
	setCachedIterationTypes := func(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes], cachedTypes IterationTypes) IterationTypes {
		(type_ /* as IterableOrIteratorType */)[cacheKey] = cachedTypes
		return (type_ /* as IterableOrIteratorType */)[cacheKey]
	}
	/**
	 * Gets the *yield*, *return*, and *next* types from an `Iterable`-like or `AsyncIterable`-like type.
	 *
	 * At every level that involves analyzing return types of signatures, we union the return types of all the signatures.
	 *
	 * Another thing to note is that at any step of this process, we could run into a dead end,
	 * meaning either the property is missing, or we run into the anyType. If either of these things
	 * happens, we return `undefined` to signal that we could not find the iteration type. If a property
	 * is missing, and the previous step did not result in `any`, then we also give an error if the
	 * caller requested it. Then the caller can decide what to do in the case where there is no iterated
	 * type.
	 *
	 * For a **for-of** statement, `yield*` (in a normal generator), spread, array
	 * destructuring, or normal generator we will only ever look for a `[Symbol.iterator]()`
	 * method.
	 *
	 * For an async generator we will only ever look at the `[Symbol.asyncIterator]()` method.
	 *
	 * For a **for-await-of** statement or a `yield*` in an async generator we will look for
	 * the `[Symbol.asyncIterator]()` method first, and then the `[Symbol.iterator]()` method.
	 */
	getIterationTypesOfIterable := func(type_ Type, use IterationUse, errorNode Node) *IterationTypes {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		if !(type_.flags & TypeFlagsUnion) {
			var errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case errorNode:
				errorOutputContainer = map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"errors": nil,
				}
			default:
				errorOutputContainer = nil
			}
			iterationTypes := getIterationTypesOfIterableWorker(type_, use, errorNode, errorOutputContainer)
			if iterationTypes == noIterationTypes {
				if errorNode {
					rootDiag := reportTypeNotIterableError(errorNode, type_, !!(use & IterationUseAllowsAsyncIterablesFlag))
					if errorOutputContainer. /* TODO(TS-TO-GO): was ? */ errors {
						addRelatedInfo(rootDiag, errorOutputContainer.errors...)
					}
				}
				return nil
			} else if errorOutputContainer. /* TODO(TS-TO-GO): was ? */ errors. /* TODO(TS-TO-GO): was ? */ length {
				for _, diag := range errorOutputContainer.errors {
					diagnostics.add(diag)
				}
			}
			return iterationTypes
		}
		var cacheKey /* TODO(TS-TO-GO) inferred type "iterationTypesOfAsyncIterable" | "iterationTypesOfIterable" */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case use & IterationUseAllowsAsyncIterablesFlag:
			cacheKey = "iterationTypesOfAsyncIterable"
		default:
			cacheKey = "iterationTypesOfIterable"
		}
		cachedTypes := getCachedIterationTypes(type_, cacheKey)
		if cachedTypes {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case cachedTypes == noIterationTypes:
				return nil
			default:
				return cachedTypes
			}
		}
		var allIterationTypes *[]IterationTypes
		for _, constituent := range (type_ /* as UnionType */).types {
			var errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case errorNode:
				errorOutputContainer = map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"errors": nil,
				}
			default:
				errorOutputContainer = nil
			}
			iterationTypes := getIterationTypesOfIterableWorker(constituent, use, errorNode, errorOutputContainer)
			if iterationTypes == noIterationTypes {
				if errorNode {
					rootDiag := reportTypeNotIterableError(errorNode, type_, !!(use & IterationUseAllowsAsyncIterablesFlag))
					if errorOutputContainer. /* TODO(TS-TO-GO): was ? */ errors {
						addRelatedInfo(rootDiag, errorOutputContainer.errors...)
					}
				}
				setCachedIterationTypes(type_, cacheKey, noIterationTypes)
				return nil
			} else if errorOutputContainer. /* TODO(TS-TO-GO): was ? */ errors. /* TODO(TS-TO-GO): was ? */ length {
				for _, diag := range errorOutputContainer.errors {
					diagnostics.add(diag)
				}
			}
			allIterationTypes = append(allIterationTypes, iterationTypes)
		}
		var iterationTypes IterationTypes
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case allIterationTypes:
			iterationTypes = combineIterationTypes(allIterationTypes)
		default:
			iterationTypes = noIterationTypes
		}
		setCachedIterationTypes(type_, cacheKey, iterationTypes)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case iterationTypes == noIterationTypes:
			return nil
		default:
			return iterationTypes
		}
	}
	getAsyncFromSyncIterationTypes := func(iterationTypes IterationTypes, errorNode Node) IterationTypes {
		if iterationTypes == noIterationTypes {
			return noIterationTypes
		}
		if iterationTypes == anyIterationTypes {
			return anyIterationTypes
		}
		TODO_IDENTIFIER := iterationTypes
		// if we're requesting diagnostics, report errors for a missing `Awaited<T>`.
		if errorNode {
			getGlobalAwaitedSymbol(true)
		}
		return createIterationTypes(getAwaitedType(yieldType, errorNode) || anyType, getAwaitedType(returnType, errorNode) || anyType, nextType)
	}
	/**
	 * Gets the *yield*, *return*, and *next* types from a non-union type.
	 *
	 * If we are unable to find the *yield*, *return*, and *next* types, `noIterationTypes` is
	 * returned to indicate to the caller that it should report an error. Otherwise, an
	 * `IterationTypes` record is returned.
	 *
	 * NOTE: You probably don't want to call this directly and should be calling
	 * `getIterationTypesOfIterable` instead.
	 */
	getIterationTypesOfIterableWorker := func(type_ Type, use IterationUse, errorNode Node, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any) IterationTypes {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		// If we are reporting errors and encounter a cached `noIterationTypes`, we should ignore the cached value and continue as if nothing was cached.
		// In addition, we should not cache any new results for this call.
		noCache := false
		if use & IterationUseAllowsAsyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableCached(type_, asyncIterationTypesResolver) || getIterationTypesOfIterableFast(type_, asyncIterationTypesResolver)
			if iterationTypes {
				if iterationTypes == noIterationTypes && errorNode {
					// ignore the cached value
					noCache = true
				} else {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case use & IterationUseForOfFlag:
						return getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
					default:
						return iterationTypes
					}
				}
			}
		}
		if use & IterationUseAllowsSyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableCached(type_, syncIterationTypesResolver) || getIterationTypesOfIterableFast(type_, syncIterationTypesResolver)
			if iterationTypes {
				if iterationTypes == noIterationTypes && errorNode {
					// ignore the cached value
					noCache = true
				} else {
					if use & IterationUseAllowsAsyncIterablesFlag {
						// for a sync iterable in an async context, only use the cached types if they are valid.
						if iterationTypes != noIterationTypes {
							iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case noCache:
								return iterationTypes
							default:
								return setCachedIterationTypes(type_, "iterationTypesOfAsyncIterable", iterationTypes)
							}
						}
					} else {
						return iterationTypes
					}
				}
			}
		}
		if use & IterationUseAllowsAsyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableSlow(type_, asyncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
			if iterationTypes != noIterationTypes {
				return iterationTypes
			}
		}
		if use & IterationUseAllowsSyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableSlow(type_, syncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
			if iterationTypes != noIterationTypes {
				if use & IterationUseAllowsAsyncIterablesFlag {
					iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case noCache:
						return iterationTypes
					default:
						return setCachedIterationTypes(type_, "iterationTypesOfAsyncIterable", iterationTypes)
					}
				} else {
					return iterationTypes
				}
			}
		}
		return noIterationTypes
	}
	/**
	 * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or
	 * `AsyncIterable`-like type from the cache.
	 *
	 * NOTE: You probably don't want to call this directly and should be calling
	 * `getIterationTypesOfIterable` instead.
	 */
	getIterationTypesOfIterableCached := func(type_ Type, resolver IterationTypesResolver) *IterationTypes {
		return getCachedIterationTypes(type_, resolver.iterableCacheKey)
	}
	/**
	 * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or `AsyncIterable`-like
	 * type from from common heuristics.
	 *
	 * If we previously analyzed this type and found no iteration types, `noIterationTypes` is
	 * returned. If we found iteration types, an `IterationTypes` record is returned.
	 * Otherwise, we return `undefined` to indicate to the caller it should perform a more
	 * exhaustive analysis.
	 *
	 * NOTE: You probably don't want to call this directly and should be calling
	 * `getIterationTypesOfIterable` instead.
	 */
	getIterationTypesOfIterableFast := func(type_ Type, resolver IterationTypesResolver) *IterationTypes {
		// As an optimization, if the type is an instantiation of the following global type, then
		// just grab its related type arguments:
		// - `Iterable<T, TReturn, TNext>` or `AsyncIterable<T, TReturn, TNext>`
		// - `IteratorObject<T, TReturn, TNext>` or `AsyncIteratorObject<T, TReturn, TNext>`
		// - `IterableIterator<T, TReturn, TNext>` or `AsyncIterableIterator<T, TReturn, TNext>`
		// - `Generator<T, TReturn, TNext>` or `AsyncGenerator<T, TReturn, TNext>`
		if isReferenceToType(type_, resolver.getGlobalIterableType(false)) || isReferenceToType(type_, resolver.getGlobalIteratorObjectType(false)) || isReferenceToType(type_, resolver.getGlobalIterableIteratorType(false)) || isReferenceToType(type_, resolver.getGlobalGeneratorType(false)) {
			TODO_IDENTIFIER := getTypeArguments(type_ /* as GenericType */)
			return setCachedIterationTypes(type_, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType /*errorNode*/, nil) || yieldType, resolver.resolveIterationType(returnType /*errorNode*/, nil) || returnType, nextType))
		}
		// As an optimization, if the type is an instantiation of one of the following global types, then
		// just grab the related type argument:
		// - `ArrayIterator<T>`
		// - `MapIterator<T>`
		// - `SetIterator<T>`
		// - `StringIterator<T>`
		// - `ReadableStreamAsyncIterator<T>`
		if isReferenceToSomeType(type_, resolver.getGlobalBuiltinIteratorTypes()) {
			TODO_IDENTIFIER := getTypeArguments(type_ /* as GenericType */)
			returnType := getBuiltinIteratorReturnType()
			nextType := unknownType
			return setCachedIterationTypes(type_, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType /*errorNode*/, nil) || yieldType, resolver.resolveIterationType(returnType /*errorNode*/, nil) || returnType, nextType))
		}
	}
	getPropertyNameForKnownSymbolName := func(symbolName string) __String {
		ctorType := getGlobalESSymbolConstructorSymbol(false)
		uniqueType := ctorType && getTypeOfPropertyOfType(getTypeOfSymbol(ctorType), escapeLeadingUnderscores(symbolName))
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case uniqueType && isTypeUsableAsPropertyName(uniqueType):
			return getPropertyNameFromType(uniqueType)
		default:
			return __TEMPLATE__("__@", symbolName) /* as __String */
		}
	}
	/**
	 * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or `AsyncIterable`-like
	 * type from its members.
	 *
	 * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
	 * record is returned. Otherwise, `noIterationTypes` is returned.
	 *
	 * NOTE: You probably don't want to call this directly and should be calling
	 * `getIterationTypesOfIterable` instead.
	 */
	getIterationTypesOfIterableSlow := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any, noCache bool) IterationTypes {
		method := getPropertyOfType(type_, getPropertyNameForKnownSymbolName(resolver.iteratorSymbolName))
		var methodType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case method && !(method.flags & SymbolFlagsOptional):
			methodType = getTypeOfSymbol(method)
		default:
			methodType = nil
		}
		if isTypeAny(methodType) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case noCache:
				return anyIterationTypes
			default:
				return setCachedIterationTypes(type_, resolver.iterableCacheKey, anyIterationTypes)
			}
		}
		var signatures *[]Signature
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case methodType:
			signatures = getSignaturesOfType(methodType, SignatureKindCall)
		default:
			signatures = nil
		}
		if !some(signatures) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case noCache:
				return noIterationTypes
			default:
				return setCachedIterationTypes(type_, resolver.iterableCacheKey, noIterationTypes)
			}
		}
		iteratorType := getIntersectionType(map_(signatures, getReturnTypeOfSignature))
		iterationTypes := /* TODO(TS-TO-GO) Node BinaryExpression: getIterationTypesOfIteratorWorker(iteratorType, resolver, errorNode, errorOutputContainer, noCache) ?? noIterationTypes */ TODO
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case noCache:
			return iterationTypes
		default:
			return setCachedIterationTypes(type_, resolver.iterableCacheKey, iterationTypes)
		}
	}
	reportTypeNotIterableError := func(errorNode Node, type_ Type, allowAsyncIterables bool) Diagnostic {
		var message DiagnosticMessage
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case allowAsyncIterables:
			message = Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator
		default:
			message = Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator
		}
		suggestAwait := !!getAwaitedTypeOfPromise(type_) || (!allowAsyncIterables && isForOfStatement(errorNode.parent) && errorNode.parent.expression == errorNode && getGlobalAsyncIterableType(false) != emptyGenericType && isTypeAssignableTo(type_, createTypeFromGenericGlobalType(getGlobalAsyncIterableType(false), []IntrinsicType{anyType, anyType, anyType})))
		return errorAndMaybeSuggestAwait(errorNode, suggestAwait, message, typeToString(type_))
	}
	/**
	 * Gets the *yield*, *return*, and *next* types from an `Iterator`-like or `AsyncIterator`-like type.
	 *
	 * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
	 * record is returned. Otherwise, `undefined` is returned.
	 */
	getIterationTypesOfIterator := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any) *IterationTypes {
		return getIterationTypesOfIteratorWorker(type_, resolver, errorNode, errorOutputContainer /*noCache*/, false)
	}
	/**
	 * Gets the *yield*, *return*, and *next* types from an `Iterator`-like or `AsyncIterator`-like type.
	 *
	 * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
	 * record is returned. Otherwise, `undefined` is returned.
	 *
	 * NOTE: You probably don't want to call this directly and should be calling
	 * `getIterationTypesOfIterator` instead.
	 */
	getIterationTypesOfIteratorWorker := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any, noCache bool) *IterationTypes {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		iterationTypes := getIterationTypesOfIteratorCached(type_, resolver) || getIterationTypesOfIteratorFast(type_, resolver)
		if iterationTypes == noIterationTypes && errorNode {
			iterationTypes = nil
			noCache = true
		}
		/* TODO(TS-TO-GO) Node BinaryExpression: iterationTypes ??= getIterationTypesOfIteratorSlow(type, resolver, errorNode, errorOutputContainer, noCache) */ TODO
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case iterationTypes == noIterationTypes:
			return nil
		default:
			return iterationTypes
		}
	}
	/**
	 * Gets the iteration types of an `Iterator`-like or `AsyncIterator`-like type from the
	 * cache.
	 *
	 * NOTE: You probably don't want to call this directly and should be calling
	 * `getIterationTypesOfIterator` instead.
	 */
	getIterationTypesOfIteratorCached := func(type_ Type, resolver IterationTypesResolver) *IterationTypes {
		return getCachedIterationTypes(type_, resolver.iteratorCacheKey)
	}
	/**
	 * Gets the iteration types of an `Iterator`-like or `AsyncIterator`-like type from the
	 * cache or from common heuristics.
	 *
	 * If we previously analyzed this type and found no iteration types, `noIterationTypes` is
	 * returned. If we found iteration types, an `IterationTypes` record is returned.
	 * Otherwise, we return `undefined` to indicate to the caller it should perform a more
	 * exhaustive analysis.
	 *
	 * NOTE: You probably don't want to call this directly and should be calling
	 * `getIterationTypesOfIterator` instead.
	 */
	getIterationTypesOfIteratorFast := func(type_ Type, resolver IterationTypesResolver) *IterationTypes {
		// As an optimization, if the type is an instantiation of one of the following global types,
		// then just grab its related type arguments:
		// - `IterableIterator<T, TReturn, TNext>` or `AsyncIterableIterator<T, TReturn, TNext>`
		// - `IteratorObject<T, TReturn, TNext>` or `AsyncIteratorObject<T, TReturn, TNext>`
		// - `Iterator<T, TReturn, TNext>` or `AsyncIterator<T, TReturn, TNext>`
		// - `Generator<T, TReturn, TNext>` or `AsyncGenerator<T, TReturn, TNext>`
		if isReferenceToType(type_, resolver.getGlobalIterableIteratorType(false)) || isReferenceToType(type_, resolver.getGlobalIteratorType(false)) || isReferenceToType(type_, resolver.getGlobalIteratorObjectType(false)) || isReferenceToType(type_, resolver.getGlobalGeneratorType(false)) {
			TODO_IDENTIFIER := getTypeArguments(type_ /* as GenericType */)
			return setCachedIterationTypes(type_, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType))
		}
		// As an optimization, if the type is an instantiation of one of the following global types, then
		// just grab the related type argument:
		// - `ArrayIterator<T>`
		// - `MapIterator<T>`
		// - `SetIterator<T>`
		// - `StringIterator<T>`
		// - `ReadableStreamAsyncIterator<T>`
		if isReferenceToSomeType(type_, resolver.getGlobalBuiltinIteratorTypes()) {
			TODO_IDENTIFIER := getTypeArguments(type_ /* as GenericType */)
			returnType := getBuiltinIteratorReturnType()
			nextType := unknownType
			return setCachedIterationTypes(type_, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType))
		}
	}
	isIteratorResult := func(type_ Type, kind /* TODO(TS-TO-GO) TypeNode UnionType: IterationTypeKind.Yield | IterationTypeKind.Return */ any) bool {
		// From https://tc39.github.io/ecma262/#sec-iteratorresult-interface:
		// > [done] is the result status of an iterator `next` method call. If the end of the iterator was reached `done` is `true`.
		// > If the end was not reached `done` is `false` and a value is available.
		// > If a `done` property (either own or inherited) does not exist, it is consider to have the value `false`.
		doneType := getTypeOfPropertyOfType(type_, "done" /* as __String */) || falseType
		return isTypeAssignableTo(__COND__(kind == IterationTypeKindYield, falseType, trueType), doneType)
	}
	isYieldIteratorResult := func(type_ Type) bool {
		return isIteratorResult(type_, IterationTypeKindYield)
	}
	isReturnIteratorResult := func(type_ Type) bool {
		return isIteratorResult(type_, IterationTypeKindReturn)
	}
	/**
	 * Gets the *yield* and *return* types of an `IteratorResult`-like type.
	 *
	 * If we are unable to determine a *yield* or a *return* type, `noIterationTypes` is
	 * returned to indicate to the caller that it should handle the error. Otherwise, an
	 * `IterationTypes` record is returned.
	 */
	getIterationTypesOfIteratorResult := func(type_ Type) IterationTypes {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		cachedTypes := getCachedIterationTypes(type_, "iterationTypesOfIteratorResult")
		if cachedTypes {
			return cachedTypes
		}
		// As an optimization, if the type is an instantiation of one of the global `IteratorYieldResult<T>`
		// or `IteratorReturnResult<TReturn>` types, then just grab its type argument.
		if isReferenceToType(type_, getGlobalIteratorYieldResultType(false)) {
			yieldType := getTypeArguments(type_ /* as GenericType */)[0]
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(yieldType /*returnType*/, nil /*nextType*/, nil))
		}
		if isReferenceToType(type_, getGlobalIteratorReturnResultType(false)) {
			returnType := getTypeArguments(type_ /* as GenericType */)[0]
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(nil, returnType /*nextType*/, nil))
		}
		// Choose any constituents that can produce the requested iteration type.
		yieldIteratorResult := filterType(type_, isYieldIteratorResult)
		var yieldType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case yieldIteratorResult != neverType:
			yieldType = getTypeOfPropertyOfType(yieldIteratorResult, "value" /* as __String */)
		default:
			yieldType = nil
		}
		returnIteratorResult := filterType(type_, isReturnIteratorResult)
		var returnType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case returnIteratorResult != neverType:
			returnType = getTypeOfPropertyOfType(returnIteratorResult, "value" /* as __String */)
		default:
			returnType = nil
		}
		if !yieldType && !returnType {
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", noIterationTypes)
		}
		// From https://tc39.github.io/ecma262/#sec-iteratorresult-interface
		// > ... If the iterator does not have a return value, `value` is `undefined`. In that case, the
		// > `value` property may be absent from the conforming object if it does not inherit an explicit
		// > `value` property.
		return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, returnType || voidType /*nextType*/, nil))
	}
	/**
	 * Gets the *yield*, *return*, and *next* types of a the `next()`, `return()`, or
	 * `throw()` method of an `Iterator`-like or `AsyncIterator`-like type.
	 *
	 * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
	 * record is returned. Otherwise, we return `undefined`.
	 */
	getIterationTypesOfMethod := func(type_ Type, resolver IterationTypesResolver, methodName /* TODO(TS-TO-GO) TypeNode UnionType: "next" | "return" | "throw" */ any, errorNode Node, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any) *IterationTypes {
		method := getPropertyOfType(type_, methodName /* as __String */)
		// Ignore 'return' or 'throw' if they are missing.
		if !method && methodName != "next" {
			return nil
		}
		var methodType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case method && !(methodName == "next" && (method.flags & SymbolFlagsOptional)):
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case methodName == "next":
				methodType = getTypeOfSymbol(method)
			default:
				methodType = getTypeWithFacts(getTypeOfSymbol(method), TypeFactsNEUndefinedOrNull)
			}
		default:
			methodType = nil
		}
		if isTypeAny(methodType) {
			return anyIterationTypes
		}
		// Both async and non-async iterators *must* have a `next` method.
		var methodSignatures []Signature
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case methodType:
			methodSignatures = getSignaturesOfType(methodType, SignatureKindCall)
		default:
			methodSignatures = emptyArray
		}
		if methodSignatures.length == 0 {
			if errorNode {
				var diagnostic DiagnosticMessage
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case methodName == "next":
					diagnostic = resolver.mustHaveANextMethodDiagnostic
				default:
					diagnostic = resolver.mustBeAMethodDiagnostic
				}
				if errorOutputContainer {
					/* TODO(TS-TO-GO) Node BinaryExpression: errorOutputContainer.errors ??= [] */ TODO
					errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, diagnostic, methodName))
				} else {
					error(errorNode, diagnostic, methodName)
				}
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case methodName == "next":
				return noIterationTypes
			default:
				return nil
			}
		}
		// If the method signature comes exclusively from the global iterator or generator type,
		// create iteration types from its type arguments like `getIterationTypesOfIteratorFast`
		// does (so as to remove `undefined` from the next and return types). We arrive here when
		// a contextual type for a generator was not a direct reference to one of those global types,
		// but looking up `methodType` referred to one of them (and nothing else). E.g., in
		// `interface SpecialIterator extends Iterator<number> {}`, `SpecialIterator` is not a
		// reference to `Iterator`, but its `next` member derives exclusively from `Iterator`.
		if methodType. /* TODO(TS-TO-GO): was ? */ symbol && methodSignatures.length == 1 {
			globalGeneratorType := resolver.getGlobalGeneratorType(false)
			globalIteratorType := resolver.getGlobalIteratorType(false)
			isGeneratorMethod := globalGeneratorType.symbol. /* TODO(TS-TO-GO): was ? */ members. /* TODO(TS-TO-GO): was ? */ get(methodName /* as __String */) == methodType.symbol
			isIteratorMethod := !isGeneratorMethod && globalIteratorType.symbol. /* TODO(TS-TO-GO): was ? */ members. /* TODO(TS-TO-GO): was ? */ get(methodName /* as __String */) == methodType.symbol
			if isGeneratorMethod || isIteratorMethod {
				var globalType GenericType
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isGeneratorMethod:
					globalType = globalGeneratorType
				default:
					globalType = globalIteratorType
				}
				TODO_IDENTIFIER := methodType /* as AnonymousType */
				return createIterationTypes(getMappedType(globalType.typeParameters[0], mapper), getMappedType(globalType.typeParameters[1], mapper), __COND__(methodName == "next", getMappedType(globalType.typeParameters[2], mapper), nil))
			}
		}
		// Extract the first parameter and return type of each signature.
		var methodParameterTypes *[]Type
		var methodReturnTypes *[]Type
		for _, signature := range methodSignatures {
			if methodName != "throw" && some(signature.parameters) {
				methodParameterTypes = append(methodParameterTypes, getTypeAtPosition(signature, 0))
			}
			methodReturnTypes = append(methodReturnTypes, getReturnTypeOfSignature(signature))
		}
		// Resolve the *next* or *return* type from the first parameter of a `next()` or
		// `return()` method, respectively.
		var returnTypes *[]Type
		var nextType Type
		if methodName != "throw" {
			var methodParameterType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case methodParameterTypes:
				methodParameterType = getUnionType(methodParameterTypes)
			default:
				methodParameterType = unknownType
			}
			if methodName == "next" {
				// The value of `next(value)` is *not* awaited by async generators
				nextType = methodParameterType
			} else if methodName == "return" {
				// The value of `return(value)` *is* awaited by async generators
				resolvedMethodParameterType := resolver.resolveIterationType(methodParameterType, errorNode) || anyType
				returnTypes = append(returnTypes, resolvedMethodParameterType)
			}
		}
		// Resolve the *yield* and *return* types from the return type of the method (i.e. `IteratorResult`)
		var yieldType Type
		var methodReturnType Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case methodReturnTypes:
			methodReturnType = getIntersectionType(methodReturnTypes)
		default:
			methodReturnType = neverType
		}
		resolvedMethodReturnType := resolver.resolveIterationType(methodReturnType, errorNode) || anyType
		iterationTypes := getIterationTypesOfIteratorResult(resolvedMethodReturnType)
		if iterationTypes == noIterationTypes {
			if errorNode {
				if errorOutputContainer {
					/* TODO(TS-TO-GO) Node BinaryExpression: errorOutputContainer.errors ??= [] */ TODO
					errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, resolver.mustHaveAValueDiagnostic, methodName))
				} else {
					error(errorNode, resolver.mustHaveAValueDiagnostic, methodName)
				}
			}
			yieldType = anyType
			returnTypes = append(returnTypes, anyType)
		} else {
			yieldType = iterationTypes.yieldType
			returnTypes = append(returnTypes, iterationTypes.returnType)
		}
		return createIterationTypes(yieldType, getUnionType(returnTypes), nextType)
	}
	/**
	 * Gets the *yield*, *return*, and *next* types of an `Iterator`-like or `AsyncIterator`-like
	 * type from its members.
	 *
	 * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
	 * record is returned. Otherwise, `noIterationTypes` is returned.
	 *
	 * NOTE: You probably don't want to call this directly and should be calling
	 * `getIterationTypesOfIterator` instead.
	 */
	getIterationTypesOfIteratorSlow := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any, noCache bool) IterationTypes {
		iterationTypes := combineIterationTypes([]*IterationTypes{getIterationTypesOfMethod(type_, resolver, "next", errorNode, errorOutputContainer), getIterationTypesOfMethod(type_, resolver, "return", errorNode, errorOutputContainer), getIterationTypesOfMethod(type_, resolver, "throw", errorNode, errorOutputContainer)})
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case noCache:
			return iterationTypes
		default:
			return setCachedIterationTypes(type_, resolver.iteratorCacheKey, iterationTypes)
		}
	}
	/**
	 * Gets the requested "iteration type" from a type that is either `Iterable`-like, `Iterator`-like,
	 * `IterableIterator`-like, or `Generator`-like (for a non-async generator); or `AsyncIterable`-like,
	 * `AsyncIterator`-like, `AsyncIterableIterator`-like, or `AsyncGenerator`-like (for an async generator).
	 */
	getIterationTypeOfGeneratorFunctionReturnType := func(kind IterationTypeKind, returnType Type, isAsyncGenerator bool) Type {
		if isTypeAny(returnType) {
			return nil
		}
		iterationTypes := getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsyncGenerator)
		return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(kind)]
	}
	getIterationTypesOfGeneratorFunctionReturnType := func(type_ Type, isAsyncGenerator bool) *IterationTypes {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		var use /* TODO(TS-TO-GO) inferred type IterationUse.AllowsSyncIterablesFlag | IterationUse.AllowsAsyncIterablesFlag */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isAsyncGenerator:
			use = IterationUseAsyncGeneratorReturnType
		default:
			use = IterationUseGeneratorReturnType
		}
		var resolver IterationTypesResolver
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isAsyncGenerator:
			resolver = asyncIterationTypesResolver
		default:
			resolver = syncIterationTypesResolver
		}
		return getIterationTypesOfIterable(type_, use /*errorNode*/, nil) || getIterationTypesOfIterator(type_, resolver /*errorNode*/, nil /*errorOutputContainer*/, nil)
	}
	checkBreakOrContinueStatement := func(node BreakOrContinueStatement) {
		// Grammar checking
		if !checkGrammarStatementInAmbientContext(node) {
			checkGrammarBreakOrContinueStatement(node)
		}
		// TODO: Check that target label is valid
	}
	unwrapReturnType := func(returnType Type, functionFlags FunctionFlags) Type {
		isGenerator := !!(functionFlags & FunctionFlagsGenerator)
		isAsync := !!(functionFlags & FunctionFlagsAsync)
		if isGenerator {
			returnIterationType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, returnType, isAsync)
			if !returnIterationType {
				return errorType
			}
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isAsync:
				return getAwaitedTypeNoAlias(unwrapAwaitedType(returnIterationType))
			default:
				return returnIterationType
			}
		}
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isAsync:
			return getAwaitedTypeNoAlias(returnType) || errorType
		default:
			return returnType
		}
	}
	isUnwrappedReturnTypeUndefinedVoidOrAny := func(func_ SignatureDeclaration, returnType Type) bool {
		type_ := unwrapReturnType(returnType, getFunctionFlags(func_))
		return !!(type_ && (maybeTypeOfKind(type_, TypeFlagsVoid) || type_.flags&(TypeFlagsAny|TypeFlagsUndefined)))
	}
	checkReturnStatement := func(node ReturnStatement) {
		// Grammar checking
		if checkGrammarStatementInAmbientContext(node) {
			return
		}
		container := getContainingFunctionOrClassStaticBlock(node)
		if container && isClassStaticBlockDeclaration(container) {
			grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block)
			return
		}
		if !container {
			grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_can_only_be_used_within_a_function_body)
			return
		}
		signature := getSignatureFromDeclaration(container)
		returnType := getReturnTypeOfSignature(signature)
		functionFlags := getFunctionFlags(container)
		if strictNullChecks || node.expression || returnType.flags&TypeFlagsNever {
			var exprType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node.expression:
				exprType = checkExpressionCached(node.expression)
			default:
				exprType = undefinedType
			}
			if container.kind == SyntaxKindSetAccessor {
				if node.expression {
					error(node, Diagnostics.Setters_cannot_return_a_value)
				}
			} else if container.kind == SyntaxKindConstructor {
				if node.expression && !checkTypeAssignableToAndOptionallyElaborate(exprType, returnType, node, node.expression) {
					error(node, Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class)
				}
			} else if getReturnTypeFromAnnotation(container) {
				unwrappedReturnType := /* TODO(TS-TO-GO) Node BinaryExpression: unwrapReturnType(returnType, functionFlags) ?? returnType */ TODO
				var unwrappedExprType Type
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case functionFlags & FunctionFlagsAsync:
					unwrappedExprType = checkAwaitedType(exprType /*withAlias*/, false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
				default:
					unwrappedExprType = exprType
				}
				if unwrappedReturnType {
					// If the function has a return type, but promisedType is
					// undefined, an error will be reported in checkAsyncFunctionReturnType
					// so we don't need to report one here.
					checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, node, node.expression)
				}
			}
		} else if container.kind != SyntaxKindConstructor && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeUndefinedVoidOrAny(container, returnType) {
			// The function has a return type, but the return statement doesn't have an expression.
			error(node, Diagnostics.Not_all_code_paths_return_a_value)
		}
	}
	checkWithStatement := func(node WithStatement) {
		// Grammar checking for withStatement
		if !checkGrammarStatementInAmbientContext(node) {
			if node.flags & NodeFlagsAwaitContext {
				grammarErrorOnFirstToken(node, Diagnostics.with_statements_are_not_allowed_in_an_async_function_block)
			}
		}
		checkExpression(node.expression)
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			start := getSpanOfTokenAtPosition(sourceFile, node.pos).start
			end := node.statement.pos
			grammarErrorAtPos(sourceFile, start, end-start, Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any)
		}
	}
	checkSwitchStatement := func(node SwitchStatement) {
		// Grammar checking
		checkGrammarStatementInAmbientContext(node)
		var firstDefaultClause CaseOrDefaultClause
		hasDuplicateDefaultClause := false
		expressionType := checkExpression(node.expression)
		forEach(node.caseBlock.clauses, func(clause /* TODO(TS-TO-GO) inferred type CaseClause | DefaultClause */ any) {
			// Grammar check for duplicate default clauses, skip if we already report duplicate default clause
			if clause.kind == SyntaxKindDefaultClause && !hasDuplicateDefaultClause {
				if firstDefaultClause == nil {
					firstDefaultClause = clause
				} else {
					grammarErrorOnNode(clause, Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement)
					hasDuplicateDefaultClause = true
				}
			}
			if clause.kind == SyntaxKindCaseClause {
				addLazyDiagnostic(createLazyCaseClauseDiagnostics(clause))
			}
			forEach(clause.statements, checkSourceElement)
			if compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(clause.fallthroughFlowNode) {
				error(clause, Diagnostics.Fallthrough_case_in_switch)
			}
			createLazyCaseClauseDiagnostics := func(clause CaseClause) /* TODO(TS-TO-GO) inferred type () => void */ any {
				return func() {
					// TypeScript 1.0 spec (April 2014): 5.9
					// In a 'switch' statement, each 'case' expression must be of a type that is comparable
					// to or from the type of the 'switch' expression.
					caseType := checkExpression(clause.expression)
					if !isTypeEqualityComparableTo(expressionType, caseType) {
						// expressionType is not comparable to caseType, try the reversed check and report errors if it fails
						checkTypeComparableTo(caseType, expressionType, clause.expression /*headMessage*/, nil)
					}
				}
			}
		})
		if node.caseBlock.locals {
			registerForUnusedIdentifiersCheck(node.caseBlock)
		}
	}
	checkLabeledStatement := func(node LabeledStatement) {
		// Grammar checking
		if !checkGrammarStatementInAmbientContext(node) {
			findAncestor(node.parent, func(current Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
				if isFunctionLike(current) {
					return "quit"
				}
				if current.kind == SyntaxKindLabeledStatement && (current /* as LabeledStatement */).label.escapedText == node.label.escapedText {
					grammarErrorOnNode(node.label, Diagnostics.Duplicate_label_0, getTextOfNode(node.label))
					return true
				}
				return false
			})
		}
		// ensure that label is unique
		checkSourceElement(node.statement)
	}
	checkThrowStatement := func(node ThrowStatement) {
		// Grammar checking
		if !checkGrammarStatementInAmbientContext(node) {
			if isIdentifier(node.expression) && !node.expression.escapedText {
				grammarErrorAfterFirstToken(node, Diagnostics.Line_break_not_permitted_here)
			}
		}
		if node.expression {
			checkExpression(node.expression)
		}
	}
	checkTryStatement := func(node TryStatement) {
		// Grammar checking
		checkGrammarStatementInAmbientContext(node)
		checkBlock(node.tryBlock)
		catchClause := node.catchClause
		if catchClause {
			// Grammar checking
			if catchClause.variableDeclaration {
				declaration := catchClause.variableDeclaration
				checkVariableLikeDeclaration(declaration)
				typeNode := getEffectiveTypeAnnotationNode(declaration)
				if typeNode {
					type_ := getTypeFromTypeNode(typeNode)
					if type_ && !(type_.flags & TypeFlagsAnyOrUnknown) {
						grammarErrorOnFirstToken(typeNode, Diagnostics.Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified)
					}
				} else if declaration.initializer {
					grammarErrorOnFirstToken(declaration.initializer, Diagnostics.Catch_clause_variable_cannot_have_an_initializer)
				} else {
					blockLocals := catchClause.block.locals
					if blockLocals {
						forEachKey(catchClause.locals, func(caughtName __String) {
							blockLocal := blockLocals.get(caughtName)
							if blockLocal. /* TODO(TS-TO-GO): was ? */ valueDeclaration && (blockLocal.flags&SymbolFlagsBlockScopedVariable) != 0 {
								grammarErrorOnNode(blockLocal.valueDeclaration, Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, unescapeLeadingUnderscores(caughtName))
							}
						})
					}
				}
			}
			checkBlock(catchClause.block)
		}
		if node.finallyBlock {
			checkBlock(node.finallyBlock)
		}
	}
	checkIndexConstraints := func(type_ Type, symbol Symbol, isStaticIndex bool) {
		indexInfos := getIndexInfosOfType(type_)
		if indexInfos.length == 0 {
			return
		}
		for _, prop := range getPropertiesOfObjectType(type_) {
			if !(isStaticIndex && prop.flags&SymbolFlagsPrototype) {
				checkIndexConstraintForProperty(type_, prop, getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique /*includeNonPublic*/, true), getNonMissingTypeOfSymbol(prop))
			}
		}
		typeDeclaration := symbol.valueDeclaration
		if typeDeclaration && isClassLike(typeDeclaration) {
			for _, member := range typeDeclaration.members {
				// Only process instance properties with computed names here. Static properties cannot be in conflict with indexers,
				// and properties with literal names were already checked.
				if !isStatic(member) && !hasBindableName(member) {
					symbol := getSymbolOfDeclaration(member)
					checkIndexConstraintForProperty(type_, symbol, getTypeOfExpression((member /* as DynamicNamedDeclaration */).name.expression), getNonMissingTypeOfSymbol(symbol))
				}
			}
		}
		if indexInfos.length > 1 {
			for _, info := range indexInfos {
				checkIndexConstraintForIndexSignature(type_, info)
			}
		}
	}
	checkIndexConstraintForProperty := func(type_ Type, prop Symbol, propNameType Type, propType Type) {
		declaration := prop.valueDeclaration
		name := getNameOfDeclaration(declaration)
		if name && isPrivateIdentifier(name) {
			return
		}
		indexInfos := getApplicableIndexInfos(type_, propNameType)
		var interfaceDeclaration Declaration
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getObjectFlags(type_) & ObjectFlagsInterface:
			interfaceDeclaration = getDeclarationOfKind(type_.symbol, SyntaxKindInterfaceDeclaration)
		default:
			interfaceDeclaration = nil
		}
		var propDeclaration Declaration
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case declaration && declaration.kind == SyntaxKindBinaryExpression || name && name.kind == SyntaxKindComputedPropertyName:
			propDeclaration = declaration
		default:
			propDeclaration = nil
		}
		var localPropDeclaration Declaration
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getParentOfSymbol(prop) == type_.symbol:
			localPropDeclaration = declaration
		default:
			localPropDeclaration = nil
		}
		for _, info := range indexInfos {
			var localIndexDeclaration *IndexSignatureDeclaration
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) == type_.symbol:
				localIndexDeclaration = info.declaration
			default:
				localIndexDeclaration = nil
			}
			// We check only when (a) the property is declared in the containing type, or (b) the applicable index signature is declared
			// in the containing type, or (c) the containing type is an interface and no base interface contains both the property and
			// the index signature (i.e. property and index signature are declared in separate inherited interfaces).
			errorNode := localPropDeclaration || localIndexDeclaration || (__COND__(interfaceDeclaration && !some(getBaseTypes(type_ /* as InterfaceType */), func(base BaseType) bool {
				return !!getPropertyOfObjectType(base, prop.escapedName) && !!getIndexTypeOfType(base, info.keyType)
			}), interfaceDeclaration, nil))
			if errorNode && !isTypeAssignableTo(propType, info.type_) {
				diagnostic := createError(errorNode, Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3, symbolToString(prop), typeToString(propType), typeToString(info.keyType), typeToString(info.type_))
				if propDeclaration && errorNode != propDeclaration {
					addRelatedInfo(diagnostic, createDiagnosticForNode(propDeclaration, Diagnostics._0_is_declared_here, symbolToString(prop)))
				}
				diagnostics.add(diagnostic)
			}
		}
	}
	checkIndexConstraintForIndexSignature := func(type_ Type, checkInfo IndexInfo) {
		declaration := checkInfo.declaration
		indexInfos := getApplicableIndexInfos(type_, checkInfo.keyType)
		var interfaceDeclaration Declaration
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getObjectFlags(type_) & ObjectFlagsInterface:
			interfaceDeclaration = getDeclarationOfKind(type_.symbol, SyntaxKindInterfaceDeclaration)
		default:
			interfaceDeclaration = nil
		}
		var localCheckDeclaration *IndexSignatureDeclaration
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case declaration && getParentOfSymbol(getSymbolOfDeclaration(declaration)) == type_.symbol:
			localCheckDeclaration = declaration
		default:
			localCheckDeclaration = nil
		}
		for _, info := range indexInfos {
			if info == checkInfo {
				continue
			}
			var localIndexDeclaration *IndexSignatureDeclaration
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) == type_.symbol:
				localIndexDeclaration = info.declaration
			default:
				localIndexDeclaration = nil
			}
			// We check only when (a) the check index signature is declared in the containing type, or (b) the applicable index
			// signature is declared in the containing type, or (c) the containing type is an interface and no base interface contains
			// both index signatures (i.e. the index signatures are declared in separate inherited interfaces).
			errorNode := localCheckDeclaration || localIndexDeclaration || (__COND__(interfaceDeclaration && !some(getBaseTypes(type_ /* as InterfaceType */), func(base BaseType) bool {
				return !!getIndexInfoOfType(base, checkInfo.keyType) && !!getIndexTypeOfType(base, info.keyType)
			}), interfaceDeclaration, nil))
			if errorNode && !isTypeAssignableTo(checkInfo.type_, info.type_) {
				error(errorNode, Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3, typeToString(checkInfo.keyType), typeToString(checkInfo.type_), typeToString(info.keyType), typeToString(info.type_))
			}
		}
	}
	checkTypeNameIsReserved := func(name Identifier, message DiagnosticMessage) {
		// TS 1.0 spec (April 2014): 3.6.1
		// The predefined type keywords are reserved and cannot be used as names of user defined types.
		switch name.escapedText {
		case "any":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "unknown":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "never":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "number":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "bigint":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "boolean":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "string":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "symbol":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "void":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "object":
			fallthrough // TODO(TS-TO-GO): merge cases
		case "undefined":
			error(name, message, name.escapedText /* as string */)
		}
	}
	/**
	 * The name cannot be used as 'Object' of user defined types with special target.
	 */
	checkClassNameCollisionWithObject := func(name Identifier) {
		if languageVersion >= ScriptTargetES5 && name.escapedText == "Object" && host.getEmitModuleFormatOfFile(getSourceFileOfNode(name)) < ModuleKindES2015 {
			error(name, Diagnostics.Class_name_cannot_be_Object_when_targeting_ES5_with_module_0, ModuleKind[moduleKind])
			// https://github.com/Microsoft/TypeScript/issues/17494
		}
	}
	checkUnmatchedJSDocParameters := func(node SignatureDeclaration) {
		jsdocParameters := filter(getJSDocTags(node), isJSDocParameterTag)
		if !length(jsdocParameters) {
			return
		}
		isJs := isInJSFile(node)
		parameters := NewSet[__String]()
		excludedParameters := NewSet[number]()
		forEach(node.parameters, func(TODO_IDENTIFIER ParameterDeclaration, index number) {
			if isIdentifier(name) {
				parameters.add(name.escapedText)
			}
			if isBindingPattern(name) {
				excludedParameters.add(index)
			}
		})
		containsArguments := containsArgumentsReference(node)
		if containsArguments {
			lastJSDocParamIndex := jsdocParameters.length - 1
			lastJSDocParam := jsdocParameters[lastJSDocParamIndex]
			if isJs && lastJSDocParam && isIdentifier(lastJSDocParam.name) && lastJSDocParam.typeExpression && lastJSDocParam.typeExpression.type_ && !parameters.has(lastJSDocParam.name.escapedText) && !excludedParameters.has(lastJSDocParamIndex) && !isArrayType(getTypeFromTypeNode(lastJSDocParam.typeExpression.type_)) {
				error(lastJSDocParam.name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type, idText(lastJSDocParam.name))
			}
		} else {
			forEach(jsdocParameters, func(TODO_IDENTIFIER JSDocParameterTag, index number) {
				if excludedParameters.has(index) || isIdentifier(name) && parameters.has(name.escapedText) {
					return
				}
				if isQualifiedName(name) {
					if isJs {
						error(name, Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, entityNameToString(name), entityNameToString(name.left))
					}
				} else {
					if !isNameFirst {
						errorOrSuggestion(isJs, name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, idText(name))
					}
				}
			})
		}
	}
	/**
	 * Check each type parameter and check that type parameters have no duplicate type parameter declarations
	 */
	checkTypeParameters := func(typeParameterDeclarations *[]TypeParameterDeclaration) {
		seenDefault := false
		if typeParameterDeclarations {
			for i := 0; i < typeParameterDeclarations.length; i++ {
				node := typeParameterDeclarations[i]
				checkTypeParameter(node)
				addLazyDiagnostic(createCheckTypeParameterDiagnostic(node, i))
			}
		}
		createCheckTypeParameterDiagnostic := func(node TypeParameterDeclaration, i number) /* TODO(TS-TO-GO) inferred type () => void */ any {
			return func() {
				if node.default_ {
					seenDefault = true
					checkTypeParametersNotReferenced(node.default_, typeParameterDeclarations, i)
				} else if seenDefault {
					error(node, Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters)
				}
				for j := 0; j < i; j++ {
					if typeParameterDeclarations[j].symbol == node.symbol {
						error(node.name, Diagnostics.Duplicate_identifier_0, declarationNameToString(node.name))
					}
				}
			}
		}
	}
	/** Check that type parameter defaults only reference previously declared type parameters */
	checkTypeParametersNotReferenced := func(root TypeNode, typeParameters []TypeParameterDeclaration, index number) {
		visit(root)
		visit := func(node Node) {
			if node.kind == SyntaxKindTypeReference {
				type_ := getTypeFromTypeReference(node /* as TypeReferenceNode */)
				if type_.flags & TypeFlagsTypeParameter {
					for i := index; i < typeParameters.length; i++ {
						if type_.symbol == getSymbolOfDeclaration(typeParameters[i]) {
							error(node, Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters)
						}
					}
				}
			}
			forEachChild(node, visit)
		}
	}
	/** Check that type parameter lists are identical across multiple declarations */
	checkTypeParameterListsIdentical := func(symbol Symbol) {
		if symbol.declarations && symbol.declarations.length == 1 {
			return
		}
		links := getSymbolLinks(symbol)
		if !links.typeParametersChecked {
			links.typeParametersChecked = true
			declarations := getClassOrInterfaceDeclarationsOfSymbol(symbol)
			if !declarations || declarations.length <= 1 {
				return
			}
			type_ := getDeclaredTypeOfSymbol(symbol) /* as InterfaceType */
			if !areTypeParametersIdentical(declarations, type_.localTypeParameters, getEffectiveTypeParameterDeclarations) {
				// Report an error on every conflicting declaration.
				name := symbolToString(symbol)
				for _, declaration := range declarations {
					error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, name)
				}
			}
		}
	}
	areTypeParametersIdentical := func(declarations []T, targetParameters []TypeParameter, getTypeParameterDeclarations func(node T) []TypeParameterDeclaration) bool {
		maxTypeArgumentCount := length(targetParameters)
		minTypeArgumentCount := getMinTypeArgumentCount(targetParameters)
		for _, declaration := range declarations {
			// If this declaration has too few or too many type parameters, we report an error
			sourceParameters := getTypeParameterDeclarations(declaration)
			numTypeParameters := sourceParameters.length
			if numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount {
				return false
			}
			for i := 0; i < numTypeParameters; i++ {
				source := sourceParameters[i]
				target := targetParameters[i]
				// If the type parameter node does not have the same as the resolved type
				// parameter at this position, we report an error.
				if source.name.escapedText != target.symbol.escapedName {
					return false
				}
				// If the type parameter node does not have an identical constraint as the resolved
				// type parameter at this position, we report an error.
				constraint := getEffectiveConstraintOfTypeParameter(source)
				sourceConstraint := constraint && getTypeFromTypeNode(constraint)
				targetConstraint := getConstraintOfTypeParameter(target)
				// relax check if later interface augmentation has no constraint, it's more broad and is OK to merge with
				// a more constrained interface (this could be generalized to a full hierarchy check, but that's maybe overkill)
				if sourceConstraint && targetConstraint && !isTypeIdenticalTo(sourceConstraint, targetConstraint) {
					return false
				}
				// If the type parameter node has a default and it is not identical to the default
				// for the type parameter at this position, we report an error.
				sourceDefault := source.default_ && getTypeFromTypeNode(source.default_)
				targetDefault := getDefaultFromTypeParameter(target)
				if sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault) {
					return false
				}
			}
		}
		return true
	}
	getFirstTransformableStaticClassElement := func(node ClassLikeDeclaration) * /* TODO(TS-TO-GO) inferred type ClassLikeDeclaration | ClassStaticBlockDeclaration | Decorator | PrivateIdentifierPropertyDeclaration | PrivateIdentifierMethodDeclaration | PrivateIdentifierGetAccessorDeclaration | PrivateIdentifierSetAccessorDeclaration | (PropertyDeclaration & { initializer: Expression; }) */ any {
		willTransformStaticElementsOfDecoratedClass := !legacyDecorators && languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators && classOrConstructorParameterIsDecorated(false, node)
		willTransformPrivateElementsOrClassStaticBlocks := languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators
		willTransformInitializers := !emitStandardClassFields
		if willTransformStaticElementsOfDecoratedClass || willTransformPrivateElementsOrClassStaticBlocks {
			for _, member := range node.members {
				if willTransformStaticElementsOfDecoratedClass && classElementOrClassElementParameterIsDecorated(false, member, node) {
					return /* TODO(TS-TO-GO) Node BinaryExpression: firstOrUndefined(getDecorators(node)) ?? node */ TODO
				} else if willTransformPrivateElementsOrClassStaticBlocks {
					if isClassStaticBlockDeclaration(member) {
						return member
					} else if isStatic(member) {
						if isPrivateIdentifierClassElementDeclaration(member) || willTransformInitializers && isInitializedProperty(member) {
							return member
						}
					}
				}
			}
		}
	}
	checkClassExpressionExternalHelpers := func(node ClassExpression) {
		if node.name {
			return
		}
		parent := walkUpOuterExpressions(node)
		if !isNamedEvaluationSource(parent) {
			return
		}
		willTransformESDecorators := !legacyDecorators && languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators
		var location Node
		if willTransformESDecorators && classOrConstructorParameterIsDecorated(false, node) {
			location = /* TODO(TS-TO-GO) Node BinaryExpression: firstOrUndefined(getDecorators(node)) ?? node */ TODO
		} else {
			location = getFirstTransformableStaticClassElement(node)
		}
		if location {
			checkExternalEmitHelpers(location, ExternalEmitHelpersSetFunctionName)
			if (isPropertyAssignment(parent) || isPropertyDeclaration(parent) || isBindingElement(parent)) && isComputedPropertyName(parent.name) {
				checkExternalEmitHelpers(location, ExternalEmitHelpersPropKey)
			}
		}
	}
	checkClassExpression := func(node ClassExpression) Type {
		checkClassLikeDeclaration(node)
		checkNodeDeferred(node)
		checkClassExpressionExternalHelpers(node)
		return getTypeOfSymbol(getSymbolOfDeclaration(node))
	}
	checkClassExpressionDeferred := func(node ClassExpression) {
		forEach(node.members, checkSourceElement)
		registerForUnusedIdentifiersCheck(node)
	}
	checkClassDeclaration := func(node ClassDeclaration) {
		firstDecorator := find(node.modifiers, isDecorator)
		if legacyDecorators && firstDecorator && some(node.members, func(p ClassElement) bool {
			return hasStaticModifier(p) && isPrivateIdentifierClassElementDeclaration(p)
		}) {
			grammarErrorOnNode(firstDecorator, Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator)
		}
		if !node.name && !hasSyntacticModifier(node, ModifierFlagsDefault) {
			grammarErrorOnFirstToken(node, Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name)
		}
		checkClassLikeDeclaration(node)
		forEach(node.members, checkSourceElement)
		registerForUnusedIdentifiersCheck(node)
	}
	checkClassLikeDeclaration := func(node ClassLikeDeclaration) {
		checkGrammarClassLikeDeclaration(node)
		checkDecorators(node)
		checkCollisionsForDeclarationName(node, node.name)
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
		checkExportsOnMergedDeclarations(node)
		symbol := getSymbolOfDeclaration(node)
		type_ := getDeclaredTypeOfSymbol(symbol) /* as InterfaceType */
		typeWithThis := getTypeWithThisArgument(type_)
		staticType := getTypeOfSymbol(symbol) /* as ObjectType */
		checkTypeParameterListsIdentical(symbol)
		checkFunctionOrConstructorSymbol(symbol)
		checkClassForDuplicateDeclarations(node)
		// Only check for reserved static identifiers on non-ambient context.
		nodeInAmbientContext := !!(node.flags & NodeFlagsAmbient)
		if !nodeInAmbientContext {
			checkClassForStaticPropertyNameConflicts(node)
		}
		baseTypeNode := getEffectiveBaseTypeNode(node)
		if baseTypeNode {
			forEach(baseTypeNode.typeArguments, checkSourceElement)
			if languageVersion < LanguageFeatureMinimumTargetClasses {
				checkExternalEmitHelpers(baseTypeNode.parent, ExternalEmitHelpersExtends)
			}
			// check both @extends and extends if both are specified.
			extendsNode := getClassExtendsHeritageElement(node)
			if extendsNode && extendsNode != baseTypeNode {
				checkExpression(extendsNode.expression)
			}
			baseTypes := getBaseTypes(type_)
			if baseTypes.length {
				addLazyDiagnostic(func() {
					baseType := baseTypes[0]
					baseConstructorType := getBaseConstructorTypeOfClass(type_)
					staticBaseType := getApparentType(baseConstructorType)
					checkBaseTypeAccessibility(staticBaseType, baseTypeNode)
					checkSourceElement(baseTypeNode.expression)
					if some(baseTypeNode.typeArguments) {
						forEach(baseTypeNode.typeArguments, checkSourceElement)
						for _, constructor := range getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode) {
							if !checkTypeArgumentConstraints(baseTypeNode, constructor.typeParameters) {
								break
							}
						}
					}
					baseWithThis := getTypeWithThisArgument(baseType, type_.thisType)
					if !checkTypeAssignableTo(typeWithThis, baseWithThis /*errorNode*/, nil) {
						issueMemberSpecificError(node, typeWithThis, baseWithThis, Diagnostics.Class_0_incorrectly_extends_base_class_1)
					} else {
						// Report static side error only when instance type is assignable
						checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1)
					}
					if baseConstructorType.flags & TypeFlagsTypeVariable {
						if !isMixinConstructorType(staticType) {
							error(node.name || node, Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any)
						} else {
							constructSignatures := getSignaturesOfType(baseConstructorType, SignatureKindConstruct)
							if constructSignatures.some(func(signature Signature) number {
								return signature.flags & SignatureFlagsAbstract
							}) && !hasSyntacticModifier(node, ModifierFlagsAbstract) {
								error(node.name || node, Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract)
							}
						}
					}
					if !(staticBaseType.symbol && staticBaseType.symbol.flags&SymbolFlagsClass) && !(baseConstructorType.flags & TypeFlagsTypeVariable) {
						// When the static base type is a "class-like" constructor function (but not actually a class), we verify
						// that all instantiated base constructor signatures return the same type.
						constructors := getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode)
						if forEach(constructors, func(sig Signature) bool {
							return !isJSConstructor(sig.declaration) && !isTypeIdenticalTo(getReturnTypeOfSignature(sig), baseType)
						}) {
							error(baseTypeNode.expression, Diagnostics.Base_constructors_must_all_have_the_same_return_type)
						}
					}
					checkKindsOfPropertyMemberOverrides(type_, baseType)
				})
			}
		}
		checkMembersForOverrideModifier(node, type_, typeWithThis, staticType)
		implementedTypeNodes := getEffectiveImplementsTypeNodes(node)
		if implementedTypeNodes {
			for _, typeRefNode := range implementedTypeNodes {
				if !isEntityNameExpression(typeRefNode.expression) || isOptionalChain(typeRefNode.expression) {
					error(typeRefNode.expression, Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments)
				}
				checkTypeReferenceNode(typeRefNode)
				addLazyDiagnostic(createImplementsDiagnostics(typeRefNode))
			}
		}
		addLazyDiagnostic(func() {
			checkIndexConstraints(type_, symbol)
			checkIndexConstraints(staticType, symbol /*isStaticIndex*/, true)
			checkTypeForDuplicateIndexSignatures(node)
			checkPropertyInitialization(node)
		})
		createImplementsDiagnostics := func(typeRefNode ExpressionWithTypeArguments) /* TODO(TS-TO-GO) inferred type () => void */ any {
			return func() {
				t := getReducedType(getTypeFromTypeNode(typeRefNode))
				if !isErrorType(t) {
					if isValidBaseType(t) {
						var genericDiag DiagnosticMessage
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case t.symbol && t.symbol.flags&SymbolFlagsClass:
							genericDiag = Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass
						default:
							genericDiag = Diagnostics.Class_0_incorrectly_implements_interface_1
						}
						baseWithThis := getTypeWithThisArgument(t, type_.thisType)
						if !checkTypeAssignableTo(typeWithThis, baseWithThis /*errorNode*/, nil) {
							issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag)
						}
					} else {
						error(typeRefNode, Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members)
					}
				}
			}
		}
	}
	checkMembersForOverrideModifier := func(node ClassLikeDeclaration, type_ InterfaceType, typeWithThis Type, staticType ObjectType) {
		baseTypeNode := getEffectiveBaseTypeNode(node)
		baseTypes := baseTypeNode && getBaseTypes(type_)
		var baseWithThis Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case baseTypes. /* TODO(TS-TO-GO): was ? */ length:
			baseWithThis = getTypeWithThisArgument(first(baseTypes), type_.thisType)
		default:
			baseWithThis = nil
		}
		baseStaticType := getBaseConstructorTypeOfClass(type_)
		for _, member := range node.members {
			if hasAmbientModifier(member) {
				continue
			}
			if isConstructorDeclaration(member) {
				forEach(member.parameters, func(param ParameterDeclaration) {
					if isParameterPropertyDeclaration(param, member) {
						checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, param, true)
					}
				})
			}
			checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, member, false)
		}
	}
	/**
	 * @param member Existing member node to be checked.
	 * Note: `member` cannot be a synthetic node.
	 */
	checkExistingMemberForOverrideModifier := func(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis Type, type_ InterfaceType, typeWithThis Type, member /* TODO(TS-TO-GO) TypeNode UnionType: ClassElement | ParameterPropertyDeclaration */ any, memberIsParameterProperty bool, reportErrors bool /*  = true */) MemberOverrideStatus {
		declaredProp := member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member)
		if !declaredProp {
			return MemberOverrideStatusOk
		}
		return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, hasOverrideModifier(member), hasAbstractModifier(member), isStatic(member), memberIsParameterProperty, declaredProp, __COND__(reportErrors, member, nil))
	}
	/**
	 * Checks a class member declaration for either a missing or an invalid `override` modifier.
	 * Note: this function can be used for speculative checking,
	 * i.e. checking a member that does not yet exist in the program.
	 * An example of that would be to call this function in a completions scenario,
	 * when offering a method declaration as completion.
	 * @param errorNode The node where we should report an error, or undefined if we should not report errors.
	 */
	checkMemberForOverrideModifier := func(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis Type, type_ InterfaceType, typeWithThis Type, memberHasOverrideModifier bool, memberHasAbstractModifier bool, memberIsStatic bool, memberIsParameterProperty bool, member Symbol, errorNode Node) MemberOverrideStatus {
		isJs := isInJSFile(node)
		nodeInAmbientContext := !!(node.flags & NodeFlagsAmbient)
		if baseWithThis && (memberHasOverrideModifier || compilerOptions.noImplicitOverride) {
			var thisType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case memberIsStatic:
				thisType = staticType
			default:
				thisType = typeWithThis
			}
			var baseType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case memberIsStatic:
				baseType = baseStaticType
			default:
				baseType = baseWithThis
			}
			prop := getPropertyOfType(thisType, member.escapedName)
			baseProp := getPropertyOfType(baseType, member.escapedName)
			baseClassName := typeToString(baseWithThis)
			if prop && !baseProp && memberHasOverrideModifier {
				if errorNode {
					suggestion := getSuggestedSymbolForNonexistentClassMember(symbolName(member), baseType)
					// Again, using symbol name: note that's different from `symbol.escapedName`
					__COND__(suggestion, error(errorNode, __COND__(isJs, Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1, Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1), baseClassName, symbolToString(suggestion)), error(errorNode, __COND__(isJs, Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0, Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0), baseClassName))
				}
				return MemberOverrideStatusHasInvalidOverride
			} else if prop && baseProp. /* TODO(TS-TO-GO): was ? */ declarations && compilerOptions.noImplicitOverride && !nodeInAmbientContext {
				baseHasAbstract := some(baseProp.declarations, hasAbstractModifier)
				if memberHasOverrideModifier {
					return MemberOverrideStatusOk
				}
				if !baseHasAbstract {
					if errorNode {
						var diag DiagnosticMessage
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case memberIsParameterProperty:
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case isJs:
								diag = Diagnostics.This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0
							default:
								diag = Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0
							}
						case isJs:
							diag = Diagnostics.This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0
						default:
							diag = Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0
						}
						error(errorNode, diag, baseClassName)
					}
					return MemberOverrideStatusNeedsOverride
				} else if memberHasAbstractModifier && baseHasAbstract {
					if errorNode {
						error(errorNode, Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0, baseClassName)
					}
					return MemberOverrideStatusNeedsOverride
				}
			}
		} else if memberHasOverrideModifier {
			if errorNode {
				className := typeToString(type_)
				error(errorNode, __COND__(isJs, Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class, Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class), className)
			}
			return MemberOverrideStatusHasInvalidOverride
		}
		return MemberOverrideStatusOk
	}
	issueMemberSpecificError := func(node ClassLikeDeclaration, typeWithThis Type, baseWithThis Type, broadDiag DiagnosticMessage) {
		// iterate over all implemented properties and issue errors on each one which isn't compatible, rather than the class as a whole, if possible
		issuedMemberError := false
		for _, member := range node.members {
			if isStatic(member) {
				continue
			}
			declaredProp := member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member)
			if declaredProp {
				prop := getPropertyOfType(typeWithThis, declaredProp.escapedName)
				baseProp := getPropertyOfType(baseWithThis, declaredProp.escapedName)
				if prop && baseProp {
					rootChain := func() DiagnosticMessageChain {
						return chainDiagnosticMessages(nil, Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2, symbolToString(declaredProp), typeToString(typeWithThis), typeToString(baseWithThis))
					}
					if !checkTypeAssignableTo(getTypeOfSymbol(prop), getTypeOfSymbol(baseProp), member.name || member /*headMessage*/, nil, rootChain) {
						issuedMemberError = true
					}
				}
			}
		}
		if !issuedMemberError {
			// check again with diagnostics to generate a less-specific error
			checkTypeAssignableTo(typeWithThis, baseWithThis, node.name || node, broadDiag)
		}
	}
	checkBaseTypeAccessibility := func(type_ Type, node ExpressionWithTypeArguments) {
		signatures := getSignaturesOfType(type_, SignatureKindConstruct)
		if signatures.length {
			declaration := signatures[0].declaration
			if declaration && hasEffectiveModifier(declaration, ModifierFlagsPrivate) {
				typeClassDeclaration := getClassLikeDeclarationOfSymbol(type_.symbol)
				if !isNodeWithinClass(node, typeClassDeclaration) {
					error(node, Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, getFullyQualifiedName(type_.symbol))
				}
			}
		}
	}
	/**
	 * Checks a member declaration node to see if has a missing or invalid `override` modifier.
	 * @param node Class-like node where the member is declared.
	 * @param member Member declaration node.
	 * @param memberSymbol Member symbol.
	 * Note: `member` can be a synthetic node without a parent.
	 */
	getMemberOverrideModifierStatus := func(node ClassLikeDeclaration, member ClassElement, memberSymbol Symbol) MemberOverrideStatus {
		if !member.name {
			return MemberOverrideStatusOk
		}
		classSymbol := getSymbolOfDeclaration(node)
		type_ := getDeclaredTypeOfSymbol(classSymbol) /* as InterfaceType */
		typeWithThis := getTypeWithThisArgument(type_)
		staticType := getTypeOfSymbol(classSymbol) /* as ObjectType */
		baseTypeNode := getEffectiveBaseTypeNode(node)
		baseTypes := baseTypeNode && getBaseTypes(type_)
		var baseWithThis Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case baseTypes. /* TODO(TS-TO-GO): was ? */ length:
			baseWithThis = getTypeWithThisArgument(first(baseTypes), type_.thisType)
		default:
			baseWithThis = nil
		}
		baseStaticType := getBaseConstructorTypeOfClass(type_)
		var memberHasOverrideModifier bool
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case member.parent:
			memberHasOverrideModifier = hasOverrideModifier(member)
		default:
			memberHasOverrideModifier = hasSyntacticModifier(member, ModifierFlagsOverride)
		}
		return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, memberHasOverrideModifier, hasAbstractModifier(member), isStatic(member), false, memberSymbol)
	}
	getTargetSymbol := func(s Symbol) Symbol {
		// if symbol is instantiated its flags are not copied from the 'target'
		// so we'll need to get back original 'target' symbol to work with correct set of flags
		// NOTE: cast to TransientSymbol should be safe because only TransientSymbols have CheckFlags.Instantiated
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getCheckFlags(s) & CheckFlagsInstantiated:
			return (s /* as TransientSymbol */).links.target
		default:
			return s
		}
	}
	getClassOrInterfaceDeclarationsOfSymbol := func(symbol Symbol) *[] /* TODO(TS-TO-GO) inferred type (ClassDeclaration | InterfaceDeclaration) */ any {
		return filter(symbol.declarations, func(d Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: d is ClassDeclaration | InterfaceDeclaration */ any {
			return d.kind == SyntaxKindClassDeclaration || d.kind == SyntaxKindInterfaceDeclaration
		})
	}
	checkKindsOfPropertyMemberOverrides := func(type_ InterfaceType, baseType BaseType) {
		// TypeScript 1.0 spec (April 2014): 8.2.3
		// A derived class inherits all members from its base class it doesn't override.
		// Inheritance means that a derived class implicitly contains all non - overridden members of the base class.
		// Both public and private property members are inherited, but only public property members can be overridden.
		// A property member in a derived class is said to override a property member in a base class
		// when the derived class property member has the same name and kind(instance or static)
		// as the base class property member.
		// The type of an overriding property member must be assignable(section 3.8.4)
		// to the type of the overridden property member, or otherwise a compile - time error occurs.
		// Base class instance member functions can be overridden by derived class instance member functions,
		// but not by other kinds of members.
		// Base class instance member variables and accessors can be overridden by
		// derived class instance member variables and accessors, but not by other kinds of members.
		// NOTE: assignability is checked in checkClassDeclaration
		baseProperties := getPropertiesOfType(baseType)
		type MemberInfo struct {
			missedProperties []string
			baseTypeName     string
			typeName         string
		}
		notImplementedInfo := NewMap[ClassLikeDeclaration, MemberInfo]()
	basePropertyCheck:
		for _, baseProperty := range baseProperties {
			base := getTargetSymbol(baseProperty)
			if base.flags & SymbolFlagsPrototype {
				continue
			}
			baseSymbol := getPropertyOfObjectType(type_, base.escapedName)
			if !baseSymbol {
				continue
			}
			derived := getTargetSymbol(baseSymbol)
			baseDeclarationFlags := getDeclarationModifierFlagsFromSymbol(base)
			Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration.")
			// In order to resolve whether the inherited method was overridden in the base class or not,
			// we compare the Symbols obtained. Since getTargetSymbol returns the symbol on the *uninstantiated*
			// type declaration, derived and base resolve to the same symbol even in the case of generic classes.
			if derived == base {
				// derived class inherits base without override/redeclaration
				derivedClassDecl := getClassLikeDeclarationOfSymbol(type_.symbol)
				// It is an error to inherit an abstract member without implementing it or being declared abstract.
				// If there is no declaration for the derived class (as in the case of class expressions),
				// then the class cannot be declared abstract.
				if baseDeclarationFlags&ModifierFlagsAbstract && (!derivedClassDecl || !hasSyntacticModifier(derivedClassDecl, ModifierFlagsAbstract)) {
					// Searches other base types for a declaration that would satisfy the inherited abstract member.
					// (The class may have more than one base type via declaration merging with an interface with the
					// same name.)
					for _, otherBaseType := range getBaseTypes(type_) {
						if otherBaseType == baseType {
							continue
						}
						baseSymbol := getPropertyOfObjectType(otherBaseType, base.escapedName)
						derivedElsewhere := baseSymbol && getTargetSymbol(baseSymbol)
						if derivedElsewhere && derivedElsewhere != base {
							continue basePropertyCheck
						}
					}
					baseTypeName := typeToString(baseType)
					typeName := typeToString(type_)
					basePropertyName := symbolToString(baseProperty)
					missedProperties := append(notImplementedInfo.get(derivedClassDecl). /* TODO(TS-TO-GO): was ? */ missedProperties, basePropertyName)
					notImplementedInfo.set(derivedClassDecl, map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"baseTypeName":     baseTypeName,
						"typeName":         typeName,
						"missedProperties": missedProperties,
					})
				}
			} else {
				// derived overrides base.
				derivedDeclarationFlags := getDeclarationModifierFlagsFromSymbol(derived)
				if baseDeclarationFlags&ModifierFlagsPrivate || derivedDeclarationFlags&ModifierFlagsPrivate {
					// either base or derived property is private - not override, skip it
					continue
				}
				var errorMessage DiagnosticMessage
				basePropertyFlags := base.flags & SymbolFlagsPropertyOrAccessor
				derivedPropertyFlags := derived.flags & SymbolFlagsPropertyOrAccessor
				if basePropertyFlags && derivedPropertyFlags {
					// property/accessor is overridden with property/accessor
					if (__COND__(getCheckFlags(base)&CheckFlagsSynthetic, base.declarations. /* TODO(TS-TO-GO): was ? */ some(func(d Declaration) bool {
						return isPropertyAbstractOrInterface(d, baseDeclarationFlags)
					}), base.declarations. /* TODO(TS-TO-GO): was ? */ every(func(d Declaration) bool {
						return isPropertyAbstractOrInterface(d, baseDeclarationFlags)
					}))) || getCheckFlags(base)&CheckFlagsMapped || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration) {
						// when the base property is abstract or from an interface, base/derived flags don't need to match
						// for intersection properties, this must be true of *any* of the declarations, for others it must be true of *all*
						// same when the derived property is from an assignment
						continue
					}
					overriddenInstanceProperty := basePropertyFlags != SymbolFlagsProperty && derivedPropertyFlags == SymbolFlagsProperty
					overriddenInstanceAccessor := basePropertyFlags == SymbolFlagsProperty && derivedPropertyFlags != SymbolFlagsProperty
					if overriddenInstanceProperty || overriddenInstanceAccessor {
						var errorMessage DiagnosticMessage
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case overriddenInstanceProperty:
							errorMessage = Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property
						default:
							errorMessage = Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor
						}
						error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType), typeToString(type_))
					} else if useDefineForClassFields {
						uninitialized := derived.declarations. /* TODO(TS-TO-GO): was ? */ find(func(d Declaration) bool {
							return d.kind == SyntaxKindPropertyDeclaration && !(d /* as PropertyDeclaration */).initializer
						})
						if uninitialized && !(derived.flags & SymbolFlagsTransient) && !(baseDeclarationFlags & ModifierFlagsAbstract) && !(derivedDeclarationFlags & ModifierFlagsAbstract) && !derived.declarations. /* TODO(TS-TO-GO): was ? */ some(func(d Declaration) bool {
							return !!(d.flags & NodeFlagsAmbient)
						}) {
							constructor := findConstructorDeclaration(getClassLikeDeclarationOfSymbol(type_.symbol))
							propName := (uninitialized /* as PropertyDeclaration */).name
							if (uninitialized /* as PropertyDeclaration */).exclamationToken || !constructor || !isIdentifier(propName) || !strictNullChecks || !isPropertyInitializedInConstructor(propName, type_, constructor) {
								errorMessage := Diagnostics.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration
								error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType))
							}
						}
					}
					// correct case
					continue
				} else if isPrototypeProperty(base) {
					if isPrototypeProperty(derived) || derived.flags&SymbolFlagsProperty {
						// method is overridden with method or property -- correct case
						continue
					} else {
						Debug.assert(!!(derived.flags & SymbolFlagsAccessor))
						errorMessage = Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor
					}
				} else if base.flags & SymbolFlagsAccessor {
					errorMessage = Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function
				} else {
					errorMessage = Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function
				}
				error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type_))
			}
		}
		for _, TODO_IDENTIFIER := range notImplementedInfo {
			if length(memberInfo.missedProperties) == 1 {
				if isClassExpression(errorNode) {
					error(errorNode, Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1, first(memberInfo.missedProperties), memberInfo.baseTypeName)
				} else {
					error(errorNode, Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2, memberInfo.typeName, first(memberInfo.missedProperties), memberInfo.baseTypeName)
				}
			} else if length(memberInfo.missedProperties) > 5 {
				missedProperties := map_(memberInfo.missedProperties.slice(0, 4), func(prop string) string {
					return __TEMPLATE__("'", prop, "'")
				}).join(", ")
				remainingMissedProperties := length(memberInfo.missedProperties) - 4
				if isClassExpression(errorNode) {
					error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1_and_2_more, memberInfo.baseTypeName, missedProperties, remainingMissedProperties)
				} else {
					error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2_and_3_more, memberInfo.typeName, memberInfo.baseTypeName, missedProperties, remainingMissedProperties)
				}
			} else {
				missedProperties := map_(memberInfo.missedProperties, func(prop string) string {
					return __TEMPLATE__("'", prop, "'")
				}).join(", ")
				if isClassExpression(errorNode) {
					error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1, memberInfo.baseTypeName, missedProperties)
				} else {
					error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2, memberInfo.typeName, memberInfo.baseTypeName, missedProperties)
				}
			}
		}
	}
	isPropertyAbstractOrInterface := func(declaration Declaration, baseDeclarationFlags ModifierFlags) bool {
		return baseDeclarationFlags&ModifierFlagsAbstract && (!isPropertyDeclaration(declaration) || !declaration.initializer) || isInterfaceDeclaration(declaration.parent)
	}
	getNonInheritedProperties := func(type_ InterfaceType, baseTypes []BaseType, properties []Symbol) []Symbol {
		if !length(baseTypes) {
			return properties
		}
		seen := NewMap[__String, Symbol]()
		forEach(properties, func(p Symbol) {
			seen.set(p.escapedName, p)
		})
		for _, base := range baseTypes {
			properties := getPropertiesOfType(getTypeWithThisArgument(base, type_.thisType))
			for _, prop := range properties {
				existing := seen.get(prop.escapedName)
				if existing && prop.parent == existing.parent {
					seen.delete(prop.escapedName)
				}
			}
		}
		return arrayFrom(seen.values())
	}
	checkInheritedPropertiesAreIdentical := func(type_ InterfaceType, typeNode Node) bool {
		baseTypes := getBaseTypes(type_)
		if baseTypes.length < 2 {
			return true
		}
		type InheritanceInfoMap struct {
			prop           Symbol
			containingType Type
		}
		seen := NewMap[__String, InheritanceInfoMap]()
		forEach(resolveDeclaredMembers(type_).declaredProperties, func(p Symbol) {
			seen.set(p.escapedName, map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"prop":           p,
				"containingType": type_,
			})
		})
		ok := true
		for _, base := range baseTypes {
			properties := getPropertiesOfType(getTypeWithThisArgument(base, type_.thisType))
			for _, prop := range properties {
				existing := seen.get(prop.escapedName)
				if !existing {
					seen.set(prop.escapedName, map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"prop":           prop,
						"containingType": base,
					})
				} else {
					isInheritedProperty := existing.containingType != type_
					if isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop) {
						ok = false
						typeName1 := typeToString(existing.containingType)
						typeName2 := typeToString(base)
						errorInfo := chainDiagnosticMessages(nil, Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical, symbolToString(prop), typeName1, typeName2)
						errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type_), typeName1, typeName2)
						diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(typeNode), typeNode, errorInfo))
					}
				}
			}
		}
		return ok
	}
	checkPropertyInitialization := func(node ClassLikeDeclaration) {
		if !strictNullChecks || !strictPropertyInitialization || node.flags&NodeFlagsAmbient {
			return
		}
		constructor := findConstructorDeclaration(node)
		for _, member := range node.members {
			if getEffectiveModifierFlags(member) & ModifierFlagsAmbient {
				continue
			}
			if !isStatic(member) && isPropertyWithoutInitializer(member) {
				propName := (member /* as PropertyDeclaration */).name
				if isIdentifier(propName) || isPrivateIdentifier(propName) || isComputedPropertyName(propName) {
					type_ := getTypeOfSymbol(getSymbolOfDeclaration(member))
					if !(type_.flags&TypeFlagsAnyOrUnknown || containsUndefinedType(type_)) {
						if !constructor || !isPropertyInitializedInConstructor(propName, type_, constructor) {
							error(member.name, Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor, declarationNameToString(propName))
						}
					}
				}
			}
		}
	}
	isPropertyWithoutInitializer := func(node Node) bool {
		return node.kind == SyntaxKindPropertyDeclaration && !hasAbstractModifier(node) && !(node /* as PropertyDeclaration */).exclamationToken && !(node /* as PropertyDeclaration */).initializer
	}
	isPropertyInitializedInStaticBlocks := func(propName /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier */ any, propType Type, staticBlocks []ClassStaticBlockDeclaration, startPos number, endPos number) bool {
		for _, staticBlock := range staticBlocks {
			// static block must be within the provided range as they are evaluated in document order (unlike constructors)
			if staticBlock.pos >= startPos && staticBlock.pos <= endPos {
				reference := factory.createPropertyAccessExpression(factory.createThis(), propName)
				setParent(reference.expression, reference)
				setParent(reference, staticBlock)
				reference.flowNode = staticBlock.returnFlowNode
				flowType := getFlowTypeOfReference(reference, propType, getOptionalType(propType))
				if !containsUndefinedType(flowType) {
					return true
				}
			}
		}
		return false
	}
	isPropertyInitializedInConstructor := func(propName /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier | ComputedPropertyName */ any, propType Type, constructor ConstructorDeclaration) bool {
		var reference /* TODO(TS-TO-GO) inferred type PropertyAccessExpression | ElementAccessExpression */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isComputedPropertyName(propName):
			reference = factory.createElementAccessExpression(factory.createThis(), propName.expression)
		default:
			reference = factory.createPropertyAccessExpression(factory.createThis(), propName)
		}
		setParent(reference.expression, reference)
		setParent(reference, constructor)
		reference.flowNode = constructor.returnFlowNode
		flowType := getFlowTypeOfReference(reference, propType, getOptionalType(propType))
		return !containsUndefinedType(flowType)
	}
	checkInterfaceDeclaration := func(node InterfaceDeclaration) {
		// Grammar checking
		if !checkGrammarModifiers(node) {
			checkGrammarInterfaceDeclaration(node)
		}
		checkTypeParameters(node.typeParameters)
		addLazyDiagnostic(func() {
			checkTypeNameIsReserved(node.name, Diagnostics.Interface_name_cannot_be_0)
			checkExportsOnMergedDeclarations(node)
			symbol := getSymbolOfDeclaration(node)
			checkTypeParameterListsIdentical(symbol)
			// Only check this symbol once
			firstInterfaceDecl := getDeclarationOfKind(symbol, SyntaxKindInterfaceDeclaration)
			if node == firstInterfaceDecl {
				type_ := getDeclaredTypeOfSymbol(symbol) /* as InterfaceType */
				typeWithThis := getTypeWithThisArgument(type_)
				// run subsequent checks only if first set succeeded
				if checkInheritedPropertiesAreIdentical(type_, node.name) {
					for _, baseType := range getBaseTypes(type_) {
						checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType, type_.thisType), node.name, Diagnostics.Interface_0_incorrectly_extends_interface_1)
					}
					checkIndexConstraints(type_, symbol)
				}
			}
			checkObjectTypeForDuplicateDeclarations(node)
		})
		forEach(getInterfaceBaseTypeNodes(node), func(heritageElement ExpressionWithTypeArguments) {
			if !isEntityNameExpression(heritageElement.expression) || isOptionalChain(heritageElement.expression) {
				error(heritageElement.expression, Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments)
			}
			checkTypeReferenceNode(heritageElement)
		})
		forEach(node.members, checkSourceElement)
		addLazyDiagnostic(func() {
			checkTypeForDuplicateIndexSignatures(node)
			registerForUnusedIdentifiersCheck(node)
		})
	}
	checkTypeAliasDeclaration := func(node TypeAliasDeclaration) {
		// Grammar checking
		checkGrammarModifiers(node)
		checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0)
		checkExportsOnMergedDeclarations(node)
		checkTypeParameters(node.typeParameters)
		if node.type_.kind == SyntaxKindIntrinsicKeyword {
			typeParameterCount := length(node.typeParameters)
			var valid bool
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case typeParameterCount == 0:
				valid = node.name.escapedText == "BuiltinIteratorReturn"
			default:
				valid = typeParameterCount == 1 && intrinsicTypeKinds.has(node.name.escapedText /* as string */)
			}
			if !valid {
				error(node.type_, Diagnostics.The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types)
			}
		} else {
			checkSourceElement(node.type_)
			registerForUnusedIdentifiersCheck(node)
		}
	}
	computeEnumMemberValues := func(node EnumDeclaration) {
		nodeLinks := getNodeLinks(node)
		if !(nodeLinks.flags & NodeCheckFlagsEnumValuesComputed) {
			nodeLinks.flags |= NodeCheckFlagsEnumValuesComputed
			var autoValue *number = 0
			var previous *EnumMember
			for _, member := range node.members {
				result := computeEnumMemberValue(member, autoValue, previous)
				getNodeLinks(member).enumMemberValue = result
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case /* TODO(TS-TO-GO) Node TypeOfExpression: typeof result.value */ TODO == "number":
					autoValue = result.value + 1
				default:
					autoValue = nil
				}
				previous = member
			}
		}
	}
	computeEnumMemberValue := func(member EnumMember, autoValue *number, previous *EnumMember) EvaluatorResult {
		if isComputedNonLiteralName(member.name) {
			error(member.name, Diagnostics.Computed_property_names_are_not_allowed_in_enums)
		} else {
			text := getTextOfPropertyName(member.name)
			if isNumericLiteralName(text) && !isInfinityOrNaNString(text) {
				error(member.name, Diagnostics.An_enum_member_cannot_have_a_numeric_name)
			}
		}
		if member.initializer {
			return computeConstantEnumMemberValue(member)
		}
		// In ambient non-const numeric enum declarations, enum members without initializers are
		// considered computed members (as opposed to having auto-incremented values).
		if member.parent.flags&NodeFlagsAmbient && !isEnumConst(member.parent) {
			return evaluatorResult(nil)
		}
		// If the member declaration specifies no value, the member is considered a constant enum member.
		// If the member is the first member in the enum declaration, it is assigned the value zero.
		// Otherwise, it is assigned the value of the immediately preceding member plus one, and an error
		// occurs if the immediately preceding member is not a constant enum member.
		if autoValue == nil {
			error(member.name, Diagnostics.Enum_member_must_have_initializer)
			return evaluatorResult(nil)
		}
		if getIsolatedModules(compilerOptions) && previous. /* TODO(TS-TO-GO): was ? */ initializer {
			prevValue := getEnumMemberValue(previous)
			if !( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof prevValue.value */ TODO == "number" && !prevValue.resolvedOtherFiles) {
				error(member.name, Diagnostics.Enum_member_following_a_non_literal_numeric_member_must_have_an_initializer_when_isolatedModules_is_enabled)
			}
		}
		return evaluatorResult(autoValue)
	}
	computeConstantEnumMemberValue := func(member EnumMember) EvaluatorResult {
		isConstEnum := isEnumConst(member.parent)
		initializer := member.initializer
		result := evaluate(initializer, member)
		if result.value != nil {
			if isConstEnum && /* TODO(TS-TO-GO) Node TypeOfExpression: typeof result.value */ TODO == "number" && !isFinite(result.value) {
				error(initializer, __COND__(isNaN(result.value), Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN, Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value))
			} else if getIsolatedModules(compilerOptions) && /* TODO(TS-TO-GO) Node TypeOfExpression: typeof result.value */ TODO == "string" && !result.isSyntacticallyString {
				error(initializer, Diagnostics._0_has_a_string_type_but_must_have_syntactically_recognizable_string_syntax_when_isolatedModules_is_enabled, __TEMPLATE__(idText(member.parent.name), ".", getTextOfPropertyName(member.name)))
			}
		} else if isConstEnum {
			error(initializer, Diagnostics.const_enum_member_initializers_must_be_constant_expressions)
		} else if member.parent.flags & NodeFlagsAmbient {
			error(initializer, Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression)
		} else {
			checkTypeAssignableTo(checkExpression(initializer), numberType, initializer, Diagnostics.Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values)
		}
		return result
	}
	evaluateEntityNameExpression := func(expr EntityNameExpression, location Declaration) /* TODO(TS-TO-GO) inferred type EvaluatorResult<string | number | undefined> */ any {
		symbol := resolveEntityName(expr, SymbolFlagsValue /*ignoreErrors*/, true)
		if !symbol {
			return evaluatorResult(nil)
		}
		if expr.kind == SyntaxKindIdentifier {
			identifier := expr
			if isInfinityOrNaNString(identifier.escapedText) && (symbol == getGlobalSymbol(identifier.escapedText, SymbolFlagsValue /*diagnostic*/, nil)) {
				// Technically we resolved a global lib file here, but the decision to treat this as numeric
				// is more predicated on the fact that the single-file resolution *didn't* resolve to a
				// different meaning of `Infinity` or `NaN`. Transpilers handle this no problem.
				return evaluatorResult(+(identifier.escapedText) /*isSyntacticallyString*/, false)
			}
		}
		if symbol.flags & SymbolFlagsEnumMember {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case location:
				return evaluateEnumMember(expr, symbol, location)
			default:
				return getEnumMemberValue(symbol.valueDeclaration /* as EnumMember */)
			}
		}
		if isConstantVariable(symbol) {
			declaration := symbol.valueDeclaration
			if declaration && isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && (!location || declaration != location && isBlockScopedNameDeclaredBeforeUse(declaration, location)) {
				result := evaluate(declaration.initializer, declaration)
				if location && getSourceFileOfNode(location) != getSourceFileOfNode(declaration) {
					return evaluatorResult(result.value, false, true, true)
				}
				return evaluatorResult(result.value, result.isSyntacticallyString, result.resolvedOtherFiles /*hasExternalReferences*/, true)
			}
		}
		return evaluatorResult(nil)
	}
	evaluateElementAccessExpression := func(expr ElementAccessExpression, location Declaration) /* TODO(TS-TO-GO) inferred type EvaluatorResult<string | number | undefined> */ any {
		root := expr.expression
		if isEntityNameExpression(root) && isStringLiteralLike(expr.argumentExpression) {
			rootSymbol := resolveEntityName(root, SymbolFlagsValue /*ignoreErrors*/, true)
			if rootSymbol && rootSymbol.flags&SymbolFlagsEnum {
				name := escapeLeadingUnderscores(expr.argumentExpression.text)
				member := rootSymbol.exports.get(name)
				if member {
					Debug.assert(getSourceFileOfNode(member.valueDeclaration) == getSourceFileOfNode(rootSymbol.valueDeclaration))
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case location:
						return evaluateEnumMember(expr, member, location)
					default:
						return getEnumMemberValue(member.valueDeclaration /* as EnumMember */)
					}
				}
			}
		}
		return evaluatorResult(nil)
	}
	evaluateEnumMember := func(expr Expression, symbol Symbol, location Declaration) /* TODO(TS-TO-GO) inferred type EvaluatorResult<string | number | undefined> */ any {
		declaration := symbol.valueDeclaration
		if !declaration || declaration == location {
			error(expr, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(symbol))
			return evaluatorResult(nil)
		}
		if !isBlockScopedNameDeclaredBeforeUse(declaration, location) {
			error(expr, Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums)
			return evaluatorResult(0)
		}
		value := getEnumMemberValue(declaration /* as EnumMember */)
		if location.parent != declaration.parent {
			return evaluatorResult(value.value, value.isSyntacticallyString, value.resolvedOtherFiles /*hasExternalReferences*/, true)
		}
		return value
	}
	checkEnumDeclaration := func(node EnumDeclaration) {
		addLazyDiagnostic(func() {
			return checkEnumDeclarationWorker(node)
		})
	}
	checkEnumDeclarationWorker := func(node EnumDeclaration) {
		// Grammar checking
		checkGrammarModifiers(node)
		checkCollisionsForDeclarationName(node, node.name)
		checkExportsOnMergedDeclarations(node)
		node.members.forEach(checkEnumMember)
		computeEnumMemberValues(node)
		// Spec 2014 - Section 9.3:
		// It isn't possible for one enum declaration to continue the automatic numbering sequence of another,
		// and when an enum type has multiple declarations, only one declaration is permitted to omit a value
		// for the first member.
		//
		// Only perform this check once per symbol
		enumSymbol := getSymbolOfDeclaration(node)
		firstDeclaration := getDeclarationOfKind(enumSymbol, node.kind)
		if node == firstDeclaration {
			if enumSymbol.declarations && enumSymbol.declarations.length > 1 {
				enumIsConst := isEnumConst(node)
				// check that const is placed\omitted on all enum declarations
				forEach(enumSymbol.declarations, func(decl Declaration) {
					if isEnumDeclaration(decl) && isEnumConst(decl) != enumIsConst {
						error(getNameOfDeclaration(decl), Diagnostics.Enum_declarations_must_all_be_const_or_non_const)
					}
				})
			}
			seenEnumMissingInitialInitializer := false
			forEach(enumSymbol.declarations, func(declaration Declaration) *false {
				// return true if we hit a violation of the rule, false otherwise
				if declaration.kind != SyntaxKindEnumDeclaration {
					return false
				}
				enumDeclaration := declaration /* as EnumDeclaration */
				if !enumDeclaration.members.length {
					return false
				}
				firstEnumMember := enumDeclaration.members[0]
				if !firstEnumMember.initializer {
					if seenEnumMissingInitialInitializer {
						error(firstEnumMember.name, Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element)
					} else {
						seenEnumMissingInitialInitializer = true
					}
				}
			})
		}
	}
	checkEnumMember := func(node EnumMember) {
		if isPrivateIdentifier(node.name) {
			error(node, Diagnostics.An_enum_member_cannot_be_named_with_a_private_identifier)
		}
		if node.initializer {
			checkExpression(node.initializer)
		}
	}
	getFirstNonAmbientClassOrFunctionDeclaration := func(symbol Symbol) Declaration {
		declarations := symbol.declarations
		if declarations {
			for _, declaration := range declarations {
				if (declaration.kind == SyntaxKindClassDeclaration || (declaration.kind == SyntaxKindFunctionDeclaration && nodeIsPresent((declaration /* as FunctionLikeDeclaration */).body))) && !(declaration.flags & NodeFlagsAmbient) {
					return declaration
				}
			}
		}
		return nil
	}
	inSameLexicalScope := func(node1 Node, node2 Node) bool {
		container1 := getEnclosingBlockScopeContainer(node1)
		container2 := getEnclosingBlockScopeContainer(node2)
		if isGlobalSourceFile(container1) {
			return isGlobalSourceFile(container2)
		} else if isGlobalSourceFile(container2) {
			return false
		} else {
			return container1 == container2
		}
	}
	checkModuleDeclaration := func(node ModuleDeclaration) {
		if node.body {
			checkSourceElement(node.body)
			if !isGlobalScopeAugmentation(node) {
				registerForUnusedIdentifiersCheck(node)
			}
		}
		addLazyDiagnostic(checkModuleDeclarationDiagnostics)
		checkModuleDeclarationDiagnostics := func() {
			// Grammar checking
			isGlobalAugmentation := isGlobalScopeAugmentation(node)
			inAmbientContext := node.flags & NodeFlagsAmbient
			if isGlobalAugmentation && !inAmbientContext {
				error(node.name, Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context)
			}
			var isAmbientExternalModule bool = isAmbientModule(node)
			var contextErrorMessage DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isAmbientExternalModule:
				contextErrorMessage = Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file
			default:
				contextErrorMessage = Diagnostics.A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module
			}
			if checkGrammarModuleElementContext(node, contextErrorMessage) {
				// If we hit a module declaration in an illegal context, just bail out to avoid cascading errors.
				return
			}
			if !checkGrammarModifiers(node) {
				if !inAmbientContext && node.name.kind == SyntaxKindStringLiteral {
					grammarErrorOnNode(node.name, Diagnostics.Only_ambient_modules_can_use_quoted_names)
				}
			}
			if isIdentifier(node.name) {
				checkCollisionsForDeclarationName(node, node.name)
				if !(node.flags & (NodeFlagsNamespace | NodeFlagsGlobalAugmentation)) {
					sourceFile := getSourceFileOfNode(node)
					pos := getNonModifierTokenPosOfNode(node)
					span := getSpanOfTokenAtPosition(sourceFile, pos)
					suggestionDiagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.A_namespace_declaration_should_not_be_declared_using_the_module_keyword_Please_use_the_namespace_keyword_instead))
				}
			}
			checkExportsOnMergedDeclarations(node)
			symbol := getSymbolOfDeclaration(node)
			// The following checks only apply on a non-ambient instantiated module declaration.
			if symbol.flags&SymbolFlagsValueModule && !inAmbientContext && isInstantiatedModule(node, shouldPreserveConstEnums(compilerOptions)) {
				if getIsolatedModules(compilerOptions) && !getSourceFileOfNode(node).externalModuleIndicator {
					// This could be loosened a little if needed. The only problem we are trying to avoid is unqualified
					// references to namespace members declared in other files. But use of namespaces is discouraged anyway,
					// so for now we will just not allow them in scripts, which is the only place they can merge cross-file.
					error(node.name, Diagnostics.Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement, isolatedModulesLikeFlagName)
				}
				if symbol.declarations. /* TODO(TS-TO-GO): was ? */ length > 1 {
					firstNonAmbientClassOrFunc := getFirstNonAmbientClassOrFunctionDeclaration(symbol)
					if firstNonAmbientClassOrFunc {
						if getSourceFileOfNode(node) != getSourceFileOfNode(firstNonAmbientClassOrFunc) {
							error(node.name, Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged)
						} else if node.pos < firstNonAmbientClassOrFunc.pos {
							error(node.name, Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged)
						}
					}
					// if the module merges with a class declaration in the same lexical scope,
					// we need to track this to ensure the correct emit.
					mergedClass := getDeclarationOfKind(symbol, SyntaxKindClassDeclaration)
					if mergedClass && inSameLexicalScope(node, mergedClass) {
						getNodeLinks(node).flags |= NodeCheckFlagsLexicalModuleMergesWithClass
					}
				}
				if compilerOptions.verbatimModuleSyntax && node.parent.kind == SyntaxKindSourceFile && host.getEmitModuleFormatOfFile(node.parent) == ModuleKindCommonJS {
					exportModifier := node.modifiers. /* TODO(TS-TO-GO): was ? */ find(func(m ModifierLike) bool {
						return m.kind == SyntaxKindExportKeyword
					})
					if exportModifier {
						error(exportModifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
					}
				}
			}
			if isAmbientExternalModule {
				if isExternalModuleAugmentation(node) {
					// body of the augmentation should be checked for consistency only if augmentation was applied to its target (either global scope or module)
					// otherwise we'll be swamped in cascading errors.
					// We can detect if augmentation was applied using following rules:
					// - augmentation for a global scope is always applied
					// - augmentation for some external module is applied if symbol for augmentation is merged (it was combined with target module).
					checkBody := isGlobalAugmentation || (getSymbolOfDeclaration(node).flags & SymbolFlagsTransient)
					if checkBody && node.body {
						for _, statement := range node.body.statements {
							checkModuleAugmentationElement(statement, isGlobalAugmentation)
						}
					}
				} else if isGlobalSourceFile(node.parent) {
					if isGlobalAugmentation {
						error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations)
					} else if isExternalModuleNameRelative(getTextOfIdentifierOrLiteral(node.name)) {
						error(node.name, Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name)
					}
				} else {
					if isGlobalAugmentation {
						error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations)
					} else {
						// Node is not an augmentation and is not located on the script level.
						// This means that this is declaration of ambient module that is located in other module or namespace which is prohibited.
						error(node.name, Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces)
					}
				}
			}
		}
	}
	checkModuleAugmentationElement := func(node Node, isGlobalAugmentation bool) {
		switch node.kind {
		case SyntaxKindVariableStatement:
			for _, decl := range (node /* as VariableStatement */).declarationList.declarations {
				checkModuleAugmentationElement(decl, isGlobalAugmentation)
			}
			break
		case SyntaxKindExportAssignment:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindExportDeclaration:
			grammarErrorOnFirstToken(node, Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations)
			break
		case SyntaxKindImportEqualsDeclaration:
			if isInternalModuleImportEqualsDeclaration(node) {
				break
			}
			fallthrough
		case SyntaxKindImportDeclaration:
			grammarErrorOnFirstToken(node, Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module)
			break
		case SyntaxKindBindingElement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindVariableDeclaration:
			name := (node /* as VariableDeclaration | BindingElement */).name
			if isBindingPattern(name) {
				for _, el := range name.elements {
					// mark individual names in binding pattern
					checkModuleAugmentationElement(el, isGlobalAugmentation)
				}
				break
			}
			fallthrough
		case SyntaxKindClassDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindEnumDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindInterfaceDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindModuleDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTypeAliasDeclaration:
			if isGlobalAugmentation {
				return
			}
			break
		}
	}
	getFirstNonModuleExportsIdentifier := func(node EntityNameOrEntityNameExpression) Identifier {
		switch node.kind {
		case SyntaxKindIdentifier:
			return node
		case SyntaxKindQualifiedName:
			// TODO(TS-TO-GO): refactor do-while loop approximation
			for ok := true; ok; ok = node.kind != SyntaxKindIdentifier {
				node = node.left
			}
			return node
		case SyntaxKindPropertyAccessExpression:
			// TODO(TS-TO-GO): refactor do-while loop approximation
			for ok := true; ok; ok = node.kind != SyntaxKindIdentifier {
				if isModuleExportsAccessExpression(node.expression) && !isPrivateIdentifier(node.name) {
					return node.name
				}
				node = node.expression
			}
			return node
		}
	}
	checkExternalImportOrExportDeclaration := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration */ any) bool {
		moduleName := getExternalModuleName(node)
		if !moduleName || nodeIsMissing(moduleName) {
			// Should be a parse error.
			return false
		}
		if !isStringLiteral(moduleName) {
			error(moduleName, Diagnostics.String_literal_expected)
			return false
		}
		inAmbientExternalModule := node.parent.kind == SyntaxKindModuleBlock && isAmbientModule(node.parent.parent)
		if node.parent.kind != SyntaxKindSourceFile && !inAmbientExternalModule {
			error(moduleName, __COND__(node.kind == SyntaxKindExportDeclaration, Diagnostics.Export_declarations_are_not_permitted_in_a_namespace, Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module))
			return false
		}
		if inAmbientExternalModule && isExternalModuleNameRelative(moduleName.text) {
			// we have already reported errors on top level imports/exports in external module augmentations in checkModuleDeclaration
			// no need to do this again.
			if !isTopLevelInExternalModuleAugmentation(node) {
				// TypeScript 1.0 spec (April 2013): 12.1.6
				// An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference
				// other external modules only through top - level external module names.
				// Relative external module names are not permitted.
				error(node, Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name)
				return false
			}
		}
		if !isImportEqualsDeclaration(node) && node.attributes {
			var diagnostic DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node.attributes.token == SyntaxKindWithKeyword:
				diagnostic = Diagnostics.Import_attribute_values_must_be_string_literal_expressions
			default:
				diagnostic = Diagnostics.Import_assertion_values_must_be_string_literal_expressions
			}
			hasError := false
			for _, attr := range node.attributes.elements {
				if !isStringLiteral(attr.value) {
					hasError = true
					error(attr.value, diagnostic)
				}
			}
			return !hasError
		}
		return true
	}
	checkModuleExportName := func(name *ModuleExportName, allowStringLiteral bool /*  = true */) {
		if name == nil || name.kind != SyntaxKindStringLiteral {
			return
		}
		if !allowStringLiteral {
			grammarErrorOnNode(name, Diagnostics.Identifier_expected)
		} else if moduleKind == ModuleKindES2015 || moduleKind == ModuleKindES2020 {
			grammarErrorOnNode(name, Diagnostics.String_literal_import_and_export_names_are_not_supported_when_the_module_flag_is_set_to_es2015_or_es2020)
		}
	}
	checkAliasSymbol := func(node AliasDeclarationNode) {
		symbol := getSymbolOfDeclaration(node)
		target := resolveAlias(symbol)
		if target != unknownSymbol {
			// For external modules, `symbol` represents the local symbol for an alias.
			// This local symbol will merge any other local declarations (excluding other aliases)
			// and symbol.flags will contains combined representation for all merged declaration.
			// Based on symbol.flags we can compute a set of excluded meanings (meaning that resolved alias should not have,
			// otherwise it will conflict with some local declaration). Note that in addition to normal flags we include matching SymbolFlags.Export*
			// in order to prevent collisions with declarations that were exported from the current module (they still contribute to local names).
			symbol = getMergedSymbol(symbol.exportSymbol || symbol)
			// A type-only import/export will already have a grammar error in a JS file, so no need to issue more errors within
			if isInJSFile(node) && !(target.flags & SymbolFlagsValue) && !isTypeOnlyImportOrExportDeclaration(node) {
				var errorNode /* TODO(TS-TO-GO) inferred type ObjectBindingPattern | ArrayBindingPattern | ImportClause | ModuleExportName */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isImportOrExportSpecifier(node):
					errorNode = node.propertyName || node.name
				case isNamedDeclaration(node):
					errorNode = node.name
				default:
					errorNode = node
				}
				Debug.assert(node.kind != SyntaxKindNamespaceExport)
				if node.kind == SyntaxKindExportSpecifier {
					diag := error(errorNode, Diagnostics.Types_cannot_appear_in_export_declarations_in_JavaScript_files)
					alreadyExportedSymbol := getSourceFileOfNode(node).symbol. /* TODO(TS-TO-GO): was ? */ exports. /* TODO(TS-TO-GO): was ? */ get(moduleExportNameTextEscaped(node.propertyName || node.name))
					if alreadyExportedSymbol == target {
						exportingDeclaration := alreadyExportedSymbol.declarations. /* TODO(TS-TO-GO): was ? */ find(isJSDocNode)
						if exportingDeclaration {
							addRelatedInfo(diag, createDiagnosticForNode(exportingDeclaration, Diagnostics._0_is_automatically_exported_here, unescapeLeadingUnderscores(alreadyExportedSymbol.escapedName)))
						}
					}
				} else {
					Debug.assert(node.kind != SyntaxKindVariableDeclaration)
					importDeclaration := findAncestor(node, or(isImportDeclaration, isImportEqualsDeclaration))
					moduleSpecifier := /* TODO(TS-TO-GO) Node BinaryExpression: (importDeclaration && tryGetModuleSpecifierFromDeclaration(importDeclaration)?.text) ?? "..." */ TODO
					importedIdentifier := unescapeLeadingUnderscores(__COND__(isIdentifier(errorNode), errorNode.escapedText, symbol.escapedName))
					error(errorNode, Diagnostics._0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation, importedIdentifier, __TEMPLATE__("import(\"", moduleSpecifier, "\").", importedIdentifier))
				}
				return
			}
			targetFlags := getSymbolFlags(target)
			excludedMeanings := (__COND__(symbol.flags&(SymbolFlagsValue|SymbolFlagsExportValue), SymbolFlagsValue, 0)) | (__COND__(symbol.flags&SymbolFlagsType, SymbolFlagsType, 0)) | (__COND__(symbol.flags&SymbolFlagsNamespace, SymbolFlagsNamespace, 0))
			if targetFlags & excludedMeanings {
				var message DiagnosticMessage
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case node.kind == SyntaxKindExportSpecifier:
					message = Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0
				default:
					message = Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0
				}
				error(node, message, symbolToString(symbol))
			} else if node.kind != SyntaxKindExportSpecifier {
				// Look at 'compilerOptions.isolatedModules' and not 'getIsolatedModules(...)' (which considers 'verbatimModuleSyntax')
				// here because 'verbatimModuleSyntax' will already have an error for importing a type without 'import type'.
				appearsValueyToTranspiler := compilerOptions.isolatedModules && !findAncestor(node, isTypeOnlyImportOrExportDeclaration)
				if appearsValueyToTranspiler && symbol.flags&(SymbolFlagsValue|SymbolFlagsExportValue) {
					error(node, Diagnostics.Import_0_conflicts_with_local_value_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, symbolToString(symbol), isolatedModulesLikeFlagName)
				}
			}
			if getIsolatedModules(compilerOptions) && !isTypeOnlyImportOrExportDeclaration(node) && !(node.flags & NodeFlagsAmbient) {
				typeOnlyAlias := getTypeOnlyAliasDeclaration(symbol)
				isType := !(targetFlags & SymbolFlagsValue)
				if isType || typeOnlyAlias {
					switch node.kind {
					case SyntaxKindImportClause:
						fallthrough // TODO(TS-TO-GO): merge cases
					case SyntaxKindImportSpecifier:
						fallthrough // TODO(TS-TO-GO): merge cases
					case SyntaxKindImportEqualsDeclaration:
						if compilerOptions.verbatimModuleSyntax {
							Debug.assertIsDefined(node.name, "An ImportClause with a symbol should have a name")
							var message DiagnosticMessage
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case compilerOptions.verbatimModuleSyntax && isInternalModuleImportEqualsDeclaration(node):
								message = Diagnostics.An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled
							case isType:
								message = Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled
							default:
								message = Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled
							}
							name := moduleExportNameTextUnescaped(__COND__(node.kind == SyntaxKindImportSpecifier, node.propertyName || node.name, node.name))
							addTypeOnlyDeclarationRelatedInfo(error(node, message, name), __COND__(isType, nil, typeOnlyAlias), name)
						}
						if isType && node.kind == SyntaxKindImportEqualsDeclaration && hasEffectiveModifier(node, ModifierFlagsExport) {
							error(node, Diagnostics.Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled, isolatedModulesLikeFlagName)
						}
						break
						fallthrough
					case SyntaxKindExportSpecifier:
						// Don't allow re-exporting an export that will be elided when `--isolatedModules` is set.
						// The exception is that `import type { A } from './a'; export { A }` is allowed
						// because single-file analysis can determine that the export should be dropped.
						if compilerOptions.verbatimModuleSyntax || getSourceFileOfNode(typeOnlyAlias) != getSourceFileOfNode(node) {
							name := moduleExportNameTextUnescaped(node.propertyName || node.name)
							var diagnostic Diagnostic
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case isType:
								diagnostic = error(node, Diagnostics.Re_exporting_a_type_when_0_is_enabled_requires_using_export_type, isolatedModulesLikeFlagName)
							default:
								diagnostic = error(node, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled, name, isolatedModulesLikeFlagName)
							}
							addTypeOnlyDeclarationRelatedInfo(diagnostic, __COND__(isType, nil, typeOnlyAlias), name)
							break
						}
					}
				}
				if compilerOptions.verbatimModuleSyntax && node.kind != SyntaxKindImportEqualsDeclaration && !isInJSFile(node) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
					error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
				} else if moduleKind == ModuleKindPreserve && node.kind != SyntaxKindImportEqualsDeclaration && node.kind != SyntaxKindVariableDeclaration && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
					// In `--module preserve`, ESM input syntax emits ESM output syntax, but there will be times
					// when we look at the `impliedNodeFormat` of this file and decide it's CommonJS (i.e., currently,
					// only if the file extension is .cjs/.cts). To avoid that inconsistency, we disallow ESM syntax
					// in files that are unambiguously CommonJS in this mode.
					error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_module_is_set_to_preserve)
				}
				if compilerOptions.verbatimModuleSyntax && !isTypeOnlyImportOrExportDeclaration(node) && !(node.flags & NodeFlagsAmbient) && targetFlags&SymbolFlagsConstEnum {
					constEnumDeclaration := target.valueDeclaration /* as EnumDeclaration */
					redirect := host.getRedirectReferenceForResolutionFromSourceOfProject(getSourceFileOfNode(constEnumDeclaration).resolvedPath)
					if constEnumDeclaration.flags&NodeFlagsAmbient && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) {
						error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName)
					}
				}
			}
			if isImportSpecifier(node) {
				targetSymbol := resolveAliasWithDeprecationCheck(symbol, node)
				if isDeprecatedSymbol(targetSymbol) && targetSymbol.declarations {
					addDeprecatedSuggestion(node, targetSymbol.declarations, targetSymbol.escapedName /* as string */)
				}
			}
		}
	}
	resolveAliasWithDeprecationCheck := func(symbol Symbol, location Node) Symbol {
		if !(symbol.flags & SymbolFlagsAlias) || isDeprecatedSymbol(symbol) || !getDeclarationOfAliasSymbol(symbol) {
			return symbol
		}
		targetSymbol := resolveAlias(symbol)
		if targetSymbol == unknownSymbol {
			return targetSymbol
		}
		for symbol.flags & SymbolFlagsAlias {
			target := getImmediateAliasedSymbol(symbol)
			if target {
				if target == targetSymbol {
					break
				}
				if target.declarations && length(target.declarations) {
					if isDeprecatedSymbol(target) {
						addDeprecatedSuggestion(location, target.declarations, target.escapedName /* as string */)
						break
					} else {
						if symbol == targetSymbol {
							break
						}
						symbol = target
					}
				}
			} else {
				break
			}
		}
		return targetSymbol
	}
	checkImportBinding := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportSpecifier */ any) {
		checkCollisionsForDeclarationName(node, node.name)
		checkAliasSymbol(node)
		if node.kind == SyntaxKindImportSpecifier {
			checkModuleExportName(node.propertyName)
			if moduleExportNameIsDefault(node.propertyName || node.name) && getESModuleInterop(compilerOptions) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem {
				checkExternalEmitHelpers(node, ExternalEmitHelpersImportDefault)
			}
		}
	}
	checkImportAttributes := func(declaration /* TODO(TS-TO-GO) TypeNode UnionType: ImportDeclaration | ExportDeclaration | JSDocImportTag */ any) *bool {
		node := declaration.attributes
		if node {
			importAttributesType := getGlobalImportAttributesType(true)
			if importAttributesType != emptyObjectType {
				checkTypeAssignableTo(getTypeFromImportAttributes(node), getNullableType(importAttributesType, TypeFlagsUndefined), node)
			}
			validForTypeAttributes := isExclusivelyTypeOnlyImportOrExport(declaration)
			override := getResolutionModeOverride(node, __COND__(validForTypeAttributes, grammarErrorOnNode, nil))
			isImportAttributes := declaration.attributes.token == SyntaxKindWithKeyword
			if validForTypeAttributes && override {
				return
				// Other grammar checks do not apply to type-only imports with resolution mode assertions
			}
			mode := (moduleKind == ModuleKindNodeNext) && declaration.moduleSpecifier && getEmitSyntaxForModuleSpecifierExpression(declaration.moduleSpecifier)
			if mode != ModuleKindESNext && moduleKind != ModuleKindESNext && moduleKind != ModuleKindPreserve {
				var message DiagnosticMessage
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isImportAttributes:
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case moduleKind == ModuleKindNodeNext:
						message = Diagnostics.Import_attributes_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls
					default:
						message = Diagnostics.Import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve
					}
				case moduleKind == ModuleKindNodeNext:
					message = Diagnostics.Import_assertions_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls
				default:
					message = Diagnostics.Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve
				}
				return grammarErrorOnNode(node, message)
			}
			isTypeOnly := isJSDocImportTag(declaration) || (__COND__(isImportDeclaration(declaration), declaration.importClause. /* TODO(TS-TO-GO): was ? */ isTypeOnly, declaration.isTypeOnly))
			if isTypeOnly {
				return grammarErrorOnNode(node, __COND__(isImportAttributes, Diagnostics.Import_attributes_cannot_be_used_with_type_only_imports_or_exports, Diagnostics.Import_assertions_cannot_be_used_with_type_only_imports_or_exports))
			}
			if override {
				return grammarErrorOnNode(node, Diagnostics.resolution_mode_can_only_be_set_for_type_only_imports)
			}
		}
	}
	checkImportAttribute := func(node ImportAttribute) Type {
		return getRegularTypeOfLiteralType(checkExpressionCached(node.value))
	}
	checkImportDeclaration := func(node ImportDeclaration) {
		if checkGrammarModuleElementContext(node, __COND__(isInJSFile(node), Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module, Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
			// If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
			return
		}
		if !checkGrammarModifiers(node) && node.modifiers {
			grammarErrorOnFirstToken(node, Diagnostics.An_import_declaration_cannot_have_modifiers)
		}
		if checkExternalImportOrExportDeclaration(node) {
			importClause := node.importClause
			if importClause && !checkGrammarImportClause(importClause) {
				if importClause.name {
					checkImportBinding(importClause)
				}
				if importClause.namedBindings {
					if importClause.namedBindings.kind == SyntaxKindNamespaceImport {
						checkImportBinding(importClause.namedBindings)
						if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && getESModuleInterop(compilerOptions) {
							// import * as ns from "foo";
							checkExternalEmitHelpers(node, ExternalEmitHelpersImportStar)
						}
					} else {
						moduleExisted := resolveExternalModuleName(node, node.moduleSpecifier)
						if moduleExisted {
							forEach(importClause.namedBindings.elements, checkImportBinding)
						}
					}
				}
			} else if noUncheckedSideEffectImports && !importClause {
				resolveExternalModuleName(node, node.moduleSpecifier)
			}
		}
		checkImportAttributes(node)
	}
	checkImportEqualsDeclaration := func(node ImportEqualsDeclaration) {
		if checkGrammarModuleElementContext(node, __COND__(isInJSFile(node), Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module, Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
			// If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
			return
		}
		checkGrammarModifiers(node)
		if isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(node) {
			checkImportBinding(node)
			markLinkedReferences(node, ReferenceHintExportImportEquals)
			if node.moduleReference.kind != SyntaxKindExternalModuleReference {
				target := resolveAlias(getSymbolOfDeclaration(node))
				if target != unknownSymbol {
					targetFlags := getSymbolFlags(target)
					if targetFlags & SymbolFlagsValue {
						// Target is a value symbol, check that it is not hidden by a local declaration with the same name
						moduleName := getFirstIdentifier(node.moduleReference)
						if !(resolveEntityName(moduleName, SymbolFlagsValue|SymbolFlagsNamespace).flags & SymbolFlagsNamespace) {
							error(moduleName, Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, declarationNameToString(moduleName))
						}
					}
					if targetFlags & SymbolFlagsType {
						checkTypeNameIsReserved(node.name, Diagnostics.Import_name_cannot_be_0)
					}
				}
				if node.isTypeOnly {
					grammarErrorOnNode(node, Diagnostics.An_import_alias_cannot_use_import_type)
				}
			} else {
				if ModuleKindES2015 <= moduleKind && moduleKind <= ModuleKindESNext && !node.isTypeOnly && !(node.flags & NodeFlagsAmbient) {
					// Import equals declaration cannot be emitted as ESM
					grammarErrorOnNode(node, Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead)
				}
			}
		}
	}
	checkExportDeclaration := func(node ExportDeclaration) {
		if checkGrammarModuleElementContext(node, __COND__(isInJSFile(node), Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_module, Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
			// If we hit an export in an illegal context, just bail out to avoid cascading errors.
			return
		}
		if !checkGrammarModifiers(node) && hasSyntacticModifiers(node) {
			grammarErrorOnFirstToken(node, Diagnostics.An_export_declaration_cannot_have_modifiers)
		}
		checkGrammarExportDeclaration(node)
		if !node.moduleSpecifier || checkExternalImportOrExportDeclaration(node) {
			if node.exportClause && !isNamespaceExport(node.exportClause) {
				// export { x, y }
				// export { x, y } from "foo"
				forEach(node.exportClause.elements, checkExportSpecifier)
				inAmbientExternalModule := node.parent.kind == SyntaxKindModuleBlock && isAmbientModule(node.parent.parent)
				inAmbientNamespaceDeclaration := !inAmbientExternalModule && node.parent.kind == SyntaxKindModuleBlock && !node.moduleSpecifier && node.flags&NodeFlagsAmbient
				if node.parent.kind != SyntaxKindSourceFile && !inAmbientExternalModule && !inAmbientNamespaceDeclaration {
					error(node, Diagnostics.Export_declarations_are_not_permitted_in_a_namespace)
				}
			} else {
				// export * from "foo"
				// export * as ns from "foo";
				moduleSymbol := resolveExternalModuleName(node, node.moduleSpecifier)
				if moduleSymbol && hasExportAssignmentSymbol(moduleSymbol) {
					error(node.moduleSpecifier, Diagnostics.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk, symbolToString(moduleSymbol))
				} else if node.exportClause {
					checkAliasSymbol(node.exportClause)
					checkModuleExportName(node.exportClause.name)
				}
				if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem {
					if node.exportClause {
						// export * as ns from "foo";
						// For ES2015 modules, we emit it as a pair of `import * as a_1 ...; export { a_1 as ns }` and don't need the helper.
						// We only use the helper here when in esModuleInterop
						if getESModuleInterop(compilerOptions) {
							checkExternalEmitHelpers(node, ExternalEmitHelpersImportStar)
						}
					} else {
						// export * from "foo"
						checkExternalEmitHelpers(node, ExternalEmitHelpersExportStar)
					}
				}
			}
		}
		checkImportAttributes(node)
	}
	checkGrammarExportDeclaration := func(node ExportDeclaration) bool {
		if node.isTypeOnly && node.exportClause. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindNamedExports {
			return checkGrammarNamedImportsOrExports(node.exportClause)
		}
		return false
	}
	checkGrammarModuleElementContext := func(node Statement, errorMessage DiagnosticMessage) bool {
		isInAppropriateContext := node.parent.kind == SyntaxKindSourceFile || node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindModuleDeclaration
		if !isInAppropriateContext {
			grammarErrorOnFirstToken(node, errorMessage)
		}
		return !isInAppropriateContext
	}
	checkExportSpecifier := func(node ExportSpecifier) {
		checkAliasSymbol(node)
		hasModuleSpecifier := node.parent.parent.moduleSpecifier != nil
		checkModuleExportName(node.propertyName, hasModuleSpecifier)
		checkModuleExportName(node.name)
		if getEmitDeclarations(compilerOptions) {
			collectLinkedAliases(node.propertyName || node.name /*setVisibility*/, true)
		}
		if !hasModuleSpecifier {
			exportedName := node.propertyName || node.name
			if exportedName.kind == SyntaxKindStringLiteral {
				return
				// Skip for invalid syntax like this: export { "x" }
			}
			// find immediate value referenced by exported name (SymbolFlags.Alias is set so we don't chase down aliases)
			symbol := resolveName(exportedName, exportedName.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias /*nameNotFoundMessage*/, nil /*isUse*/, true)
			if symbol && (symbol == undefinedSymbol || symbol == globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0]))) {
				error(exportedName, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, idText(exportedName))
			} else {
				markLinkedReferences(node, ReferenceHintExportSpecifier)
			}
		} else {
			if getESModuleInterop(compilerOptions) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && moduleExportNameIsDefault(node.propertyName || node.name) {
				checkExternalEmitHelpers(node, ExternalEmitHelpersImportDefault)
			}
		}
	}
	checkExportAssignment := func(node ExportAssignment) {
		var illegalContextMessage DiagnosticMessage
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.isExportEquals:
			illegalContextMessage = Diagnostics.An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration
		default:
			illegalContextMessage = Diagnostics.A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration
		}
		if checkGrammarModuleElementContext(node, illegalContextMessage) {
			// If we hit an export assignment in an illegal context, just bail out to avoid cascading errors.
			return
		}
		var container /* TODO(TS-TO-GO) inferred type SourceFile | ModuleDeclaration */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case node.parent.kind == SyntaxKindSourceFile:
			container = node.parent
		default:
			container = node.parent.parent /* as ModuleDeclaration */
		}
		if container.kind == SyntaxKindModuleDeclaration && !isAmbientModule(container) {
			if node.isExportEquals {
				error(node, Diagnostics.An_export_assignment_cannot_be_used_in_a_namespace)
			} else {
				error(node, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module)
			}
			return
		}
		// Grammar checking
		if !checkGrammarModifiers(node) && hasEffectiveModifiers(node) {
			grammarErrorOnFirstToken(node, Diagnostics.An_export_assignment_cannot_have_modifiers)
		}
		typeAnnotationNode := getEffectiveTypeAnnotationNode(node)
		if typeAnnotationNode {
			checkTypeAssignableTo(checkExpressionCached(node.expression), getTypeFromTypeNode(typeAnnotationNode), node.expression)
		}
		isIllegalExportDefaultInCJS := !node.isExportEquals && !(node.flags & NodeFlagsAmbient) && compilerOptions.verbatimModuleSyntax && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS
		if node.expression.kind == SyntaxKindIdentifier {
			id := node.expression /* as Identifier */
			sym := getExportSymbolOfValueSymbolIfExported(resolveEntityName(id, SymbolFlagsAll /*ignoreErrors*/, true /*dontResolveAlias*/, true, node))
			if sym {
				markLinkedReferences(node, ReferenceHintExportAssignment)
				typeOnlyDeclaration := getTypeOnlyAliasDeclaration(sym, SymbolFlagsValue)
				// If not a value, we're interpreting the identifier as a type export, along the lines of (`export { Id as default }`)
				if getSymbolFlags(sym) & SymbolFlagsValue {
					// However if it is a value, we need to check it's being used correctly
					checkExpressionCached(id)
					if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && compilerOptions.verbatimModuleSyntax && typeOnlyDeclaration {
						error(id, __COND__(node.isExportEquals, Diagnostics.An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration, Diagnostics.An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration), idText(id))
					}
				} else if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && compilerOptions.verbatimModuleSyntax {
					error(id, __COND__(node.isExportEquals, Diagnostics.An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type, Diagnostics.An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type), idText(id))
				}
				if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && getIsolatedModules(compilerOptions) && !(sym.flags & SymbolFlagsValue) {
					nonLocalMeanings := getSymbolFlags(sym /*excludeTypeOnlyMeanings*/, false /*excludeLocalMeanings*/, true)
					if sym.flags&SymbolFlagsAlias && nonLocalMeanings&SymbolFlagsType && !(nonLocalMeanings & SymbolFlagsValue) && (!typeOnlyDeclaration || getSourceFileOfNode(typeOnlyDeclaration) != getSourceFileOfNode(node)) {
						// import { SomeType } from "./someModule";
						// export default SomeType; OR
						// export = SomeType;
						error(id, __COND__(node.isExportEquals, Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported, Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default), idText(id), isolatedModulesLikeFlagName)
					} else if typeOnlyDeclaration && getSourceFileOfNode(typeOnlyDeclaration) != getSourceFileOfNode(node) {
						// import { SomeTypeOnlyValue } from "./someModule";
						// export default SomeTypeOnlyValue; OR
						// export = SomeTypeOnlyValue;
						addTypeOnlyDeclarationRelatedInfo(error(id, __COND__(node.isExportEquals, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default), idText(id), isolatedModulesLikeFlagName), typeOnlyDeclaration, idText(id))
					}
				}
			} else {
				checkExpressionCached(id)
				// doesn't resolve, check as expression to mark as error
			}
			if getEmitDeclarations(compilerOptions) {
				collectLinkedAliases(id /*setVisibility*/, true)
			}
		} else {
			checkExpressionCached(node.expression)
		}
		if isIllegalExportDefaultInCJS {
			error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
		}
		checkExternalModuleExports(container)
		if (node.flags & NodeFlagsAmbient) && !isEntityNameExpression(node.expression) {
			grammarErrorOnNode(node.expression, Diagnostics.The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context)
		}
		if node.isExportEquals {
			// Forbid export= in esm implementation files, and esm mode declaration files
			if moduleKind >= ModuleKindES2015 && moduleKind != ModuleKindPreserve && ((node.flags&NodeFlagsAmbient && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) == ModuleKindESNext) || (!(node.flags & NodeFlagsAmbient) && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) != ModuleKindCommonJS)) {
				// export assignment is not supported in es6 modules
				grammarErrorOnNode(node, Diagnostics.Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead)
			} else if moduleKind == ModuleKindSystem && !(node.flags & NodeFlagsAmbient) {
				// system modules does not support export assignment
				grammarErrorOnNode(node, Diagnostics.Export_assignment_is_not_supported_when_module_flag_is_system)
			}
		}
	}
	hasExportedMembers := func(moduleSymbol Symbol) *bool {
		return forEachEntry(moduleSymbol.exports, func(_ Symbol, id __String) bool {
			return id != "export="
		})
	}
	checkExternalModuleExports := func(node /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | ModuleDeclaration */ any) {
		moduleSymbol := getSymbolOfDeclaration(node)
		links := getSymbolLinks(moduleSymbol)
		if !links.exportsChecked {
			exportEqualsSymbol := moduleSymbol.exports.get("export=" /* as __String */)
			if exportEqualsSymbol && hasExportedMembers(moduleSymbol) {
				declaration := getDeclarationOfAliasSymbol(exportEqualsSymbol) || exportEqualsSymbol.valueDeclaration
				if declaration && !isTopLevelInExternalModuleAugmentation(declaration) && !isInJSFile(declaration) {
					error(declaration, Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements)
				}
			}
			// Checks for export * conflicts
			exports := getExportsOfModule(moduleSymbol)
			if exports {
				exports.forEach(func(TODO_IDENTIFIER Symbol, id __String) {
					if id == "__export" {
						return
					}
					// ECMA262: 15.2.1.1 It is a Syntax Error if the ExportedNames of ModuleItemList contains any duplicate entries.
					// (TS Exceptions: namespaces, function overloads, enums, and interfaces)
					if flags & (SymbolFlagsNamespace | SymbolFlagsEnum) {
						return
					}
					exportedDeclarationsCount := countWhere(declarations, and(isNotOverloadAndNotAccessor, not(isInterfaceDeclaration)))
					if flags&SymbolFlagsTypeAlias && exportedDeclarationsCount <= 2 {
						// it is legal to merge type alias with other values
						// so count should be either 1 (just type alias) or 2 (type alias + merged value)
						return
					}
					if exportedDeclarationsCount > 1 {
						if !isDuplicatedCommonJSExport(declarations) {
							for _, declaration := range declarations {
								if isNotOverload(declaration) {
									diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Cannot_redeclare_exported_variable_0, unescapeLeadingUnderscores(id)))
								}
							}
						}
					}
				})
			}
			links.exportsChecked = true
		}
	}
	isDuplicatedCommonJSExport := func(declarations *[]Declaration) *bool {
		return declarations && declarations.length > 1 && declarations.every(func(d Declaration) bool {
			return isInJSFile(d) && isAccessExpression(d) && (isExportsIdentifier(d.expression) || isModuleExportsAccessExpression(d.expression))
		})
	}
	checkSourceElement := func(node Node) {
		if node {
			saveCurrentNode := currentNode
			currentNode = node
			instantiationCount = 0
			checkSourceElementWorker(node)
			currentNode = saveCurrentNode
		}
	}
	checkSourceElementWorker := func(node Node) {
		if getNodeCheckFlags(node) & NodeCheckFlagsPartiallyTypeChecked {
			return
		}
		if canHaveJSDoc(node) {
			forEach(node.jsDoc, func(TODO_IDENTIFIER JSDoc) {
				checkJSDocCommentWorker(comment)
				forEach(tags, func(tag JSDocTag) {
					checkJSDocCommentWorker(tag.comment)
					if isInJSFile(node) {
						checkSourceElement(tag)
					}
				})
			})
		}
		kind := node.kind
		if cancellationToken {
			// Only bother checking on a few construct kinds.  We don't want to be excessively
			// hitting the cancellation token on every node we check.
			switch kind {
			case SyntaxKindModuleDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindClassDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindFunctionDeclaration:
				cancellationToken.throwIfCancellationRequested()
			}
		}
		if kind >= SyntaxKindFirstStatement && kind <= SyntaxKindLastStatement && canHaveFlowNode(node) && node.flowNode && !isReachableFlowNode(node.flowNode) {
			errorOrSuggestion(compilerOptions.allowUnreachableCode == false, node, Diagnostics.Unreachable_code_detected)
		}
		// If editing this, keep `isSourceElement` in utilities up to date.
		switch kind {
		case SyntaxKindTypeParameter:
			return checkTypeParameter(node /* as TypeParameterDeclaration */)
		case SyntaxKindParameter:
			return checkParameter(node /* as ParameterDeclaration */)
		case SyntaxKindPropertyDeclaration:
			return checkPropertyDeclaration(node /* as PropertyDeclaration */)
		case SyntaxKindPropertySignature:
			return checkPropertySignature(node /* as PropertySignature */)
		case SyntaxKindConstructorType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindCallSignature:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindConstructSignature:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindIndexSignature:
			return checkSignatureDeclaration(node /* as SignatureDeclaration */)
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMethodSignature:
			return checkMethodDeclaration(node /* as MethodDeclaration | MethodSignature */)
		case SyntaxKindClassStaticBlockDeclaration:
			return checkClassStaticBlockDeclaration(node /* as ClassStaticBlockDeclaration */)
		case SyntaxKindConstructor:
			return checkConstructorDeclaration(node /* as ConstructorDeclaration */)
		case SyntaxKindGetAccessor:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindSetAccessor:
			return checkAccessorDeclaration(node /* as AccessorDeclaration */)
		case SyntaxKindTypeReference:
			return checkTypeReferenceNode(node /* as TypeReferenceNode */)
		case SyntaxKindTypePredicate:
			return checkTypePredicate(node /* as TypePredicateNode */)
		case SyntaxKindTypeQuery:
			return checkTypeQuery(node /* as TypeQueryNode */)
		case SyntaxKindTypeLiteral:
			return checkTypeLiteral(node /* as TypeLiteralNode */)
		case SyntaxKindArrayType:
			return checkArrayType(node /* as ArrayTypeNode */)
		case SyntaxKindTupleType:
			return checkTupleType(node /* as TupleTypeNode */)
		case SyntaxKindUnionType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindIntersectionType:
			return checkUnionOrIntersectionType(node /* as UnionOrIntersectionTypeNode */)
		case SyntaxKindParenthesizedType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindOptionalType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindRestType:
			return checkSourceElement((node /* as ParenthesizedTypeNode | OptionalTypeNode | RestTypeNode */).type_)
		case SyntaxKindThisType:
			return checkThisType(node /* as ThisTypeNode */)
		case SyntaxKindTypeOperator:
			return checkTypeOperator(node /* as TypeOperatorNode */)
		case SyntaxKindConditionalType:
			return checkConditionalType(node /* as ConditionalTypeNode */)
		case SyntaxKindInferType:
			return checkInferType(node /* as InferTypeNode */)
		case SyntaxKindTemplateLiteralType:
			return checkTemplateLiteralType(node /* as TemplateLiteralTypeNode */)
		case SyntaxKindImportType:
			return checkImportType(node /* as ImportTypeNode */)
		case SyntaxKindNamedTupleMember:
			return checkNamedTupleMember(node /* as NamedTupleMember */)
		case SyntaxKindJSDocAugmentsTag:
			return checkJSDocAugmentsTag(node /* as JSDocAugmentsTag */)
		case SyntaxKindJSDocImplementsTag:
			return checkJSDocImplementsTag(node /* as JSDocImplementsTag */)
		case SyntaxKindJSDocTypedefTag:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocCallbackTag:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocEnumTag:
			return checkJSDocTypeAliasTag(node /* as JSDocTypedefTag */)
		case SyntaxKindJSDocTemplateTag:
			return checkJSDocTemplateTag(node /* as JSDocTemplateTag */)
		case SyntaxKindJSDocTypeTag:
			return checkJSDocTypeTag(node /* as JSDocTypeTag */)
		case SyntaxKindJSDocLink:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocLinkCode:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocLinkPlain:
			return checkJSDocLinkLikeTag(node /* as JSDocLink | JSDocLinkCode | JSDocLinkPlain */)
		case SyntaxKindJSDocParameterTag:
			return checkJSDocParameterTag(node /* as JSDocParameterTag */)
		case SyntaxKindJSDocPropertyTag:
			return checkJSDocPropertyTag(node /* as JSDocPropertyTag */)
		case SyntaxKindJSDocFunctionType:
			checkJSDocFunctionType(node /* as JSDocFunctionType */)
			fallthrough
		case SyntaxKindJSDocNonNullableType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocNullableType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocAllType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocUnknownType:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocTypeLiteral:
			checkJSDocTypeIsInJsFile(node)
			forEachChild(node, checkSourceElement)
			return
		case SyntaxKindJSDocVariadicType:
			checkJSDocVariadicType(node /* as JSDocVariadicType */)
			return
		case SyntaxKindJSDocTypeExpression:
			return checkSourceElement((node /* as JSDocTypeExpression */).type_)
		case SyntaxKindJSDocPublicTag:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocProtectedTag:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJSDocPrivateTag:
			return checkJSDocAccessibilityModifiers(node /* as JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag */)
		case SyntaxKindJSDocSatisfiesTag:
			return checkJSDocSatisfiesTag(node /* as JSDocSatisfiesTag */)
		case SyntaxKindJSDocThisTag:
			return checkJSDocThisTag(node /* as JSDocThisTag */)
		case SyntaxKindJSDocImportTag:
			return checkJSDocImportTag(node /* as JSDocImportTag */)
		case SyntaxKindIndexedAccessType:
			return checkIndexedAccessType(node /* as IndexedAccessTypeNode */)
		case SyntaxKindMappedType:
			return checkMappedType(node /* as MappedTypeNode */)
		case SyntaxKindFunctionDeclaration:
			return checkFunctionDeclaration(node /* as FunctionDeclaration */)
		case SyntaxKindBlock:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindModuleBlock:
			return checkBlock(node /* as Block */)
		case SyntaxKindVariableStatement:
			return checkVariableStatement(node /* as VariableStatement */)
		case SyntaxKindExpressionStatement:
			return checkExpressionStatement(node /* as ExpressionStatement */)
		case SyntaxKindIfStatement:
			return checkIfStatement(node /* as IfStatement */)
		case SyntaxKindDoStatement:
			return checkDoStatement(node /* as DoStatement */)
		case SyntaxKindWhileStatement:
			return checkWhileStatement(node /* as WhileStatement */)
		case SyntaxKindForStatement:
			return checkForStatement(node /* as ForStatement */)
		case SyntaxKindForInStatement:
			return checkForInStatement(node /* as ForInStatement */)
		case SyntaxKindForOfStatement:
			return checkForOfStatement(node /* as ForOfStatement */)
		case SyntaxKindContinueStatement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindBreakStatement:
			return checkBreakOrContinueStatement(node /* as BreakOrContinueStatement */)
		case SyntaxKindReturnStatement:
			return checkReturnStatement(node /* as ReturnStatement */)
		case SyntaxKindWithStatement:
			return checkWithStatement(node /* as WithStatement */)
		case SyntaxKindSwitchStatement:
			return checkSwitchStatement(node /* as SwitchStatement */)
		case SyntaxKindLabeledStatement:
			return checkLabeledStatement(node /* as LabeledStatement */)
		case SyntaxKindThrowStatement:
			return checkThrowStatement(node /* as ThrowStatement */)
		case SyntaxKindTryStatement:
			return checkTryStatement(node /* as TryStatement */)
		case SyntaxKindVariableDeclaration:
			return checkVariableDeclaration(node /* as VariableDeclaration */)
		case SyntaxKindBindingElement:
			return checkBindingElement(node /* as BindingElement */)
		case SyntaxKindClassDeclaration:
			return checkClassDeclaration(node /* as ClassDeclaration */)
		case SyntaxKindInterfaceDeclaration:
			return checkInterfaceDeclaration(node /* as InterfaceDeclaration */)
		case SyntaxKindTypeAliasDeclaration:
			return checkTypeAliasDeclaration(node /* as TypeAliasDeclaration */)
		case SyntaxKindEnumDeclaration:
			return checkEnumDeclaration(node /* as EnumDeclaration */)
		case SyntaxKindModuleDeclaration:
			return checkModuleDeclaration(node /* as ModuleDeclaration */)
		case SyntaxKindImportDeclaration:
			return checkImportDeclaration(node /* as ImportDeclaration */)
		case SyntaxKindImportEqualsDeclaration:
			return checkImportEqualsDeclaration(node /* as ImportEqualsDeclaration */)
		case SyntaxKindExportDeclaration:
			return checkExportDeclaration(node /* as ExportDeclaration */)
		case SyntaxKindExportAssignment:
			return checkExportAssignment(node /* as ExportAssignment */)
		case SyntaxKindEmptyStatement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindDebuggerStatement:
			checkGrammarStatementInAmbientContext(node)
			return
		case SyntaxKindMissingDeclaration:
			return checkMissingDeclaration(node)
		}
	}
	checkJSDocCommentWorker := func(node /* TODO(TS-TO-GO) TypeNode UnionType: string | readonly JSDocComment[] | undefined */ any) {
		if isArray(node) {
			forEach(node, func(tag JSDocComment) {
				if isJSDocLinkLike(tag) {
					checkSourceElement(tag)
				}
			})
		}
	}
	checkJSDocTypeIsInJsFile := func(node Node) {
		if !isInJSFile(node) {
			if isJSDocNonNullableType(node) || isJSDocNullableType(node) {
				token := tokenToString(__COND__(isJSDocNonNullableType(node), SyntaxKindExclamationToken, SyntaxKindQuestionToken))
				var diagnostic DiagnosticMessage
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case node.postfix:
					diagnostic = Diagnostics._0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1
				default:
					diagnostic = Diagnostics._0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1
				}
				typeNode := node.type_
				type_ := getTypeFromTypeNode(typeNode)
				grammarErrorOnNode(node, diagnostic, token, typeToString(__COND__(isJSDocNullableType(node) && !(type_ == neverType || type_ == voidType), getUnionType(append([]Type{type_, undefinedType}, __COND__(node.postfix, nil, nullType))), type_)))
			} else {
				grammarErrorOnNode(node, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments)
			}
		}
	}
	checkJSDocVariadicType := func(node JSDocVariadicType) {
		checkJSDocTypeIsInJsFile(node)
		checkSourceElement(node.type_)
		// Only legal location is in the *last* parameter tag or last parameter of a JSDoc function.
		TODO_IDENTIFIER := node
		if isParameter(parent) && isJSDocFunctionType(parent.parent) {
			if last(parent.parent.parameters) != parent {
				error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list)
			}
			return
		}
		if !isJSDocTypeExpression(parent) {
			error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature)
		}
		paramTag := node.parent.parent
		if !isJSDocParameterTag(paramTag) {
			error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature)
			return
		}
		param := getParameterSymbolFromJSDoc(paramTag)
		if !param {
			// We will error in `checkJSDocParameterTag`.
			return
		}
		host := getHostSignatureFromJSDoc(paramTag)
		if !host || last(host.parameters).symbol != param {
			error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list)
		}
	}
	getTypeFromJSDocVariadicType := func(node JSDocVariadicType) Type {
		type_ := getTypeFromTypeNode(node.type_)
		TODO_IDENTIFIER := node
		paramTag := node.parent.parent
		if isJSDocTypeExpression(node.parent) && isJSDocParameterTag(paramTag) {
			// Else we will add a diagnostic, see `checkJSDocVariadicType`.
			host := getHostSignatureFromJSDoc(paramTag)
			isCallbackTag := isJSDocCallbackTag(paramTag.parent.parent)
			if host || isCallbackTag {
				/*
				   Only return an array type if the corresponding parameter is marked as a rest parameter, or if there are no parameters.
				   So in the following situation we will not create an array type:
				       /** @param {...number} a * /
				       function f(a) {}
				   Because `a` will just be of type `number | undefined`. A synthetic `...args` will also be added, which *will* get an array type.
				*/
				var lastParamDeclaration * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | JSDocParameterTag */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isCallbackTag:
					lastParamDeclaration = lastOrUndefined((paramTag.parent.parent /* as unknown */ /* as JSDocCallbackTag */).typeExpression.parameters)
				default:
					lastParamDeclaration = lastOrUndefined(host.parameters)
				}
				symbol := getParameterSymbolFromJSDoc(paramTag)
				if !lastParamDeclaration || symbol && lastParamDeclaration.symbol == symbol && isRestParameter(lastParamDeclaration) {
					return createArrayType(type_)
				}
			}
		}
		if isParameter(parent) && isJSDocFunctionType(parent.parent) {
			return createArrayType(type_)
		}
		return addOptionality(type_)
	}
	// Function and class expression bodies are checked after all statements in the enclosing body. This is
	// to ensure constructs like the following are permitted:
	//     const foo = function () {
	//        const s = foo();
	//        return "hello";
	//     }
	// Here, performing a full type check of the body of the function expression whilst in the process of
	// determining the type of foo would cause foo to be given type any because of the recursive reference.
	// Delaying the type check of the body ensures foo has been assigned a type.
	checkNodeDeferred := func(node Node) {
		enclosingFile := getSourceFileOfNode(node)
		links := getNodeLinks(enclosingFile)
		if !(links.flags & NodeCheckFlagsTypeChecked) {
			/* TODO(TS-TO-GO) Node BinaryExpression: links.deferredNodes ||= new Set() */ TODO
			links.deferredNodes.add(node)
		} else {
			Debug.assert(!links.deferredNodes, "A type-checked file should have no deferred nodes.")
		}
	}
	checkDeferredNodes := func(context SourceFile) {
		links := getNodeLinks(context)
		if links.deferredNodes {
			links.deferredNodes.forEach(checkDeferredNode)
		}
		links.deferredNodes = nil
	}
	checkDeferredNode := func(node Node) {
		tracing. /* TODO(TS-TO-GO): was ? */ push(tracing.Phase.Check, "checkDeferredNode", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"kind": node.kind,
			"pos":  node.pos,
			"end":  node.end,
			"path": (node /* as TracingNode */).tracingPath,
		})
		saveCurrentNode := currentNode
		currentNode = node
		instantiationCount = 0
		switch node.kind {
		case SyntaxKindCallExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNewExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTaggedTemplateExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindDecorator:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindJsxOpeningElement:
			resolveUntypedCall(node /* as CallLikeExpression */)
			break
		case SyntaxKindFunctionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMethodSignature:
			checkFunctionExpressionOrObjectLiteralMethodDeferred(node /* as FunctionExpression */)
			break
		case SyntaxKindGetAccessor:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindSetAccessor:
			checkAccessorDeclaration(node /* as AccessorDeclaration */)
			break
		case SyntaxKindClassExpression:
			checkClassExpressionDeferred(node /* as ClassExpression */)
			break
		case SyntaxKindTypeParameter:
			checkTypeParameterDeferred(node /* as TypeParameterDeclaration */)
			break
		case SyntaxKindJsxSelfClosingElement:
			checkJsxSelfClosingElementDeferred(node /* as JsxSelfClosingElement */)
			break
		case SyntaxKindJsxElement:
			checkJsxElementDeferred(node /* as JsxElement */)
			break
		case SyntaxKindTypeAssertionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindAsExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindParenthesizedExpression:
			checkAssertionDeferred(node /* as AssertionExpression | JSDocTypeAssertion */)
			break
		case SyntaxKindVoidExpression:
			checkExpression((node /* as VoidExpression */).expression)
			break
		case SyntaxKindBinaryExpression:
			if isInstanceOfExpression(node) {
				resolveUntypedCall(node)
			}
			break
		}
		currentNode = saveCurrentNode
		tracing. /* TODO(TS-TO-GO): was ? */ pop()
	}
	checkSourceFile := func(node SourceFile, nodesToCheck *[]Node) {
		tracing. /* TODO(TS-TO-GO): was ? */ push(tracing.Phase.Check, __COND__(nodesToCheck, "checkSourceFileNodes", "checkSourceFile"), map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"path": node.path,
		}, /*separateBeginAndEnd*/ true)
		var beforeMark /* TODO(TS-TO-GO) inferred type "beforeCheckNodes" | "beforeCheck" */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case nodesToCheck:
			beforeMark = "beforeCheckNodes"
		default:
			beforeMark = "beforeCheck"
		}
		var afterMark /* TODO(TS-TO-GO) inferred type "afterCheckNodes" | "afterCheck" */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case nodesToCheck:
			afterMark = "afterCheckNodes"
		default:
			afterMark = "afterCheck"
		}
		performance.mark(beforeMark)
		__COND__(nodesToCheck, checkSourceFileNodesWorker(node, nodesToCheck), checkSourceFileWorker(node))
		performance.mark(afterMark)
		performance.measure("Check", beforeMark, afterMark)
		tracing. /* TODO(TS-TO-GO): was ? */ pop()
	}
	unusedIsError := func(kind UnusedKind, isAmbient bool) bool {
		if isAmbient {
			return false
		}
		switch kind {
		case UnusedKindLocal:
			return !!compilerOptions.noUnusedLocals
		case UnusedKindParameter:
			return !!compilerOptions.noUnusedParameters
		default:
			return Debug.assertNever(kind)
		}
	}
	getPotentiallyUnusedIdentifiers := func(sourceFile SourceFile) []PotentiallyUnusedIdentifier {
		return allPotentiallyUnusedIdentifiers.get(sourceFile.path) || emptyArray
	}
	// Fully type check a source file and collect the relevant diagnostics.
	checkSourceFileWorker := func(node SourceFile) {
		links := getNodeLinks(node)
		if !(links.flags & NodeCheckFlagsTypeChecked) {
			if skipTypeChecking(node, compilerOptions, host) {
				return
			}
			// Grammar checking
			checkGrammarSourceFile(node)
			clear(potentialThisCollisions)
			clear(potentialNewTargetCollisions)
			clear(potentialWeakMapSetCollisions)
			clear(potentialReflectCollisions)
			clear(potentialUnusedRenamedBindingElementsInTypes)
			if links.flags & NodeCheckFlagsPartiallyTypeChecked {
				potentialThisCollisions = links.potentialThisCollisions
				potentialNewTargetCollisions = links.potentialNewTargetCollisions
				potentialWeakMapSetCollisions = links.potentialWeakMapSetCollisions
				potentialReflectCollisions = links.potentialReflectCollisions
				potentialUnusedRenamedBindingElementsInTypes = links.potentialUnusedRenamedBindingElementsInTypes
			}
			forEach(node.statements, checkSourceElement)
			checkSourceElement(node.endOfFileToken)
			checkDeferredNodes(node)
			if isExternalOrCommonJsModule(node) {
				registerForUnusedIdentifiersCheck(node)
			}
			addLazyDiagnostic(func() {
				// This relies on the results of other lazy diagnostics, so must be computed after them
				if !node.isDeclarationFile && (compilerOptions.noUnusedLocals || compilerOptions.noUnusedParameters) {
					checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(node), func(containingNode Node, kind UnusedKind, diag DiagnosticWithLocation) {
						if !containsParseError(containingNode) && unusedIsError(kind, !!(containingNode.flags&NodeFlagsAmbient)) {
							diagnostics.add(diag)
						}
					})
				}
				if !node.isDeclarationFile {
					checkPotentialUncheckedRenamedBindingElementsInTypes()
				}
			})
			if isExternalOrCommonJsModule(node) {
				checkExternalModuleExports(node)
			}
			if potentialThisCollisions.length {
				forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope)
				clear(potentialThisCollisions)
			}
			if potentialNewTargetCollisions.length {
				forEach(potentialNewTargetCollisions, checkIfNewTargetIsCapturedInEnclosingScope)
				clear(potentialNewTargetCollisions)
			}
			if potentialWeakMapSetCollisions.length {
				forEach(potentialWeakMapSetCollisions, checkWeakMapSetCollision)
				clear(potentialWeakMapSetCollisions)
			}
			if potentialReflectCollisions.length {
				forEach(potentialReflectCollisions, checkReflectCollision)
				clear(potentialReflectCollisions)
			}
			links.flags |= NodeCheckFlagsTypeChecked
		}
	}
	checkSourceFileNodesWorker := func(file SourceFile, nodes []Node) {
		links := getNodeLinks(file)
		if !(links.flags & NodeCheckFlagsTypeChecked) {
			if skipTypeChecking(file, compilerOptions, host) {
				return
			}
			// Grammar checking
			checkGrammarSourceFile(file)
			clear(potentialThisCollisions)
			clear(potentialNewTargetCollisions)
			clear(potentialWeakMapSetCollisions)
			clear(potentialReflectCollisions)
			clear(potentialUnusedRenamedBindingElementsInTypes)
			forEach(nodes, checkSourceElement)
			checkDeferredNodes(file)
			(links.potentialThisCollisions || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.potentialThisCollisions = [] */ TODO)).push(potentialThisCollisions...)
			(links.potentialNewTargetCollisions || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.potentialNewTargetCollisions = [] */ TODO)).push(potentialNewTargetCollisions...)
			(links.potentialWeakMapSetCollisions || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.potentialWeakMapSetCollisions = [] */ TODO)).push(potentialWeakMapSetCollisions...)
			(links.potentialReflectCollisions || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.potentialReflectCollisions = [] */ TODO)).push(potentialReflectCollisions...)
			(links.potentialUnusedRenamedBindingElementsInTypes || ( /* TODO(TS-TO-GO) Node BinaryExpression: links.potentialUnusedRenamedBindingElementsInTypes = [] */ TODO)).push(potentialUnusedRenamedBindingElementsInTypes...)
			links.flags |= NodeCheckFlagsPartiallyTypeChecked
			for _, node := range nodes {
				nodeLinks := getNodeLinks(node)
				nodeLinks.flags |= NodeCheckFlagsPartiallyTypeChecked
			}
		}
	}
	getDiagnostics := func(sourceFile SourceFile, ct CancellationToken, nodesToCheck []Node) []Diagnostic {
		// TODO(TS-TO-GO): try
		{
			// Record the cancellation token so it can be checked later on during checkSourceElement.
			// Do this in a finally block so we can ensure that it gets reset back to nothing after
			// this call is done.
			cancellationToken = ct
			return getDiagnosticsWorker(sourceFile, nodesToCheck)
		}
		/* TODO(TS-TO-GO) Node Block: { cancellationToken = undefined; } */
		/* TODO(TS-TO-GO) Node TryStatement: try { // Record the cancellation token so it can be checked later on during checkSourceElement. // Do this in a finally block so we can ensure that it gets reset back to nothing after // this call is done. cancellationToken = ct; return getDiagnosticsWorker(sourceFile, nodesToCheck); } finally { cancellationToken = undefined; } */
	}
	ensurePendingDiagnosticWorkComplete := func() {
		// Invoke any existing lazy diagnostics to add them, clear the backlog of diagnostics
		for _, cb := range deferredDiagnosticsCallbacks {
			cb()
		}
		deferredDiagnosticsCallbacks = []never{}
	}
	checkSourceFileWithEagerDiagnostics := func(sourceFile SourceFile, nodesToCheck []Node) {
		ensurePendingDiagnosticWorkComplete()
		// then setup diagnostics for immediate invocation (as we are about to collect them, and
		// this avoids the overhead of longer-lived callbacks we don't need to allocate)
		// This also serves to make the shift to possibly lazy diagnostics transparent to serial command-line scenarios
		// (as in those cases, all the diagnostics will still be computed as the appropriate place in the tree,
		// thus much more likely retaining the same union ordering as before we had lazy diagnostics)
		oldAddLazyDiagnostics := addLazyDiagnostic
		addLazyDiagnostic = func(cb /* TODO(TS-TO-GO) inferred type () => void */ any) {
			return cb()
		}
		checkSourceFile(sourceFile, nodesToCheck)
		addLazyDiagnostic = oldAddLazyDiagnostics
	}
	getDiagnosticsWorker := func(sourceFile SourceFile, nodesToCheck *[]Node) []Diagnostic {
		if sourceFile {
			ensurePendingDiagnosticWorkComplete()
			// Some global diagnostics are deferred until they are needed and
			// may not be reported in the first call to getGlobalDiagnostics.
			// We should catch these changes and report them.
			previousGlobalDiagnostics := diagnostics.getGlobalDiagnostics()
			previousGlobalDiagnosticsSize := previousGlobalDiagnostics.length
			checkSourceFileWithEagerDiagnostics(sourceFile, nodesToCheck)
			semanticDiagnostics := diagnostics.getDiagnostics(sourceFile.fileName)
			if nodesToCheck {
				// No need to get global diagnostics.
				return semanticDiagnostics
			}
			currentGlobalDiagnostics := diagnostics.getGlobalDiagnostics()
			if currentGlobalDiagnostics != previousGlobalDiagnostics {
				// If the arrays are not the same reference, new diagnostics were added.
				deferredGlobalDiagnostics := relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, compareDiagnostics)
				return concatenate(deferredGlobalDiagnostics, semanticDiagnostics)
			} else if previousGlobalDiagnosticsSize == 0 && currentGlobalDiagnostics.length > 0 {
				// If the arrays are the same reference, but the length has changed, a single
				// new diagnostic was added as DiagnosticCollection attempts to reuse the
				// same array.
				return concatenate(currentGlobalDiagnostics, semanticDiagnostics)
			}
			return semanticDiagnostics
		}
		// Global diagnostics are always added when a file is not provided to
		// getDiagnostics
		forEach(host.getSourceFiles(), func(file SourceFile) {
			return checkSourceFileWithEagerDiagnostics(file)
		})
		return diagnostics.getDiagnostics()
	}
	getGlobalDiagnostics := func() []Diagnostic {
		ensurePendingDiagnosticWorkComplete()
		return diagnostics.getGlobalDiagnostics()
	}
	// Language service support
	getSymbolsInScope := func(location Node, meaning SymbolFlags) []Symbol {
		if location.flags & NodeFlagsInWithStatement {
			// We cannot answer semantic questions within a with block, do not proceed any further
			return []never{}
		}
		symbols := createSymbolTable()
		isStaticSymbol := false
		populateSymbols()
		symbols.delete(InternalSymbolNameThis)
		// Not a symbol, a keyword
		return symbolsToArray(symbols)
		populateSymbols := func() {
			for location {
				if canHaveLocals(location) && location.locals && !isGlobalSourceFile(location) {
					copySymbols(location.locals, meaning)
				}
				switch location.kind {
				case SyntaxKindSourceFile:
					if !isExternalModule(location /* as SourceFile */) {
						break
					}
					fallthrough
				case SyntaxKindModuleDeclaration:
					copyLocallyVisibleExportSymbols(getSymbolOfDeclaration(location /* as ModuleDeclaration | SourceFile */).exports, meaning&SymbolFlagsModuleMember)
					break
				case SyntaxKindEnumDeclaration:
					copySymbols(getSymbolOfDeclaration(location /* as EnumDeclaration */).exports, meaning&SymbolFlagsEnumMember)
					break
				case SyntaxKindClassExpression:
					className := (location /* as ClassExpression */).name
					if className {
						copySymbol((location /* as ClassExpression */).symbol, meaning)
					}
					fallthrough
				case SyntaxKindClassDeclaration:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindInterfaceDeclaration:
					if !isStaticSymbol {
						copySymbols(getMembersOfSymbol(getSymbolOfDeclaration(location /* as ClassDeclaration | InterfaceDeclaration */)), meaning&SymbolFlagsType)
					}
					break
				case SyntaxKindFunctionExpression:
					funcName := (location /* as FunctionExpression */).name
					if funcName {
						copySymbol((location /* as FunctionExpression */).symbol, meaning)
					}
					break
				}
				if introducesArgumentsExoticObject(location) {
					copySymbol(argumentsSymbol, meaning)
				}
				isStaticSymbol = isStatic(location)
				location = location.parent
			}
			copySymbols(globals, meaning)
		}
		/**
		 * Copy the given symbol into symbol tables if the symbol has the given meaning
		 * and it doesn't already existed in the symbol table
		 * @param key a key for storing in symbol table; if undefined, use symbol.name
		 * @param symbol the symbol to be added into symbol table
		 * @param meaning meaning of symbol to filter by before adding to symbol table
		 */
		copySymbol := func(symbol Symbol, meaning SymbolFlags) {
			if getCombinedLocalAndExportSymbolFlags(symbol) & meaning {
				id := symbol.escapedName
				// We will copy all symbol regardless of its reserved name because
				// symbolsToArray will check whether the key is a reserved name and
				// it will not copy symbol with reserved name to the array
				if !symbols.has(id) {
					symbols.set(id, symbol)
				}
			}
		}
		copySymbols := func(source SymbolTable, meaning SymbolFlags) {
			if meaning {
				source.forEach(func(symbol Symbol) {
					copySymbol(symbol, meaning)
				})
			}
		}
		copyLocallyVisibleExportSymbols := func(source SymbolTable, meaning SymbolFlags) {
			if meaning {
				source.forEach(func(symbol Symbol) {
					// Similar condition as in `resolveNameHelper`
					if !getDeclarationOfKind(symbol, SyntaxKindExportSpecifier) && !getDeclarationOfKind(symbol, SyntaxKindNamespaceExport) && symbol.escapedName != InternalSymbolNameDefault {
						copySymbol(symbol, meaning)
					}
				})
			}
		}
	}
	isTypeDeclarationName := func(name Node) bool {
		return name.kind == SyntaxKindIdentifier && isTypeDeclaration(name.parent) && getNameOfDeclaration(name.parent) == name
	}
	// True if the given identifier is part of a type reference
	isTypeReferenceIdentifier := func(node EntityName) bool {
		for node.parent.kind == SyntaxKindQualifiedName {
			node = node.parent /* as QualifiedName */
		}
		return node.parent.kind == SyntaxKindTypeReference
	}
	isInNameOfExpressionWithTypeArguments := func(node Node) bool {
		for node.parent.kind == SyntaxKindPropertyAccessExpression {
			node = node.parent
		}
		return node.parent.kind == SyntaxKindExpressionWithTypeArguments
	}
	forEachEnclosingClass := func(node Node, callback func(node ClassLikeDeclaration) *T) *T {
		var result *T
		containingClass := getContainingClass(node)
		for containingClass {
			if /* TODO(TS-TO-GO) Node BinaryExpression: result = callback(containingClass) */ TODO {
				break
			}
			containingClass = getContainingClass(containingClass)
		}
		return result
	}
	isNodeUsedDuringClassInitialization := func(node Node) bool {
		return !!findAncestor(node, func(element Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			if isConstructorDeclaration(element) && nodeIsPresent(element.body) || isPropertyDeclaration(element) {
				return true
			} else if isClassLike(element) || isFunctionLikeDeclaration(element) {
				return "quit"
			}
			return false
		})
	}
	isNodeWithinClass := func(node Node, classDeclaration ClassLikeDeclaration) bool {
		return !!forEachEnclosingClass(node, func(n ClassLikeDeclaration) bool {
			return n == classDeclaration
		})
	}
	getLeftSideOfImportEqualsOrExportAssignment := func(nodeOnRightSide EntityName) /* TODO(TS-TO-GO) TypeNode UnionType: ImportEqualsDeclaration | ExportAssignment | undefined */ any {
		for nodeOnRightSide.parent.kind == SyntaxKindQualifiedName {
			nodeOnRightSide = nodeOnRightSide.parent /* as QualifiedName */
		}
		if nodeOnRightSide.parent.kind == SyntaxKindImportEqualsDeclaration {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (nodeOnRightSide.parent /* as ImportEqualsDeclaration */).moduleReference == nodeOnRightSide:
				return nodeOnRightSide.parent /* as ImportEqualsDeclaration */
			default:
				return nil
			}
		}
		if nodeOnRightSide.parent.kind == SyntaxKindExportAssignment {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (nodeOnRightSide.parent /* as ExportAssignment */).expression == nodeOnRightSide /* as Node */ :
				return nodeOnRightSide.parent /* as ExportAssignment */
			default:
				return nil
			}
		}
		return nil
	}
	isInRightSideOfImportOrExportAssignment := func(node EntityName) bool {
		return getLeftSideOfImportEqualsOrExportAssignment(node) != nil
	}
	getSpecialPropertyAssignmentSymbolFromEntityName := func(entityName /* TODO(TS-TO-GO) TypeNode UnionType: EntityName | PropertyAccessExpression */ any) Symbol {
		specialPropertyAssignmentKind := getAssignmentDeclarationKind(entityName.parent.parent /* as BinaryExpression */)
		switch specialPropertyAssignmentKind {
		case AssignmentDeclarationKindExportsProperty:
			fallthrough // TODO(TS-TO-GO): merge cases
		case AssignmentDeclarationKindPrototypeProperty:
			return getSymbolOfNode(entityName.parent)
		case AssignmentDeclarationKindProperty:
			if isPropertyAccessExpression(entityName.parent) && getLeftmostAccessExpression(entityName.parent) == entityName {
				return nil
			}
			fallthrough
		case AssignmentDeclarationKindThisProperty:
			fallthrough // TODO(TS-TO-GO): merge cases
		case AssignmentDeclarationKindModuleExports:
			return getSymbolOfDeclaration(entityName.parent.parent /* as BinaryExpression */)
		}
	}
	isImportTypeQualifierPart := func(node EntityName) *ImportTypeNode {
		parent := node.parent
		for isQualifiedName(parent) {
			node = parent
			parent = parent.parent
		}
		if parent && parent.kind == SyntaxKindImportType && (parent /* as ImportTypeNode */).qualifier == node {
			return parent /* as ImportTypeNode */
		}
		return nil
	}
	isThisPropertyAndThisTyped := func(node PropertyAccessExpression) *bool {
		if node.expression.kind == SyntaxKindThisKeyword {
			container := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
			if isFunctionLike(container) {
				containingLiteral := getContainingObjectLiteral(container)
				if containingLiteral {
					contextualType := getApparentTypeOfContextualType(containingLiteral /*contextFlags*/, nil)
					type_ := getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
					return type_ && !isTypeAny(type_)
				}
			}
		}
	}
	getSymbolOfNameOrPropertyAccessExpression := func(name /* TODO(TS-TO-GO) TypeNode UnionType: EntityName | PrivateIdentifier | PropertyAccessExpression | JSDocMemberName */ any) Symbol {
		if isDeclarationName(name) {
			return getSymbolOfNode(name.parent)
		}
		if isInJSFile(name) && name.parent.kind == SyntaxKindPropertyAccessExpression && name.parent == (name.parent.parent /* as BinaryExpression */).left {
			// Check if this is a special property assignment
			if !isPrivateIdentifier(name) && !isJSDocMemberName(name) && !isThisPropertyAndThisTyped(name.parent /* as PropertyAccessExpression */) {
				specialPropertyAssignmentSymbol := getSpecialPropertyAssignmentSymbolFromEntityName(name)
				if specialPropertyAssignmentSymbol {
					return specialPropertyAssignmentSymbol
				}
			}
		}
		if name.parent.kind == SyntaxKindExportAssignment && isEntityNameExpression(name) {
			// Even an entity name expression that doesn't resolve as an entityname may still typecheck as a property access expression
			success := resolveEntityName(name /*all meanings*/, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias /*ignoreErrors*/, true)
			if success && success != unknownSymbol {
				return success
			}
		} else if isEntityName(name) && isInRightSideOfImportOrExportAssignment(name) {
			// Since we already checked for ExportAssignment, this really could only be an Import
			importEqualsDeclaration := getAncestor(name, SyntaxKindImportEqualsDeclaration)
			Debug.assert(importEqualsDeclaration != nil)
			return getSymbolOfPartOfRightHandSideOfImportEquals(name /*dontResolveAlias*/, true)
		}
		if isEntityName(name) {
			possibleImportNode := isImportTypeQualifierPart(name)
			if possibleImportNode {
				getTypeFromTypeNode(possibleImportNode)
				sym := getNodeLinks(name).resolvedSymbol
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case sym == unknownSymbol:
					return nil
				default:
					return sym
				}
			}
		}
		for isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(name) {
			name = name.parent /* as QualifiedName | PropertyAccessEntityNameExpression | JSDocMemberName */
		}
		if isInNameOfExpressionWithTypeArguments(name) {
			meaning := SymbolFlagsNone
			if name.parent.kind == SyntaxKindExpressionWithTypeArguments {
				// An 'ExpressionWithTypeArguments' may appear in type space (interface Foo extends Bar<T>),
				// value space (return foo<T>), or both(class Foo extends Bar<T>); ensure the meaning matches.
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isPartOfTypeNode(name):
					meaning = SymbolFlagsType
				default:
					meaning = SymbolFlagsValue
				}
				// In a class 'extends' clause we are also looking for a value.
				if isExpressionWithTypeArgumentsInClassExtendsClause(name.parent) {
					meaning |= SymbolFlagsValue
				}
			} else {
				meaning = SymbolFlagsNamespace
			}
			meaning |= SymbolFlagsAlias
			var entityNameSymbol Symbol
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isEntityNameExpression(name):
				entityNameSymbol = resolveEntityName(name, meaning /*ignoreErrors*/, true)
			default:
				entityNameSymbol = nil
			}
			if entityNameSymbol {
				return entityNameSymbol
			}
		}
		if name.parent.kind == SyntaxKindJSDocParameterTag {
			return getParameterSymbolFromJSDoc(name.parent /* as JSDocParameterTag */)
		}
		if name.parent.kind == SyntaxKindTypeParameter && name.parent.parent.kind == SyntaxKindJSDocTemplateTag {
			Debug.assert(!isInJSFile(name))
			// Otherwise `isDeclarationName` would have been true.
			typeParameter := getTypeParameterFromJsDoc(name.parent /* as TypeParameterDeclaration & { parent: JSDocTemplateTag; } */)
			return typeParameter && typeParameter.symbol
		}
		if isExpressionNode(name) {
			if nodeIsMissing(name) {
				// Missing entity name.
				return nil
			}
			isJSDoc := findAncestor(name, or(isJSDocLinkLike, isJSDocNameReference, isJSDocMemberName))
			var meaning number
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isJSDoc:
				meaning = SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsValue
			default:
				meaning = SymbolFlagsValue
			}
			if name.kind == SyntaxKindIdentifier {
				if isJSXTagName(name) && isJsxIntrinsicTagName(name) {
					symbol := getIntrinsicTagSymbol(name.parent /* as JsxOpeningLikeElement */)
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case symbol == unknownSymbol:
						return nil
					default:
						return symbol
					}
				}
				result := resolveEntityName(name, meaning /*ignoreErrors*/, true /*dontResolveAlias*/, true, getHostSignatureFromJSDoc(name))
				if !result && isJSDoc {
					container := findAncestor(name, or(isClassLike, isInterfaceDeclaration))
					if container {
						return resolveJSDocMemberName(name /*ignoreErrors*/, true, getSymbolOfDeclaration(container))
					}
				}
				if result && isJSDoc {
					container := getJSDocHost(name)
					if container && isEnumMember(container) && container == result.valueDeclaration {
						return resolveEntityName(name, meaning /*ignoreErrors*/, true /*dontResolveAlias*/, true, getSourceFileOfNode(container)) || result
					}
				}
				return result
			} else if isPrivateIdentifier(name) {
				return getSymbolForPrivateIdentifierExpression(name)
			} else if name.kind == SyntaxKindPropertyAccessExpression || name.kind == SyntaxKindQualifiedName {
				links := getNodeLinks(name)
				if links.resolvedSymbol {
					return links.resolvedSymbol
				}
				if name.kind == SyntaxKindPropertyAccessExpression {
					checkPropertyAccessExpression(name, CheckModeNormal)
					if !links.resolvedSymbol {
						links.resolvedSymbol = getApplicableIndexSymbol(checkExpressionCached(name.expression), getLiteralTypeFromPropertyName(name.name))
					}
				} else {
					checkQualifiedName(name, CheckModeNormal)
				}
				if !links.resolvedSymbol && isJSDoc && isQualifiedName(name) {
					return resolveJSDocMemberName(name)
				}
				return links.resolvedSymbol
			} else if isJSDocMemberName(name) {
				return resolveJSDocMemberName(name)
			}
		} else if isTypeReferenceIdentifier(name /* as EntityName */) {
			var meaning /* TODO(TS-TO-GO) inferred type SymbolFlags.Type | SymbolFlags.Namespace */ any
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case name.parent.kind == SyntaxKindTypeReference:
				meaning = SymbolFlagsType
			default:
				meaning = SymbolFlagsNamespace
			}
			symbol := resolveEntityName(name /* as EntityName */, meaning /*ignoreErrors*/, false /*dontResolveAlias*/, true)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case symbol && symbol != unknownSymbol:
				return symbol
			default:
				return getUnresolvedSymbolForEntityName(name /* as EntityName */)
			}
		}
		if name.parent.kind == SyntaxKindTypePredicate {
			return resolveEntityName(name /* as Identifier */ /*meaning*/, SymbolFlagsFunctionScopedVariable)
		}
		return nil
	}
	getApplicableIndexSymbol := func(type_ Type, keyType Type) Symbol {
		infos := getApplicableIndexInfos(type_, keyType)
		if infos.length && (type_ /* as ObjectType */).members {
			symbol := getIndexSymbolFromSymbolTable(resolveStructuredTypeMembers(type_ /* as ObjectType */).members)
			if infos == getIndexInfosOfType(type_) {
				return symbol
			} else if symbol {
				symbolLinks := getSymbolLinks(symbol)
				declarationList := mapDefined(infos, func(i IndexInfo) *IndexSignatureDeclaration {
					return i.declaration
				})
				nodeListId := map_(declarationList, getNodeId).join(",")
				if !symbolLinks.filteredIndexSymbolCache {
					symbolLinks.filteredIndexSymbolCache = NewMap()
				}
				if symbolLinks.filteredIndexSymbolCache.has(nodeListId) {
					return symbolLinks.filteredIndexSymbolCache.get(nodeListId)
				} else {
					copy := createSymbol(SymbolFlagsSignature, InternalSymbolNameIndex)
					copy.declarations = mapDefined(infos, func(i IndexInfo) *IndexSignatureDeclaration {
						return i.declaration
					})
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case type_.aliasSymbol:
						copy.parent = type_.aliasSymbol
					case type_.symbol:
						copy.parent = type_.symbol
					default:
						copy.parent = getSymbolAtLocation(copy.declarations[0].parent)
					}
					symbolLinks.filteredIndexSymbolCache.set(nodeListId, copy)
					return copy
				}
			}
		}
	}
	/**
	 * Recursively resolve entity names and jsdoc instance references:
	 * 1. K#m as K.prototype.m for a class (or other value) K
	 * 2. K.m as K.prototype.m
	 * 3. I.m as I.m for a type I, or any other I.m that fails to resolve in (1) or (2)
	 *
	 * For unqualified names, a container K may be provided as a second argument.
	 */
	resolveJSDocMemberName := func(name /* TODO(TS-TO-GO) TypeNode UnionType: EntityName | JSDocMemberName */ any, ignoreErrors bool, container Symbol) Symbol {
		if isEntityName(name) {
			// resolve static values first
			meaning := SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsValue
			symbol := resolveEntityName(name, meaning, ignoreErrors /*dontResolveAlias*/, true, getHostSignatureFromJSDoc(name))
			if !symbol && isIdentifier(name) && container {
				symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(container), name.escapedText, meaning))
			}
			if symbol {
				return symbol
			}
		}
		var left Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isIdentifier(name):
			left = container
		default:
			left = resolveJSDocMemberName(name.left, ignoreErrors, container)
		}
		var right __String
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isIdentifier(name):
			right = name.escapedText
		default:
			right = name.right.escapedText
		}
		if left {
			proto := left.flags&SymbolFlagsValue && getPropertyOfType(getTypeOfSymbol(left), "prototype" /* as __String */)
			var t Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case proto:
				t = getTypeOfSymbol(proto)
			default:
				t = getDeclaredTypeOfSymbol(left)
			}
			return getPropertyOfType(t, right)
		}
	}
	getSymbolAtLocation := func(node Node, ignoreErrors bool) Symbol {
		if isSourceFile(node) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isExternalModule(node):
				return getMergedSymbol(node.symbol)
			default:
				return nil
			}
		}
		TODO_IDENTIFIER := node
		grandParent := parent.parent
		if node.flags & NodeFlagsInWithStatement {
			// We cannot answer semantic questions within a with block, do not proceed any further
			return nil
		}
		if isDeclarationNameOrImportPropertyName(node) {
			// This is a declaration, call getSymbolOfNode
			parentSymbol := getSymbolOfDeclaration(parent /* as Declaration */)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isImportOrExportSpecifier(node.parent) && node.parent.propertyName == node:
				return getImmediateAliasedSymbol(parentSymbol)
			default:
				return parentSymbol
			}
		} else if isLiteralComputedPropertyDeclarationName(node) {
			return getSymbolOfDeclaration(parent.parent /* as Declaration */)
		}
		if node.kind == SyntaxKindIdentifier {
			if isInRightSideOfImportOrExportAssignment(node /* as Identifier */) {
				return getSymbolOfNameOrPropertyAccessExpression(node /* as Identifier */)
			} else if parent.kind == SyntaxKindBindingElement && grandParent.kind == SyntaxKindObjectBindingPattern && node == (parent /* as BindingElement */).propertyName {
				typeOfPattern := getTypeOfNode(grandParent)
				propertyDeclaration := getPropertyOfType(typeOfPattern, (node /* as Identifier */).escapedText)
				if propertyDeclaration {
					return propertyDeclaration
				}
			} else if isMetaProperty(parent) && parent.name == node {
				if parent.keywordToken == SyntaxKindNewKeyword && idText(node /* as Identifier */) == "target" {
					// `target` in `new.target`
					return checkNewTargetMetaProperty(parent).symbol
				}
				// The `meta` in `import.meta` could be given `getTypeOfNode(parent).symbol` (the `ImportMeta` interface symbol), but
				// we have a fake expression type made for other reasons already, whose transient `meta`
				// member should more exactly be the kind of (declarationless) symbol we want.
				// (See #44364 and #45031 for relevant implementation PRs)
				if parent.keywordToken == SyntaxKindImportKeyword && idText(node /* as Identifier */) == "meta" {
					return getGlobalImportMetaExpressionType().members.get("meta" /* as __String */)
				}
				// no other meta properties are valid syntax, thus no others should have symbols
				return nil
			}
		}
		switch node.kind {
		case SyntaxKindIdentifier:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPrivateIdentifier:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindQualifiedName:
			if !isThisInTypeQuery(node) {
				return getSymbolOfNameOrPropertyAccessExpression(node /* as EntityName | PrivateIdentifier | PropertyAccessExpression */)
			}
			fallthrough
		case SyntaxKindThisKeyword:
			container := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
			if isFunctionLike(container) {
				sig := getSignatureFromDeclaration(container)
				if sig.thisParameter {
					return sig.thisParameter
				}
			}
			if isInExpressionContext(node) {
				return checkExpression(node /* as Expression */).symbol
			}
			fallthrough
		case SyntaxKindThisType:
			return getTypeFromThisTypeNode(node /* as ThisExpression | ThisTypeNode */).symbol
		case SyntaxKindSuperKeyword:
			return checkExpression(node /* as Expression */).symbol
		case SyntaxKindConstructorKeyword:
			constructorDeclaration := node.parent
			if constructorDeclaration && constructorDeclaration.kind == SyntaxKindConstructor {
				return (constructorDeclaration.parent /* as ClassDeclaration */).symbol
			}
			return nil
		case SyntaxKindStringLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNoSubstitutionTemplateLiteral:
			if (isExternalModuleImportEqualsDeclaration(node.parent.parent) && getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) == node) || ((node.parent.kind == SyntaxKindImportDeclaration || node.parent.kind == SyntaxKindExportDeclaration) && (node.parent /* as ImportDeclaration */).moduleSpecifier == node) || (isInJSFile(node) && isJSDocImportTag(node.parent) && node.parent.moduleSpecifier == node) || ((isInJSFile(node) && isRequireCall(node.parent /*requireStringLiteralLikeArgument*/, false)) || isImportCall(node.parent)) || (isLiteralTypeNode(node.parent) && isLiteralImportTypeNode(node.parent.parent) && node.parent.parent.argument == node.parent) {
				return resolveExternalModuleName(node, node /* as LiteralExpression */, ignoreErrors)
			}
			if isCallExpression(parent) && isBindableObjectDefinePropertyCall(parent) && parent.arguments[1] == node {
				return getSymbolOfDeclaration(parent)
			}
			fallthrough
		case SyntaxKindNumericLiteral:
			var objectType Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isElementAccessExpression(parent):
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case parent.argumentExpression == node:
					objectType = getTypeOfExpression(parent.expression)
				default:
					objectType = nil
				}
			case isLiteralTypeNode(parent) && isIndexedAccessTypeNode(grandParent):
				objectType = getTypeFromTypeNode(grandParent.objectType)
			default:
				objectType = nil
			}
			return objectType && getPropertyOfType(objectType, escapeLeadingUnderscores((node /* as StringLiteral | NumericLiteral */).text))
		case SyntaxKindDefaultKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindEqualsGreaterThanToken:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindClassKeyword:
			return getSymbolOfNode(node.parent)
		case SyntaxKindImportType:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isLiteralImportTypeNode(node):
				return getSymbolAtLocation(node.argument.literal, ignoreErrors)
			default:
				return nil
			}
		case SyntaxKindExportKeyword:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isExportAssignment(node.parent):
				return Debug.checkDefined(node.parent.symbol)
			default:
				return nil
			}
		case SyntaxKindImportKeyword:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNewKeyword:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isMetaProperty(node.parent):
				return checkMetaPropertyKeyword(node.parent).symbol
			default:
				return nil
			}
		case SyntaxKindInstanceOfKeyword:
			if isBinaryExpression(node.parent) {
				type_ := getTypeOfExpression(node.parent.right)
				hasInstanceMethodType := getSymbolHasInstanceMethodOfObjectType(type_)
				return /* TODO(TS-TO-GO) Node BinaryExpression: hasInstanceMethodType?.symbol ?? type.symbol */ TODO
			}
			return nil
		case SyntaxKindMetaProperty:
			return checkExpression(node /* as Expression */).symbol
		case SyntaxKindJsxNamespacedName:
			if isJSXTagName(node) && isJsxIntrinsicTagName(node) {
				symbol := getIntrinsicTagSymbol(node.parent /* as JsxOpeningLikeElement */)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case symbol == unknownSymbol:
					return nil
				default:
					return symbol
				}
			}
			fallthrough
		default:
			return nil
		}
	}
	getIndexInfosAtLocation := func(node Node) *[]IndexInfo {
		if isIdentifier(node) && isPropertyAccessExpression(node.parent) && node.parent.name == node {
			keyType := getLiteralTypeFromPropertyName(node)
			objectType := getTypeOfExpression(node.parent.expression)
			var objectTypes []Type
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case objectType.flags & TypeFlagsUnion:
				objectTypes = (objectType /* as UnionType */).types
			default:
				objectTypes = []Type{objectType}
			}
			return flatMap(objectTypes, func(t Type) []IndexInfo {
				return filter(getIndexInfosOfType(t), func(info IndexInfo) bool {
					return isApplicableIndexType(keyType, info.keyType)
				})
			})
		}
		return nil
	}
	getShorthandAssignmentValueSymbol := func(location Node) Symbol {
		if location && location.kind == SyntaxKindShorthandPropertyAssignment {
			return resolveEntityName((location /* as ShorthandPropertyAssignment */).name, SymbolFlagsValue|SymbolFlagsAlias)
		}
		return nil
	}
	/** Returns the target of an export specifier without following aliases */
	getExportSpecifierLocalTargetSymbol := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ExportSpecifier | Identifier */ any) Symbol {
		if isExportSpecifier(node) {
			name := node.propertyName || node.name
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node.parent.parent.moduleSpecifier:
				return getExternalModuleMember(node.parent.parent, node)
			case name.kind == SyntaxKindStringLiteral:
				return nil
			default:
				return resolveEntityName(name, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias)
			}
		} else {
			return resolveEntityName(node, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias)
		}
	}
	getTypeOfNode := func(node Node) Type {
		if isSourceFile(node) && !isExternalModule(node) {
			return errorType
		}
		if node.flags & NodeFlagsInWithStatement {
			// We cannot answer semantic questions within a with block, do not proceed any further
			return errorType
		}
		classDecl := tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node)
		classType := classDecl && getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(classDecl.class))
		if isPartOfTypeNode(node) {
			typeFromTypeNode := getTypeFromTypeNode(node /* as TypeNode */)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case classType:
				return getTypeWithThisArgument(typeFromTypeNode, classType.thisType)
			default:
				return typeFromTypeNode
			}
		}
		if isExpressionNode(node) {
			return getRegularTypeOfExpression(node /* as Expression */)
		}
		if classType && !classDecl.isImplements {
			// A SyntaxKind.ExpressionWithTypeArguments is considered a type node, except when it occurs in the
			// extends clause of a class. We handle that case here.
			baseType := firstOrUndefined(getBaseTypes(classType))
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case baseType:
				return getTypeWithThisArgument(baseType, classType.thisType)
			default:
				return errorType
			}
		}
		if isTypeDeclaration(node) {
			// In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
			symbol := getSymbolOfDeclaration(node)
			return getDeclaredTypeOfSymbol(symbol)
		}
		if isTypeDeclarationName(node) {
			symbol := getSymbolAtLocation(node)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case symbol:
				return getDeclaredTypeOfSymbol(symbol)
			default:
				return errorType
			}
		}
		if isBindingElement(node) {
			return getTypeForVariableLikeDeclaration(node /*includeOptionality*/, true, CheckModeNormal) || errorType
		}
		if isDeclaration(node) {
			// In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
			symbol := getSymbolOfDeclaration(node)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case symbol:
				return getTypeOfSymbol(symbol)
			default:
				return errorType
			}
		}
		if isDeclarationNameOrImportPropertyName(node) {
			symbol := getSymbolAtLocation(node)
			if symbol {
				return getTypeOfSymbol(symbol)
			}
			return errorType
		}
		if isBindingPattern(node) {
			return getTypeForVariableLikeDeclaration(node.parent /*includeOptionality*/, true, CheckModeNormal) || errorType
		}
		if isInRightSideOfImportOrExportAssignment(node /* as Identifier */) {
			symbol := getSymbolAtLocation(node)
			if symbol {
				declaredType := getDeclaredTypeOfSymbol(symbol)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case !isErrorType(declaredType):
					return declaredType
				default:
					return getTypeOfSymbol(symbol)
				}
			}
		}
		if isMetaProperty(node.parent) && node.parent.keywordToken == node.kind {
			return checkMetaPropertyKeyword(node.parent)
		}
		if isImportAttributes(node) {
			return getGlobalImportAttributesType(false)
		}
		return errorType
	}
	// Gets the type of object literal or array literal of destructuring assignment.
	// { a } from
	//     for ( { a } of elems) {
	//     }
	// [ a ] from
	//     [a] = [ some array ...]
	getTypeOfAssignmentPattern := func(expr AssignmentPattern) Type {
		Debug.assert(expr.kind == SyntaxKindObjectLiteralExpression || expr.kind == SyntaxKindArrayLiteralExpression)
		// If this is from "for of"
		//     for ( { a } of elems) {
		//     }
		if expr.parent.kind == SyntaxKindForOfStatement {
			iteratedType := checkRightHandSideOfForOf(expr.parent /* as ForOfStatement */)
			return checkDestructuringAssignment(expr, iteratedType || errorType)
		}
		// If this is from "for" initializer
		//     for ({a } = elems[0];.....) { }
		if expr.parent.kind == SyntaxKindBinaryExpression {
			iteratedType := getTypeOfExpression((expr.parent /* as BinaryExpression */).right)
			return checkDestructuringAssignment(expr, iteratedType || errorType)
		}
		// If this is from nested object binding pattern
		//     for ({ skills: { primary, secondary } } = multiRobot, i = 0; i < 1; i++) {
		if expr.parent.kind == SyntaxKindPropertyAssignment {
			node := cast(expr.parent.parent, isObjectLiteralExpression)
			typeOfParentObjectLiteral := getTypeOfAssignmentPattern(node) || errorType
			propertyIndex := indexOfNode(node.properties, expr.parent)
			return checkObjectLiteralDestructuringPropertyAssignment(node, typeOfParentObjectLiteral, propertyIndex)
		}
		// Array literal assignment - array destructuring pattern
		node := cast(expr.parent, isArrayLiteralExpression)
		//    [{ property1: p1, property2 }] = elems;
		typeOfArrayLiteral := getTypeOfAssignmentPattern(node) || errorType
		elementType := checkIteratedTypeOrElementType(IterationUseDestructuring, typeOfArrayLiteral, undefinedType, expr.parent) || errorType
		return checkArrayLiteralDestructuringElementAssignment(node, typeOfArrayLiteral, node.elements.indexOf(expr), elementType)
	}
	// Gets the property symbol corresponding to the property in destructuring assignment
	// 'property1' from
	//     for ( { property1: a } of elems) {
	//     }
	// 'property1' at location 'a' from:
	//     [a] = [ property1, property2 ]
	getPropertySymbolOfDestructuringAssignment := func(location Identifier) Symbol {
		// Get the type of the object or array literal and then look for property of given name in the type
		typeOfObjectLiteral := getTypeOfAssignmentPattern(cast(location.parent.parent, isAssignmentPattern))
		return typeOfObjectLiteral && getPropertyOfType(typeOfObjectLiteral, location.escapedText)
	}
	getRegularTypeOfExpression := func(expr Expression) Type {
		if isRightSideOfQualifiedNameOrPropertyAccess(expr) {
			expr = expr.parent /* as Expression */
		}
		return getRegularTypeOfLiteralType(getTypeOfExpression(expr))
	}
	/**
	 * Gets either the static or instance type of a class element, based on
	 * whether the element is declared as "static".
	 */
	getParentTypeOfClassElement := func(node ClassElement) Type {
		classSymbol := getSymbolOfNode(node.parent)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isStatic(node):
			return getTypeOfSymbol(classSymbol)
		default:
			return getDeclaredTypeOfSymbol(classSymbol)
		}
	}
	getClassElementPropertyKeyType := func(element ClassElement) Type {
		name := element.name
		switch name.kind {
		case SyntaxKindIdentifier:
			return getStringLiteralType(idText(name))
		case SyntaxKindNumericLiteral:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindStringLiteral:
			return getStringLiteralType(name.text)
		case SyntaxKindComputedPropertyName:
			nameType := checkComputedPropertyName(name)
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isTypeAssignableToKind(nameType, TypeFlagsESSymbolLike):
				return nameType
			default:
				return stringType
			}
		default:
			return Debug.fail("Unsupported property name.")
		}
	}
	// Return the list of properties of the given type, augmented with properties from Function
	// if the type has call or construct signatures
	getAugmentedPropertiesOfType := func(type_ Type) []Symbol {
		type_ = getApparentType(type_)
		propsByName := createSymbolTable(getPropertiesOfType(type_))
		var functionType *ObjectType
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case getSignaturesOfType(type_, SignatureKindCall).length:
			functionType = globalCallableFunctionType
		case getSignaturesOfType(type_, SignatureKindConstruct).length:
			functionType = globalNewableFunctionType
		default:
			functionType = nil
		}
		if functionType {
			forEach(getPropertiesOfType(functionType), func(p Symbol) {
				if !propsByName.has(p.escapedName) {
					propsByName.set(p.escapedName, p)
				}
			})
		}
		return getNamedMembers(propsByName)
	}
	typeHasCallOrConstructSignatures := func(type_ Type) bool {
		return getSignaturesOfType(type_, SignatureKindCall).length != 0 || getSignaturesOfType(type_, SignatureKindConstruct).length != 0
	}
	getRootSymbols := func(symbol Symbol) []Symbol {
		roots := getImmediateRootSymbols(symbol)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case roots:
			return flatMap(roots, getRootSymbols)
		default:
			return []Symbol{symbol}
		}
	}
	getImmediateRootSymbols := func(symbol Symbol) *[]Symbol {
		if getCheckFlags(symbol) & CheckFlagsSynthetic {
			return mapDefined(getSymbolLinks(symbol).containingType.types, func(type_ Type) Symbol {
				return getPropertyOfType(type_, symbol.escapedName)
			})
		} else if symbol.flags & SymbolFlagsTransient {
			TODO_IDENTIFIER := symbol /* as TransientSymbol */
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case leftSpread:
				return []Symbol{leftSpread, rightSpread}
			case syntheticOrigin:
				return []Symbol{syntheticOrigin}
			default:
				return singleElementArray(tryGetTarget(symbol))
			}
		}
		return nil
	}
	tryGetTarget := func(symbol Symbol) Symbol {
		var target Symbol
		var next Symbol = symbol
		for /* TODO(TS-TO-GO) Node BinaryExpression: next = getSymbolLinks(next).target */ TODO {
			target = next
		}
		return target
	}
	// Emitter support
	isArgumentsLocalBinding := func(nodeIn Identifier) bool {
		// Note: does not handle isShorthandPropertyAssignment (and probably a few more)
		if isGeneratedIdentifier(nodeIn) {
			return false
		}
		node := getParseTreeNode(nodeIn, isIdentifier)
		if !node {
			return false
		}
		parent := node.parent
		if !parent {
			return false
		}
		isPropertyName := (isPropertyAccessExpression(parent) || isPropertyAssignment(parent)) && parent.name == node
		return !isPropertyName && getReferencedValueSymbol(node) == argumentsSymbol
	}
	isNameOfModuleOrEnumDeclaration := func(node Identifier) bool {
		return isModuleOrEnumDeclaration(node.parent) && node == node.parent.name
	}
	// When resolved as an expression identifier, if the given node references an exported entity, return the declaration
	// node of the exported entity's container. Otherwise, return undefined.
	getReferencedExportContainer := func(nodeIn Identifier, prefixLocals bool) /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | ModuleDeclaration | EnumDeclaration | undefined */ any {
		node := getParseTreeNode(nodeIn, isIdentifier)
		if node {
			// When resolving the export container for the name of a module or enum
			// declaration, we need to start resolution at the declaration's container.
			// Otherwise, we could incorrectly resolve the export container as the
			// declaration if it contains an exported member with the same name.
			symbol := getReferencedValueSymbol(node /*startInDeclarationContainer*/, isNameOfModuleOrEnumDeclaration(node))
			if symbol {
				if symbol.flags & SymbolFlagsExportValue {
					// If we reference an exported entity within the same module declaration, then whether
					// we prefix depends on the kind of entity. SymbolFlags.ExportHasLocal encompasses all the
					// kinds that we do NOT prefix.
					exportSymbol := getMergedSymbol(symbol.exportSymbol)
					if !prefixLocals && exportSymbol.flags&SymbolFlagsExportHasLocal && !(exportSymbol.flags & SymbolFlagsVariable) {
						return nil
					}
					symbol = exportSymbol
				}
				parentSymbol := getParentOfSymbol(symbol)
				if parentSymbol {
					if parentSymbol.flags&SymbolFlagsValueModule && parentSymbol.valueDeclaration. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindSourceFile {
						symbolFile := parentSymbol.valueDeclaration /* as SourceFile */
						referenceFile := getSourceFileOfNode(node)
						// If `node` accesses an export and that export isn't in the same file, then symbol is a namespace export, so return undefined.
						symbolIsUmdExport := symbolFile != referenceFile
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case symbolIsUmdExport:
							return nil
						default:
							return symbolFile
						}
					}
					return findAncestor(node.parent, func(n Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: n is ModuleDeclaration | EnumDeclaration */ any {
						return isModuleOrEnumDeclaration(n) && getSymbolOfDeclaration(n) == parentSymbol
					})
				}
			}
		}
	}
	// When resolved as an expression identifier, if the given node references an import, return the declaration of
	// that import. Otherwise, return undefined.
	getReferencedImportDeclaration := func(nodeIn Identifier) Declaration {
		specifier := getIdentifierGeneratedImportReference(nodeIn)
		if specifier {
			return specifier
		}
		node := getParseTreeNode(nodeIn, isIdentifier)
		if node {
			symbol := getReferencedValueOrAliasSymbol(node)
			// We should only get the declaration of an alias if there isn't a local value
			// declaration for the symbol
			if isNonLocalAlias(symbol /*excludes*/, SymbolFlagsValue) && !getTypeOnlyAliasDeclaration(symbol, SymbolFlagsValue) {
				return getDeclarationOfAliasSymbol(symbol)
			}
		}
		return nil
	}
	isSymbolOfDestructuredElementOfCatchBinding := func(symbol Symbol) *bool {
		return symbol.valueDeclaration && isBindingElement(symbol.valueDeclaration) && walkUpBindingElementsAndPatterns(symbol.valueDeclaration).parent.kind == SyntaxKindCatchClause
	}
	isSymbolOfDeclarationWithCollidingName := func(symbol Symbol) bool {
		if symbol.flags&SymbolFlagsBlockScoped && symbol.valueDeclaration && !isSourceFile(symbol.valueDeclaration) {
			links := getSymbolLinks(symbol)
			if links.isDeclarationWithCollidingName == nil {
				container := getEnclosingBlockScopeContainer(symbol.valueDeclaration)
				if isStatementWithLocals(container) || isSymbolOfDestructuredElementOfCatchBinding(symbol) {
					if resolveName(container.parent, symbol.escapedName, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, false) {
						// redeclaration - always should be renamed
						links.isDeclarationWithCollidingName = true
					} else if hasNodeCheckFlag(symbol.valueDeclaration, NodeCheckFlagsCapturedBlockScopedBinding) {
						// binding is captured in the function
						// should be renamed if:
						// - binding is not top level - top level bindings never collide with anything
						// AND
						//   - binding is not declared in loop, should be renamed to avoid name reuse across siblings
						//     let a, b
						//     { let x = 1; a = () => x; }
						//     { let x = 100; b = () => x; }
						//     console.log(a()); // should print '1'
						//     console.log(b()); // should print '100'
						//     OR
						//   - binding is declared inside loop but not in inside initializer of iteration statement or directly inside loop body
						//     * variables from initializer are passed to rewritten loop body as parameters so they are not captured directly
						//     * variables that are declared immediately in loop body will become top level variable after loop is rewritten and thus
						//       they will not collide with anything
						isDeclaredInLoop := hasNodeCheckFlag(symbol.valueDeclaration, NodeCheckFlagsBlockScopedBindingInLoop)
						inLoopInitializer := isIterationStatement(container /*lookInLabeledStatements*/, false)
						inLoopBodyBlock := container.kind == SyntaxKindBlock && isIterationStatement(container.parent /*lookInLabeledStatements*/, false)
						links.isDeclarationWithCollidingName = !isBlockScopedContainerTopLevel(container) && (!isDeclaredInLoop || (!inLoopInitializer && !inLoopBodyBlock))
					} else {
						links.isDeclarationWithCollidingName = false
					}
				}
			}
			return links.isDeclarationWithCollidingName
		}
		return false
	}
	// When resolved as an expression identifier, if the given node references a nested block scoped entity with
	// a name that either hides an existing name or might hide it when compiled downlevel,
	// return the declaration of that entity. Otherwise, return undefined.
	getReferencedDeclarationWithCollidingName := func(nodeIn Identifier) Declaration {
		if !isGeneratedIdentifier(nodeIn) {
			node := getParseTreeNode(nodeIn, isIdentifier)
			if node {
				symbol := getReferencedValueSymbol(node)
				if symbol && isSymbolOfDeclarationWithCollidingName(symbol) {
					return symbol.valueDeclaration
				}
			}
		}
		return nil
	}
	// Return true if the given node is a declaration of a nested block scoped entity with a name that either hides an
	// existing name or might hide a name when compiled downlevel
	isDeclarationWithCollidingName := func(nodeIn Declaration) bool {
		node := getParseTreeNode(nodeIn, isDeclaration)
		if node {
			symbol := getSymbolOfDeclaration(node)
			if symbol {
				return isSymbolOfDeclarationWithCollidingName(symbol)
			}
		}
		return false
	}
	isValueAliasDeclaration := func(node Node) bool {
		Debug.assert(canCollectSymbolAliasAccessabilityData)
		switch node.kind {
		case SyntaxKindImportEqualsDeclaration:
			return isAliasResolvedToValue(getSymbolOfDeclaration(node /* as ImportEqualsDeclaration */))
		case SyntaxKindImportClause:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNamespaceImport:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindImportSpecifier:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindExportSpecifier:
			symbol := getSymbolOfDeclaration(node /* as ImportClause | NamespaceImport | ImportSpecifier | ExportSpecifier */)
			return !!symbol && isAliasResolvedToValue(symbol /*excludeTypeOnlyValues*/, true)
		case SyntaxKindExportDeclaration:
			exportClause := (node /* as ExportDeclaration */).exportClause
			return !!exportClause && (isNamespaceExport(exportClause) || some(exportClause.elements, isValueAliasDeclaration))
		case SyntaxKindExportAssignment:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case (node /* as ExportAssignment */).expression && (node /* as ExportAssignment */).expression.kind == SyntaxKindIdentifier:
				return isAliasResolvedToValue(getSymbolOfDeclaration(node /* as ExportAssignment */) /*excludeTypeOnlyValues*/, true)
			default:
				return true
			}
		}
		return false
	}
	isTopLevelValueImportEqualsWithEntityName := func(nodeIn ImportEqualsDeclaration) bool {
		node := getParseTreeNode(nodeIn, isImportEqualsDeclaration)
		if node == nil || node.parent.kind != SyntaxKindSourceFile || !isInternalModuleImportEqualsDeclaration(node) {
			// parent is not source file or it is not reference to internal module
			return false
		}
		isValue := isAliasResolvedToValue(getSymbolOfDeclaration(node))
		return isValue && node.moduleReference && !nodeIsMissing(node.moduleReference)
	}
	isAliasResolvedToValue := func(symbol Symbol, excludeTypeOnlyValues bool) bool {
		if !symbol {
			return false
		}
		container := getSourceFileOfNode(symbol.valueDeclaration)
		fileSymbol := container && getSymbolOfDeclaration(container)
		// Ensures cjs export assignment is setup, since this symbol may point at, and merge with, the file itself.
		// If we don't, the merge may not have yet occured, and the flags check below will be missing flags that
		// are added as a result of the merge.
		resolveExternalModuleSymbol(fileSymbol)
		target := getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol))
		if target == unknownSymbol {
			return !excludeTypeOnlyValues || !getTypeOnlyAliasDeclaration(symbol)
		}
		// const enums and modules that contain only const enums are not considered values from the emit perspective
		// unless 'preserveConstEnums' option is set to true
		return !!(getSymbolFlags(symbol, excludeTypeOnlyValues /*excludeLocalMeanings*/, true) & SymbolFlagsValue) && (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target))
	}
	isConstEnumOrConstEnumOnlyModule := func(s Symbol) bool {
		return isConstEnumSymbol(s) || !!s.constEnumOnlyModule
	}
	isReferencedAliasDeclaration := func(node Node, checkChildren bool) bool {
		Debug.assert(canCollectSymbolAliasAccessabilityData)
		if isAliasSymbolDeclaration(node) {
			symbol := getSymbolOfDeclaration(node /* as Declaration */)
			links := symbol && getSymbolLinks(symbol)
			if links. /* TODO(TS-TO-GO): was ? */ referenced {
				return true
			}
			target := getSymbolLinks(symbol).aliasTarget
			if target && getEffectiveModifierFlags(node)&ModifierFlagsExport && getSymbolFlags(target)&SymbolFlagsValue && (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target)) {
				// An `export import ... =` of a value symbol is always considered referenced
				return true
			}
		}
		if checkChildren {
			return !!forEachChild(node, func(node Node) bool {
				return isReferencedAliasDeclaration(node, checkChildren)
			})
		}
		return false
	}
	isImplementationOfOverload := func(node SignatureDeclaration) bool {
		if nodeIsPresent((node /* as FunctionLikeDeclaration */).body) {
			if isGetAccessor(node) || isSetAccessor(node) {
				return false
				// Get or set accessors can never be overload implementations, but can have up to 2 signatures
			}
			// Get or set accessors can never be overload implementations, but can have up to 2 signatures
			symbol := getSymbolOfDeclaration(node)
			signaturesOfSymbol := getSignaturesOfSymbol(symbol)
			// If this function body corresponds to function with multiple signature, it is implementation of overload
			// e.g.: function foo(a: string): string;
			//       function foo(a: number): number;
			//       function foo(a: any) { // This is implementation of the overloads
			//           return a;
			//       }
			return signaturesOfSymbol.length > 1 || (signaturesOfSymbol.length == 1 && signaturesOfSymbol[0].declaration != node)
		}
		return false
	}
	declaredParameterTypeContainsUndefined := func(parameter /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag */ any) bool {
		typeNode := getNonlocalEffectiveTypeAnnotationNode(parameter)
		if !typeNode {
			return false
		}
		type_ := getTypeFromTypeNode(typeNode)
		return containsUndefinedType(type_)
	}
	requiresAddingImplicitUndefined := func(parameter /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) bool {
		return (isRequiredInitializedParameter(parameter, enclosingDeclaration) || isOptionalUninitializedParameterProperty(parameter)) && !declaredParameterTypeContainsUndefined(parameter)
	}
	isRequiredInitializedParameter := func(parameter /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) bool {
		if !strictNullChecks || isOptionalParameter(parameter) || isJSDocParameterTag(parameter) || !parameter.initializer {
			return false
		}
		if hasSyntacticModifier(parameter, ModifierFlagsParameterPropertyModifier) {
			return !!enclosingDeclaration && isFunctionLikeDeclaration(enclosingDeclaration)
		}
		return true
	}
	isOptionalUninitializedParameterProperty := func(parameter /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag */ any) bool {
		return strictNullChecks && isOptionalParameter(parameter) && (isJSDocParameterTag(parameter) || !parameter.initializer) && hasSyntacticModifier(parameter, ModifierFlagsParameterPropertyModifier)
	}
	isExpandoFunctionDeclaration := func(node Declaration) bool {
		declaration := getParseTreeNode(node, func(n Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: n is FunctionDeclaration | VariableDeclaration */ any {
			return isFunctionDeclaration(n) || isVariableDeclaration(n)
		})
		if !declaration {
			return false
		}
		var symbol Symbol
		if isVariableDeclaration(declaration) {
			if declaration.type_ || (!isInJSFile(declaration) && !isVarConstLike(declaration)) {
				return false
			}
			initializer := getDeclaredExpandoInitializer(declaration)
			if !initializer || !canHaveSymbol(initializer) {
				return false
			}
			symbol = getSymbolOfDeclaration(initializer)
		} else {
			symbol = getSymbolOfDeclaration(declaration)
		}
		if !symbol || !(symbol.flags&SymbolFlagsFunction | SymbolFlagsVariable) {
			return false
		}
		return !!forEachEntry(getExportsOfSymbol(symbol), func(p Symbol) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
			return p.flags&SymbolFlagsValue && isExpandoPropertyDeclaration(p.valueDeclaration)
		})
	}
	getPropertiesOfContainerFunction := func(node Declaration) []Symbol {
		declaration := getParseTreeNode(node, isFunctionDeclaration)
		if !declaration {
			return emptyArray
		}
		symbol := getSymbolOfDeclaration(declaration)
		return symbol && getPropertiesOfType(getTypeOfSymbol(symbol)) || emptyArray
	}
	getNodeCheckFlags := func(node Node) NodeCheckFlags {
		nodeId := node.id || 0
		if nodeId < 0 || nodeId >= nodeLinks.length {
			return 0
		}
		return nodeLinks[nodeId]. /* TODO(TS-TO-GO): was ? */ flags || 0
	}
	hasNodeCheckFlag := func(node Node, flag LazyNodeCheckFlags) bool {
		calculateNodeCheckFlagWorker(node, flag)
		return !!(getNodeCheckFlags(node) & flag)
	}
	calculateNodeCheckFlagWorker := func(node Node, flag LazyNodeCheckFlags) {
		if !compilerOptions.noCheck && canIncludeBindAndCheckDiagnostics(getSourceFileOfNode(node), compilerOptions) {
			// Unless noCheck is passed, assume calculation of node check flags has been done eagerly.
			// This saves needing to mark up where in the eager traversal certain results are "done",
			// just to reconcile the eager and lazy results. This wouldn't be hard if an eager typecheck
			// was actually an in-order traversal, but it isn't - some nodes are deferred, and so don't
			// have these node check flags calculated until that deferral is completed. As an example,
			// in concept, we could consider a class that we've called `checkSourceElement` on as having had
			// these flags calculated, but since the method bodies are deferred, we actually can't set the
			// flags as having been calculated until that deferral is completed.
			// The downside to this either/or approach to eager or lazy calculation is that we can't combine
			// a partial eager traversal and lazy calculation for the missing bits, and there's a bit of
			// overlap in functionality. This isn't a huge loss for any usecases today, but would be nice
			// alongside language service partial file checking and editor-triggered emit.
			return
		}
		links := getNodeLinks(node)
		if links.calculatedFlags & flag {
			return
		}
		// This is only the set of `NodeCheckFlags` our emitter actually looks for, not all of them
		switch flag {
		case NodeCheckFlagsSuperInstance:
			fallthrough // TODO(TS-TO-GO): merge cases
		case NodeCheckFlagsSuperStatic:
			return checkSingleSuperExpression(node)
		case NodeCheckFlagsMethodWithSuperPropertyAccessInAsync:
			fallthrough // TODO(TS-TO-GO): merge cases
		case NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync:
			fallthrough // TODO(TS-TO-GO): merge cases
		case NodeCheckFlagsContainsSuperPropertyInStaticInitializer:
			return checkChildSuperExpressions(node)
		case NodeCheckFlagsCaptureArguments:
			fallthrough // TODO(TS-TO-GO): merge cases
		case NodeCheckFlagsContainsCapturedBlockScopeBinding:
			fallthrough // TODO(TS-TO-GO): merge cases
		case NodeCheckFlagsNeedsLoopOutParameter:
			fallthrough // TODO(TS-TO-GO): merge cases
		case NodeCheckFlagsContainsConstructorReference:
			return checkChildIdentifiers(node)
		case NodeCheckFlagsConstructorReference:
			return checkSingleIdentifier(node)
		case NodeCheckFlagsLoopWithCapturedBlockScopedBinding:
			fallthrough // TODO(TS-TO-GO): merge cases
		case NodeCheckFlagsBlockScopedBindingInLoop:
			fallthrough // TODO(TS-TO-GO): merge cases
		case NodeCheckFlagsCapturedBlockScopedBinding:
			return checkContainingBlockScopeBindingUses(node)
		default:
			return Debug.assertNever(flag, __TEMPLATE__("Unhandled node check flag calculation: ", Debug.formatNodeCheckFlags(flag)))
		}
		forEachNodeRecursively := func(root Node, cb func(node Node, parent Node) /* TODO(TS-TO-GO) TypeNode UnionType: T | "skip" | undefined */ any) *T {
			rootResult := cb(root, root.parent)
			if rootResult == "skip" {
				return nil
			}
			if rootResult {
				return rootResult
			}
			return forEachChildRecursively(root, cb)
		}
		checkSuperExpressions := func(node Node) * /* TODO(TS-TO-GO) inferred type "skip" */ any {
			links := getNodeLinks(node)
			if links.calculatedFlags & flag {
				return "skip"
			}
			links.calculatedFlags |= NodeCheckFlagsMethodWithSuperPropertyAccessInAsync | NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync | NodeCheckFlagsContainsSuperPropertyInStaticInitializer
			checkSingleSuperExpression(node)
			return nil
		}
		checkChildSuperExpressions := func(node Node) {
			forEachNodeRecursively(node, checkSuperExpressions)
		}
		checkSingleSuperExpression := func(node Node) {
			nodeLinks := getNodeLinks(node)
			// This is called on sub-nodes of the original input, make sure we set `calculatedFlags` on the correct node
			nodeLinks.calculatedFlags |= NodeCheckFlagsSuperInstance | NodeCheckFlagsSuperStatic
			// Yes, we set this on non-applicable nodes, so we can entirely skip the traversal on future calls
			if node.kind == SyntaxKindSuperKeyword {
				checkSuperExpression(node)
			}
		}
		checkIdentifiers := func(node Node) * /* TODO(TS-TO-GO) inferred type "skip" */ any {
			links := getNodeLinks(node)
			if links.calculatedFlags & flag {
				return "skip"
			}
			links.calculatedFlags |= NodeCheckFlagsCaptureArguments | NodeCheckFlagsContainsCapturedBlockScopeBinding | NodeCheckFlagsNeedsLoopOutParameter | NodeCheckFlagsContainsConstructorReference
			checkSingleIdentifier(node)
			return nil
		}
		checkChildIdentifiers := func(node Node) {
			forEachNodeRecursively(node, checkIdentifiers)
		}
		isExpressionNodeOrShorthandPropertyAssignmentName := func(node Identifier) bool {
			// TODO(jakebailey): Just use isExpressionNode once that considers these identifiers to be expressions.
			return isExpressionNode(node) || isShorthandPropertyAssignment(node.parent) && ( /* TODO(TS-TO-GO) Node BinaryExpression: node.parent.objectAssignmentInitializer ?? node.parent.name */ TODO) == node
		}
		checkSingleIdentifier := func(node Node) {
			nodeLinks := getNodeLinks(node)
			nodeLinks.calculatedFlags |= NodeCheckFlagsConstructorReference
			if isIdentifier(node) {
				nodeLinks.calculatedFlags |= NodeCheckFlagsBlockScopedBindingInLoop | NodeCheckFlagsCapturedBlockScopedBinding
				// Can't set on all arbitrary nodes (these nodes have this flag set by `checkSingleBlockScopeBinding` only)
				if isExpressionNodeOrShorthandPropertyAssignmentName(node) && !(isPropertyAccessExpression(node.parent) && node.parent.name == node) {
					s := getResolvedSymbol(node)
					if s && s != unknownSymbol {
						checkIdentifierCalculateNodeCheckFlags(node, s)
					}
				}
			}
		}
		checkBlockScopeBindings := func(node Node) * /* TODO(TS-TO-GO) inferred type "skip" */ any {
			links := getNodeLinks(node)
			if links.calculatedFlags & flag {
				return "skip"
			}
			links.calculatedFlags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding | NodeCheckFlagsBlockScopedBindingInLoop | NodeCheckFlagsCapturedBlockScopedBinding
			checkSingleBlockScopeBinding(node)
			return nil
		}
		checkContainingBlockScopeBindingUses := func(node Node) {
			scope := getEnclosingBlockScopeContainer(__COND__(isDeclarationName(node), node.parent, node))
			forEachNodeRecursively(scope, checkBlockScopeBindings)
		}
		checkSingleBlockScopeBinding := func(node Node) {
			checkSingleIdentifier(node)
			if isComputedPropertyName(node) {
				checkComputedPropertyName(node)
			}
			if isPrivateIdentifier(node) && isClassElement(node.parent) {
				setNodeLinksForPrivateIdentifierScope(node.parent /* as PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration */)
			}
		}
	}
	getEnumMemberValue := func(node EnumMember) EvaluatorResult {
		computeEnumMemberValues(node.parent)
		return /* TODO(TS-TO-GO) Node BinaryExpression: getNodeLinks(node).enumMemberValue ?? evaluatorResult(/*value* / undefined) */ TODO
	}
	canHaveConstantValue := func(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is EnumMember | AccessExpression */ any {
		switch node.kind {
		case SyntaxKindEnumMember:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindElementAccessExpression:
			return true
		}
		return false
	}
	getConstantValue := func(node /* TODO(TS-TO-GO) TypeNode UnionType: EnumMember | AccessExpression */ any) /* TODO(TS-TO-GO) TypeNode UnionType: string | number | undefined */ any {
		if node.kind == SyntaxKindEnumMember {
			return getEnumMemberValue(node).value
		}
		if !getNodeLinks(node).resolvedSymbol {
			checkExpressionCached(node)
			// ensure cached resolved symbol is set
		}
		symbol := getNodeLinks(node).resolvedSymbol || (__COND__(isEntityNameExpression(node), resolveEntityName(node, SymbolFlagsValue /*ignoreErrors*/, true), nil))
		if symbol && (symbol.flags & SymbolFlagsEnumMember) {
			// inline property\index accesses only for const enums
			member := symbol.valueDeclaration /* as EnumMember */
			if isEnumConst(member.parent) {
				return getEnumMemberValue(member).value
			}
		}
		return nil
	}
	isFunctionType := func(type_ Type) bool {
		return !!(type_.flags & TypeFlagsObject) && getSignaturesOfType(type_, SignatureKindCall).length > 0
	}
	getTypeReferenceSerializationKind := func(typeNameIn EntityName, location Node) TypeReferenceSerializationKind {
		// ensure both `typeName` and `location` are parse tree nodes.
		typeName := getParseTreeNode(typeNameIn, isEntityName)
		if !typeName {
			return TypeReferenceSerializationKindUnknown
		}
		if location {
			location = getParseTreeNode(location)
			if !location {
				return TypeReferenceSerializationKindUnknown
			}
		}
		// Resolve the symbol as a value to ensure the type can be reached at runtime during emit.
		isTypeOnly := false
		if isQualifiedName(typeName) {
			rootValueSymbol := resolveEntityName(getFirstIdentifier(typeName), SymbolFlagsValue /*ignoreErrors*/, true /*dontResolveAlias*/, true, location)
			isTypeOnly = !!rootValueSymbol. /* TODO(TS-TO-GO): was ? */ declarations. /* TODO(TS-TO-GO): was ? */ every(isTypeOnlyImportOrExportDeclaration)
		}
		valueSymbol := resolveEntityName(typeName, SymbolFlagsValue /*ignoreErrors*/, true /*dontResolveAlias*/, true, location)
		var resolvedValueSymbol Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case valueSymbol && valueSymbol.flags&SymbolFlagsAlias:
			resolvedValueSymbol = resolveAlias(valueSymbol)
		default:
			resolvedValueSymbol = valueSymbol
		}
		/* TODO(TS-TO-GO) Node BinaryExpression: isTypeOnly ||= !!(valueSymbol && getTypeOnlyAliasDeclaration(valueSymbol, SymbolFlags.Value)) */ TODO
		// Resolve the symbol as a type so that we can provide a more useful hint for the type serializer.
		typeSymbol := resolveEntityName(typeName, SymbolFlagsType /*ignoreErrors*/, true /*dontResolveAlias*/, true, location)
		var resolvedTypeSymbol Symbol
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case typeSymbol && typeSymbol.flags&SymbolFlagsAlias:
			resolvedTypeSymbol = resolveAlias(typeSymbol)
		default:
			resolvedTypeSymbol = typeSymbol
		}
		// In case the value symbol can't be resolved (e.g. because of missing declarations), use type symbol for reachability check.
		if !valueSymbol {
			/* TODO(TS-TO-GO) Node BinaryExpression: isTypeOnly ||= !!(typeSymbol && getTypeOnlyAliasDeclaration(typeSymbol, SymbolFlags.Type)) */ TODO
		}
		if resolvedValueSymbol && resolvedValueSymbol == resolvedTypeSymbol {
			globalPromiseSymbol := getGlobalPromiseConstructorSymbol(false)
			if globalPromiseSymbol && resolvedValueSymbol == globalPromiseSymbol {
				return TypeReferenceSerializationKindPromise
			}
			constructorType := getTypeOfSymbol(resolvedValueSymbol)
			if constructorType && isConstructorType(constructorType) {
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isTypeOnly:
					return TypeReferenceSerializationKindTypeWithCallSignature
				default:
					return TypeReferenceSerializationKindTypeWithConstructSignatureAndValue
				}
			}
		}
		// We might not be able to resolve type symbol so use unknown type in that case (eg error case)
		if !resolvedTypeSymbol {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isTypeOnly:
				return TypeReferenceSerializationKindObjectType
			default:
				return TypeReferenceSerializationKindUnknown
			}
		}
		type_ := getDeclaredTypeOfSymbol(resolvedTypeSymbol)
		if isErrorType(type_) {
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case isTypeOnly:
				return TypeReferenceSerializationKindObjectType
			default:
				return TypeReferenceSerializationKindUnknown
			}
		} else if type_.flags & TypeFlagsAnyOrUnknown {
			return TypeReferenceSerializationKindObjectType
		} else if isTypeAssignableToKind(type_, TypeFlagsVoid|TypeFlagsNullable|TypeFlagsNever) {
			return TypeReferenceSerializationKindVoidNullableOrNeverType
		} else if isTypeAssignableToKind(type_, TypeFlagsBooleanLike) {
			return TypeReferenceSerializationKindBooleanType
		} else if isTypeAssignableToKind(type_, TypeFlagsNumberLike) {
			return TypeReferenceSerializationKindNumberLikeType
		} else if isTypeAssignableToKind(type_, TypeFlagsBigIntLike) {
			return TypeReferenceSerializationKindBigIntLikeType
		} else if isTypeAssignableToKind(type_, TypeFlagsStringLike) {
			return TypeReferenceSerializationKindStringLikeType
		} else if isTupleType(type_) {
			return TypeReferenceSerializationKindArrayLikeType
		} else if isTypeAssignableToKind(type_, TypeFlagsESSymbolLike) {
			return TypeReferenceSerializationKindESSymbolType
		} else if isFunctionType(type_) {
			return TypeReferenceSerializationKindTypeWithCallSignature
		} else if isArrayType(type_) {
			return TypeReferenceSerializationKindArrayLikeType
		} else {
			return TypeReferenceSerializationKindObjectType
		}
	}
	createTypeOfDeclaration := func(declarationIn /* TODO(TS-TO-GO) TypeNode UnionType: AccessorDeclaration | VariableLikeDeclaration | PropertyAccessExpression */ any, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
		declaration := getParseTreeNode(declarationIn, isVariableLikeOrAccessor)
		if !declaration {
			return factory.createToken(SyntaxKindAnyKeyword) /* as KeywordTypeNode */
		}
		// Get type of the symbol if this is the valid symbol otherwise get type at location
		symbol := getSymbolOfDeclaration(declaration)
		var type_ Type
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case symbol && !(symbol.flags & (SymbolFlagsTypeLiteral | SymbolFlagsSignature)):
			type_ = getWidenedLiteralType(getTypeOfSymbol(symbol))
		default:
			type_ = errorType
		}
		return nodeBuilder.serializeTypeForDeclaration(declaration, type_, symbol, enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
	}
	type DeclarationWithPotentialInnerNodeReuse /* TODO(TS-TO-GO) TypeNode UnionType: | SignatureDeclaration | JSDocSignature | AccessorDeclaration | VariableLikeDeclaration | PropertyAccessExpression | ExportAssignment */ any
	isDeclarationWithPossibleInnerTypeNodeReuse := func(declaration Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: declaration is DeclarationWithPotentialInnerNodeReuse */ any {
		return isFunctionLike(declaration) || isExportAssignment(declaration) || isVariableLike(declaration)
	}
	getAllAccessorDeclarationsForDeclaration := func(accessor AccessorDeclaration) AllAccessorDeclarations {
		accessor = getParseTreeNode(accessor, isGetOrSetAccessorDeclaration)
		// TODO: GH#18217
		var otherKind /* TODO(TS-TO-GO) inferred type SyntaxKind.GetAccessor | SyntaxKind.SetAccessor */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case accessor.kind == SyntaxKindSetAccessor:
			otherKind = SyntaxKindGetAccessor
		default:
			otherKind = SyntaxKindSetAccessor
		}
		otherAccessor := getDeclarationOfKind(getSymbolOfDeclaration(accessor), otherKind)
		var firstAccessor AccessorDeclaration
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case otherAccessor && (otherAccessor.pos < accessor.pos):
			firstAccessor = otherAccessor
		default:
			firstAccessor = accessor
		}
		var secondAccessor *AccessorDeclaration
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case otherAccessor && (otherAccessor.pos < accessor.pos):
			secondAccessor = accessor
		default:
			secondAccessor = otherAccessor
		}
		var setAccessor SetAccessorDeclaration
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case accessor.kind == SyntaxKindSetAccessor:
			setAccessor = accessor
		default:
			setAccessor = otherAccessor /* as SetAccessorDeclaration */
		}
		var getAccessor GetAccessorDeclaration
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case accessor.kind == SyntaxKindGetAccessor:
			getAccessor = accessor
		default:
			getAccessor = otherAccessor /* as GetAccessorDeclaration */
		}
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"firstAccessor":  firstAccessor,
			"secondAccessor": secondAccessor,
			"setAccessor":    setAccessor,
			"getAccessor":    getAccessor,
		}
	}
	getPossibleTypeNodeReuseExpression := func(declaration DeclarationWithPotentialInnerNodeReuse) Expression {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isFunctionLike(declaration) && !isSetAccessor(declaration):
			return getSingleReturnExpression(declaration)
		case isExportAssignment(declaration):
			return declaration.expression
		case !!(declaration /* as HasInitializer */).initializer:
			return (declaration /* as HasInitializer & typeof declaration */).initializer
		case isParameter(declaration) && isSetAccessor(declaration.parent):
			return getSingleReturnExpression(getAllAccessorDeclarationsForDeclaration(declaration.parent).getAccessor)
		default:
			return nil
		}
	}
	getSingleReturnExpression := func(declaration *SignatureDeclaration) Expression {
		var candidateExpr Expression
		if declaration && !nodeIsMissing((declaration /* as FunctionLikeDeclaration */).body) {
			if getFunctionFlags(declaration) & FunctionFlagsAsyncGenerator {
				return nil
			}
			body := (declaration /* as FunctionLikeDeclaration */).body
			if body && isBlock(body) {
				forEachReturnStatement(body, func(s ReturnStatement) *true {
					if !candidateExpr {
						candidateExpr = s.expression
					} else {
						candidateExpr = nil
						return true
					}
				})
			} else {
				candidateExpr = body
			}
		}
		return candidateExpr
	}
	createReturnTypeOfSignatureDeclaration := func(signatureDeclarationIn SignatureDeclaration, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
		signatureDeclaration := getParseTreeNode(signatureDeclarationIn, isFunctionLike)
		if !signatureDeclaration {
			return factory.createToken(SyntaxKindAnyKeyword) /* as KeywordTypeNode */
		}
		return nodeBuilder.serializeReturnTypeForSignature(getSignatureFromDeclaration(signatureDeclaration), enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
	}
	createTypeOfExpression := func(exprIn Expression, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
		expr := getParseTreeNode(exprIn, isExpression)
		if !expr {
			return factory.createToken(SyntaxKindAnyKeyword) /* as KeywordTypeNode */
		}
		type_ := getWidenedType(getRegularTypeOfExpression(expr))
		return nodeBuilder.expressionOrTypeToTypeNode(expr, type_ /*addUndefined*/, nil, enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
	}
	hasGlobalName := func(name string) bool {
		return globals.has(escapeLeadingUnderscores(name))
	}
	getReferencedValueSymbol := func(reference Identifier, startInDeclarationContainer bool) Symbol {
		resolvedSymbol := getNodeLinks(reference).resolvedSymbol
		if resolvedSymbol {
			return resolvedSymbol
		}
		var location Node = reference
		if startInDeclarationContainer {
			// When resolving the name of a declaration as a value, we need to start resolution
			// at a point outside of the declaration.
			parent := reference.parent
			if isDeclaration(parent) && reference == parent.name {
				location = getDeclarationContainer(parent)
			}
		}
		return resolveName(location, reference.escapedText, SymbolFlagsValue|SymbolFlagsExportValue|SymbolFlagsAlias /*nameNotFoundMessage*/, nil /*isUse*/, true)
	}
	/**
	 * Get either a value-meaning symbol or an alias symbol.
	 * Unlike `getReferencedValueSymbol`, if the cached resolved symbol is the unknown symbol,
	 * we call `resolveName` to find a symbol.
	 * This is because when caching the resolved symbol, we only consider value symbols, but here
	 * we want to also get an alias symbol if one exists.
	 */
	getReferencedValueOrAliasSymbol := func(reference Identifier) Symbol {
		resolvedSymbol := getNodeLinks(reference).resolvedSymbol
		if resolvedSymbol && resolvedSymbol != unknownSymbol {
			return resolvedSymbol
		}
		return resolveName(reference, reference.escapedText, SymbolFlagsValue|SymbolFlagsExportValue|SymbolFlagsAlias, nil, true, nil)
	}
	getReferencedValueDeclaration := func(referenceIn Identifier) Declaration {
		if !isGeneratedIdentifier(referenceIn) {
			reference := getParseTreeNode(referenceIn, isIdentifier)
			if reference {
				symbol := getReferencedValueSymbol(reference)
				if symbol {
					return getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration
				}
			}
		}
		return nil
	}
	getReferencedValueDeclarations := func(referenceIn Identifier) *[]Declaration {
		if !isGeneratedIdentifier(referenceIn) {
			reference := getParseTreeNode(referenceIn, isIdentifier)
			if reference {
				symbol := getReferencedValueSymbol(reference)
				if symbol {
					return filter(getExportSymbolOfValueSymbolIfExported(symbol).declarations, func(declaration Declaration) bool {
						switch declaration.kind {
						case SyntaxKindVariableDeclaration:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindParameter:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindBindingElement:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindPropertyDeclaration:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindPropertyAssignment:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindShorthandPropertyAssignment:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindEnumMember:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindObjectLiteralExpression:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindFunctionDeclaration:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindFunctionExpression:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindArrowFunction:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindClassDeclaration:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindClassExpression:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindEnumDeclaration:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindMethodDeclaration:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindGetAccessor:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindSetAccessor:
							fallthrough // TODO(TS-TO-GO): merge cases
						case SyntaxKindModuleDeclaration:
							return true
						}
						return false
					})
				}
			}
		}
		return nil
	}
	isLiteralConstDeclaration := func(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any) bool {
		if isDeclarationReadonly(node) || isVariableDeclaration(node) && isVarConstLike(node) {
			return isFreshLiteralType(getTypeOfSymbol(getSymbolOfDeclaration(node)))
		}
		return false
	}
	literalTypeToNode := func(type_ FreshableType, enclosing Node, tracker SymbolTracker) Expression {
		var enumResult * /* TODO(TS-TO-GO) inferred type false | Expression */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case type_.flags & TypeFlagsEnumLike:
			enumResult = nodeBuilder.symbolToExpression(type_.symbol, SymbolFlagsValue, enclosing /*flags*/, nil /*internalFlags*/, nil, tracker)
		case type_ == trueType:
			enumResult = factory.createTrue()
		default:
			enumResult = type_ == falseType && factory.createFalse()
		}
		if enumResult {
			return enumResult
		}
		literalValue := (type_ /* as LiteralType */).value
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case /* TODO(TS-TO-GO) Node TypeOfExpression: typeof literalValue */ TODO == "object":
			return factory.createBigIntLiteral(literalValue)
		case /* TODO(TS-TO-GO) Node TypeOfExpression: typeof literalValue */ TODO == "string":
			return factory.createStringLiteral(literalValue)
		case literalValue < 0:
			return factory.createPrefixUnaryExpression(SyntaxKindMinusToken, factory.createNumericLiteral(-literalValue))
		default:
			return factory.createNumericLiteral(literalValue)
		}
	}
	createLiteralConstValue := func(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any, tracker SymbolTracker) Expression {
		type_ := getTypeOfSymbol(getSymbolOfDeclaration(node))
		return literalTypeToNode(type_ /* as FreshableType */, node, tracker)
	}
	getJsxFactoryEntity := func(location Node) *EntityName {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case location:
			return ( /* TODO(TS-TO-GO) Node BinaryExpression: getJsxNamespace(location), (getSourceFileOfNode(location).localJsxFactory || _jsxFactoryEntity) */ TODO)
		default:
			return _jsxFactoryEntity
		}
	}
	getJsxFragmentFactoryEntity := func(location Node) *EntityName {
		if location {
			file := getSourceFileOfNode(location)
			if file {
				if file.localJsxFragmentFactory {
					return file.localJsxFragmentFactory
				}
				jsxFragPragmas := file.pragmas.get("jsxfrag")
				var jsxFragPragma /* TODO(TS-TO-GO) inferred type { arguments: { factory: string; }; range: CommentRange; } */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case isArray(jsxFragPragmas):
					jsxFragPragma = jsxFragPragmas[0]
				default:
					jsxFragPragma = jsxFragPragmas
				}
				if jsxFragPragma {
					file.localJsxFragmentFactory = parseIsolatedEntityName(jsxFragPragma.arguments.factory, languageVersion)
					return file.localJsxFragmentFactory
				}
			}
		}
		if compilerOptions.jsxFragmentFactory {
			return parseIsolatedEntityName(compilerOptions.jsxFragmentFactory, languageVersion)
		}
	}
	getNonlocalEffectiveTypeAnnotationNode := func(node Node) *TypeNode {
		direct := getEffectiveTypeAnnotationNode(node)
		if direct {
			return direct
		}
		if node.kind == SyntaxKindParameter && node.parent.kind == SyntaxKindSetAccessor {
			other := getAllAccessorDeclarationsForDeclaration(node.parent /* as SetAccessorDeclaration */).getAccessor
			if other {
				return getEffectiveReturnTypeNode(other)
			}
		}
		return nil
	}
	getNonlocalEffectiveReturnTypeAnnotationNode := func(node /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any) *TypeNode {
		direct := getEffectiveReturnTypeNode(node)
		if direct {
			return direct
		}
		if node.kind == SyntaxKindGetAccessor {
			other := getAllAccessorDeclarationsForDeclaration(node).setAccessor
			if other {
				param := getSetAccessorValueParameter(other)
				if param {
					return getEffectiveTypeAnnotationNode(param)
				}
			}
		}
		return nil
	}
	createResolver := func() EmitResolver {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"getReferencedExportContainer":              getReferencedExportContainer,
			"getReferencedImportDeclaration":            getReferencedImportDeclaration,
			"getReferencedDeclarationWithCollidingName": getReferencedDeclarationWithCollidingName,
			"isDeclarationWithCollidingName":            isDeclarationWithCollidingName,
			"isValueAliasDeclaration": func(nodeIn Node) bool {
				node := getParseTreeNode(nodeIn)
				// Synthesized nodes are always treated like values.
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case node && canCollectSymbolAliasAccessabilityData:
					return isValueAliasDeclaration(node)
				default:
					return true
				}
			},
			"hasGlobalName": hasGlobalName,
			"isReferencedAliasDeclaration": func(nodeIn Node, checkChildren *bool) bool {
				node := getParseTreeNode(nodeIn)
				// Synthesized nodes are always treated as referenced.
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case node && canCollectSymbolAliasAccessabilityData:
					return isReferencedAliasDeclaration(node, checkChildren)
				default:
					return true
				}
			},
			"hasNodeCheckFlag": func(nodeIn Node, flag LazyNodeCheckFlags) bool {
				node := getParseTreeNode(nodeIn)
				if !node {
					return false
				}
				return hasNodeCheckFlag(node, flag)
			},
			"isTopLevelValueImportEqualsWithEntityName": isTopLevelValueImportEqualsWithEntityName,
			"isDeclarationVisible":                      isDeclarationVisible,
			"isImplementationOfOverload":                isImplementationOfOverload,
			"requiresAddingImplicitUndefined":           requiresAddingImplicitUndefined,
			"isExpandoFunctionDeclaration":              isExpandoFunctionDeclaration,
			"getPropertiesOfContainerFunction":          getPropertiesOfContainerFunction,
			"createTypeOfDeclaration":                   createTypeOfDeclaration,
			"createReturnTypeOfSignatureDeclaration":    createReturnTypeOfSignatureDeclaration,
			"createTypeOfExpression":                    createTypeOfExpression,
			"createLiteralConstValue":                   createLiteralConstValue,
			"isSymbolAccessible":                        isSymbolAccessible,
			"isEntityNameVisible":                       isEntityNameVisible,
			"getConstantValue": func(nodeIn /* TODO(TS-TO-GO) inferred type PropertyAccessExpression | ElementAccessExpression | EnumMember */ any) * /* TODO(TS-TO-GO) inferred type string | number */ any {
				node := getParseTreeNode(nodeIn, canHaveConstantValue)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case node:
					return getConstantValue(node)
				default:
					return nil
				}
			},
			"getEnumMemberValue": func(nodeIn EnumMember) * /* TODO(TS-TO-GO) inferred type EvaluatorResult<string | number | undefined> */ any {
				node := getParseTreeNode(nodeIn, isEnumMember)
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case node:
					return getEnumMemberValue(node)
				default:
					return nil
				}
			},
			"collectLinkedAliases": collectLinkedAliases,
			"markLinkedReferences": func(nodeIn Node) {
				node := getParseTreeNode(nodeIn)
				return node && markLinkedReferences(node, ReferenceHintUnspecified)
			},
			"getReferencedValueDeclaration":     getReferencedValueDeclaration,
			"getReferencedValueDeclarations":    getReferencedValueDeclarations,
			"getTypeReferenceSerializationKind": getTypeReferenceSerializationKind,
			"isOptionalParameter":               isOptionalParameter,
			"isArgumentsLocalBinding":           isArgumentsLocalBinding,
			"getExternalModuleFileFromDeclaration": func(nodeIn /* TODO(TS-TO-GO) inferred type ExportDeclaration | ModuleDeclaration | ImportDeclaration | ImportEqualsDeclaration | ImportTypeNode | ImportCall */ any) *SourceFile {
				node := getParseTreeNode(nodeIn, hasPossibleExternalModuleReference)
				return node && getExternalModuleFileFromDeclaration(node)
			},
			"isLiteralConstDeclaration": isLiteralConstDeclaration,
			"isLateBound": func(nodeIn Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: nodeIn is LateBoundDeclaration */ any {
				node := getParseTreeNode(nodeIn, isDeclaration)
				symbol := node && getSymbolOfDeclaration(node)
				return !!(symbol && getCheckFlags(symbol)&CheckFlagsLate)
			},
			"getJsxFactoryEntity":         getJsxFactoryEntity,
			"getJsxFragmentFactoryEntity": getJsxFragmentFactoryEntity,
			"isBindingCapturedByNode": func(node Node, decl /* TODO(TS-TO-GO) inferred type VariableDeclaration | BindingElement */ any) bool {
				parseNode := getParseTreeNode(node)
				parseDecl := getParseTreeNode(decl)
				return !!parseNode && !!parseDecl && (isVariableDeclaration(parseDecl) || isBindingElement(parseDecl)) && isBindingCapturedByNode(parseNode, parseDecl)
			},
			"getDeclarationStatementsForSourceFile": func(node SourceFile, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *[]Statement {
				n := getParseTreeNode(node) /* as SourceFile */
				Debug.assert(n && n.kind == SyntaxKindSourceFile, "Non-sourcefile node passed into getDeclarationsForSourceFile")
				sym := getSymbolOfDeclaration(node)
				if !sym {
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case !node.locals:
						return []never{}
					default:
						return nodeBuilder.symbolTableToDeclarationStatements(node.locals, node, flags, internalFlags, tracker)
					}
				}
				resolveExternalModuleSymbol(sym)
				// ensures cjs export assignment is setup
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case !sym.exports:
					return []never{}
				default:
					return nodeBuilder.symbolTableToDeclarationStatements(sym.exports, node, flags, internalFlags, tracker)
				}
			},
			"isImportRequiredByAugmentation":            isImportRequiredByAugmentation,
			"isDefinitelyReferenceToGlobalSymbolObject": isDefinitelyReferenceToGlobalSymbolObject,
		}
		isImportRequiredByAugmentation := func(node ImportDeclaration) bool {
			file := getSourceFileOfNode(node)
			if !file.symbol {
				return false
			}
			importTarget := getExternalModuleFileFromDeclaration(node)
			if !importTarget {
				return false
			}
			if importTarget == file {
				return false
			}
			exports := getExportsOfModule(file.symbol)
			for _, s := range arrayFrom(exports.values()) {
				if s.mergeId {
					merged := getMergedSymbol(s)
					if merged.declarations {
						for _, d := range merged.declarations {
							declFile := getSourceFileOfNode(d)
							if declFile == importTarget {
								return true
							}
						}
					}
				}
			}
			return false
		}
	}
	getExternalModuleFileFromDeclaration := func(declaration /* TODO(TS-TO-GO) TypeNode UnionType: AnyImportOrReExport | ModuleDeclaration | ImportTypeNode | ImportCall */ any) *SourceFile {
		var specifier Expression
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case declaration.kind == SyntaxKindModuleDeclaration:
			specifier = tryCast(declaration.name, isStringLiteral)
		default:
			specifier = getExternalModuleName(declaration)
		}
		moduleSymbol := resolveExternalModuleNameWorker(specifier, specifier /*moduleNotFoundError*/, nil)
		// TODO: GH#18217
		if !moduleSymbol {
			return nil
		}
		return getDeclarationOfKind(moduleSymbol, SyntaxKindSourceFile)
	}
	initializeTypeChecker := func() {
		// Bind all source files and propagate errors
		for _, file := range host.getSourceFiles() {
			bindSourceFile(file, compilerOptions)
		}
		amalgamatedDuplicates = NewMap()
		// Initialize global symbol table
		var augmentations *[][] /* TODO(TS-TO-GO) TypeNode UnionType: StringLiteral | Identifier */ any
		for _, file := range host.getSourceFiles() {
			if file.redirectInfo {
				continue
			}
			if !isExternalOrCommonJsModule(file) {
				// It is an error for a non-external-module (i.e. script) to declare its own `globalThis`.
				fileGlobalThisSymbol := file.locals.get("globalThis" /* as __String */)
				if fileGlobalThisSymbol. /* TODO(TS-TO-GO): was ? */ declarations {
					for _, declaration := range fileGlobalThisSymbol.declarations {
						diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, "globalThis"))
					}
				}
				mergeSymbolTable(globals, file.locals)
			}
			if file.jsGlobalAugmentations {
				mergeSymbolTable(globals, file.jsGlobalAugmentations)
			}
			if file.patternAmbientModules && file.patternAmbientModules.length {
				patternAmbientModules = concatenate(patternAmbientModules, file.patternAmbientModules)
			}
			if file.moduleAugmentations.length {
				(augmentations || ( /* TODO(TS-TO-GO) Node BinaryExpression: augmentations = [] */ TODO)).push(file.moduleAugmentations)
			}
			if file.symbol && file.symbol.globalExports {
				// Merge in UMD exports with first-in-wins semantics (see #9771)
				source := file.symbol.globalExports
				source.forEach(func(sourceSymbol Symbol, id __String) {
					if !globals.has(id) {
						globals.set(id, sourceSymbol)
					}
				})
			}
		}
		// We do global augmentations separately from module augmentations (and before creating global types) because they
		//  1. Affect global types. We won't have the correct global types until global augmentations are merged. Also,
		//  2. Module augmentation instantiation requires creating the type of a module, which, in turn, can require
		//       checking for an export or property on the module (if export=) which, in turn, can fall back to the
		//       apparent type of the module - either globalObjectType or globalFunctionType - which wouldn't exist if we
		//       did module augmentations prior to finalizing the global types.
		if augmentations {
			// merge _global_ module augmentations.
			// this needs to be done after global symbol table is initialized to make sure that all ambient modules are indexed
			for _, list := range augmentations {
				for _, augmentation := range list {
					if !isGlobalScopeAugmentation(augmentation.parent /* as ModuleDeclaration */) {
						continue
					}
					mergeModuleAugmentation(augmentation)
				}
			}
		}
		addUndefinedToGlobalsOrErrorOnRedeclaration()
		getSymbolLinks(undefinedSymbol).type_ = undefinedWideningType
		getSymbolLinks(argumentsSymbol).type_ = getGlobalType("IArguments" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
		getSymbolLinks(unknownSymbol).type_ = errorType
		getSymbolLinks(globalThisSymbol).type_ = createObjectType(ObjectFlagsAnonymous, globalThisSymbol)
		// Initialize special types
		globalArrayType = getGlobalType("Array" /* as __String */ /*arity*/, 1 /*reportErrors*/, true)
		globalObjectType = getGlobalType("Object" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
		globalFunctionType = getGlobalType("Function" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
		globalCallableFunctionType = strictBindCallApply && getGlobalType("CallableFunction" /* as __String */ /*arity*/, 0 /*reportErrors*/, true) || globalFunctionType
		globalNewableFunctionType = strictBindCallApply && getGlobalType("NewableFunction" /* as __String */ /*arity*/, 0 /*reportErrors*/, true) || globalFunctionType
		globalStringType = getGlobalType("String" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
		globalNumberType = getGlobalType("Number" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
		globalBooleanType = getGlobalType("Boolean" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
		globalRegExpType = getGlobalType("RegExp" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
		anyArrayType = createArrayType(anyType)
		autoArrayType = createArrayType(autoType)
		if autoArrayType == emptyObjectType {
			// autoArrayType is used as a marker, so even if global Array type is not defined, it needs to be a unique type
			autoArrayType = createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
		}
		globalReadonlyArrayType = getGlobalTypeOrUndefined("ReadonlyArray" /* as __String */ /*arity*/, 1) /* as GenericType */ || globalArrayType
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case globalReadonlyArrayType:
			anyReadonlyArrayType = createTypeFromGenericGlobalType(globalReadonlyArrayType, []IntrinsicType{anyType})
		default:
			anyReadonlyArrayType = anyArrayType
		}
		globalThisType = getGlobalTypeOrUndefined("ThisType" /* as __String */ /*arity*/, 1) /* as GenericType */
		if augmentations {
			// merge _nonglobal_ module augmentations.
			// this needs to be done after global symbol table is initialized to make sure that all ambient modules are indexed
			for _, list := range augmentations {
				for _, augmentation := range list {
					if isGlobalScopeAugmentation(augmentation.parent /* as ModuleDeclaration */) {
						continue
					}
					mergeModuleAugmentation(augmentation)
				}
			}
		}
		amalgamatedDuplicates.forEach(func(TODO_IDENTIFIER DuplicateInfoForFiles) {
			// If not many things conflict, issue individual errors
			if conflictingSymbols.size < 8 {
				conflictingSymbols.forEach(func(TODO_IDENTIFIER DuplicateInfoForSymbol, symbolName string) {
					var message DiagnosticMessage
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case isBlockScoped:
						message = Diagnostics.Cannot_redeclare_block_scoped_variable_0
					default:
						message = Diagnostics.Duplicate_identifier_0
					}
					for _, node := range firstFileLocations {
						addDuplicateDeclarationError(node, message, symbolName, secondFileLocations)
					}
					for _, node := range secondFileLocations {
						addDuplicateDeclarationError(node, message, symbolName, firstFileLocations)
					}
				})
			} else {
				// Otherwise issue top-level error since the files appear very identical in terms of what they contain
				list := arrayFrom(conflictingSymbols.keys()).join(", ")
				diagnostics.add(addRelatedInfo(createDiagnosticForNode(firstFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), createDiagnosticForNode(secondFile, Diagnostics.Conflicts_are_in_this_file)))
				diagnostics.add(addRelatedInfo(createDiagnosticForNode(secondFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), createDiagnosticForNode(firstFile, Diagnostics.Conflicts_are_in_this_file)))
			}
		})
		amalgamatedDuplicates = nil
	}
	checkExternalEmitHelpers := func(location Node, helpers ExternalEmitHelpers) {
		if compilerOptions.importHelpers {
			sourceFile := getSourceFileOfNode(location)
			if isEffectiveExternalModule(sourceFile, compilerOptions) && !(location.flags & NodeFlagsAmbient) {
				helpersModule := resolveHelpersModule(sourceFile, location)
				if helpersModule != unknownSymbol {
					links := getSymbolLinks(helpersModule)
					/* TODO(TS-TO-GO) Node BinaryExpression: links.requestedExternalEmitHelpers ??= 0 as ExternalEmitHelpers */ TODO
					if (links.requestedExternalEmitHelpers & helpers) != helpers {
						uncheckedHelpers := helpers & ~links.requestedExternalEmitHelpers
						for helper := ExternalEmitHelpersFirstEmitHelper; helper <= ExternalEmitHelpersLastEmitHelper; helper <<= 1 {
							if uncheckedHelpers & helper {
								for _, name := range getHelperNames(helper) {
									symbol := resolveSymbol(getSymbol(getExportsOfModule(helpersModule), escapeLeadingUnderscores(name), SymbolFlagsValue))
									if !symbol {
										error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name)
									} else if helper & ExternalEmitHelpersClassPrivateFieldGet {
										if !some(getSignaturesOfSymbol(symbol), func(signature Signature) bool {
											return getParameterCount(signature) > 3
										}) {
											error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 4)
										}
									} else if helper & ExternalEmitHelpersClassPrivateFieldSet {
										if !some(getSignaturesOfSymbol(symbol), func(signature Signature) bool {
											return getParameterCount(signature) > 4
										}) {
											error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 5)
										}
									} else if helper & ExternalEmitHelpersSpreadArray {
										if !some(getSignaturesOfSymbol(symbol), func(signature Signature) bool {
											return getParameterCount(signature) > 2
										}) {
											error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 3)
										}
									}
								}
							}
						}
					}
					links.requestedExternalEmitHelpers |= helpers
				}
			}
		}
	}
	getHelperNames := func(helper ExternalEmitHelpers) []string {
		switch helper {
		case ExternalEmitHelpersExtends:
			return []string{"__extends"}
		case ExternalEmitHelpersAssign:
			return []string{"__assign"}
		case ExternalEmitHelpersRest:
			return []string{"__rest"}
		case ExternalEmitHelpersDecorate:
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case legacyDecorators:
				return []string{"__decorate"}
			default:
				return []string{"__esDecorate", "__runInitializers"}
			}
		case ExternalEmitHelpersMetadata:
			return []string{"__metadata"}
		case ExternalEmitHelpersParam:
			return []string{"__param"}
		case ExternalEmitHelpersAwaiter:
			return []string{"__awaiter"}
		case ExternalEmitHelpersGenerator:
			return []string{"__generator"}
		case ExternalEmitHelpersValues:
			return []string{"__values"}
		case ExternalEmitHelpersRead:
			return []string{"__read"}
		case ExternalEmitHelpersSpreadArray:
			return []string{"__spreadArray"}
		case ExternalEmitHelpersAwait:
			return []string{"__await"}
		case ExternalEmitHelpersAsyncGenerator:
			return []string{"__asyncGenerator"}
		case ExternalEmitHelpersAsyncDelegator:
			return []string{"__asyncDelegator"}
		case ExternalEmitHelpersAsyncValues:
			return []string{"__asyncValues"}
		case ExternalEmitHelpersExportStar:
			return []string{"__exportStar"}
		case ExternalEmitHelpersImportStar:
			return []string{"__importStar"}
		case ExternalEmitHelpersImportDefault:
			return []string{"__importDefault"}
		case ExternalEmitHelpersMakeTemplateObject:
			return []string{"__makeTemplateObject"}
		case ExternalEmitHelpersClassPrivateFieldGet:
			return []string{"__classPrivateFieldGet"}
		case ExternalEmitHelpersClassPrivateFieldSet:
			return []string{"__classPrivateFieldSet"}
		case ExternalEmitHelpersClassPrivateFieldIn:
			return []string{"__classPrivateFieldIn"}
		case ExternalEmitHelpersSetFunctionName:
			return []string{"__setFunctionName"}
		case ExternalEmitHelpersPropKey:
			return []string{"__propKey"}
		case ExternalEmitHelpersAddDisposableResourceAndDisposeResources:
			return []string{"__addDisposableResource", "__disposeResources"}
		default:
			return Debug.fail("Unrecognized helper")
		}
	}
	resolveHelpersModule := func(file SourceFile, errorNode Node) Symbol {
		links := getNodeLinks(file)
		if !links.externalHelpersModule {
			links.externalHelpersModule = resolveExternalModule(getImportHelpersImportSpecifier(file), externalHelpersModuleNameText, Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || unknownSymbol
		}
		return links.externalHelpersModule
	}
	// GRAMMAR CHECKING
	checkGrammarModifiers := func(node /* TODO(TS-TO-GO) TypeNode UnionType: HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) bool {
		quickResult := reportObviousDecoratorErrors(node) || reportObviousModifierErrors(node)
		if quickResult != nil {
			return quickResult
		}
		if isParameter(node) && parameterIsThisKeyword(node) {
			return grammarErrorOnFirstToken(node, Diagnostics.Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters)
		}
		var blockScopeKind number
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isVariableStatement(node):
			blockScopeKind = node.declarationList.flags & NodeFlagsBlockScoped
		default:
			blockScopeKind = NodeFlagsNone
		}
		var lastStatic Node
		var lastDeclare Node
		var lastAsync Node
		var lastOverride Node
		var firstDecorator *Decorator
		flags := ModifierFlagsNone
		sawExportBeforeDecorators := false
		// We parse decorators and modifiers in four contiguous chunks:
		// [...leadingDecorators, ...leadingModifiers, ...trailingDecorators, ...trailingModifiers]. It is an error to
		// have both leading and trailing decorators.
		hasLeadingDecorators := false
		for _, modifier := range (node /* as HasModifiers */).modifiers {
			if isDecorator(modifier) {
				if !nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent) {
					if node.kind == SyntaxKindMethodDeclaration && !nodeIsPresent(node.body) {
						return grammarErrorOnFirstToken(node, Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload)
					} else {
						return grammarErrorOnFirstToken(node, Diagnostics.Decorators_are_not_valid_here)
					}
				} else if legacyDecorators && (node.kind == SyntaxKindGetAccessor || node.kind == SyntaxKindSetAccessor) {
					accessors := getAllAccessorDeclarationsForDeclaration(node /* as AccessorDeclaration */)
					if hasDecorators(accessors.firstAccessor) && node == accessors.secondAccessor {
						return grammarErrorOnFirstToken(node, Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name)
					}
				}
				// if we've seen any modifiers aside from `export`, `default`, or another decorator, then this is an invalid position
				if flags & ~(ModifierFlagsExportDefault | ModifierFlagsDecorator) {
					return grammarErrorOnNode(modifier, Diagnostics.Decorators_are_not_valid_here)
				}
				// if we've already seen leading decorators and leading modifiers, then trailing decorators are an invalid position
				if hasLeadingDecorators && flags&ModifierFlagsModifier {
					Debug.assertIsDefined(firstDecorator)
					sourceFile := getSourceFileOfNode(modifier)
					if !hasParseDiagnostics(sourceFile) {
						addRelatedInfo(error(modifier, Diagnostics.Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export), createDiagnosticForNode(firstDecorator, Diagnostics.Decorator_used_before_export_here))
						return true
					}
					return false
				}
				flags |= ModifierFlagsDecorator
				// if we have not yet seen a modifier, then these are leading decorators
				if !(flags & ModifierFlagsModifier) {
					hasLeadingDecorators = true
				} else if flags & ModifierFlagsExport {
					sawExportBeforeDecorators = true
				}
				/* TODO(TS-TO-GO) Node BinaryExpression: firstDecorator ??= modifier */ TODO
			} else {
				if modifier.kind != SyntaxKindReadonlyKeyword {
					if node.kind == SyntaxKindPropertySignature || node.kind == SyntaxKindMethodSignature {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_member, tokenToString(modifier.kind))
					}
					if node.kind == SyntaxKindIndexSignature && (modifier.kind != SyntaxKindStaticKeyword || !isClassLike(node.parent)) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_index_signature, tokenToString(modifier.kind))
					}
				}
				if modifier.kind != SyntaxKindInKeyword && modifier.kind != SyntaxKindOutKeyword && modifier.kind != SyntaxKindConstKeyword {
					if node.kind == SyntaxKindTypeParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_parameter, tokenToString(modifier.kind))
					}
				}
				switch modifier.kind {
				case SyntaxKindConstKeyword:
					if node.kind != SyntaxKindEnumDeclaration && node.kind != SyntaxKindTypeParameter {
						return grammarErrorOnNode(node, Diagnostics.A_class_member_cannot_have_the_0_keyword, tokenToString(SyntaxKindConstKeyword))
					}
					parent := (isJSDocTemplateTag(node.parent) && getEffectiveJSDocHost(node.parent)) || node.parent
					if node.kind == SyntaxKindTypeParameter && !(isFunctionLikeDeclaration(parent) || isClassLike(parent) || isFunctionTypeNode(parent) || isConstructorTypeNode(parent) || isCallSignatureDeclaration(parent) || isConstructSignatureDeclaration(parent) || isMethodSignature(parent)) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class, tokenToString(modifier.kind))
					}
					break
					fallthrough
				case SyntaxKindOverrideKeyword:
					if flags & ModifierFlagsOverride {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "override")
					} else if flags & ModifierFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "override", "declare")
					} else if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "readonly")
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "accessor")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "async")
					}
					flags |= ModifierFlagsOverride
					lastOverride = modifier
					break
				case SyntaxKindPublicKeyword:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindProtectedKeyword:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindPrivateKeyword:
					text := visibilityToString(modifierToFlag(modifier.kind))
					if flags & ModifierFlagsAccessibilityModifier {
						return grammarErrorOnNode(modifier, Diagnostics.Accessibility_modifier_already_seen)
					} else if flags & ModifierFlagsOverride {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "override")
					} else if flags & ModifierFlagsStatic {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "static")
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "accessor")
					} else if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "async")
					} else if node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, text)
					} else if flags & ModifierFlagsAbstract {
						if modifier.kind == SyntaxKindPrivateKeyword {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, text, "abstract")
						} else {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "abstract")
						}
					} else if isPrivateIdentifierClassElementDeclaration(node) {
						return grammarErrorOnNode(modifier, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier)
					}
					flags |= modifierToFlag(modifier.kind)
					break
				case SyntaxKindStaticKeyword:
					if flags & ModifierFlagsStatic {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "static")
					} else if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "readonly")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "async")
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "accessor")
					} else if node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, "static")
					} else if node.kind == SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static")
					} else if flags & ModifierFlagsAbstract {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract")
					} else if flags & ModifierFlagsOverride {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "override")
					}
					flags |= ModifierFlagsStatic
					lastStatic = modifier
					break
				case SyntaxKindAccessorKeyword:
					if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "accessor")
					} else if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "readonly")
					} else if flags & ModifierFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "declare")
					} else if node.kind != SyntaxKindPropertyDeclaration {
						return grammarErrorOnNode(modifier, Diagnostics.accessor_modifier_can_only_appear_on_a_property_declaration)
					}
					flags |= ModifierFlagsAccessor
					break
				case SyntaxKindReadonlyKeyword:
					if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "readonly")
					} else if node.kind != SyntaxKindPropertyDeclaration && node.kind != SyntaxKindPropertySignature && node.kind != SyntaxKindIndexSignature && node.kind != SyntaxKindParameter {
						// If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.
						return grammarErrorOnNode(modifier, Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature)
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "readonly", "accessor")
					}
					flags |= ModifierFlagsReadonly
					break
				case SyntaxKindExportKeyword:
					if compilerOptions.verbatimModuleSyntax && !(node.flags & NodeFlagsAmbient) && node.kind != SyntaxKindTypeAliasDeclaration && node.kind != SyntaxKindInterfaceDeclaration && node.kind != SyntaxKindModuleDeclaration && node.parent.kind == SyntaxKindSourceFile && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
						return grammarErrorOnNode(modifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
					}
					if flags & ModifierFlagsExport {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "export")
					} else if flags & ModifierFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare")
					} else if flags & ModifierFlagsAbstract {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "abstract")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "async")
					} else if isClassLike(node.parent) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "export")
					} else if node.kind == SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export")
					} else if blockScopeKind == NodeFlagsUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "export")
					} else if blockScopeKind == NodeFlagsAwaitUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "export")
					}
					flags |= ModifierFlagsExport
					break
				case SyntaxKindDefaultKeyword:
					var container Node
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case node.parent.kind == SyntaxKindSourceFile:
						container = node.parent
					default:
						container = node.parent.parent
					}
					if container.kind == SyntaxKindModuleDeclaration && !isAmbientModule(container) {
						return grammarErrorOnNode(modifier, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module)
					} else if blockScopeKind == NodeFlagsUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "default")
					} else if blockScopeKind == NodeFlagsAwaitUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "default")
					} else if !(flags & ModifierFlagsExport) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "default")
					} else if sawExportBeforeDecorators {
						return grammarErrorOnNode(firstDecorator, Diagnostics.Decorators_are_not_valid_here)
					}
					flags |= ModifierFlagsDefault
					break
				case SyntaxKindDeclareKeyword:
					if flags & ModifierFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "declare")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async")
					} else if flags & ModifierFlagsOverride {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "override")
					} else if isClassLike(node.parent) && !isPropertyDeclaration(node) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "declare")
					} else if node.kind == SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare")
					} else if blockScopeKind == NodeFlagsUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "declare")
					} else if blockScopeKind == NodeFlagsAwaitUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "declare")
					} else if (node.parent.flags & NodeFlagsAmbient) && node.parent.kind == SyntaxKindModuleBlock {
						return grammarErrorOnNode(modifier, Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context)
					} else if isPrivateIdentifierClassElementDeclaration(node) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "declare")
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "declare", "accessor")
					}
					flags |= ModifierFlagsAmbient
					lastDeclare = modifier
					break
				case SyntaxKindAbstractKeyword:
					if flags & ModifierFlagsAbstract {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "abstract")
					}
					if node.kind != SyntaxKindClassDeclaration && node.kind != SyntaxKindConstructorType {
						if node.kind != SyntaxKindMethodDeclaration && node.kind != SyntaxKindPropertyDeclaration && node.kind != SyntaxKindGetAccessor && node.kind != SyntaxKindSetAccessor {
							return grammarErrorOnNode(modifier, Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration)
						}
						if !(node.parent.kind == SyntaxKindClassDeclaration && hasSyntacticModifier(node.parent, ModifierFlagsAbstract)) {
							var message DiagnosticMessage
							// TODO(TS-TO-GO): converted from conditional expression
							switch {
							case node.kind == SyntaxKindPropertyDeclaration:
								message = Diagnostics.Abstract_properties_can_only_appear_within_an_abstract_class
							default:
								message = Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class
							}
							return grammarErrorOnNode(modifier, message)
						}
						if flags & ModifierFlagsStatic {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract")
						}
						if flags & ModifierFlagsPrivate {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "private", "abstract")
						}
						if flags&ModifierFlagsAsync && lastAsync {
							return grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract")
						}
						if flags & ModifierFlagsOverride {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "override")
						}
						if flags & ModifierFlagsAccessor {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "accessor")
						}
					}
					if isNamedDeclaration(node) && node.name.kind == SyntaxKindPrivateIdentifier {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "abstract")
					}
					flags |= ModifierFlagsAbstract
					break
				case SyntaxKindAsyncKeyword:
					if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "async")
					} else if flags&ModifierFlagsAmbient || node.parent.flags&NodeFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async")
					} else if node.kind == SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async")
					}
					if flags & ModifierFlagsAbstract {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract")
					}
					flags |= ModifierFlagsAsync
					lastAsync = modifier
					break
				case SyntaxKindInKeyword:
					fallthrough // TODO(TS-TO-GO): merge cases
				case SyntaxKindOutKeyword:
					var inOutFlag /* TODO(TS-TO-GO) inferred type ModifierFlags.In | ModifierFlags.Out */ any
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case modifier.kind == SyntaxKindInKeyword:
						inOutFlag = ModifierFlagsIn
					default:
						inOutFlag = ModifierFlagsOut
					}
					var inOutText /* TODO(TS-TO-GO) inferred type "in" | "out" */ any
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case modifier.kind == SyntaxKindInKeyword:
						inOutText = "in"
					default:
						inOutText = "out"
					}
					parent := isJSDocTemplateTag(node.parent) && (getEffectiveJSDocHost(node.parent) || find(getJSDocRoot(node.parent). /* TODO(TS-TO-GO): was ? */ tags, isJSDocTypedefTag)) || node.parent
					if node.kind != SyntaxKindTypeParameter || parent && !(isInterfaceDeclaration(parent) || isClassLike(parent) || isTypeAliasDeclaration(parent) || isJSDocTypedefTag(parent)) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias, inOutText)
					}
					if flags & inOutFlag {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, inOutText)
					}
					if inOutFlag&ModifierFlagsIn && flags&ModifierFlagsOut {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "in", "out")
					}
					flags |= inOutFlag
					break
				}
			}
		}
		if node.kind == SyntaxKindConstructor {
			if flags & ModifierFlagsStatic {
				return grammarErrorOnNode(lastStatic, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static")
			}
			if flags & ModifierFlagsOverride {
				return grammarErrorOnNode(lastOverride, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "override")
				// TODO: GH#18217
			}
			if flags & ModifierFlagsAsync {
				return grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "async")
			}
			return false
		} else if (node.kind == SyntaxKindImportDeclaration || node.kind == SyntaxKindImportEqualsDeclaration) && flags&ModifierFlagsAmbient {
			return grammarErrorOnNode(lastDeclare, Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration, "declare")
		} else if node.kind == SyntaxKindParameter && (flags & ModifierFlagsParameterPropertyModifier) && isBindingPattern(node.name) {
			return grammarErrorOnNode(node, Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern)
		} else if node.kind == SyntaxKindParameter && (flags & ModifierFlagsParameterPropertyModifier) && node.dotDotDotToken {
			return grammarErrorOnNode(node, Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter)
		}
		if flags & ModifierFlagsAsync {
			return checkGrammarAsyncModifier(node, lastAsync)
		}
		return false
	}
	/**
	 * true | false: Early return this value from checkGrammarModifiers.
	 * undefined: Need to do full checking on the modifiers.
	 */
	reportObviousModifierErrors := func(node /* TODO(TS-TO-GO) TypeNode UnionType: HasModifiers | HasIllegalModifiers */ any) *bool {
		if !node.modifiers {
			return false
		}
		modifier := findFirstIllegalModifier(node)
		return modifier && grammarErrorOnFirstToken(modifier, Diagnostics.Modifiers_cannot_appear_here)
	}
	findFirstModifierExcept := func(node HasModifiers, allowedModifier SyntaxKind) *Modifier {
		modifier := find(node.modifiers, isModifier)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case modifier && modifier.kind != allowedModifier:
			return modifier
		default:
			return nil
		}
	}
	findFirstIllegalModifier := func(node /* TODO(TS-TO-GO) TypeNode UnionType: HasModifiers | HasIllegalModifiers */ any) *Modifier {
		switch node.kind {
		case SyntaxKindGetAccessor:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindSetAccessor:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindConstructor:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertyDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertySignature:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMethodSignature:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindIndexSignature:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindModuleDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindImportDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindImportEqualsDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindExportDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindExportAssignment:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindParameter:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindTypeParameter:
			return nil
		case SyntaxKindClassStaticBlockDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindPropertyAssignment:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindShorthandPropertyAssignment:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindNamespaceExportDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindMissingDeclaration:
			return find(node.modifiers, isModifier)
		default:
			if node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
				return nil
			}
			switch node.kind {
			case SyntaxKindFunctionDeclaration:
				return findFirstModifierExcept(node, SyntaxKindAsyncKeyword)
			case SyntaxKindClassDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindConstructorType:
				return findFirstModifierExcept(node, SyntaxKindAbstractKeyword)
			case SyntaxKindClassExpression:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindTypeAliasDeclaration:
				return find(node.modifiers, isModifier)
			case SyntaxKindVariableStatement:
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case node.declarationList.flags & NodeFlagsUsing:
					return findFirstModifierExcept(node, SyntaxKindAwaitKeyword)
				default:
					return find(node.modifiers, isModifier)
				}
			case SyntaxKindEnumDeclaration:
				return findFirstModifierExcept(node, SyntaxKindConstKeyword)
			default:
				Debug.assertNever(node)
			}
		}
	}
	reportObviousDecoratorErrors := func(node /* TODO(TS-TO-GO) TypeNode UnionType: HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) *bool {
		decorator := findFirstIllegalDecorator(node)
		return decorator && grammarErrorOnFirstToken(decorator, Diagnostics.Decorators_are_not_valid_here)
	}
	findFirstIllegalDecorator := func(node /* TODO(TS-TO-GO) TypeNode UnionType: HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) *Decorator {
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case canHaveIllegalDecorators(node):
			return find(node.modifiers, isDecorator)
		default:
			return nil
		}
	}
	checkGrammarAsyncModifier := func(node Node, asyncModifier Node) bool {
		switch node.kind {
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindArrowFunction:
			return false
		}
		return grammarErrorOnNode(asyncModifier, Diagnostics._0_modifier_cannot_be_used_here, "async")
	}
	checkGrammarForDisallowedTrailingComma := func(list *NodeArray[Node], diag DiagnosticMessage /*  = Diagnostics.Trailing_comma_not_allowed */) bool {
		if list && list.hasTrailingComma {
			return grammarErrorAtPos(list[0], list.end-len(","), len(","), diag)
		}
		return false
	}
	checkGrammarTypeParameterList := func(typeParameters *NodeArray[TypeParameterDeclaration], file SourceFile) bool {
		if typeParameters && typeParameters.length == 0 {
			start := typeParameters.pos - len("<")
			end := skipTrivia(file.text, typeParameters.end) + len(">")
			return grammarErrorAtPos(file, start, end-start, Diagnostics.Type_parameter_list_cannot_be_empty)
		}
		return false
	}
	checkGrammarParameterList := func(parameters NodeArray[ParameterDeclaration]) *bool {
		seenOptionalParameter := false
		parameterCount := parameters.length
		for i := 0; i < parameterCount; i++ {
			parameter := parameters[i]
			if parameter.dotDotDotToken {
				if i != (parameterCount - 1) {
					return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list)
				}
				if !(parameter.flags & NodeFlagsAmbient) {
					checkGrammarForDisallowedTrailingComma(parameters, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
				}
				if parameter.questionToken {
					return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_rest_parameter_cannot_be_optional)
				}
				if parameter.initializer {
					return grammarErrorOnNode(parameter.name, Diagnostics.A_rest_parameter_cannot_have_an_initializer)
				}
			} else if hasEffectiveQuestionToken(parameter) {
				seenOptionalParameter = true
				if parameter.questionToken && parameter.initializer {
					return grammarErrorOnNode(parameter.name, Diagnostics.Parameter_cannot_have_question_mark_and_initializer)
				}
			} else if seenOptionalParameter && !parameter.initializer {
				return grammarErrorOnNode(parameter.name, Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter)
			}
		}
	}
	getNonSimpleParameters := func(parameters []ParameterDeclaration) []ParameterDeclaration {
		return filter(parameters, func(parameter ParameterDeclaration) bool {
			return !!parameter.initializer || isBindingPattern(parameter.name) || isRestParameter(parameter)
		})
	}
	checkGrammarForUseStrictSimpleParameterList := func(node FunctionLikeDeclaration) bool {
		if languageVersion >= ScriptTargetES2016 {
			useStrictDirective := node.body && isBlock(node.body) && findUseStrictPrologue(node.body.statements)
			if useStrictDirective {
				nonSimpleParameters := getNonSimpleParameters(node.parameters)
				if length(nonSimpleParameters) {
					forEach(nonSimpleParameters, func(parameter ParameterDeclaration) {
						addRelatedInfo(error(parameter, Diagnostics.This_parameter_is_not_allowed_with_use_strict_directive), createDiagnosticForNode(useStrictDirective, Diagnostics.use_strict_directive_used_here))
					})
					diagnostics := nonSimpleParameters.map_(func(parameter ParameterDeclaration, index number) DiagnosticWithLocation {
						return (__COND__(index == 0, createDiagnosticForNode(parameter, Diagnostics.Non_simple_parameter_declared_here), createDiagnosticForNode(parameter, Diagnostics.and_here)))
					}) /* as [DiagnosticWithLocation, ...DiagnosticWithLocation[]] */
					addRelatedInfo(error(useStrictDirective, Diagnostics.use_strict_directive_cannot_be_used_with_non_simple_parameter_list), diagnostics...)
					return true
				}
			}
		}
		return false
	}
	checkGrammarFunctionLikeDeclaration := func(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionLikeDeclaration | MethodSignature */ any) bool {
		// Prevent cascading error by short-circuit
		file := getSourceFileOfNode(node)
		return checkGrammarModifiers(node) || checkGrammarTypeParameterList(node.typeParameters, file) || checkGrammarParameterList(node.parameters) || checkGrammarArrowFunction(node, file) || (isFunctionLikeDeclaration(node) && checkGrammarForUseStrictSimpleParameterList(node))
	}
	checkGrammarClassLikeDeclaration := func(node ClassLikeDeclaration) bool {
		file := getSourceFileOfNode(node)
		return checkGrammarClassDeclarationHeritageClauses(node) || checkGrammarTypeParameterList(node.typeParameters, file)
	}
	checkGrammarArrowFunction := func(node Node, file SourceFile) bool {
		if !isArrowFunction(node) {
			return false
		}
		if node.typeParameters && !(length(node.typeParameters) > 1 || node.typeParameters.hasTrailingComma || node.typeParameters[0].constraint) {
			if file && fileExtensionIsOneOf(file.fileName, []Extension{ExtensionMts, ExtensionCts}) {
				grammarErrorOnNode(node.typeParameters[0], Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint)
			}
		}
		TODO_IDENTIFIER := node
		startLine := getLineAndCharacterOfPosition(file, equalsGreaterThanToken.pos).line
		endLine := getLineAndCharacterOfPosition(file, equalsGreaterThanToken.end).line
		return startLine != endLine && grammarErrorOnNode(equalsGreaterThanToken, Diagnostics.Line_terminator_not_permitted_before_arrow)
	}
	checkGrammarIndexSignatureParameters := func(node SignatureDeclaration) bool {
		parameter := node.parameters[0]
		if node.parameters.length != 1 {
			if parameter {
				return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_must_have_exactly_one_parameter)
			} else {
				return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_exactly_one_parameter)
			}
		}
		checkGrammarForDisallowedTrailingComma(node.parameters, Diagnostics.An_index_signature_cannot_have_a_trailing_comma)
		if parameter.dotDotDotToken {
			return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.An_index_signature_cannot_have_a_rest_parameter)
		}
		if hasEffectiveModifiers(parameter) {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier)
		}
		if parameter.questionToken {
			return grammarErrorOnNode(parameter.questionToken, Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark)
		}
		if parameter.initializer {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_initializer)
		}
		if !parameter.type_ {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_must_have_a_type_annotation)
		}
		type_ := getTypeFromTypeNode(parameter.type_)
		if someType(type_, func(t Type) bool {
			return !!(t.flags & TypeFlagsStringOrNumberLiteralOrUnique)
		}) || isGenericType(type_) {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead)
		}
		if !everyType(type_, isValidIndexKeyType) {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type)
		}
		if !node.type_ {
			return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_a_type_annotation)
		}
		return false
	}
	checkGrammarIndexSignature := func(node IndexSignatureDeclaration) bool {
		// Prevent cascading error by short-circuit
		return checkGrammarModifiers(node) || checkGrammarIndexSignatureParameters(node)
	}
	checkGrammarForAtLeastOneTypeArgument := func(node Node, typeArguments *NodeArray[TypeNode]) bool {
		if typeArguments && typeArguments.length == 0 {
			sourceFile := getSourceFileOfNode(node)
			start := typeArguments.pos - len("<")
			end := skipTrivia(sourceFile.text, typeArguments.end) + len(">")
			return grammarErrorAtPos(sourceFile, start, end-start, Diagnostics.Type_argument_list_cannot_be_empty)
		}
		return false
	}
	checkGrammarTypeArguments := func(node Node, typeArguments *NodeArray[TypeNode]) bool {
		return checkGrammarForDisallowedTrailingComma(typeArguments) || checkGrammarForAtLeastOneTypeArgument(node, typeArguments)
	}
	checkGrammarTaggedTemplateChain := func(node TaggedTemplateExpression) bool {
		if node.questionDotToken || node.flags&NodeFlagsOptionalChain {
			return grammarErrorOnNode(node.template, Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain)
		}
		return false
	}
	checkGrammarHeritageClause := func(node HeritageClause) bool {
		types := node.types
		if checkGrammarForDisallowedTrailingComma(types) {
			return true
		}
		if types && types.length == 0 {
			listType := tokenToString(node.token)
			return grammarErrorAtPos(node, types.pos, 0, Diagnostics._0_list_cannot_be_empty, listType)
		}
		return some(types, checkGrammarExpressionWithTypeArguments)
	}
	checkGrammarExpressionWithTypeArguments := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ExpressionWithTypeArguments | TypeQueryNode */ any) bool {
		if isExpressionWithTypeArguments(node) && isImportKeyword(node.expression) && node.typeArguments {
			return grammarErrorOnNode(node, Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments)
		}
		return checkGrammarTypeArguments(node, node.typeArguments)
	}
	checkGrammarClassDeclarationHeritageClauses := func(node ClassLikeDeclaration) *bool {
		seenExtendsClause := false
		seenImplementsClause := false
		if !checkGrammarModifiers(node) && node.heritageClauses {
			for _, heritageClause := range node.heritageClauses {
				if heritageClause.token == SyntaxKindExtendsKeyword {
					if seenExtendsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen)
					}
					if seenImplementsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_must_precede_implements_clause)
					}
					if heritageClause.types.length > 1 {
						return grammarErrorOnFirstToken(heritageClause.types[1], Diagnostics.Classes_can_only_extend_a_single_class)
					}
					seenExtendsClause = true
				} else {
					Debug.assert(heritageClause.token == SyntaxKindImplementsKeyword)
					if seenImplementsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.implements_clause_already_seen)
					}
					seenImplementsClause = true
				}
				// Grammar checking heritageClause inside class declaration
				checkGrammarHeritageClause(heritageClause)
			}
		}
	}
	checkGrammarInterfaceDeclaration := func(node InterfaceDeclaration) bool {
		seenExtendsClause := false
		if node.heritageClauses {
			for _, heritageClause := range node.heritageClauses {
				if heritageClause.token == SyntaxKindExtendsKeyword {
					if seenExtendsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen)
					}
					seenExtendsClause = true
				} else {
					Debug.assert(heritageClause.token == SyntaxKindImplementsKeyword)
					return grammarErrorOnFirstToken(heritageClause, Diagnostics.Interface_declaration_cannot_have_implements_clause)
				}
				// Grammar checking heritageClause inside class declaration
				checkGrammarHeritageClause(heritageClause)
			}
		}
		return false
	}
	checkGrammarComputedPropertyName := func(node Node) bool {
		// If node is not a computedPropertyName, just skip the grammar checking
		if node.kind != SyntaxKindComputedPropertyName {
			return false
		}
		computedPropertyName := node /* as ComputedPropertyName */
		if computedPropertyName.expression.kind == SyntaxKindBinaryExpression && (computedPropertyName.expression /* as BinaryExpression */).operatorToken.kind == SyntaxKindCommaToken {
			return grammarErrorOnNode(computedPropertyName.expression, Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name)
		}
		return false
	}
	checkGrammarForGenerator := func(node FunctionLikeDeclaration) *bool {
		if node.asteriskToken {
			Debug.assert(node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindFunctionExpression || node.kind == SyntaxKindMethodDeclaration)
			if node.flags & NodeFlagsAmbient {
				return grammarErrorOnNode(node.asteriskToken, Diagnostics.Generators_are_not_allowed_in_an_ambient_context)
			}
			if !node.body {
				return grammarErrorOnNode(node.asteriskToken, Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator)
			}
		}
	}
	checkGrammarForInvalidQuestionMark := func(questionToken *QuestionToken, message DiagnosticMessage) bool {
		return !!questionToken && grammarErrorOnNode(questionToken, message)
	}
	checkGrammarForInvalidExclamationToken := func(exclamationToken *ExclamationToken, message DiagnosticMessage) bool {
		return !!exclamationToken && grammarErrorOnNode(exclamationToken, message)
	}
	checkGrammarObjectLiteralExpression := func(node ObjectLiteralExpression, inDestructuring bool) *bool {
		seen := NewMap[__String, DeclarationMeaning]()
		for _, prop := range node.properties {
			if prop.kind == SyntaxKindSpreadAssignment {
				if inDestructuring {
					// a rest property cannot be destructured any further
					expression := skipParentheses(prop.expression)
					if isArrayLiteralExpression(expression) || isObjectLiteralExpression(expression) {
						return grammarErrorOnNode(prop.expression, Diagnostics.A_rest_element_cannot_contain_a_binding_pattern)
					}
				}
				continue
			}
			name := prop.name
			if name.kind == SyntaxKindComputedPropertyName {
				// If the name is not a ComputedPropertyName, the grammar checking will skip it
				checkGrammarComputedPropertyName(name)
			}
			if prop.kind == SyntaxKindShorthandPropertyAssignment && !inDestructuring && prop.objectAssignmentInitializer {
				// having objectAssignmentInitializer is only valid in ObjectAssignmentPattern
				// outside of destructuring it is a syntax error
				grammarErrorOnNode(prop.equalsToken, Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern)
			}
			if name.kind == SyntaxKindPrivateIdentifier {
				grammarErrorOnNode(name, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
			}
			// Modifiers are never allowed on properties except for 'async' on a method declaration
			if canHaveModifiers(prop) && prop.modifiers {
				for _, mod := range prop.modifiers {
					if isModifier(mod) && (mod.kind != SyntaxKindAsyncKeyword || prop.kind != SyntaxKindMethodDeclaration) {
						grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod))
					}
				}
			} else if canHaveIllegalModifiers(prop) && prop.modifiers {
				for _, mod := range prop.modifiers {
					if isModifier(mod) {
						grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod))
					}
				}
			}
			// ECMA-262 11.1.5 Object Initializer
			// If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true
			// a.This production is contained in strict code and IsDataDescriptor(previous) is true and
			// IsDataDescriptor(propId.descriptor) is true.
			//    b.IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true.
			//    c.IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true.
			//    d.IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true
			// and either both previous and propId.descriptor have[[Get]] fields or both previous and propId.descriptor have[[Set]] fields
			var currentKind DeclarationMeaning
			switch prop.kind {
			case SyntaxKindShorthandPropertyAssignment:
				fallthrough // TODO(TS-TO-GO): merge cases
			case SyntaxKindPropertyAssignment:
				checkGrammarForInvalidExclamationToken(prop.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context)
				checkGrammarForInvalidQuestionMark(prop.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional)
				if name.kind == SyntaxKindNumericLiteral {
					checkGrammarNumericLiteral(name)
				}
				if name.kind == SyntaxKindBigIntLiteral {
					addErrorOrSuggestion(true, createDiagnosticForNode(name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name))
				}
				currentKind = DeclarationMeaningPropertyAssignment
				break
			case SyntaxKindMethodDeclaration:
				currentKind = DeclarationMeaningMethod
				break
			case SyntaxKindGetAccessor:
				currentKind = DeclarationMeaningGetAccessor
				break
			case SyntaxKindSetAccessor:
				currentKind = DeclarationMeaningSetAccessor
				break
			default:
				Debug.assertNever(prop, "Unexpected syntax kind:"+(prop /* as Node */).kind)
			}
			if !inDestructuring {
				effectiveName := getEffectivePropertyNameForPropertyNameNode(name)
				if effectiveName == nil {
					continue
				}
				existingKind := seen.get(effectiveName)
				if !existingKind {
					seen.set(effectiveName, currentKind)
				} else {
					if (currentKind & DeclarationMeaningMethod) && (existingKind & DeclarationMeaningMethod) {
						grammarErrorOnNode(name, Diagnostics.Duplicate_identifier_0, getTextOfNode(name))
					} else if (currentKind & DeclarationMeaningPropertyAssignment) && (existingKind & DeclarationMeaningPropertyAssignment) {
						grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name, getTextOfNode(name))
					} else if (currentKind & DeclarationMeaningGetOrSetAccessor) && (existingKind & DeclarationMeaningGetOrSetAccessor) {
						if existingKind != DeclarationMeaningGetOrSetAccessor && currentKind != existingKind {
							seen.set(effectiveName, currentKind|existingKind)
						} else {
							return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name)
						}
					} else {
						return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name)
					}
				}
			}
		}
	}
	checkGrammarJsxElement := func(node JsxOpeningLikeElement) *bool {
		checkGrammarJsxName(node.tagName)
		checkGrammarTypeArguments(node, node.typeArguments)
		seen := NewMap[__String, bool]()
		for _, attr := range node.attributes.properties {
			if attr.kind == SyntaxKindJsxSpreadAttribute {
				continue
			}
			TODO_IDENTIFIER := attr
			escapedText := getEscapedTextOfJsxAttributeName(name)
			if !seen.get(escapedText) {
				seen.set(escapedText, true)
			} else {
				return grammarErrorOnNode(name, Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name)
			}
			if initializer && initializer.kind == SyntaxKindJsxExpression && !initializer.expression {
				return grammarErrorOnNode(initializer, Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression)
			}
		}
	}
	checkGrammarJsxName := func(node JsxTagNameExpression) *bool {
		if isPropertyAccessExpression(node) && isJsxNamespacedName(node.expression) {
			return grammarErrorOnNode(node.expression, Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names)
		}
		if isJsxNamespacedName(node) && getJSXTransformEnabled(compilerOptions) && !isIntrinsicJsxName(node.namespace.escapedText) {
			return grammarErrorOnNode(node, Diagnostics.React_components_cannot_include_JSX_namespace_names)
		}
	}
	checkGrammarJsxExpression := func(node JsxExpression) *bool {
		if node.expression && isCommaSequence(node.expression) {
			return grammarErrorOnNode(node.expression, Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array)
		}
	}
	checkGrammarForInOrForOfStatement := func(forInOrOfStatement ForInOrOfStatement) bool {
		if checkGrammarStatementInAmbientContext(forInOrOfStatement) {
			return true
		}
		if forInOrOfStatement.kind == SyntaxKindForOfStatement && forInOrOfStatement.awaitModifier {
			if !(forInOrOfStatement.flags & NodeFlagsAwaitContext) {
				sourceFile := getSourceFileOfNode(forInOrOfStatement)
				if isInTopLevelContext(forInOrOfStatement) {
					if !hasParseDiagnostics(sourceFile) {
						if !isEffectiveExternalModule(sourceFile, compilerOptions) {
							diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module))
						}
						switch moduleKind {
						case ModuleKindNode16:
							fallthrough // TODO(TS-TO-GO): merge cases
						case ModuleKindNodeNext:
							if sourceFile.impliedNodeFormat == ModuleKindCommonJS {
								diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level))
								break
							}
							fallthrough
						case ModuleKindES2022:
							fallthrough // TODO(TS-TO-GO): merge cases
						case ModuleKindESNext:
							fallthrough // TODO(TS-TO-GO): merge cases
						case ModuleKindPreserve:
							fallthrough // TODO(TS-TO-GO): merge cases
						case ModuleKindSystem:
							if languageVersion >= ScriptTargetES2017 {
								break
							}
							fallthrough
						default:
							diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher))
							break
						}
					}
				} else {
					// use of 'for-await-of' in non-async function
					if !hasParseDiagnostics(sourceFile) {
						diagnostic := createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules)
						func_ := getContainingFunction(forInOrOfStatement)
						if func_ && func_.kind != SyntaxKindConstructor {
							Debug.assert((getFunctionFlags(func_)&FunctionFlagsAsync) == 0, "Enclosing function should never be an async function.")
							relatedInfo := createDiagnosticForNode(func_, Diagnostics.Did_you_mean_to_mark_this_function_as_async)
							addRelatedInfo(diagnostic, relatedInfo)
						}
						diagnostics.add(diagnostic)
						return true
					}
				}
			}
		}
		if isForOfStatement(forInOrOfStatement) && !(forInOrOfStatement.flags & NodeFlagsAwaitContext) && isIdentifier(forInOrOfStatement.initializer) && forInOrOfStatement.initializer.escapedText == "async" {
			grammarErrorOnNode(forInOrOfStatement.initializer, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async)
			return false
		}
		if forInOrOfStatement.initializer.kind == SyntaxKindVariableDeclarationList {
			variableList := forInOrOfStatement.initializer /* as VariableDeclarationList */
			if !checkGrammarVariableDeclarationList(variableList) {
				declarations := variableList.declarations
				// declarations.length can be zero if there is an error in variable declaration in for-of or for-in
				// See http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements for details
				// For example:
				//      var let = 10;
				//      for (let of [1,2,3]) {} // this is invalid ES6 syntax
				//      for (let in [1,2,3]) {} // this is invalid ES6 syntax
				// We will then want to skip on grammar checking on variableList declaration
				if !declarations.length {
					return false
				}
				if declarations.length > 1 {
					var diagnostic DiagnosticMessage
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case forInOrOfStatement.kind == SyntaxKindForInStatement:
						diagnostic = Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement
					default:
						diagnostic = Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement
					}
					return grammarErrorOnFirstToken(variableList.declarations[1], diagnostic)
				}
				firstDeclaration := declarations[0]
				if firstDeclaration.initializer {
					var diagnostic DiagnosticMessage
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case forInOrOfStatement.kind == SyntaxKindForInStatement:
						diagnostic = Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer
					default:
						diagnostic = Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer
					}
					return grammarErrorOnNode(firstDeclaration.name, diagnostic)
				}
				if firstDeclaration.type_ {
					var diagnostic DiagnosticMessage
					// TODO(TS-TO-GO): converted from conditional expression
					switch {
					case forInOrOfStatement.kind == SyntaxKindForInStatement:
						diagnostic = Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation
					default:
						diagnostic = Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation
					}
					return grammarErrorOnNode(firstDeclaration, diagnostic)
				}
			}
		}
		return false
	}
	checkGrammarAccessor := func(accessor AccessorDeclaration) bool {
		if !(accessor.flags & NodeFlagsAmbient) && (accessor.parent.kind != SyntaxKindTypeLiteral) && (accessor.parent.kind != SyntaxKindInterfaceDeclaration) {
			if languageVersion < ScriptTargetES2015 && isPrivateIdentifier(accessor.name) {
				return grammarErrorOnNode(accessor.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if accessor.body == nil && !hasSyntacticModifier(accessor, ModifierFlagsAbstract) {
				return grammarErrorAtPos(accessor, accessor.end-1, len(";"), Diagnostics._0_expected, "{")
			}
		}
		if accessor.body {
			if hasSyntacticModifier(accessor, ModifierFlagsAbstract) {
				return grammarErrorOnNode(accessor, Diagnostics.An_abstract_accessor_cannot_have_an_implementation)
			}
			if accessor.parent.kind == SyntaxKindTypeLiteral || accessor.parent.kind == SyntaxKindInterfaceDeclaration {
				return grammarErrorOnNode(accessor.body, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts)
			}
		}
		if accessor.typeParameters {
			return grammarErrorOnNode(accessor.name, Diagnostics.An_accessor_cannot_have_type_parameters)
		}
		if !doesAccessorHaveCorrectParameterCount(accessor) {
			return grammarErrorOnNode(accessor.name, __COND__(accessor.kind == SyntaxKindGetAccessor, Diagnostics.A_get_accessor_cannot_have_parameters, Diagnostics.A_set_accessor_must_have_exactly_one_parameter))
		}
		if accessor.kind == SyntaxKindSetAccessor {
			if accessor.type_ {
				return grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation)
			}
			parameter := Debug.checkDefined(getSetAccessorValueParameter(accessor), "Return value does not match parameter count assertion.")
			if parameter.dotDotDotToken {
				return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_set_accessor_cannot_have_rest_parameter)
			}
			if parameter.questionToken {
				return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_set_accessor_cannot_have_an_optional_parameter)
			}
			if parameter.initializer {
				return grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer)
			}
		}
		return false
	}
	/** Does the accessor have the right number of parameters?
	 * A get accessor has no parameters or a single `this` parameter.
	 * A set accessor has one parameter or a `this` parameter and one more parameter.
	 */
	doesAccessorHaveCorrectParameterCount := func(accessor AccessorDeclaration) /* TODO(TS-TO-GO) inferred type boolean | ParameterDeclaration */ any {
		return getAccessorThisParameter(accessor) || accessor.parameters.length == (__COND__(accessor.kind == SyntaxKindGetAccessor, 0, 1))
	}
	getAccessorThisParameter := func(accessor AccessorDeclaration) *ParameterDeclaration {
		if accessor.parameters.length == (__COND__(accessor.kind == SyntaxKindGetAccessor, 1, 2)) {
			return getThisParameter(accessor)
		}
	}
	checkGrammarTypeOperatorNode := func(node TypeOperatorNode) *bool {
		if node.operator == SyntaxKindUniqueKeyword {
			if node.type_.kind != SyntaxKindSymbolKeyword {
				return grammarErrorOnNode(node.type_, Diagnostics._0_expected, tokenToString(SyntaxKindSymbolKeyword))
			}
			parent := walkUpParenthesizedTypes(node.parent)
			if isInJSFile(parent) && isJSDocTypeExpression(parent) {
				host := getJSDocHost(parent)
				if host {
					parent = getSingleVariableOfVariableStatement(host) || host
				}
			}
			switch parent.kind {
			case SyntaxKindVariableDeclaration:
				decl := parent /* as VariableDeclaration */
				if decl.name.kind != SyntaxKindIdentifier {
					return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name)
				}
				if !isVariableDeclarationInVariableStatement(decl) {
					return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement)
				}
				if !(decl.parent.flags & NodeFlagsConst) {
					return grammarErrorOnNode((parent /* as VariableDeclaration */).name, Diagnostics.A_variable_whose_type_is_a_unique_symbol_type_must_be_const)
				}
				break
			case SyntaxKindPropertyDeclaration:
				if !isStatic(parent) || !hasEffectiveReadonlyModifier(parent) {
					return grammarErrorOnNode((parent /* as PropertyDeclaration */).name, Diagnostics.A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly)
				}
				break
			case SyntaxKindPropertySignature:
				if !hasSyntacticModifier(parent, ModifierFlagsReadonly) {
					return grammarErrorOnNode((parent /* as PropertySignature */).name, Diagnostics.A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly)
				}
				break
			default:
				return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_not_allowed_here)
			}
		} else if node.operator == SyntaxKindReadonlyKeyword {
			if node.type_.kind != SyntaxKindArrayType && node.type_.kind != SyntaxKindTupleType {
				return grammarErrorOnFirstToken(node, Diagnostics.readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types, tokenToString(SyntaxKindSymbolKeyword))
			}
		}
	}
	checkGrammarForInvalidDynamicName := func(node DeclarationName, message DiagnosticMessage) *bool {
		if isNonBindableDynamicName(node) {
			return grammarErrorOnNode(node, message)
		}
	}
	checkGrammarMethod := func(node /* TODO(TS-TO-GO) TypeNode UnionType: MethodDeclaration | MethodSignature */ any) *bool {
		if checkGrammarFunctionLikeDeclaration(node) {
			return true
		}
		if node.kind == SyntaxKindMethodDeclaration {
			if node.parent.kind == SyntaxKindObjectLiteralExpression {
				// We only disallow modifier on a method declaration if it is a property of object-literal-expression
				if node.modifiers && !(node.modifiers.length == 1 && first(node.modifiers).kind == SyntaxKindAsyncKeyword) {
					return grammarErrorOnFirstToken(node, Diagnostics.Modifiers_cannot_appear_here)
				} else if checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional) {
					return true
				} else if checkGrammarForInvalidExclamationToken(node.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context) {
					return true
				} else if node.body == nil {
					return grammarErrorAtPos(node, node.end-1, len(";"), Diagnostics._0_expected, "{")
				}
			}
			if checkGrammarForGenerator(node) {
				return true
			}
		}
		if isClassLike(node.parent) {
			if languageVersion < ScriptTargetES2015 && isPrivateIdentifier(node.name) {
				return grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			// Technically, computed properties in ambient contexts is disallowed
			// for property declarations and accessors too, not just methods.
			// However, property declarations disallow computed names in general,
			// and accessors are not allowed in ambient contexts in general,
			// so this error only really matters for methods.
			if node.flags & NodeFlagsAmbient {
				return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
			} else if node.kind == SyntaxKindMethodDeclaration && !node.body {
				return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
			}
		} else if node.parent.kind == SyntaxKindInterfaceDeclaration {
			return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
		} else if node.parent.kind == SyntaxKindTypeLiteral {
			return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
		}
	}
	checkGrammarBreakOrContinueStatement := func(node BreakOrContinueStatement) bool {
		var current Node = node
		for current {
			if isFunctionLikeOrClassStaticBlockDeclaration(current) {
				return grammarErrorOnNode(node, Diagnostics.Jump_target_cannot_cross_function_boundary)
			}
			switch current.kind {
			case SyntaxKindLabeledStatement:
				if node.label && (current /* as LabeledStatement */).label.escapedText == node.label.escapedText {
					// found matching label - verify that label usage is correct
					// continue can only target labels that are on iteration statements
					isMisplacedContinueLabel := node.kind == SyntaxKindContinueStatement && !isIterationStatement((current /* as LabeledStatement */).statement /*lookInLabeledStatements*/, true)
					if isMisplacedContinueLabel {
						return grammarErrorOnNode(node, Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement)
					}
					return false
				}
				break
			case SyntaxKindSwitchStatement:
				if node.kind == SyntaxKindBreakStatement && !node.label {
					// unlabeled break within switch statement - ok
					return false
				}
				break
			default:
				if isIterationStatement(current /*lookInLabeledStatements*/, false) && !node.label {
					// unlabeled break or continue within iteration statement - ok
					return false
				}
				break
			}
			current = current.parent
		}
		if node.label {
			var message DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node.kind == SyntaxKindBreakStatement:
				message = Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement
			default:
				message = Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement
			}
			return grammarErrorOnNode(node, message)
		} else {
			var message DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node.kind == SyntaxKindBreakStatement:
				message = Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement
			default:
				message = Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement
			}
			return grammarErrorOnNode(node, message)
		}
	}
	checkGrammarBindingElement := func(node BindingElement) *bool {
		if node.dotDotDotToken {
			elements := node.parent.elements
			if node != last(elements) {
				return grammarErrorOnNode(node, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
			}
			checkGrammarForDisallowedTrailingComma(elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
			if node.propertyName {
				return grammarErrorOnNode(node.name, Diagnostics.A_rest_element_cannot_have_a_property_name)
			}
		}
		if node.dotDotDotToken && node.initializer {
			// Error on equals token which immediately precedes the initializer
			return grammarErrorAtPos(node, node.initializer.pos-1, 1, Diagnostics.A_rest_element_cannot_have_an_initializer)
		}
	}
	isStringOrNumberLiteralExpression := func(expr Expression) bool {
		return isStringOrNumericLiteralLike(expr) || expr.kind == SyntaxKindPrefixUnaryExpression && (expr /* as PrefixUnaryExpression */).operator == SyntaxKindMinusToken && (expr /* as PrefixUnaryExpression */).operand.kind == SyntaxKindNumericLiteral
	}
	isBigIntLiteralExpression := func(expr Expression) bool {
		return expr.kind == SyntaxKindBigIntLiteral || expr.kind == SyntaxKindPrefixUnaryExpression && (expr /* as PrefixUnaryExpression */).operator == SyntaxKindMinusToken && (expr /* as PrefixUnaryExpression */).operand.kind == SyntaxKindBigIntLiteral
	}
	isSimpleLiteralEnumReference := func(expr Expression) *bool {
		if (isPropertyAccessExpression(expr) || (isElementAccessExpression(expr) && isStringOrNumberLiteralExpression(expr.argumentExpression))) && isEntityNameExpression(expr.expression) {
			return !!(checkExpressionCached(expr).flags & TypeFlagsEnumLike)
		}
	}
	checkAmbientInitializer := func(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | PropertyDeclaration | PropertySignature */ any) *bool {
		initializer := node.initializer
		if initializer {
			isInvalidInitializer := !(isStringOrNumberLiteralExpression(initializer) || isSimpleLiteralEnumReference(initializer) || initializer.kind == SyntaxKindTrueKeyword || initializer.kind == SyntaxKindFalseKeyword || isBigIntLiteralExpression(initializer))
			isConstOrReadonly := isDeclarationReadonly(node) || isVariableDeclaration(node) && (isVarConstLike(node))
			if isConstOrReadonly && !node.type_ {
				if isInvalidInitializer {
					return grammarErrorOnNode(initializer, Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference)
				}
			} else {
				return grammarErrorOnNode(initializer, Diagnostics.Initializers_are_not_allowed_in_ambient_contexts)
			}
		}
	}
	checkGrammarVariableDeclaration := func(node VariableDeclaration) bool {
		nodeFlags := getCombinedNodeFlagsCached(node)
		blockScopeKind := nodeFlags & NodeFlagsBlockScoped
		if isBindingPattern(node.name) {
			switch blockScopeKind {
			case NodeFlagsAwaitUsing:
				return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "await using")
			case NodeFlagsUsing:
				return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "using")
			}
		}
		if node.parent.parent.kind != SyntaxKindForInStatement && node.parent.parent.kind != SyntaxKindForOfStatement {
			if nodeFlags & NodeFlagsAmbient {
				checkAmbientInitializer(node)
			} else if !node.initializer {
				if isBindingPattern(node.name) && !isBindingPattern(node.parent) {
					return grammarErrorOnNode(node, Diagnostics.A_destructuring_declaration_must_have_an_initializer)
				}
				switch blockScopeKind {
				case NodeFlagsAwaitUsing:
					return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "await using")
				case NodeFlagsUsing:
					return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "using")
				case NodeFlagsConst:
					return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "const")
				}
			}
		}
		if node.exclamationToken && (node.parent.parent.kind != SyntaxKindVariableStatement || !node.type_ || node.initializer || nodeFlags&NodeFlagsAmbient) {
			var message DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node.initializer:
				message = Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions
			case !node.type_:
				message = Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations
			default:
				message = Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context
			}
			return grammarErrorOnNode(node.exclamationToken, message)
		}
		if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && !(node.parent.parent.flags & NodeFlagsAmbient) && hasSyntacticModifier(node.parent.parent, ModifierFlagsExport) {
			checkESModuleMarker(node.name)
		}
		// 1. LexicalDeclaration : LetOrConst BindingList ;
		// It is a Syntax Error if the BoundNames of BindingList contains "let".
		// 2. ForDeclaration: ForDeclaration : LetOrConst ForBinding
		// It is a Syntax Error if the BoundNames of ForDeclaration contains "let".
		// It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within strict code
		// and its Identifier is eval or arguments
		return !!blockScopeKind && checkGrammarNameInLetOrConstDeclarations(node.name)
	}
	checkESModuleMarker := func(name /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | BindingPattern */ any) bool {
		if name.kind == SyntaxKindIdentifier {
			if idText(name) == "__esModule" {
				return grammarErrorOnNodeSkippedOn("noEmit", name, Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules)
			}
		} else {
			elements := name.elements
			for _, element := range elements {
				if !isOmittedExpression(element) {
					return checkESModuleMarker(element.name)
				}
			}
		}
		return false
	}
	checkGrammarNameInLetOrConstDeclarations := func(name /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | BindingPattern */ any) bool {
		if name.kind == SyntaxKindIdentifier {
			if name.escapedText == "let" {
				return grammarErrorOnNode(name, Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations)
			}
		} else {
			elements := name.elements
			for _, element := range elements {
				if !isOmittedExpression(element) {
					checkGrammarNameInLetOrConstDeclarations(element.name)
				}
			}
		}
		return false
	}
	checkGrammarVariableDeclarationList := func(declarationList VariableDeclarationList) bool {
		declarations := declarationList.declarations
		if checkGrammarForDisallowedTrailingComma(declarationList.declarations) {
			return true
		}
		if !declarationList.declarations.length {
			return grammarErrorAtPos(declarationList, declarations.pos, declarations.end-declarations.pos, Diagnostics.Variable_declaration_list_cannot_be_empty)
		}
		blockScopeFlags := declarationList.flags & NodeFlagsBlockScoped
		if (blockScopeFlags == NodeFlagsUsing || blockScopeFlags == NodeFlagsAwaitUsing) && isForInStatement(declarationList.parent) {
			return grammarErrorOnNode(declarationList, __COND__(blockScopeFlags == NodeFlagsUsing, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration))
		}
		if blockScopeFlags == NodeFlagsAwaitUsing {
			return checkAwaitGrammar(declarationList)
		}
		return false
	}
	allowLetAndConstDeclarations := func(parent Node) bool {
		switch parent.kind {
		case SyntaxKindIfStatement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindDoStatement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindWhileStatement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindWithStatement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindForStatement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindForInStatement:
			fallthrough // TODO(TS-TO-GO): merge cases
		case SyntaxKindForOfStatement:
			return false
		case SyntaxKindLabeledStatement:
			return allowLetAndConstDeclarations(parent.parent)
		}
		return true
	}
	checkGrammarForDisallowedBlockScopedVariableStatement := func(node VariableStatement) *bool {
		if !allowLetAndConstDeclarations(node.parent) {
			blockScopeKind := getCombinedNodeFlagsCached(node.declarationList) & NodeFlagsBlockScoped
			if blockScopeKind {
				var keyword /* TODO(TS-TO-GO) inferred type "const" | "await using" | "using" | "let" */ any
				// TODO(TS-TO-GO): converted from conditional expression
				switch {
				case blockScopeKind == NodeFlagsLet:
					keyword = "let"
				case blockScopeKind == NodeFlagsConst:
					keyword = "const"
				case blockScopeKind == NodeFlagsUsing:
					keyword = "using"
				case blockScopeKind == NodeFlagsAwaitUsing:
					keyword = "await using"
				default:
					keyword = Debug.fail("Unknown BlockScope flag")
				}
				return grammarErrorOnNode(node, Diagnostics._0_declarations_can_only_be_declared_inside_a_block, keyword)
			}
		}
	}
	checkGrammarMetaProperty := func(node MetaProperty) *bool {
		escapedText := node.name.escapedText
		switch node.keywordToken {
		case SyntaxKindNewKeyword:
			if escapedText != "target" {
				return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "target")
			}
			break
		case SyntaxKindImportKeyword:
			if escapedText != "meta" {
				return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "meta")
			}
			break
		}
	}
	hasParseDiagnostics := func(sourceFile SourceFile) bool {
		return sourceFile.parseDiagnostics.length > 0
	}
	grammarErrorOnFirstToken := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			span := getSpanOfTokenAtPosition(sourceFile, node.pos)
			diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message, args...))
			return true
		}
		return false
	}
	grammarErrorAtPos := func(nodeForSourceFile Node, start number, length number, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(nodeForSourceFile)
		if !hasParseDiagnostics(sourceFile) {
			diagnostics.add(createFileDiagnostic(sourceFile, start, length, message, args...))
			return true
		}
		return false
	}
	grammarErrorOnNodeSkippedOn := func(key CompilerOptions, node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			errorSkippedOn(key, node, message, args...)
			return true
		}
		return false
	}
	grammarErrorOnNode := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			diagnostics.add(createDiagnosticForNode(node, message, args...))
			return true
		}
		return false
	}
	checkGrammarConstructorTypeParameters := func(node ConstructorDeclaration) *bool {
		var jsdocTypeParameters *[]TypeParameterDeclaration
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case isInJSFile(node):
			jsdocTypeParameters = getJSDocTypeParameterDeclarations(node)
		default:
			jsdocTypeParameters = nil
		}
		range_ := node.typeParameters || jsdocTypeParameters && firstOrUndefined(jsdocTypeParameters)
		if range_ {
			var pos number
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case range_.pos == range_.end:
				pos = range_.pos
			default:
				pos = skipTrivia(getSourceFileOfNode(node).text, range_.pos)
			}
			return grammarErrorAtPos(node, pos, range_.end-pos, Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration)
		}
	}
	checkGrammarConstructorTypeAnnotation := func(node ConstructorDeclaration) *bool {
		type_ := node.type_ || getEffectiveReturnTypeNode(node)
		if type_ {
			return grammarErrorOnNode(type_, Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration)
		}
	}
	checkGrammarProperty := func(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyDeclaration | PropertySignature */ any) *bool {
		if isComputedPropertyName(node.name) && isBinaryExpression(node.name.expression) && node.name.expression.operatorToken.kind == SyntaxKindInKeyword {
			return grammarErrorOnNode(node.parent.members[0], Diagnostics.A_mapped_type_may_not_declare_properties_or_methods)
		}
		if isClassLike(node.parent) {
			if isStringLiteral(node.name) && node.name.text == "constructor" {
				return grammarErrorOnNode(node.name, Diagnostics.Classes_may_not_have_a_field_named_constructor)
			}
			if checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type) {
				return true
			}
			if languageVersion < ScriptTargetES2015 && isPrivateIdentifier(node.name) {
				return grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if languageVersion < ScriptTargetES2015 && isAutoAccessorPropertyDeclaration(node) {
				return grammarErrorOnNode(node.name, Diagnostics.Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if isAutoAccessorPropertyDeclaration(node) && checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_accessor_property_cannot_be_declared_optional) {
				return true
			}
		} else if node.parent.kind == SyntaxKindInterfaceDeclaration {
			if checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type) {
				return true
			}
			// Interfaces cannot contain property declarations
			Debug.assertNode(node, isPropertySignature)
			if node.initializer {
				return grammarErrorOnNode(node.initializer, Diagnostics.An_interface_property_cannot_have_an_initializer)
			}
		} else if isTypeLiteralNode(node.parent) {
			if checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type) {
				return true
			}
			// Type literals cannot contain property declarations
			Debug.assertNode(node, isPropertySignature)
			if node.initializer {
				return grammarErrorOnNode(node.initializer, Diagnostics.A_type_literal_property_cannot_have_an_initializer)
			}
		}
		if node.flags & NodeFlagsAmbient {
			checkAmbientInitializer(node)
		}
		if isPropertyDeclaration(node) && node.exclamationToken && (!isClassLike(node.parent) || !node.type_ || node.initializer || node.flags&NodeFlagsAmbient || isStatic(node) || hasAbstractModifier(node)) {
			var message DiagnosticMessage
			// TODO(TS-TO-GO): converted from conditional expression
			switch {
			case node.initializer:
				message = Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions
			case !node.type_:
				message = Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations
			default:
				message = Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context
			}
			return grammarErrorOnNode(node.exclamationToken, message)
		}
	}
	checkGrammarTopLevelElementForRequiredDeclareModifier := func(node Node) bool {
		// A declare modifier is required for any top level .d.ts declaration except export=, export default, export as namespace
		// interfaces and imports categories:
		//
		//  DeclarationElement:
		//     ExportAssignment
		//     export_opt   InterfaceDeclaration
		//     export_opt   TypeAliasDeclaration
		//     export_opt   ImportDeclaration
		//     export_opt   ExternalImportDeclaration
		//     export_opt   AmbientDeclaration
		//
		// TODO: The spec needs to be amended to reflect this grammar.
		if node.kind == SyntaxKindInterfaceDeclaration || node.kind == SyntaxKindTypeAliasDeclaration || node.kind == SyntaxKindImportDeclaration || node.kind == SyntaxKindImportEqualsDeclaration || node.kind == SyntaxKindExportDeclaration || node.kind == SyntaxKindExportAssignment || node.kind == SyntaxKindNamespaceExportDeclaration || hasSyntacticModifier(node, ModifierFlagsAmbient|ModifierFlagsExport|ModifierFlagsDefault) {
			return false
		}
		return grammarErrorOnFirstToken(node, Diagnostics.Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier)
	}
	checkGrammarTopLevelElementsForRequiredDeclareModifier := func(file SourceFile) bool {
		for _, decl := range file.statements {
			if isDeclaration(decl) || decl.kind == SyntaxKindVariableStatement {
				if checkGrammarTopLevelElementForRequiredDeclareModifier(decl) {
					return true
				}
			}
		}
		return false
	}
	checkGrammarSourceFile := func(node SourceFile) bool {
		return !!(node.flags & NodeFlagsAmbient) && checkGrammarTopLevelElementsForRequiredDeclareModifier(node)
	}
	checkGrammarStatementInAmbientContext := func(node Node) bool {
		if node.flags & NodeFlagsAmbient {
			// Find containing block which is either Block, ModuleBlock, SourceFile
			links := getNodeLinks(node)
			if !links.hasReportedStatementInAmbientContext && (isFunctionLike(node.parent) || isAccessor(node.parent)) {
				getNodeLinks(node).hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts)
				return getNodeLinks(node).hasReportedStatementInAmbientContext
			}
			// We are either parented by another statement, or some sort of block.
			// If we're in a block, we only want to really report an error once
			// to prevent noisiness.  So use a bit on the block to indicate if
			// this has already been reported, and don't report if it has.
			//
			if node.parent.kind == SyntaxKindBlock || node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
				links := getNodeLinks(node.parent)
				// Check if the containing block ever report this error
				if !links.hasReportedStatementInAmbientContext {
					links.hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.Statements_are_not_allowed_in_ambient_contexts)
					return links.hasReportedStatementInAmbientContext
				}
			} else {
				// We must be parented by a statement.  If so, there's no need
				// to report the error as our parent will have already done it.
				// Debug.assert(isStatement(node.parent));
			}
		}
		return false
	}
	checkGrammarNumericLiteral := func(node NumericLiteral) {
		// Realism (size) checking
		// We should test against `getTextOfNode(node)` rather than `node.text`, because `node.text` for large numeric literals can contain "."
		// e.g. `node.text` for numeric literal `1100000000000000000000` is `1.1e21`.
		isFractional := getTextOfNode(node).includes(".")
		isScientific := node.numericLiteralFlags & TokenFlagsScientific
		// Scientific notation (e.g. 2e54 and 1e00000000010) can't be converted to bigint
		// Fractional numbers (e.g. 9000000000000000.001) are inherently imprecise anyway
		if isFractional || isScientific {
			return
		}
		// Here `node` is guaranteed to be a numeric literal representing an integer.
		// We need to judge whether the integer `node` represents is <= 2 ** 53 - 1, which can be accomplished by comparing to `value` defined below because:
		// 1) when `node` represents an integer <= 2 ** 53 - 1, `node.text` is its exact string representation and thus `value` precisely represents the integer.
		// 2) otherwise, although `node.text` may be imprecise string representation, its mathematical value and consequently `value` cannot be less than 2 ** 53,
		//    thus the result of the predicate won't be affected.
		value := +node.text
		if value <= /* TODO(TS-TO-GO) Node BinaryExpression: 2 ** 53 */ TODO-1 {
			return
		}
		addErrorOrSuggestion(false, createDiagnosticForNode(node, Diagnostics.Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers))
	}
	checkGrammarBigIntLiteral := func(node BigIntLiteral) bool {
		literalType := isLiteralTypeNode(node.parent) || isPrefixUnaryExpression(node.parent) && isLiteralTypeNode(node.parent.parent)
		if !literalType {
			if languageVersion < ScriptTargetES2020 {
				if grammarErrorOnNode(node, Diagnostics.BigInt_literals_are_not_available_when_targeting_lower_than_ES2020) {
					return true
				}
			}
		}
		return false
	}
	grammarErrorAfterFirstToken := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			span := getSpanOfTokenAtPosition(sourceFile, node.pos)
			diagnostics.add(createFileDiagnostic(sourceFile, textSpanEnd(span) /*length*/, 0, message, args...))
			return true
		}
		return false
	}
	getAmbientModules := func() []Symbol {
		if !ambientModulesCache {
			ambientModulesCache = []never{}
			globals.forEach(func(global Symbol, sym __String) {
				// No need to `unescapeLeadingUnderscores`, an escaped symbol is never an ambient module.
				if ambientModuleSymbolRegex.test(sym /* as string */) {
					ambientModulesCache.push(global)
				}
			})
		}
		return ambientModulesCache
	}
	checkGrammarImportClause := func(node ImportClause) bool {
		if node.isTypeOnly && node.name && node.namedBindings {
			return grammarErrorOnNode(node, Diagnostics.A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both)
		}
		if node.isTypeOnly && node.namedBindings. /* TODO(TS-TO-GO): was ? */ kind == SyntaxKindNamedImports {
			return checkGrammarNamedImportsOrExports(node.namedBindings)
		}
		return false
	}
	checkGrammarNamedImportsOrExports := func(namedBindings NamedImportsOrExports) bool {
		return !!forEach(namedBindings.elements, func(specifier /* TODO(TS-TO-GO) inferred type ExportSpecifier | ImportSpecifier */ any) *bool {
			if specifier.isTypeOnly {
				return grammarErrorOnFirstToken(specifier, __COND__(specifier.kind == SyntaxKindImportSpecifier, Diagnostics.The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement, Diagnostics.The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement))
			}
		})
	}
	checkGrammarImportCallExpression := func(node ImportCall) bool {
		if compilerOptions.verbatimModuleSyntax && moduleKind == ModuleKindCommonJS {
			return grammarErrorOnNode(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
		}
		if moduleKind == ModuleKindES2015 {
			return grammarErrorOnNode(node, Diagnostics.Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext)
		}
		if node.typeArguments {
			return grammarErrorOnNode(node, Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments)
		}
		nodeArguments := node.arguments
		if moduleKind != ModuleKindESNext && moduleKind != ModuleKindNodeNext && moduleKind != ModuleKindNode16 && moduleKind != ModuleKindPreserve {
			// We are allowed trailing comma after proposal-import-assertions.
			checkGrammarForDisallowedTrailingComma(nodeArguments)
			if nodeArguments.length > 1 {
				importAttributesArgument := nodeArguments[1]
				return grammarErrorOnNode(importAttributesArgument, Diagnostics.Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_nodenext_or_preserve)
			}
		}
		if nodeArguments.length == 0 || nodeArguments.length > 2 {
			return grammarErrorOnNode(node, Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments)
		}
		// see: parseArgumentOrArrayLiteralElement...we use this function which parse arguments of callExpression to parse specifier for dynamic import.
		// parseArgumentOrArrayLiteralElement allows spread element to be in an argument list which is not allowed as specifier in dynamic import.
		spreadElement := find(nodeArguments, isSpreadElement)
		if spreadElement {
			return grammarErrorOnNode(spreadElement, Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element)
		}
		return false
	}
	findMatchingTypeReferenceOrTypeAliasReference := func(source Type, unionTarget UnionOrIntersectionType) Type {
		sourceObjectFlags := getObjectFlags(source)
		if sourceObjectFlags&(ObjectFlagsReference|ObjectFlagsAnonymous) && unionTarget.flags&TypeFlagsUnion {
			return find(unionTarget.types, func(target Type) bool {
				if target.flags & TypeFlagsObject {
					overlapObjFlags := sourceObjectFlags & getObjectFlags(target)
					if overlapObjFlags & ObjectFlagsReference {
						return (source /* as TypeReference */).target == (target /* as TypeReference */).target
					}
					if overlapObjFlags & ObjectFlagsAnonymous {
						return !!(source /* as AnonymousType */).aliasSymbol && (source /* as AnonymousType */).aliasSymbol == (target /* as AnonymousType */).aliasSymbol
					}
				}
				return false
			})
		}
	}
	findBestTypeForObjectLiteral := func(source Type, unionTarget UnionOrIntersectionType) Type {
		if getObjectFlags(source)&ObjectFlagsObjectLiteral && someType(unionTarget, isArrayLikeType) {
			return find(unionTarget.types, func(t Type) bool {
				return !isArrayLikeType(t)
			})
		}
	}
	findBestTypeForInvokable := func(source Type, unionTarget UnionOrIntersectionType) Type {
		signatureKind := SignatureKindCall
		hasSignatures := getSignaturesOfType(source, signatureKind).length > 0 || ( /* TODO(TS-TO-GO) Node BinaryExpression: signatureKind = SignatureKind.Construct, getSignaturesOfType(source, signatureKind).length > 0 */ TODO)
		if hasSignatures {
			return find(unionTarget.types, func(t Type) bool {
				return getSignaturesOfType(t, signatureKind).length > 0
			})
		}
	}
	findMostOverlappyType := func(source Type, unionTarget UnionOrIntersectionType) Type {
		var bestMatch Type
		if !(source.flags & (TypeFlagsPrimitive | TypeFlagsInstantiablePrimitive)) {
			matchingCount := 0
			for _, target := range unionTarget.types {
				if !(target.flags & (TypeFlagsPrimitive | TypeFlagsInstantiablePrimitive)) {
					overlap := getIntersectionType([]Type{getIndexType(source), getIndexType(target)})
					if overlap.flags & TypeFlagsIndex {
						// perfect overlap of keys
						return target
					} else if isUnitType(overlap) || overlap.flags&TypeFlagsUnion {
						// We only want to account for literal types otherwise.
						// If we have a union of index types, it seems likely that we
						// needed to elaborate between two generic mapped types anyway.
						var len number
						// TODO(TS-TO-GO): converted from conditional expression
						switch {
						case overlap.flags & TypeFlagsUnion:
							len = countWhere((overlap /* as UnionType */).types, isUnitType)
						default:
							len = 1
						}
						if len >= matchingCount {
							bestMatch = target
							matchingCount = len
						}
					}
				}
			}
		}
		return bestMatch
	}
	filterPrimitivesIfContainsNonPrimitive := func(type_ UnionType) Type {
		if maybeTypeOfKind(type_, TypeFlagsNonPrimitive) {
			result := filterType(type_, func(t Type) bool {
				return !(t.flags & TypeFlagsPrimitive)
			})
			if !(result.flags & TypeFlagsNever) {
				return result
			}
		}
		return type_
	}
	// Keep this up-to-date with the same logic within `getApparentTypeOfContextualType`, since they should behave similarly
	findMatchingDiscriminantType := func(source Type, target Type, isRelatedTo func(source Type, target Type) Ternary) Type {
		if target.flags&TypeFlagsUnion && source.flags&(TypeFlagsIntersection|TypeFlagsObject) {
			match := getMatchingUnionConstituentForType(target /* as UnionType */, source)
			if match {
				return match
			}
			sourceProperties := getPropertiesOfType(source)
			if sourceProperties {
				sourcePropertiesFiltered := findDiscriminantProperties(sourceProperties, target)
				if sourcePropertiesFiltered {
					discriminated := discriminateTypeByDiscriminableItems(target /* as UnionType */, map_(sourcePropertiesFiltered, func(p Symbol) /* TODO(TS-TO-GO) inferred type [() => Type, __String] */ any {
						return ([]any{func() Type {
							return getTypeOfSymbol(p)
						}, p.escapedName} /* as [() => Type, __String] */)
					}), isRelatedTo)
					if discriminated != target {
						return discriminated
					}
				}
			}
		}
		return nil
	}
	getEffectivePropertyNameForPropertyNameNode := func(node PropertyName) *__String {
		name := getPropertyNameForPropertyNameNode(node)
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case name:
			return name
		case isComputedPropertyName(node):
			return tryGetNameFromType(getTypeOfExpression(node.expression))
		default:
			return nil
		}
	}
	getCombinedModifierFlagsCached := func(node Declaration) ModifierFlags {
		// we hold onto the last node and result to speed up repeated lookups against the same node.
		if lastGetCombinedModifierFlagsNode == node {
			return lastGetCombinedModifierFlagsResult
		}
		lastGetCombinedModifierFlagsNode = node
		lastGetCombinedModifierFlagsResult = getCombinedModifierFlags(node)
		return lastGetCombinedModifierFlagsResult
	}
	getCombinedNodeFlagsCached := func(node Node) NodeFlags {
		// we hold onto the last node and result to speed up repeated lookups against the same node.
		if lastGetCombinedNodeFlagsNode == node {
			return lastGetCombinedNodeFlagsResult
		}
		lastGetCombinedNodeFlagsNode = node
		lastGetCombinedNodeFlagsResult = getCombinedNodeFlags(node)
		return lastGetCombinedNodeFlagsResult
	}
	isVarConstLike := func(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | VariableDeclarationList */ any) bool {
		blockScopeKind := getCombinedNodeFlagsCached(node) & NodeFlagsBlockScoped
		return blockScopeKind == NodeFlagsConst || blockScopeKind == NodeFlagsUsing || blockScopeKind == NodeFlagsAwaitUsing
	}
	getJSXRuntimeImportSpecifier := func(file *SourceFile, specifierText string) *StringLiteralLike {
		// Synthesized JSX import is either first or after tslib
		var jsxImportIndex /* TODO(TS-TO-GO) inferred type 0 | 1 */ any
		// TODO(TS-TO-GO): converted from conditional expression
		switch {
		case compilerOptions.importHelpers:
			jsxImportIndex = 1
		default:
			jsxImportIndex = 0
		}
		specifier := file. /* TODO(TS-TO-GO): was ? */ imports[jsxImportIndex]
		if specifier {
			Debug.assert(nodeIsSynthesized(specifier) && specifier.text == specifierText, __TEMPLATE__("Expected sourceFile.imports[", jsxImportIndex, "] to be the synthesized JSX runtime import"))
		}
		return specifier
	}
	getImportHelpersImportSpecifier := func(file SourceFile) StringLiteralLike {
		Debug.assert(compilerOptions.importHelpers, "Expected importHelpers to be enabled")
		specifier := file.imports[0]
		Debug.assert(specifier && nodeIsSynthesized(specifier) && specifier.text == "tslib", `Expected sourceFile.imports[0] to be the synthesized tslib import`)
		return specifier
	}
}
func isNotAccessor(declaration Declaration) bool {
	// Accessors check for their own matching duplicates, and in contexts where they are valid, there are already duplicate identifier checks
	return !isAccessor(declaration)
}
func isNotOverload(declaration Declaration) bool {
	return (declaration.kind != SyntaxKindFunctionDeclaration && declaration.kind != SyntaxKindMethodDeclaration) || !!(declaration /* as FunctionDeclaration */).body
}

/** Like 'isDeclarationName', but returns true for LHS of `import { x as y }` or `export { x as y }`. */
func isDeclarationNameOrImportPropertyName(name Node) bool {
	switch name.parent.kind {
	case SyntaxKindImportSpecifier:
		fallthrough // TODO(TS-TO-GO): merge cases
	case SyntaxKindExportSpecifier:
		return isIdentifier(name) || name.kind == SyntaxKindStringLiteral
	default:
		return isDeclarationName(name)
	}
}

var JsxNames = struct {
	JSX                                    __String
	IntrinsicElements                      __String
	ElementClass                           __String
	ElementAttributesPropertyNameContainer __String
	ElementChildrenAttributeNameContainer  __String
	Element                                __String
	ElementType                            __String
	IntrinsicAttributes                    __String
	IntrinsicClassAttributes               __String
	LibraryManagedAttributes               __String
}{
	JSX:                                    __String("JSX"),
	IntrinsicElements:                      __String("IntrinsicElements"),
	ElementClass:                           __String("ElementClass"),
	ElementAttributesPropertyNameContainer: __String("ElementAttributesProperty"),
	ElementChildrenAttributeNameContainer:  __String("ElementChildrenAttribute"),
	Element:                                __String("Element"),
	ElementType:                            __String("ElementType"),
	IntrinsicAttributes:                    __String("IntrinsicAttributes"),
	IntrinsicClassAttributes:               __String("IntrinsicClassAttributes"),
	LibraryManagedAttributes:               __String("LibraryManagedAttributes"),
}

func getIterationTypesKeyFromIterationTypeKind(typeKind IterationTypeKind) /* TODO(TS-TO-GO) inferred type "yieldType" | "returnType" | "nextType" */ any {
	switch typeKind {
	case IterationTypeKindYield:
		return "yieldType"
	case IterationTypeKindReturn:
		return "returnType"
	case IterationTypeKindNext:
		return "nextType"
	}
}

/** @internal */
func signatureHasRestParameter(s Signature) bool {
	return !!(s.flags & SignatureFlagsHasRestParameter)
}
func signatureHasLiteralTypes(s Signature) bool {
	return !!(s.flags & SignatureFlagsHasLiteralTypes)
}
func createBasicNodeBuilderModuleSpecifierResolutionHost(host TypeCheckerHost) ModuleSpecifierResolutionHost {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"getCommonSourceDirectory": __COND__(!!(host /* as Program */).getCommonSourceDirectory, func() string {
			return (host /* as Program */).getCommonSourceDirectory()
		}, func() string {
			return ""
		}),
		"getCurrentDirectory": func() string {
			return host.getCurrentDirectory()
		},
		"getSymlinkCache": maybeBind(host, host.getSymlinkCache),
		"getPackageJsonInfoCache": func() *PackageJsonInfoCache {
			return host.getPackageJsonInfoCache()
		},
		"useCaseSensitiveFileNames": maybeBind(host, host.useCaseSensitiveFileNames),
		"redirectTargetsMap":        host.redirectTargetsMap,
		"getProjectReferenceRedirect": func(fileName string) *string {
			return host.getProjectReferenceRedirect(fileName)
		},
		"isSourceOfProjectReferenceRedirect": func(fileName string) bool {
			return host.isSourceOfProjectReferenceRedirect(fileName)
		},
		"fileExists": func(fileName string) bool {
			return host.fileExists(fileName)
		},
		"getFileIncludeReasons": func() /* TODO(TS-TO-GO) inferred type MultiMap<Path, FileIncludeReason> */ any {
			return host.getFileIncludeReasons()
		},
		"readFile": __COND__(host.readFile, (func(fileName string) *string {
			return host.readFile(fileName)
		}), nil),
		"getDefaultResolutionModeForFile": func(file SourceFile) ResolutionMode {
			return host.getDefaultResolutionModeForFile(file)
		},
		"getModeForResolutionAtIndex": func(file SourceFile, index number) ResolutionMode {
			return host.getModeForResolutionAtIndex(file, index)
		},
	}
}

type NodeBuilderContext struct {
	enclosingDeclaration                  Node
	enclosingFile                         *SourceFile
	flags                                 NodeBuilderFlags
	internalFlags                         InternalNodeBuilderFlags
	tracker                               SymbolTrackerImpl
	encounteredError                      bool
	reportedDiagnostic                    bool
	trackedSymbols                        *[]TrackedSymbol
	visitedTypes                          *Set[number]
	symbolDepth                           *Map[string, number]
	inferTypeParameters                   *[]TypeParameter
	approximateLength                     number
	truncating                            bool
	mustCreateTypeParameterSymbolList     bool
	typeParameterSymbolList               *Set[number]
	mustCreateTypeParametersNamesLookups  bool
	typeParameterNames                    *Map[TypeId, Identifier]
	typeParameterNamesByText              *Set[string]
	typeParameterNamesByTextNextNameCount *Map[string, number]
	usedSymbolNames                       *Set[string]
	remappedSymbolNames                   *Map[SymbolId, string]
	remappedSymbolReferences              *Map[SymbolId, Symbol]
	reverseMappedStack                    *[]ReverseMappedSymbol
	bundled                               bool
	mapper                                *TypeMapper
}

/* TODO(TS-TO-GO) Node ClassDeclaration: class SymbolTrackerImpl implements SymbolTracker { moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined = undefined; context: NodeBuilderContext; readonly inner: SymbolTracker | undefined = undefined; readonly canTrackSymbol: boolean; disableTrackSymbol = false; constructor(context: NodeBuilderContext, tracker: SymbolTracker | undefined, moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined) { while (tracker instanceof SymbolTrackerImpl) { tracker = tracker.inner; } this.inner = tracker; this.moduleResolverHost = moduleResolverHost; this.context = context; this.canTrackSymbol = !!this.inner?.trackSymbol; } trackSymbol(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): boolean { if (this.inner?.trackSymbol && !this.disableTrackSymbol) { if (this.inner.trackSymbol(symbol, enclosingDeclaration, meaning)) { this.onDiagnosticReported(); return true; } // Skip recording type parameters as they dont contribute to late painted statements if (!(symbol.flags & SymbolFlags.TypeParameter)) (this.context.trackedSymbols ??= []).push([symbol, enclosingDeclaration, meaning]); } return false; } reportInaccessibleThisError(): void { if (this.inner?.reportInaccessibleThisError) { this.onDiagnosticReported(); this.inner.reportInaccessibleThisError(); } } reportPrivateInBaseOfClassExpression(propertyName: string): void { if (this.inner?.reportPrivateInBaseOfClassExpression) { this.onDiagnosticReported(); this.inner.reportPrivateInBaseOfClassExpression(propertyName); } } reportInaccessibleUniqueSymbolError(): void { if (this.inner?.reportInaccessibleUniqueSymbolError) { this.onDiagnosticReported(); this.inner.reportInaccessibleUniqueSymbolError(); } } reportCyclicStructureError(): void { if (this.inner?.reportCyclicStructureError) { this.onDiagnosticReported(); this.inner.reportCyclicStructureError(); } } reportLikelyUnsafeImportRequiredError(specifier: string): void { if (this.inner?.reportLikelyUnsafeImportRequiredError) { this.onDiagnosticReported(); this.inner.reportLikelyUnsafeImportRequiredError(specifier); } } reportTruncationError(): void { if (this.inner?.reportTruncationError) { this.onDiagnosticReported(); this.inner.reportTruncationError(); } } reportNonlocalAugmentation(containingFile: SourceFile, parentSymbol: Symbol, augmentingSymbol: Symbol): void { if (this.inner?.reportNonlocalAugmentation) { this.onDiagnosticReported(); this.inner.reportNonlocalAugmentation(containingFile, parentSymbol, augmentingSymbol); } } reportNonSerializableProperty(propertyName: string): void { if (this.inner?.reportNonSerializableProperty) { this.onDiagnosticReported(); this.inner.reportNonSerializableProperty(propertyName); } } private onDiagnosticReported() { this.context.reportedDiagnostic = true; } reportInferenceFallback(node: Node): void { if (this.inner?.reportInferenceFallback) { this.inner.reportInferenceFallback(node); } }
} */
