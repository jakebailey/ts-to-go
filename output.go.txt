package output

var ambientModuleSymbolRegex = regexp.MustParse(`^".+"$`)
var anon = "(anonymous)" /* as */ /* TODO(IntersectionType): __String & string */
type ReferenceHint int32
const (
    ReferenceHintUnspecified ReferenceHint = iota
    ReferenceHintIdentifier 
    ReferenceHintProperty 
    ReferenceHintExportAssignment 
    ReferenceHintJsx 
    ReferenceHintAsyncFunction 
    ReferenceHintExportImportEquals 
    ReferenceHintExportSpecifier 
    ReferenceHintDecorator 
)
var nextSymbolId = 1
var nextNodeId = 1
var nextMergeId = 1
var nextFlowId = 1
type IterationUse int32
const (
    IterationUseAllowsSyncIterablesFlag IterationUse = 1 << 0
    IterationUseAllowsAsyncIterablesFlag IterationUse = 1 << 1
    IterationUseAllowsStringInputFlag IterationUse = 1 << 2
    IterationUseForOfFlag IterationUse = 1 << 3
    IterationUseYieldStarFlag IterationUse = 1 << 4
    IterationUseSpreadFlag IterationUse = 1 << 5
    IterationUseDestructuringFlag IterationUse = 1 << 6
    IterationUsePossiblyOutOfBounds IterationUse = 1 << 7
    IterationUseElement IterationUse = IterationUseAllowsSyncIterablesFlag
    IterationUseSpread IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseSpreadFlag
    IterationUseDestructuring IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseDestructuringFlag
    IterationUseForOf IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
    IterationUseForAwaitOf IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
    IterationUseYieldStar IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseYieldStarFlag
    IterationUseAsyncYieldStar IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseIterationUseYieldStarFlag
    IterationUseGeneratorReturnType IterationUse = IterationUseAllowsSyncIterablesFlag
    IterationUseAsyncGeneratorReturnType IterationUse = IterationUseAllowsAsyncIterablesFlag
)
type IterationTypeKind int32
const (
    IterationTypeKindYield IterationTypeKind = iota
    IterationTypeKindReturn 
    IterationTypeKindNext 
)
type IterationTypesResolver struct {
    iterableCacheKey /* TODO(UnionType): "iterationTypesOfAsyncIterable" | "iterationTypesOfIterable" */ any
    iteratorCacheKey /* TODO(UnionType): "iterationTypesOfAsyncIterator" | "iterationTypesOfIterator" */ any
    iteratorSymbolName /* TODO(UnionType): "asyncIterator" | "iterator" */ any
    getGlobalIteratorType func(reportErrors bool) GenericType
    getGlobalIterableType func(reportErrors bool) GenericType
    getGlobalIterableIteratorType func(reportErrors bool) GenericType
    getGlobalIteratorObjectType func(reportErrors bool) GenericType
    getGlobalGeneratorType func(reportErrors bool) GenericType
    getGlobalBuiltinIteratorTypes func() []GenericType
    resolveIterationType func(type_ Type, errorNode Node) *Type
    mustHaveANextMethodDiagnostic DiagnosticMessage
    mustBeAMethodDiagnostic DiagnosticMessage
    mustHaveAValueDiagnostic DiagnosticMessage
}
type WideningKind int32
const (
    WideningKindNormal WideningKind = iota
    WideningKindFunctionReturn 
    WideningKindGeneratorNext 
    WideningKindGeneratorYield 
)
type TypeFacts int32
const (
    TypeFactsNone TypeFacts = 0
    TypeFactsTypeofEQString TypeFacts = 1 << 0
    TypeFactsTypeofEQNumber TypeFacts = 1 << 1
    TypeFactsTypeofEQBigInt TypeFacts = 1 << 2
    TypeFactsTypeofEQBoolean TypeFacts = 1 << 3
    TypeFactsTypeofEQSymbol TypeFacts = 1 << 4
    TypeFactsTypeofEQObject TypeFacts = 1 << 5
    TypeFactsTypeofEQFunction TypeFacts = 1 << 6
    TypeFactsTypeofEQHostObject TypeFacts = 1 << 7
    TypeFactsTypeofNEString TypeFacts = 1 << 8
    TypeFactsTypeofNENumber TypeFacts = 1 << 9
    TypeFactsTypeofNEBigInt TypeFacts = 1 << 10
    TypeFactsTypeofNEBoolean TypeFacts = 1 << 11
    TypeFactsTypeofNESymbol TypeFacts = 1 << 12
    TypeFactsTypeofNEObject TypeFacts = 1 << 13
    TypeFactsTypeofNEFunction TypeFacts = 1 << 14
    TypeFactsTypeofNEHostObject TypeFacts = 1 << 15
    TypeFactsEQUndefined TypeFacts = 1 << 16
    TypeFactsEQNull TypeFacts = 1 << 17
    TypeFactsEQUndefinedOrNull TypeFacts = 1 << 18
    TypeFactsNEUndefined TypeFacts = 1 << 19
    TypeFactsNENull TypeFacts = 1 << 20
    TypeFactsNEUndefinedOrNull TypeFacts = 1 << 21
    TypeFactsTruthy TypeFacts = 1 << 22
    TypeFactsFalsy TypeFacts = 1 << 23
    TypeFactsIsUndefined TypeFacts = 1 << 24
    TypeFactsIsNull TypeFacts = 1 << 25
    TypeFactsIsUndefinedOrNull TypeFacts = TypeFactsIsUndefined | TypeFactsIsNull
    TypeFactsAll TypeFacts = (1 << 27) - 1
    TypeFactsBaseStringStrictFacts TypeFacts = TypeFactsTypeofEQString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
    TypeFactsBaseStringFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsStringStrictFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy | TypeFactsFalsy
    TypeFactsStringFacts TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
    TypeFactsEmptyStringStrictFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsFalsy
    TypeFactsEmptyStringFacts TypeFacts = TypeFactsBaseTypeFactsStringFacts
    TypeFactsNonEmptyStringStrictFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy
    TypeFactsNonEmptyStringFacts TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
    TypeFactsBaseNumberStrictFacts TypeFacts = TypeFactsTypeofEQNumber | TypeFactsTypeofNEString | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
    TypeFactsBaseNumberFacts TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsNumberStrictFacts TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy | TypeFactsFalsy
    TypeFactsNumberFacts TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
    TypeFactsZeroNumberStrictFacts TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsFalsy
    TypeFactsZeroNumberFacts TypeFacts = TypeFactsBaseTypeFactsNumberFacts
    TypeFactsNonZeroNumberStrictFacts TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy
    TypeFactsNonZeroNumberFacts TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
    TypeFactsBaseBigIntStrictFacts TypeFacts = TypeFactsTypeofEQBigInt | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
    TypeFactsBaseBigIntFacts TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsBigIntStrictFacts TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy | TypeFactsFalsy
    TypeFactsBigIntFacts TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
    TypeFactsZeroBigIntStrictFacts TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsFalsy
    TypeFactsZeroBigIntFacts TypeFacts = TypeFactsBaseTypeFactsBigIntFacts
    TypeFactsNonZeroBigIntStrictFacts TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy
    TypeFactsNonZeroBigIntFacts TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
    TypeFactsBaseBooleanStrictFacts TypeFacts = TypeFactsTypeofEQBoolean | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
    TypeFactsBaseBooleanFacts TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsBooleanStrictFacts TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy | TypeFactsFalsy
    TypeFactsBooleanFacts TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
    TypeFactsFalseStrictFacts TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsFalsy
    TypeFactsFalseFacts TypeFacts = TypeFactsBaseTypeFactsBooleanFacts
    TypeFactsTrueStrictFacts TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy
    TypeFactsTrueFacts TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
    TypeFactsSymbolStrictFacts TypeFacts = TypeFactsTypeofEQSymbol | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
    TypeFactsSymbolFacts TypeFacts = TypeFactsSymbolStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsObjectStrictFacts TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
    TypeFactsObjectFacts TypeFacts = TypeFactsObjectStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsFunctionStrictFacts TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
    TypeFactsFunctionFacts TypeFacts = TypeFactsFunctionStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsVoidFacts TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy
    TypeFactsUndefinedFacts TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy | TypeFactsIsUndefined
    TypeFactsNullFacts TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNEUndefined | TypeFactsFalsy | TypeFactsIsNull
    TypeFactsEmptyObjectStrictFacts TypeFacts = TypeFactsAll & ~(TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsTypeFactsIsUndefinedOrNull)
    TypeFactsEmptyObjectFacts TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
    TypeFactsUnknownFacts TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
    TypeFactsAllTypeofNE TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsNEUndefined
    TypeFactsOrFactsMask TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofNEObject
    TypeFactsAndFactsMask TypeFacts = TypeFactsAll & ~TypeFactsOrFactsMask
)
var typeofNEFacts ReadonlyMap[string, TypeFacts] = /* TODO(NewExpression): new Map(Object.entries({     string: TypeFacts.TypeofNEString,     number: TypeFacts.TypeofNENumber,     bigint: TypeFacts.TypeofNEBigInt,     boolean: TypeFacts.TypeofNEBoolean,     symbol: TypeFacts.TypeofNESymbol,     undefined: TypeFacts.NEUndefined,     object: TypeFacts.TypeofNEObject,     function: TypeFacts.TypeofNEFunction, })) */ TODO
type TypeSystemEntity /* TODO(UnionType): Node | Symbol | Type | Signature */ any
type TypeSystemPropertyName int32
const (
    TypeSystemPropertyNameType TypeSystemPropertyName = iota
    TypeSystemPropertyNameResolvedBaseConstructorType 
    TypeSystemPropertyNameDeclaredType 
    TypeSystemPropertyNameResolvedReturnType 
    TypeSystemPropertyNameImmediateBaseConstraint 
    TypeSystemPropertyNameResolvedTypeArguments 
    TypeSystemPropertyNameResolvedBaseTypes 
    TypeSystemPropertyNameWriteType 
    TypeSystemPropertyNameParameterInitializerContainsUndefined 
)
type CheckMode int32
const (
    CheckModeNormal CheckMode = 0
    CheckModeContextual CheckMode = 1 << 0
    CheckModeInferential CheckMode = 1 << 1
    CheckModeSkipContextSensitive CheckMode = 1 << 2
    CheckModeSkipGenericFunctions CheckMode = 1 << 3
    CheckModeIsForSignatureHelp CheckMode = 1 << 4
    CheckModeRestBindingElement CheckMode = 1 << 5
    CheckModeTypeOnly CheckMode = 1 << 6
)
type SignatureCheckMode int32
const (
    SignatureCheckModeNone SignatureCheckMode = 0
    SignatureCheckModeBivariantCallback SignatureCheckMode = 1 << 0
    SignatureCheckModeStrictCallback SignatureCheckMode = 1 << 1
    SignatureCheckModeIgnoreReturnTypes SignatureCheckMode = 1 << 2
    SignatureCheckModeStrictArity SignatureCheckMode = 1 << 3
    SignatureCheckModeStrictTopSignature SignatureCheckMode = 1 << 4
    SignatureCheckModeCallback SignatureCheckMode = SignatureCheckModeBivariantSignatureCheckModeCallback | SignatureCheckModeStrictSignatureCheckModeCallback
)
type IntersectionState int32
const (
    IntersectionStateNone IntersectionState = 0
    IntersectionStateSource IntersectionState = 1 << 0
    IntersectionStateTarget IntersectionState = 1 << 1
)
type RecursionFlags int32
const (
    RecursionFlagsNone RecursionFlags = 0
    RecursionFlagsSource RecursionFlags = 1 << 0
    RecursionFlagsTarget RecursionFlags = 1 << 1
    RecursionFlagsBoth RecursionFlags = RecursionFlagsSource | RecursionFlagsTarget
)
type MappedTypeModifiers int32
const (
    MappedTypeModifiersIncludeReadonly MappedTypeModifiers = 1 << 0
    MappedTypeModifiersExcludeReadonly MappedTypeModifiers = 1 << 1
    MappedTypeModifiersIncludeOptional MappedTypeModifiers = 1 << 2
    MappedTypeModifiersExcludeOptional MappedTypeModifiers = 1 << 3
)
type MappedTypeNameTypeKind int32
const (
    MappedTypeNameTypeKindNone MappedTypeNameTypeKind = iota
    MappedTypeNameTypeKindFiltering 
    MappedTypeNameTypeKindRemapping 
)
type ExpandingFlags int32
const (
    ExpandingFlagsNone ExpandingFlags = 0
    ExpandingFlagsSource ExpandingFlags = 1
    ExpandingFlagsTarget ExpandingFlags = 1 << 1
    ExpandingFlagsBoth ExpandingFlags = ExpandingFlagsSource | ExpandingFlagsTarget
)
type MembersOrExportsResolutionKind string
const (
    MembersOrExportsResolutionKindresolvedExports MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedExports"
    MembersOrExportsResolutionKindresolvedMembers MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedMembers"
)
type UnusedKind int32
const (
    UnusedKindLocal UnusedKind = iota
    UnusedKindParameter 
)
type AddUnusedDiagnostic func(containingNode Node, type_ UnusedKind, diagnostic DiagnosticWithLocation) 
var isNotOverloadAndNotAccessor = and(isNotOverload, isNotAccessor)
type DeclarationMeaning int32
const (
    DeclarationMeaningGetAccessor DeclarationMeaning = 1
    DeclarationMeaningSetAccessor DeclarationMeaning = 2
    DeclarationMeaningPropertyAssignment DeclarationMeaning = 4
    DeclarationMeaningMethod DeclarationMeaning = 8
    DeclarationMeaningPrivateStatic DeclarationMeaning = 16
    DeclarationMeaningGetOrSetAccessor DeclarationMeaning = DeclarationMeaningGetAccessor | DeclarationMeaningSetAccessor
    DeclarationMeaningPropertyAssignmentOrMethod DeclarationMeaning = DeclarationMeaningPropertyAssignment | DeclarationMeaningMethod
)
type DeclarationSpaces int32
const (
    DeclarationSpacesNone DeclarationSpaces = 0
    DeclarationSpacesExportValue DeclarationSpaces = 1 << 0
    DeclarationSpacesExportType DeclarationSpaces = 1 << 1
    DeclarationSpacesExportNamespace DeclarationSpaces = 1 << 2
)
type MinArgumentCountFlags int32
const (
    MinArgumentCountFlagsNone MinArgumentCountFlags = 0
    MinArgumentCountFlagsStrongArityForUntypedJS MinArgumentCountFlags = 1 << 0
    MinArgumentCountFlagsVoidIsNonOptional MinArgumentCountFlags = 1 << 1
)
type IntrinsicTypeKind int32
const (
    IntrinsicTypeKindUppercase IntrinsicTypeKind = iota
    IntrinsicTypeKindLowercase 
    IntrinsicTypeKindCapitalize 
    IntrinsicTypeKindUncapitalize 
    IntrinsicTypeKindNoInfer 
)
var intrinsicTypeKinds ReadonlyMap[string, IntrinsicTypeKind] = /* TODO(NewExpression): new Map(Object.entries({     Uppercase: IntrinsicTypeKind.Uppercase,     Lowercase: IntrinsicTypeKind.Lowercase,     Capitalize: IntrinsicTypeKind.Capitalize,     Uncapitalize: IntrinsicTypeKind.Uncapitalize,     NoInfer: IntrinsicTypeKind.NoInfer, })) */ TODO
var SymbolLinks = /* TODO(ClassExpression): class implements SymbolLinks {     declare _symbolLinksBrand: any; } */ TODO
func NodeLinks(this NodeLinks) {
    /* TODO(ExpressionStatement): this.flags = NodeCheckFlags.None; */
}
func getNodeId(node Node) number {
    if /* TODO(PrefixUnaryExpression): !node.id */ TODO {
        /* TODO(ExpressionStatement): node.id = nextNodeId; */
        /* TODO(ExpressionStatement): nextNodeId++; */
    }
     /* TODO(PropertyAccessExpression): node.id */ TODO
}
func getSymbolId(symbol Symbol) SymbolId {
    if /* TODO(PrefixUnaryExpression): !symbol.id */ TODO {
        /* TODO(ExpressionStatement): symbol.id = nextSymbolId; */
        /* TODO(ExpressionStatement): nextSymbolId++; */
    }
     /* TODO(PropertyAccessExpression): symbol.id */ TODO
}
func isInstantiatedModule(node ModuleDeclaration, preserveConstEnums bool) /* TODO(undefined): boolean */ TODO {
    moduleState := getModuleInstanceState(node)
     /* TODO(BinaryExpression): moduleState === ModuleInstanceState.Instantiated ||         (preserveConstEnums && moduleState === ModuleInstanceState.ConstEnumOnly) */ TODO
}
func createTypeChecker(host TypeCheckerHost) TypeChecker {
    var deferredDiagnosticsCallbacks []func()  = /* TODO(ArrayLiteralExpression): [] */ TODO
    addLazyDiagnostic := /* TODO(ArrowFunction): (arg: () => void) => {         deferredDiagnosticsCallbacks.push(arg);     } */ TODO
    var cancellationToken *CancellationToken
    var scanner *Scanner
    Symbol := /* TODO(PropertyAccessExpression): objectAllocator.getSymbolConstructor */ TODO()
    Type := /* TODO(PropertyAccessExpression): objectAllocator.getTypeConstructor */ TODO()
    Signature := /* TODO(PropertyAccessExpression): objectAllocator.getSignatureConstructor */ TODO()
    typeCount := 0
    symbolCount := 0
    totalInstantiationCount := 0
    instantiationCount := 0
    instantiationDepth := 0
    inlineLevel := 0
    var currentNode Node
    var varianceTypeParameter *TypeParameter
    isInferencePartiallyBlocked := /* TODO(FalseKeyword): false */ TODO
    emptySymbols := createSymbolTable()
    arrayVariances := /* TODO(ArrayLiteralExpression): [VarianceFlags.Covariant] */ TODO
    compilerOptions := /* TODO(PropertyAccessExpression): host.getCompilerOptions */ TODO()
    languageVersion := getEmitScriptTarget(compilerOptions)
    moduleKind := getEmitModuleKind(compilerOptions)
    legacyDecorators := /* TODO(PrefixUnaryExpression): !!compilerOptions.experimentalDecorators */ TODO
    useDefineForClassFields := getUseDefineForClassFields(compilerOptions)
    emitStandardClassFields := getEmitStandardClassFields(compilerOptions)
    allowSyntheticDefaultImports := getAllowSyntheticDefaultImports(compilerOptions)
    strictNullChecks := getStrictOptionValue(compilerOptions, "strictNullChecks")
    strictFunctionTypes := getStrictOptionValue(compilerOptions, "strictFunctionTypes")
    strictBindCallApply := getStrictOptionValue(compilerOptions, "strictBindCallApply")
    strictPropertyInitialization := getStrictOptionValue(compilerOptions, "strictPropertyInitialization")
    strictBuiltinIteratorReturn := getStrictOptionValue(compilerOptions, "strictBuiltinIteratorReturn")
    noImplicitAny := getStrictOptionValue(compilerOptions, "noImplicitAny")
    noImplicitThis := getStrictOptionValue(compilerOptions, "noImplicitThis")
    useUnknownInCatchVariables := getStrictOptionValue(compilerOptions, "useUnknownInCatchVariables")
    exactOptionalPropertyTypes := /* TODO(PropertyAccessExpression): compilerOptions.exactOptionalPropertyTypes */ TODO
    noUncheckedSideEffectImports := /* TODO(PrefixUnaryExpression): !!compilerOptions.noUncheckedSideEffectImports */ TODO
    checkBinaryExpression := createCheckBinaryExpression()
    emitResolver := createResolver()
    nodeBuilder := createNodeBuilder()
    syntacticNodeBuilder := createSyntacticTypeNodeBuilder(compilerOptions, /* TODO(ObjectLiteralExpression): {         isEntityNameVisible,         isExpandoFunctionDeclaration,         getAllAccessorDeclarations: getAllAccessorDeclarationsForDeclaration,         requiresAddingImplicitUndefined,         isUndefinedIdentifierExpression(node: Identifier) {             Debug.assert(isExpressionNode(node));             return getSymbolAtLocation(node) === undefinedSymbol;         },         isDefinitelyReferenceToGlobalSymbolObject,     } */ TODO)
    evaluate := createEvaluator(/* TODO(ObjectLiteralExpression): {         evaluateElementAccessExpression,         evaluateEntityNameExpression,     } */ TODO)
    globals := createSymbolTable()
    undefinedSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "undefined" /* as */ /* TODO(TypeReference): __String */)
    /* TODO(ExpressionStatement): undefinedSymbol.declarations = []; */
    globalThisSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Module */ TODO, "globalThis" /* as */ /* TODO(TypeReference): __String */, /* TODO(PropertyAccessExpression): CheckFlags.Readonly */ TODO)
    /* TODO(ExpressionStatement): globalThisSymbol.exports = globals; */
    /* TODO(ExpressionStatement): globalThisSymbol.declarations = []; */
    /* TODO(ExpressionStatement): globals.set(globalThisSymbol.escapedName, globalThisSymbol); */
    argumentsSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "arguments" /* as */ /* TODO(TypeReference): __String */)
    requireSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "require" /* as */ /* TODO(TypeReference): __String */)
    isolatedModulesLikeFlagName := /* TODO(ConditionalExpression): compilerOptions.verbatimModuleSyntax ? "verbatimModuleSyntax" : "isolatedModules" */ TODO
    canCollectSymbolAliasAccessabilityData := /* TODO(PrefixUnaryExpression): !compilerOptions.verbatimModuleSyntax */ TODO
    var apparentArgumentCount /* TODO(NumberKeyword): number */ any
    var lastGetCombinedNodeFlagsNode Node
    lastGetCombinedNodeFlagsResult := /* TODO(PropertyAccessExpression): NodeFlags.None */ TODO
    var lastGetCombinedModifierFlagsNode Declaration
    lastGetCombinedModifierFlagsResult := /* TODO(PropertyAccessExpression): ModifierFlags.None */ TODO
    resolveName := createNameResolver(/* TODO(ObjectLiteralExpression): {         compilerOptions,         requireSymbol,         argumentsSymbol,         globals,         getSymbolOfDeclaration,         error,         getRequiresScopeChangeCache,         setRequiresScopeChangeCache,         lookup: getSymbol,         onPropertyWithInvalidInitializer: checkAndReportErrorForInvalidInitializer,         onFailedToResolveSymbol,         onSuccessfullyResolvedSymbol,     } */ TODO)
    resolveNameForSymbolSuggestion := createNameResolver(/* TODO(ObjectLiteralExpression): {         compilerOptions,         requireSymbol,         argumentsSymbol,         globals,         getSymbolOfDeclaration,         error,         getRequiresScopeChangeCache,         setRequiresScopeChangeCache,         lookup: getSuggestionForSymbolNameLookup,     } */ TODO)
    var checker TypeChecker = /* TODO(ObjectLiteralExpression): {         getNodeCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.nodeCount, 0),         getIdentifierCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.identifierCount, 0),         getSymbolCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.symbolCount, symbolCount),         getTypeCount: () => typeCount,         getInstantiationCount: () => totalInstantiationCount,         getRelationCacheSizes: () => ({             assignable: assignableRelation.size,             identity: identityRelation.size,             subtype: subtypeRelation.size,             strictSubtype: strictSubtypeRelation.size,         }),         isUndefinedSymbol: symbol => symbol === undefinedSymbol,         isArgumentsSymbol: symbol => symbol === argumentsSymbol,         isUnknownSymbol: symbol => symbol === unknownSymbol,         getMergedSymbol,         symbolIsValue,         getDiagnostics,         getGlobalDiagnostics,         getRecursionIdentity,         getUnmatchedProperties,         getTypeOfSymbolAtLocation: (symbol, locationIn) => {             const location = getParseTreeNode(locationIn);             return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType;         },         getTypeOfSymbol,         getSymbolsOfParameterPropertyDeclaration: (parameterIn, parameterName) => {             const parameter = getParseTreeNode(parameterIn, isParameter);             if (parameter === undefined) return Debug.fail("Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.");             Debug.assert(isParameterPropertyDeclaration(parameter, parameter.parent));             return getSymbolsOfParameterPropertyDeclaration(parameter, escapeLeadingUnderscores(parameterName));         },         getDeclaredTypeOfSymbol,         getPropertiesOfType,         getPropertyOfType: (type, name) => getPropertyOfType(type, escapeLeadingUnderscores(name)),         getPrivateIdentifierPropertyOfType: (leftType: Type, name: string, location: Node) => {             const node = getParseTreeNode(location);             if (!node) {                 return undefined;             }             const propName = escapeLeadingUnderscores(name);             const lexicallyScopedIdentifier = lookupSymbolForPrivateIdentifierDeclaration(propName, node);             return lexicallyScopedIdentifier ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) : undefined;         },         getTypeOfPropertyOfType: (type, name) => getTypeOfPropertyOfType(type, escapeLeadingUnderscores(name)),         getIndexInfoOfType: (type, kind) => getIndexInfoOfType(type, kind === IndexKind.String ? stringType : numberType),         getIndexInfosOfType,         getIndexInfosOfIndexSymbol,         getSignaturesOfType,         getIndexTypeOfType: (type, kind) => getIndexTypeOfType(type, kind === IndexKind.String ? stringType : numberType),         getIndexType: type => getIndexType(type),         getBaseTypes,         getBaseTypeOfLiteralType,         getWidenedType,         getWidenedLiteralType,         getTypeFromTypeNode: nodeIn => {             const node = getParseTreeNode(nodeIn, isTypeNode);             return node ? getTypeFromTypeNode(node) : errorType;         },         getParameterType: getTypeAtPosition,         getParameterIdentifierInfoAtPosition,         getPromisedTypeOfPromise,         getAwaitedType: type => getAwaitedType(type),         getReturnTypeOfSignature,         isNullableType,         getNullableType,         getNonNullableType,         getNonOptionalType: removeOptionalTypeMarker,         getTypeArguments,         typeToTypeNode: nodeBuilder.typeToTypeNode,         typePredicateToTypePredicateNode: nodeBuilder.typePredicateToTypePredicateNode,         indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration,         signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration,         symbolToEntityName: nodeBuilder.symbolToEntityName,         symbolToExpression: nodeBuilder.symbolToExpression,         symbolToNode: nodeBuilder.symbolToNode,         symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations,         symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration,         typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration,         getSymbolsInScope: (locationIn, meaning) => {             const location = getParseTreeNode(locationIn);             return location ? getSymbolsInScope(location, meaning) : [];         },         getSymbolAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             // set ignoreErrors: true because any lookups invoked by the API shouldn't cause any new errors             return node ? getSymbolAtLocation(node, /*ignoreErrors* / true) : undefined;         },         getIndexInfosAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getIndexInfosAtLocation(node) : undefined;         },         getShorthandAssignmentValueSymbol: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getShorthandAssignmentValueSymbol(node) : undefined;         },         getExportSpecifierLocalTargetSymbol: nodeIn => {             const node = getParseTreeNode(nodeIn, isExportSpecifier);             return node ? getExportSpecifierLocalTargetSymbol(node) : undefined;         },         getExportSymbolOfSymbol(symbol) {             return getMergedSymbol(symbol.exportSymbol || symbol);         },         getTypeAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getTypeOfNode(node) : errorType;         },         getTypeOfAssignmentPattern: nodeIn => {             const node = getParseTreeNode(nodeIn, isAssignmentPattern);             return node && getTypeOfAssignmentPattern(node) || errorType;         },         getPropertySymbolOfDestructuringAssignment: locationIn => {             const location = getParseTreeNode(locationIn, isIdentifier);             return location ? getPropertySymbolOfDestructuringAssignment(location) : undefined;         },         signatureToString: (signature, enclosingDeclaration, flags, kind) => {             return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind);         },         typeToString: (type, enclosingDeclaration, flags) => {             return typeToString(type, getParseTreeNode(enclosingDeclaration), flags);         },         symbolToString: (symbol, enclosingDeclaration, meaning, flags) => {             return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags);         },         typePredicateToString: (predicate, enclosingDeclaration, flags) => {             return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags);         },         writeSignature: (signature, enclosingDeclaration, flags, kind, writer) => {             return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind, writer);         },         writeType: (type, enclosingDeclaration, flags, writer) => {             return typeToString(type, getParseTreeNode(enclosingDeclaration), flags, writer);         },         writeSymbol: (symbol, enclosingDeclaration, meaning, flags, writer) => {             return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags, writer);         },         writeTypePredicate: (predicate, enclosingDeclaration, flags, writer) => {             return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags, writer);         },         getAugmentedPropertiesOfType,         getRootSymbols,         getSymbolOfExpando,         getContextualType: (nodeIn: Expression, contextFlags?: ContextFlags) => {             const node = getParseTreeNode(nodeIn, isExpression);             if (!node) {                 return undefined;             }             if (contextFlags! & ContextFlags.Completions) {                 return runWithInferenceBlockedFromSourceNode(node, () => getContextualType(node, contextFlags));             }             return getContextualType(node, contextFlags);         },         getContextualTypeForObjectLiteralElement: nodeIn => {             const node = getParseTreeNode(nodeIn, isObjectLiteralElementLike);             return node ? getContextualTypeForObjectLiteralElement(node, /*contextFlags* / undefined) : undefined;         },         getContextualTypeForArgumentAtIndex: (nodeIn, argIndex) => {             const node = getParseTreeNode(nodeIn, isCallLikeExpression);             return node && getContextualTypeForArgumentAtIndex(node, argIndex);         },         getContextualTypeForJsxAttribute: nodeIn => {             const node = getParseTreeNode(nodeIn, isJsxAttributeLike);             return node && getContextualTypeForJsxAttribute(node, /*contextFlags* / undefined);         },         isContextSensitive,         getTypeOfPropertyOfContextualType,         getFullyQualifiedName,         getResolvedSignature: (node, candidatesOutArray, argumentCount) => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.Normal),         getCandidateSignaturesForStringLiteralCompletions,         getResolvedSignatureForSignatureHelp: (node, candidatesOutArray, argumentCount) => runWithoutResolvedSignatureCaching(node, () => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.IsForSignatureHelp)),         getExpandedParameters,         hasEffectiveRestParameter,         containsArgumentsReference,         getConstantValue: nodeIn => {             const node = getParseTreeNode(nodeIn, canHaveConstantValue);             return node ? getConstantValue(node) : undefined;         },         isValidPropertyAccess: (nodeIn, propertyName) => {             const node = getParseTreeNode(nodeIn, isPropertyAccessOrQualifiedNameOrImportTypeNode);             return !!node && isValidPropertyAccess(node, escapeLeadingUnderscores(propertyName));         },         isValidPropertyAccessForCompletions: (nodeIn, type, property) => {             const node = getParseTreeNode(nodeIn, isPropertyAccessExpression);             return !!node && isValidPropertyAccessForCompletions(node, type, property);         },         getSignatureFromDeclaration: declarationIn => {             const declaration = getParseTreeNode(declarationIn, isFunctionLike);             return declaration ? getSignatureFromDeclaration(declaration) : undefined;         },         isImplementationOfOverload: nodeIn => {             const node = getParseTreeNode(nodeIn, isFunctionLike);             return node ? isImplementationOfOverload(node) : undefined;         },         getImmediateAliasedSymbol,         getAliasedSymbol: resolveAlias,         getEmitResolver,         requiresAddingImplicitUndefined,         getExportsOfModule: getExportsOfModuleAsArray,         getExportsAndPropertiesOfModule,         forEachExportAndPropertyOfModule,         getSymbolWalker: createGetSymbolWalker(             getRestTypeOfSignature,             getTypePredicateOfSignature,             getReturnTypeOfSignature,             getBaseTypes,             resolveStructuredTypeMembers,             getTypeOfSymbol,             getResolvedSymbol,             getConstraintOfTypeParameter,             getFirstIdentifier,             getTypeArguments,         ),         getAmbientModules,         getJsxIntrinsicTagNamesAt,         isOptionalParameter: nodeIn => {             const node = getParseTreeNode(nodeIn, isParameter);             return node ? isOptionalParameter(node) : false;         },         tryGetMemberInModuleExports: (name, symbol) => tryGetMemberInModuleExports(escapeLeadingUnderscores(name), symbol),         tryGetMemberInModuleExportsAndProperties: (name, symbol) => tryGetMemberInModuleExportsAndProperties(escapeLeadingUnderscores(name), symbol),         tryFindAmbientModule: moduleName => tryFindAmbientModule(moduleName, /*withAugmentations* / true),         getApparentType,         getUnionType,         isTypeAssignableTo,         createAnonymousType,         createSignature,         createSymbol,         createIndexInfo,         getAnyType: () => anyType,         getStringType: () => stringType,         getStringLiteralType,         getNumberType: () => numberType,         getNumberLiteralType,         getBigIntType: () => bigintType,         getBigIntLiteralType,         createPromiseType,         createArrayType,         getElementTypeOfArrayType,         getBooleanType: () => booleanType,         getFalseType: (fresh?) => fresh ? falseType : regularFalseType,         getTrueType: (fresh?) => fresh ? trueType : regularTrueType,         getVoidType: () => voidType,         getUndefinedType: () => undefinedType,         getNullType: () => nullType,         getESSymbolType: () => esSymbolType,         getNeverType: () => neverType,         getOptionalType: () => optionalType,         getPromiseType: () => getGlobalPromiseType(/*reportErrors* / false),         getPromiseLikeType: () => getGlobalPromiseLikeType(/*reportErrors* / false),         getAnyAsyncIterableType: () => {             const type = getGlobalAsyncIterableType(/*reportErrors* / false);             if (type === emptyGenericType) return undefined;             return createTypeReference(type, [anyType, anyType, anyType]);         },         isSymbolAccessible,         isArrayType,         isTupleType,         isArrayLikeType,         isEmptyAnonymousObjectType,         isTypeInvalidDueToUnionDiscriminant,         getExactOptionalProperties,         getAllPossiblePropertiesOfTypes,         getSuggestedSymbolForNonexistentProperty,         getSuggestedSymbolForNonexistentJSXAttribute,         getSuggestedSymbolForNonexistentSymbol: (location, name, meaning) => getSuggestedSymbolForNonexistentSymbol(location, escapeLeadingUnderscores(name), meaning),         getSuggestedSymbolForNonexistentModule,         getSuggestedSymbolForNonexistentClassMember,         getBaseConstraintOfType,         getDefaultFromTypeParameter: type => type && type.flags & TypeFlags.TypeParameter ? getDefaultFromTypeParameter(type as TypeParameter) : undefined,         resolveName(name, location, meaning, excludeGlobals) {             return resolveName(location, escapeLeadingUnderscores(name), meaning, /*nameNotFoundMessage* / undefined, /*isUse* / false, excludeGlobals);         },         getJsxNamespace: n => unescapeLeadingUnderscores(getJsxNamespace(n)),         getJsxFragmentFactory: n => {             const jsxFragmentFactory = getJsxFragmentFactoryEntity(n);             return jsxFragmentFactory && unescapeLeadingUnderscores(getFirstIdentifier(jsxFragmentFactory).escapedText);         },         getAccessibleSymbolChain,         getTypePredicateOfSignature,         resolveExternalModuleName: moduleSpecifierIn => {             const moduleSpecifier = getParseTreeNode(moduleSpecifierIn, isExpression);             return moduleSpecifier && resolveExternalModuleName(moduleSpecifier, moduleSpecifier, /*ignoreErrors* / true);         },         resolveExternalModuleSymbol,         tryGetThisTypeAt: (nodeIn, includeGlobalThis, container) => {             const node = getParseTreeNode(nodeIn);             return node && tryGetThisTypeAt(node, includeGlobalThis, container);         },         getTypeArgumentConstraint: nodeIn => {             const node = getParseTreeNode(nodeIn, isTypeNode);             return node && getTypeArgumentConstraint(node);         },         getSuggestionDiagnostics: (fileIn, ct) => {             const file = getParseTreeNode(fileIn, isSourceFile) || Debug.fail("Could not determine parsed source file.");             if (skipTypeChecking(file, compilerOptions, host)) {                 return emptyArray;             }              let diagnostics: DiagnosticWithLocation[] | undefined;             try {                 // Record the cancellation token so it can be checked later on during checkSourceElement.                 // Do this in a finally block so we can ensure that it gets reset back to nothing after                 // this call is done.                 cancellationToken = ct;                  // Ensure file is type checked, with _eager_ diagnostic production, so identifiers are registered as potentially unused                 checkSourceFileWithEagerDiagnostics(file);                 Debug.assert(!!(getNodeLinks(file).flags & NodeCheckFlags.TypeChecked));                  diagnostics = addRange(diagnostics, suggestionDiagnostics.getDiagnostics(file.fileName));                 checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), (containingNode, kind, diag) => {                     if (!containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) {                         (diagnostics || (diagnostics = [])).push({ ...diag, category: DiagnosticCategory.Suggestion });                     }                 });                  return diagnostics || emptyArray;             }             finally {                 cancellationToken = undefined;             }         },          runWithCancellationToken: (token, callback) => {             try {                 cancellationToken = token;                 return callback(checker);             }             finally {                 cancellationToken = undefined;             }         },          getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,         isDeclarationVisible,         isPropertyAccessible,         getTypeOnlyAliasDeclaration,         getMemberOverrideModifierStatus,         isTypeParameterPossiblyReferenced,         typeHasCallOrConstructSignatures,         getSymbolFlags,     } */ TODO
    getCandidateSignaturesForStringLiteralCompletions := func(call CallLikeExpression, editingArgument Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
        candidatesSet := /* TODO(NewExpression): new Set<Signature>() */ TODO
        var candidates []Signature = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ExpressionStatement): runWithInferenceBlockedFromSourceNode(editingArgument, () => getResolvedSignatureWorker(call, candidates, /*argumentCount* / undefined, CheckMode.Normal)); */
        /* TODO(ForOfStatement): for (const candidate of candidates) {             candidatesSet.add(candidate);         } */
        /* TODO(ExpressionStatement): candidates.length = 0; */
        /* TODO(ExpressionStatement): runWithoutResolvedSignatureCaching(editingArgument, () => getResolvedSignatureWorker(call, candidates, /*argumentCount* / undefined, CheckMode.Normal)); */
        /* TODO(ForOfStatement): for (const candidate of candidates) {             candidatesSet.add(candidate);         } */
         arrayFrom(candidatesSet)
    }
    runWithoutResolvedSignatureCaching := func(node Node, fn func() T) T {
        /* TODO(ExpressionStatement): node = findAncestor(node, isCallLikeOrFunctionLikeExpression); */
        if node {
            cachedResolvedSignatures := /* TODO(ArrayLiteralExpression): [] */ TODO
            cachedTypes := /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(WhileStatement): while (node) {                 const nodeLinks = getNodeLinks(node);                 cachedResolvedSignatures.push([nodeLinks, nodeLinks.resolvedSignature] as const);                 nodeLinks.resolvedSignature = undefined;                 if (isFunctionExpressionOrArrowFunction(node)) {                     const symbolLinks = getSymbolLinks(getSymbolOfDeclaration(node));                     const type = symbolLinks.type;                     cachedTypes.push([symbolLinks, type] as const);                     symbolLinks.type = undefined;                 }                 node = findAncestor(node.parent, isCallLikeOrFunctionLikeExpression);             } */
            result := fn()
            /* TODO(ForOfStatement): for (const [nodeLinks, resolvedSignature] of cachedResolvedSignatures) {                 nodeLinks.resolvedSignature = resolvedSignature;             } */
            /* TODO(ForOfStatement): for (const [symbolLinks, type] of cachedTypes) {                 symbolLinks.type = type;             } */
             result
        }
         fn()
    }
    runWithInferenceBlockedFromSourceNode := func(node Node, fn func() T) T {
        containingCall := findAncestor(node, isCallLikeExpression)
        if containingCall {
            toMarkSkip := /* TODO(NonNullExpression): node! */ TODO
            /* TODO(DoStatement): do {                 getNodeLinks(toMarkSkip).skipDirectInference = true;                 toMarkSkip = toMarkSkip.parent;             }             while (toMarkSkip && toMarkSkip !== containingCall); */
        }
        /* TODO(ExpressionStatement): isInferencePartiallyBlocked = true; */
        result := runWithoutResolvedSignatureCaching(node, fn)
        /* TODO(ExpressionStatement): isInferencePartiallyBlocked = false; */
        if containingCall {
            toMarkSkip := /* TODO(NonNullExpression): node! */ TODO
            /* TODO(DoStatement): do {                 getNodeLinks(toMarkSkip).skipDirectInference = undefined;                 toMarkSkip = toMarkSkip.parent;             }             while (toMarkSkip && toMarkSkip !== containingCall); */
        }
         result
    }
    getResolvedSignatureWorker := func(nodeIn CallLikeExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, argumentCount /* TODO(NumberKeyword): number */ any, checkMode CheckMode) *Signature {
        node := getParseTreeNode(nodeIn, isCallLikeExpression)
        /* TODO(ExpressionStatement): apparentArgumentCount = argumentCount; */
        res := /* TODO(ConditionalExpression): !node ? undefined : getResolvedSignature(node, candidatesOutArray, checkMode) */ TODO
        /* TODO(ExpressionStatement): apparentArgumentCount = undefined; */
         res
    }
    tupleTypes := /* TODO(NewExpression): new Map<string, GenericType>() */ TODO
    unionTypes := /* TODO(NewExpression): new Map<string, UnionType>() */ TODO
    unionOfUnionTypes := /* TODO(NewExpression): new Map<string, Type>() */ TODO
    intersectionTypes := /* TODO(NewExpression): new Map<string, Type>() */ TODO
    stringLiteralTypes := /* TODO(NewExpression): new Map<string, StringLiteralType>() */ TODO
    numberLiteralTypes := /* TODO(NewExpression): new Map<number, NumberLiteralType>() */ TODO
    bigIntLiteralTypes := /* TODO(NewExpression): new Map<string, BigIntLiteralType>() */ TODO
    enumLiteralTypes := /* TODO(NewExpression): new Map<string, LiteralType>() */ TODO
    indexedAccessTypes := /* TODO(NewExpression): new Map<string, IndexedAccessType>() */ TODO
    templateLiteralTypes := /* TODO(NewExpression): new Map<string, TemplateLiteralType>() */ TODO
    stringMappingTypes := /* TODO(NewExpression): new Map<string, StringMappingType>() */ TODO
    substitutionTypes := /* TODO(NewExpression): new Map<string, SubstitutionType>() */ TODO
    subtypeReductionCache := /* TODO(NewExpression): new Map<string, Type[]>() */ TODO
    decoratorContextOverrideTypeCache := /* TODO(NewExpression): new Map<string, Type>() */ TODO
    cachedTypes := /* TODO(NewExpression): new Map<string, Type>() */ TODO
    var evolvingArrayTypes []EvolvingArrayType = /* TODO(ArrayLiteralExpression): [] */ TODO
    var undefinedProperties SymbolTable = /* TODO(NewExpression): new Map() */ TODO
    markerTypes := /* TODO(NewExpression): new Set<number>() */ TODO
    unknownSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "unknown" /* as */ /* TODO(TypeReference): __String */)
    resolvingSymbol := createSymbol(0, /* TODO(PropertyAccessExpression): InternalSymbolName.Resolving */ TODO)
    unresolvedSymbols := /* TODO(NewExpression): new Map<string, TransientSymbol>() */ TODO
    errorTypes := /* TODO(NewExpression): new Map<string, Type>() */ TODO
    seenIntrinsicNames := /* TODO(NewExpression): new Set<string>() */ TODO
    anyType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "any")
    autoType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "any", /* TODO(PropertyAccessExpression): ObjectFlags.NonInferrableType */ TODO, "auto")
    wildcardType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "any", undefined, "wildcard")
    blockedStringType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "any", undefined, "blocked string")
    errorType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "error")
    unresolvedType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "unresolved")
    nonInferrableAnyType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "any", /* TODO(PropertyAccessExpression): ObjectFlags.ContainsWideningType */ TODO, "non-inferrable")
    intrinsicMarkerType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "intrinsic")
    unknownType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Unknown */ TODO, "unknown")
    undefinedType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Undefined */ TODO, "undefined")
    undefinedWideningType := /* TODO(ConditionalExpression): strictNullChecks ? undefinedType : createIntrinsicType(TypeFlags.Undefined, "undefined", ObjectFlags.ContainsWideningType, "widening") */ TODO
    missingType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Undefined */ TODO, "undefined", undefined, "missing")
    undefinedOrMissingType := /* TODO(ConditionalExpression): exactOptionalPropertyTypes ? missingType : undefinedType */ TODO
    optionalType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Undefined */ TODO, "undefined", undefined, "optional")
    nullType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Null */ TODO, "null")
    nullWideningType := /* TODO(ConditionalExpression): strictNullChecks ? nullType : createIntrinsicType(TypeFlags.Null, "null", ObjectFlags.ContainsWideningType, "widening") */ TODO
    stringType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.String */ TODO, "string")
    numberType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Number */ TODO, "number")
    bigintType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.BigInt */ TODO, "bigint")
    falseType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.BooleanLiteral */ TODO, "false", undefined, "fresh") /* as */ /* TODO(TypeReference): FreshableIntrinsicType */
    regularFalseType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.BooleanLiteral */ TODO, "false") /* as */ /* TODO(TypeReference): FreshableIntrinsicType */
    trueType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.BooleanLiteral */ TODO, "true", undefined, "fresh") /* as */ /* TODO(TypeReference): FreshableIntrinsicType */
    regularTrueType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.BooleanLiteral */ TODO, "true") /* as */ /* TODO(TypeReference): FreshableIntrinsicType */
    /* TODO(ExpressionStatement): trueType.regularType = regularTrueType; */
    /* TODO(ExpressionStatement): trueType.freshType = trueType; */
    /* TODO(ExpressionStatement): regularTrueType.regularType = regularTrueType; */
    /* TODO(ExpressionStatement): regularTrueType.freshType = trueType; */
    /* TODO(ExpressionStatement): falseType.regularType = regularFalseType; */
    /* TODO(ExpressionStatement): falseType.freshType = falseType; */
    /* TODO(ExpressionStatement): regularFalseType.regularType = regularFalseType; */
    /* TODO(ExpressionStatement): regularFalseType.freshType = falseType; */
    booleanType := getUnionType(/* TODO(ArrayLiteralExpression): [regularFalseType, regularTrueType] */ TODO)
    esSymbolType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.ESSymbol */ TODO, "symbol")
    voidType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Void */ TODO, "void")
    neverType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Never */ TODO, "never")
    silentNeverType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Never */ TODO, "never", /* TODO(PropertyAccessExpression): ObjectFlags.NonInferrableType */ TODO, "silent")
    implicitNeverType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Never */ TODO, "never", undefined, "implicit")
    unreachableNeverType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Never */ TODO, "never", undefined, "unreachable")
    nonPrimitiveType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.NonPrimitive */ TODO, "object")
    stringOrNumberType := getUnionType(/* TODO(ArrayLiteralExpression): [stringType, numberType] */ TODO)
    stringNumberSymbolType := getUnionType(/* TODO(ArrayLiteralExpression): [stringType, numberType, esSymbolType] */ TODO)
    numberOrBigIntType := getUnionType(/* TODO(ArrayLiteralExpression): [numberType, bigintType] */ TODO)
    templateConstraintType := getUnionType(/* TODO(ArrayLiteralExpression): [stringType, numberType, booleanType, bigintType, nullType, undefinedType] */ TODO) /* as */ /* TODO(TypeReference): UnionType */
    numericStringType := getTemplateLiteralType(/* TODO(ArrayLiteralExpression): ["", ""] */ TODO, /* TODO(ArrayLiteralExpression): [numberType] */ TODO)
    var restrictiveMapper TypeMapper = makeFunctionTypeMapper(/* TODO(ArrowFunction): t => t.flags & TypeFlags.TypeParameter ? getRestrictiveTypeParameter(t as TypeParameter) : t */ TODO, /* TODO(ArrowFunction): () => "(restrictive mapper)" */ TODO)
    var permissiveMapper TypeMapper = makeFunctionTypeMapper(/* TODO(ArrowFunction): t => t.flags & TypeFlags.TypeParameter ? wildcardType : t */ TODO, /* TODO(ArrowFunction): () => "(permissive mapper)" */ TODO)
    uniqueLiteralType := createIntrinsicType(/* TODO(PropertyAccessExpression): TypeFlags.Never */ TODO, "never", undefined, "unique literal")
    var uniqueLiteralMapper TypeMapper = makeFunctionTypeMapper(/* TODO(ArrowFunction): t => t.flags & TypeFlags.TypeParameter ? uniqueLiteralType : t */ TODO, /* TODO(ArrowFunction): () => "(unique literal mapper)" */ TODO)
    var outofbandVarianceMarkerHandler /* TODO(ParenthesizedType): ((onlyUnreliable: boolean) => void) */ any
    reportUnreliableMapper := makeFunctionTypeMapper(/* TODO(ArrowFunction): t => {         if (outofbandVarianceMarkerHandler && (t === markerSuperType || t === markerSubType || t === markerOtherType)) {             outofbandVarianceMarkerHandler(/*onlyUnreliable* / true);         }         return t;     } */ TODO, /* TODO(ArrowFunction): () => "(unmeasurable reporter)" */ TODO)
    reportUnmeasurableMapper := makeFunctionTypeMapper(/* TODO(ArrowFunction): t => {         if (outofbandVarianceMarkerHandler && (t === markerSuperType || t === markerSubType || t === markerOtherType)) {             outofbandVarianceMarkerHandler(/*onlyUnreliable* / false);         }         return t;     } */ TODO, /* TODO(ArrowFunction): () => "(unreliable reporter)" */ TODO)
    emptyObjectType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    emptyJsxObjectType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    /* TODO(ExpressionStatement): emptyJsxObjectType.objectFlags |= ObjectFlags.JsxAttributes; */
    emptyTypeLiteralSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.TypeLiteral */ TODO, /* TODO(PropertyAccessExpression): InternalSymbolName.Type */ TODO)
    /* TODO(ExpressionStatement): emptyTypeLiteralSymbol.members = createSymbolTable(); */
    emptyTypeLiteralType := createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, emptyArray, emptyArray, emptyArray)
    unknownEmptyObjectType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    unknownUnionType := /* TODO(ConditionalExpression): strictNullChecks ? getUnionType([undefinedType, nullType, unknownEmptyObjectType]) : unknownType */ TODO
    emptyGenericType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray) /* as */ /* TODO(TypeReference): ObjectType */ /* as */ /* TODO(TypeReference): GenericType */
    /* TODO(ExpressionStatement): emptyGenericType.instantiations = new Map<string, TypeReference>(); */
    anyFunctionType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    /* TODO(ExpressionStatement): anyFunctionType.objectFlags |= ObjectFlags.NonInferrableType; */
    noConstraintType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    circularConstraintType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    resolvingDefaultType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    markerSuperType := createTypeParameter()
    markerSubType := createTypeParameter()
    /* TODO(ExpressionStatement): markerSubType.constraint = markerSuperType; */
    markerOtherType := createTypeParameter()
    markerSuperTypeForCheck := createTypeParameter()
    markerSubTypeForCheck := createTypeParameter()
    /* TODO(ExpressionStatement): markerSubTypeForCheck.constraint = markerSuperTypeForCheck; */
    noTypePredicate := createTypePredicate(/* TODO(PropertyAccessExpression): TypePredicateKind.Identifier */ TODO, "<<unresolved>>", 0, anyType)
    anySignature := createSignature(undefined, undefined, undefined, emptyArray, anyType, undefined, 0, /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO)
    unknownSignature := createSignature(undefined, undefined, undefined, emptyArray, errorType, undefined, 0, /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO)
    resolvingSignature := createSignature(undefined, undefined, undefined, emptyArray, anyType, undefined, 0, /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO)
    silentNeverSignature := createSignature(undefined, undefined, undefined, emptyArray, silentNeverType, undefined, 0, /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO)
    enumNumberIndexInfo := createIndexInfo(numberType, stringType, /* TODO(TrueKeyword): true */ TODO)
    iterationTypesCache := /* TODO(NewExpression): new Map<string, IterationTypes>() */ TODO
    var noIterationTypes IterationTypes = /* TODO(ObjectLiteralExpression): {         get yieldType(): Type {             return Debug.fail("Not supported");         },         get returnType(): Type {             return Debug.fail("Not supported");         },         get nextType(): Type {             return Debug.fail("Not supported");         },     } */ TODO
    anyIterationTypes := createIterationTypes(anyType, anyType, anyType)
    var asyncIterationTypesResolver IterationTypesResolver = /* TODO(ObjectLiteralExpression): {         iterableCacheKey: "iterationTypesOfAsyncIterable",         iteratorCacheKey: "iterationTypesOfAsyncIterator",         iteratorSymbolName: "asyncIterator",         getGlobalIteratorType: getGlobalAsyncIteratorType,         getGlobalIterableType: getGlobalAsyncIterableType,         getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,         getGlobalIteratorObjectType: getGlobalAsyncIteratorObjectType,         getGlobalGeneratorType: getGlobalAsyncGeneratorType,         getGlobalBuiltinIteratorTypes: getGlobalBuiltinAsyncIteratorTypes,         resolveIterationType: (type, errorNode) => getAwaitedType(type, errorNode, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member),         mustHaveANextMethodDiagnostic: Diagnostics.An_async_iterator_must_have_a_next_method,         mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,         mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,     } */ TODO
    var syncIterationTypesResolver IterationTypesResolver = /* TODO(ObjectLiteralExpression): {         iterableCacheKey: "iterationTypesOfIterable",         iteratorCacheKey: "iterationTypesOfIterator",         iteratorSymbolName: "iterator",         getGlobalIteratorType,         getGlobalIterableType,         getGlobalIterableIteratorType,         getGlobalIteratorObjectType,         getGlobalGeneratorType,         getGlobalBuiltinIteratorTypes,         resolveIterationType: (type, _errorNode) => type,         mustHaveANextMethodDiagnostic: Diagnostics.An_iterator_must_have_a_next_method,         mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_iterator_must_be_a_method,         mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,     } */ TODO
    type DuplicateInfoForSymbol struct {
        firstFileLocations []Declaration
        secondFileLocations []Declaration
        isBlockScoped bool
    }
    type DuplicateInfoForFiles struct {
        firstFile SourceFile
        secondFile SourceFile
        conflictingSymbols Map[string, DuplicateInfoForSymbol]
    }
    var amalgamatedDuplicates *Map[string, DuplicateInfoForFiles]
    reverseMappedCache := /* TODO(NewExpression): new Map<string, Type | undefined>() */ TODO
    reverseHomomorphicMappedCache := /* TODO(NewExpression): new Map<string, Type | undefined>() */ TODO
    var ambientModulesCache /* TODO(ArrayType): Symbol[] */ any
    var patternAmbientModules []PatternAmbientModule
    var patternAmbientModuleAugmentations *Map[string, Symbol]
    var globalObjectType ObjectType
    var globalFunctionType ObjectType
    var globalCallableFunctionType ObjectType
    var globalNewableFunctionType ObjectType
    var globalArrayType GenericType
    var globalReadonlyArrayType GenericType
    var globalStringType ObjectType
    var globalNumberType ObjectType
    var globalBooleanType ObjectType
    var globalRegExpType ObjectType
    var globalThisType GenericType
    var anyArrayType Type
    var autoArrayType Type
    var anyReadonlyArrayType Type
    var deferredGlobalNonNullableTypeAlias Symbol
    var deferredGlobalESSymbolConstructorSymbol *Symbol
    var deferredGlobalESSymbolConstructorTypeSymbol *Symbol
    var deferredGlobalESSymbolType *ObjectType
    var deferredGlobalTypedPropertyDescriptorType GenericType
    var deferredGlobalPromiseType *GenericType
    var deferredGlobalPromiseLikeType *GenericType
    var deferredGlobalPromiseConstructorSymbol *Symbol
    var deferredGlobalPromiseConstructorLikeType *ObjectType
    var deferredGlobalIterableType *GenericType
    var deferredGlobalIteratorType *GenericType
    var deferredGlobalIterableIteratorType *GenericType
    var deferredGlobalIteratorObjectType *GenericType
    var deferredGlobalGeneratorType *GenericType
    var deferredGlobalIteratorYieldResultType *GenericType
    var deferredGlobalIteratorReturnResultType *GenericType
    var deferredGlobalAsyncIterableType *GenericType
    var deferredGlobalAsyncIteratorType *GenericType
    var deferredGlobalAsyncIterableIteratorType *GenericType
    var deferredGlobalBuiltinIteratorTypes /* TODO(TypeOperator): readonly GenericType[] */ any
    var deferredGlobalBuiltinAsyncIteratorTypes /* TODO(TypeOperator): readonly GenericType[] */ any
    var deferredGlobalAsyncIteratorObjectType *GenericType
    var deferredGlobalAsyncGeneratorType *GenericType
    var deferredGlobalTemplateStringsArrayType *ObjectType
    var deferredGlobalImportMetaType ObjectType
    var deferredGlobalImportMetaExpressionType ObjectType
    var deferredGlobalImportCallOptionsType *ObjectType
    var deferredGlobalImportAttributesType *ObjectType
    var deferredGlobalDisposableType *ObjectType
    var deferredGlobalAsyncDisposableType *ObjectType
    var deferredGlobalExtractSymbol *Symbol
    var deferredGlobalOmitSymbol *Symbol
    var deferredGlobalAwaitedSymbol *Symbol
    var deferredGlobalBigIntType *ObjectType
    var deferredGlobalNaNSymbol *Symbol
    var deferredGlobalRecordSymbol *Symbol
    var deferredGlobalClassDecoratorContextType *GenericType
    var deferredGlobalClassMethodDecoratorContextType *GenericType
    var deferredGlobalClassGetterDecoratorContextType *GenericType
    var deferredGlobalClassSetterDecoratorContextType *GenericType
    var deferredGlobalClassAccessorDecoratorContextType *GenericType
    var deferredGlobalClassAccessorDecoratorTargetType *GenericType
    var deferredGlobalClassAccessorDecoratorResultType *GenericType
    var deferredGlobalClassFieldDecoratorContextType *GenericType
    allPotentiallyUnusedIdentifiers := /* TODO(NewExpression): new Map<Path, PotentiallyUnusedIdentifier[]>() */ TODO
    flowLoopStart := 0
    flowLoopCount := 0
    sharedFlowCount := 0
    flowAnalysisDisabled := /* TODO(FalseKeyword): false */ TODO
    flowInvocationCount := 0
    var lastFlowNode *FlowNode
    var lastFlowNodeReachable bool
    var flowTypeCache /* TODO(ArrayType): Type[] */ any
    var contextualTypeNodes []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
    var contextualTypes []*Type = /* TODO(ArrayLiteralExpression): [] */ TODO
    var contextualIsCache []bool = /* TODO(ArrayLiteralExpression): [] */ TODO
    contextualTypeCount := 0
    var contextualBindingPatterns []BindingPattern = /* TODO(ArrayLiteralExpression): [] */ TODO
    var inferenceContextNodes []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
    var inferenceContexts []*InferenceContext = /* TODO(ArrayLiteralExpression): [] */ TODO
    inferenceContextCount := 0
    emptyStringType := getStringLiteralType("")
    zeroType := getNumberLiteralType(0)
    zeroBigIntType := getBigIntLiteralType(/* TODO(ObjectLiteralExpression): { negative: false, base10Value: "0" } */ TODO)
    var resolutionTargets []TypeSystemEntity = /* TODO(ArrayLiteralExpression): [] */ TODO
    var resolutionResults []bool = /* TODO(ArrayLiteralExpression): [] */ TODO
    var resolutionPropertyNames []TypeSystemPropertyName = /* TODO(ArrayLiteralExpression): [] */ TODO
    resolutionStart := 0
    inVarianceComputation := /* TODO(FalseKeyword): false */ TODO
    suggestionCount := 0
    maximumSuggestionCount := 10
    var mergedSymbols []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
    var symbolLinks []SymbolLinks = /* TODO(ArrayLiteralExpression): [] */ TODO
    var nodeLinks []NodeLinks = /* TODO(ArrayLiteralExpression): [] */ TODO
    var flowLoopCaches []Map[string, Type] = /* TODO(ArrayLiteralExpression): [] */ TODO
    var flowLoopNodes []FlowNode = /* TODO(ArrayLiteralExpression): [] */ TODO
    var flowLoopKeys []string = /* TODO(ArrayLiteralExpression): [] */ TODO
    var flowLoopTypes [][]Type = /* TODO(ArrayLiteralExpression): [] */ TODO
    var sharedFlowNodes []FlowNode = /* TODO(ArrayLiteralExpression): [] */ TODO
    var sharedFlowTypes []FlowType = /* TODO(ArrayLiteralExpression): [] */ TODO
    var flowNodeReachable []/* TODO(BooleanKeyword): boolean */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
    var flowNodePostSuper []/* TODO(BooleanKeyword): boolean */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
    var potentialThisCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
    var potentialNewTargetCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
    var potentialWeakMapSetCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
    var potentialReflectCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
    var potentialUnusedRenamedBindingElementsInTypes []BindingElement = /* TODO(ArrayLiteralExpression): [] */ TODO
    var awaitedTypeStack []number = /* TODO(ArrayLiteralExpression): [] */ TODO
    var reverseMappedSourceStack []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
    var reverseMappedTargetStack []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
    reverseExpandingFlags := /* TODO(PropertyAccessExpression): ExpandingFlags.None */ TODO
    diagnostics := createDiagnosticCollection()
    suggestionDiagnostics := createDiagnosticCollection()
    typeofType := createTypeofType()
    var _jsxNamespace __String
    var _jsxFactoryEntity *EntityName
    subtypeRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
    strictSubtypeRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
    assignableRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
    comparableRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
    identityRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
    enumRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
    var suggestedExtensions []/* TODO(TupleType): [string, string] */ TODO = /* TODO(ArrayLiteralExpression): [         [".mts", ".mjs"],         [".ts", ".js"],         [".cts", ".cjs"],         [".mjs", ".mjs"],         [".js", ".js"],         [".cjs", ".cjs"],         [".tsx", compilerOptions.jsx === JsxEmit.Preserve ? ".jsx" : ".js"],         [".jsx", ".jsx"],         [".json", ".json"],     ] */ TODO
    /* TODO(ExpressionStatement): initializeTypeChecker(); */
     checker
    isDefinitelyReferenceToGlobalSymbolObject := func(node Node) bool {
        if /* TODO(PrefixUnaryExpression): !isPropertyAccessExpression(node) */ TODO {
            /* TODO(FalseKeyword): false */
        }
        if /* TODO(PrefixUnaryExpression): !isIdentifier(node.name) */ TODO {
            /* TODO(FalseKeyword): false */
        }
        if /* TODO(BinaryExpression): !isPropertyAccessExpression(node.expression) && !isIdentifier(node.expression) */ TODO {
            /* TODO(FalseKeyword): false */
        }
        if isIdentifier(/* TODO(PropertyAccessExpression): node.expression */ TODO) {
             /* TODO(BinaryExpression): idText(node.expression) === "Symbol" && getResolvedSymbol(node.expression) === (getGlobalSymbol("Symbol" as __String, SymbolFlags.Value | SymbolFlags.ExportValue, /*diagnostic* / undefined) || unknownSymbol) */ TODO
        }
        if /* TODO(PrefixUnaryExpression): !isIdentifier(node.expression.expression) */ TODO {
            /* TODO(FalseKeyword): false */
        }
         /* TODO(BinaryExpression): idText(node.expression.name) === "Symbol" && idText(node.expression.expression) === "globalThis" && getResolvedSymbol(node.expression.expression) === globalThisSymbol */ TODO
    }
    getCachedType := func(key /* TODO(StringKeyword): string */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
         /* TODO(ConditionalExpression): key ? cachedTypes.get(key) : undefined */ TODO
    }
    setCachedType := func(key /* TODO(StringKeyword): string */ any, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if key {
            /* TODO(CallExpression): cachedTypes.set(key, type) */
        }
         type_
    }
    getJsxNamespace := func(location Node) __String {
        if location {
            file := getSourceFileOfNode(location)
            if file {
                if isJsxOpeningFragment(location) {
                    if /* TODO(PropertyAccessExpression): file.localJsxFragmentNamespace */ TODO {
                         /* TODO(PropertyAccessExpression): file.localJsxFragmentNamespace */ TODO
                    }
                    jsxFragmentPragma := /* TODO(PropertyAccessExpression): file.pragmas.get */ TODO("jsxfrag")
                    if jsxFragmentPragma {
                        chosenPragma := /* TODO(ConditionalExpression): isArray(jsxFragmentPragma) ? jsxFragmentPragma[0] : jsxFragmentPragma */ TODO
                        /* TODO(ExpressionStatement): file.localJsxFragmentFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion); */
                        /* TODO(ExpressionStatement): visitNode(file.localJsxFragmentFactory, markAsSynthetic, isEntityName); */
                        if /* TODO(PropertyAccessExpression): file.localJsxFragmentFactory */ TODO {
                             /* TODO(BinaryExpression): file.localJsxFragmentNamespace = getFirstIdentifier(file.localJsxFragmentFactory).escapedText */ TODO
                        }
                    }
                    entity := getJsxFragmentFactoryEntity(location)
                    if entity {
                        /* TODO(ExpressionStatement): file.localJsxFragmentFactory = entity; */
                         /* TODO(BinaryExpression): file.localJsxFragmentNamespace = getFirstIdentifier(entity).escapedText */ TODO
                    }
                } else {
                    localJsxNamespace := getLocalJsxNamespace(file)
                    if localJsxNamespace {
                         /* TODO(BinaryExpression): file.localJsxNamespace = localJsxNamespace */ TODO
                    }
                }
            }
        }
        if /* TODO(PrefixUnaryExpression): !_jsxNamespace */ TODO {
            /* TODO(ExpressionStatement): _jsxNamespace = "React" as __String; */
            if /* TODO(PropertyAccessExpression): compilerOptions.jsxFactory */ TODO {
                /* TODO(ExpressionStatement): _jsxFactoryEntity = parseIsolatedEntityName(compilerOptions.jsxFactory, languageVersion); */
                /* TODO(ExpressionStatement): visitNode(_jsxFactoryEntity, markAsSynthetic); */
                if _jsxFactoryEntity {
                    /* TODO(ExpressionStatement): _jsxNamespace = getFirstIdentifier(_jsxFactoryEntity).escapedText; */
                }
            } else if /* TODO(PropertyAccessExpression): compilerOptions.reactNamespace */ TODO {
                /* TODO(ExpressionStatement): _jsxNamespace = escapeLeadingUnderscores(compilerOptions.reactNamespace); */
            }
        }
        if /* TODO(PrefixUnaryExpression): !_jsxFactoryEntity */ TODO {
            /* TODO(ExpressionStatement): _jsxFactoryEntity = factory.createQualifiedName(factory.createIdentifier(unescapeLeadingUnderscores(_jsxNamespace)), "createElement"); */
        }
         _jsxNamespace
    }
    getLocalJsxNamespace := func(file SourceFile) *__String {
        if /* TODO(PropertyAccessExpression): file.localJsxNamespace */ TODO {
             /* TODO(PropertyAccessExpression): file.localJsxNamespace */ TODO
        }
        jsxPragma := /* TODO(PropertyAccessExpression): file.pragmas.get */ TODO("jsx")
        if jsxPragma {
            chosenPragma := /* TODO(ConditionalExpression): isArray(jsxPragma) ? jsxPragma[0] : jsxPragma */ TODO
            /* TODO(ExpressionStatement): file.localJsxFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion); */
            /* TODO(ExpressionStatement): visitNode(file.localJsxFactory, markAsSynthetic, isEntityName); */
            if /* TODO(PropertyAccessExpression): file.localJsxFactory */ TODO {
                 /* TODO(BinaryExpression): file.localJsxNamespace = getFirstIdentifier(file.localJsxFactory).escapedText */ TODO
            }
        }
    }
    markAsSynthetic := func(node T) VisitResult[T] {
        /* TODO(ExpressionStatement): setTextRangePosEnd(node, -1, -1); */
         visitEachChildWorker(node, markAsSynthetic, undefined)
    }
    getEmitResolver := func(sourceFile SourceFile, cancellationToken CancellationToken, skipDiagnostics bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EmitResolver */ TODO {
        if /* TODO(PrefixUnaryExpression): !skipDiagnostics */ TODO {
            /* TODO(CallExpression): getDiagnostics(sourceFile, cancellationToken) */
        }
         emitResolver
    }
    lookupOrIssueError := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
        diagnostic := /* TODO(ConditionalExpression): location             ? createDiagnosticForNode(location, message, ...args)             : createCompilerDiagnostic(message, ...args) */ TODO
        existing := /* TODO(PropertyAccessExpression): diagnostics.lookup */ TODO(diagnostic)
        if existing {
             existing
        } else {
            /* TODO(ExpressionStatement): diagnostics.add(diagnostic); */
             diagnostic
        }
    }
    errorSkippedOn := func(key CompilerOptions, location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
        diagnostic := error(location, message, /* TODO(SpreadElement): ...args */ TODO)
        /* TODO(ExpressionStatement): diagnostic.skippedOn = key; */
         diagnostic
    }
    createError := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
         /* TODO(ConditionalExpression): location             ? createDiagnosticForNode(location, message, ...args)             : createCompilerDiagnostic(message, ...args) */ TODO
    }
    error := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
        diagnostic := createError(location, message, /* TODO(SpreadElement): ...args */ TODO)
        /* TODO(ExpressionStatement): diagnostics.add(diagnostic); */
         diagnostic
    }
    addErrorOrSuggestion := func(isError bool, diagnostic Diagnostic) {
        if isError {
            /* TODO(ExpressionStatement): diagnostics.add(diagnostic); */
        } else {
            /* TODO(ExpressionStatement): suggestionDiagnostics.add({ ...diagnostic, category: DiagnosticCategory.Suggestion }); */
        }
    }
    errorOrSuggestion := func(isError bool, location Node, message /* TODO(UnionType): DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) {
        if /* TODO(BinaryExpression): location.pos < 0 || location.end < 0 */ TODO {
            if /* TODO(PrefixUnaryExpression): !isError */ TODO {

            }
            file := getSourceFileOfNode(location)
            /* TODO(ExpressionStatement): addErrorOrSuggestion(isError, "message" in message ? createFileDiagnostic(file, 0, 0, message, ...args) : createDiagnosticForFileFromMessageChain(file, message)); */

        }
        /* TODO(ExpressionStatement): addErrorOrSuggestion(isError, "message" in message ? createDiagnosticForNode(location, message, ...args) : createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(location), location, message)); */
    }
    errorAndMaybeSuggestAwait := func(location Node, maybeMissingAwait bool, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
        diagnostic := error(location, message, /* TODO(SpreadElement): ...args */ TODO)
        if maybeMissingAwait {
            related := createDiagnosticForNode(location, /* TODO(PropertyAccessExpression): Diagnostics.Did_you_forget_to_use_await */ TODO)
            /* TODO(ExpressionStatement): addRelatedInfo(diagnostic, related); */
        }
         diagnostic
    }
    addDeprecatedSuggestionWorker := func(declarations /* TODO(UnionType): Node | Node[] */ any, diagnostic DiagnosticWithLocation) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
        deprecatedTag := /* TODO(ConditionalExpression): Array.isArray(declarations) ? forEach(declarations, getJSDocDeprecatedTag) : getJSDocDeprecatedTag(declarations) */ TODO
        if deprecatedTag {
            /* TODO(ExpressionStatement): addRelatedInfo(                 diagnostic,                 createDiagnosticForNode(deprecatedTag, Diagnostics.The_declaration_was_marked_as_deprecated_here),             ); */
        }
        /* TODO(ExpressionStatement): suggestionDiagnostics.add(diagnostic); */
         diagnostic
    }
    isDeprecatedSymbol := func(symbol Symbol) /* TODO(undefined): boolean | 0 */ TODO {
        parentSymbol := getParentOfSymbol(symbol)
        if /* TODO(BinaryExpression): parentSymbol && length(symbol.declarations) > 1 */ TODO {
             /* TODO(ConditionalExpression): parentSymbol.flags & SymbolFlags.Interface ? some(symbol.declarations, isDeprecatedDeclaration) : every(symbol.declarations, isDeprecatedDeclaration) */ TODO
        }
         /* TODO(BinaryExpression): !!symbol.valueDeclaration && isDeprecatedDeclaration(symbol.valueDeclaration)             || length(symbol.declarations) && every(symbol.declarations, isDeprecatedDeclaration) */ TODO
    }
    isDeprecatedDeclaration := func(declaration Declaration) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(getCombinedNodeFlagsCached(declaration) & NodeFlags.Deprecated) */ TODO
    }
    addDeprecatedSuggestion := func(location Node, declarations []Node, deprecatedEntity string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
        diagnostic := createDiagnosticForNode(location, /* TODO(PropertyAccessExpression): Diagnostics._0_is_deprecated */ TODO, deprecatedEntity)
         addDeprecatedSuggestionWorker(declarations, diagnostic)
    }
    addDeprecatedSuggestionWithSignature := func(location Node, declaration Node, deprecatedEntity /* TODO(StringKeyword): string */ any, signatureString string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
        diagnostic := /* TODO(ConditionalExpression): deprecatedEntity             ? createDiagnosticForNode(location, Diagnostics.The_signature_0_of_1_is_deprecated, signatureString, deprecatedEntity)             : createDiagnosticForNode(location, Diagnostics._0_is_deprecated, signatureString) */ TODO
         addDeprecatedSuggestionWorker(declaration, diagnostic)
    }
    createSymbol := func(flags SymbolFlags, name __String, checkFlags CheckFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
        /* TODO(ExpressionStatement): symbolCount++; */
        symbol := /* TODO(NewExpression): new Symbol(flags | SymbolFlags.Transient, name) */ TODO /* as */ /* TODO(TypeReference): TransientSymbol */
        /* TODO(ExpressionStatement): symbol.links = new SymbolLinks() as TransientSymbolLinks; */
        /* TODO(ExpressionStatement): symbol.links.checkFlags = checkFlags || CheckFlags.None; */
         symbol
    }
    createParameter := func(name __String, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
        symbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.FunctionScopedVariable */ TODO, name)
        /* TODO(ExpressionStatement): symbol.links.type = type; */
         symbol
    }
    createProperty := func(name __String, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
        symbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, name)
        /* TODO(ExpressionStatement): symbol.links.type = type; */
         symbol
    }
    getExcludedSymbolFlags := func(flags SymbolFlags) SymbolFlags {
        var result SymbolFlags = 0
        if /* TODO(BinaryExpression): flags & SymbolFlags.BlockScopedVariable */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.BlockScopedVariableExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.FunctionScopedVariable */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.FunctionScopedVariableExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.Property */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.PropertyExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.EnumMember */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.EnumMemberExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.Function */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.FunctionExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.Class */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.ClassExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.Interface */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.InterfaceExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.RegularEnum */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.RegularEnumExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.ConstEnum */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.ConstEnumExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.ValueModule */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.ValueModuleExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.Method */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.MethodExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.GetAccessor */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.GetAccessorExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.SetAccessor */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.SetAccessorExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.TypeParameter */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.TypeParameterExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.TypeAlias */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.TypeAliasExcludes */
        }
        if /* TODO(BinaryExpression): flags & SymbolFlags.Alias */ TODO {
            /* TODO(BinaryExpression): result |= SymbolFlags.AliasExcludes */
        }
         result
    }
    recordMergedSymbol := func(target Symbol, source Symbol) {
        if /* TODO(PrefixUnaryExpression): !source.mergeId */ TODO {
            /* TODO(ExpressionStatement): source.mergeId = nextMergeId; */
            /* TODO(ExpressionStatement): nextMergeId++; */
        }
        /* TODO(ExpressionStatement): mergedSymbols[source.mergeId] = target; */
    }
    cloneSymbol := func(symbol Symbol) TransientSymbol {
        result := createSymbol(/* TODO(PropertyAccessExpression): symbol.flags */ TODO, /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO)
        /* TODO(ExpressionStatement): result.declarations = symbol.declarations ? symbol.declarations.slice() : []; */
        /* TODO(ExpressionStatement): result.parent = symbol.parent; */
        if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
            /* TODO(BinaryExpression): result.valueDeclaration = symbol.valueDeclaration */
        }
        if /* TODO(PropertyAccessExpression): symbol.constEnumOnlyModule */ TODO {
            /* TODO(BinaryExpression): result.constEnumOnlyModule = true */
        }
        if /* TODO(PropertyAccessExpression): symbol.members */ TODO {
            /* TODO(BinaryExpression): result.members = new Map(symbol.members) */
        }
        if /* TODO(PropertyAccessExpression): symbol.exports */ TODO {
            /* TODO(BinaryExpression): result.exports = new Map(symbol.exports) */
        }
        /* TODO(ExpressionStatement): recordMergedSymbol(result, symbol); */
         result
    }
    mergeSymbol := func(target Symbol, source Symbol, unidirectional /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) Symbol {
        if /* TODO(BinaryExpression): !(target.flags & getExcludedSymbolFlags(source.flags)) ||             (source.flags | target.flags) & SymbolFlags.Assignment */ TODO {
            if /* TODO(BinaryExpression): source === target */ TODO {
                 target
            }
            if /* TODO(PrefixUnaryExpression): !(target.flags & SymbolFlags.Transient) */ TODO {
                resolvedTarget := resolveSymbol(target)
                if /* TODO(BinaryExpression): resolvedTarget === unknownSymbol */ TODO {
                     source
                }
                if /* TODO(BinaryExpression): !(resolvedTarget.flags & getExcludedSymbolFlags(source.flags)) ||                     (source.flags | resolvedTarget.flags) & SymbolFlags.Assignment */ TODO {
                    /* TODO(ExpressionStatement): target = cloneSymbol(resolvedTarget); */
                } else {
                    /* TODO(ExpressionStatement): reportMergeSymbolError(target, source); */
                     source
                }
            }
            if /* TODO(BinaryExpression): source.flags & SymbolFlags.ValueModule && target.flags & SymbolFlags.ValueModule && target.constEnumOnlyModule && !source.constEnumOnlyModule */ TODO {
                /* TODO(ExpressionStatement): target.constEnumOnlyModule = false; */
            }
            /* TODO(ExpressionStatement): target.flags |= source.flags; */
            if /* TODO(PropertyAccessExpression): source.valueDeclaration */ TODO {
                /* TODO(ExpressionStatement): setValueDeclaration(target, source.valueDeclaration); */
            }
            /* TODO(ExpressionStatement): addRange(target.declarations, source.declarations); */
            if /* TODO(PropertyAccessExpression): source.members */ TODO {
                if /* TODO(PrefixUnaryExpression): !target.members */ TODO {
                    /* TODO(BinaryExpression): target.members = createSymbolTable() */
                }
                /* TODO(ExpressionStatement): mergeSymbolTable(target.members, source.members, unidirectional); */
            }
            if /* TODO(PropertyAccessExpression): source.exports */ TODO {
                if /* TODO(PrefixUnaryExpression): !target.exports */ TODO {
                    /* TODO(BinaryExpression): target.exports = createSymbolTable() */
                }
                /* TODO(ExpressionStatement): mergeSymbolTable(target.exports, source.exports, unidirectional, target); */
            }
            if /* TODO(PrefixUnaryExpression): !unidirectional */ TODO {
                /* TODO(ExpressionStatement): recordMergedSymbol(target, source); */
            }
        } else if /* TODO(BinaryExpression): target.flags & SymbolFlags.NamespaceModule */ TODO {
            if /* TODO(BinaryExpression): target !== globalThisSymbol */ TODO {
                /* TODO(ExpressionStatement): error(                     source.declarations && getNameOfDeclaration(source.declarations[0]),                     Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity,                     symbolToString(target),                 ); */
            }
        } else {
            /* TODO(ExpressionStatement): reportMergeSymbolError(target, source); */
        }
         target
        reportMergeSymbolError := func(target Symbol, source Symbol) {
            isEitherEnum := /* TODO(PrefixUnaryExpression): !!(target.flags & SymbolFlags.Enum || source.flags & SymbolFlags.Enum) */ TODO
            isEitherBlockScoped := /* TODO(PrefixUnaryExpression): !!(target.flags & SymbolFlags.BlockScopedVariable || source.flags & SymbolFlags.BlockScopedVariable) */ TODO
            message := /* TODO(ConditionalExpression): isEitherEnum ? Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations                 : isEitherBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0                 : Diagnostics.Duplicate_identifier_0 */ TODO
            sourceSymbolFile := /* TODO(BinaryExpression): source.declarations && getSourceFileOfNode(source.declarations[0]) */ TODO
            targetSymbolFile := /* TODO(BinaryExpression): target.declarations && getSourceFileOfNode(target.declarations[0]) */ TODO
            isSourcePlainJs := isPlainJsFile(sourceSymbolFile, /* TODO(PropertyAccessExpression): compilerOptions.checkJs */ TODO)
            isTargetPlainJs := isPlainJsFile(targetSymbolFile, /* TODO(PropertyAccessExpression): compilerOptions.checkJs */ TODO)
            symbolName := symbolToString(source)
            if /* TODO(BinaryExpression): sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && sourceSymbolFile !== targetSymbolFile */ TODO {
                firstFile := /* TODO(ConditionalExpression): comparePaths(sourceSymbolFile.path, targetSymbolFile.path) === Comparison.LessThan ? sourceSymbolFile : targetSymbolFile */ TODO
                secondFile := /* TODO(ConditionalExpression): firstFile === sourceSymbolFile ? targetSymbolFile : sourceSymbolFile */ TODO
                filesDuplicates := getOrUpdate(amalgamatedDuplicates, /* TODO(TemplateExpression): `${firstFile.path}|${secondFile.path}` */ TODO, /* TODO(ArrowFunction): (): DuplicateInfoForFiles => ({ firstFile, secondFile, conflictingSymbols: new Map() }) */ TODO)
                conflictingSymbolInfo := getOrUpdate(/* TODO(PropertyAccessExpression): filesDuplicates.conflictingSymbols */ TODO, symbolName, /* TODO(ArrowFunction): (): DuplicateInfoForSymbol => ({ isBlockScoped: isEitherBlockScoped, firstFileLocations: [], secondFileLocations: [] }) */ TODO)
                if /* TODO(PrefixUnaryExpression): !isSourcePlainJs */ TODO {
                    /* TODO(CallExpression): addDuplicateLocations(conflictingSymbolInfo.firstFileLocations, source) */
                }
                if /* TODO(PrefixUnaryExpression): !isTargetPlainJs */ TODO {
                    /* TODO(CallExpression): addDuplicateLocations(conflictingSymbolInfo.secondFileLocations, target) */
                }
            } else {
                if /* TODO(PrefixUnaryExpression): !isSourcePlainJs */ TODO {
                    /* TODO(CallExpression): addDuplicateDeclarationErrorsForSymbols(source, message, symbolName, target) */
                }
                if /* TODO(PrefixUnaryExpression): !isTargetPlainJs */ TODO {
                    /* TODO(CallExpression): addDuplicateDeclarationErrorsForSymbols(target, message, symbolName, source) */
                }
            }
        }
        addDuplicateLocations := func(locs []Declaration, symbol Symbol) {
            if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
                /* TODO(ForOfStatement): for (const decl of symbol.declarations) {                     pushIfUnique(locs, decl);                 } */
            }
        }
    }
    addDuplicateDeclarationErrorsForSymbols := func(target Symbol, message DiagnosticMessage, symbolName string, source Symbol) {
        /* TODO(ExpressionStatement): forEach(target.declarations, node => {             addDuplicateDeclarationError(node, message, symbolName, source.declarations);         }); */
    }
    addDuplicateDeclarationError := func(node Declaration, message DiagnosticMessage, symbolName string, relatedNodes /* TODO(TypeOperator): readonly Declaration[] */ any) {
        errorNode := /* TODO(BinaryExpression): (getExpandoInitializer(node, /*isPrototypeAssignment* / false) ? getNameOfExpando(node) : getNameOfDeclaration(node)) || node */ TODO
        err := lookupOrIssueError(errorNode, message, symbolName)
        /* TODO(ForOfStatement): for (const relatedNode of relatedNodes || emptyArray) {             const adjustedNode = (getExpandoInitializer(relatedNode, /*isPrototypeAssignment* / false) ? getNameOfExpando(relatedNode) : getNameOfDeclaration(relatedNode)) || relatedNode;             if (adjustedNode === errorNode) continue;             err.relatedInformation = err.relatedInformation || [];             const leadingMessage = createDiagnosticForNode(adjustedNode, Diagnostics._0_was_also_declared_here, symbolName);             const followOnMessage = createDiagnosticForNode(adjustedNode, Diagnostics.and_here);             if (length(err.relatedInformation) >= 5 || some(err.relatedInformation, r => compareDiagnostics(r, followOnMessage) === Comparison.EqualTo || compareDiagnostics(r, leadingMessage) === Comparison.EqualTo)) continue;             addRelatedInfo(err, !length(err.relatedInformation) ? leadingMessage : followOnMessage);         } */
    }
    combineSymbolTables := func(first *SymbolTable, second *SymbolTable) *SymbolTable {
        if /* TODO(PrefixUnaryExpression): !first?.size */ TODO {
            /* TODO(Identifier): second */
        }
        if /* TODO(PrefixUnaryExpression): !second?.size */ TODO {
            /* TODO(Identifier): first */
        }
        combined := createSymbolTable()
        /* TODO(ExpressionStatement): mergeSymbolTable(combined, first); */
        /* TODO(ExpressionStatement): mergeSymbolTable(combined, second); */
         combined
    }
    mergeSymbolTable := func(target SymbolTable, source SymbolTable, unidirectional /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, mergedParent Symbol) {
        /* TODO(ExpressionStatement): source.forEach((sourceSymbol, id) => {             const targetSymbol = target.get(id);             const merged = targetSymbol ? mergeSymbol(targetSymbol, sourceSymbol, unidirectional) : getMergedSymbol(sourceSymbol);             if (mergedParent && targetSymbol) {                 // If a merge was performed on the target symbol, set its parent to the merged parent that initiated the merge                 // of its exports. Otherwise, `merged` came only from `sourceSymbol` and can keep its parent:                 //                 // // a.ts                 // export interface A { x: number; }                 //                 // // b.ts                 // declare module "./a" {                 //   interface A { y: number; }                 //   interface B {}                 // }                 //                 // When merging the module augmentation into a.ts, the symbol for `A` will itself be merged, so its parent                 // should be the merged module symbol. But the symbol for `B` has only one declaration, so its parent should                 // be the module augmentation symbol, which contains its only declaration.                 merged.parent = mergedParent;             }             target.set(id, merged);         }); */
    }
    mergeModuleAugmentation := func(moduleName /* TODO(UnionType): StringLiteral | Identifier */ any) {
        moduleAugmentation := /* TODO(PropertyAccessExpression): moduleName.parent */ TODO /* as */ /* TODO(TypeReference): ModuleDeclaration */
        if /* TODO(BinaryExpression): moduleAugmentation.symbol.declarations?.[0] !== moduleAugmentation */ TODO {
            /* TODO(ExpressionStatement): Debug.assert(moduleAugmentation.symbol.declarations!.length > 1); */

        }
        if isGlobalScopeAugmentation(moduleAugmentation) {
            /* TODO(ExpressionStatement): mergeSymbolTable(globals, moduleAugmentation.symbol.exports!); */
        } else {
            moduleNotFoundError := /* TODO(ConditionalExpression): !(moduleName.parent.parent.flags & NodeFlags.Ambient)                 ? Diagnostics.Invalid_module_name_in_augmentation_module_0_cannot_be_found                 : undefined */ TODO
            mainModule := resolveExternalModuleNameWorker(moduleName, moduleName, moduleNotFoundError, /* TODO(FalseKeyword): false */ TODO, /* TODO(TrueKeyword): true */ TODO)
            if /* TODO(PrefixUnaryExpression): !mainModule */ TODO {

            }
            /* TODO(ExpressionStatement): mainModule = resolveExternalModuleSymbol(mainModule); */
            if /* TODO(BinaryExpression): mainModule.flags & SymbolFlags.Namespace */ TODO {
                if some(patternAmbientModules, /* TODO(ArrowFunction): module => mainModule === module.symbol */ TODO) {
                    merged := mergeSymbol(/* TODO(PropertyAccessExpression): moduleAugmentation.symbol */ TODO, mainModule, /* TODO(TrueKeyword): true */ TODO)
                    if /* TODO(PrefixUnaryExpression): !patternAmbientModuleAugmentations */ TODO {
                        /* TODO(ExpressionStatement): patternAmbientModuleAugmentations = new Map(); */
                    }
                    /* TODO(ExpressionStatement): patternAmbientModuleAugmentations.set((moduleName as StringLiteral).text, merged); */
                } else {
                    if /* TODO(BinaryExpression): mainModule.exports?.get(InternalSymbolName.ExportStar) && moduleAugmentation.symbol.exports?.size */ TODO {
                        resolvedExports := getResolvedMembersOrExportsOfSymbol(mainModule, /* TODO(PropertyAccessExpression): MembersOrExportsResolutionKind.resolvedExports */ TODO)
                        /* TODO(ForOfStatement): for (const [key, value] of arrayFrom(moduleAugmentation.symbol.exports.entries())) {                             if (resolvedExports.has(key) && !mainModule.exports.has(key)) {                                 mergeSymbol(resolvedExports.get(key)!, value);                             }                         } */
                    }
                    /* TODO(ExpressionStatement): mergeSymbol(mainModule, moduleAugmentation.symbol); */
                }
            } else {
                /* TODO(ExpressionStatement): error(moduleName, Diagnostics.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity, (moduleName as StringLiteral).text); */
            }
        }
    }
    addUndefinedToGlobalsOrErrorOnRedeclaration := func() {
        name := /* TODO(PropertyAccessExpression): undefinedSymbol.escapedName */ TODO
        targetSymbol := /* TODO(PropertyAccessExpression): globals.get */ TODO(name)
        if targetSymbol {
            /* TODO(ExpressionStatement): forEach(targetSymbol.declarations, declaration => {                 // checkTypeNameIsReserved will have added better diagnostics for type declarations.                 if (!isTypeDeclaration(declaration)) {                     diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, unescapeLeadingUnderscores(name)));                 }             }); */
        } else {
            /* TODO(ExpressionStatement): globals.set(name, undefinedSymbol); */
        }
    }
    getSymbolLinks := func(symbol Symbol) SymbolLinks {
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Transient */ TODO {
            /* TODO(PropertyAccessExpression): (symbol as TransientSymbol).links */
        }
        id := getSymbolId(symbol)
         /* TODO(BinaryExpression): symbolLinks[id] ??= new SymbolLinks() */ TODO
    }
    getNodeLinks := func(node Node) NodeLinks {
        nodeId := getNodeId(node)
         /* TODO(BinaryExpression): nodeLinks[nodeId] || (nodeLinks[nodeId] = new (NodeLinks as any)()) */ TODO
    }
    getSymbol := func(symbols SymbolTable, name __String, meaning SymbolFlags) *Symbol {
        if meaning {
            symbol := getMergedSymbol(/* TODO(PropertyAccessExpression): symbols.get */ TODO(name))
            if symbol {
                if /* TODO(BinaryExpression): symbol.flags & meaning */ TODO {
                     symbol
                }
                if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO {
                    targetFlags := getSymbolFlags(symbol)
                    if /* TODO(BinaryExpression): targetFlags & meaning */ TODO {
                         symbol
                    }
                }
            }
        }
    }
    getSymbolsOfParameterPropertyDeclaration := func(parameter ParameterPropertyDeclaration, parameterName __String) /* TODO(TupleType): [Symbol, Symbol] */ TODO {
        constructorDeclaration := /* TODO(PropertyAccessExpression): parameter.parent */ TODO
        classDeclaration := /* TODO(PropertyAccessExpression): parameter.parent.parent */ TODO
        parameterSymbol := getSymbol(/* TODO(NonNullExpression): constructorDeclaration.locals! */ TODO, parameterName, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO)
        propertySymbol := getSymbol(getMembersOfSymbol(/* TODO(PropertyAccessExpression): classDeclaration.symbol */ TODO), parameterName, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO)
        if /* TODO(BinaryExpression): parameterSymbol && propertySymbol */ TODO {
             /* TODO(ArrayLiteralExpression): [parameterSymbol, propertySymbol] */ TODO
        }
         /* TODO(PropertyAccessExpression): Debug.fail */ TODO("There should exist two symbols, one as property declaration and one as parameter declaration")
    }
    isBlockScopedNameDeclaredBeforeUse := func(declaration Declaration, usage Node) bool {
        declarationFile := getSourceFileOfNode(declaration)
        useFile := getSourceFileOfNode(usage)
        declContainer := getEnclosingBlockScopeContainer(declaration)
        if /* TODO(BinaryExpression): declarationFile !== useFile */ TODO {
            if /* TODO(BinaryExpression): (moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) ||                 (!compilerOptions.outFile) ||                 isInTypeQuery(usage) ||                 declaration.flags & NodeFlags.Ambient */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            if isUsedInFunctionOrInstanceProperty(usage, declaration) {
                 /* TODO(TrueKeyword): true */ TODO
            }
            sourceFiles := /* TODO(PropertyAccessExpression): host.getSourceFiles */ TODO()
             /* TODO(BinaryExpression): sourceFiles.indexOf(declarationFile) <= sourceFiles.indexOf(useFile) */ TODO
        }
        if /* TODO(BinaryExpression): !!(usage.flags & NodeFlags.JSDoc) || isInTypeQuery(usage) || isInAmbientOrTypeNode(usage) */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): declaration.pos <= usage.pos && !(isPropertyDeclaration(declaration) && isThisProperty(usage.parent) && !declaration.initializer && !declaration.exclamationToken) */ TODO {
            if /* TODO(BinaryExpression): declaration.kind === SyntaxKind.BindingElement */ TODO {
                errorBindingElement := getAncestor(usage, /* TODO(PropertyAccessExpression): SyntaxKind.BindingElement */ TODO) /* as */ /* TODO(TypeReference): BindingElement */
                if errorBindingElement {
                     /* TODO(BinaryExpression): findAncestor(errorBindingElement, isBindingElement) !== findAncestor(declaration, isBindingElement) ||                         declaration.pos < errorBindingElement.pos */ TODO
                }
                 isBlockScopedNameDeclaredBeforeUse(getAncestor(declaration, /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclaration */ TODO) /* as */ /* TODO(TypeReference): Declaration */, usage)
            } else if /* TODO(BinaryExpression): declaration.kind === SyntaxKind.VariableDeclaration */ TODO {
                 /* TODO(PrefixUnaryExpression): !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration as VariableDeclaration, usage) */ TODO
            } else if isClassLike(declaration) {
                container := findAncestor(usage, /* TODO(ArrowFunction): n =>                     n === declaration ? "quit" :                         isComputedPropertyName(n) ? n.parent.parent === declaration :                         !legacyDecorators && isDecorator(n) && (n.parent === declaration ||                             isMethodDeclaration(n.parent) && n.parent.parent === declaration ||                             isGetOrSetAccessorDeclaration(n.parent) && n.parent.parent === declaration ||                             isPropertyDeclaration(n.parent) && n.parent.parent === declaration ||                             isParameter(n.parent) && n.parent.parent.parent === declaration) */ TODO)
                if /* TODO(PrefixUnaryExpression): !container */ TODO {
                     /* TODO(TrueKeyword): true */ TODO
                }
                if /* TODO(BinaryExpression): !legacyDecorators && isDecorator(container) */ TODO {
                     /* TODO(PrefixUnaryExpression): !!findAncestor(usage, n => n === container ? "quit" : isFunctionLike(n) && !getImmediatelyInvokedFunctionExpression(n)) */ TODO
                }
                 /* TODO(FalseKeyword): false */ TODO
            } else if isPropertyDeclaration(declaration) {
                 /* TODO(PrefixUnaryExpression): !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, /*stopAtAnyPropertyDeclaration* / false) */ TODO
            } else if isParameterPropertyDeclaration(declaration, /* TODO(PropertyAccessExpression): declaration.parent */ TODO) {
                 /* TODO(PrefixUnaryExpression): !(emitStandardClassFields                     && getContainingClass(declaration) === getContainingClass(usage)                     && isUsedInFunctionOrInstanceProperty(usage, declaration)) */ TODO
            }
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): usage.parent.kind === SyntaxKind.ExportSpecifier || (usage.parent.kind === SyntaxKind.ExportAssignment && (usage.parent as ExportAssignment).isExportEquals) */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): usage.kind === SyntaxKind.ExportAssignment && (usage as ExportAssignment).isExportEquals */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if isUsedInFunctionOrInstanceProperty(usage, declaration) {
            if /* TODO(BinaryExpression): emitStandardClassFields                 && getContainingClass(declaration)                 && (isPropertyDeclaration(declaration) || isParameterPropertyDeclaration(declaration, declaration.parent)) */ TODO {
                 /* TODO(PrefixUnaryExpression): !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, /*stopAtAnyPropertyDeclaration* / true) */ TODO
            } else {
                 /* TODO(TrueKeyword): true */ TODO
            }
        }
         /* TODO(FalseKeyword): false */ TODO
        isImmediatelyUsedInInitializerOfBlockScopedVariable := func(declaration VariableDeclaration, usage Node) bool {
            /* TODO(SwitchStatement): switch (declaration.parent.parent.kind) {                 case SyntaxKind.VariableStatement:                 case SyntaxKind.ForStatement:                 case SyntaxKind.ForOfStatement:                     // variable statement/for/for-of statement case,                     // use site should not be inside variable declaration (initializer of declaration or binding element)                     if (isSameScopeDescendentOf(usage, declaration, declContainer)) {                         return true;                     }                     break;             } */
            grandparent := /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO
             /* TODO(BinaryExpression): isForInOrOfStatement(grandparent) && isSameScopeDescendentOf(usage, grandparent.expression, declContainer) */ TODO
        }
        isUsedInFunctionOrInstanceProperty := func(usage Node, declaration Node) bool {
             /* TODO(PrefixUnaryExpression): !!findAncestor(usage, current => {                 if (current === declContainer) {                     return "quit";                 }                 if (isFunctionLike(current)) {                     return true;                 }                 if (isClassStaticBlockDeclaration(current)) {                     return declaration.pos < usage.pos;                 }                  const propertyDeclaration = tryCast(current.parent, isPropertyDeclaration);                 if (propertyDeclaration) {                     const initializerOfProperty = propertyDeclaration.initializer === current;                     if (initializerOfProperty) {                         if (isStatic(current.parent)) {                             if (declaration.kind === SyntaxKind.MethodDeclaration) {                                 return true;                             }                             if (isPropertyDeclaration(declaration) && getContainingClass(usage) === getContainingClass(declaration)) {                                 const propName = declaration.name;                                 if (isIdentifier(propName) || isPrivateIdentifier(propName)) {                                     const type = getTypeOfSymbol(getSymbolOfDeclaration(declaration));                                     const staticBlocks = filter(declaration.parent.members, isClassStaticBlockDeclaration);                                     if (isPropertyInitializedInStaticBlocks(propName, type, staticBlocks, declaration.parent.pos, current.pos)) {                                         return true;                                     }                                 }                             }                         }                         else {                             const isDeclarationInstanceProperty = declaration.kind === SyntaxKind.PropertyDeclaration && !isStatic(declaration);                             if (!isDeclarationInstanceProperty || getContainingClass(usage) !== getContainingClass(declaration)) {                                 return true;                             }                         }                     }                 }                 return false;             }) */ TODO
        }
        isPropertyImmediatelyReferencedWithinDeclaration := func(declaration /* TODO(UnionType): PropertyDeclaration | ParameterPropertyDeclaration */ any, usage Node, stopAtAnyPropertyDeclaration bool) /* TODO(undefined): boolean */ TODO {
            if /* TODO(BinaryExpression): usage.end > declaration.end */ TODO {
                 /* TODO(FalseKeyword): false */ TODO
            }
            ancestorChangingReferenceScope := findAncestor(usage, /* TODO(ArrowFunction): (node: Node) => {                 if (node === declaration) {                     return "quit";                 }                  switch (node.kind) {                     case SyntaxKind.ArrowFunction:                         return true;                     case SyntaxKind.PropertyDeclaration:                         // even when stopping at any property declaration, they need to come from the same class                         return stopAtAnyPropertyDeclaration &&                                 (isPropertyDeclaration(declaration) && node.parent === declaration.parent                                     || isParameterPropertyDeclaration(declaration, declaration.parent) && node.parent === declaration.parent.parent)                             ? "quit" : true;                     case SyntaxKind.Block:                         switch (node.parent.kind) {                             case SyntaxKind.GetAccessor:                             case SyntaxKind.MethodDeclaration:                             case SyntaxKind.SetAccessor:                                 return true;                             default:                                 return false;                         }                     default:                         return false;                 }             } */ TODO)
             /* TODO(BinaryExpression): ancestorChangingReferenceScope === undefined */ TODO
        }
    }
    getRequiresScopeChangeCache := func(node FunctionLikeDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
         /* TODO(PropertyAccessExpression): getNodeLinks(node).declarationRequiresScopeChange */ TODO
    }
    setRequiresScopeChangeCache := func(node FunctionLikeDeclaration, value bool) {
        /* TODO(ExpressionStatement): getNodeLinks(node).declarationRequiresScopeChange = value; */
    }
    checkAndReportErrorForInvalidInitializer := func(errorLocation Node, name __String, propertyWithInvalidInitializer PropertyDeclaration, result *Symbol) /* TODO(undefined): boolean */ TODO {
        if /* TODO(PrefixUnaryExpression): !emitStandardClassFields */ TODO {
            if /* TODO(BinaryExpression): errorLocation && !result && checkAndReportErrorForMissingPrefix(errorLocation, name, name) */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            /* TODO(ExpressionStatement): error(                 errorLocation,                 errorLocation && propertyWithInvalidInitializer.type && textRangeContainsPositionInclusive(propertyWithInvalidInitializer.type, errorLocation.pos)                     ? Diagnostics.Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor                     : Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor,                 declarationNameToString(propertyWithInvalidInitializer.name),                 diagnosticName(name),             ); */
             /* TODO(TrueKeyword): true */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    onFailedToResolveSymbol := func(errorLocation Node, nameArg /* TODO(UnionType): __String | Identifier */ any, meaning SymbolFlags, nameNotFoundMessage DiagnosticMessage) {
        name := /* TODO(ConditionalExpression): isString(nameArg) ? nameArg : (nameArg as Identifier).escapedText */ TODO
        /* TODO(ExpressionStatement): addLazyDiagnostic(() => {             if (                 !errorLocation ||                 errorLocation.parent.kind !== SyntaxKind.JSDocLink &&                     !checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) &&                     !checkAndReportErrorForExtendingInterface(errorLocation) &&                     !checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) &&                     !checkAndReportErrorForExportingPrimitiveType(errorLocation, name) &&                     !checkAndReportErrorForUsingNamespaceAsTypeOrValue(errorLocation, name, meaning) &&                     !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) &&                     !checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning)             ) {                 let suggestion: Symbol | undefined;                 let suggestedLib: string | undefined;                 // Report missing lib first                 if (nameArg) {                     suggestedLib = getSuggestedLibForNonExistentName(nameArg);                     if (suggestedLib) {                         error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg), suggestedLib);                     }                 }                 // then spelling suggestions                 if (!suggestedLib && suggestionCount < maximumSuggestionCount) {                     suggestion = getSuggestedSymbolForNonexistentSymbol(errorLocation, name, meaning);                     const isGlobalScopeAugmentationDeclaration = suggestion?.valueDeclaration && isAmbientModule(suggestion.valueDeclaration) && isGlobalScopeAugmentation(suggestion.valueDeclaration);                     if (isGlobalScopeAugmentationDeclaration) {                         suggestion = undefined;                     }                     if (suggestion) {                         const suggestionName = symbolToString(suggestion);                         const isUncheckedJS = isUncheckedJSSuggestion(errorLocation, suggestion, /*excludeClasses* / false);                         const message = meaning === SymbolFlags.Namespace ||                                 nameArg && typeof nameArg !== "string" && nodeIsSynthesized(nameArg) ?                             Diagnostics.Cannot_find_namespace_0_Did_you_mean_1                             : isUncheckedJS ? Diagnostics.Could_not_find_name_0_Did_you_mean_1                             : Diagnostics.Cannot_find_name_0_Did_you_mean_1;                         const diagnostic = createError(errorLocation, message, diagnosticName(nameArg), suggestionName);                         diagnostic.canonicalHead = getCanonicalDiagnostic(nameNotFoundMessage, diagnosticName(nameArg));                         addErrorOrSuggestion(!isUncheckedJS, diagnostic);                         if (suggestion.valueDeclaration) {                             addRelatedInfo(                                 diagnostic,                                 createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName),                             );                         }                     }                 }                 // And then fall back to unspecified "not found"                 if (!suggestion && !suggestedLib && nameArg) {                     error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg));                 }                 suggestionCount++;             }         }); */
    }
    onSuccessfullyResolvedSymbol := func(errorLocation Node, result Symbol, meaning SymbolFlags, lastLocation Node, associatedDeclarationForContainingInitializerOrBindingName /* TODO(UnionType): ParameterDeclaration | BindingElement | undefined */ any, withinDeferredContext bool) {
        /* TODO(ExpressionStatement): addLazyDiagnostic(() => {             const name = result.escapedName;             const isInExternalModule = lastLocation && isSourceFile(lastLocation) && isExternalOrCommonJsModule(lastLocation);             // Only check for block-scoped variable if we have an error location and are looking for the             // name with variable meaning             //      For example,             //          declare module foo {             //              interface bar {}             //          }             //      const foo/*1* /: foo/*2* /.bar;             // The foo at /*1* / and /*2* / will share same symbol with two meanings:             // block-scoped variable and namespace module. However, only when we             // try to resolve name in /*1* / which is used in variable position,             // we want to check for block-scoped             if (                 errorLocation &&                 (meaning & SymbolFlags.BlockScopedVariable ||                     ((meaning & SymbolFlags.Class || meaning & SymbolFlags.Enum) && (meaning & SymbolFlags.Value) === SymbolFlags.Value))             ) {                 const exportOrLocalSymbol = getExportSymbolOfValueSymbolIfExported(result);                 if (exportOrLocalSymbol.flags & SymbolFlags.BlockScopedVariable || exportOrLocalSymbol.flags & SymbolFlags.Class || exportOrLocalSymbol.flags & SymbolFlags.Enum) {                     checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation);                 }             }              // If we're in an external module, we can't reference value symbols created from UMD export declarations             if (isInExternalModule && (meaning & SymbolFlags.Value) === SymbolFlags.Value && !(errorLocation!.flags & NodeFlags.JSDoc)) {                 const merged = getMergedSymbol(result);                 if (length(merged.declarations) && every(merged.declarations, d => isNamespaceExportDeclaration(d) || isSourceFile(d) && !!d.symbol.globalExports)) {                     errorOrSuggestion(!compilerOptions.allowUmdGlobalAccess, errorLocation!, Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead, unescapeLeadingUnderscores(name));                 }             }              // If we're in a parameter initializer or binding name, we can't reference the values of the parameter whose initializer we're within or parameters to the right             if (associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning & SymbolFlags.Value) === SymbolFlags.Value) {                 const candidate = getMergedSymbol(getLateBoundSymbol(result));                 const root = getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName) as ParameterDeclaration;                 // A parameter initializer or binding pattern initializer within a parameter cannot refer to itself                 if (candidate === getSymbolOfDeclaration(associatedDeclarationForContainingInitializerOrBindingName)) {                     error(errorLocation, Diagnostics.Parameter_0_cannot_reference_itself, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name));                 }                 // And it cannot refer to any declarations which come after it                 else if (candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && getSymbol(root.parent.locals, candidate.escapedName, meaning) === candidate) {                     error(errorLocation, Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name), declarationNameToString(errorLocation as Identifier));                 }             }             if (errorLocation && meaning & SymbolFlags.Value && result.flags & SymbolFlags.Alias && !(result.flags & SymbolFlags.Value) && !isValidTypeOnlyAliasUseSite(errorLocation)) {                 const typeOnlyDeclaration = getTypeOnlyAliasDeclaration(result, SymbolFlags.Value);                 if (typeOnlyDeclaration) {                     const message = typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration || typeOnlyDeclaration.kind === SyntaxKind.NamespaceExport                         ? Diagnostics._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type                         : Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type;                     const unescapedName = unescapeLeadingUnderscores(name);                     addTypeOnlyDeclarationRelatedInfo(                         error(errorLocation, message, unescapedName),                         typeOnlyDeclaration,                         unescapedName,                     );                 }             }              // Look at 'compilerOptions.isolatedModules' and not 'getIsolatedModules(...)' (which considers 'verbatimModuleSyntax')             // here because 'verbatimModuleSyntax' will already have an error for importing a type without 'import type'.             if (compilerOptions.isolatedModules && result && isInExternalModule && (meaning & SymbolFlags.Value) === SymbolFlags.Value) {                 const isGlobal = getSymbol(globals, name, meaning) === result;                 const nonValueSymbol = isGlobal && isSourceFile(lastLocation) && lastLocation.locals && getSymbol(lastLocation.locals, name, ~SymbolFlags.Value);                 if (nonValueSymbol) {                     const importDecl = nonValueSymbol.declarations?.find(d => d.kind === SyntaxKind.ImportSpecifier || d.kind === SyntaxKind.ImportClause || d.kind === SyntaxKind.NamespaceImport || d.kind === SyntaxKind.ImportEqualsDeclaration);                     if (importDecl && !isTypeOnlyImportDeclaration(importDecl)) {                         error(importDecl, Diagnostics.Import_0_conflicts_with_global_value_used_in_this_file_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, unescapeLeadingUnderscores(name));                     }                 }             }         }); */
    }
    addTypeOnlyDeclarationRelatedInfo := func(diagnostic Diagnostic, typeOnlyDeclaration *TypeOnlyCompatibleAliasDeclaration, unescapedName string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic */ TODO {
        if /* TODO(PrefixUnaryExpression): !typeOnlyDeclaration */ TODO {
            /* TODO(Identifier): diagnostic */
        }
         addRelatedInfo(diagnostic, createDiagnosticForNode(typeOnlyDeclaration, /* TODO(ConditionalExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration || typeOnlyDeclaration.kind === SyntaxKind.NamespaceExport                     ? Diagnostics._0_was_exported_here                     : Diagnostics._0_was_imported_here */ TODO, unescapedName))
    }
    diagnosticName := func(nameArg /* TODO(UnionType): __String | Identifier | PrivateIdentifier */ any) /* TODO(undefined): string */ TODO {
         /* TODO(ConditionalExpression): isString(nameArg) ? unescapeLeadingUnderscores(nameArg as __String) : declarationNameToString(nameArg as Identifier) */ TODO
    }
    checkAndReportErrorForMissingPrefix := func(errorLocation Node, name __String, nameArg /* TODO(UnionType): __String | Identifier */ any) bool {
        if /* TODO(BinaryExpression): !isIdentifier(errorLocation) || errorLocation.escapedText !== name || isTypeReferenceIdentifier(errorLocation) || isInTypeQuery(errorLocation) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        container := getThisContainer(errorLocation, /* TODO(FalseKeyword): false */ TODO, /* TODO(FalseKeyword): false */ TODO)
        var location Node = container
        /* TODO(WhileStatement): while (location) {             if (isClassLike(location.parent)) {                 const classSymbol = getSymbolOfDeclaration(location.parent);                 if (!classSymbol) {                     break;                 }                  // Check to see if a static member exists.                 const constructorType = getTypeOfSymbol(classSymbol);                 if (getPropertyOfType(constructorType, name)) {                     error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0, diagnosticName(nameArg), symbolToString(classSymbol));                     return true;                 }                  // No static member is present.                 // Check if we're in an instance method and look for a relevant instance member.                 if (location === container && !isStatic(location)) {                     const instanceType = (getDeclaredTypeOfSymbol(classSymbol) as InterfaceType).thisType!; // TODO: GH#18217                     if (getPropertyOfType(instanceType, name)) {                         error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0, diagnosticName(nameArg));                         return true;                     }                 }             }              location = location.parent;         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    checkAndReportErrorForExtendingInterface := func(errorLocation Node) bool {
        expression := getEntityNameForExtendingInterface(errorLocation)
        if /* TODO(BinaryExpression): expression && resolveEntityName(expression, SymbolFlags.Interface, /*ignoreErrors* / true) */ TODO {
            /* TODO(ExpressionStatement): error(errorLocation, Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements, getTextOfNode(expression)); */
             /* TODO(TrueKeyword): true */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    getEntityNameForExtendingInterface := func(node Node) *EntityNameExpression {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:             case SyntaxKind.PropertyAccessExpression:                 return node.parent ? getEntityNameForExtendingInterface(node.parent) : undefined;             case SyntaxKind.ExpressionWithTypeArguments:                 if (isEntityNameExpression((node as ExpressionWithTypeArguments).expression)) {                     return (node as ExpressionWithTypeArguments).expression as EntityNameExpression;                 }                 // falls through             default:                 return undefined;         } */
    }
    checkAndReportErrorForUsingTypeAsNamespace := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
        namespaceMeaning := /* TODO(BinaryExpression): SymbolFlags.Namespace | (isInJSFile(errorLocation) ? SymbolFlags.Value : 0) */ TODO
        if /* TODO(BinaryExpression): meaning === namespaceMeaning */ TODO {
            symbol := resolveSymbol(resolveName(errorLocation, name, /* TODO(BinaryExpression): SymbolFlags.Type & ~namespaceMeaning */ TODO, undefined, /* TODO(FalseKeyword): false */ TODO))
            parent := /* TODO(PropertyAccessExpression): errorLocation.parent */ TODO
            if symbol {
                if isQualifiedName(parent) {
                    /* TODO(ExpressionStatement): Debug.assert(parent.left === errorLocation, "Should only be resolving left side of qualified name as a namespace"); */
                    propName := /* TODO(PropertyAccessExpression): parent.right.escapedText */ TODO
                    propType := getPropertyOfType(getDeclaredTypeOfSymbol(symbol), propName)
                    if propType {
                        /* TODO(ExpressionStatement): error(                             parent,                             Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1,                             unescapeLeadingUnderscores(name),                             unescapeLeadingUnderscores(propName),                         ); */
                         /* TODO(TrueKeyword): true */ TODO
                    }
                }
                /* TODO(ExpressionStatement): error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here, unescapeLeadingUnderscores(name)); */
                 /* TODO(TrueKeyword): true */ TODO
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkAndReportErrorForUsingValueAsType := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
        if /* TODO(BinaryExpression): meaning & (SymbolFlags.Type & ~SymbolFlags.Namespace) */ TODO {
            symbol := resolveSymbol(resolveName(errorLocation, name, /* TODO(BinaryExpression): ~SymbolFlags.Type & SymbolFlags.Value */ TODO, undefined, /* TODO(FalseKeyword): false */ TODO))
            if /* TODO(BinaryExpression): symbol && !(symbol.flags & SymbolFlags.Namespace) */ TODO {
                /* TODO(ExpressionStatement): error(errorLocation, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, unescapeLeadingUnderscores(name)); */
                 /* TODO(TrueKeyword): true */ TODO
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isPrimitiveTypeName := func(name __String) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): name === "any" || name === "string" || name === "number" || name === "boolean" || name === "never" || name === "unknown" */ TODO
    }
    checkAndReportErrorForExportingPrimitiveType := func(errorLocation Node, name __String) bool {
        if /* TODO(BinaryExpression): isPrimitiveTypeName(name) && errorLocation.parent.kind === SyntaxKind.ExportSpecifier */ TODO {
            /* TODO(ExpressionStatement): error(errorLocation, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, name as string); */
             /* TODO(TrueKeyword): true */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkAndReportErrorForUsingTypeAsValue := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
        if /* TODO(BinaryExpression): meaning & SymbolFlags.Value */ TODO {
            if isPrimitiveTypeName(name) {
                grandparent := /* TODO(PropertyAccessExpression): errorLocation.parent.parent */ TODO
                if /* TODO(BinaryExpression): grandparent && grandparent.parent && isHeritageClause(grandparent) */ TODO {
                    heritageKind := /* TODO(PropertyAccessExpression): grandparent.token */ TODO
                    containerKind := /* TODO(PropertyAccessExpression): grandparent.parent.kind */ TODO
                    if /* TODO(BinaryExpression): containerKind === SyntaxKind.InterfaceDeclaration && heritageKind === SyntaxKind.ExtendsKeyword */ TODO {
                        /* TODO(ExpressionStatement): error(errorLocation, Diagnostics.An_interface_cannot_extend_a_primitive_type_like_0_It_can_only_extend_other_named_object_types, unescapeLeadingUnderscores(name)); */
                    } else if /* TODO(BinaryExpression): containerKind === SyntaxKind.ClassDeclaration && heritageKind === SyntaxKind.ExtendsKeyword */ TODO {
                        /* TODO(ExpressionStatement): error(errorLocation, Diagnostics.A_class_cannot_extend_a_primitive_type_like_0_Classes_can_only_extend_constructable_values, unescapeLeadingUnderscores(name)); */
                    } else if /* TODO(BinaryExpression): containerKind === SyntaxKind.ClassDeclaration && heritageKind === SyntaxKind.ImplementsKeyword */ TODO {
                        /* TODO(ExpressionStatement): error(errorLocation, Diagnostics.A_class_cannot_implement_a_primitive_type_like_0_It_can_only_implement_other_named_object_types, unescapeLeadingUnderscores(name)); */
                    }
                } else {
                    /* TODO(ExpressionStatement): error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, unescapeLeadingUnderscores(name)); */
                }
                 /* TODO(TrueKeyword): true */ TODO
            }
            symbol := resolveSymbol(resolveName(errorLocation, name, /* TODO(BinaryExpression): SymbolFlags.Type & ~SymbolFlags.Value */ TODO, undefined, /* TODO(FalseKeyword): false */ TODO))
            allFlags := /* TODO(BinaryExpression): symbol && getSymbolFlags(symbol) */ TODO
            if /* TODO(BinaryExpression): symbol && allFlags !== undefined && !(allFlags & SymbolFlags.Value) */ TODO {
                rawName := unescapeLeadingUnderscores(name)
                if isES2015OrLaterConstructorName(name) {
                    /* TODO(ExpressionStatement): error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later, rawName); */
                } else if maybeMappedType(errorLocation, symbol) {
                    /* TODO(ExpressionStatement): error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0, rawName, rawName === "K" ? "P" : "K"); */
                } else {
                    /* TODO(ExpressionStatement): error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, rawName); */
                }
                 /* TODO(TrueKeyword): true */ TODO
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    maybeMappedType := func(node Node, symbol Symbol) /* TODO(undefined): boolean */ TODO {
        container := findAncestor(/* TODO(PropertyAccessExpression): node.parent */ TODO, /* TODO(ArrowFunction): n => isComputedPropertyName(n) || isPropertySignature(n) ? false : isTypeLiteralNode(n) || "quit" */ TODO) /* as */ /* TODO(UnionType): TypeLiteralNode | undefined */
        if /* TODO(BinaryExpression): container && container.members.length === 1 */ TODO {
            type_ := getDeclaredTypeOfSymbol(symbol)
             /* TODO(BinaryExpression): !!(type.flags & TypeFlags.Union) && allTypesAssignableToKind(type, TypeFlags.StringOrNumberLiteral, /*strict* / true) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isES2015OrLaterConstructorName := func(n __String) /* TODO(undefined): boolean */ TODO {
        /* TODO(SwitchStatement): switch (n) {             case "Promise":             case "Symbol":             case "Map":             case "WeakMap":             case "Set":             case "WeakSet":                 return true;         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    checkAndReportErrorForUsingNamespaceAsTypeOrValue := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
        if /* TODO(BinaryExpression): meaning & (SymbolFlags.Value & ~SymbolFlags.Type) */ TODO {
            symbol := resolveSymbol(resolveName(errorLocation, name, /* TODO(PropertyAccessExpression): SymbolFlags.NamespaceModule */ TODO, undefined, /* TODO(FalseKeyword): false */ TODO))
            if symbol {
                /* TODO(ExpressionStatement): error(                     errorLocation,                     Diagnostics.Cannot_use_namespace_0_as_a_value,                     unescapeLeadingUnderscores(name),                 ); */
                 /* TODO(TrueKeyword): true */ TODO
            }
        } else if /* TODO(BinaryExpression): meaning & (SymbolFlags.Type & ~SymbolFlags.Value) */ TODO {
            symbol := resolveSymbol(resolveName(errorLocation, name, /* TODO(PropertyAccessExpression): SymbolFlags.Module */ TODO, undefined, /* TODO(FalseKeyword): false */ TODO))
            if symbol {
                /* TODO(ExpressionStatement): error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_type, unescapeLeadingUnderscores(name)); */
                 /* TODO(TrueKeyword): true */ TODO
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkResolvedBlockScopedVariable := func(result Symbol, errorLocation Node) {
        /* TODO(ExpressionStatement): Debug.assert(!!(result.flags & SymbolFlags.BlockScopedVariable || result.flags & SymbolFlags.Class || result.flags & SymbolFlags.Enum)); */
        if /* TODO(BinaryExpression): result.flags & (SymbolFlags.Function | SymbolFlags.FunctionScopedVariable | SymbolFlags.Assignment) && result.flags & SymbolFlags.Class */ TODO {

        }
        declaration := /* TODO(PropertyAccessExpression): result.declarations?.find */ TODO(/* TODO(ArrowFunction): d => isBlockOrCatchScoped(d) || isClassLike(d) || (d.kind === SyntaxKind.EnumDeclaration) */ TODO)
        if /* TODO(BinaryExpression): declaration === undefined */ TODO {
            /* TODO(CallExpression): Debug.fail("checkResolvedBlockScopedVariable could not find block-scoped declaration") */
        }
        if /* TODO(BinaryExpression): !(declaration.flags & NodeFlags.Ambient) && !isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation) */ TODO {
            diagnosticMessage
            declarationName := declarationNameToString(getNameOfDeclaration(declaration))
            if /* TODO(BinaryExpression): result.flags & SymbolFlags.BlockScopedVariable */ TODO {
                /* TODO(ExpressionStatement): diagnosticMessage = error(errorLocation, Diagnostics.Block_scoped_variable_0_used_before_its_declaration, declarationName); */
            } else if /* TODO(BinaryExpression): result.flags & SymbolFlags.Class */ TODO {
                /* TODO(ExpressionStatement): diagnosticMessage = error(errorLocation, Diagnostics.Class_0_used_before_its_declaration, declarationName); */
            } else if /* TODO(BinaryExpression): result.flags & SymbolFlags.RegularEnum */ TODO {
                /* TODO(ExpressionStatement): diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName); */
            } else {
                /* TODO(ExpressionStatement): Debug.assert(!!(result.flags & SymbolFlags.ConstEnum)); */
                if getIsolatedModules(compilerOptions) {
                    /* TODO(ExpressionStatement): diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName); */
                }
            }
            if diagnosticMessage {
                /* TODO(ExpressionStatement): addRelatedInfo(diagnosticMessage, createDiagnosticForNode(declaration, Diagnostics._0_is_declared_here, declarationName)); */
            }
        }
    }
    isSameScopeDescendentOf := func(initial Node, parent Node, stopAt Node) bool {
         /* TODO(BinaryExpression): !!parent && !!findAncestor(initial, n =>             n === parent             || (n === stopAt || isFunctionLike(n) && (!getImmediatelyInvokedFunctionExpression(n) || (getFunctionFlags(n) & FunctionFlags.AsyncGenerator)) ? "quit" : false)) */ TODO
    }
    getAnyImportSyntax := func(node Node) *AnyImportOrJsDocImport {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ImportEqualsDeclaration:                 return node as ImportEqualsDeclaration;             case SyntaxKind.ImportClause:                 return (node as ImportClause).parent;             case SyntaxKind.NamespaceImport:                 return (node as NamespaceImport).parent.parent;             case SyntaxKind.ImportSpecifier:                 return (node as ImportSpecifier).parent.parent.parent;             default:                 return undefined;         } */
    }
    getDeclarationOfAliasSymbol := func(symbol Symbol) Declaration {
         /* TODO(BinaryExpression): symbol.declarations && findLast<Declaration>(symbol.declarations, isAliasSymbolDeclaration) */ TODO
    }
    isAliasSymbolDeclaration := func(node Node) bool {
         /* TODO(BinaryExpression): node.kind === SyntaxKind.ImportEqualsDeclaration             || node.kind === SyntaxKind.NamespaceExportDeclaration             || node.kind === SyntaxKind.ImportClause && !!(node as ImportClause).name             || node.kind === SyntaxKind.NamespaceImport             || node.kind === SyntaxKind.NamespaceExport             || node.kind === SyntaxKind.ImportSpecifier             || node.kind === SyntaxKind.ExportSpecifier             || node.kind === SyntaxKind.ExportAssignment && exportAssignmentIsAlias(node as ExportAssignment)             || isBinaryExpression(node) && getAssignmentDeclarationKind(node) === AssignmentDeclarationKind.ModuleExports && exportAssignmentIsAlias(node)             || isAccessExpression(node)                 && isBinaryExpression(node.parent)                 && node.parent.left === node                 && node.parent.operatorToken.kind === SyntaxKind.EqualsToken                 && isAliasableOrJsExpression(node.parent.right)             || node.kind === SyntaxKind.ShorthandPropertyAssignment             || node.kind === SyntaxKind.PropertyAssignment && isAliasableOrJsExpression((node as PropertyAssignment).initializer)             || node.kind === SyntaxKind.VariableDeclaration && isVariableDeclarationInitializedToBareOrAccessedRequire(node)             || node.kind === SyntaxKind.BindingElement && isVariableDeclarationInitializedToBareOrAccessedRequire(node.parent.parent) */ TODO
    }
    isAliasableOrJsExpression := func(e Expression) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isAliasableExpression(e) || isFunctionExpression(e) && isJSConstructor(e) */ TODO
    }
    getTargetOfImportEqualsDeclaration := func(node /* TODO(UnionType): ImportEqualsDeclaration | VariableDeclaration */ any, dontResolveAlias bool) *Symbol {
        commonJSPropertyAccess := getCommonJSPropertyAccess(node)
        if commonJSPropertyAccess {
            name := /* TODO(ElementAccessExpression): (getLeftmostAccessExpression(commonJSPropertyAccess.expression) as CallExpression).arguments[0] */ TODO /* as */ /* TODO(TypeReference): StringLiteral */
             /* TODO(ConditionalExpression): isIdentifier(commonJSPropertyAccess.name)                 ? resolveSymbol(getPropertyOfType(resolveExternalModuleTypeByLiteral(name), commonJSPropertyAccess.name.escapedText))                 : undefined */ TODO
        }
        if /* TODO(BinaryExpression): isVariableDeclaration(node) || node.moduleReference.kind === SyntaxKind.ExternalModuleReference */ TODO {
            immediate := resolveExternalModuleName(node, /* TODO(BinaryExpression): getExternalModuleRequireArgument(node) || getExternalModuleImportEqualsDeclarationExpression(node) */ TODO)
            resolved := resolveExternalModuleSymbol(immediate)
            /* TODO(ExpressionStatement): markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, /*overwriteEmpty* / false); */
             resolved
        }
        resolved := getSymbolOfPartOfRightHandSideOfImportEquals(/* TODO(PropertyAccessExpression): node.moduleReference */ TODO, dontResolveAlias)
        /* TODO(ExpressionStatement): checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved); */
         resolved
    }
    checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol := func(node ImportEqualsDeclaration, resolved *Symbol) {
        if /* TODO(BinaryExpression): markSymbolOfAliasDeclarationIfTypeOnly(node, /*immediateTarget* / undefined, resolved, /*overwriteEmpty* / false) && !node.isTypeOnly */ TODO {
            typeOnlyDeclaration := /* TODO(NonNullExpression): getTypeOnlyAliasDeclaration(getSymbolOfDeclaration(node))! */ TODO
            isExport := /* TODO(BinaryExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration */ TODO
            message := /* TODO(ConditionalExpression): isExport                 ? Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type                 : Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type */ TODO
            relatedMessage := /* TODO(ConditionalExpression): isExport                 ? Diagnostics._0_was_exported_here                 : Diagnostics._0_was_imported_here */ TODO
            name := /* TODO(ConditionalExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration ? "*" : moduleExportNameTextUnescaped(typeOnlyDeclaration.name) */ TODO
            /* TODO(ExpressionStatement): addRelatedInfo(error(node.moduleReference, message), createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, name)); */
        }
    }
    resolveExportByName := func(moduleSymbol Symbol, name __String, sourceNode *TypeOnlyCompatibleAliasDeclaration, dontResolveAlias bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        exportValue := /* TODO(PropertyAccessExpression): moduleSymbol.exports!.get */ TODO(/* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO)
        exportSymbol := /* TODO(ConditionalExpression): exportValue             ? getPropertyOfType(getTypeOfSymbol(exportValue), name, /*skipObjectFunctionPropertyAugment* / true)             : moduleSymbol.exports!.get(name) */ TODO
        resolved := resolveSymbol(exportSymbol, dontResolveAlias)
        /* TODO(ExpressionStatement): markSymbolOfAliasDeclarationIfTypeOnly(sourceNode, exportSymbol, resolved, /*overwriteEmpty* / false); */
         resolved
    }
    isSyntacticDefault := func(node Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(ParenthesizedExpression): ((isExportAssignment(node) && !node.isExportEquals)             || hasSyntacticModifier(node, ModifierFlags.Default)             || isExportSpecifier(node)             || isNamespaceExport(node)) */ TODO
    }
    getEmitSyntaxForModuleSpecifierExpression := func(usage Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolutionMode */ TODO {
         /* TODO(ConditionalExpression): isStringLiteralLike(usage) ? host.getEmitSyntaxForUsageLocation(getSourceFileOfNode(usage), usage) : undefined */ TODO
    }
    isESMFormatImportImportingCommonjsFormatFile := func(usageMode ResolutionMode, targetMode ResolutionMode) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): usageMode === ModuleKind.ESNext && targetMode === ModuleKind.CommonJS */ TODO
    }
    isOnlyImportableAsDefault := func(usage Expression) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): ModuleKind.Node16 <= moduleKind && moduleKind <= ModuleKind.NodeNext */ TODO {
            usageMode := getEmitSyntaxForModuleSpecifierExpression(usage)
             /* TODO(BinaryExpression): usageMode === ModuleKind.ESNext && endsWith((usage as StringLiteralLike).text, Extension.Json) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    canHaveSyntheticDefault := func(file *SourceFile, moduleSymbol Symbol, dontResolveAlias bool, usage Expression) /* TODO(undefined): boolean */ TODO {
        usageMode := /* TODO(BinaryExpression): file && getEmitSyntaxForModuleSpecifierExpression(usage) */ TODO
        if /* TODO(BinaryExpression): file && usageMode !== undefined */ TODO {
            targetMode := /* TODO(PropertyAccessExpression): host.getImpliedNodeFormatForEmit */ TODO(file)
            if /* TODO(BinaryExpression): usageMode === ModuleKind.ESNext && targetMode === ModuleKind.CommonJS && ModuleKind.Node16 <= moduleKind && moduleKind <= ModuleKind.NodeNext */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            if /* TODO(BinaryExpression): usageMode === ModuleKind.ESNext && targetMode === ModuleKind.ESNext */ TODO {
                 /* TODO(FalseKeyword): false */ TODO
            }
        }
        if /* TODO(PrefixUnaryExpression): !allowSyntheticDefaultImports */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): !file || file.isDeclarationFile */ TODO {
            defaultExportSymbol := resolveExportByName(moduleSymbol, /* TODO(PropertyAccessExpression): InternalSymbolName.Default */ TODO, undefined, /* TODO(TrueKeyword): true */ TODO)
            if /* TODO(BinaryExpression): defaultExportSymbol && some(defaultExportSymbol.declarations, isSyntacticDefault) */ TODO {
                 /* TODO(FalseKeyword): false */ TODO
            }
            if resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), undefined, dontResolveAlias) {
                 /* TODO(FalseKeyword): false */ TODO
            }
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(PrefixUnaryExpression): !isSourceFileJS(file) */ TODO {
             hasExportAssignmentSymbol(moduleSymbol)
        }
         /* TODO(BinaryExpression): typeof file.externalModuleIndicator !== "object" && !resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), /*sourceNode* / undefined, dontResolveAlias) */ TODO
    }
    getTargetOfImportClause := func(node ImportClause, dontResolveAlias bool) *Symbol {
        moduleSymbol := resolveExternalModuleName(node, /* TODO(PropertyAccessExpression): node.parent.moduleSpecifier */ TODO)
        if moduleSymbol {
             getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
        }
    }
    getTargetofModuleDefault := func(moduleSymbol Symbol, node /* TODO(UnionType): ImportClause | ImportOrExportSpecifier */ any, dontResolveAlias bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        var exportDefaultSymbol *Symbol
        if isShorthandAmbientModuleSymbol(moduleSymbol) {
            /* TODO(ExpressionStatement): exportDefaultSymbol = moduleSymbol; */
        } else {
            /* TODO(ExpressionStatement): exportDefaultSymbol = resolveExportByName(moduleSymbol, InternalSymbolName.Default, node, dontResolveAlias); */
        }
        file := /* TODO(PropertyAccessExpression): moduleSymbol.declarations?.find */ TODO(isSourceFile)
        specifier := getModuleSpecifierForImportOrExport(node)
        if /* TODO(PrefixUnaryExpression): !specifier */ TODO {
             exportDefaultSymbol
        }
        hasDefaultOnly := isOnlyImportableAsDefault(specifier)
        hasSyntheticDefault := canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, specifier)
        if /* TODO(BinaryExpression): !exportDefaultSymbol && !hasSyntheticDefault && !hasDefaultOnly */ TODO {
            if /* TODO(BinaryExpression): hasExportAssignmentSymbol(moduleSymbol) && !allowSyntheticDefaultImports */ TODO {
                compilerOptionName := /* TODO(ConditionalExpression): moduleKind >= ModuleKind.ES2015 ? "allowSyntheticDefaultImports" : "esModuleInterop" */ TODO
                exportEqualsSymbol := /* TODO(PropertyAccessExpression): moduleSymbol.exports!.get */ TODO(/* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO)
                exportAssignment := /* TODO(PropertyAccessExpression): exportEqualsSymbol!.valueDeclaration */ TODO
                err := error(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Module_0_can_only_be_default_imported_using_the_1_flag */ TODO, symbolToString(moduleSymbol), compilerOptionName)
                if exportAssignment {
                    /* TODO(ExpressionStatement): addRelatedInfo(                         err,                         createDiagnosticForNode(                             exportAssignment,                             Diagnostics.This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag,                             compilerOptionName,                         ),                     ); */
                }
            } else if isImportClause(node) {
                /* TODO(ExpressionStatement): reportNonDefaultExport(moduleSymbol, node); */
            } else {
                /* TODO(ExpressionStatement): errorNoModuleMemberSymbol(moduleSymbol, moduleSymbol, node, isImportOrExportSpecifier(node) && node.propertyName || node.name); */
            }
        } else if /* TODO(BinaryExpression): hasSyntheticDefault || hasDefaultOnly */ TODO {
            resolved := /* TODO(BinaryExpression): resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias) */ TODO
            /* TODO(ExpressionStatement): markSymbolOfAliasDeclarationIfTypeOnly(node, moduleSymbol, resolved, /*overwriteEmpty* / false); */
             resolved
        }
        /* TODO(ExpressionStatement): markSymbolOfAliasDeclarationIfTypeOnly(node, exportDefaultSymbol, /*finalTarget* / undefined, /*overwriteEmpty* / false); */
         exportDefaultSymbol
    }
    getModuleSpecifierForImportOrExport := func(node /* TODO(UnionType): ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportOrExportSpecifier */ any) *Expression {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ImportClause:                 return node.parent.moduleSpecifier;             case SyntaxKind.ImportEqualsDeclaration:                 return isExternalModuleReference(node.moduleReference) ? node.moduleReference.expression : undefined;             case SyntaxKind.NamespaceImport:                 return node.parent.parent.moduleSpecifier;             case SyntaxKind.ImportSpecifier:                 return node.parent.parent.parent.moduleSpecifier;             case SyntaxKind.ExportSpecifier:                 return node.parent.parent.moduleSpecifier;             default:                 return Debug.assertNever(node);         } */
    }
    reportNonDefaultExport := func(moduleSymbol Symbol, node ImportClause) {
        if /* TODO(PropertyAccessExpression): moduleSymbol.exports?.has */ TODO(/* TODO(PropertyAccessExpression): node.symbol.escapedName */ TODO) {
            /* TODO(ExpressionStatement): error(                 node.name,                 Diagnostics.Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead,                 symbolToString(moduleSymbol),                 symbolToString(node.symbol),             ); */
        } else {
            diagnostic := error(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Module_0_has_no_default_export */ TODO, symbolToString(moduleSymbol))
            exportStar := /* TODO(PropertyAccessExpression): moduleSymbol.exports?.get */ TODO(/* TODO(PropertyAccessExpression): InternalSymbolName.ExportStar */ TODO)
            if exportStar {
                defaultExport := /* TODO(PropertyAccessExpression): exportStar.declarations?.find */ TODO(/* TODO(ArrowFunction): decl =>                     !!(                         isExportDeclaration(decl) && decl.moduleSpecifier &&                         resolveExternalModuleName(decl, decl.moduleSpecifier)?.exports?.has(InternalSymbolName.Default)                     ) */ TODO)
                if defaultExport {
                    /* TODO(ExpressionStatement): addRelatedInfo(diagnostic, createDiagnosticForNode(defaultExport, Diagnostics.export_Asterisk_does_not_re_export_a_default)); */
                }
            }
        }
    }
    getTargetOfNamespaceImport := func(node NamespaceImport, dontResolveAlias bool) *Symbol {
        moduleSpecifier := /* TODO(PropertyAccessExpression): node.parent.parent.moduleSpecifier */ TODO
        immediate := resolveExternalModuleName(node, moduleSpecifier)
        resolved := resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, /* TODO(FalseKeyword): false */ TODO)
        /* TODO(ExpressionStatement): markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, /*overwriteEmpty* / false); */
         resolved
    }
    getTargetOfNamespaceExport := func(node NamespaceExport, dontResolveAlias bool) *Symbol {
        moduleSpecifier := /* TODO(PropertyAccessExpression): node.parent.moduleSpecifier */ TODO
        immediate := /* TODO(BinaryExpression): moduleSpecifier && resolveExternalModuleName(node, moduleSpecifier) */ TODO
        resolved := /* TODO(BinaryExpression): moduleSpecifier && resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, /*suppressInteropError* / false) */ TODO
        /* TODO(ExpressionStatement): markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, /*overwriteEmpty* / false); */
         resolved
    }
    combineValueAndTypeSymbols := func(valueSymbol Symbol, typeSymbol Symbol) Symbol {
        if /* TODO(BinaryExpression): valueSymbol === unknownSymbol && typeSymbol === unknownSymbol */ TODO {
             unknownSymbol
        }
        if /* TODO(BinaryExpression): valueSymbol.flags & (SymbolFlags.Type | SymbolFlags.Namespace) */ TODO {
             valueSymbol
        }
        result := createSymbol(/* TODO(BinaryExpression): valueSymbol.flags | typeSymbol.flags */ TODO, /* TODO(PropertyAccessExpression): valueSymbol.escapedName */ TODO)
        /* TODO(ExpressionStatement): Debug.assert(valueSymbol.declarations || typeSymbol.declarations); */
        /* TODO(ExpressionStatement): result.declarations = deduplicate(concatenate(valueSymbol.declarations!, typeSymbol.declarations), equateValues); */
        /* TODO(ExpressionStatement): result.parent = valueSymbol.parent || typeSymbol.parent; */
        if /* TODO(PropertyAccessExpression): valueSymbol.valueDeclaration */ TODO {
            /* TODO(BinaryExpression): result.valueDeclaration = valueSymbol.valueDeclaration */
        }
        if /* TODO(PropertyAccessExpression): typeSymbol.members */ TODO {
            /* TODO(BinaryExpression): result.members = new Map(typeSymbol.members) */
        }
        if /* TODO(PropertyAccessExpression): valueSymbol.exports */ TODO {
            /* TODO(BinaryExpression): result.exports = new Map(valueSymbol.exports) */
        }
         result
    }
    getExportOfModule := func(symbol Symbol, nameText __String, specifier Declaration, dontResolveAlias bool) *Symbol {
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Module */ TODO {
            exportSymbol := /* TODO(PropertyAccessExpression): getExportsOfSymbol(symbol).get */ TODO(nameText)
            resolved := resolveSymbol(exportSymbol, dontResolveAlias)
            exportStarDeclaration := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).typeOnlyExportStarMap?.get */ TODO(nameText)
            /* TODO(ExpressionStatement): markSymbolOfAliasDeclarationIfTypeOnly(specifier, exportSymbol, resolved, /*overwriteEmpty* / false, exportStarDeclaration, nameText); */
             resolved
        }
    }
    getPropertyOfVariable := func(symbol Symbol, name __String) *Symbol {
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Variable */ TODO {
            typeAnnotation := /* TODO(PropertyAccessExpression): (symbol.valueDeclaration as VariableDeclaration).type */ TODO
            if typeAnnotation {
                 resolveSymbol(getPropertyOfType(getTypeFromTypeNode(typeAnnotation), name))
            }
        }
    }
    getExternalModuleMember := func(node /* TODO(UnionType): ImportDeclaration | ExportDeclaration | VariableDeclaration | JSDocImportTag */ any, specifier /* TODO(UnionType): ImportOrExportSpecifier | BindingElement | PropertyAccessExpression */ any, dontResolveAlias /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) *Symbol {
        moduleSpecifier := /* TODO(BinaryExpression): getExternalModuleRequireArgument(node) || (node as ImportDeclaration | ExportDeclaration | JSDocImportTag).moduleSpecifier! */ TODO
        moduleSymbol := /* TODO(NonNullExpression): resolveExternalModuleName(node, moduleSpecifier)! */ TODO
        name := /* TODO(BinaryExpression): !isPropertyAccessExpression(specifier) && specifier.propertyName || specifier.name */ TODO
        if /* TODO(BinaryExpression): !isIdentifier(name) && name.kind !== SyntaxKind.StringLiteral */ TODO {
             undefined
        }
        nameText := moduleExportNameTextEscaped(name)
        suppressInteropError := /* TODO(BinaryExpression): nameText === InternalSymbolName.Default && allowSyntheticDefaultImports */ TODO
        targetSymbol := resolveESModuleSymbol(moduleSymbol, moduleSpecifier, /* TODO(FalseKeyword): false */ TODO, suppressInteropError)
        if targetSymbol {
            if /* TODO(BinaryExpression): nameText || name.kind === SyntaxKind.StringLiteral */ TODO {
                if isShorthandAmbientModuleSymbol(moduleSymbol) {
                     moduleSymbol
                }
                var symbolFromVariable *Symbol
                if /* TODO(BinaryExpression): moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get(InternalSymbolName.ExportEquals) */ TODO {
                    /* TODO(ExpressionStatement): symbolFromVariable = getPropertyOfType(getTypeOfSymbol(targetSymbol), nameText, /*skipObjectFunctionPropertyAugment* / true); */
                } else {
                    /* TODO(ExpressionStatement): symbolFromVariable = getPropertyOfVariable(targetSymbol, nameText); */
                }
                /* TODO(ExpressionStatement): symbolFromVariable = resolveSymbol(symbolFromVariable, dontResolveAlias); */
                symbolFromModule := getExportOfModule(targetSymbol, nameText, specifier, dontResolveAlias)
                if /* TODO(BinaryExpression): symbolFromModule === undefined && nameText === InternalSymbolName.Default */ TODO {
                    file := /* TODO(PropertyAccessExpression): moduleSymbol.declarations?.find */ TODO(isSourceFile)
                    if /* TODO(BinaryExpression): isOnlyImportableAsDefault(moduleSpecifier) || canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, moduleSpecifier) */ TODO {
                        /* TODO(ExpressionStatement): symbolFromModule = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias); */
                    }
                }
                symbol := /* TODO(ConditionalExpression): symbolFromModule && symbolFromVariable && symbolFromModule !== symbolFromVariable ?                     combineValueAndTypeSymbols(symbolFromVariable, symbolFromModule) :                     symbolFromModule || symbolFromVariable */ TODO
                if /* TODO(PrefixUnaryExpression): !symbol */ TODO {
                    /* TODO(ExpressionStatement): errorNoModuleMemberSymbol(moduleSymbol, targetSymbol, node, name); */
                }
                 symbol
            }
        }
    }
    errorNoModuleMemberSymbol := func(moduleSymbol Symbol, targetSymbol Symbol, node Node, name ModuleExportName) {
        moduleName := getFullyQualifiedName(moduleSymbol, node)
        declarationName := declarationNameToString(name)
        suggestion := /* TODO(ConditionalExpression): isIdentifier(name) ? getSuggestedSymbolForNonexistentModule(name, targetSymbol) : undefined */ TODO
        if /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
            suggestionName := symbolToString(suggestion)
            diagnostic := error(name, /* TODO(PropertyAccessExpression): Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2 */ TODO, moduleName, declarationName, suggestionName)
            if /* TODO(PropertyAccessExpression): suggestion.valueDeclaration */ TODO {
                /* TODO(ExpressionStatement): addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName)); */
            }
        } else {
            if /* TODO(PropertyAccessExpression): moduleSymbol.exports?.has */ TODO(/* TODO(PropertyAccessExpression): InternalSymbolName.Default */ TODO) {
                /* TODO(ExpressionStatement): error(                     name,                     Diagnostics.Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead,                     moduleName,                     declarationName,                 ); */
            } else {
                /* TODO(ExpressionStatement): reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName); */
            }
        }
    }
    reportNonExportedMember := func(node Node, name ModuleExportName, declarationName string, moduleSymbol Symbol, moduleName string) {
        localSymbol := /* TODO(PropertyAccessExpression): tryCast(moduleSymbol.valueDeclaration, canHaveLocals)?.locals?.get */ TODO(moduleExportNameTextEscaped(name))
        exports := /* TODO(PropertyAccessExpression): moduleSymbol.exports */ TODO
        if localSymbol {
            exportedEqualsSymbol := /* TODO(PropertyAccessExpression): exports?.get */ TODO(/* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO)
            if exportedEqualsSymbol {
                /* TODO(ExpressionStatement): getSymbolIfSameReference(exportedEqualsSymbol, localSymbol) ? reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName) :                     error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName); */
            } else {
                exportedSymbol := /* TODO(ConditionalExpression): exports ? find(symbolsToArray(exports), symbol => !!getSymbolIfSameReference(symbol, localSymbol)) : undefined */ TODO
                diagnostic := /* TODO(ConditionalExpression): exportedSymbol ? error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_exported_as_2, moduleName, declarationName, symbolToString(exportedSymbol)) :                     error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_not_exported, moduleName, declarationName) */ TODO
                if /* TODO(PropertyAccessExpression): localSymbol.declarations */ TODO {
                    /* TODO(ExpressionStatement): addRelatedInfo(diagnostic, ...map(localSymbol.declarations, (decl, index) => createDiagnosticForNode(decl, index === 0 ? Diagnostics._0_is_declared_here : Diagnostics.and_here, declarationName))); */
                }
            }
        } else {
            /* TODO(ExpressionStatement): error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName); */
        }
    }
    reportInvalidImportEqualsExportMember := func(node Node, name ModuleExportName, declarationName string, moduleName string) {
        if /* TODO(BinaryExpression): moduleKind >= ModuleKind.ES2015 */ TODO {
            message := /* TODO(ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_default_import :                 Diagnostics._0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
            /* TODO(ExpressionStatement): error(name, message, declarationName); */
        } else {
            if isInJSFile(node) {
                message := /* TODO(ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import :                     Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
                /* TODO(ExpressionStatement): error(name, message, declarationName); */
            } else {
                message := /* TODO(ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import :                     Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
                /* TODO(ExpressionStatement): error(name, message, declarationName, declarationName, moduleName); */
            }
        }
    }
    getTargetOfImportSpecifier := func(node /* TODO(UnionType): ImportSpecifier | BindingElement */ any, dontResolveAlias bool) *Symbol {
        if /* TODO(BinaryExpression): isImportSpecifier(node) && moduleExportNameIsDefault(node.propertyName || node.name) */ TODO {
            specifier := getModuleSpecifierForImportOrExport(node)
            moduleSymbol := /* TODO(BinaryExpression): specifier && resolveExternalModuleName(node, specifier) */ TODO
            if moduleSymbol {
                 getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
            }
        }
        root := /* TODO(ConditionalExpression): isBindingElement(node) ? getRootDeclaration(node) as VariableDeclaration : node.parent.parent.parent */ TODO
        commonJSPropertyAccess := getCommonJSPropertyAccess(root)
        resolved := getExternalModuleMember(root, /* TODO(BinaryExpression): commonJSPropertyAccess || node */ TODO, dontResolveAlias)
        name := /* TODO(BinaryExpression): node.propertyName || node.name */ TODO
        if /* TODO(BinaryExpression): commonJSPropertyAccess && resolved && isIdentifier(name) */ TODO {
             resolveSymbol(getPropertyOfType(getTypeOfSymbol(resolved), /* TODO(PropertyAccessExpression): name.escapedText */ TODO), dontResolveAlias)
        }
        /* TODO(ExpressionStatement): markSymbolOfAliasDeclarationIfTypeOnly(node, /*immediateTarget* / undefined, resolved, /*overwriteEmpty* / false); */
         resolved
    }
    getCommonJSPropertyAccess := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyAccessExpression | undefined */ TODO {
        if /* TODO(BinaryExpression): isVariableDeclaration(node) && node.initializer && isPropertyAccessExpression(node.initializer) */ TODO {
             /* TODO(PropertyAccessExpression): node.initializer */ TODO
        }
    }
    getTargetOfNamespaceExportDeclaration := func(node NamespaceExportDeclaration, dontResolveAlias bool) *Symbol {
        if canHaveSymbol(/* TODO(PropertyAccessExpression): node.parent */ TODO) {
            resolved := resolveExternalModuleSymbol(/* TODO(PropertyAccessExpression): node.parent.symbol */ TODO, dontResolveAlias)
            /* TODO(ExpressionStatement): markSymbolOfAliasDeclarationIfTypeOnly(node, /*immediateTarget* / undefined, resolved, /*overwriteEmpty* / false); */
             resolved
        }
    }
    getTargetOfExportSpecifier := func(node ExportSpecifier, meaning SymbolFlags, dontResolveAlias bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        name := /* TODO(BinaryExpression): node.propertyName || node.name */ TODO
        if moduleExportNameIsDefault(name) {
            specifier := getModuleSpecifierForImportOrExport(node)
            moduleSymbol := /* TODO(BinaryExpression): specifier && resolveExternalModuleName(node, specifier) */ TODO
            if moduleSymbol {
                 getTargetofModuleDefault(moduleSymbol, node, /* TODO(PrefixUnaryExpression): !!dontResolveAlias */ TODO)
            }
        }
        resolved := /* TODO(ConditionalExpression): node.parent.parent.moduleSpecifier ?             getExternalModuleMember(node.parent.parent, node, dontResolveAlias) :             name.kind === SyntaxKind.StringLiteral ? undefined : // Skip for invalid syntax like this: export { "x" }             resolveEntityName(name, meaning, /*ignoreErrors* / false, dontResolveAlias) */ TODO
        /* TODO(ExpressionStatement): markSymbolOfAliasDeclarationIfTypeOnly(node, /*immediateTarget* / undefined, resolved, /*overwriteEmpty* / false); */
         resolved
    }
    getTargetOfExportAssignment := func(node /* TODO(UnionType): ExportAssignment | BinaryExpression */ any, dontResolveAlias bool) *Symbol {
        expression := /* TODO(ConditionalExpression): isExportAssignment(node) ? node.expression : node.right */ TODO
        resolved := getTargetOfAliasLikeExpression(expression, dontResolveAlias)
        /* TODO(ExpressionStatement): markSymbolOfAliasDeclarationIfTypeOnly(node, /*immediateTarget* / undefined, resolved, /*overwriteEmpty* / false); */
         resolved
    }
    getTargetOfAliasLikeExpression := func(expression Expression, dontResolveAlias bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        if isClassExpression(expression) {
             /* TODO(PropertyAccessExpression): checkExpressionCached(expression).symbol */ TODO
        }
        if /* TODO(BinaryExpression): !isEntityName(expression) && !isEntityNameExpression(expression) */ TODO {
             undefined
        }
        aliasLike := resolveEntityName(expression, /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace */ TODO, /* TODO(TrueKeyword): true */ TODO, dontResolveAlias)
        if aliasLike {
             aliasLike
        }
        /* TODO(ExpressionStatement): checkExpressionCached(expression); */
         /* TODO(PropertyAccessExpression): getNodeLinks(expression).resolvedSymbol */ TODO
    }
    getTargetOfAccessExpression := func(node AccessExpression, dontRecursivelyResolve bool) *Symbol {
        if /* TODO(PrefixUnaryExpression): !(isBinaryExpression(node.parent) && node.parent.left === node && node.parent.operatorToken.kind === SyntaxKind.EqualsToken) */ TODO {
             undefined
        }
         getTargetOfAliasLikeExpression(/* TODO(PropertyAccessExpression): node.parent.right */ TODO, dontRecursivelyResolve)
    }
    getTargetOfAliasDeclaration := func(node Declaration, dontRecursivelyResolve /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) *Symbol {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ImportEqualsDeclaration:             case SyntaxKind.VariableDeclaration:                 return getTargetOfImportEqualsDeclaration(node as ImportEqualsDeclaration | VariableDeclaration, dontRecursivelyResolve);             case SyntaxKind.ImportClause:                 return getTargetOfImportClause(node as ImportClause, dontRecursivelyResolve);             case SyntaxKind.NamespaceImport:                 return getTargetOfNamespaceImport(node as NamespaceImport, dontRecursivelyResolve);             case SyntaxKind.NamespaceExport:                 return getTargetOfNamespaceExport(node as NamespaceExport, dontRecursivelyResolve);             case SyntaxKind.ImportSpecifier:             case SyntaxKind.BindingElement:                 return getTargetOfImportSpecifier(node as ImportSpecifier | BindingElement, dontRecursivelyResolve);             case SyntaxKind.ExportSpecifier:                 return getTargetOfExportSpecifier(node as ExportSpecifier, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, dontRecursivelyResolve);             case SyntaxKind.ExportAssignment:             case SyntaxKind.BinaryExpression:                 return getTargetOfExportAssignment(node as ExportAssignment | BinaryExpression, dontRecursivelyResolve);             case SyntaxKind.NamespaceExportDeclaration:                 return getTargetOfNamespaceExportDeclaration(node as NamespaceExportDeclaration, dontRecursivelyResolve);             case SyntaxKind.ShorthandPropertyAssignment:                 return resolveEntityName((node as ShorthandPropertyAssignment).name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*ignoreErrors* / true, dontRecursivelyResolve);             case SyntaxKind.PropertyAssignment:                 return getTargetOfAliasLikeExpression((node as PropertyAssignment).initializer, dontRecursivelyResolve);             case SyntaxKind.ElementAccessExpression:             case SyntaxKind.PropertyAccessExpression:                 return getTargetOfAccessExpression(node as AccessExpression, dontRecursivelyResolve);             default:                 return Debug.fail();         } */
    }
    isNonLocalAlias := func(symbol *Symbol, excludes /* TODO(undefined): number */ TODO /* = */ /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace */) /* TODO(TypePredicate): symbol is Symbol */ TODO {
        if /* TODO(PrefixUnaryExpression): !symbol */ TODO {
            /* TODO(FalseKeyword): false */
        }
         /* TODO(BinaryExpression): (symbol.flags & (SymbolFlags.Alias | excludes)) === SymbolFlags.Alias || !!(symbol.flags & SymbolFlags.Alias && symbol.flags & SymbolFlags.Assignment) */ TODO
    }
    // OVERLOAD: resolveSymbol := func(symbol Symbol, dontResolveAlias bool) Symbol
    // OVERLOAD: resolveSymbol := func(symbol *Symbol, dontResolveAlias bool) *Symbol
    resolveSymbol := func(symbol *Symbol, dontResolveAlias bool) *Symbol {
         /* TODO(ConditionalExpression): !dontResolveAlias && isNonLocalAlias(symbol) ? resolveAlias(symbol) : symbol */ TODO
    }
    resolveAlias := func(symbol Symbol) Symbol {
        /* TODO(ExpressionStatement): Debug.assert((symbol.flags & SymbolFlags.Alias) !== 0, "Should only get Alias here."); */
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.aliasTarget */ TODO {
            /* TODO(ExpressionStatement): links.aliasTarget = resolvingSymbol; */
            node := getDeclarationOfAliasSymbol(symbol)
            if /* TODO(PrefixUnaryExpression): !node */ TODO {
                /* TODO(CallExpression): Debug.fail() */
            }
            target := getTargetOfAliasDeclaration(node)
            if /* TODO(BinaryExpression): links.aliasTarget === resolvingSymbol */ TODO {
                /* TODO(ExpressionStatement): links.aliasTarget = target || unknownSymbol; */
            } else {
                /* TODO(ExpressionStatement): error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol)); */
            }
        } else if /* TODO(BinaryExpression): links.aliasTarget === resolvingSymbol */ TODO {
            /* TODO(ExpressionStatement): links.aliasTarget = unknownSymbol; */
        }
         /* TODO(PropertyAccessExpression): links.aliasTarget */ TODO
    }
    tryResolveAlias := func(symbol Symbol) *Symbol {
        links := getSymbolLinks(symbol)
        if /* TODO(BinaryExpression): links.aliasTarget !== resolvingSymbol */ TODO {
             resolveAlias(symbol)
        }
         undefined
    }
    getSymbolFlags := func(symbol Symbol, excludeTypeOnlyMeanings bool, excludeLocalMeanings bool) SymbolFlags {
        typeOnlyDeclaration := /* TODO(BinaryExpression): excludeTypeOnlyMeanings && getTypeOnlyAliasDeclaration(symbol) */ TODO
        typeOnlyDeclarationIsExportStar := /* TODO(BinaryExpression): typeOnlyDeclaration && isExportDeclaration(typeOnlyDeclaration) */ TODO
        typeOnlyResolution := /* TODO(BinaryExpression): typeOnlyDeclaration && (             typeOnlyDeclarationIsExportStar                 ? resolveExternalModuleName(typeOnlyDeclaration.moduleSpecifier, typeOnlyDeclaration.moduleSpecifier, /*ignoreErrors* / true)                 : resolveAlias(typeOnlyDeclaration.symbol)         ) */ TODO
        typeOnlyExportStarTargets := /* TODO(ConditionalExpression): typeOnlyDeclarationIsExportStar && typeOnlyResolution ? getExportsOfModule(typeOnlyResolution) : undefined */ TODO
        flags := /* TODO(ConditionalExpression): excludeLocalMeanings ? SymbolFlags.None : symbol.flags */ TODO
        seenSymbols
        /* TODO(WhileStatement): while (symbol.flags & SymbolFlags.Alias) {             const target = getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol));             if (                 !typeOnlyDeclarationIsExportStar && target === typeOnlyResolution ||                 typeOnlyExportStarTargets?.get(target.escapedName) === target             ) {                 break;             }             if (target === unknownSymbol) {                 return SymbolFlags.All;             }              // Optimizations - try to avoid creating or adding to             // `seenSymbols` if possible             if (target === symbol || seenSymbols?.has(target)) {                 break;             }             if (target.flags & SymbolFlags.Alias) {                 if (seenSymbols) {                     seenSymbols.add(target);                 }                 else {                     seenSymbols = new Set([symbol, target]);                 }             }             flags |= target.flags;             symbol = target;         } */
         flags
    }
    markSymbolOfAliasDeclarationIfTypeOnly := func(aliasDeclaration Declaration, immediateTarget *Symbol, finalTarget *Symbol, overwriteEmpty bool, exportStarDeclaration /* TODO(IntersectionType): ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */ TODO, exportStarName __String) bool {
        if /* TODO(BinaryExpression): !aliasDeclaration || isPropertyAccessExpression(aliasDeclaration) */ TODO {
            /* TODO(FalseKeyword): false */
        }
        sourceSymbol := getSymbolOfDeclaration(aliasDeclaration)
        if isTypeOnlyImportOrExportDeclaration(aliasDeclaration) {
            links := getSymbolLinks(sourceSymbol)
            /* TODO(ExpressionStatement): links.typeOnlyDeclaration = aliasDeclaration; */
             /* TODO(TrueKeyword): true */ TODO
        }
        if exportStarDeclaration {
            links := getSymbolLinks(sourceSymbol)
            /* TODO(ExpressionStatement): links.typeOnlyDeclaration = exportStarDeclaration; */
            if /* TODO(BinaryExpression): sourceSymbol.escapedName !== exportStarName */ TODO {
                /* TODO(ExpressionStatement): links.typeOnlyExportStarName = exportStarName; */
            }
             /* TODO(TrueKeyword): true */ TODO
        }
        links := getSymbolLinks(sourceSymbol)
         /* TODO(BinaryExpression): markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, immediateTarget, overwriteEmpty)             || markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, finalTarget, overwriteEmpty) */ TODO
    }
    markSymbolOfAliasDeclarationIfTypeOnlyWorker := func(aliasDeclarationLinks SymbolLinks, target *Symbol, overwriteEmpty bool) bool {
        if /* TODO(BinaryExpression): target && (aliasDeclarationLinks.typeOnlyDeclaration === undefined || overwriteEmpty && aliasDeclarationLinks.typeOnlyDeclaration === false) */ TODO {
            exportSymbol := /* TODO(BinaryExpression): target.exports?.get(InternalSymbolName.ExportEquals) ?? target */ TODO
            typeOnly := /* TODO(BinaryExpression): exportSymbol.declarations && find(exportSymbol.declarations, isTypeOnlyImportOrExportDeclaration) */ TODO
            /* TODO(ExpressionStatement): aliasDeclarationLinks.typeOnlyDeclaration = typeOnly ?? getSymbolLinks(exportSymbol).typeOnlyDeclaration ?? false; */
        }
         /* TODO(PrefixUnaryExpression): !!aliasDeclarationLinks.typeOnlyDeclaration */ TODO
    }
    getTypeOnlyAliasDeclaration := func(symbol Symbol, include SymbolFlags) *TypeOnlyAliasDeclaration {
        if /* TODO(PrefixUnaryExpression): !(symbol.flags & SymbolFlags.Alias) */ TODO {
             undefined
        }
        links := getSymbolLinks(symbol)
        if /* TODO(BinaryExpression): links.typeOnlyDeclaration === undefined */ TODO {
            /* TODO(ExpressionStatement): links.typeOnlyDeclaration = false; */
            resolved := resolveSymbol(symbol)
            /* TODO(ExpressionStatement): markSymbolOfAliasDeclarationIfTypeOnly(symbol.declarations?.[0], getDeclarationOfAliasSymbol(symbol) && getImmediateAliasedSymbol(symbol), resolved, /*overwriteEmpty* / true); */
        }
        if /* TODO(BinaryExpression): include === undefined */ TODO {
             /* TODO(BinaryExpression): links.typeOnlyDeclaration || undefined */ TODO
        }
        if /* TODO(PropertyAccessExpression): links.typeOnlyDeclaration */ TODO {
            resolved := /* TODO(ConditionalExpression): links.typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration                 ? resolveSymbol(getExportsOfModule(links.typeOnlyDeclaration.symbol.parent!).get(links.typeOnlyExportStarName || symbol.escapedName))!                 : resolveAlias(links.typeOnlyDeclaration.symbol) */ TODO
             /* TODO(ConditionalExpression): getSymbolFlags(resolved) & include ? links.typeOnlyDeclaration : undefined */ TODO
        }
         undefined
    }
    getSymbolOfPartOfRightHandSideOfImportEquals := func(entityName EntityName, dontResolveAlias bool) *Symbol {
        if /* TODO(BinaryExpression): entityName.kind === SyntaxKind.Identifier && isRightSideOfQualifiedNameOrPropertyAccess(entityName) */ TODO {
            /* TODO(ExpressionStatement): entityName = entityName.parent as QualifiedName; */
        }
        if /* TODO(BinaryExpression): entityName.kind === SyntaxKind.Identifier || entityName.parent.kind === SyntaxKind.QualifiedName */ TODO {
             resolveEntityName(entityName, /* TODO(PropertyAccessExpression): SymbolFlags.Namespace */ TODO, /* TODO(FalseKeyword): false */ TODO, dontResolveAlias)
        } else {
            /* TODO(ExpressionStatement): Debug.assert(entityName.parent.kind === SyntaxKind.ImportEqualsDeclaration); */
             resolveEntityName(entityName, /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace */ TODO, /* TODO(FalseKeyword): false */ TODO, dontResolveAlias)
        }
    }
    getFullyQualifiedName := func(symbol Symbol, containingLocation Node) string {
         /* TODO(ConditionalExpression): symbol.parent ? getFullyQualifiedName(symbol.parent, containingLocation) + "." + symbolToString(symbol) : symbolToString(symbol, containingLocation, /*meaning* / undefined, SymbolFormatFlags.DoNotIncludeSymbolChain | SymbolFormatFlags.AllowAnyNodeKind) */ TODO
    }
    getContainingQualifiedNameNode := func(node QualifiedName) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").QualifiedName */ TODO {
        /* TODO(WhileStatement): while (isQualifiedName(node.parent)) {             node = node.parent;         } */
         node
    }
    tryGetQualifiedNameAsValue := func(node QualifiedName) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        var left /* TODO(UnionType): Identifier | QualifiedName */ any = getFirstIdentifier(node)
        symbol := resolveName(left, left, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO, undefined, /* TODO(TrueKeyword): true */ TODO)
        if /* TODO(PrefixUnaryExpression): !symbol */ TODO {
             undefined
        }
        /* TODO(WhileStatement): while (isQualifiedName(left.parent)) {             const type = getTypeOfSymbol(symbol);             symbol = getPropertyOfType(type, left.parent.right.escapedText);             if (!symbol) {                 return undefined;             }             left = left.parent;         } */
         symbol
    }
    resolveEntityName := func(name EntityNameOrEntityNameExpression, meaning SymbolFlags, ignoreErrors bool, dontResolveAlias bool, location Node) *Symbol {
        if nodeIsMissing(name) {
             undefined
        }
        namespaceMeaning := /* TODO(BinaryExpression): SymbolFlags.Namespace | (isInJSFile(name) ? meaning & SymbolFlags.Value : 0) */ TODO
        var symbol *Symbol
        if /* TODO(BinaryExpression): name.kind === SyntaxKind.Identifier */ TODO {
            message := /* TODO(ConditionalExpression): meaning === namespaceMeaning || nodeIsSynthesized(name) ? Diagnostics.Cannot_find_namespace_0 : getCannotFindNameDiagnosticForName(getFirstIdentifier(name)) */ TODO
            symbolFromJSPrototype := /* TODO(ConditionalExpression): isInJSFile(name) && !nodeIsSynthesized(name) ? resolveEntityNameFromAssignmentDeclaration(name, meaning) : undefined */ TODO
            /* TODO(ExpressionStatement): symbol = getMergedSymbol(resolveName(location || name, name, meaning, ignoreErrors || symbolFromJSPrototype ? undefined : message, /*isUse* / true, /*excludeGlobals* / false)); */
            if /* TODO(PrefixUnaryExpression): !symbol */ TODO {
                 getMergedSymbol(symbolFromJSPrototype)
            }
        } else if /* TODO(BinaryExpression): name.kind === SyntaxKind.QualifiedName || name.kind === SyntaxKind.PropertyAccessExpression */ TODO {
            left := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.left : name.expression */ TODO
            right := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.right : name.name */ TODO
            namespace := resolveEntityName(left, namespaceMeaning, ignoreErrors, /* TODO(FalseKeyword): false */ TODO, location)
            if /* TODO(BinaryExpression): !namespace || nodeIsMissing(right) */ TODO {
                 undefined
            } else if /* TODO(BinaryExpression): namespace === unknownSymbol */ TODO {
                 namespace
            }
            if /* TODO(BinaryExpression): namespace.valueDeclaration &&                 isInJSFile(namespace.valueDeclaration) &&                 getEmitModuleResolutionKind(compilerOptions) !== ModuleResolutionKind.Bundler &&                 isVariableDeclaration(namespace.valueDeclaration) &&                 namespace.valueDeclaration.initializer &&                 isCommonJsRequire(namespace.valueDeclaration.initializer) */ TODO {
                moduleName := /* TODO(ElementAccessExpression): (namespace.valueDeclaration.initializer as CallExpression).arguments[0] */ TODO /* as */ /* TODO(TypeReference): StringLiteral */
                moduleSym := resolveExternalModuleName(moduleName, moduleName)
                if moduleSym {
                    resolvedModuleSymbol := resolveExternalModuleSymbol(moduleSym)
                    if resolvedModuleSymbol {
                        /* TODO(ExpressionStatement): namespace = resolvedModuleSymbol; */
                    }
                }
            }
            /* TODO(ExpressionStatement): symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, meaning)); */
            if /* TODO(BinaryExpression): !symbol && (namespace.flags & SymbolFlags.Alias) */ TODO {
                /* TODO(ExpressionStatement): symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(resolveAlias(namespace)), right.escapedText, meaning)); */
            }
            if /* TODO(PrefixUnaryExpression): !symbol */ TODO {
                if /* TODO(PrefixUnaryExpression): !ignoreErrors */ TODO {
                    namespaceName := getFullyQualifiedName(namespace)
                    declarationName := declarationNameToString(right)
                    suggestionForNonexistentModule := getSuggestedSymbolForNonexistentModule(right, namespace)
                    if suggestionForNonexistentModule {
                        /* TODO(ExpressionStatement): error(right, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, namespaceName, declarationName, symbolToString(suggestionForNonexistentModule)); */
                         undefined
                    }
                    containingQualifiedName := /* TODO(BinaryExpression): isQualifiedName(name) && getContainingQualifiedNameNode(name) */ TODO
                    canSuggestTypeof := /* TODO(BinaryExpression): globalObjectType // <-- can't pull on types if global types aren't initialized yet                         && (meaning & SymbolFlags.Type)                         && containingQualifiedName                         && !isTypeOfExpression(containingQualifiedName.parent)                         && tryGetQualifiedNameAsValue(containingQualifiedName) */ TODO
                    if canSuggestTypeof {
                        /* TODO(ExpressionStatement): error(                             containingQualifiedName,                             Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0,                             entityNameToString(containingQualifiedName),                         ); */
                         undefined
                    }
                    if /* TODO(BinaryExpression): meaning & SymbolFlags.Namespace && isQualifiedName(name.parent) */ TODO {
                        exportedTypeSymbol := getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), /* TODO(PropertyAccessExpression): right.escapedText */ TODO, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO))
                        if exportedTypeSymbol {
                            /* TODO(ExpressionStatement): error(                                 name.parent.right,                                 Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1,                                 symbolToString(exportedTypeSymbol),                                 unescapeLeadingUnderscores(name.parent.right.escapedText),                             ); */
                             undefined
                        }
                    }
                    /* TODO(ExpressionStatement): error(right, Diagnostics.Namespace_0_has_no_exported_member_1, namespaceName, declarationName); */
                }
                 undefined
            }
        } else {
            /* TODO(ExpressionStatement): Debug.assertNever(name, "Unknown entity name kind."); */
        }
        if /* TODO(BinaryExpression): !nodeIsSynthesized(name) && isEntityName(name) && (symbol.flags & SymbolFlags.Alias || name.parent.kind === SyntaxKind.ExportAssignment) */ TODO {
            /* TODO(ExpressionStatement): markSymbolOfAliasDeclarationIfTypeOnly(getAliasDeclarationFromName(name), symbol, /*finalTarget* / undefined, /*overwriteEmpty* / true); */
        }
         /* TODO(ConditionalExpression): (symbol.flags & meaning) || dontResolveAlias ? symbol : resolveAlias(symbol) */ TODO
    }
    resolveEntityNameFromAssignmentDeclaration := func(name Identifier, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        if isJSDocTypeReference(/* TODO(PropertyAccessExpression): name.parent */ TODO) {
            secondaryLocation := getAssignmentDeclarationLocation(/* TODO(PropertyAccessExpression): name.parent */ TODO)
            if secondaryLocation {
                 resolveName(secondaryLocation, name, meaning, undefined, /* TODO(TrueKeyword): true */ TODO)
            }
        }
    }
    getAssignmentDeclarationLocation := func(node TypeReferenceNode) Node {
        typeAlias := findAncestor(node, /* TODO(ArrowFunction): node => !(isJSDocNode(node) || node.flags & NodeFlags.JSDoc) ? "quit" : isJSDocTypeAlias(node) */ TODO)
        if typeAlias {

        }
        host := getJSDocHost(node)
        if /* TODO(BinaryExpression): host && isExpressionStatement(host) && isPrototypePropertyAssignment(host.expression) */ TODO {
            symbol := getSymbolOfDeclaration(/* TODO(PropertyAccessExpression): host.expression.left */ TODO)
            if symbol {
                 getDeclarationOfJSPrototypeContainer(symbol)
            }
        }
        if /* TODO(BinaryExpression): host && isFunctionExpression(host) && isPrototypePropertyAssignment(host.parent) && isExpressionStatement(host.parent.parent) */ TODO {
            symbol := getSymbolOfDeclaration(/* TODO(PropertyAccessExpression): host.parent.left */ TODO)
            if symbol {
                 getDeclarationOfJSPrototypeContainer(symbol)
            }
        }
        if /* TODO(BinaryExpression): host && (isObjectLiteralMethod(host) || isPropertyAssignment(host)) &&             isBinaryExpression(host.parent.parent) &&             getAssignmentDeclarationKind(host.parent.parent) === AssignmentDeclarationKind.Prototype */ TODO {
            symbol := getSymbolOfDeclaration(/* TODO(PropertyAccessExpression): host.parent.parent.left */ TODO /* as */ /* TODO(TypeReference): BindableStaticNameExpression */)
            if symbol {
                 getDeclarationOfJSPrototypeContainer(symbol)
            }
        }
        sig := getEffectiveJSDocHost(node)
        if /* TODO(BinaryExpression): sig && isFunctionLike(sig) */ TODO {
            symbol := getSymbolOfDeclaration(sig)
             /* TODO(BinaryExpression): symbol && symbol.valueDeclaration */ TODO
        }
    }
    getDeclarationOfJSPrototypeContainer := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration | undefined */ TODO {
        decl := /* TODO(PropertyAccessExpression): symbol.parent!.valueDeclaration */ TODO
        if /* TODO(PrefixUnaryExpression): !decl */ TODO {
             undefined
        }
        initializer := /* TODO(ConditionalExpression): isAssignmentDeclaration(decl) ? getAssignedExpandoInitializer(decl) :             hasOnlyExpressionInitializer(decl) ? getDeclaredExpandoInitializer(decl) :             undefined */ TODO
         /* TODO(BinaryExpression): initializer || decl */ TODO
    }
    getExpandoSymbol := func(symbol Symbol) *Symbol {
        decl := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
        if /* TODO(BinaryExpression): !decl || !isInJSFile(decl) || symbol.flags & SymbolFlags.TypeAlias || getExpandoInitializer(decl, /*isPrototypeAssignment* / false) */ TODO {
             undefined
        }
        init := /* TODO(ConditionalExpression): isVariableDeclaration(decl) ? getDeclaredExpandoInitializer(decl) : getAssignedExpandoInitializer(decl) */ TODO
        if init {
            initSymbol := getSymbolOfNode(init)
            if initSymbol {
                 mergeJSSymbols(initSymbol, symbol)
            }
        }
    }
    resolveExternalModuleName := func(location Node, moduleReferenceExpression Expression, ignoreErrors bool) *Symbol {
        isClassic := /* TODO(BinaryExpression): getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.Classic */ TODO
        errorMessage := /* TODO(ConditionalExpression): isClassic ?             Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option             : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations */ TODO
         resolveExternalModuleNameWorker(location, moduleReferenceExpression, /* TODO(ConditionalExpression): ignoreErrors ? undefined : errorMessage */ TODO, ignoreErrors)
    }
    resolveExternalModuleNameWorker := func(location Node, moduleReferenceExpression Expression, moduleNotFoundError *DiagnosticMessage, ignoreErrors /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, isForAugmentation /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) *Symbol {
         /* TODO(ConditionalExpression): isStringLiteralLike(moduleReferenceExpression)             ? resolveExternalModule(location, moduleReferenceExpression.text, moduleNotFoundError, !ignoreErrors ? moduleReferenceExpression : undefined, isForAugmentation)             : undefined */ TODO
    }
    resolveExternalModule := func(location Node, moduleReference string, moduleNotFoundError *DiagnosticMessage, errorNode Node, isForAugmentation /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) *Symbol {
        if /* TODO(BinaryExpression): errorNode && startsWith(moduleReference, "@types/") */ TODO {
            diag := /* TODO(PropertyAccessExpression): Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1 */ TODO
            withoutAtTypePrefix := removePrefix(moduleReference, "@types/")
            /* TODO(ExpressionStatement): error(errorNode, diag, withoutAtTypePrefix, moduleReference); */
        }
        ambientModule := tryFindAmbientModule(moduleReference, /* TODO(TrueKeyword): true */ TODO)
        if ambientModule {
             ambientModule
        }
        currentSourceFile := getSourceFileOfNode(location)
        contextSpecifier := /* TODO(ConditionalExpression): isStringLiteralLike(location)             ? location             : (isModuleDeclaration(location) ? location : location.parent && isModuleDeclaration(location.parent) && location.parent.name === location ? location.parent : undefined)?.name ||                 (isLiteralImportTypeNode(location) ? location : undefined)?.argument.literal ||                 (isInJSFile(location) && isJSDocImportTag(location) ? location.moduleSpecifier : undefined) ||                 (isVariableDeclaration(location) && location.initializer && isRequireCall(location.initializer, /*requireStringLiteralLikeArgument* / true) ? location.initializer.arguments[0] : undefined) ||                 findAncestor(location, isImportCall)?.arguments[0] ||                 findAncestor(location, isImportDeclaration)?.moduleSpecifier ||                 findAncestor(location, isExternalModuleImportEqualsDeclaration)?.moduleReference.expression ||                 findAncestor(location, isExportDeclaration)?.moduleSpecifier */ TODO
        mode := /* TODO(ConditionalExpression): contextSpecifier && isStringLiteralLike(contextSpecifier)             ? host.getModeForUsageLocation(currentSourceFile, contextSpecifier)             : host.getDefaultResolutionModeForFile(currentSourceFile) */ TODO
        moduleResolutionKind := getEmitModuleResolutionKind(compilerOptions)
        resolvedModule := /* TODO(PropertyAccessExpression): host.getResolvedModule(currentSourceFile, moduleReference, mode)?.resolvedModule */ TODO
        resolutionDiagnostic := /* TODO(BinaryExpression): errorNode && resolvedModule && getResolutionDiagnostic(compilerOptions, resolvedModule, currentSourceFile) */ TODO
        sourceFile := /* TODO(BinaryExpression): resolvedModule             && (!resolutionDiagnostic || resolutionDiagnostic === Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set)             && host.getSourceFile(resolvedModule.resolvedFileName) */ TODO
        if sourceFile {
            if resolutionDiagnostic {
                /* TODO(ExpressionStatement): error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName); */
            }
            if /* TODO(BinaryExpression): resolvedModule.resolvedUsingTsExtension && isDeclarationFileName(moduleReference) */ TODO {
                importOrExport := /* TODO(BinaryExpression): findAncestor(location, isImportDeclaration)?.importClause ||                     findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration)) */ TODO
                if /* TODO(BinaryExpression): errorNode && importOrExport && !importOrExport.isTypeOnly || findAncestor(location, isImportCall) */ TODO {
                    /* TODO(ExpressionStatement): error(                         errorNode,                         Diagnostics.A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_file_0_instead,                         getSuggestedImportSource(Debug.checkDefined(tryExtractTSExtension(moduleReference))),                     ); */
                }
            } else if /* TODO(BinaryExpression): resolvedModule.resolvedUsingTsExtension && !shouldAllowImportingTsExtension(compilerOptions, currentSourceFile.fileName) */ TODO {
                importOrExport := /* TODO(BinaryExpression): findAncestor(location, isImportDeclaration)?.importClause ||                     findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration)) */ TODO
                if /* TODO(BinaryExpression): errorNode && !(importOrExport?.isTypeOnly || findAncestor(location, isImportTypeNode)) */ TODO {
                    tsExtension := /* TODO(PropertyAccessExpression): Debug.checkDefined */ TODO(tryExtractTSExtension(moduleReference))
                    /* TODO(ExpressionStatement): error(errorNode, Diagnostics.An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled, tsExtension); */
                }
            }
            if /* TODO(PropertyAccessExpression): sourceFile.symbol */ TODO {
                if /* TODO(BinaryExpression): errorNode && resolvedModule.isExternalLibraryImport && !resolutionExtensionIsTSOrJson(resolvedModule.extension) */ TODO {
                    /* TODO(ExpressionStatement): errorOnImplicitAnyModule(/*isError* / false, errorNode, currentSourceFile, mode, resolvedModule, moduleReference); */
                }
                if /* TODO(BinaryExpression): errorNode && (moduleResolutionKind === ModuleResolutionKind.Node16 || moduleResolutionKind === ModuleResolutionKind.NodeNext) */ TODO {
                    isSyncImport := /* TODO(BinaryExpression): (currentSourceFile.impliedNodeFormat === ModuleKind.CommonJS && !findAncestor(location, isImportCall)) || !!findAncestor(location, isImportEqualsDeclaration) */ TODO
                    overrideHost := findAncestor(location, /* TODO(ArrowFunction): l => isImportTypeNode(l) || isExportDeclaration(l) || isImportDeclaration(l) || isJSDocImportTag(l) */ TODO)
                    if /* TODO(BinaryExpression): isSyncImport && sourceFile.impliedNodeFormat === ModuleKind.ESNext && !hasResolutionModeOverride(overrideHost) */ TODO {
                        if findAncestor(location, isImportEqualsDeclaration) {
                            /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead, moduleReference); */
                        } else {
                            diagnosticDetails
                            ext := tryGetExtensionFromPath(/* TODO(PropertyAccessExpression): currentSourceFile.fileName */ TODO)
                            if /* TODO(BinaryExpression): ext === Extension.Ts || ext === Extension.Js || ext === Extension.Tsx || ext === Extension.Jsx */ TODO {
                                /* TODO(ExpressionStatement): diagnosticDetails = createModeMismatchDetails(currentSourceFile); */
                            }
                            /* TODO(ExpressionStatement): diagnostics.add(createDiagnosticForNodeFromMessageChain(                                 getSourceFileOfNode(errorNode),                                 errorNode,                                 chainDiagnosticMessages(                                     diagnosticDetails,                                     Diagnostics.The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead,                                     moduleReference,                                 ),                             )); */
                        }
                    }
                }
                 getMergedSymbol(/* TODO(PropertyAccessExpression): sourceFile.symbol */ TODO)
            }
            if /* TODO(BinaryExpression): errorNode && moduleNotFoundError && !isSideEffectImport(errorNode) */ TODO {
                /* TODO(ExpressionStatement): error(errorNode, Diagnostics.File_0_is_not_a_module, sourceFile.fileName); */
            }
             undefined
        }
        if patternAmbientModules {
            pattern := findBestPatternMatch(patternAmbientModules, /* TODO(ArrowFunction): _ => _.pattern */ TODO, moduleReference)
            if pattern {
                augmentation := /* TODO(BinaryExpression): patternAmbientModuleAugmentations && patternAmbientModuleAugmentations.get(moduleReference) */ TODO
                if augmentation {
                     getMergedSymbol(augmentation)
                }
                 getMergedSymbol(/* TODO(PropertyAccessExpression): pattern.symbol */ TODO)
            }
        }
        if /* TODO(PrefixUnaryExpression): !errorNode */ TODO {
             undefined
        }
        if /* TODO(BinaryExpression): resolvedModule && !resolutionExtensionIsTSOrJson(resolvedModule.extension) && resolutionDiagnostic === undefined || resolutionDiagnostic === Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type */ TODO {
            if isForAugmentation {
                diag := /* TODO(PropertyAccessExpression): Diagnostics.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented */ TODO
                /* TODO(ExpressionStatement): error(errorNode, diag, moduleReference, resolvedModule!.resolvedFileName); */
            } else {
                /* TODO(ExpressionStatement): errorOnImplicitAnyModule(/*isError* / noImplicitAny && !!moduleNotFoundError, errorNode, currentSourceFile, mode, resolvedModule!, moduleReference); */
            }
             undefined
        }
        if moduleNotFoundError {
            if resolvedModule {
                redirect := /* TODO(PropertyAccessExpression): host.getProjectReferenceRedirect */ TODO(/* TODO(PropertyAccessExpression): resolvedModule.resolvedFileName */ TODO)
                if redirect {
                    /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect, resolvedModule.resolvedFileName); */
                     undefined
                }
            }
            if resolutionDiagnostic {
                /* TODO(ExpressionStatement): error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName); */
            } else {
                isExtensionlessRelativePathImport := /* TODO(BinaryExpression): pathIsRelative(moduleReference) && !hasExtension(moduleReference) */ TODO
                resolutionIsNode16OrNext := /* TODO(BinaryExpression): moduleResolutionKind === ModuleResolutionKind.Node16 ||                     moduleResolutionKind === ModuleResolutionKind.NodeNext */ TODO
                if /* TODO(BinaryExpression): !getResolveJsonModule(compilerOptions) &&                     fileExtensionIs(moduleReference, Extension.Json) &&                     moduleResolutionKind !== ModuleResolutionKind.Classic &&                     hasJsonModuleEmitEnabled(compilerOptions) */ TODO {
                    /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension, moduleReference); */
                } else if /* TODO(BinaryExpression): mode === ModuleKind.ESNext && resolutionIsNode16OrNext && isExtensionlessRelativePathImport */ TODO {
                    absoluteRef := getNormalizedAbsolutePath(moduleReference, getDirectoryPath(/* TODO(PropertyAccessExpression): currentSourceFile.path */ TODO))
                    suggestedExt := /* TODO(ElementAccessExpression): suggestedExtensions.find(([actualExt, _importExt]) => host.fileExists(absoluteRef + actualExt))?.[1] */ TODO
                    if suggestedExt {
                        /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0, moduleReference + suggestedExt); */
                    } else {
                        /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path); */
                    }
                } else {
                    if /* TODO(PropertyAccessExpression): host.getResolvedModule(currentSourceFile, moduleReference, mode)?.alternateResult */ TODO {
                        errorInfo := createModuleNotFoundChain(currentSourceFile, host, moduleReference, mode, moduleReference)
                        /* TODO(ExpressionStatement): errorOrSuggestion(/*isError* / true, errorNode, chainDiagnosticMessages(errorInfo, moduleNotFoundError, moduleReference)); */
                    } else {
                        /* TODO(ExpressionStatement): error(errorNode, moduleNotFoundError, moduleReference); */
                    }
                }
            }
        }
         undefined
        getSuggestedImportSource := func(tsExtension string) /* TODO(undefined): string */ TODO {
            importSourceWithoutExtension := removeExtension(moduleReference, tsExtension)
            if /* TODO(BinaryExpression): emitModuleKindIsNonNodeESM(moduleKind) || mode === ModuleKind.ESNext */ TODO {
                preferTs := /* TODO(BinaryExpression): isDeclarationFileName(moduleReference) && shouldAllowImportingTsExtension(compilerOptions) */ TODO
                ext := /* TODO(ConditionalExpression): tsExtension === Extension.Mts || tsExtension === Extension.Dmts ? preferTs ? ".mts" : ".mjs" :                     tsExtension === Extension.Cts || tsExtension === Extension.Dmts ? preferTs ? ".cts" : ".cjs" :                     preferTs ? ".ts" : ".js" */ TODO
                 /* TODO(BinaryExpression): importSourceWithoutExtension + ext */ TODO
            }
             importSourceWithoutExtension
        }
    }
    errorOnImplicitAnyModule := func(isError bool, errorNode Node, sourceFile SourceFile, mode ResolutionMode, TODO_IDENTIFIER ResolvedModuleFull, moduleReference string) {
        if isSideEffectImport(errorNode) {

        }
        var errorInfo *DiagnosticMessageChain
        if /* TODO(BinaryExpression): !isExternalModuleNameRelative(moduleReference) && packageId */ TODO {
            /* TODO(ExpressionStatement): errorInfo = createModuleNotFoundChain(sourceFile, host, moduleReference, mode, packageId.name); */
        }
        /* TODO(ExpressionStatement): errorOrSuggestion(             isError,             errorNode,             chainDiagnosticMessages(                 errorInfo,                 Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type,                 moduleReference,                 resolvedFileName,             ),         ); */
    }
    // OVERLOAD: resolveExternalModuleSymbol := func(moduleSymbol Symbol, dontResolveAlias bool) Symbol
    // OVERLOAD: resolveExternalModuleSymbol := func(moduleSymbol *Symbol, dontResolveAlias bool) *Symbol
    resolveExternalModuleSymbol := func(moduleSymbol *Symbol, dontResolveAlias bool) *Symbol {
        if /* TODO(PropertyAccessExpression): moduleSymbol?.exports */ TODO {
            exportEquals := resolveSymbol(/* TODO(PropertyAccessExpression): moduleSymbol.exports.get */ TODO(/* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO), dontResolveAlias)
            exported := getCommonJsExportEquals(getMergedSymbol(exportEquals), getMergedSymbol(moduleSymbol))
             /* TODO(BinaryExpression): getMergedSymbol(exported) || moduleSymbol */ TODO
        }
         undefined
    }
    getCommonJsExportEquals := func(exported *Symbol, moduleSymbol Symbol) *Symbol {
        if /* TODO(BinaryExpression): !exported || exported === unknownSymbol || exported === moduleSymbol || moduleSymbol.exports!.size === 1 || exported.flags & SymbolFlags.Alias */ TODO {
             exported
        }
        links := getSymbolLinks(exported)
        if /* TODO(PropertyAccessExpression): links.cjsExportMerged */ TODO {
             /* TODO(PropertyAccessExpression): links.cjsExportMerged */ TODO
        }
        merged := /* TODO(ConditionalExpression): exported.flags & SymbolFlags.Transient ? exported : cloneSymbol(exported) */ TODO
        /* TODO(ExpressionStatement): merged.flags = merged.flags | SymbolFlags.ValueModule; */
        if /* TODO(BinaryExpression): merged.exports === undefined */ TODO {
            /* TODO(ExpressionStatement): merged.exports = createSymbolTable(); */
        }
        /* TODO(ExpressionStatement): moduleSymbol.exports!.forEach((s, name) => {             if (name === InternalSymbolName.ExportEquals) return;             merged.exports!.set(name, merged.exports!.has(name) ? mergeSymbol(merged.exports!.get(name)!, s) : s);         }); */
        if /* TODO(BinaryExpression): merged === exported */ TODO {
            /* TODO(ExpressionStatement): getSymbolLinks(merged).resolvedExports = undefined; */
            /* TODO(ExpressionStatement): getSymbolLinks(merged).resolvedMembers = undefined; */
        }
        /* TODO(ExpressionStatement): getSymbolLinks(merged).cjsExportMerged = merged; */
         /* TODO(BinaryExpression): links.cjsExportMerged = merged */ TODO
    }
    resolveESModuleSymbol := func(moduleSymbol *Symbol, referencingLocation Node, dontResolveAlias bool, suppressInteropError bool) *Symbol {
        symbol := resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias)
        if /* TODO(BinaryExpression): !dontResolveAlias && symbol */ TODO {
            if /* TODO(BinaryExpression): !suppressInteropError && !(symbol.flags & (SymbolFlags.Module | SymbolFlags.Variable)) && !getDeclarationOfKind(symbol, SyntaxKind.SourceFile) */ TODO {
                compilerOptionName := /* TODO(ConditionalExpression): moduleKind >= ModuleKind.ES2015                     ? "allowSyntheticDefaultImports"                     : "esModuleInterop" */ TODO
                /* TODO(ExpressionStatement): error(referencingLocation, Diagnostics.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export, compilerOptionName); */
                 symbol
            }
            referenceParent := /* TODO(PropertyAccessExpression): referencingLocation.parent */ TODO
            if /* TODO(BinaryExpression): (isImportDeclaration(referenceParent) && getNamespaceDeclarationNode(referenceParent)) ||                 isImportCall(referenceParent) */ TODO {
                reference := /* TODO(ConditionalExpression): isImportCall(referenceParent) ? referenceParent.arguments[0] : referenceParent.moduleSpecifier */ TODO
                type_ := getTypeOfSymbol(symbol)
                defaultOnlyType := getTypeWithSyntheticDefaultOnly(type_, symbol, /* TODO(NonNullExpression): moduleSymbol! */ TODO, reference)
                if defaultOnlyType {
                     cloneTypeAsModuleType(symbol, defaultOnlyType, referenceParent)
                }
                targetFile := /* TODO(PropertyAccessExpression): moduleSymbol?.declarations?.find */ TODO(isSourceFile)
                isEsmCjsRef := /* TODO(BinaryExpression): targetFile && isESMFormatImportImportingCommonjsFormatFile(getEmitSyntaxForModuleSpecifierExpression(reference), host.getImpliedNodeFormatForEmit(targetFile)) */ TODO
                if /* TODO(BinaryExpression): getESModuleInterop(compilerOptions) || isEsmCjsRef */ TODO {
                    sigs := getSignaturesOfStructuredType(type_, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
                    if /* TODO(BinaryExpression): !sigs || !sigs.length */ TODO {
                        /* TODO(ExpressionStatement): sigs = getSignaturesOfStructuredType(type, SignatureKind.Construct); */
                    }
                    if /* TODO(BinaryExpression): (sigs && sigs.length) ||                         getPropertyOfType(type, InternalSymbolName.Default, /*skipObjectFunctionPropertyAugment* / true) ||                         isEsmCjsRef */ TODO {
                        moduleType := /* TODO(ConditionalExpression): type.flags & TypeFlags.StructuredType                             ? getTypeWithSyntheticDefaultImportType(type, symbol, moduleSymbol!, reference)                             : createDefaultPropertyWrapperForModule(symbol, symbol.parent) */ TODO
                         cloneTypeAsModuleType(symbol, moduleType, referenceParent)
                    }
                }
            }
        }
         symbol
    }
    cloneTypeAsModuleType := func(symbol Symbol, moduleType Type, referenceParent /* TODO(UnionType): ImportDeclaration | ImportCall */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
        result := createSymbol(/* TODO(PropertyAccessExpression): symbol.flags */ TODO, /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO)
        /* TODO(ExpressionStatement): result.declarations = symbol.declarations ? symbol.declarations.slice() : []; */
        /* TODO(ExpressionStatement): result.parent = symbol.parent; */
        /* TODO(ExpressionStatement): result.links.target = symbol; */
        /* TODO(ExpressionStatement): result.links.originatingImport = referenceParent; */
        if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
            /* TODO(BinaryExpression): result.valueDeclaration = symbol.valueDeclaration */
        }
        if /* TODO(PropertyAccessExpression): symbol.constEnumOnlyModule */ TODO {
            /* TODO(BinaryExpression): result.constEnumOnlyModule = true */
        }
        if /* TODO(PropertyAccessExpression): symbol.members */ TODO {
            /* TODO(BinaryExpression): result.members = new Map(symbol.members) */
        }
        if /* TODO(PropertyAccessExpression): symbol.exports */ TODO {
            /* TODO(BinaryExpression): result.exports = new Map(symbol.exports) */
        }
        resolvedModuleType := resolveStructuredTypeMembers(moduleType /* as */ /* TODO(TypeReference): StructuredType */)
        /* TODO(ExpressionStatement): result.links.type = createAnonymousType(result, resolvedModuleType.members, emptyArray, emptyArray, resolvedModuleType.indexInfos); */
         result
    }
    hasExportAssignmentSymbol := func(moduleSymbol Symbol) bool {
         /* TODO(BinaryExpression): moduleSymbol.exports!.get(InternalSymbolName.ExportEquals) !== undefined */ TODO
    }
    getExportsOfModuleAsArray := func(moduleSymbol Symbol) []Symbol {
         symbolsToArray(getExportsOfModule(moduleSymbol))
    }
    getExportsAndPropertiesOfModule := func(moduleSymbol Symbol) []Symbol {
        exports := getExportsOfModuleAsArray(moduleSymbol)
        exportEquals := resolveExternalModuleSymbol(moduleSymbol)
        if /* TODO(BinaryExpression): exportEquals !== moduleSymbol */ TODO {
            type_ := getTypeOfSymbol(exportEquals)
            if shouldTreatPropertiesOfExternalModuleAsExports(type_) {
                /* TODO(ExpressionStatement): addRange(exports, getPropertiesOfType(type)); */
            }
        }
         exports
    }
    forEachExportAndPropertyOfModule := func(moduleSymbol Symbol, cb func(symbol Symbol, key __String) ) {
        exports := getExportsOfModule(moduleSymbol)
        /* TODO(ExpressionStatement): exports.forEach((symbol, key) => {             if (!isReservedMemberName(key)) {                 cb(symbol, key);             }         }); */
        exportEquals := resolveExternalModuleSymbol(moduleSymbol)
        if /* TODO(BinaryExpression): exportEquals !== moduleSymbol */ TODO {
            type_ := getTypeOfSymbol(exportEquals)
            if shouldTreatPropertiesOfExternalModuleAsExports(type_) {
                /* TODO(ExpressionStatement): forEachPropertyOfType(type, (symbol, escapedName) => {                     cb(symbol, escapedName);                 }); */
            }
        }
    }
    tryGetMemberInModuleExports := func(memberName __String, moduleSymbol Symbol) *Symbol {
        symbolTable := getExportsOfModule(moduleSymbol)
        if symbolTable {
             /* TODO(PropertyAccessExpression): symbolTable.get */ TODO(memberName)
        }
    }
    tryGetMemberInModuleExportsAndProperties := func(memberName __String, moduleSymbol Symbol) *Symbol {
        symbol := tryGetMemberInModuleExports(memberName, moduleSymbol)
        if symbol {
             symbol
        }
        exportEquals := resolveExternalModuleSymbol(moduleSymbol)
        if /* TODO(BinaryExpression): exportEquals === moduleSymbol */ TODO {
             undefined
        }
        type_ := getTypeOfSymbol(exportEquals)
         /* TODO(ConditionalExpression): shouldTreatPropertiesOfExternalModuleAsExports(type) ? getPropertyOfType(type, memberName) : undefined */ TODO
    }
    shouldTreatPropertiesOfExternalModuleAsExports := func(resolvedExternalModuleType Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !(resolvedExternalModuleType.flags & TypeFlags.Primitive ||             getObjectFlags(resolvedExternalModuleType) & ObjectFlags.Class ||             // `isArrayOrTupleLikeType` is too expensive to use in this auto-imports hot path             isArrayType(resolvedExternalModuleType) ||             isTupleType(resolvedExternalModuleType)) */ TODO
    }
    getExportsOfSymbol := func(symbol Symbol) SymbolTable {
         /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.LateBindingContainer ? getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKind.resolvedExports) :             symbol.flags & SymbolFlags.Module ? getExportsOfModule(symbol) :             symbol.exports || emptySymbols */ TODO
    }
    getExportsOfModule := func(moduleSymbol Symbol) SymbolTable {
        links := getSymbolLinks(moduleSymbol)
        if /* TODO(PrefixUnaryExpression): !links.resolvedExports */ TODO {
            TODO_IDENTIFIER := getExportsOfModuleWorker(moduleSymbol)
            /* TODO(ExpressionStatement): links.resolvedExports = exports; */
            /* TODO(ExpressionStatement): links.typeOnlyExportStarMap = typeOnlyExportStarMap; */
        }
         /* TODO(PropertyAccessExpression): links.resolvedExports */ TODO
    }
    type ExportCollisionTracker struct {
        specifierText string
        exportsWithDuplicate []ExportDeclaration
    }
    type ExportCollisionTrackerTable Map[__String, ExportCollisionTracker]
    extendExportSymbols := func(target SymbolTable, source *SymbolTable, lookupTable ExportCollisionTrackerTable, exportNode ExportDeclaration) {
        if /* TODO(PrefixUnaryExpression): !source */ TODO {
        }
        /* TODO(ExpressionStatement): source.forEach((sourceSymbol, id) => {             if (id === InternalSymbolName.Default) return;              const targetSymbol = target.get(id);             if (!targetSymbol) {                 target.set(id, sourceSymbol);                 if (lookupTable && exportNode) {                     lookupTable.set(id, {                         specifierText: getTextOfNode(exportNode.moduleSpecifier!),                     });                 }             }             else if (lookupTable && exportNode && targetSymbol && resolveSymbol(targetSymbol) !== resolveSymbol(sourceSymbol)) {                 const collisionTracker = lookupTable.get(id)!;                 if (!collisionTracker.exportsWithDuplicate) {                     collisionTracker.exportsWithDuplicate = [exportNode];                 }                 else {                     collisionTracker.exportsWithDuplicate.push(exportNode);                 }             }         }); */
    }
    getExportsOfModuleWorker := func(moduleSymbol Symbol) /* TODO(undefined): { exports: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable; typeOnlyExportStarMap: Map<import("/home/jabaile/work/TypeScript/src/compiler/types").__String, import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; }> | undefined; } */ TODO {
        var visitedSymbols []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
        var typeOnlyExportStarMap *Map[__String, /* TODO(IntersectionType): ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */ TODO]
        nonTypeOnlyNames := /* TODO(NewExpression): new Set<__String>() */ TODO
        /* TODO(ExpressionStatement): moduleSymbol = resolveExternalModuleSymbol(moduleSymbol); */
        exports := /* TODO(BinaryExpression): visit(moduleSymbol) || emptySymbols */ TODO
        if typeOnlyExportStarMap {
            /* TODO(ExpressionStatement): nonTypeOnlyNames.forEach(name => typeOnlyExportStarMap!.delete(name)); */
        }
         /* TODO(ObjectLiteralExpression): {             exports,             typeOnlyExportStarMap,         } */ TODO
        visit := func(symbol *Symbol, exportStar ExportDeclaration, isTypeOnly bool) *SymbolTable {
            if /* TODO(BinaryExpression): !isTypeOnly && symbol?.exports */ TODO {
                /* TODO(ExpressionStatement): symbol.exports.forEach((_, name) => nonTypeOnlyNames.add(name)); */
            }
            if /* TODO(PrefixUnaryExpression): !(symbol && symbol.exports && pushIfUnique(visitedSymbols, symbol)) */ TODO {

            }
            symbols := /* TODO(NewExpression): new Map(symbol.exports) */ TODO
            exportStars := /* TODO(PropertyAccessExpression): symbol.exports.get */ TODO(/* TODO(PropertyAccessExpression): InternalSymbolName.ExportStar */ TODO)
            if exportStars {
                nestedSymbols := createSymbolTable()
                var lookupTable ExportCollisionTrackerTable = /* TODO(NewExpression): new Map() */ TODO
                if /* TODO(PropertyAccessExpression): exportStars.declarations */ TODO {
                    /* TODO(ForOfStatement): for (const node of exportStars.declarations) {                         const resolvedModule = resolveExternalModuleName(node, (node as ExportDeclaration).moduleSpecifier!);                         const exportedSymbols = visit(resolvedModule, node as ExportDeclaration, isTypeOnly || (node as ExportDeclaration).isTypeOnly);                         extendExportSymbols(                             nestedSymbols,                             exportedSymbols,                             lookupTable,                             node as ExportDeclaration,                         );                     } */
                }
                /* TODO(ExpressionStatement): lookupTable.forEach(({ exportsWithDuplicate }, id) => {                     // It's not an error if the file with multiple `export *`s with duplicate names exports a member with that name itself                     if (id === "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id)) {                         return;                     }                     for (const node of exportsWithDuplicate) {                         diagnostics.add(createDiagnosticForNode(                             node,                             Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity,                             lookupTable.get(id)!.specifierText,                             unescapeLeadingUnderscores(id),                         ));                     }                 }); */
                /* TODO(ExpressionStatement): extendExportSymbols(symbols, nestedSymbols); */
            }
            if /* TODO(PropertyAccessExpression): exportStar?.isTypeOnly */ TODO {
                /* TODO(ExpressionStatement): typeOnlyExportStarMap ??= new Map(); */
                /* TODO(ExpressionStatement): symbols.forEach((_, escapedName) =>                     typeOnlyExportStarMap!.set(                         escapedName,                         exportStar as ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; },                     )                 ); */
            }
             symbols
        }
    }
    // OVERLOAD: getMergedSymbol := func(symbol Symbol) Symbol
    // OVERLOAD: getMergedSymbol := func(symbol *Symbol) *Symbol
    getMergedSymbol := func(symbol *Symbol) *Symbol {
        var merged Symbol
         /* TODO(ConditionalExpression): symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol */ TODO
    }
    getSymbolOfDeclaration := func(node Declaration) Symbol {
         getMergedSymbol(/* TODO(BinaryExpression): node.symbol && getLateBoundSymbol(node.symbol) */ TODO)
    }
    getSymbolOfNode := func(node Node) *Symbol {
         /* TODO(ConditionalExpression): canHaveSymbol(node) ? getSymbolOfDeclaration(node) : undefined */ TODO
    }
    getParentOfSymbol := func(symbol Symbol) *Symbol {
         getMergedSymbol(/* TODO(BinaryExpression): symbol.parent && getLateBoundSymbol(symbol.parent) */ TODO)
    }
    getFunctionExpressionParentSymbolOrSymbol := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
         /* TODO(ConditionalExpression): symbol.valueDeclaration?.kind === SyntaxKind.ArrowFunction || symbol.valueDeclaration?.kind === SyntaxKind.FunctionExpression             ? getSymbolOfNode(symbol.valueDeclaration.parent) || symbol             : symbol */ TODO
    }
    getAlternativeContainingModules := func(symbol Symbol, enclosingDeclaration Node) []Symbol {
        containingFile := getSourceFileOfNode(enclosingDeclaration)
        id := getNodeId(containingFile)
        links := getSymbolLinks(symbol)
        var results /* TODO(ArrayType): Symbol[] */ any
        if /* TODO(BinaryExpression): links.extendedContainersByFile && (results = links.extendedContainersByFile.get(id)) */ TODO {
             results
        }
        if /* TODO(BinaryExpression): containingFile && containingFile.imports */ TODO {
            /* TODO(ForOfStatement): for (const importRef of containingFile.imports) {                 if (nodeIsSynthesized(importRef)) continue; // Synthetic names can't be resolved by `resolveExternalModuleName` - they'll cause a debug assert if they error                 const resolvedModule = resolveExternalModuleName(enclosingDeclaration, importRef, /*ignoreErrors* / true);                 if (!resolvedModule) continue;                 const ref = getAliasForSymbolInContainer(resolvedModule, symbol);                 if (!ref) continue;                 results = append(results, resolvedModule);             } */
            if length(results) {
                /* TODO(ExpressionStatement): (links.extendedContainersByFile || (links.extendedContainersByFile = new Map())).set(id, results!); */
                 /* TODO(NonNullExpression): results! */ TODO
            }
        }
        if /* TODO(PropertyAccessExpression): links.extendedContainers */ TODO {
             /* TODO(PropertyAccessExpression): links.extendedContainers */ TODO
        }
        otherFiles := /* TODO(PropertyAccessExpression): host.getSourceFiles */ TODO()
        /* TODO(ForOfStatement): for (const file of otherFiles) {             if (!isExternalModule(file)) continue;             const sym = getSymbolOfDeclaration(file);             const ref = getAliasForSymbolInContainer(sym, symbol);             if (!ref) continue;             results = append(results, sym);         } */
         /* TODO(BinaryExpression): links.extendedContainers = results || emptyArray */ TODO
    }
    getContainersOfSymbol := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) /* TODO(ArrayType): Symbol[] */ any {
        container := getParentOfSymbol(symbol)
        if /* TODO(BinaryExpression): container && !(symbol.flags & SymbolFlags.TypeParameter) */ TODO {
             getWithAlternativeContainers(container)
        }
        candidates := mapDefined(/* TODO(PropertyAccessExpression): symbol.declarations */ TODO, /* TODO(ArrowFunction): d => {             if (!isAmbientModule(d) && d.parent) {                 // direct children of a module                 if (hasNonGlobalAugmentationExternalModuleSymbol(d.parent)) {                     return getSymbolOfDeclaration(d.parent as Declaration);                 }                 // export ='d member of an ambient module                 if (isModuleBlock(d.parent) && d.parent.parent && resolveExternalModuleSymbol(getSymbolOfDeclaration(d.parent.parent)) === symbol) {                     return getSymbolOfDeclaration(d.parent.parent);                 }             }             if (isClassExpression(d) && isBinaryExpression(d.parent) && d.parent.operatorToken.kind === SyntaxKind.EqualsToken && isAccessExpression(d.parent.left) && isEntityNameExpression(d.parent.left.expression)) {                 if (isModuleExportsAccessExpression(d.parent.left) || isExportsIdentifier(d.parent.left.expression)) {                     return getSymbolOfDeclaration(getSourceFileOfNode(d));                 }                 checkExpressionCached(d.parent.left.expression);                 return getNodeLinks(d.parent.left.expression).resolvedSymbol;             }         } */ TODO)
        if /* TODO(PrefixUnaryExpression): !length(candidates) */ TODO {
             undefined
        }
        containers := mapDefined(candidates, /* TODO(ArrowFunction): candidate => getAliasForSymbolInContainer(candidate, symbol) ? candidate : undefined */ TODO)
        var bestContainers []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
        var alternativeContainers []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForOfStatement): for (const container of containers) {             const [bestMatch, ...rest] = getWithAlternativeContainers(container);             bestContainers = append(bestContainers, bestMatch);             alternativeContainers = addRange(alternativeContainers, rest);         } */
         concatenate(bestContainers, alternativeContainers)
        getWithAlternativeContainers := func(container Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
            additionalContainers := mapDefined(/* TODO(PropertyAccessExpression): container.declarations */ TODO, fileSymbolIfFileSymbolExportEqualsContainer)
            reexportContainers := /* TODO(BinaryExpression): enclosingDeclaration && getAlternativeContainingModules(symbol, enclosingDeclaration) */ TODO
            objectLiteralContainer := getVariableDeclarationOfObjectLiteral(container, meaning)
            if /* TODO(BinaryExpression): enclosingDeclaration &&                 container.flags & getQualifiedLeftMeaning(meaning) &&                 getAccessibleSymbolChain(container, enclosingDeclaration, SymbolFlags.Namespace, /*useOnlyExternalAliasing* / false) */ TODO {
                 append(concatenate(concatenate(/* TODO(ArrayLiteralExpression): [container] */ TODO, additionalContainers), reexportContainers), objectLiteralContainer)
            }
            firstVariableMatch := /* TODO(ConditionalExpression): !(container.flags & getQualifiedLeftMeaning(meaning))                     && container.flags & SymbolFlags.Type                     && getDeclaredTypeOfSymbol(container).flags & TypeFlags.Object                     && meaning === SymbolFlags.Value                 ? forEachSymbolTableInScope(enclosingDeclaration, t => {                     return forEachEntry(t, s => {                         if (s.flags & getQualifiedLeftMeaning(meaning) && getTypeOfSymbol(s) === getDeclaredTypeOfSymbol(container)) {                             return s;                         }                     });                 }) : undefined */ TODO
            res := /* TODO(ConditionalExpression): firstVariableMatch ? [firstVariableMatch, ...additionalContainers, container] : [...additionalContainers, container] */ TODO
            /* TODO(ExpressionStatement): res = append(res, objectLiteralContainer); */
            /* TODO(ExpressionStatement): res = addRange(res, reexportContainers); */
             res
        }
        fileSymbolIfFileSymbolExportEqualsContainer := func(d Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
             /* TODO(BinaryExpression): container && getFileSymbolIfFileSymbolExportEqualsContainer(d, container) */ TODO
        }
    }
    getVariableDeclarationOfObjectLiteral := func(symbol Symbol, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        var firstDecl /* TODO(UnionType): Node | false */ any = /* TODO(BinaryExpression): !!length(symbol.declarations) && first(symbol.declarations!) */ TODO
        if /* TODO(BinaryExpression): meaning & SymbolFlags.Value && firstDecl && firstDecl.parent && isVariableDeclaration(firstDecl.parent) */ TODO {
            if /* TODO(BinaryExpression): isObjectLiteralExpression(firstDecl) && firstDecl === firstDecl.parent.initializer || isTypeLiteralNode(firstDecl) && firstDecl === firstDecl.parent.type */ TODO {
                 getSymbolOfDeclaration(/* TODO(PropertyAccessExpression): firstDecl.parent */ TODO)
            }
        }
    }
    getFileSymbolIfFileSymbolExportEqualsContainer := func(d Declaration, container Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        fileSymbol := getExternalModuleContainer(d)
        exported := /* TODO(BinaryExpression): fileSymbol && fileSymbol.exports && fileSymbol.exports.get(InternalSymbolName.ExportEquals) */ TODO
         /* TODO(ConditionalExpression): exported && getSymbolIfSameReference(exported, container) ? fileSymbol : undefined */ TODO
    }
    getAliasForSymbolInContainer := func(container Symbol, symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        if /* TODO(BinaryExpression): container === getParentOfSymbol(symbol) */ TODO {
             symbol
        }
        exportEquals := /* TODO(BinaryExpression): container.exports && container.exports.get(InternalSymbolName.ExportEquals) */ TODO
        if /* TODO(BinaryExpression): exportEquals && getSymbolIfSameReference(exportEquals, symbol) */ TODO {
             container
        }
        exports := getExportsOfSymbol(container)
        quick := /* TODO(PropertyAccessExpression): exports.get */ TODO(/* TODO(PropertyAccessExpression): symbol.escapedName */ TODO)
        if /* TODO(BinaryExpression): quick && getSymbolIfSameReference(quick, symbol) */ TODO {
             quick
        }
         forEachEntry(exports, /* TODO(ArrowFunction): exported => {             if (getSymbolIfSameReference(exported, symbol)) {                 return exported;             }         } */ TODO)
    }
    getSymbolIfSameReference := func(s1 Symbol, s2 Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        if /* TODO(BinaryExpression): getMergedSymbol(resolveSymbol(getMergedSymbol(s1))) === getMergedSymbol(resolveSymbol(getMergedSymbol(s2))) */ TODO {
             s1
        }
    }
    // OVERLOAD: getExportSymbolOfValueSymbolIfExported := func(symbol Symbol) Symbol
    // OVERLOAD: getExportSymbolOfValueSymbolIfExported := func(symbol *Symbol) *Symbol
    getExportSymbolOfValueSymbolIfExported := func(symbol *Symbol) *Symbol {
         getMergedSymbol(/* TODO(BinaryExpression): symbol && (symbol.flags & SymbolFlags.ExportValue) !== 0 && symbol.exportSymbol || symbol */ TODO)
    }
    symbolIsValue := func(symbol Symbol, includeTypeOnlyMembers bool) bool {
         /* TODO(PrefixUnaryExpression): !!(             symbol.flags & SymbolFlags.Value ||             symbol.flags & SymbolFlags.Alias && getSymbolFlags(symbol, !includeTypeOnlyMembers) & SymbolFlags.Value         ) */ TODO
    }
    createType := func(flags TypeFlags) Type {
        result := /* TODO(NewExpression): new Type(checker, flags) */ TODO
        /* TODO(ExpressionStatement): typeCount++; */
        /* TODO(ExpressionStatement): result.id = typeCount; */
        /* TODO(ExpressionStatement): tracing?.recordType(result); */
         result
    }
    createTypeWithSymbol := func(flags TypeFlags, symbol Symbol) Type {
        result := createType(flags)
        /* TODO(ExpressionStatement): result.symbol = symbol; */
         result
    }
    createOriginType := func(flags TypeFlags) Type {
         /* TODO(NewExpression): new Type(checker, flags) */ TODO
    }
    createIntrinsicType := func(kind TypeFlags, intrinsicName string, objectFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): ObjectFlags.None */, debugIntrinsicName string) IntrinsicType {
        /* TODO(ExpressionStatement): checkIntrinsicName(intrinsicName, debugIntrinsicName); */
        type_ := createType(kind) /* as */ /* TODO(TypeReference): IntrinsicType */
        /* TODO(ExpressionStatement): type.intrinsicName = intrinsicName; */
        /* TODO(ExpressionStatement): type.debugIntrinsicName = debugIntrinsicName; */
        /* TODO(ExpressionStatement): type.objectFlags = objectFlags | ObjectFlags.CouldContainTypeVariablesComputed | ObjectFlags.IsGenericTypeComputed | ObjectFlags.IsUnknownLikeUnionComputed | ObjectFlags.IsNeverIntersectionComputed; */
         type_
    }
    checkIntrinsicName := func(name string, debug /* TODO(StringKeyword): string */ any) {
        key := /* TODO(TemplateExpression): `${name},${debug ?? ""}` */ TODO
        if /* TODO(PropertyAccessExpression): seenIntrinsicNames.has */ TODO(key) {
            /* TODO(ExpressionStatement): Debug.fail(`Duplicate intrinsic type name ${name}${debug ? ` (${debug})` : ""}; you may need to pass a name to createIntrinsicType.`); */
        }
        /* TODO(ExpressionStatement): seenIntrinsicNames.add(key); */
    }
    createObjectType := func(objectFlags ObjectFlags, symbol Symbol) ObjectType {
        type_ := createTypeWithSymbol(/* TODO(PropertyAccessExpression): TypeFlags.Object */ TODO, /* TODO(NonNullExpression): symbol! */ TODO) /* as */ /* TODO(TypeReference): ObjectType */
        /* TODO(ExpressionStatement): type.objectFlags = objectFlags; */
        /* TODO(ExpressionStatement): type.members = undefined; */
        /* TODO(ExpressionStatement): type.properties = undefined; */
        /* TODO(ExpressionStatement): type.callSignatures = undefined; */
        /* TODO(ExpressionStatement): type.constructSignatures = undefined; */
        /* TODO(ExpressionStatement): type.indexInfos = undefined; */
         type_
    }
    createTypeofType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         getUnionType(arrayFrom(/* TODO(PropertyAccessExpression): typeofNEFacts.keys */ TODO(), getStringLiteralType))
    }
    createTypeParameter := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
         createTypeWithSymbol(/* TODO(PropertyAccessExpression): TypeFlags.TypeParameter */ TODO, /* TODO(NonNullExpression): symbol! */ TODO) /* as */ /* TODO(TypeReference): TypeParameter */
    }
    isReservedMemberName := func(name __String) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): (name as string).charCodeAt(0) === CharacterCodes._ &&             (name as string).charCodeAt(1) === CharacterCodes._ &&             (name as string).charCodeAt(2) !== CharacterCodes._ &&             (name as string).charCodeAt(2) !== CharacterCodes.at &&             (name as string).charCodeAt(2) !== CharacterCodes.hash */ TODO
    }
    getNamedMembers := func(members SymbolTable) []Symbol {
        var result /* TODO(ArrayType): Symbol[] */ any
        /* TODO(ExpressionStatement): members.forEach((symbol, id) => {             if (isNamedMember(symbol, id)) {                 (result || (result = [])).push(symbol);             }         }); */
         /* TODO(BinaryExpression): result || emptyArray */ TODO
    }
    isNamedMember := func(member Symbol, escapedName __String) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !isReservedMemberName(escapedName) && symbolIsValue(member) */ TODO
    }
    getNamedOrIndexSignatureMembers := func(members SymbolTable) []Symbol {
        result := getNamedMembers(members)
        index := getIndexSymbolFromSymbolTable(members)
         /* TODO(ConditionalExpression): index ? concatenate(result, [index]) : result */ TODO
    }
    setStructuredTypeMembers := func(type_ StructuredType, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
        resolved := type_ /* as */ /* TODO(TypeReference): ResolvedType */
        /* TODO(ExpressionStatement): resolved.members = members; */
        /* TODO(ExpressionStatement): resolved.properties = emptyArray; */
        /* TODO(ExpressionStatement): resolved.callSignatures = callSignatures; */
        /* TODO(ExpressionStatement): resolved.constructSignatures = constructSignatures; */
        /* TODO(ExpressionStatement): resolved.indexInfos = indexInfos; */
        if /* TODO(BinaryExpression): members !== emptySymbols */ TODO {
            /* TODO(BinaryExpression): resolved.properties = getNamedMembers(members) */
        }
         resolved
    }
    createAnonymousType := func(symbol *Symbol, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
         setStructuredTypeMembers(createObjectType(/* TODO(PropertyAccessExpression): ObjectFlags.Anonymous */ TODO, symbol), members, callSignatures, constructSignatures, indexInfos)
    }
    getResolvedTypeWithoutAbstractConstructSignatures := func(type_ ResolvedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
        if /* TODO(BinaryExpression): type.constructSignatures.length === 0 */ TODO {
            /* TODO(Identifier): type */
        }
        if /* TODO(PropertyAccessExpression): type.objectTypeWithoutAbstractConstructSignatures */ TODO {
            /* TODO(PropertyAccessExpression): type.objectTypeWithoutAbstractConstructSignatures */
        }
        constructSignatures := filter(/* TODO(PropertyAccessExpression): type.constructSignatures */ TODO, /* TODO(ArrowFunction): signature => !(signature.flags & SignatureFlags.Abstract) */ TODO)
        if /* TODO(BinaryExpression): type.constructSignatures === constructSignatures */ TODO {
            /* TODO(Identifier): type */
        }
        typeCopy := createAnonymousType(/* TODO(PropertyAccessExpression): type.symbol */ TODO, /* TODO(PropertyAccessExpression): type.members */ TODO, /* TODO(PropertyAccessExpression): type.callSignatures */ TODO, /* TODO(ConditionalExpression): some(constructSignatures) ? constructSignatures : emptyArray */ TODO, /* TODO(PropertyAccessExpression): type.indexInfos */ TODO)
        /* TODO(ExpressionStatement): type.objectTypeWithoutAbstractConstructSignatures = typeCopy; */
        /* TODO(ExpressionStatement): typeCopy.objectTypeWithoutAbstractConstructSignatures = typeCopy; */
         typeCopy
    }
    forEachSymbolTableInScope := func(enclosingDeclaration Node, callback func(symbolTable SymbolTable, ignoreQualification bool, isLocalNameLookup bool, scopeNode Node) T) T {
        var result T
        /* TODO(ForStatement): for (let location = enclosingDeclaration; location; location = location.parent) {             // Locals of a source file are not in scope (because they get merged into the global symbol table)             if (canHaveLocals(location) && location.locals && !isGlobalSourceFile(location)) {                 if (result = callback(location.locals, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location)) {                     return result;                 }             }             switch (location.kind) {                 case SyntaxKind.SourceFile:                     if (!isExternalOrCommonJsModule(location as SourceFile)) {                         break;                     }                     // falls through                 case SyntaxKind.ModuleDeclaration:                     const sym = getSymbolOfDeclaration(location as ModuleDeclaration);                     // `sym` may not have exports if this module declaration is backed by the symbol for a `const` that's being rewritten                     // into a namespace - in such cases, it's best to just let the namespace appear empty (the const members couldn't have referred                     // to one another anyway)                     if (result = callback(sym?.exports || emptySymbols, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location)) {                         return result;                     }                     break;                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression:                 case SyntaxKind.InterfaceDeclaration:                     // Type parameters are bound into `members` lists so they can merge across declarations                     // This is troublesome, since in all other respects, they behave like locals :cries:                     // TODO: the below is shared with similar code in `resolveName` - in fact, rephrasing all this symbol                     // lookup logic in terms of `resolveName` would be nice                     // The below is used to lookup type parameters within a class or interface, as they are added to the class/interface locals                     // These can never be latebound, so the symbol's raw members are sufficient. `getMembersOfNode` cannot be used, as it would                     // trigger resolving late-bound names, which we may already be in the process of doing while we're here!                     let table: Map<__String, Symbol> | undefined;                     // TODO: Should this filtered table be cached in some way?                     (getSymbolOfDeclaration(location as ClassLikeDeclaration | InterfaceDeclaration).members || emptySymbols).forEach((memberSymbol, key) => {                         if (memberSymbol.flags & (SymbolFlags.Type & ~SymbolFlags.Assignment)) {                             (table || (table = createSymbolTable())).set(key, memberSymbol);                         }                     });                     if (table && (result = callback(table, /*ignoreQualification* / undefined, /*isLocalNameLookup* / false, location))) {                         return result;                     }                     break;             }         } */
         callback(globals, undefined, /* TODO(TrueKeyword): true */ TODO)
    }
    getQualifiedLeftMeaning := func(rightMeaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags.Value | import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags.Namespace */ TODO {
         /* TODO(ConditionalExpression): rightMeaning === SymbolFlags.Value ? SymbolFlags.Value : SymbolFlags.Namespace */ TODO
    }
    getAccessibleSymbolChain := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, useOnlyExternalAliasing bool, visitedSymbolTablesMap /* TODO(undefined): Map<number, import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable[]> */ TODO /* = */ /* TODO(NewExpression): new Map<SymbolId, SymbolTable[]>() */) /* TODO(ArrayType): Symbol[] */ any {
        if /* TODO(PrefixUnaryExpression): !(symbol && !isPropertyOrMethodDeclarationSymbol(symbol)) */ TODO {
             undefined
        }
        links := getSymbolLinks(symbol)
        cache := /* TODO(ParenthesizedExpression): (links.accessibleChainCache ||= new Map()) */ TODO
        firstRelevantLocation := forEachSymbolTableInScope(enclosingDeclaration, /* TODO(ArrowFunction): (_, __, ___, node) => node */ TODO)
        key := /* TODO(TemplateExpression): `${useOnlyExternalAliasing ? 0 : 1}|${firstRelevantLocation && getNodeId(firstRelevantLocation)}|${meaning}` */ TODO
        if /* TODO(PropertyAccessExpression): cache.has */ TODO(key) {
             /* TODO(PropertyAccessExpression): cache.get */ TODO(key)
        }
        id := getSymbolId(symbol)
        visitedSymbolTables := /* TODO(PropertyAccessExpression): visitedSymbolTablesMap.get */ TODO(id)
        if /* TODO(PrefixUnaryExpression): !visitedSymbolTables */ TODO {
            /* TODO(ExpressionStatement): visitedSymbolTablesMap.set(id, visitedSymbolTables = []); */
        }
        result := forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable)
        /* TODO(ExpressionStatement): cache.set(key, result); */
         result
        getAccessibleSymbolChainFromSymbolTable := func(symbols SymbolTable, ignoreQualification bool, isLocalNameLookup bool) /* TODO(ArrayType): Symbol[] */ any {
            if /* TODO(PrefixUnaryExpression): !pushIfUnique(visitedSymbolTables!, symbols) */ TODO {
                 undefined
            }
            result := trySymbolTable(symbols, ignoreQualification, isLocalNameLookup)
            /* TODO(ExpressionStatement): visitedSymbolTables!.pop(); */
             result
        }
        canQualifySymbol := func(symbolFromSymbolTable Symbol, meaning SymbolFlags) /* TODO(undefined): boolean */ TODO {
             /* TODO(BinaryExpression): !needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning) ||                 // If symbol needs qualification, make sure that parent is accessible, if it is then this symbol is accessible too                 !!getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing, visitedSymbolTablesMap) */ TODO
        }
        isAccessible := func(symbolFromSymbolTable Symbol, resolvedAliasSymbol Symbol, ignoreQualification bool) /* TODO(undefined): boolean */ TODO {
             /* TODO(BinaryExpression): (symbol === (resolvedAliasSymbol || symbolFromSymbolTable) || getMergedSymbol(symbol) === getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) &&                 // if the symbolFromSymbolTable is not external module (it could be if it was determined as ambient external module and would be in globals table)                 // and if symbolFromSymbolTable or alias resolution matches the symbol,                 // check the symbol can be qualified, it is only then this symbol is accessible                 !some(symbolFromSymbolTable.declarations, hasNonGlobalAugmentationExternalModuleSymbol) &&                 (ignoreQualification || canQualifySymbol(getMergedSymbol(symbolFromSymbolTable), meaning)) */ TODO
        }
        trySymbolTable := func(symbols SymbolTable, ignoreQualification /* TODO(BooleanKeyword): boolean */ any, isLocalNameLookup /* TODO(BooleanKeyword): boolean */ any) /* TODO(ArrayType): Symbol[] */ any {
            if isAccessible(/* TODO(NonNullExpression): symbols.get(symbol!.escapedName)! */ TODO, undefined, ignoreQualification) {
                 /* TODO(ArrayLiteralExpression): [symbol!] */ TODO
            }
            result := forEachEntry(symbols, /* TODO(ArrowFunction): symbolFromSymbolTable => {                 if (                     symbolFromSymbolTable.flags & SymbolFlags.Alias                     && symbolFromSymbolTable.escapedName !== InternalSymbolName.ExportEquals                     && symbolFromSymbolTable.escapedName !== InternalSymbolName.Default                     && !(isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && isExternalModule(getSourceFileOfNode(enclosingDeclaration)))                     // If `!useOnlyExternalAliasing`, we can use any type of alias to get the name                     && (!useOnlyExternalAliasing || some(symbolFromSymbolTable.declarations, isExternalModuleImportEqualsDeclaration))                     // If we're looking up a local name to reference directly, omit namespace reexports, otherwise when we're trawling through an export list to make a dotted name, we can keep it                     && (isLocalNameLookup ? !some(symbolFromSymbolTable.declarations, isNamespaceReexportDeclaration) : true)                     // While exports are generally considered to be in scope, export-specifier declared symbols are _not_                     // See similar comment in `resolveName` for details                     && (ignoreQualification || !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKind.ExportSpecifier))                 ) {                     const resolvedImportedSymbol = resolveAlias(symbolFromSymbolTable);                     const candidate = getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification);                     if (candidate) {                         return candidate;                     }                 }                 if (symbolFromSymbolTable.escapedName === symbol!.escapedName && symbolFromSymbolTable.exportSymbol) {                     if (isAccessible(getMergedSymbol(symbolFromSymbolTable.exportSymbol), /*resolvedAliasSymbol* / undefined, ignoreQualification)) {                         return [symbol!];                     }                 }             } */ TODO)
             /* TODO(BinaryExpression): result || (symbols === globals ? getCandidateListForSymbol(globalThisSymbol, globalThisSymbol, ignoreQualification) : undefined) */ TODO
        }
        getCandidateListForSymbol := func(symbolFromSymbolTable Symbol, resolvedImportedSymbol Symbol, ignoreQualification /* TODO(BooleanKeyword): boolean */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] | undefined */ TODO {
            if isAccessible(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification) {
                 /* TODO(ArrayLiteralExpression): [symbolFromSymbolTable] */ TODO
            }
            candidateTable := getExportsOfSymbol(resolvedImportedSymbol)
            accessibleSymbolsFromExports := /* TODO(BinaryExpression): candidateTable && getAccessibleSymbolChainFromSymbolTable(candidateTable, /*ignoreQualification* / true) */ TODO
            if /* TODO(BinaryExpression): accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning)) */ TODO {
                 /* TODO(PropertyAccessExpression): [symbolFromSymbolTable].concat */ TODO(accessibleSymbolsFromExports)
            }
        }
    }
    needsQualification := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) /* TODO(undefined): boolean */ TODO {
        qualify := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ExpressionStatement): forEachSymbolTableInScope(enclosingDeclaration, symbolTable => {             // If symbol of this name is not available in the symbol table we are ok             let symbolFromSymbolTable = getMergedSymbol(symbolTable.get(symbol.escapedName));             if (!symbolFromSymbolTable) {                 // Continue to the next symbol table                 return false;             }             // If the symbol with this name is present it should refer to the symbol             if (symbolFromSymbolTable === symbol) {                 // No need to qualify                 return true;             }              // Qualify if the symbol from symbol table has same meaning as expected             const shouldResolveAlias = symbolFromSymbolTable.flags & SymbolFlags.Alias && !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKind.ExportSpecifier);             symbolFromSymbolTable = shouldResolveAlias ? resolveAlias(symbolFromSymbolTable) : symbolFromSymbolTable;             const flags = shouldResolveAlias ? getSymbolFlags(symbolFromSymbolTable) : symbolFromSymbolTable.flags;             if (flags & meaning) {                 qualify = true;                 return true;             }              // Continue to the next symbol table             return false;         }); */
         qualify
    }
    isPropertyOrMethodDeclarationSymbol := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): symbol.declarations && symbol.declarations.length */ TODO {
            /* TODO(ForOfStatement): for (const declaration of symbol.declarations) {                 switch (declaration.kind) {                     case SyntaxKind.PropertyDeclaration:                     case SyntaxKind.MethodDeclaration:                     case SyntaxKind.GetAccessor:                     case SyntaxKind.SetAccessor:                         continue;                     default:                         return false;                 }             } */
             /* TODO(TrueKeyword): true */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isTypeSymbolAccessible := func(typeSymbol Symbol, enclosingDeclaration Node) bool {
        access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO, /* TODO(FalseKeyword): false */ TODO, /* TODO(TrueKeyword): true */ TODO)
         /* TODO(BinaryExpression): access.accessibility === SymbolAccessibility.Accessible */ TODO
    }
    isValueSymbolAccessible := func(typeSymbol Symbol, enclosingDeclaration Node) bool {
        access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO, /* TODO(FalseKeyword): false */ TODO, /* TODO(TrueKeyword): true */ TODO)
         /* TODO(BinaryExpression): access.accessibility === SymbolAccessibility.Accessible */ TODO
    }
    isSymbolAccessibleByFlags := func(typeSymbol Symbol, enclosingDeclaration Node, flags SymbolFlags) bool {
        access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, flags, /* TODO(FalseKeyword): false */ TODO, /* TODO(FalseKeyword): false */ TODO)
         /* TODO(BinaryExpression): access.accessibility === SymbolAccessibility.Accessible */ TODO
    }
    isAnySymbolAccessible := func(symbols /* TODO(ArrayType): Symbol[] */ any, enclosingDeclaration Node, initialSymbol Symbol, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) *SymbolAccessibilityResult {
        if /* TODO(PrefixUnaryExpression): !length(symbols) */ TODO {
        }
        var hadAccessibleChain *Symbol
        earlyModuleBail := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForOfStatement): for (const symbol of symbols!) {             // Symbol is accessible if it by itself is accessible             const accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, /*useOnlyExternalAliasing* / false);             if (accessibleSymbolChain) {                 hadAccessibleChain = symbol;                 const hasAccessibleDeclarations = hasVisibleDeclarations(accessibleSymbolChain[0], shouldComputeAliasesToMakeVisible);                 if (hasAccessibleDeclarations) {                     return hasAccessibleDeclarations;                 }             }             if (allowModules) {                 if (some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {                     if (shouldComputeAliasesToMakeVisible) {                         earlyModuleBail = true;                         // Generally speaking, we want to use the aliases that already exist to refer to a module, if present                         // In order to do so, we need to find those aliases in order to retain them in declaration emit; so                         // if we are in declaration emit, we cannot use the fast path for module visibility until we've exhausted                         // all other visibility options (in order to capture the possible aliases used to reference the module)                         continue;                     }                     // Any meaning of a module symbol is always accessible via an `import` type                     return {                         accessibility: SymbolAccessibility.Accessible,                     };                 }             }              // If we haven't got the accessible symbol, it doesn't mean the symbol is actually inaccessible.             // It could be a qualified symbol and hence verify the path             // e.g.:             // module m {             //     export class c {             //     }             // }             // const x: typeof m.c             // In the above example when we start with checking if typeof m.c symbol is accessible,             // we are going to see if c can be accessed in scope directly.             // But it can't, hence the accessible is going to be undefined, but that doesn't mean m.c is inaccessible             // It is accessible if the parent m is accessible because then m.c can be accessed through qualification              const containers = getContainersOfSymbol(symbol, enclosingDeclaration, meaning);             const parentResult = isAnySymbolAccessible(containers, enclosingDeclaration, initialSymbol, initialSymbol === symbol ? getQualifiedLeftMeaning(meaning) : meaning, shouldComputeAliasesToMakeVisible, allowModules);             if (parentResult) {                 return parentResult;             }         } */
        if earlyModuleBail {
             /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.Accessible,             } */ TODO
        }
        if hadAccessibleChain {
             /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.NotAccessible,                 errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),                 errorModuleName: hadAccessibleChain !== initialSymbol ? symbolToString(hadAccessibleChain, enclosingDeclaration, SymbolFlags.Namespace) : undefined,             } */ TODO
        }
    }
    isSymbolAccessible := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool) SymbolAccessibilityResult {
         isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible, /* TODO(TrueKeyword): true */ TODO)
    }
    isSymbolAccessibleWorker := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) SymbolAccessibilityResult {
        if /* TODO(BinaryExpression): symbol && enclosingDeclaration */ TODO {
            result := isAnySymbolAccessible(/* TODO(ArrayLiteralExpression): [symbol] */ TODO, enclosingDeclaration, symbol, meaning, shouldComputeAliasesToMakeVisible, allowModules)
            if result {
                 result
            }
            symbolExternalModule := forEach(/* TODO(PropertyAccessExpression): symbol.declarations */ TODO, getExternalModuleContainer)
            if symbolExternalModule {
                enclosingExternalModule := getExternalModuleContainer(enclosingDeclaration)
                if /* TODO(BinaryExpression): symbolExternalModule !== enclosingExternalModule */ TODO {
                     /* TODO(ObjectLiteralExpression): {                         accessibility: SymbolAccessibility.CannotBeNamed,                         errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),                         errorModuleName: symbolToString(symbolExternalModule),                         errorNode: isInJSFile(enclosingDeclaration) ? enclosingDeclaration : undefined,                     } */ TODO
                }
            }
             /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.NotAccessible,                 errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),             } */ TODO
        }
         /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
    }
    getExternalModuleContainer := func(declaration Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        node := findAncestor(declaration, hasExternalModuleSymbol)
         /* TODO(BinaryExpression): node && getSymbolOfDeclaration(node as AmbientModuleDeclaration | SourceFile) */ TODO
    }
    hasExternalModuleSymbol := func(declaration Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isAmbientModule(declaration) || (declaration.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(declaration as SourceFile)) */ TODO
    }
    hasNonGlobalAugmentationExternalModuleSymbol := func(declaration Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isModuleWithStringLiteralName(declaration) || (declaration.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(declaration as SourceFile)) */ TODO
    }
    hasVisibleDeclarations := func(symbol Symbol, shouldComputeAliasToMakeVisible bool) *SymbolVisibilityResult {
        var aliasesToMakeVisible /* TODO(ArrayType): LateVisibilityPaintedStatement[] */ any
        if /* TODO(PrefixUnaryExpression): !every(filter(symbol.declarations, d => d.kind !== SyntaxKind.Identifier), getIsDeclarationVisible) */ TODO {
             undefined
        }
         /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible, aliasesToMakeVisible } */ TODO
        getIsDeclarationVisible := func(declaration Declaration) /* TODO(undefined): boolean */ TODO {
            if /* TODO(PrefixUnaryExpression): !isDeclarationVisible(declaration) */ TODO {
                anyImportSyntax := getAnyImportSyntax(declaration)
                if /* TODO(BinaryExpression): anyImportSyntax &&                     !hasSyntacticModifier(anyImportSyntax, ModifierFlags.Export) && // import clause without export                     isDeclarationVisible(anyImportSyntax.parent) */ TODO {
                     addVisibleAlias(declaration, anyImportSyntax)
                } else if /* TODO(BinaryExpression): isVariableDeclaration(declaration) && isVariableStatement(declaration.parent.parent) &&                     !hasSyntacticModifier(declaration.parent.parent, ModifierFlags.Export) && // unexported variable statement                     isDeclarationVisible(declaration.parent.parent.parent) */ TODO {
                     addVisibleAlias(declaration, /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO)
                } else if /* TODO(BinaryExpression): isLateVisibilityPaintedStatement(declaration) // unexported top-level statement                     && !hasSyntacticModifier(declaration, ModifierFlags.Export)                     && isDeclarationVisible(declaration.parent) */ TODO {
                     addVisibleAlias(declaration, declaration)
                } else if isBindingElement(declaration) {
                    if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias && isInJSFile(declaration) && declaration.parent?.parent // exported import-like top-level JS require statement                         && isVariableDeclaration(declaration.parent.parent)                         && declaration.parent.parent.parent?.parent && isVariableStatement(declaration.parent.parent.parent.parent)                         && !hasSyntacticModifier(declaration.parent.parent.parent.parent, ModifierFlags.Export)                         && declaration.parent.parent.parent.parent.parent // check if the thing containing the variable statement is visible (ie, the file)                         && isDeclarationVisible(declaration.parent.parent.parent.parent.parent) */ TODO {
                         addVisibleAlias(declaration, /* TODO(PropertyAccessExpression): declaration.parent.parent.parent.parent */ TODO)
                    } else if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.BlockScopedVariable */ TODO {
                        variableStatement := /* TODO(NonNullExpression): findAncestor(declaration, isVariableStatement)! */ TODO
                        if hasSyntacticModifier(variableStatement, /* TODO(PropertyAccessExpression): ModifierFlags.Export */ TODO) {
                             /* TODO(TrueKeyword): true */ TODO
                        }
                        if /* TODO(PrefixUnaryExpression): !isDeclarationVisible(variableStatement.parent) */ TODO {
                             /* TODO(FalseKeyword): false */ TODO
                        }
                         addVisibleAlias(declaration, variableStatement)
                    }
                }
                 /* TODO(FalseKeyword): false */ TODO
            }
             /* TODO(TrueKeyword): true */ TODO
        }
        addVisibleAlias := func(declaration Declaration, aliasingStatement LateVisibilityPaintedStatement) /* TODO(undefined): boolean */ TODO {
            if shouldComputeAliasToMakeVisible {
                /* TODO(ExpressionStatement): getNodeLinks(declaration).isVisible = true; */
                /* TODO(ExpressionStatement): aliasesToMakeVisible = appendIfUnique(aliasesToMakeVisible, aliasingStatement); */
            }
             /* TODO(TrueKeyword): true */ TODO
        }
    }
    getMeaningOfEntityNameReference := func(entityName EntityNameOrEntityNameExpression) SymbolFlags {
        var meaning SymbolFlags
        if /* TODO(BinaryExpression): entityName.parent.kind === SyntaxKind.TypeQuery ||             entityName.parent.kind === SyntaxKind.ExpressionWithTypeArguments && !isPartOfTypeNode(entityName.parent) ||             entityName.parent.kind === SyntaxKind.ComputedPropertyName ||             entityName.parent.kind === SyntaxKind.TypePredicate && (entityName.parent as TypePredicateNode).parameterName === entityName */ TODO {
            /* TODO(ExpressionStatement): meaning = SymbolFlags.Value | SymbolFlags.ExportValue; */
        } else if /* TODO(BinaryExpression): entityName.kind === SyntaxKind.QualifiedName || entityName.kind === SyntaxKind.PropertyAccessExpression ||             entityName.parent.kind === SyntaxKind.ImportEqualsDeclaration ||             (entityName.parent.kind === SyntaxKind.QualifiedName && (entityName.parent as QualifiedName).left === entityName) ||             (entityName.parent.kind === SyntaxKind.PropertyAccessExpression && (entityName.parent as PropertyAccessExpression).expression === entityName) ||             (entityName.parent.kind === SyntaxKind.ElementAccessExpression && (entityName.parent as ElementAccessExpression).expression === entityName) */ TODO {
            /* TODO(ExpressionStatement): meaning = SymbolFlags.Namespace; */
        } else {
            /* TODO(ExpressionStatement): meaning = SymbolFlags.Type; */
        }
         meaning
    }
    isEntityNameVisible := func(entityName EntityNameOrEntityNameExpression, enclosingDeclaration Node, shouldComputeAliasToMakeVisible /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) SymbolVisibilityResult {
        meaning := getMeaningOfEntityNameReference(entityName)
        firstIdentifier := getFirstIdentifier(entityName)
        symbol := resolveName(enclosingDeclaration, /* TODO(PropertyAccessExpression): firstIdentifier.escapedText */ TODO, meaning, undefined, /* TODO(FalseKeyword): false */ TODO)
        if /* TODO(BinaryExpression): symbol && symbol.flags & SymbolFlags.TypeParameter && meaning & SymbolFlags.Type */ TODO {
             /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
        }
        if /* TODO(BinaryExpression): !symbol && isThisIdentifier(firstIdentifier) && isSymbolAccessible(getSymbolOfDeclaration(getThisContainer(firstIdentifier, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false)), firstIdentifier, meaning, /*shouldComputeAliasesToMakeVisible* / false).accessibility === SymbolAccessibility.Accessible */ TODO {
             /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
        }
        if /* TODO(PrefixUnaryExpression): !symbol */ TODO {
             /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.NotResolved,                 errorSymbolName: getTextOfNode(firstIdentifier),                 errorNode: firstIdentifier,             } */ TODO
        }
         /* TODO(BinaryExpression): hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) || {             accessibility: SymbolAccessibility.NotAccessible,             errorSymbolName: getTextOfNode(firstIdentifier),             errorNode: firstIdentifier,         } */ TODO
    }
    symbolToString := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags, flags SymbolFormatFlags /* = */ /* TODO(PropertyAccessExpression): SymbolFormatFlags.AllowAnyNodeKind */, writer EmitTextWriter) string {
        nodeFlags := /* TODO(PropertyAccessExpression): NodeBuilderFlags.IgnoreErrors */ TODO
        internalNodeFlags := /* TODO(PropertyAccessExpression): InternalNodeBuilderFlags.None */ TODO
        if /* TODO(BinaryExpression): flags & SymbolFormatFlags.UseOnlyExternalAliasing */ TODO {
            /* TODO(ExpressionStatement): nodeFlags |= NodeBuilderFlags.UseOnlyExternalAliasing; */
        }
        if /* TODO(BinaryExpression): flags & SymbolFormatFlags.WriteTypeParametersOrArguments */ TODO {
            /* TODO(ExpressionStatement): nodeFlags |= NodeBuilderFlags.WriteTypeParametersInQualifiedName; */
        }
        if /* TODO(BinaryExpression): flags & SymbolFormatFlags.UseAliasDefinedOutsideCurrentScope */ TODO {
            /* TODO(ExpressionStatement): nodeFlags |= NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope; */
        }
        if /* TODO(BinaryExpression): flags & SymbolFormatFlags.DoNotIncludeSymbolChain */ TODO {
            /* TODO(ExpressionStatement): internalNodeFlags |= InternalNodeBuilderFlags.DoNotIncludeSymbolChain; */
        }
        if /* TODO(BinaryExpression): flags & SymbolFormatFlags.WriteComputedProps */ TODO {
            /* TODO(ExpressionStatement): internalNodeFlags |= InternalNodeBuilderFlags.WriteComputedProps; */
        }
        builder := /* TODO(ConditionalExpression): flags & SymbolFormatFlags.AllowAnyNodeKind ? nodeBuilder.symbolToNode : nodeBuilder.symbolToEntityName */ TODO
         /* TODO(ConditionalExpression): writer ? symbolToStringWorker(writer).getText() : usingSingleLineStringWriter(symbolToStringWorker) */ TODO
        symbolToStringWorker := func(writer EmitTextWriter) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ TODO {
            entity := /* TODO(NonNullExpression): builder(symbol, meaning!, enclosingDeclaration, nodeFlags, internalNodeFlags)! */ TODO
            printer := /* TODO(ConditionalExpression): enclosingDeclaration?.kind === SyntaxKind.SourceFile                 ? createPrinterWithRemoveCommentsNeverAsciiEscape()                 : createPrinterWithRemoveComments() */ TODO
            sourceFile := /* TODO(BinaryExpression): enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration) */ TODO
            /* TODO(ExpressionStatement): printer.writeNode(EmitHint.Unspecified, entity, /*sourceFile* / sourceFile, writer); */
             writer
        }
    }
    signatureToString := func(signature Signature, enclosingDeclaration Node, flags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFormatFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): TypeFormatFlags.None */, kind SignatureKind, writer EmitTextWriter) string {
         /* TODO(ConditionalExpression): writer ? signatureToStringWorker(writer).getText() : usingSingleLineStringWriter(signatureToStringWorker) */ TODO
        signatureToStringWorker := func(writer EmitTextWriter) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ TODO {
            var sigOutput SyntaxKind
            if /* TODO(BinaryExpression): flags & TypeFormatFlags.WriteArrowStyleSignature */ TODO {
                /* TODO(ExpressionStatement): sigOutput = kind === SignatureKind.Construct ? SyntaxKind.ConstructorType : SyntaxKind.FunctionType; */
            } else {
                /* TODO(ExpressionStatement): sigOutput = kind === SignatureKind.Construct ? SyntaxKind.ConstructSignature : SyntaxKind.CallSignature; */
            }
            sig := /* TODO(PropertyAccessExpression): nodeBuilder.signatureToSignatureDeclaration */ TODO(signature, sigOutput, enclosingDeclaration, /* TODO(BinaryExpression): toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | NodeBuilderFlags.WriteTypeParametersInQualifiedName */ TODO)
            printer := createPrinterWithRemoveCommentsOmitTrailingSemicolon()
            sourceFile := /* TODO(BinaryExpression): enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration) */ TODO
            /* TODO(ExpressionStatement): printer.writeNode(EmitHint.Unspecified, sig!, /*sourceFile* / sourceFile, getTrailingSemicolonDeferringWriter(writer)); */
             writer
        }
    }
    typeToString := func(type_ Type, enclosingDeclaration Node, flags TypeFormatFlags /* = */ /* TODO(BinaryExpression): TypeFormatFlags.AllowUniqueESSymbolType | TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter /* = */ /* TODO(CallExpression): createTextWriter("") */) string {
        noTruncation := /* TODO(BinaryExpression): compilerOptions.noErrorTruncation || flags & TypeFormatFlags.NoTruncation */ TODO
        typeNode := /* TODO(PropertyAccessExpression): nodeBuilder.typeToTypeNode */ TODO(type_, enclosingDeclaration, /* TODO(BinaryExpression): toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | (noTruncation ? NodeBuilderFlags.NoTruncation : NodeBuilderFlags.None) */ TODO, undefined)
        if /* TODO(BinaryExpression): typeNode === undefined */ TODO {
            /* TODO(CallExpression): Debug.fail("should always get typenode") */
        }
        printer := /* TODO(ConditionalExpression): type !== unresolvedType ? createPrinterWithRemoveComments() : createPrinterWithDefaults() */ TODO
        sourceFile := /* TODO(BinaryExpression): enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration) */ TODO
        /* TODO(ExpressionStatement): printer.writeNode(EmitHint.Unspecified, typeNode, /*sourceFile* / sourceFile, writer); */
        result := /* TODO(PropertyAccessExpression): writer.getText */ TODO()
        maxLength := /* TODO(ConditionalExpression): noTruncation ? noTruncationMaximumTruncationLength * 2 : defaultMaximumTruncationLength * 2 */ TODO
        if /* TODO(BinaryExpression): maxLength && result && result.length >= maxLength */ TODO {
             /* TODO(BinaryExpression): result.substr(0, maxLength - "...".length) + "..." */ TODO
        }
         result
    }
    getTypeNamesForErrorDisplay := func(left Type, right Type) /* TODO(TupleType): [string, string] */ TODO {
        leftStr := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(left.symbol) ? typeToString(left, left.symbol.valueDeclaration) : typeToString(left) */ TODO
        rightStr := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(right.symbol) ? typeToString(right, right.symbol.valueDeclaration) : typeToString(right) */ TODO
        if /* TODO(BinaryExpression): leftStr === rightStr */ TODO {
            /* TODO(ExpressionStatement): leftStr = getTypeNameForErrorDisplay(left); */
            /* TODO(ExpressionStatement): rightStr = getTypeNameForErrorDisplay(right); */
        }
         /* TODO(ArrayLiteralExpression): [leftStr, rightStr] */ TODO
    }
    getTypeNameForErrorDisplay := func(type_ Type) /* TODO(undefined): string */ TODO {
         typeToString(type_, undefined, /* TODO(PropertyAccessExpression): TypeFormatFlags.UseFullyQualifiedType */ TODO)
    }
    symbolValueDeclarationIsContextSensitive := func(symbol Symbol) bool {
         /* TODO(BinaryExpression): symbol && !!symbol.valueDeclaration && isExpression(symbol.valueDeclaration) && !isContextSensitive(symbol.valueDeclaration) */ TODO
    }
    toNodeBuilderFlags := func(flags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFormatFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): TypeFormatFlags.None */) NodeBuilderFlags {
         /* TODO(BinaryExpression): flags & TypeFormatFlags.NodeBuilderFlagsMask */ TODO
    }
    isClassInstanceSide := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !!type.symbol && !!(type.symbol.flags & SymbolFlags.Class) && (type === getDeclaredTypeOfClassOrInterface(type.symbol) || (!!(type.flags & TypeFlags.Object) && !!(getObjectFlags(type) & ObjectFlags.IsClassInstanceClone))) */ TODO
    }
    getTypeFromTypeNodeWithoutContext := func(node TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         getTypeFromTypeNode(node)
    }
    createNodeBuilder := func() /* TODO(undefined): { typeToTypeNode: (type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; typePredicateToTypePredicateNode: (typePredicate: import("/home/jabaile/work/TypeScript/src/compiler/types").TypePredicate, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypePredicateNode | undefined; expressionOrTypeToTypeNode: (expr: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttributeValue | undefined, type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, addUndefined?: boolean | undefined, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; serializeTypeForDeclaration: (declaration: import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration, type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; serializeReturnTypeForSignature: (signature: import("/home/jabaile/work/TypeScript/src/compiler/types").Signature, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; indexInfoToIndexSignatureDeclaration: (indexInfo: import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | undefined; signatureToSignatureDeclaration: (signature: import("/home/jabaile/work/TypeScript/src/compiler/types").Signature, kind: import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.MethodSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.MethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.Constructor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.GetAccessor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.SetAccessor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.CallSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ConstructSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.IndexSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionType | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ConstructorType | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ArrowFunction | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.JSDocFunctionType, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").SignatureDeclaration | undefined; symbolToEntityName: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").EntityName | undefined; symbolToExpression: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined; symbolToTypeParameterDeclarations: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").NodeArray<import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration> | undefined; symbolToParameterDeclaration: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined; typeParameterToDeclaration: (parameter: import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration | undefined; symbolTableToDeclarationStatements: (symbolTable: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] | undefined; symbolToNode: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName | undefined; } */ TODO {
         /* TODO(ObjectLiteralExpression): {             typeToTypeNode: (type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeToTypeNodeHelper(type, context)),             typePredicateToTypePredicateNode: (typePredicate: TypePredicate, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typePredicateToTypePredicateNodeHelper(typePredicate, context)),             expressionOrTypeToTypeNode: (expr: Expression | JsxAttributeValue | undefined, type: Type, addUndefined?: boolean, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => expressionOrTypeToTypeNode(context, expr, type, addUndefined)),             serializeTypeForDeclaration: (declaration: Declaration, type: Type, symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => serializeTypeForDeclaration(context, declaration, type, symbol)),             serializeReturnTypeForSignature: (signature: Signature, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => serializeReturnTypeForSignature(context, signature)),             indexInfoToIndexSignatureDeclaration: (indexInfo: IndexInfo, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => indexInfoToIndexSignatureDeclarationHelper(indexInfo, context, /*typeNode* / undefined)),             signatureToSignatureDeclaration: (signature: Signature, kind: SignatureDeclaration["kind"], enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => signatureToSignatureDeclarationHelper(signature, kind, context)),             symbolToEntityName: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToName(symbol, context, meaning, /*expectsIdentifier* / false)),             symbolToExpression: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToExpression(symbol, context, meaning)),             symbolToTypeParameterDeclarations: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeParametersToTypeParameterDeclarations(symbol, context)),             symbolToParameterDeclaration: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToParameterDeclaration(symbol, context)),             typeParameterToDeclaration: (parameter: TypeParameter, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeParameterToDeclaration(parameter, context)),             symbolTableToDeclarationStatements: (symbolTable: SymbolTable, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolTableToDeclarationStatements(symbolTable, context)),             symbolToNode: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToNode(symbol, context, meaning)),         } */ TODO
        // OVERLOAD: getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes /* TODO(LiteralType): false */ TODO) Type
        // OVERLOAD: getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes /* TODO(LiteralType): true */ TODO) *Type
        getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes bool) *Type {
            type_ := getTypeFromTypeNodeWithoutContext(node)
            if /* TODO(PrefixUnaryExpression): !context.mapper */ TODO {
                /* TODO(Identifier): type */
            }
            mappedType := instantiateType(type_, /* TODO(PropertyAccessExpression): context.mapper */ TODO)
             /* TODO(ConditionalExpression): noMappedTypes && mappedType !== type ? undefined : mappedType */ TODO
        }
        setTextRange := func(context NodeBuilderContext, range_ T, location Node) T {
            if /* TODO(BinaryExpression): !nodeIsSynthesized(range) || !(range.flags & NodeFlags.Synthesized) || !context.enclosingFile || context.enclosingFile !== getSourceFileOfNode(getOriginalNode(range)) */ TODO {
                /* TODO(ExpressionStatement): range = factory.cloneNode(range); */
            }
            if /* TODO(BinaryExpression): range === location */ TODO {
                /* TODO(Identifier): range */
            }
            if /* TODO(PrefixUnaryExpression): !location */ TODO {
                 range_
            }
            original := /* TODO(PropertyAccessExpression): range.original */ TODO
            /* TODO(WhileStatement): while (original && original !== location) {                 original = original.original;             } */
            if /* TODO(PrefixUnaryExpression): !original */ TODO {
                /* TODO(ExpressionStatement): setOriginalNode(range, location); */
            }
            if /* TODO(BinaryExpression): context.enclosingFile && context.enclosingFile === getSourceFileOfNode(getOriginalNode(location)) */ TODO {
                 setTextRangeWorker(range_, location)
            }
             range_
        }
        expressionOrTypeToTypeNode := func(context NodeBuilderContext, expr /* TODO(UnionType): Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
            restoreFlags := saveRestoreFlags(context)
            if /* TODO(BinaryExpression): expr && !(context.internalFlags & InternalNodeBuilderFlags.NoSyntacticPrinter) */ TODO {
                /* TODO(ExpressionStatement): syntacticNodeBuilder.serializeTypeOfExpression(expr, context, addUndefined); */
            }
            /* TODO(ExpressionStatement): context.internalFlags |= InternalNodeBuilderFlags.NoSyntacticPrinter; */
            result := expressionOrTypeToTypeNodeHelper(context, expr, type_, addUndefined)
            /* TODO(ExpressionStatement): restoreFlags(); */
             result
        }
        expressionOrTypeToTypeNodeHelper := func(context NodeBuilderContext, expr /* TODO(UnionType): Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
            if expr {
                typeNode := /* TODO(ConditionalExpression): isAssertionExpression(expr) ? expr.type                     : isJSDocTypeAssertion(expr) ? getJSDocTypeAssertionType(expr)                     : undefined */ TODO
                if /* TODO(BinaryExpression): typeNode && !isConstTypeReference(typeNode) */ TODO {
                    result := tryReuseExistingTypeNode(context, typeNode, type_, /* TODO(PropertyAccessExpression): expr.parent */ TODO, addUndefined)
                    if result {
                         result
                    }
                }
            }
            if addUndefined {
                /* TODO(ExpressionStatement): type = getOptionalType(type); */
            }
             typeToTypeNodeHelper(type_, context)
        }
        tryReuseExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode, type_ Type, host Node, addUndefined bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
            originalType := type_
            if addUndefined {
                /* TODO(ExpressionStatement): type = getOptionalType(type, !isParameter(host)); */
            }
            clone := tryReuseExistingNonParameterTypeNode(context, typeNode, type_, host)
            if clone {
                if /* TODO(BinaryExpression): addUndefined && containsNonMissingUndefinedType(type) && !someType(getTypeFromTypeNode(context, typeNode), t => !!(t.flags & TypeFlags.Undefined)) */ TODO {
                     /* TODO(PropertyAccessExpression): factory.createUnionTypeNode */ TODO(/* TODO(ArrayLiteralExpression): [clone, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)] */ TODO)
                }
                 clone
            }
            if /* TODO(BinaryExpression): addUndefined && originalType !== type */ TODO {
                cloneMissingUndefined := tryReuseExistingNonParameterTypeNode(context, typeNode, originalType, host)
                if cloneMissingUndefined {
                     /* TODO(PropertyAccessExpression): factory.createUnionTypeNode */ TODO(/* TODO(ArrayLiteralExpression): [cloneMissingUndefined, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)] */ TODO)
                }
            }
             undefined
        }
        tryReuseExistingNonParameterTypeNode := func(context NodeBuilderContext, existing TypeNode, type_ Type, host /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO /* = */ /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, annotationType /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO /* = */ /* TODO(CallExpression): getTypeFromTypeNode(context, existing, /*noMappedTypes* / true) */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
            if /* TODO(BinaryExpression): annotationType && typeNodeIsEquivalentToType(host, type, annotationType) && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type) */ TODO {
                result := tryReuseExistingTypeNodeHelper(context, existing)
                if result {
                     result
                }
            }
             undefined
        }
        symbolToNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName */ TODO {
            if /* TODO(BinaryExpression): context.internalFlags & InternalNodeBuilderFlags.WriteComputedProps */ TODO {
                if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
                    name := getNameOfDeclaration(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
                    if /* TODO(BinaryExpression): name && isComputedPropertyName(name) */ TODO {
                        /* TODO(Identifier): name */
                    }
                }
                nameType := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).nameType */ TODO
                if /* TODO(BinaryExpression): nameType && nameType.flags & (TypeFlags.EnumLiteral | TypeFlags.UniqueESSymbol) */ TODO {
                    /* TODO(ExpressionStatement): context.enclosingDeclaration = nameType.symbol.valueDeclaration; */
                     /* TODO(PropertyAccessExpression): factory.createComputedPropertyName */ TODO(symbolToExpression(/* TODO(PropertyAccessExpression): nameType.symbol */ TODO, context, meaning))
                }
            }
             symbolToExpression(symbol, context, meaning)
        }
        withContext := func(enclosingDeclaration Node, flags *NodeBuilderFlags, internalFlags *InternalNodeBuilderFlags, tracker *SymbolTracker, cb func(context NodeBuilderContext) T) *T {
            moduleResolverHost := /* TODO(ConditionalExpression): tracker?.trackSymbol ? tracker.moduleResolverHost :                 (internalFlags || InternalNodeBuilderFlags.None) & InternalNodeBuilderFlags.DoNotIncludeSymbolChain ? createBasicNodeBuilderModuleSpecifierResolutionHost(host) :                 undefined */ TODO
            var context NodeBuilderContext = /* TODO(ObjectLiteralExpression): {                 enclosingDeclaration,                 enclosingFile: enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration),                 flags: flags || NodeBuilderFlags.None,                 internalFlags: internalFlags || InternalNodeBuilderFlags.None,                 tracker: undefined!,                 encounteredError: false,                 reportedDiagnostic: false,                 visitedTypes: undefined,                 symbolDepth: undefined,                 inferTypeParameters: undefined,                 approximateLength: 0,                 trackedSymbols: undefined,                 bundled: !!compilerOptions.outFile && !!enclosingDeclaration && isExternalOrCommonJsModule(getSourceFileOfNode(enclosingDeclaration)),                 truncating: false,                 usedSymbolNames: undefined,                 remappedSymbolNames: undefined,                 remappedSymbolReferences: undefined,                 reverseMappedStack: undefined,                 mustCreateTypeParameterSymbolList: true,                 typeParameterSymbolList: undefined,                 mustCreateTypeParametersNamesLookups: true,                 typeParameterNames: undefined,                 typeParameterNamesByText: undefined,                 typeParameterNamesByTextNextNameCount: undefined,                 mapper: undefined,             } */ TODO
            /* TODO(ExpressionStatement): context.tracker = new SymbolTrackerImpl(context, tracker, moduleResolverHost); */
            resultingNode := cb(context)
            if /* TODO(BinaryExpression): context.truncating && context.flags & NodeBuilderFlags.NoTruncation */ TODO {
                /* TODO(ExpressionStatement): context.tracker.reportTruncationError(); */
            }
             /* TODO(ConditionalExpression): context.encounteredError ? undefined : resultingNode */ TODO
        }
        saveRestoreFlags := func(context NodeBuilderContext) /* TODO(undefined): () => void */ TODO {
            flags := /* TODO(PropertyAccessExpression): context.flags */ TODO
            internalFlags := /* TODO(PropertyAccessExpression): context.internalFlags */ TODO
             restore
            restore := func() {
                /* TODO(ExpressionStatement): context.flags = flags; */
                /* TODO(ExpressionStatement): context.internalFlags = internalFlags; */
            }
        }
        checkTruncationLength := func(context NodeBuilderContext) bool {
            if /* TODO(PropertyAccessExpression): context.truncating */ TODO {
                /* TODO(PropertyAccessExpression): context.truncating */
            }
             /* TODO(BinaryExpression): context.truncating = context.approximateLength > ((context.flags & NodeBuilderFlags.NoTruncation) ? noTruncationMaximumTruncationLength : defaultMaximumTruncationLength) */ TODO
        }
        typeToTypeNodeHelper := func(type_ Type, context NodeBuilderContext) TypeNode {
            restoreFlags := saveRestoreFlags(context)
            typeNode := typeToTypeNodeWorker(type_, context)
            /* TODO(ExpressionStatement): restoreFlags(); */
             typeNode
        }
        typeToTypeNodeWorker := func(type_ Type, context NodeBuilderContext) TypeNode {
            if /* TODO(BinaryExpression): cancellationToken && cancellationToken.throwIfCancellationRequested */ TODO {
                /* TODO(ExpressionStatement): cancellationToken.throwIfCancellationRequested(); */
            }
            inTypeAlias := /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.InTypeAlias */ TODO
            /* TODO(ExpressionStatement): context.flags &= ~NodeBuilderFlags.InTypeAlias; */
            if /* TODO(PrefixUnaryExpression): !type */ TODO {
                if /* TODO(PrefixUnaryExpression): !(context.flags & NodeBuilderFlags.AllowEmptyUnionOrIntersection) */ TODO {
                    /* TODO(ExpressionStatement): context.encounteredError = true; */
                     /* TODO(NonNullExpression): undefined! */ TODO
                }
                /* TODO(ExpressionStatement): context.approximateLength += 3; */
                 /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO)
            }
            if /* TODO(PrefixUnaryExpression): !(context.flags & NodeBuilderFlags.NoTypeReduction) */ TODO {
                /* TODO(ExpressionStatement): type = getReducedType(type); */
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Any */ TODO {
                if /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO {
                     /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(symbolToEntityNameNode(/* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO), mapToTypeNodes(/* TODO(PropertyAccessExpression): type.aliasTypeArguments */ TODO, context))
                }
                if /* TODO(BinaryExpression): type === unresolvedType */ TODO {
                     addSyntheticLeadingComment(/* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO), /* TODO(PropertyAccessExpression): SyntaxKind.MultiLineCommentTrivia */ TODO, "unresolved")
                }
                /* TODO(ExpressionStatement): context.approximateLength += 3; */
                 /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(ConditionalExpression): type === intrinsicMarkerType ? SyntaxKind.IntrinsicKeyword : SyntaxKind.AnyKeyword */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Unknown */ TODO {
                 /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.UnknownKeyword */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.String */ TODO {
                /* TODO(ExpressionStatement): context.approximateLength += 6; */
                 /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.StringKeyword */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Number */ TODO {
                /* TODO(ExpressionStatement): context.approximateLength += 6; */
                 /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.NumberKeyword */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.BigInt */ TODO {
                /* TODO(ExpressionStatement): context.approximateLength += 6; */
                 /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.BigIntKeyword */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Boolean && !type.aliasSymbol */ TODO {
                /* TODO(ExpressionStatement): context.approximateLength += 7; */
                 /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.BooleanKeyword */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.EnumLike */ TODO {
                if /* TODO(BinaryExpression): type.symbol.flags & SymbolFlags.EnumMember */ TODO {
                    parentSymbol := /* TODO(NonNullExpression): getParentOfSymbol(type.symbol)! */ TODO
                    parentName := symbolToTypeNode(parentSymbol, context, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO)
                    if /* TODO(BinaryExpression): getDeclaredTypeOfSymbol(parentSymbol) === type */ TODO {
                         parentName
                    }
                    memberName := symbolName(/* TODO(PropertyAccessExpression): type.symbol */ TODO)
                    if isIdentifierText(memberName, /* TODO(PropertyAccessExpression): ScriptTarget.ES5 */ TODO) {
                         appendReferenceToType(parentName /* as */ /* TODO(UnionType): TypeReferenceNode | ImportTypeNode */, /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(memberName, undefined))
                    }
                    if isImportTypeNode(parentName) {
                        /* TODO(ExpressionStatement): (parentName as any).isTypeOf = true; */
                         /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO(parentName, /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(memberName)))
                    } else if isTypeReferenceNode(parentName) {
                         /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createTypeQueryNode */ TODO(/* TODO(PropertyAccessExpression): parentName.typeName */ TODO), /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(memberName)))
                    } else {
                         /* TODO(PropertyAccessExpression): Debug.fail */ TODO("Unhandled type node kind returned from `symbolToTypeNode`.")
                    }
                }
                 symbolToTypeNode(/* TODO(PropertyAccessExpression): type.symbol */ TODO, context, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.StringLiteral */ TODO {
                /* TODO(ExpressionStatement): context.approximateLength += (type as StringLiteralType).value.length + 2; */
                 /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO(setEmitFlags(/* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(/* TODO(PropertyAccessExpression): (type as StringLiteralType).value */ TODO, /* TODO(PrefixUnaryExpression): !!(context.flags & NodeBuilderFlags.UseSingleQuotesForStringLiteralType) */ TODO), /* TODO(PropertyAccessExpression): EmitFlags.NoAsciiEscaping */ TODO))
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.NumberLiteral */ TODO {
                value := /* TODO(PropertyAccessExpression): (type as NumberLiteralType).value */ TODO
                /* TODO(ExpressionStatement): context.approximateLength += ("" + value).length; */
                 /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO(/* TODO(ConditionalExpression): value < 0 ? factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createNumericLiteral(-value)) : factory.createNumericLiteral(value) */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.BigIntLiteral */ TODO {
                /* TODO(ExpressionStatement): context.approximateLength += (pseudoBigIntToString((type as BigIntLiteralType).value).length) + 1; */
                 /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createBigIntLiteral */ TODO(/* TODO(PropertyAccessExpression): (type as BigIntLiteralType).value */ TODO))
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.BooleanLiteral */ TODO {
                /* TODO(ExpressionStatement): context.approximateLength += (type as IntrinsicType).intrinsicName.length; */
                 /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO(/* TODO(ConditionalExpression): (type as IntrinsicType).intrinsicName === "true" ? factory.createTrue() : factory.createFalse() */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.UniqueESSymbol */ TODO {
                if /* TODO(PrefixUnaryExpression): !(context.flags & NodeBuilderFlags.AllowUniqueESSymbolType) */ TODO {
                    if isValueSymbolAccessible(/* TODO(PropertyAccessExpression): type.symbol */ TODO, /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO) {
                        /* TODO(ExpressionStatement): context.approximateLength += 6; */
                         symbolToTypeNode(/* TODO(PropertyAccessExpression): type.symbol */ TODO, context, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO)
                    }
                    if /* TODO(PropertyAccessExpression): context.tracker.reportInaccessibleUniqueSymbolError */ TODO {
                        /* TODO(ExpressionStatement): context.tracker.reportInaccessibleUniqueSymbolError(); */
                    }
                }
                /* TODO(ExpressionStatement): context.approximateLength += 13; */
                 /* TODO(PropertyAccessExpression): factory.createTypeOperatorNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.UniqueKeyword */ TODO, /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.SymbolKeyword */ TODO))
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Void */ TODO {
                /* TODO(ExpressionStatement): context.approximateLength += 4; */
                 /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.VoidKeyword */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Undefined */ TODO {
                /* TODO(ExpressionStatement): context.approximateLength += 9; */
                 /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.UndefinedKeyword */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Null */ TODO {
                /* TODO(ExpressionStatement): context.approximateLength += 4; */
                 /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createNull */ TODO())
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Never */ TODO {
                /* TODO(ExpressionStatement): context.approximateLength += 5; */
                 /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.NeverKeyword */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.ESSymbol */ TODO {
                /* TODO(ExpressionStatement): context.approximateLength += 6; */
                 /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.SymbolKeyword */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.NonPrimitive */ TODO {
                /* TODO(ExpressionStatement): context.approximateLength += 6; */
                 /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.ObjectKeyword */ TODO)
            }
            if isThisTypeParameter(type_) {
                if /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.InObjectTypeLiteral */ TODO {
                    if /* TODO(BinaryExpression): !context.encounteredError && !(context.flags & NodeBuilderFlags.AllowThisInObjectLiteral) */ TODO {
                        /* TODO(ExpressionStatement): context.encounteredError = true; */
                    }
                    /* TODO(ExpressionStatement): context.tracker.reportInaccessibleThisError?.(); */
                }
                /* TODO(ExpressionStatement): context.approximateLength += 4; */
                 /* TODO(PropertyAccessExpression): factory.createThisTypeNode */ TODO()
            }
            if /* TODO(BinaryExpression): !inTypeAlias && type.aliasSymbol && (context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope || isTypeSymbolAccessible(type.aliasSymbol, context.enclosingDeclaration)) */ TODO {
                typeArgumentNodes := mapToTypeNodes(/* TODO(PropertyAccessExpression): type.aliasTypeArguments */ TODO, context)
                if /* TODO(BinaryExpression): isReservedMemberName(type.aliasSymbol.escapedName) && !(type.aliasSymbol.flags & SymbolFlags.Class) */ TODO {
                    /* TODO(CallExpression): factory.createTypeReferenceNode(factory.createIdentifier(""), typeArgumentNodes) */
                }
                if /* TODO(BinaryExpression): length(typeArgumentNodes) === 1 && type.aliasSymbol === globalArrayType.symbol */ TODO {
                     /* TODO(PropertyAccessExpression): factory.createArrayTypeNode */ TODO(/* TODO(ElementAccessExpression): typeArgumentNodes![0] */ TODO)
                }
                 symbolToTypeNode(/* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO, context, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO, typeArgumentNodes)
            }
            objectFlags := getObjectFlags(type_)
            if /* TODO(BinaryExpression): objectFlags & ObjectFlags.Reference */ TODO {
                /* TODO(ExpressionStatement): Debug.assert(!!(type.flags & TypeFlags.Object)); */
                 /* TODO(ConditionalExpression): (type as TypeReference).node ? visitAndTransformType(type as TypeReference, typeReferenceToTypeNode) : typeReferenceToTypeNode(type as TypeReference) */ TODO
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.TypeParameter || objectFlags & ObjectFlags.ClassOrInterface */ TODO {
                if /* TODO(BinaryExpression): type.flags & TypeFlags.TypeParameter && contains(context.inferTypeParameters, type) */ TODO {
                    /* TODO(ExpressionStatement): context.approximateLength += symbolName(type.symbol).length + 6; */
                    var constraintNode *TypeNode
                    constraint := getConstraintOfTypeParameter(type_ /* as */ /* TODO(TypeReference): TypeParameter */)
                    if constraint {
                        inferredConstraint := getInferredTypeParameterConstraint(type_ /* as */ /* TODO(TypeReference): TypeParameter */, /* TODO(TrueKeyword): true */ TODO)
                        if /* TODO(PrefixUnaryExpression): !(inferredConstraint && isTypeIdenticalTo(constraint, inferredConstraint)) */ TODO {
                            /* TODO(ExpressionStatement): context.approximateLength += 9; */
                            /* TODO(ExpressionStatement): constraintNode = constraint && typeToTypeNodeHelper(constraint, context); */
                        }
                    }
                     /* TODO(PropertyAccessExpression): factory.createInferTypeNode */ TODO(typeParameterToDeclarationWithConstraint(type_ /* as */ /* TODO(TypeReference): TypeParameter */, context, constraintNode))
                }
                if /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams &&                     type.flags & TypeFlags.TypeParameter */ TODO {
                    name := typeParameterToName(type_, context)
                    /* TODO(ExpressionStatement): context.approximateLength += idText(name).length; */
                     /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(/* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(idText(name)), undefined)
                }
                if /* TODO(PropertyAccessExpression): type.symbol */ TODO {
                     symbolToTypeNode(/* TODO(PropertyAccessExpression): type.symbol */ TODO, context, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO)
                }
                name := /* TODO(ConditionalExpression): (type === markerSuperTypeForCheck || type === markerSubTypeForCheck) && varianceTypeParameter && varianceTypeParameter.symbol ?                     (type === markerSubTypeForCheck ? "sub-" : "super-") + symbolName(varianceTypeParameter.symbol) : "?" */ TODO
                 /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(/* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(name), undefined)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Union && (type as UnionType).origin */ TODO {
                /* TODO(ExpressionStatement): type = (type as UnionType).origin!; */
            }
            if /* TODO(BinaryExpression): type.flags & (TypeFlags.Union | TypeFlags.Intersection) */ TODO {
                types := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? formatUnionTypes((type as UnionType).types) : (type as IntersectionType).types */ TODO
                if /* TODO(BinaryExpression): length(types) === 1 */ TODO {
                     typeToTypeNodeHelper(/* TODO(ElementAccessExpression): types[0] */ TODO, context)
                }
                typeNodes := mapToTypeNodes(types, context, /* TODO(TrueKeyword): true */ TODO)
                if /* TODO(BinaryExpression): typeNodes && typeNodes.length > 0 */ TODO {
                     /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? factory.createUnionTypeNode(typeNodes) : factory.createIntersectionTypeNode(typeNodes) */ TODO
                } else {
                    if /* TODO(BinaryExpression): !context.encounteredError && !(context.flags & NodeBuilderFlags.AllowEmptyUnionOrIntersection) */ TODO {
                        /* TODO(ExpressionStatement): context.encounteredError = true; */
                    }
                     /* TODO(NonNullExpression): undefined! */ TODO
                }
            }
            if /* TODO(BinaryExpression): objectFlags & (ObjectFlags.Anonymous | ObjectFlags.Mapped) */ TODO {
                /* TODO(ExpressionStatement): Debug.assert(!!(type.flags & TypeFlags.Object)); */
                 createAnonymousTypeNode(type_ /* as */ /* TODO(TypeReference): ObjectType */)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Index */ TODO {
                indexedType := /* TODO(PropertyAccessExpression): (type as IndexType).type */ TODO
                /* TODO(ExpressionStatement): context.approximateLength += 6; */
                indexTypeNode := typeToTypeNodeHelper(indexedType, context)
                 /* TODO(PropertyAccessExpression): factory.createTypeOperatorNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.KeyOfKeyword */ TODO, indexTypeNode)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.TemplateLiteral */ TODO {
                texts := /* TODO(PropertyAccessExpression): (type as TemplateLiteralType).texts */ TODO
                types := /* TODO(PropertyAccessExpression): (type as TemplateLiteralType).types */ TODO
                templateHead := /* TODO(PropertyAccessExpression): factory.createTemplateHead */ TODO(/* TODO(ElementAccessExpression): texts[0] */ TODO)
                templateSpans := /* TODO(PropertyAccessExpression): factory.createNodeArray */ TODO(map_(types, /* TODO(ArrowFunction): (t, i) =>                         factory.createTemplateLiteralTypeSpan(                             typeToTypeNodeHelper(t, context),                             (i < types.length - 1 ? factory.createTemplateMiddle : factory.createTemplateTail)(texts[i + 1]),                         ) */ TODO))
                /* TODO(ExpressionStatement): context.approximateLength += 2; */
                 /* TODO(PropertyAccessExpression): factory.createTemplateLiteralType */ TODO(templateHead, templateSpans)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.StringMapping */ TODO {
                typeNode := typeToTypeNodeHelper(/* TODO(PropertyAccessExpression): (type as StringMappingType).type */ TODO, context)
                 symbolToTypeNode(/* TODO(PropertyAccessExpression): (type as StringMappingType).symbol */ TODO, context, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO, /* TODO(ArrayLiteralExpression): [typeNode] */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.IndexedAccess */ TODO {
                objectTypeNode := typeToTypeNodeHelper(/* TODO(PropertyAccessExpression): (type as IndexedAccessType).objectType */ TODO, context)
                indexTypeNode := typeToTypeNodeHelper(/* TODO(PropertyAccessExpression): (type as IndexedAccessType).indexType */ TODO, context)
                /* TODO(ExpressionStatement): context.approximateLength += 2; */
                 /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO(objectTypeNode, indexTypeNode)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Conditional */ TODO {
                 visitAndTransformType(type_, /* TODO(ArrowFunction): type => conditionalTypeToTypeNode(type as ConditionalType) */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Substitution */ TODO {
                typeNode := typeToTypeNodeHelper(/* TODO(PropertyAccessExpression): (type as SubstitutionType).baseType */ TODO, context)
                noInferSymbol := /* TODO(BinaryExpression): isNoInferType(type) && getGlobalTypeSymbol("NoInfer" as __String, /*reportErrors* / false) */ TODO
                 /* TODO(ConditionalExpression): noInferSymbol ? symbolToTypeNode(noInferSymbol, context, SymbolFlags.Type, [typeNode]) : typeNode */ TODO
            }
             /* TODO(PropertyAccessExpression): Debug.fail */ TODO("Should be unreachable.")
            conditionalTypeToTypeNode := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ConditionalTypeNode */ TODO {
                checkTypeNode := typeToTypeNodeHelper(/* TODO(PropertyAccessExpression): type.checkType */ TODO, context)
                /* TODO(ExpressionStatement): context.approximateLength += 15; */
                if /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams && type.root.isDistributive && !(type.checkType.flags & TypeFlags.TypeParameter) */ TODO {
                    newParam := createTypeParameter(createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.TypeParameter */ TODO, "T" /* as */ /* TODO(TypeReference): __String */))
                    name := typeParameterToName(newParam, context)
                    newTypeVariable := /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(name)
                    /* TODO(ExpressionStatement): context.approximateLength += 37; */
                    newMapper := prependTypeMapping(/* TODO(PropertyAccessExpression): type.root.checkType */ TODO, newParam, /* TODO(PropertyAccessExpression): type.mapper */ TODO)
                    saveInferTypeParameters := /* TODO(PropertyAccessExpression): context.inferTypeParameters */ TODO
                    /* TODO(ExpressionStatement): context.inferTypeParameters = type.root.inferTypeParameters; */
                    extendsTypeNode := typeToTypeNodeHelper(instantiateType(/* TODO(PropertyAccessExpression): type.root.extendsType */ TODO, newMapper), context)
                    /* TODO(ExpressionStatement): context.inferTypeParameters = saveInferTypeParameters; */
                    trueTypeNode := typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, /* TODO(PropertyAccessExpression): type.root.node.trueType */ TODO), newMapper))
                    falseTypeNode := typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, /* TODO(PropertyAccessExpression): type.root.node.falseType */ TODO), newMapper))
                     /* TODO(PropertyAccessExpression): factory.createConditionalTypeNode */ TODO(checkTypeNode, /* TODO(PropertyAccessExpression): factory.createInferTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createTypeParameterDeclaration */ TODO(undefined, /* TODO(PropertyAccessExpression): factory.cloneNode */ TODO(/* TODO(PropertyAccessExpression): newTypeVariable.typeName */ TODO) /* as */ /* TODO(TypeReference): Identifier */)), /* TODO(PropertyAccessExpression): factory.createConditionalTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(/* TODO(PropertyAccessExpression): factory.cloneNode */ TODO(name)), typeToTypeNodeHelper(/* TODO(PropertyAccessExpression): type.checkType */ TODO, context), /* TODO(PropertyAccessExpression): factory.createConditionalTypeNode */ TODO(newTypeVariable, extendsTypeNode, trueTypeNode, falseTypeNode), /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.NeverKeyword */ TODO)), /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.NeverKeyword */ TODO))
                }
                saveInferTypeParameters := /* TODO(PropertyAccessExpression): context.inferTypeParameters */ TODO
                /* TODO(ExpressionStatement): context.inferTypeParameters = type.root.inferTypeParameters; */
                extendsTypeNode := typeToTypeNodeHelper(/* TODO(PropertyAccessExpression): type.extendsType */ TODO, context)
                /* TODO(ExpressionStatement): context.inferTypeParameters = saveInferTypeParameters; */
                trueTypeNode := typeToTypeNodeOrCircularityElision(getTrueTypeFromConditionalType(type_))
                falseTypeNode := typeToTypeNodeOrCircularityElision(getFalseTypeFromConditionalType(type_))
                 /* TODO(PropertyAccessExpression): factory.createConditionalTypeNode */ TODO(checkTypeNode, extendsTypeNode, trueTypeNode, falseTypeNode)
            }
            typeToTypeNodeOrCircularityElision := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
                if /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
                    if /* TODO(PropertyAccessExpression): context.visitedTypes?.has */ TODO(getTypeId(type_)) {
                        if /* TODO(PrefixUnaryExpression): !(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier) */ TODO {
                            /* TODO(ExpressionStatement): context.encounteredError = true; */
                            /* TODO(ExpressionStatement): context.tracker?.reportCyclicStructureError?.(); */
                        }
                         createElidedInformationPlaceholder(context)
                    }
                     visitAndTransformType(type_, /* TODO(ArrowFunction): type => typeToTypeNodeHelper(type, context) */ TODO)
                }
                 typeToTypeNodeHelper(type_, context)
            }
            isMappedTypeHomomorphic := func(type_ MappedType) /* TODO(undefined): boolean */ TODO {
                 /* TODO(PrefixUnaryExpression): !!getHomomorphicTypeVariable(type) */ TODO
            }
            isHomomorphicMappedTypeWithNonHomomorphicInstantiation := func(type_ MappedType) /* TODO(undefined): boolean */ TODO {
                 /* TODO(BinaryExpression): !!type.target && isMappedTypeHomomorphic(type.target as MappedType) && !isMappedTypeHomomorphic(type) */ TODO
            }
            createMappedTypeNodeFromType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ConditionalTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").MappedTypeNode */ TODO {
                /* TODO(ExpressionStatement): Debug.assert(!!(type.flags & TypeFlags.Object)); */
                readonlyToken := /* TODO(ConditionalExpression): type.declaration.readonlyToken ? factory.createToken(type.declaration.readonlyToken.kind) as ReadonlyKeyword | PlusToken | MinusToken : undefined */ TODO
                questionToken := /* TODO(ConditionalExpression): type.declaration.questionToken ? factory.createToken(type.declaration.questionToken.kind) as QuestionToken | PlusToken | MinusToken : undefined */ TODO
                var appropriateConstraintTypeNode TypeNode
                var newTypeVariable *TypeReferenceNode
                needsModifierPreservingWrapper := /* TODO(BinaryExpression): !isMappedTypeWithKeyofConstraintDeclaration(type)                     && !(getModifiersTypeFromMappedType(type).flags & TypeFlags.Unknown)                     && context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams                     && !(getConstraintTypeFromMappedType(type).flags & TypeFlags.TypeParameter && getConstraintOfTypeParameter(getConstraintTypeFromMappedType(type))?.flags! & TypeFlags.Index) */ TODO
                if isMappedTypeWithKeyofConstraintDeclaration(type_) {
                    if /* TODO(BinaryExpression): isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type) && context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams */ TODO {
                        newParam := createTypeParameter(createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.TypeParameter */ TODO, "T" /* as */ /* TODO(TypeReference): __String */))
                        name := typeParameterToName(newParam, context)
                        /* TODO(ExpressionStatement): newTypeVariable = factory.createTypeReferenceNode(name); */
                    }
                    /* TODO(ExpressionStatement): appropriateConstraintTypeNode = factory.createTypeOperatorNode(SyntaxKind.KeyOfKeyword, newTypeVariable || typeToTypeNodeHelper(getModifiersTypeFromMappedType(type), context)); */
                } else if needsModifierPreservingWrapper {
                    newParam := createTypeParameter(createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.TypeParameter */ TODO, "T" /* as */ /* TODO(TypeReference): __String */))
                    name := typeParameterToName(newParam, context)
                    /* TODO(ExpressionStatement): newTypeVariable = factory.createTypeReferenceNode(name); */
                    /* TODO(ExpressionStatement): appropriateConstraintTypeNode = newTypeVariable; */
                } else {
                    /* TODO(ExpressionStatement): appropriateConstraintTypeNode = typeToTypeNodeHelper(getConstraintTypeFromMappedType(type), context); */
                }
                typeParameterNode := typeParameterToDeclarationWithConstraint(getTypeParameterFromMappedType(type_), context, appropriateConstraintTypeNode)
                nameTypeNode := /* TODO(ConditionalExpression): type.declaration.nameType ? typeToTypeNodeHelper(getNameTypeFromMappedType(type)!, context) : undefined */ TODO
                templateTypeNode := typeToTypeNodeHelper(removeMissingType(getTemplateTypeFromMappedType(type_), /* TODO(PrefixUnaryExpression): !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional) */ TODO), context)
                mappedTypeNode := /* TODO(PropertyAccessExpression): factory.createMappedTypeNode */ TODO(readonlyToken, typeParameterNode, nameTypeNode, questionToken, templateTypeNode, undefined)
                /* TODO(ExpressionStatement): context.approximateLength += 10; */
                result := setEmitFlags(mappedTypeNode, /* TODO(PropertyAccessExpression): EmitFlags.SingleLine */ TODO)
                if /* TODO(BinaryExpression): isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type) && context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams */ TODO {
                    originalConstraint := instantiateType(/* TODO(BinaryExpression): getConstraintOfTypeParameter(getTypeFromTypeNode(context, (type.declaration.typeParameter.constraint! as TypeOperatorNode).type) as TypeParameter) || unknownType */ TODO, /* TODO(PropertyAccessExpression): type.mapper */ TODO)
                     /* TODO(PropertyAccessExpression): factory.createConditionalTypeNode */ TODO(typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context), /* TODO(PropertyAccessExpression): factory.createInferTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createTypeParameterDeclaration */ TODO(undefined, /* TODO(PropertyAccessExpression): factory.cloneNode */ TODO(/* TODO(PropertyAccessExpression): newTypeVariable!.typeName */ TODO) /* as */ /* TODO(TypeReference): Identifier */, /* TODO(ConditionalExpression): originalConstraint.flags & TypeFlags.Unknown ? undefined : typeToTypeNodeHelper(originalConstraint, context) */ TODO)), result, /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.NeverKeyword */ TODO))
                } else if needsModifierPreservingWrapper {
                     /* TODO(PropertyAccessExpression): factory.createConditionalTypeNode */ TODO(typeToTypeNodeHelper(getConstraintTypeFromMappedType(type_), context), /* TODO(PropertyAccessExpression): factory.createInferTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createTypeParameterDeclaration */ TODO(undefined, /* TODO(PropertyAccessExpression): factory.cloneNode */ TODO(/* TODO(PropertyAccessExpression): newTypeVariable!.typeName */ TODO) /* as */ /* TODO(TypeReference): Identifier */, /* TODO(PropertyAccessExpression): factory.createTypeOperatorNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.KeyOfKeyword */ TODO, typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context)))), result, /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.NeverKeyword */ TODO))
                }
                 result
            }
            createAnonymousTypeNode := func(type_ ObjectType) TypeNode {
                typeId := /* TODO(PropertyAccessExpression): type.id */ TODO
                symbol := /* TODO(PropertyAccessExpression): type.symbol */ TODO
                if symbol {
                    isInstantiationExpressionType := /* TODO(PrefixUnaryExpression): !!(getObjectFlags(type) & ObjectFlags.InstantiationExpressionType) */ TODO
                    if isInstantiationExpressionType {
                        instantiationExpressionType := type_ /* as */ /* TODO(TypeReference): InstantiationExpressionType */
                        existing := /* TODO(PropertyAccessExpression): instantiationExpressionType.node */ TODO
                        if isTypeQueryNode(existing) {
                            typeNode := tryReuseExistingNonParameterTypeNode(context, existing, type_)
                            if typeNode {
                                 typeNode
                            }
                        }
                        if /* TODO(PropertyAccessExpression): context.visitedTypes?.has */ TODO(typeId) {
                             createElidedInformationPlaceholder(context)
                        }
                         visitAndTransformType(type_, createTypeNodeFromObjectType)
                    }
                    isInstanceType := /* TODO(ConditionalExpression): isClassInstanceSide(type) ? SymbolFlags.Type : SymbolFlags.Value */ TODO
                    if isJSConstructor(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO) {
                         symbolToTypeNode(symbol, context, isInstanceType)
                    } else if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Class                             && !getBaseTypeVariableOfClass(symbol)                             && !(symbol.valueDeclaration && isClassLike(symbol.valueDeclaration) && context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral && (!isClassDeclaration(symbol.valueDeclaration) || isSymbolAccessible(symbol, context.enclosingDeclaration, isInstanceType, /*shouldComputeAliasesToMakeVisible* / false).accessibility !== SymbolAccessibility.Accessible)) ||                         symbol.flags & (SymbolFlags.Enum | SymbolFlags.ValueModule) ||                         shouldWriteTypeOfFunctionSymbol() */ TODO {
                         symbolToTypeNode(symbol, context, isInstanceType)
                    } else if /* TODO(PropertyAccessExpression): context.visitedTypes?.has */ TODO(typeId) {
                        typeAlias := getTypeAliasForTypeLiteral(type_)
                        if typeAlias {
                             symbolToTypeNode(typeAlias, context, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO)
                        } else {
                             createElidedInformationPlaceholder(context)
                        }
                    } else {
                         visitAndTransformType(type_, createTypeNodeFromObjectType)
                    }
                } else {
                     createTypeNodeFromObjectType(type_)
                }
                shouldWriteTypeOfFunctionSymbol := func() /* TODO(undefined): boolean | undefined */ TODO {
                    isStaticMethodSymbol := /* TODO(BinaryExpression): !!(symbol.flags & SymbolFlags.Method) && // typeof static method                         some(symbol.declarations, declaration => isStatic(declaration)) */ TODO
                    isNonLocalFunctionSymbol := /* TODO(BinaryExpression): !!(symbol.flags & SymbolFlags.Function) &&                         (symbol.parent || // is exported function symbol                             forEach(symbol.declarations, declaration => declaration.parent.kind === SyntaxKind.SourceFile || declaration.parent.kind === SyntaxKind.ModuleBlock)) */ TODO
                    if /* TODO(BinaryExpression): isStaticMethodSymbol || isNonLocalFunctionSymbol */ TODO {
                         /* TODO(BinaryExpression): (!!(context.flags & NodeBuilderFlags.UseTypeOfFunction) || (context.visitedTypes?.has(typeId))) && // it is type of the symbol uses itself recursively                             (!(context.flags & NodeBuilderFlags.UseStructuralFallback) || isValueSymbolAccessible(symbol, context.enclosingDeclaration)) */ TODO
                    }
                }
            }
            visitAndTransformType := func(type_ T, transform func(type_ T) TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
                typeId := /* TODO(PropertyAccessExpression): type.id */ TODO
                isConstructorObject := /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.Anonymous && type.symbol && type.symbol.flags & SymbolFlags.Class */ TODO
                id := /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference & T).node ? "N" + getNodeId((type as TypeReference & T).node!) :                     type.flags & TypeFlags.Conditional ? "N" + getNodeId((type as ConditionalType & T).root.node) :                     type.symbol ? (isConstructorObject ? "+" : "") + getSymbolId(type.symbol) :                     undefined */ TODO
                if /* TODO(PrefixUnaryExpression): !context.visitedTypes */ TODO {
                    /* TODO(ExpressionStatement): context.visitedTypes = new Set(); */
                }
                if /* TODO(BinaryExpression): id && !context.symbolDepth */ TODO {
                    /* TODO(ExpressionStatement): context.symbolDepth = new Map(); */
                }
                links := /* TODO(BinaryExpression): context.enclosingDeclaration && getNodeLinks(context.enclosingDeclaration) */ TODO
                key := /* TODO(TemplateExpression): `${getTypeId(type)}|${context.flags}|${context.internalFlags}` */ TODO
                if links {
                    /* TODO(ExpressionStatement): links.serializedTypes ||= new Map(); */
                }
                cachedResult := /* TODO(PropertyAccessExpression): links?.serializedTypes?.get */ TODO(key)
                if cachedResult {
                    /* TODO(ExpressionStatement): cachedResult.trackedSymbols?.forEach(                         ([symbol, enclosingDeclaration, meaning]) =>                             context.tracker.trackSymbol(                                 symbol,                                 enclosingDeclaration,                                 meaning,                             ),                     ); */
                    if /* TODO(PropertyAccessExpression): cachedResult.truncating */ TODO {
                        /* TODO(ExpressionStatement): context.truncating = true; */
                    }
                    /* TODO(ExpressionStatement): context.approximateLength += cachedResult.addedLength; */
                     deepCloneOrReuseNode(/* TODO(PropertyAccessExpression): cachedResult.node */ TODO)
                }
                var depth /* TODO(NumberKeyword): number */ any
                if id {
                    /* TODO(ExpressionStatement): depth = context.symbolDepth!.get(id) || 0; */
                    if /* TODO(BinaryExpression): depth > 10 */ TODO {
                         createElidedInformationPlaceholder(context)
                    }
                    /* TODO(ExpressionStatement): context.symbolDepth!.set(id, depth + 1); */
                }
                /* TODO(ExpressionStatement): context.visitedTypes.add(typeId); */
                prevTrackedSymbols := /* TODO(PropertyAccessExpression): context.trackedSymbols */ TODO
                /* TODO(ExpressionStatement): context.trackedSymbols = undefined; */
                startLength := /* TODO(PropertyAccessExpression): context.approximateLength */ TODO
                result := transform(type_)
                addedLength := /* TODO(BinaryExpression): context.approximateLength - startLength */ TODO
                if /* TODO(BinaryExpression): !context.reportedDiagnostic && !context.encounteredError */ TODO {
                    /* TODO(ExpressionStatement): links?.serializedTypes?.set(key, {                         node: result,                         truncating: context.truncating,                         addedLength,                         trackedSymbols: context.trackedSymbols,                     }); */
                }
                /* TODO(ExpressionStatement): context.visitedTypes.delete(typeId); */
                if id {
                    /* TODO(ExpressionStatement): context.symbolDepth!.set(id, depth!); */
                }
                /* TODO(ExpressionStatement): context.trackedSymbols = prevTrackedSymbols; */
                 result
                deepCloneOrReuseNode := func(node T) T {
                    if /* TODO(BinaryExpression): !nodeIsSynthesized(node) && getParseTreeNode(node) === node */ TODO {
                         node
                    }
                     setTextRange(context, /* TODO(PropertyAccessExpression): factory.cloneNode */ TODO(visitEachChildWorker(node, deepCloneOrReuseNode, undefined, deepCloneOrReuseNodes, deepCloneOrReuseNode)), node)
                }
                deepCloneOrReuseNodes := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
                    if /* TODO(BinaryExpression): nodes && nodes.length === 0 */ TODO {
                         setTextRangeWorker(/* TODO(PropertyAccessExpression): factory.createNodeArray */ TODO(undefined, /* TODO(PropertyAccessExpression): nodes.hasTrailingComma */ TODO), nodes)
                    }
                     visitNodes(nodes, visitor, test, start, count)
                }
            }
            createTypeNodeFromObjectType := func(type_ ObjectType) TypeNode {
                if /* TODO(BinaryExpression): isGenericMappedType(type) || (type as MappedType).containsError */ TODO {
                     createMappedTypeNodeFromType(type_ /* as */ /* TODO(TypeReference): MappedType */)
                }
                resolved := resolveStructuredTypeMembers(type_)
                if /* TODO(BinaryExpression): !resolved.properties.length && !resolved.indexInfos.length */ TODO {
                    if /* TODO(BinaryExpression): !resolved.callSignatures.length && !resolved.constructSignatures.length */ TODO {
                        /* TODO(ExpressionStatement): context.approximateLength += 2; */
                         setEmitFlags(/* TODO(PropertyAccessExpression): factory.createTypeLiteralNode */ TODO(undefined), /* TODO(PropertyAccessExpression): EmitFlags.SingleLine */ TODO)
                    }
                    if /* TODO(BinaryExpression): resolved.callSignatures.length === 1 && !resolved.constructSignatures.length */ TODO {
                        signature := /* TODO(ElementAccessExpression): resolved.callSignatures[0] */ TODO
                        signatureNode := signatureToSignatureDeclarationHelper(signature, /* TODO(PropertyAccessExpression): SyntaxKind.FunctionType */ TODO, context) /* as */ /* TODO(TypeReference): FunctionTypeNode */
                         signatureNode
                    }
                    if /* TODO(BinaryExpression): resolved.constructSignatures.length === 1 && !resolved.callSignatures.length */ TODO {
                        signature := /* TODO(ElementAccessExpression): resolved.constructSignatures[0] */ TODO
                        signatureNode := signatureToSignatureDeclarationHelper(signature, /* TODO(PropertyAccessExpression): SyntaxKind.ConstructorType */ TODO, context) /* as */ /* TODO(TypeReference): ConstructorTypeNode */
                         signatureNode
                    }
                }
                abstractSignatures := filter(/* TODO(PropertyAccessExpression): resolved.constructSignatures */ TODO, /* TODO(ArrowFunction): signature => !!(signature.flags & SignatureFlags.Abstract) */ TODO)
                if some(abstractSignatures) {
                    types := map_(abstractSignatures, /* TODO(ArrowFunction): s => getOrCreateTypeFromSignature(s) */ TODO)
                    typeElementCount := /* TODO(BinaryExpression): resolved.callSignatures.length +                         (resolved.constructSignatures.length - abstractSignatures.length) +                         resolved.indexInfos.length +                         // exclude `prototype` when writing a class expression as a type literal, as per                         // the logic in `createTypeNodesFromResolvedType`.                         (context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral ?                             countWhere(resolved.properties, p => !(p.flags & SymbolFlags.Prototype)) :                             length(resolved.properties)) */ TODO
                    if typeElementCount {
                        /* TODO(ExpressionStatement): types.push(getResolvedTypeWithoutAbstractConstructSignatures(resolved)); */
                    }
                     typeToTypeNodeHelper(getIntersectionType(types), context)
                }
                restoreFlags := saveRestoreFlags(context)
                /* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.InObjectTypeLiteral; */
                members := createTypeNodesFromResolvedType(resolved)
                /* TODO(ExpressionStatement): restoreFlags(); */
                typeLiteralNode := /* TODO(PropertyAccessExpression): factory.createTypeLiteralNode */ TODO(members)
                /* TODO(ExpressionStatement): context.approximateLength += 2; */
                /* TODO(ExpressionStatement): setEmitFlags(typeLiteralNode, (context.flags & NodeBuilderFlags.MultilineObjectLiterals) ? 0 : EmitFlags.SingleLine); */
                 typeLiteralNode
            }
            typeReferenceToTypeNode := func(type_ TypeReference) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
                var typeArguments []Type = getTypeArguments(type_)
                if /* TODO(BinaryExpression): type.target === globalArrayType || type.target === globalReadonlyArrayType */ TODO {
                    if /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.WriteArrayAsGenericType */ TODO {
                        typeArgumentNode := typeToTypeNodeHelper(/* TODO(ElementAccessExpression): typeArguments[0] */ TODO, context)
                         /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(/* TODO(ConditionalExpression): type.target === globalArrayType ? "Array" : "ReadonlyArray" */ TODO, /* TODO(ArrayLiteralExpression): [typeArgumentNode] */ TODO)
                    }
                    elementType := typeToTypeNodeHelper(/* TODO(ElementAccessExpression): typeArguments[0] */ TODO, context)
                    arrayType := /* TODO(PropertyAccessExpression): factory.createArrayTypeNode */ TODO(elementType)
                     /* TODO(ConditionalExpression): type.target === globalArrayType ? arrayType : factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, arrayType) */ TODO
                } else if /* TODO(BinaryExpression): type.target.objectFlags & ObjectFlags.Tuple */ TODO {
                    /* TODO(ExpressionStatement): typeArguments = sameMap(typeArguments, (t, i) => removeMissingType(t, !!((type.target as TupleType).elementFlags[i] & ElementFlags.Optional))); */
                    if /* TODO(BinaryExpression): typeArguments.length > 0 */ TODO {
                        arity := getTypeReferenceArity(type_)
                        tupleConstituentNodes := mapToTypeNodes(/* TODO(PropertyAccessExpression): typeArguments.slice */ TODO(0, arity), context)
                        if tupleConstituentNodes {
                            TODO_IDENTIFIER := /* TODO(PropertyAccessExpression): type.target */ TODO /* as */ /* TODO(TypeReference): TupleType */
                            /* TODO(ForStatement): for (let i = 0; i < tupleConstituentNodes.length; i++) {                                 const flags = (type.target as TupleType).elementFlags[i];                                 const labeledElementDeclaration = labeledElementDeclarations?.[i];                                  if (labeledElementDeclaration) {                                     tupleConstituentNodes[i] = factory.createNamedTupleMember(                                         flags & ElementFlags.Variable ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined,                                         factory.createIdentifier(unescapeLeadingUnderscores(getTupleElementLabel(labeledElementDeclaration))),                                         flags & ElementFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                         flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) :                                             tupleConstituentNodes[i],                                     );                                 }                                 else {                                     tupleConstituentNodes[i] = flags & ElementFlags.Variable ? factory.createRestTypeNode(flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i]) :                                         flags & ElementFlags.Optional ? factory.createOptionalTypeNode(tupleConstituentNodes[i]) :                                         tupleConstituentNodes[i];                                 }                             } */
                            tupleTypeNode := setEmitFlags(/* TODO(PropertyAccessExpression): factory.createTupleTypeNode */ TODO(tupleConstituentNodes), /* TODO(PropertyAccessExpression): EmitFlags.SingleLine */ TODO)
                             /* TODO(ConditionalExpression): (type.target as TupleType).readonly ? factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, tupleTypeNode) : tupleTypeNode */ TODO
                        }
                    }
                    if /* TODO(BinaryExpression): context.encounteredError || (context.flags & NodeBuilderFlags.AllowEmptyTuple) */ TODO {
                        tupleTypeNode := setEmitFlags(/* TODO(PropertyAccessExpression): factory.createTupleTypeNode */ TODO(/* TODO(ArrayLiteralExpression): [] */ TODO), /* TODO(PropertyAccessExpression): EmitFlags.SingleLine */ TODO)
                         /* TODO(ConditionalExpression): (type.target as TupleType).readonly ? factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, tupleTypeNode) : tupleTypeNode */ TODO
                    }
                    /* TODO(ExpressionStatement): context.encounteredError = true; */
                     /* TODO(NonNullExpression): undefined! */ TODO
                } else if /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral &&                     type.symbol.valueDeclaration &&                     isClassLike(type.symbol.valueDeclaration) &&                     !isValueSymbolAccessible(type.symbol, context.enclosingDeclaration) */ TODO {
                     createAnonymousTypeNode(type_)
                } else {
                    outerTypeParameters := /* TODO(PropertyAccessExpression): type.target.outerTypeParameters */ TODO
                    i := 0
                    var resultType /* TODO(UnionType): TypeReferenceNode | ImportTypeNode | undefined */ any
                    if outerTypeParameters {
                        length := /* TODO(PropertyAccessExpression): outerTypeParameters.length */ TODO
                        /* TODO(WhileStatement): while (i < length) {                             // Find group of type arguments for type parameters with the same declaring container.                             const start = i;                             const parent = getParentSymbolOfTypeParameter(outerTypeParameters[i])!;                             do {                                 i++;                             }                             while (i < length && getParentSymbolOfTypeParameter(outerTypeParameters[i]) === parent);                             // When type parameters are their own type arguments for the whole group (i.e. we have                             // the default outer type arguments), we don't show the group.                             if (!rangeEquals(outerTypeParameters, typeArguments, start, i)) {                                 const typeArgumentSlice = mapToTypeNodes(typeArguments.slice(start, i), context);                                 const restoreFlags = saveRestoreFlags(context);                                 context.flags |= NodeBuilderFlags.ForbidIndexedAccessSymbolReferences;                                 const ref = symbolToTypeNode(parent, context, SymbolFlags.Type, typeArgumentSlice) as TypeReferenceNode | ImportTypeNode;                                 restoreFlags();                                 resultType = !resultType ? ref : appendReferenceToType(resultType, ref as TypeReferenceNode);                             }                         } */
                    }
                    var typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any
                    if /* TODO(BinaryExpression): typeArguments.length > 0 */ TODO {
                        typeParameterCount := 0
                        if /* TODO(PropertyAccessExpression): type.target.typeParameters */ TODO {
                            /* TODO(ExpressionStatement): typeParameterCount = Math.min(type.target.typeParameters.length, typeArguments.length); */
                            if /* TODO(BinaryExpression): isReferenceToType(type, getGlobalIterableType(/*reportErrors* / false)) ||                                 isReferenceToType(type, getGlobalIterableIteratorType(/*reportErrors* / false)) ||                                 isReferenceToType(type, getGlobalAsyncIterableType(/*reportErrors* / false)) ||                                 isReferenceToType(type, getGlobalAsyncIterableIteratorType(/*reportErrors* / false)) */ TODO {
                                if /* TODO(BinaryExpression): !type.node || !isTypeReferenceNode(type.node) || !type.node.typeArguments ||                                     type.node.typeArguments.length < typeParameterCount */ TODO {
                                    /* TODO(WhileStatement): while (typeParameterCount > 0) {                                         const typeArgument = typeArguments[typeParameterCount - 1];                                         const typeParameter = type.target.typeParameters[typeParameterCount - 1];                                         const defaultType = getDefaultFromTypeParameter(typeParameter);                                         if (!defaultType || !isTypeIdenticalTo(typeArgument, defaultType)) {                                             break;                                         }                                         typeParameterCount--;                                     } */
                                }
                            }
                        }
                        /* TODO(ExpressionStatement): typeArgumentNodes = mapToTypeNodes(typeArguments.slice(i, typeParameterCount), context); */
                    }
                    restoreFlags := saveRestoreFlags(context)
                    /* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.ForbidIndexedAccessSymbolReferences; */
                    finalRef := symbolToTypeNode(/* TODO(PropertyAccessExpression): type.symbol */ TODO, context, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO, typeArgumentNodes)
                    /* TODO(ExpressionStatement): restoreFlags(); */
                     /* TODO(ConditionalExpression): !resultType ? finalRef : appendReferenceToType(resultType, finalRef as TypeReferenceNode) */ TODO
                }
            }
            appendReferenceToType := func(root /* TODO(UnionType): TypeReferenceNode | ImportTypeNode */ any, ref TypeReferenceNode) /* TODO(UnionType): TypeReferenceNode | ImportTypeNode */ any {
                if isImportTypeNode(root) {
                    typeArguments := /* TODO(PropertyAccessExpression): root.typeArguments */ TODO
                    qualifier := /* TODO(PropertyAccessExpression): root.qualifier */ TODO
                    if qualifier {
                        if isIdentifier(qualifier) {
                            if /* TODO(BinaryExpression): typeArguments !== getIdentifierTypeArguments(qualifier) */ TODO {
                                /* TODO(ExpressionStatement): qualifier = setIdentifierTypeArguments(factory.cloneNode(qualifier), typeArguments); */
                            }
                        } else {
                            if /* TODO(BinaryExpression): typeArguments !== getIdentifierTypeArguments(qualifier.right) */ TODO {
                                /* TODO(ExpressionStatement): qualifier = factory.updateQualifiedName(qualifier, qualifier.left, setIdentifierTypeArguments(factory.cloneNode(qualifier.right), typeArguments)); */
                            }
                        }
                    }
                    /* TODO(ExpressionStatement): typeArguments = ref.typeArguments; */
                    ids := getAccessStack(ref)
                    /* TODO(ForOfStatement): for (const id of ids) {                         qualifier = qualifier ? factory.createQualifiedName(qualifier, id) : id;                     } */
                     /* TODO(PropertyAccessExpression): factory.updateImportTypeNode */ TODO(root, /* TODO(PropertyAccessExpression): root.argument */ TODO, /* TODO(PropertyAccessExpression): root.attributes */ TODO, qualifier, typeArguments, /* TODO(PropertyAccessExpression): root.isTypeOf */ TODO)
                } else {
                    typeArguments := /* TODO(PropertyAccessExpression): root.typeArguments */ TODO
                    typeName := /* TODO(PropertyAccessExpression): root.typeName */ TODO
                    if isIdentifier(typeName) {
                        if /* TODO(BinaryExpression): typeArguments !== getIdentifierTypeArguments(typeName) */ TODO {
                            /* TODO(ExpressionStatement): typeName = setIdentifierTypeArguments(factory.cloneNode(typeName), typeArguments); */
                        }
                    } else {
                        if /* TODO(BinaryExpression): typeArguments !== getIdentifierTypeArguments(typeName.right) */ TODO {
                            /* TODO(ExpressionStatement): typeName = factory.updateQualifiedName(typeName, typeName.left, setIdentifierTypeArguments(factory.cloneNode(typeName.right), typeArguments)); */
                        }
                    }
                    /* TODO(ExpressionStatement): typeArguments = ref.typeArguments; */
                    ids := getAccessStack(ref)
                    /* TODO(ForOfStatement): for (const id of ids) {                         typeName = factory.createQualifiedName(typeName, id);                     } */
                     /* TODO(PropertyAccessExpression): factory.updateTypeReferenceNode */ TODO(root, typeName, typeArguments)
                }
            }
            getAccessStack := func(ref TypeReferenceNode) []Identifier {
                state := /* TODO(PropertyAccessExpression): ref.typeName */ TODO
                ids := /* TODO(ArrayLiteralExpression): [] */ TODO
                /* TODO(WhileStatement): while (!isIdentifier(state)) {                     ids.unshift(state.right);                     state = state.left;                 } */
                /* TODO(ExpressionStatement): ids.unshift(state); */
                 ids
            }
            createTypeNodesFromResolvedType := func(resolvedType ResolvedType) /* TODO(ArrayType): TypeElement[] */ any {
                if checkTruncationLength(context) {
                     /* TODO(ArrayLiteralExpression): [factory.createPropertySignature(/*modifiers* / undefined, "...", /*questionToken* / undefined, /*type* / undefined)] */ TODO
                }
                var typeElements []TypeElement = /* TODO(ArrayLiteralExpression): [] */ TODO
                /* TODO(ForOfStatement): for (const signature of resolvedType.callSignatures) {                     typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKind.CallSignature, context) as CallSignatureDeclaration);                 } */
                /* TODO(ForOfStatement): for (const signature of resolvedType.constructSignatures) {                     if (signature.flags & SignatureFlags.Abstract) continue;                     typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKind.ConstructSignature, context) as ConstructSignatureDeclaration);                 } */
                /* TODO(ForOfStatement): for (const info of resolvedType.indexInfos) {                     typeElements.push(indexInfoToIndexSignatureDeclarationHelper(info, context, resolvedType.objectFlags & ObjectFlags.ReverseMapped ? createElidedInformationPlaceholder(context) : undefined));                 } */
                properties := /* TODO(PropertyAccessExpression): resolvedType.properties */ TODO
                if /* TODO(PrefixUnaryExpression): !properties */ TODO {
                     typeElements
                }
                i := 0
                /* TODO(ForOfStatement): for (const propertySymbol of properties) {                     i++;                     if (context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral) {                         if (propertySymbol.flags & SymbolFlags.Prototype) {                             continue;                         }                         if (getDeclarationModifierFlagsFromSymbol(propertySymbol) & (ModifierFlags.Private | ModifierFlags.Protected) && context.tracker.reportPrivateInBaseOfClassExpression) {                             context.tracker.reportPrivateInBaseOfClassExpression(unescapeLeadingUnderscores(propertySymbol.escapedName));                         }                     }                     if (checkTruncationLength(context) && (i + 2 < properties.length - 1)) {                         typeElements.push(factory.createPropertySignature(/*modifiers* / undefined, `... ${properties.length - i} more ...`, /*questionToken* / undefined, /*type* / undefined));                         addPropertyToElementList(properties[properties.length - 1], context, typeElements);                         break;                     }                     addPropertyToElementList(propertySymbol, context, typeElements);                 } */
                 /* TODO(ConditionalExpression): typeElements.length ? typeElements : undefined */ TODO
            }
        }
        createElidedInformationPlaceholder := func(context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").KeywordTypeNode<import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.AnyKeyword> | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeReferenceNode */ TODO {
            /* TODO(ExpressionStatement): context.approximateLength += 3; */
            if /* TODO(PrefixUnaryExpression): !(context.flags & NodeBuilderFlags.NoTruncation) */ TODO {
                 /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(/* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO("..."), undefined)
            }
             /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO)
        }
        shouldUsePlaceholderForProperty := func(propertySymbol Symbol, context NodeBuilderContext) /* TODO(undefined): boolean */ TODO {
            depth := 3
             /* TODO(BinaryExpression): !!(getCheckFlags(propertySymbol) & CheckFlags.ReverseMapped)                 && (                     contains(context.reverseMappedStack, propertySymbol as ReverseMappedSymbol)                     || (                         context.reverseMappedStack?.[0]                         && !(getObjectFlags(last(context.reverseMappedStack).links.propertyType) & ObjectFlags.Anonymous)                     )                     || isDeeplyNestedReverseMappedTypeProperty()                 ) */ TODO
            isDeeplyNestedReverseMappedTypeProperty := func() /* TODO(undefined): boolean */ TODO {
                if /* TODO(BinaryExpression): (context.reverseMappedStack?.length ?? 0) < depth */ TODO {
                     /* TODO(FalseKeyword): false */ TODO
                }
                /* TODO(ForStatement): for (let i = 0; i < depth; i++) {                     const prop = context.reverseMappedStack![context.reverseMappedStack!.length - 1 - i];                     if (prop.links.mappedType.symbol !== (propertySymbol as ReverseMappedSymbol).links.mappedType.symbol) {                         return false;                     }                 } */
                 /* TODO(TrueKeyword): true */ TODO
            }
        }
        addPropertyToElementList := func(propertySymbol Symbol, context NodeBuilderContext, typeElements []TypeElement) {
            propertyIsReverseMapped := /* TODO(PrefixUnaryExpression): !!(getCheckFlags(propertySymbol) & CheckFlags.ReverseMapped) */ TODO
            propertyType := /* TODO(ConditionalExpression): shouldUsePlaceholderForProperty(propertySymbol, context) ?                 anyType : getNonMissingTypeOfSymbol(propertySymbol) */ TODO
            saveEnclosingDeclaration := /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO
            /* TODO(ExpressionStatement): context.enclosingDeclaration = undefined; */
            if /* TODO(BinaryExpression): context.tracker.canTrackSymbol && isLateBoundName(propertySymbol.escapedName) */ TODO {
                if /* TODO(PropertyAccessExpression): propertySymbol.declarations */ TODO {
                    decl := first(/* TODO(PropertyAccessExpression): propertySymbol.declarations */ TODO)
                    if hasLateBindableName(decl) {
                        if isBinaryExpression(decl) {
                            name := getNameOfDeclaration(decl)
                            if /* TODO(BinaryExpression): name && isElementAccessExpression(name) && isPropertyAccessEntityNameExpression(name.argumentExpression) */ TODO {
                                /* TODO(ExpressionStatement): trackComputedName(name.argumentExpression, saveEnclosingDeclaration, context); */
                            }
                        } else {
                            /* TODO(ExpressionStatement): trackComputedName(decl.name.expression, saveEnclosingDeclaration, context); */
                        }
                    }
                } else {
                    /* TODO(ExpressionStatement): context.tracker.reportNonSerializableProperty(symbolToString(propertySymbol)); */
                }
            }
            /* TODO(ExpressionStatement): context.enclosingDeclaration = propertySymbol.valueDeclaration || propertySymbol.declarations?.[0] || saveEnclosingDeclaration; */
            propertyName := getPropertyNameNodeForSymbol(propertySymbol, context)
            /* TODO(ExpressionStatement): context.enclosingDeclaration = saveEnclosingDeclaration; */
            /* TODO(ExpressionStatement): context.approximateLength += symbolName(propertySymbol).length + 1; */
            if /* TODO(BinaryExpression): propertySymbol.flags & SymbolFlags.Accessor */ TODO {
                writeType := getWriteTypeOfSymbol(propertySymbol)
                if /* TODO(BinaryExpression): propertyType !== writeType && !isErrorType(propertyType) && !isErrorType(writeType) */ TODO {
                    getterDeclaration := /* TODO(NonNullExpression): getDeclarationOfKind<GetAccessorDeclaration>(propertySymbol, SyntaxKind.GetAccessor)! */ TODO
                    getterSignature := getSignatureFromDeclaration(getterDeclaration)
                    /* TODO(ExpressionStatement): typeElements.push(                         setCommentRange(                             context,                             signatureToSignatureDeclarationHelper(getterSignature, SyntaxKind.GetAccessor, context, { name: propertyName }) as GetAccessorDeclaration,                             getterDeclaration,                         ),                     ); */
                    setterDeclaration := /* TODO(NonNullExpression): getDeclarationOfKind<SetAccessorDeclaration>(propertySymbol, SyntaxKind.SetAccessor)! */ TODO
                    setterSignature := getSignatureFromDeclaration(setterDeclaration)
                    /* TODO(ExpressionStatement): typeElements.push(                         setCommentRange(                             context,                             signatureToSignatureDeclarationHelper(setterSignature, SyntaxKind.SetAccessor, context, { name: propertyName }) as SetAccessorDeclaration,                             setterDeclaration,                         ),                     ); */

                }
            }
            optionalToken := /* TODO(ConditionalExpression): propertySymbol.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined */ TODO
            if /* TODO(BinaryExpression): propertySymbol.flags & (SymbolFlags.Function | SymbolFlags.Method) && !getPropertiesOfObjectType(propertyType).length && !isReadonlySymbol(propertySymbol) */ TODO {
                signatures := getSignaturesOfType(filterType(propertyType, /* TODO(ArrowFunction): t => !(t.flags & TypeFlags.Undefined) */ TODO), /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
                /* TODO(ForOfStatement): for (const signature of signatures) {                     const methodDeclaration = signatureToSignatureDeclarationHelper(signature, SyntaxKind.MethodSignature, context, { name: propertyName, questionToken: optionalToken }) as MethodSignature;                     typeElements.push(preserveCommentsOn(methodDeclaration));                 } */
                if /* TODO(BinaryExpression): signatures.length || !optionalToken */ TODO {

                }
            }
            var propertyTypeNode TypeNode
            if shouldUsePlaceholderForProperty(propertySymbol, context) {
                /* TODO(ExpressionStatement): propertyTypeNode = createElidedInformationPlaceholder(context); */
            } else {
                if propertyIsReverseMapped {
                    /* TODO(ExpressionStatement): context.reverseMappedStack ||= []; */
                    /* TODO(ExpressionStatement): context.reverseMappedStack.push(propertySymbol as ReverseMappedSymbol); */
                }
                /* TODO(ExpressionStatement): propertyTypeNode = propertyType ? serializeTypeForDeclaration(context, /*declaration* / undefined, propertyType, propertySymbol) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword); */
                if propertyIsReverseMapped {
                    /* TODO(ExpressionStatement): context.reverseMappedStack!.pop(); */
                }
            }
            modifiers := /* TODO(ConditionalExpression): isReadonlySymbol(propertySymbol) ? [factory.createToken(SyntaxKind.ReadonlyKeyword)] : undefined */ TODO
            if modifiers {
                /* TODO(ExpressionStatement): context.approximateLength += 9; */
            }
            propertySignature := /* TODO(PropertyAccessExpression): factory.createPropertySignature */ TODO(modifiers, propertyName, optionalToken, propertyTypeNode)
            /* TODO(ExpressionStatement): typeElements.push(preserveCommentsOn(propertySignature)); */
            preserveCommentsOn := func(node T) /* TODO(undefined): T */ TODO {
                jsdocPropertyTag := /* TODO(PropertyAccessExpression): propertySymbol.declarations?.find */ TODO(/* TODO(ArrowFunction): (d): d is JSDocPropertyTag => d.kind === SyntaxKind.JSDocPropertyTag */ TODO)
                if jsdocPropertyTag {
                    commentText := getTextOfJSDocComment(/* TODO(PropertyAccessExpression): jsdocPropertyTag.comment */ TODO)
                    if commentText {
                        /* TODO(ExpressionStatement): setSyntheticLeadingComments(node, [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }]); */
                    }
                } else if /* TODO(PropertyAccessExpression): propertySymbol.valueDeclaration */ TODO {
                    /* TODO(ExpressionStatement): setCommentRange(context, node, propertySymbol.valueDeclaration); */
                }
                 node
            }
        }
        setCommentRange := func(context NodeBuilderContext, node T, range_ Node) T {
            if /* TODO(BinaryExpression): context.enclosingFile && context.enclosingFile === getSourceFileOfNode(range) */ TODO {
                 setCommentRangeWorker(node, range_)
            }
             node
        }
        mapToTypeNodes := func(types /* TODO(TypeOperator): readonly Type[] */ any, context NodeBuilderContext, isBareList bool) /* TODO(ArrayType): TypeNode[] */ any {
            if some(types) {
                if checkTruncationLength(context) {
                    if /* TODO(PrefixUnaryExpression): !isBareList */ TODO {
                         /* TODO(ArrayLiteralExpression): [factory.createTypeReferenceNode("...", /*typeArguments* / undefined)] */ TODO
                    } else if /* TODO(BinaryExpression): types.length > 2 */ TODO {
                         /* TODO(ArrayLiteralExpression): [                             typeToTypeNodeHelper(types[0], context),                             factory.createTypeReferenceNode(`... ${types.length - 2} more ...`, /*typeArguments* / undefined),                             typeToTypeNodeHelper(types[types.length - 1], context),                         ] */ TODO
                    }
                }
                mayHaveNameCollisions := /* TODO(PrefixUnaryExpression): !(context.flags & NodeBuilderFlags.UseFullyQualifiedType) */ TODO
                seenNames := /* TODO(ConditionalExpression): mayHaveNameCollisions ? createMultiMap<__String, [Type, number]>() : undefined */ TODO
                var result []TypeNode = /* TODO(ArrayLiteralExpression): [] */ TODO
                i := 0
                /* TODO(ForOfStatement): for (const type of types) {                     i++;                     if (checkTruncationLength(context) && (i + 2 < types.length - 1)) {                         result.push(factory.createTypeReferenceNode(`... ${types.length - i} more ...`, /*typeArguments* / undefined));                         const typeNode = typeToTypeNodeHelper(types[types.length - 1], context);                         if (typeNode) {                             result.push(typeNode);                         }                         break;                     }                     context.approximateLength += 2; // Account for whitespace + separator                     const typeNode = typeToTypeNodeHelper(type, context);                     if (typeNode) {                         result.push(typeNode);                         if (seenNames && isIdentifierTypeReference(typeNode)) {                             seenNames.add(typeNode.typeName.escapedText, [type, result.length - 1]);                         }                     }                 } */
                if seenNames {
                    restoreFlags := saveRestoreFlags(context)
                    /* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.UseFullyQualifiedType; */
                    /* TODO(ExpressionStatement): seenNames.forEach(types => {                         if (!arrayIsHomogeneous(types, ([a], [b]) => typesAreSameReference(a, b))) {                             for (const [type, resultIndex] of types) {                                 result[resultIndex] = typeToTypeNodeHelper(type, context);                             }                         }                     }); */
                    /* TODO(ExpressionStatement): restoreFlags(); */
                }
                 result
            }
        }
        typesAreSameReference := func(a Type, b Type) bool {
             /* TODO(BinaryExpression): a === b                 || !!a.symbol && a.symbol === b.symbol                 || !!a.aliasSymbol && a.aliasSymbol === b.aliasSymbol */ TODO
        }
        indexInfoToIndexSignatureDeclarationHelper := func(indexInfo IndexInfo, context NodeBuilderContext, typeNode *TypeNode) IndexSignatureDeclaration {
            name := /* TODO(BinaryExpression): getNameFromIndexInfo(indexInfo) || "x" */ TODO
            indexerTypeNode := typeToTypeNodeHelper(/* TODO(PropertyAccessExpression): indexInfo.keyType */ TODO, context)
            indexingParameter := /* TODO(PropertyAccessExpression): factory.createParameterDeclaration */ TODO(undefined, undefined, name, undefined, indexerTypeNode, undefined)
            if /* TODO(PrefixUnaryExpression): !typeNode */ TODO {
                /* TODO(ExpressionStatement): typeNode = typeToTypeNodeHelper(indexInfo.type || anyType, context); */
            }
            if /* TODO(BinaryExpression): !indexInfo.type && !(context.flags & NodeBuilderFlags.AllowEmptyIndexInfoType) */ TODO {
                /* TODO(ExpressionStatement): context.encounteredError = true; */
            }
            /* TODO(ExpressionStatement): context.approximateLength += name.length + 4; */
             /* TODO(PropertyAccessExpression): factory.createIndexSignature */ TODO(/* TODO(ConditionalExpression): indexInfo.isReadonly ? [factory.createToken(SyntaxKind.ReadonlyKeyword)] : undefined */ TODO, /* TODO(ArrayLiteralExpression): [indexingParameter] */ TODO, typeNode)
        }
        type SignatureToSignatureDeclarationOptions struct {
            modifiers []Modifier
            name PropertyName
            questionToken QuestionToken
        }
        signatureToSignatureDeclarationHelper := func(signature Signature, kind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO, context NodeBuilderContext, options SignatureToSignatureDeclarationOptions) SignatureDeclaration {
            var typeParameters /* TODO(ArrayType): TypeParameterDeclaration[] */ any
            var typeArguments /* TODO(ArrayType): TypeNode[] */ any
            expandedParams := /* TODO(ElementAccessExpression): getExpandedParameters(signature, /*skipUnionExpanding* / true)[0] */ TODO
            cleanup := enterNewScope(context, /* TODO(PropertyAccessExpression): signature.declaration */ TODO, expandedParams, /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO, /* TODO(PropertyAccessExpression): signature.parameters */ TODO, /* TODO(PropertyAccessExpression): signature.mapper */ TODO)
            /* TODO(ExpressionStatement): context.approximateLength += 3; */
            if /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.WriteTypeArgumentsOfSignature && signature.target && signature.mapper && signature.target.typeParameters */ TODO {
                /* TODO(ExpressionStatement): typeArguments = signature.target.typeParameters.map(parameter => typeToTypeNodeHelper(instantiateType(parameter, signature.mapper), context)); */
            } else {
                /* TODO(ExpressionStatement): typeParameters = signature.typeParameters && signature.typeParameters.map(parameter => typeParameterToDeclaration(parameter, context)); */
            }
            restoreFlags := saveRestoreFlags(context)
            /* TODO(ExpressionStatement): context.flags &= ~NodeBuilderFlags.SuppressAnyReturnType; */
            parameters := /* TODO(PropertyAccessExpression): (some(expandedParams, p => p !== expandedParams[expandedParams.length - 1] && !!(getCheckFlags(p) & CheckFlags.RestParameter)) ? signature.parameters : expandedParams).map */ TODO(/* TODO(ArrowFunction): parameter => symbolToParameterDeclaration(parameter, context, kind === SyntaxKind.Constructor) */ TODO)
            thisParameter := /* TODO(ConditionalExpression): context.flags & NodeBuilderFlags.OmitThisParameter ? undefined : tryGetThisParameterDeclaration(signature, context) */ TODO
            if thisParameter {
                /* TODO(ExpressionStatement): parameters.unshift(thisParameter); */
            }
            /* TODO(ExpressionStatement): restoreFlags(); */
            returnTypeNode := serializeReturnTypeForSignature(context, signature)
            modifiers := /* TODO(PropertyAccessExpression): options?.modifiers */ TODO
            if /* TODO(BinaryExpression): (kind === SyntaxKind.ConstructorType) && signature.flags & SignatureFlags.Abstract */ TODO {
                flags := modifiersToFlags(modifiers)
                /* TODO(ExpressionStatement): modifiers = factory.createModifiersFromModifierFlags(flags | ModifierFlags.Abstract); */
            }
            node := /* TODO(ConditionalExpression): kind === SyntaxKind.CallSignature ? factory.createCallSignature(typeParameters, parameters, returnTypeNode) :                 kind === SyntaxKind.ConstructSignature ? factory.createConstructSignature(typeParameters, parameters, returnTypeNode) :                 kind === SyntaxKind.MethodSignature ? factory.createMethodSignature(modifiers, options?.name ?? factory.createIdentifier(""), options?.questionToken, typeParameters, parameters, returnTypeNode) :                 kind === SyntaxKind.MethodDeclaration ? factory.createMethodDeclaration(modifiers, /*asteriskToken* / undefined, options?.name ?? factory.createIdentifier(""), /*questionToken* / undefined, typeParameters, parameters, returnTypeNode, /*body* / undefined) :                 kind === SyntaxKind.Constructor ? factory.createConstructorDeclaration(modifiers, parameters, /*body* / undefined) :                 kind === SyntaxKind.GetAccessor ? factory.createGetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, returnTypeNode, /*body* / undefined) :                 kind === SyntaxKind.SetAccessor ? factory.createSetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, /*body* / undefined) :                 kind === SyntaxKind.IndexSignature ? factory.createIndexSignature(modifiers, parameters, returnTypeNode) :                 kind === SyntaxKind.JSDocFunctionType ? factory.createJSDocFunctionType(parameters, returnTypeNode) :                 kind === SyntaxKind.FunctionType ? factory.createFunctionTypeNode(typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) :                 kind === SyntaxKind.ConstructorType ? factory.createConstructorTypeNode(modifiers, typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) :                 kind === SyntaxKind.FunctionDeclaration ? factory.createFunctionDeclaration(modifiers, /*asteriskToken* / undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, /*body* / undefined) :                 kind === SyntaxKind.FunctionExpression ? factory.createFunctionExpression(modifiers, /*asteriskToken* / undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, factory.createBlock([])) :                 kind === SyntaxKind.ArrowFunction ? factory.createArrowFunction(modifiers, typeParameters, parameters, returnTypeNode, /*equalsGreaterThanToken* / undefined, factory.createBlock([])) :                 Debug.assertNever(kind) */ TODO
            if typeArguments {
                /* TODO(ExpressionStatement): node.typeArguments = factory.createNodeArray(typeArguments); */
            }
            if /* TODO(BinaryExpression): signature.declaration?.kind === SyntaxKind.JSDocSignature && signature.declaration.parent.kind === SyntaxKind.JSDocOverloadTag */ TODO {
                comment := /* TODO(PropertyAccessExpression): getTextOfNode(signature.declaration.parent.parent, /*includeTrivia* / true).slice(2, -2).split(/\r\n|\n|\r/).map(line => line.replace(/^\s+/, " ")).join */ TODO("\n")
                /* TODO(ExpressionStatement): addSyntheticLeadingComment(node, SyntaxKind.MultiLineCommentTrivia, comment, /*hasTrailingNewLine* / true); */
            }
            /* TODO(ExpressionStatement): cleanup?.(); */
             node
        }
        type IntroducesNewScopeNode /* TODO(UnionType): SignatureDeclaration | JSDocSignature | MappedTypeNode */ any
        isNewScopeNode := func(node Node) /* TODO(TypePredicate): node is IntroducesNewScopeNode */ TODO {
             /* TODO(BinaryExpression): isFunctionLike(node)                 || isJSDocSignature(node)                 || isMappedTypeNode(node) */ TODO
        }
        getTypeParametersInScope := func(node /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
             /* TODO(ConditionalExpression): isFunctionLike(node) || isJSDocSignature(node) ? getSignatureFromDeclaration(node).typeParameters :                 isConditionalTypeNode(node) ? getInferTypeParameters(node) :                 [getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter))] */ TODO
        }
        getParametersInScope := func(node /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] | undefined */ TODO {
             /* TODO(ConditionalExpression): isFunctionLike(node) || isJSDocSignature(node) ? getSignatureFromDeclaration(node).parameters : undefined */ TODO
        }
        enterNewScope := func(context NodeBuilderContext, declaration /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode | undefined */ any, expandedParams /* TODO(TypeOperator): readonly Symbol[] */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, originalParameters /* TODO(TypeOperator): readonly Symbol[] */ any, mapper TypeMapper) /* TODO(undefined): () => void */ TODO {
            cleanupContext := cloneNodeBuilderContext(context)
            var cleanupParams /* TODO(ParenthesizedType): (() => void) */ any
            var cleanupTypeParams /* TODO(ParenthesizedType): (() => void) */ any
            oldEnclosingDecl := /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO
            oldMapper := /* TODO(PropertyAccessExpression): context.mapper */ TODO
            if mapper {
                /* TODO(ExpressionStatement): context.mapper = mapper; */
            }
            if /* TODO(BinaryExpression): context.enclosingDeclaration && declaration */ TODO {
                /* TODO(ExpressionStatement): cleanupParams = !some(expandedParams) ? undefined : pushFakeScope(                     "params",                     add => {                         if (!expandedParams) return;                         for (let pIndex = 0; pIndex < expandedParams.length; pIndex++) {                             const param = expandedParams[pIndex];                             const originalParam = originalParameters?.[pIndex];                             if (originalParameters && originalParam !== param) {                                 // Can't reference parameters that come from an expansion                                 add(param.escapedName, unknownSymbol);                                 // Can't reference the original expanded parameter either                                 if (originalParam) {                                     add(originalParam.escapedName, unknownSymbol);                                 }                             }                             else if (                                 !forEach(param.declarations, d => {                                     if (isParameter(d) && isBindingPattern(d.name)) {                                         bindPattern(d.name);                                         return true;                                     }                                     return undefined;                                     function bindPattern(p: BindingPattern): void {                                         forEach(p.elements, e => {                                             switch (e.kind) {                                                 case SyntaxKind.OmittedExpression:                                                     return;                                                 case SyntaxKind.BindingElement:                                                     return bindElement(e);                                                 default:                                                     return Debug.assertNever(e);                                             }                                         });                                     }                                     function bindElement(e: BindingElement): void {                                         if (isBindingPattern(e.name)) {                                             return bindPattern(e.name);                                         }                                         const symbol = getSymbolOfDeclaration(e);                                         add(symbol.escapedName, symbol);                                     }                                 })                             ) {                                 add(param.escapedName, param);                             }                         }                     },                 ); */
                if /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams && some(typeParameters) */ TODO {
                    /* TODO(ExpressionStatement): cleanupTypeParams = pushFakeScope(                         "typeParams",                         add => {                             for (const typeParam of typeParameters ?? emptyArray) {                                 const typeParamName = typeParameterToName(typeParam, context).escapedText;                                 add(typeParamName, typeParam.symbol);                             }                         },                     ); */
                }
                pushFakeScope := func(kind /* TODO(UnionType): "params" | "typeParams" */ any, addAll func(addSymbol func(name __String, symbol Symbol) ) ) /* TODO(undefined): (() => void) | undefined */ TODO {
                    /* TODO(ExpressionStatement): Debug.assert(context.enclosingDeclaration); */
                    var existingFakeScope Node
                    if /* TODO(BinaryExpression): getNodeLinks(context.enclosingDeclaration).fakeScopeForSignatureDeclaration === kind */ TODO {
                        /* TODO(ExpressionStatement): existingFakeScope = context.enclosingDeclaration; */
                    } else if /* TODO(BinaryExpression): context.enclosingDeclaration.parent && getNodeLinks(context.enclosingDeclaration.parent).fakeScopeForSignatureDeclaration === kind */ TODO {
                        /* TODO(ExpressionStatement): existingFakeScope = context.enclosingDeclaration.parent; */
                    }
                    /* TODO(ExpressionStatement): Debug.assertOptionalNode(existingFakeScope, isBlock); */
                    locals := /* TODO(BinaryExpression): existingFakeScope?.locals ?? createSymbolTable() */ TODO
                    var newLocals /* TODO(ArrayType): __String[] */ any
                    var oldLocals /* TODO(ArrayType): { name: __String; oldSymbol: Symbol; }[] */ any
                    /* TODO(ExpressionStatement): addAll((name, symbol) => {                         // Add cleanup information only if we don't own the fake scope                         if (existingFakeScope) {                             const oldSymbol = locals.get(name);                             if (!oldSymbol) {                                 newLocals = append(newLocals, name);                             }                             else {                                 oldLocals = append(oldLocals, { name, oldSymbol });                             }                         }                         locals.set(name, symbol);                     }); */
                    if /* TODO(PrefixUnaryExpression): !existingFakeScope */ TODO {
                        fakeScope := /* TODO(PropertyAccessExpression): factory.createBlock */ TODO(emptyArray)
                        /* TODO(ExpressionStatement): getNodeLinks(fakeScope).fakeScopeForSignatureDeclaration = kind; */
                        /* TODO(ExpressionStatement): fakeScope.locals = locals; */
                        /* TODO(ExpressionStatement): setParent(fakeScope, context.enclosingDeclaration); */
                        /* TODO(ExpressionStatement): context.enclosingDeclaration = fakeScope; */
                    } else {
                         /* TODO(FunctionExpression): function undo() {                             forEach(newLocals, s => locals.delete(s));                             forEach(oldLocals, s => locals.set(s.name, s.oldSymbol));                         } */ TODO
                    }
                }
            }
             /* TODO(ArrowFunction): () => {                 cleanupParams?.();                 cleanupTypeParams?.();                 cleanupContext();                 context.enclosingDeclaration = oldEnclosingDecl;                 context.mapper = oldMapper;             } */ TODO
        }
        tryGetThisParameterDeclaration := func(signature Signature, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined */ TODO {
            if /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO {
                 symbolToParameterDeclaration(/* TODO(PropertyAccessExpression): signature.thisParameter */ TODO, context)
            }
            if /* TODO(BinaryExpression): signature.declaration && isInJSFile(signature.declaration) */ TODO {
                thisTag := getJSDocThisTag(/* TODO(PropertyAccessExpression): signature.declaration */ TODO)
                if /* TODO(BinaryExpression): thisTag && thisTag.typeExpression */ TODO {
                     /* TODO(PropertyAccessExpression): factory.createParameterDeclaration */ TODO(undefined, undefined, "this", undefined, typeToTypeNodeHelper(getTypeFromTypeNode(context, /* TODO(PropertyAccessExpression): thisTag.typeExpression */ TODO), context))
                }
            }
        }
        typeParameterToDeclarationWithConstraint := func(type_ TypeParameter, context NodeBuilderContext, constraintNode *TypeNode) TypeParameterDeclaration {
            restoreFlags := saveRestoreFlags(context)
            /* TODO(ExpressionStatement): context.flags &= ~NodeBuilderFlags.WriteTypeParametersInQualifiedName; */
            modifiers := /* TODO(PropertyAccessExpression): factory.createModifiersFromModifierFlags */ TODO(getTypeParameterModifiers(type_))
            name := typeParameterToName(type_, context)
            defaultParameter := getDefaultFromTypeParameter(type_)
            defaultParameterNode := /* TODO(BinaryExpression): defaultParameter && typeToTypeNodeHelper(defaultParameter, context) */ TODO
            /* TODO(ExpressionStatement): restoreFlags(); */
             /* TODO(PropertyAccessExpression): factory.createTypeParameterDeclaration */ TODO(modifiers, name, constraintNode, defaultParameterNode)
        }
        typeToTypeNodeHelperWithPossibleReusableTypeNode := func(type_ Type, typeNode *TypeNode, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
             /* TODO(BinaryExpression): typeNode && tryReuseExistingNonParameterTypeNode(context, typeNode, type) || typeToTypeNodeHelper(type, context) */ TODO
        }
        typeParameterToDeclaration := func(type_ TypeParameter, context NodeBuilderContext, constraint /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO /* = */ /* TODO(CallExpression): getConstraintOfTypeParameter(type) */) TypeParameterDeclaration {
            constraintNode := /* TODO(BinaryExpression): constraint && typeToTypeNodeHelperWithPossibleReusableTypeNode(constraint, getConstraintDeclaration(type), context) */ TODO
             typeParameterToDeclarationWithConstraint(type_, context, constraintNode)
        }
        typePredicateToTypePredicateNodeHelper := func(typePredicate TypePredicate, context NodeBuilderContext) TypePredicateNode {
            assertsModifier := /* TODO(ConditionalExpression): typePredicate.kind === TypePredicateKind.AssertsThis || typePredicate.kind === TypePredicateKind.AssertsIdentifier ?                 factory.createToken(SyntaxKind.AssertsKeyword) :                 undefined */ TODO
            parameterName := /* TODO(ConditionalExpression): typePredicate.kind === TypePredicateKind.Identifier || typePredicate.kind === TypePredicateKind.AssertsIdentifier ?                 setEmitFlags(factory.createIdentifier(typePredicate.parameterName), EmitFlags.NoAsciiEscaping) :                 factory.createThisTypeNode() */ TODO
            typeNode := /* TODO(BinaryExpression): typePredicate.type && typeToTypeNodeHelper(typePredicate.type, context) */ TODO
             /* TODO(PropertyAccessExpression): factory.createTypePredicateNode */ TODO(assertsModifier, parameterName, typeNode)
        }
        getEffectiveParameterDeclaration := func(parameterSymbol Symbol) /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any {
            var parameterDeclaration /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any = getDeclarationOfKind(parameterSymbol, /* TODO(PropertyAccessExpression): SyntaxKind.Parameter */ TODO)
            if parameterDeclaration {
                 parameterDeclaration
            }
            if /* TODO(PrefixUnaryExpression): !isTransientSymbol(parameterSymbol) */ TODO {
                 getDeclarationOfKind(parameterSymbol, /* TODO(PropertyAccessExpression): SyntaxKind.JSDocParameterTag */ TODO)
            }
        }
        symbolToParameterDeclaration := func(parameterSymbol Symbol, context NodeBuilderContext, preserveModifierFlags bool) ParameterDeclaration {
            parameterDeclaration := getEffectiveParameterDeclaration(parameterSymbol)
            parameterType := getTypeOfSymbol(parameterSymbol)
            parameterTypeNode := serializeTypeForDeclaration(context, parameterDeclaration, parameterType, parameterSymbol)
            modifiers := /* TODO(ConditionalExpression): !(context.flags & NodeBuilderFlags.OmitParameterModifiers) && preserveModifierFlags && parameterDeclaration && canHaveModifiers(parameterDeclaration) ? map(getModifiers(parameterDeclaration), factory.cloneNode) : undefined */ TODO
            isRest := /* TODO(BinaryExpression): parameterDeclaration && isRestParameter(parameterDeclaration) || getCheckFlags(parameterSymbol) & CheckFlags.RestParameter */ TODO
            dotDotDotToken := /* TODO(ConditionalExpression): isRest ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined */ TODO
            name := parameterToParameterDeclarationName(parameterSymbol, parameterDeclaration, context)
            isOptional := /* TODO(BinaryExpression): parameterDeclaration && isOptionalParameter(parameterDeclaration) || getCheckFlags(parameterSymbol) & CheckFlags.OptionalParameter */ TODO
            questionToken := /* TODO(ConditionalExpression): isOptional ? factory.createToken(SyntaxKind.QuestionToken) : undefined */ TODO
            parameterNode := /* TODO(PropertyAccessExpression): factory.createParameterDeclaration */ TODO(modifiers, dotDotDotToken, name, questionToken, parameterTypeNode, undefined)
            /* TODO(ExpressionStatement): context.approximateLength += symbolName(parameterSymbol).length + 3; */
             parameterNode
        }
        parameterToParameterDeclarationName := func(parameterSymbol Symbol, parameterDeclaration /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any, context NodeBuilderContext) /* TODO(undefined): string | import("/home/jabaile/work/TypeScript/src/compiler/types").BindingName */ TODO {
             /* TODO(ConditionalExpression): parameterDeclaration ? parameterDeclaration.name ?                 parameterDeclaration.name.kind === SyntaxKind.Identifier ? setEmitFlags(factory.cloneNode(parameterDeclaration.name), EmitFlags.NoAsciiEscaping) :                     parameterDeclaration.name.kind === SyntaxKind.QualifiedName ? setEmitFlags(factory.cloneNode(parameterDeclaration.name.right), EmitFlags.NoAsciiEscaping) :                     cloneBindingName(parameterDeclaration.name) :                 symbolName(parameterSymbol) :                 symbolName(parameterSymbol) */ TODO
            cloneBindingName := func(node BindingName) BindingName {
                 elideInitializerAndSetEmitFlags(node) /* as */ /* TODO(TypeReference): BindingName */
                elideInitializerAndSetEmitFlags := func(node Node) Node {
                    if /* TODO(BinaryExpression): context.tracker.canTrackSymbol && isComputedPropertyName(node) && isLateBindableName(node) */ TODO {
                        /* TODO(ExpressionStatement): trackComputedName(node.expression, context.enclosingDeclaration, context); */
                    }
                    visited := visitEachChildWorker(node, elideInitializerAndSetEmitFlags, undefined, undefined, elideInitializerAndSetEmitFlags)
                    if isBindingElement(visited) {
                        /* TODO(ExpressionStatement): visited = factory.updateBindingElement(                             visited,                             visited.dotDotDotToken,                             visited.propertyName,                             visited.name,                             /*initializer* / undefined,                         ); */
                    }
                    if /* TODO(PrefixUnaryExpression): !nodeIsSynthesized(visited) */ TODO {
                        /* TODO(ExpressionStatement): visited = factory.cloneNode(visited); */
                    }
                     setEmitFlags(visited, /* TODO(BinaryExpression): EmitFlags.SingleLine | EmitFlags.NoAsciiEscaping */ TODO)
                }
            }
        }
        trackComputedName := func(accessExpression EntityNameOrEntityNameExpression, enclosingDeclaration Node, context NodeBuilderContext) {
            if /* TODO(PrefixUnaryExpression): !context.tracker.canTrackSymbol */ TODO {
            }
            firstIdentifier := getFirstIdentifier(accessExpression)
            name := resolveName(firstIdentifier, /* TODO(PropertyAccessExpression): firstIdentifier.escapedText */ TODO, /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.ExportValue */ TODO, undefined, /* TODO(TrueKeyword): true */ TODO)
            if name {
                /* TODO(ExpressionStatement): context.tracker.trackSymbol(name, enclosingDeclaration, SymbolFlags.Value); */
            }
        }
        lookupSymbolChain := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
            /* TODO(ExpressionStatement): context.tracker.trackSymbol(symbol, context.enclosingDeclaration, meaning); */
             lookupSymbolChainWorker(symbol, context, meaning, yieldModuleSymbol)
        }
        lookupSymbolChainWorker := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
            var chain []Symbol
            isTypeParameter := /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeParameter */ TODO
            if /* TODO(BinaryExpression): !isTypeParameter && (context.enclosingDeclaration || context.flags & NodeBuilderFlags.UseFullyQualifiedType) && !(context.internalFlags & InternalNodeBuilderFlags.DoNotIncludeSymbolChain) */ TODO {
                /* TODO(ExpressionStatement): chain = Debug.checkDefined(getSymbolChain(symbol, meaning, /*endOfChain* / true)); */
                /* TODO(ExpressionStatement): Debug.assert(chain && chain.length > 0); */
            } else {
                /* TODO(ExpressionStatement): chain = [symbol]; */
            }
             chain
            getSymbolChain := func(symbol Symbol, meaning SymbolFlags, endOfChain bool) /* TODO(ArrayType): Symbol[] */ any {
                accessibleSymbolChain := getAccessibleSymbolChain(symbol, /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO, meaning, /* TODO(PrefixUnaryExpression): !!(context.flags & NodeBuilderFlags.UseOnlyExternalAliasing) */ TODO)
                var parentSpecifiers []/* TODO(StringKeyword): string */ any
                if /* TODO(BinaryExpression): !accessibleSymbolChain ||                     needsQualification(accessibleSymbolChain[0], context.enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning)) */ TODO {
                    parents := getContainersOfSymbol(/* TODO(ConditionalExpression): accessibleSymbolChain ? accessibleSymbolChain[0] : symbol */ TODO, /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO, meaning)
                    if length(parents) {
                        /* TODO(ExpressionStatement): parentSpecifiers = parents!.map(symbol =>                             some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)                                 ? getSpecifierForModuleSymbol(symbol, context)                                 : undefined                         ); */
                        indices := /* TODO(PropertyAccessExpression): parents!.map */ TODO(/* TODO(ArrowFunction): (_, i) => i */ TODO)
                        /* TODO(ExpressionStatement): indices.sort(sortByBestName); */
                        sortedParents := /* TODO(PropertyAccessExpression): indices.map */ TODO(/* TODO(ArrowFunction): i => parents![i] */ TODO)
                        /* TODO(ForOfStatement): for (const parent of sortedParents) {                             const parentChain = getSymbolChain(parent, getQualifiedLeftMeaning(meaning), /*endOfChain* / false);                             if (parentChain) {                                 if (                                     parent.exports && parent.exports.get(InternalSymbolName.ExportEquals) &&                                     getSymbolIfSameReference(parent.exports.get(InternalSymbolName.ExportEquals)!, symbol)                                 ) {                                     // parentChain root _is_ symbol - symbol is a module export=, so it kinda looks like it's own parent                                     // No need to lookup an alias for the symbol in itself                                     accessibleSymbolChain = parentChain;                                     break;                                 }                                 accessibleSymbolChain = parentChain.concat(accessibleSymbolChain || [getAliasForSymbolInContainer(parent, symbol) || symbol]);                                 break;                             }                         } */
                    }
                }
                if accessibleSymbolChain {
                     accessibleSymbolChain
                }
                if /* TODO(BinaryExpression): endOfChain ||                     // If a parent symbol is an anonymous type, don't write it.                     !(symbol.flags & (SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral)) */ TODO {
                    if /* TODO(BinaryExpression): !endOfChain && !yieldModuleSymbol && !!forEach(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) */ TODO {

                    }
                     /* TODO(ArrayLiteralExpression): [symbol] */ TODO
                }
                sortByBestName := func(a number, b number) /* TODO(undefined): number */ TODO {
                    specifierA := /* TODO(ElementAccessExpression): parentSpecifiers[a] */ TODO
                    specifierB := /* TODO(ElementAccessExpression): parentSpecifiers[b] */ TODO
                    if /* TODO(BinaryExpression): specifierA && specifierB */ TODO {
                        isBRelative := pathIsRelative(specifierB)
                        if /* TODO(BinaryExpression): pathIsRelative(specifierA) === isBRelative */ TODO {
                             /* TODO(BinaryExpression): moduleSpecifiers.countPathComponents(specifierA) - moduleSpecifiers.countPathComponents(specifierB) */ TODO
                        }
                        if isBRelative {
                             /* TODO(PrefixUnaryExpression): -1 */ TODO
                        }
                         1
                    }
                     0
                }
            }
        }
        typeParametersToTypeParameterDeclarations := func(symbol Symbol, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").NodeArray<import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration> | undefined */ TODO {
            var typeParameterNodes *NodeArray[TypeParameterDeclaration]
            targetSymbol := getTargetSymbol(symbol)
            if /* TODO(BinaryExpression): targetSymbol.flags & (SymbolFlags.Class | SymbolFlags.Interface | SymbolFlags.TypeAlias) */ TODO {
                /* TODO(ExpressionStatement): typeParameterNodes = factory.createNodeArray(map(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol), tp => typeParameterToDeclaration(tp, context))); */
            }
             typeParameterNodes
        }
        lookupTypeParameterNodes := func(chain []Symbol, index number, context NodeBuilderContext) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode[] | readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration[] | undefined */ TODO {
            /* TODO(ExpressionStatement): Debug.assert(chain && 0 <= index && index < chain.length); */
            symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
            symbolId := getSymbolId(symbol)
            if /* TODO(PropertyAccessExpression): context.typeParameterSymbolList?.has */ TODO(symbolId) {
                 undefined
            }
            if /* TODO(PropertyAccessExpression): context.mustCreateTypeParameterSymbolList */ TODO {
                /* TODO(ExpressionStatement): context.mustCreateTypeParameterSymbolList = false; */
                /* TODO(ExpressionStatement): context.typeParameterSymbolList = new Set(context.typeParameterSymbolList); */
            }
            /* TODO(ExpressionStatement): context.typeParameterSymbolList!.add(symbolId); */
            var typeParameterNodes /* TODO(UnionType): readonly TypeNode[] | readonly TypeParameterDeclaration[] | undefined */ any
            if /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.WriteTypeParametersInQualifiedName && index < (chain.length - 1) */ TODO {
                parentSymbol := symbol
                nextSymbol := /* TODO(ElementAccessExpression): chain[index + 1] */ TODO
                if /* TODO(BinaryExpression): getCheckFlags(nextSymbol) & CheckFlags.Instantiated */ TODO {
                    params := getTypeParametersOfClassOrInterface(/* TODO(ConditionalExpression): parentSymbol.flags & SymbolFlags.Alias ? resolveAlias(parentSymbol) : parentSymbol */ TODO)
                    /* TODO(ExpressionStatement): typeParameterNodes = mapToTypeNodes(map(params, t => getMappedType(t, (nextSymbol as TransientSymbol).links.mapper!)), context); */
                } else {
                    /* TODO(ExpressionStatement): typeParameterNodes = typeParametersToTypeParameterDeclarations(symbol, context); */
                }
            }
             typeParameterNodes
        }
        getTopmostIndexedAccessType := func(top IndexedAccessTypeNode) IndexedAccessTypeNode {
            if isIndexedAccessTypeNode(/* TODO(PropertyAccessExpression): top.objectType */ TODO) {
                 getTopmostIndexedAccessType(/* TODO(PropertyAccessExpression): top.objectType */ TODO)
            }
             top
        }
        getSpecifierForModuleSymbol := func(symbol Symbol, context NodeBuilderContext, overrideImportMode ResolutionMode) /* TODO(undefined): string */ TODO {
            file := getDeclarationOfKind(symbol, /* TODO(PropertyAccessExpression): SyntaxKind.SourceFile */ TODO)
            if /* TODO(PrefixUnaryExpression): !file */ TODO {
                equivalentFileSymbol := firstDefined(/* TODO(PropertyAccessExpression): symbol.declarations */ TODO, /* TODO(ArrowFunction): d => getFileSymbolIfFileSymbolExportEqualsContainer(d, symbol) */ TODO)
                if equivalentFileSymbol {
                    /* TODO(ExpressionStatement): file = getDeclarationOfKind<SourceFile>(equivalentFileSymbol, SyntaxKind.SourceFile); */
                }
            }
            if /* TODO(BinaryExpression): file && file.moduleName !== undefined */ TODO {
                 /* TODO(PropertyAccessExpression): file.moduleName */ TODO
            }
            if /* TODO(PrefixUnaryExpression): !file */ TODO {
                if /* TODO(PropertyAccessExpression): ambientModuleSymbolRegex.test */ TODO(/* TODO(PropertyAccessExpression): symbol.escapedName */ TODO /* as */ /* TODO(StringKeyword): string */) {
                     /* TODO(PropertyAccessExpression): (symbol.escapedName as string).substring */ TODO(1, /* TODO(BinaryExpression): (symbol.escapedName as string).length - 1 */ TODO)
                }
            }
            if /* TODO(BinaryExpression): !context.enclosingFile || !context.tracker.moduleResolverHost */ TODO {
                if /* TODO(PropertyAccessExpression): ambientModuleSymbolRegex.test */ TODO(/* TODO(PropertyAccessExpression): symbol.escapedName */ TODO /* as */ /* TODO(StringKeyword): string */) {
                     /* TODO(PropertyAccessExpression): (symbol.escapedName as string).substring */ TODO(1, /* TODO(BinaryExpression): (symbol.escapedName as string).length - 1 */ TODO)
                }
                 /* TODO(PropertyAccessExpression): getSourceFileOfNode(getNonAugmentationDeclaration(symbol)!).fileName */ TODO
            }
            enclosingDeclaration := getOriginalNode(/* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO)
            originalModuleSpecifier := /* TODO(ConditionalExpression): canHaveModuleSpecifier(enclosingDeclaration) ? tryGetModuleSpecifierFromDeclaration(enclosingDeclaration) : undefined */ TODO
            contextFile := /* TODO(PropertyAccessExpression): context.enclosingFile */ TODO
            resolutionMode := /* TODO(BinaryExpression): overrideImportMode                 || originalModuleSpecifier && host.getModeForUsageLocation(contextFile, originalModuleSpecifier)                 || contextFile && host.getDefaultResolutionModeForFile(contextFile) */ TODO
            cacheKey := createModeAwareCacheKey(/* TODO(PropertyAccessExpression): contextFile.path */ TODO, resolutionMode)
            links := getSymbolLinks(symbol)
            specifier := /* TODO(BinaryExpression): links.specifierCache && links.specifierCache.get(cacheKey) */ TODO
            if /* TODO(PrefixUnaryExpression): !specifier */ TODO {
                isBundle := /* TODO(PrefixUnaryExpression): !!compilerOptions.outFile */ TODO
                TODO_IDENTIFIER := /* TODO(PropertyAccessExpression): context.tracker */ TODO
                specifierCompilerOptions := /* TODO(ConditionalExpression): isBundle ? { ...compilerOptions, baseUrl: moduleResolverHost.getCommonSourceDirectory() } : compilerOptions */ TODO
                /* TODO(ExpressionStatement): specifier = first(moduleSpecifiers.getModuleSpecifiers(                     symbol,                     checker,                     specifierCompilerOptions,                     contextFile,                     moduleResolverHost,                     {                         importModuleSpecifierPreference: isBundle ? "non-relative" : "project-relative",                         importModuleSpecifierEnding: isBundle ? "minimal"                             : resolutionMode === ModuleKind.ESNext ? "js"                             : undefined,                     },                     { overrideImportMode },                 )); */
                /* TODO(ExpressionStatement): links.specifierCache ??= new Map(); */
                /* TODO(ExpressionStatement): links.specifierCache.set(cacheKey, specifier); */
            }
             specifier
        }
        symbolToEntityNameNode := func(symbol Symbol) EntityName {
            identifier := /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(unescapeLeadingUnderscores(/* TODO(PropertyAccessExpression): symbol.escapedName */ TODO))
             /* TODO(ConditionalExpression): symbol.parent ? factory.createQualifiedName(symbolToEntityNameNode(symbol.parent), identifier) : identifier */ TODO
        }
        symbolToTypeNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, overrideTypeArguments []TypeNode) TypeNode {
            chain := lookupSymbolChain(symbol, context, meaning, /* TODO(PrefixUnaryExpression): !(context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope) */ TODO)
            isTypeOf := /* TODO(BinaryExpression): meaning === SymbolFlags.Value */ TODO
            if some(/* TODO(PropertyAccessExpression): chain[0].declarations */ TODO, hasNonGlobalAugmentationExternalModuleSymbol) {
                nonRootParts := /* TODO(ConditionalExpression): chain.length > 1 ? createAccessFromSymbolChain(chain, chain.length - 1, 1) : undefined */ TODO
                typeParameterNodes := /* TODO(BinaryExpression): overrideTypeArguments || lookupTypeParameterNodes(chain, 0, context) */ TODO
                contextFile := getSourceFileOfNode(getOriginalNode(/* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO))
                targetFile := getSourceFileOfModule(/* TODO(ElementAccessExpression): chain[0] */ TODO)
                var specifier /* TODO(StringKeyword): string */ any
                var attributes *ImportAttributes
                if /* TODO(BinaryExpression): getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.Node16 || getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.NodeNext */ TODO {
                    if /* TODO(BinaryExpression): targetFile?.impliedNodeFormat === ModuleKind.ESNext && targetFile.impliedNodeFormat !== contextFile?.impliedNodeFormat */ TODO {
                        /* TODO(ExpressionStatement): specifier = getSpecifierForModuleSymbol(chain[0], context, ModuleKind.ESNext); */
                        /* TODO(ExpressionStatement): attributes = factory.createImportAttributes(                             factory.createNodeArray([                                 factory.createImportAttribute(                                     factory.createStringLiteral("resolution-mode"),                                     factory.createStringLiteral("import"),                                 ),                             ]),                         ); */
                    }
                }
                if /* TODO(PrefixUnaryExpression): !specifier */ TODO {
                    /* TODO(ExpressionStatement): specifier = getSpecifierForModuleSymbol(chain[0], context); */
                }
                if /* TODO(BinaryExpression): !(context.flags & NodeBuilderFlags.AllowNodeModulesRelativePaths) && getEmitModuleResolutionKind(compilerOptions) !== ModuleResolutionKind.Classic && specifier.includes("/node_modules/") */ TODO {
                    oldSpecifier := specifier
                    if /* TODO(BinaryExpression): getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.Node16 || getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.NodeNext */ TODO {
                        swappedMode := /* TODO(ConditionalExpression): contextFile?.impliedNodeFormat === ModuleKind.ESNext ? ModuleKind.CommonJS : ModuleKind.ESNext */ TODO
                        /* TODO(ExpressionStatement): specifier = getSpecifierForModuleSymbol(chain[0], context, swappedMode); */
                        if /* TODO(PropertyAccessExpression): specifier.includes */ TODO("/node_modules/") {
                            /* TODO(ExpressionStatement): specifier = oldSpecifier; */
                        } else {
                            /* TODO(ExpressionStatement): attributes = factory.createImportAttributes(                                 factory.createNodeArray([                                     factory.createImportAttribute(                                         factory.createStringLiteral("resolution-mode"),                                         factory.createStringLiteral(swappedMode === ModuleKind.ESNext ? "import" : "require"),                                     ),                                 ]),                             ); */
                        }
                    }
                    if /* TODO(PrefixUnaryExpression): !attributes */ TODO {
                        /* TODO(ExpressionStatement): context.encounteredError = true; */
                        if /* TODO(PropertyAccessExpression): context.tracker.reportLikelyUnsafeImportRequiredError */ TODO {
                            /* TODO(ExpressionStatement): context.tracker.reportLikelyUnsafeImportRequiredError(oldSpecifier); */
                        }
                    }
                }
                lit := /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(specifier))
                /* TODO(ExpressionStatement): context.approximateLength += specifier.length + 10; */
                if /* TODO(BinaryExpression): !nonRootParts || isEntityName(nonRootParts) */ TODO {
                    if nonRootParts {
                        lastId := /* TODO(ConditionalExpression): isIdentifier(nonRootParts) ? nonRootParts : nonRootParts.right */ TODO
                        /* TODO(ExpressionStatement): setIdentifierTypeArguments(lastId, /*typeArguments* / undefined); */
                    }
                     /* TODO(PropertyAccessExpression): factory.createImportTypeNode */ TODO(lit, attributes, nonRootParts /* as */ /* TODO(TypeReference): EntityName */, typeParameterNodes /* as */ /* TODO(TypeOperator): readonly TypeNode[] */, isTypeOf)
                } else {
                    splitNode := getTopmostIndexedAccessType(nonRootParts)
                    qualifier := /* TODO(PropertyAccessExpression): (splitNode.objectType as TypeReferenceNode).typeName */ TODO
                     /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createImportTypeNode */ TODO(lit, attributes, qualifier, typeParameterNodes /* as */ /* TODO(TypeOperator): readonly TypeNode[] */, isTypeOf), /* TODO(PropertyAccessExpression): splitNode.indexType */ TODO)
                }
            }
            entityName := createAccessFromSymbolChain(chain, /* TODO(BinaryExpression): chain.length - 1 */ TODO, 0)
            if isIndexedAccessTypeNode(entityName) {
                 entityName
            }
            if isTypeOf {
                 /* TODO(PropertyAccessExpression): factory.createTypeQueryNode */ TODO(entityName)
            } else {
                lastId := /* TODO(ConditionalExpression): isIdentifier(entityName) ? entityName : entityName.right */ TODO
                lastTypeArgs := getIdentifierTypeArguments(lastId)
                /* TODO(ExpressionStatement): setIdentifierTypeArguments(lastId, /*typeArguments* / undefined); */
                 /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(entityName, lastTypeArgs /* as */ /* TODO(TypeReference): NodeArray<TypeNode> */)
            }
            createAccessFromSymbolChain := func(chain []Symbol, index number, stopper number) /* TODO(UnionType): EntityName | IndexedAccessTypeNode */ any {
                typeParameterNodes := /* TODO(ConditionalExpression): index === (chain.length - 1) ? overrideTypeArguments : lookupTypeParameterNodes(chain, index, context) */ TODO
                symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
                parent := /* TODO(ElementAccessExpression): chain[index - 1] */ TODO
                var symbolName /* TODO(StringKeyword): string */ any
                if /* TODO(BinaryExpression): index === 0 */ TODO {
                    /* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.InInitialEntityName; */
                    /* TODO(ExpressionStatement): symbolName = getNameOfSymbolAsWritten(symbol, context); */
                    /* TODO(ExpressionStatement): context.approximateLength += (symbolName ? symbolName.length : 0) + 1; */
                    /* TODO(ExpressionStatement): context.flags ^= NodeBuilderFlags.InInitialEntityName; */
                } else {
                    if /* TODO(BinaryExpression): parent && getExportsOfSymbol(parent) */ TODO {
                        exports := getExportsOfSymbol(parent)
                        /* TODO(ExpressionStatement): forEachEntry(exports, (ex, name) => {                             if (getSymbolIfSameReference(ex, symbol) && !isLateBoundName(name) && name !== InternalSymbolName.ExportEquals) {                                 symbolName = unescapeLeadingUnderscores(name);                                 return true;                             }                         }); */
                    }
                }
                if /* TODO(BinaryExpression): symbolName === undefined */ TODO {
                    name := firstDefined(/* TODO(PropertyAccessExpression): symbol.declarations */ TODO, getNameOfDeclaration)
                    if /* TODO(BinaryExpression): name && isComputedPropertyName(name) && isEntityName(name.expression) */ TODO {
                        LHS := createAccessFromSymbolChain(chain, /* TODO(BinaryExpression): index - 1 */ TODO, stopper)
                        if isEntityName(LHS) {
                             /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createParenthesizedType */ TODO(/* TODO(PropertyAccessExpression): factory.createTypeQueryNode */ TODO(LHS)), /* TODO(PropertyAccessExpression): factory.createTypeQueryNode */ TODO(/* TODO(PropertyAccessExpression): name.expression */ TODO))
                        }
                         LHS
                    }
                    /* TODO(ExpressionStatement): symbolName = getNameOfSymbolAsWritten(symbol, context); */
                }
                /* TODO(ExpressionStatement): context.approximateLength += symbolName.length + 1; */
                if /* TODO(BinaryExpression): !(context.flags & NodeBuilderFlags.ForbidIndexedAccessSymbolReferences) && parent &&                     getMembersOfSymbol(parent) && getMembersOfSymbol(parent).get(symbol.escapedName) &&                     getSymbolIfSameReference(getMembersOfSymbol(parent).get(symbol.escapedName)!, symbol) */ TODO {
                    LHS := createAccessFromSymbolChain(chain, /* TODO(BinaryExpression): index - 1 */ TODO, stopper)
                    if isIndexedAccessTypeNode(LHS) {
                         /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO(LHS, /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(symbolName)))
                    } else {
                         /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(LHS, typeParameterNodes /* as */ /* TODO(TypeOperator): readonly TypeNode[] */), /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO(/* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(symbolName)))
                    }
                }
                identifier := setEmitFlags(/* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(symbolName), /* TODO(PropertyAccessExpression): EmitFlags.NoAsciiEscaping */ TODO)
                if typeParameterNodes {
                    /* TODO(CallExpression): setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes)) */
                }
                /* TODO(ExpressionStatement): identifier.symbol = symbol; */
                if /* TODO(BinaryExpression): index > stopper */ TODO {
                    LHS := createAccessFromSymbolChain(chain, /* TODO(BinaryExpression): index - 1 */ TODO, stopper)
                    if /* TODO(PrefixUnaryExpression): !isEntityName(LHS) */ TODO {
                         /* TODO(PropertyAccessExpression): Debug.fail */ TODO("Impossible construct - an export of an indexed access cannot be reachable")
                    }
                     /* TODO(PropertyAccessExpression): factory.createQualifiedName */ TODO(LHS, identifier)
                }
                 identifier
            }
        }
        typeParameterShadowsOtherTypeParameterInScope := func(escapedName __String, context NodeBuilderContext, type_ TypeParameter) /* TODO(undefined): boolean */ TODO {
            result := resolveName(/* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO, escapedName, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO, undefined, /* TODO(FalseKeyword): false */ TODO)
            if /* TODO(BinaryExpression): result && result.flags & SymbolFlags.TypeParameter */ TODO {
                 /* TODO(BinaryExpression): result !== type.symbol */ TODO
            }
             /* TODO(FalseKeyword): false */ TODO
        }
        typeParameterToName := func(type_ TypeParameter, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier */ TODO {
            if /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams && context.typeParameterNames */ TODO {
                cached := /* TODO(PropertyAccessExpression): context.typeParameterNames.get */ TODO(getTypeId(type_))
                if cached {
                     cached
                }
            }
            result := symbolToName(/* TODO(PropertyAccessExpression): type.symbol */ TODO, context, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO, /* TODO(TrueKeyword): true */ TODO)
            if /* TODO(PrefixUnaryExpression): !(result.kind & SyntaxKind.Identifier) */ TODO {
                 /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO("(Missing type parameter)")
            }
            decl := /* TODO(ElementAccessExpression): type.symbol?.declarations?.[0] */ TODO
            if /* TODO(BinaryExpression): decl && isTypeParameterDeclaration(decl) */ TODO {
                /* TODO(ExpressionStatement): result = setTextRange(context, result, decl.name); */
            }
            if /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams */ TODO {
                rawtext := /* TODO(PropertyAccessExpression): result.escapedText */ TODO /* as */ /* TODO(StringKeyword): string */
                i := /* TODO(BinaryExpression): context.typeParameterNamesByTextNextNameCount?.get(rawtext) || 0 */ TODO
                text := rawtext
                /* TODO(WhileStatement): while (context.typeParameterNamesByText?.has(text) || typeParameterShadowsOtherTypeParameterInScope(text as __String, context, type)) {                     i++;                     text = `${rawtext}_${i}`;                 } */
                if /* TODO(BinaryExpression): text !== rawtext */ TODO {
                    typeArguments := getIdentifierTypeArguments(result)
                    /* TODO(ExpressionStatement): result = factory.createIdentifier(text); */
                    /* TODO(ExpressionStatement): setIdentifierTypeArguments(result, typeArguments); */
                }
                if /* TODO(PropertyAccessExpression): context.mustCreateTypeParametersNamesLookups */ TODO {
                    /* TODO(ExpressionStatement): context.mustCreateTypeParametersNamesLookups = false; */
                    /* TODO(ExpressionStatement): context.typeParameterNames = new Map(context.typeParameterNames); */
                    /* TODO(ExpressionStatement): context.typeParameterNamesByTextNextNameCount = new Map(context.typeParameterNamesByTextNextNameCount); */
                    /* TODO(ExpressionStatement): context.typeParameterNamesByText = new Set(context.typeParameterNamesByText); */
                }
                /* TODO(ExpressionStatement): context.typeParameterNamesByTextNextNameCount!.set(rawtext, i); */
                /* TODO(ExpressionStatement): context.typeParameterNames!.set(getTypeId(type), result); */
                /* TODO(ExpressionStatement): context.typeParameterNamesByText!.add(text); */
            }
             result
        }
        // OVERLOAD: symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier /* TODO(LiteralType): true */ TODO) Identifier
        // OVERLOAD: symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier /* TODO(LiteralType): false */ TODO) EntityName
        symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier bool) EntityName {
            chain := lookupSymbolChain(symbol, context, meaning)
            if /* TODO(BinaryExpression): expectsIdentifier && chain.length !== 1                 && !context.encounteredError                 && !(context.flags & NodeBuilderFlags.AllowQualifiedNameInPlaceOfIdentifier) */ TODO {
                /* TODO(ExpressionStatement): context.encounteredError = true; */
            }
             createEntityNameFromSymbolChain(chain, /* TODO(BinaryExpression): chain.length - 1 */ TODO)
            createEntityNameFromSymbolChain := func(chain []Symbol, index number) EntityName {
                typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
                symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
                if /* TODO(BinaryExpression): index === 0 */ TODO {
                    /* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.InInitialEntityName; */
                }
                symbolName := getNameOfSymbolAsWritten(symbol, context)
                if /* TODO(BinaryExpression): index === 0 */ TODO {
                    /* TODO(ExpressionStatement): context.flags ^= NodeBuilderFlags.InInitialEntityName; */
                }
                identifier := setEmitFlags(/* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(symbolName), /* TODO(PropertyAccessExpression): EmitFlags.NoAsciiEscaping */ TODO)
                if typeParameterNodes {
                    /* TODO(CallExpression): setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes)) */
                }
                /* TODO(ExpressionStatement): identifier.symbol = symbol; */
                 /* TODO(ConditionalExpression): index > 0 ? factory.createQualifiedName(createEntityNameFromSymbolChain(chain, index - 1), identifier) : identifier */ TODO
            }
        }
        symbolToExpression := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ TODO {
            chain := lookupSymbolChain(symbol, context, meaning)
             createExpressionFromSymbolChain(chain, /* TODO(BinaryExpression): chain.length - 1 */ TODO)
            createExpressionFromSymbolChain := func(chain []Symbol, index number) Expression {
                typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
                symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
                if /* TODO(BinaryExpression): index === 0 */ TODO {
                    /* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.InInitialEntityName; */
                }
                symbolName := getNameOfSymbolAsWritten(symbol, context)
                if /* TODO(BinaryExpression): index === 0 */ TODO {
                    /* TODO(ExpressionStatement): context.flags ^= NodeBuilderFlags.InInitialEntityName; */
                }
                firstChar := /* TODO(PropertyAccessExpression): symbolName.charCodeAt */ TODO(0)
                if /* TODO(BinaryExpression): isSingleOrDoubleQuote(firstChar) && some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) */ TODO {
                     /* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(getSpecifierForModuleSymbol(symbol, context))
                }
                if /* TODO(BinaryExpression): index === 0 || canUsePropertyAccess(symbolName, languageVersion) */ TODO {
                    identifier := setEmitFlags(/* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(symbolName), /* TODO(PropertyAccessExpression): EmitFlags.NoAsciiEscaping */ TODO)
                    if typeParameterNodes {
                        /* TODO(CallExpression): setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes)) */
                    }
                    /* TODO(ExpressionStatement): identifier.symbol = symbol; */
                     /* TODO(ConditionalExpression): index > 0 ? factory.createPropertyAccessExpression(createExpressionFromSymbolChain(chain, index - 1), identifier) : identifier */ TODO
                } else {
                    if /* TODO(BinaryExpression): firstChar === CharacterCodes.openBracket */ TODO {
                        /* TODO(ExpressionStatement): symbolName = symbolName.substring(1, symbolName.length - 1); */
                        /* TODO(ExpressionStatement): firstChar = symbolName.charCodeAt(0); */
                    }
                    var expression *Expression
                    if /* TODO(BinaryExpression): isSingleOrDoubleQuote(firstChar) && !(symbol.flags & SymbolFlags.EnumMember) */ TODO {
                        /* TODO(ExpressionStatement): expression = factory.createStringLiteral(stripQuotes(symbolName).replace(/\\./g, s => s.substring(1)), firstChar === CharacterCodes.singleQuote); */
                    } else if /* TODO(BinaryExpression): ("" + +symbolName) === symbolName */ TODO {
                        /* TODO(ExpressionStatement): expression = factory.createNumericLiteral(+symbolName); */
                    }
                    if /* TODO(PrefixUnaryExpression): !expression */ TODO {
                        identifier := setEmitFlags(/* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(symbolName), /* TODO(PropertyAccessExpression): EmitFlags.NoAsciiEscaping */ TODO)
                        if typeParameterNodes {
                            /* TODO(CallExpression): setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes)) */
                        }
                        /* TODO(ExpressionStatement): identifier.symbol = symbol; */
                        /* TODO(ExpressionStatement): expression = identifier; */
                    }
                     /* TODO(PropertyAccessExpression): factory.createElementAccessExpression */ TODO(createExpressionFromSymbolChain(chain, /* TODO(BinaryExpression): index - 1 */ TODO), expression)
                }
            }
        }
        isStringNamed := func(d Declaration) /* TODO(undefined): boolean */ TODO {
            name := getNameOfDeclaration(d)
            if /* TODO(PrefixUnaryExpression): !name */ TODO {
                 /* TODO(FalseKeyword): false */ TODO
            }
            if isComputedPropertyName(name) {
                type_ := checkExpression(/* TODO(PropertyAccessExpression): name.expression */ TODO)
                 /* TODO(PrefixUnaryExpression): !!(type.flags & TypeFlags.StringLike) */ TODO
            }
            if isElementAccessExpression(name) {
                type_ := checkExpression(/* TODO(PropertyAccessExpression): name.argumentExpression */ TODO)
                 /* TODO(PrefixUnaryExpression): !!(type.flags & TypeFlags.StringLike) */ TODO
            }
             isStringLiteral(name)
        }
        isSingleQuotedStringNamed := func(d Declaration) /* TODO(undefined): boolean */ TODO {
            name := getNameOfDeclaration(d)
             /* TODO(PrefixUnaryExpression): !!(name && isStringLiteral(name) && (name.singleQuote || !nodeIsSynthesized(name) && startsWith(getTextOfNode(name, /*includeTrivia* / false), "'"))) */ TODO
        }
        getPropertyNameNodeForSymbol := func(symbol Symbol, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").NumericLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName */ TODO {
            stringNamed := /* TODO(BinaryExpression): !!length(symbol.declarations) && every(symbol.declarations, isStringNamed) */ TODO
            singleQuote := /* TODO(BinaryExpression): !!length(symbol.declarations) && every(symbol.declarations, isSingleQuotedStringNamed) */ TODO
            isMethod := /* TODO(PrefixUnaryExpression): !!(symbol.flags & SymbolFlags.Method) */ TODO
            fromNameType := getPropertyNameNodeForSymbolFromNameType(symbol, context, singleQuote, stringNamed, isMethod)
            if fromNameType {
                 fromNameType
            }
            rawName := unescapeLeadingUnderscores(/* TODO(PropertyAccessExpression): symbol.escapedName */ TODO)
             createPropertyNameNodeForIdentifierOrLiteral(rawName, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod)
        }
        getPropertyNameNodeForSymbolFromNameType := func(symbol Symbol, context NodeBuilderContext, singleQuote bool, stringNamed bool, isMethod bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").NumericLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName | undefined */ TODO {
            nameType := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).nameType */ TODO
            if nameType {
                if /* TODO(BinaryExpression): nameType.flags & TypeFlags.StringOrNumberLiteral */ TODO {
                    name := /* TODO(BinaryExpression): "" + (nameType as StringLiteralType | NumberLiteralType).value */ TODO
                    if /* TODO(BinaryExpression): !isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && (stringNamed || !isNumericLiteralName(name)) */ TODO {
                         /* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(name, /* TODO(PrefixUnaryExpression): !!singleQuote */ TODO)
                    }
                    if /* TODO(BinaryExpression): isNumericLiteralName(name) && startsWith(name, "-") */ TODO {
                         /* TODO(PropertyAccessExpression): factory.createComputedPropertyName */ TODO(/* TODO(PropertyAccessExpression): factory.createPrefixUnaryExpression */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.MinusToken */ TODO, /* TODO(PropertyAccessExpression): factory.createNumericLiteral */ TODO(/* TODO(PrefixUnaryExpression): -name */ TODO)))
                    }
                     createPropertyNameNodeForIdentifierOrLiteral(name, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod)
                }
                if /* TODO(BinaryExpression): nameType.flags & TypeFlags.UniqueESSymbol */ TODO {
                     /* TODO(PropertyAccessExpression): factory.createComputedPropertyName */ TODO(symbolToExpression(/* TODO(PropertyAccessExpression): (nameType as UniqueESSymbolType).symbol */ TODO, context, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO))
                }
            }
        }
        cloneNodeBuilderContext := func(context NodeBuilderContext) /* TODO(undefined): () => void */ TODO {
            oldMustCreateTypeParameterSymbolList := /* TODO(PropertyAccessExpression): context.mustCreateTypeParameterSymbolList */ TODO
            oldMustCreateTypeParametersNamesLookups := /* TODO(PropertyAccessExpression): context.mustCreateTypeParametersNamesLookups */ TODO
            /* TODO(ExpressionStatement): context.mustCreateTypeParameterSymbolList = true; */
            /* TODO(ExpressionStatement): context.mustCreateTypeParametersNamesLookups = true; */
            oldTypeParameterNames := /* TODO(PropertyAccessExpression): context.typeParameterNames */ TODO
            oldTypeParameterNamesByText := /* TODO(PropertyAccessExpression): context.typeParameterNamesByText */ TODO
            oldTypeParameterNamesByTextNextNameCount := /* TODO(PropertyAccessExpression): context.typeParameterNamesByTextNextNameCount */ TODO
            oldTypeParameterSymbolList := /* TODO(PropertyAccessExpression): context.typeParameterSymbolList */ TODO
             /* TODO(ArrowFunction): () => {                 context.typeParameterNames = oldTypeParameterNames;                 context.typeParameterNamesByText = oldTypeParameterNamesByText;                 context.typeParameterNamesByTextNextNameCount = oldTypeParameterNamesByTextNextNameCount;                 context.typeParameterSymbolList = oldTypeParameterSymbolList;                 context.mustCreateTypeParameterSymbolList = oldMustCreateTypeParameterSymbolList;                 context.mustCreateTypeParametersNamesLookups = oldMustCreateTypeParametersNamesLookups;             } */ TODO
        }
        getDeclarationWithTypeAnnotation := func(symbol Symbol, enclosingDeclaration Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration | undefined */ TODO {
             /* TODO(BinaryExpression): symbol.declarations && find(symbol.declarations, s => !!getNonlocalEffectiveTypeAnnotationNode(s) && (!enclosingDeclaration || !!findAncestor(s, n => n === enclosingDeclaration))) */ TODO
        }
        existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount := func(existing TypeNode, type_ Type) /* TODO(undefined): boolean */ TODO {
            if /* TODO(PrefixUnaryExpression): !(getObjectFlags(type) & ObjectFlags.Reference) */ TODO {
                /* TODO(TrueKeyword): true */
            }
            if /* TODO(PrefixUnaryExpression): !isTypeReferenceNode(existing) */ TODO {
                /* TODO(TrueKeyword): true */
            }
            /* TODO(ExpressionStatement): void getTypeFromTypeReference(existing); */
            symbol := /* TODO(PropertyAccessExpression): getNodeLinks(existing).resolvedSymbol */ TODO
            existingTarget := /* TODO(BinaryExpression): symbol && getDeclaredTypeOfSymbol(symbol) */ TODO
            if /* TODO(BinaryExpression): !existingTarget || existingTarget !== (type as TypeReference).target */ TODO {
                /* TODO(TrueKeyword): true */
            }
             /* TODO(BinaryExpression): length(existing.typeArguments) >= getMinTypeArgumentCount((type as TypeReference).target.typeParameters) */ TODO
        }
        getEnclosingDeclarationIgnoringFakeScope := func(enclosingDeclaration Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO {
            /* TODO(WhileStatement): while (getNodeLinks(enclosingDeclaration).fakeScopeForSignatureDeclaration) {                 enclosingDeclaration = enclosingDeclaration.parent;             } */
             enclosingDeclaration
        }
        serializeTypeForDeclaration := func(context NodeBuilderContext, declaration Declaration, type_ Type, symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
            addUndefinedForParameter := /* TODO(BinaryExpression): declaration && (isParameter(declaration) || isJSDocParameterTag(declaration)) && requiresAddingImplicitUndefined(declaration, context.enclosingDeclaration) */ TODO
            enclosingDeclaration := /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO
            restoreFlags := saveRestoreFlags(context)
            if /* TODO(BinaryExpression): declaration && hasInferredType(declaration) && !(context.internalFlags & InternalNodeBuilderFlags.NoSyntacticPrinter) */ TODO {
                /* TODO(ExpressionStatement): syntacticNodeBuilder.serializeTypeOfDeclaration(declaration, context); */
            }
            /* TODO(ExpressionStatement): context.internalFlags |= InternalNodeBuilderFlags.NoSyntacticPrinter; */
            if /* TODO(BinaryExpression): enclosingDeclaration && (!isErrorType(type) || (context.internalFlags & InternalNodeBuilderFlags.AllowUnresolvedNames)) */ TODO {
                declWithExistingAnnotation := /* TODO(ConditionalExpression): declaration && getNonlocalEffectiveTypeAnnotationNode(declaration)                     ? declaration                     : getDeclarationWithTypeAnnotation(symbol) */ TODO
                if /* TODO(BinaryExpression): declWithExistingAnnotation && !isFunctionLikeDeclaration(declWithExistingAnnotation) && !isGetAccessorDeclaration(declWithExistingAnnotation) */ TODO {
                    existing := /* TODO(NonNullExpression): getNonlocalEffectiveTypeAnnotationNode(declWithExistingAnnotation)! */ TODO
                    addUndefined := /* TODO(BinaryExpression): addUndefinedForParameter || !!(symbol.flags & SymbolFlags.Property && symbol.flags & SymbolFlags.Optional && isOptionalDeclaration(declWithExistingAnnotation) && (symbol as MappedSymbol).links?.mappedType && containsNonMissingUndefinedType(type)) */ TODO
                    result := /* TODO(BinaryExpression): !isTypePredicateNode(existing) && tryReuseExistingTypeNode(context, existing, type, declWithExistingAnnotation, addUndefined) */ TODO
                    if result {
                        /* TODO(ExpressionStatement): restoreFlags(); */
                         result
                    }
                }
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.UniqueESSymbol &&                 type.symbol === symbol && (!context.enclosingDeclaration || some(symbol.declarations, d => getSourceFileOfNode(d) === getSourceFileOfNode(context.enclosingDeclaration!))) */ TODO {
                /* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.AllowUniqueESSymbolType; */
            }
            decl := /* TODO(BinaryExpression): declaration ?? symbol.valueDeclaration ?? symbol.declarations?.[0] */ TODO
            expr := /* TODO(ConditionalExpression): decl && isDeclarationWithPossibleInnerTypeNodeReuse(decl) ? getPossibleTypeNodeReuseExpression(decl) : undefined */ TODO
            result := expressionOrTypeToTypeNode(context, expr, type_, addUndefinedForParameter)
            /* TODO(ExpressionStatement): restoreFlags(); */
             result
        }
        typeNodeIsEquivalentToType := func(annotatedDeclaration Node, type_ Type, typeFromTypeNode Type) /* TODO(undefined): boolean */ TODO {
            if /* TODO(BinaryExpression): typeFromTypeNode === type */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            if /* TODO(BinaryExpression): annotatedDeclaration && (isParameter(annotatedDeclaration) || isPropertySignature(annotatedDeclaration) || isPropertyDeclaration(annotatedDeclaration)) && annotatedDeclaration.questionToken */ TODO {
                 /* TODO(BinaryExpression): getTypeWithFacts(type, TypeFacts.NEUndefined) === typeFromTypeNode */ TODO
            }
             /* TODO(FalseKeyword): false */ TODO
        }
        serializeReturnTypeForSignature := func(context NodeBuilderContext, signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
            suppressAny := /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.SuppressAnyReturnType */ TODO
            restoreFlags := saveRestoreFlags(context)
            if suppressAny {
                /* TODO(BinaryExpression): context.flags &= ~NodeBuilderFlags.SuppressAnyReturnType */
            }
            var returnTypeNode *TypeNode
            returnType := getReturnTypeOfSignature(signature)
            if /* TODO(BinaryExpression): returnType && !(suppressAny && isTypeAny(returnType)) */ TODO {
                if /* TODO(BinaryExpression): signature.declaration && !(context.internalFlags & InternalNodeBuilderFlags.NoSyntacticPrinter) */ TODO {
                    /* TODO(ExpressionStatement): syntacticNodeBuilder.serializeReturnTypeForSignature(signature.declaration, context); */
                }
                /* TODO(ExpressionStatement): context.internalFlags |= InternalNodeBuilderFlags.NoSyntacticPrinter; */
                /* TODO(ExpressionStatement): returnTypeNode = serializeReturnTypeForSignatureWorker(context, signature); */
            } else if /* TODO(PrefixUnaryExpression): !suppressAny */ TODO {
                /* TODO(ExpressionStatement): returnTypeNode = factory.createKeywordTypeNode(SyntaxKind.AnyKeyword); */
            }
            /* TODO(ExpressionStatement): restoreFlags(); */
             returnTypeNode
        }
        serializeReturnTypeForSignatureWorker := func(context NodeBuilderContext, signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
            typePredicate := getTypePredicateOfSignature(signature)
            type_ := getReturnTypeOfSignature(signature)
            if /* TODO(BinaryExpression): context.enclosingDeclaration && (!isErrorType(type) || (context.internalFlags & InternalNodeBuilderFlags.AllowUnresolvedNames)) && signature.declaration && !nodeIsSynthesized(signature.declaration) */ TODO {
                annotation := getNonlocalEffectiveReturnTypeAnnotationNode(/* TODO(PropertyAccessExpression): signature.declaration */ TODO)
                if annotation {
                    result := tryReuseExistingTypeNode(context, annotation, type_, /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO)
                    if result {
                         result
                    }
                }
            }
            if typePredicate {
                 typePredicateToTypePredicateNodeHelper(typePredicate, context)
            }
            expr := /* TODO(BinaryExpression): signature.declaration && getPossibleTypeNodeReuseExpression(signature.declaration) */ TODO
             expressionOrTypeToTypeNode(context, expr, type_)
        }
        trackExistingEntityName := func(node T, context NodeBuilderContext) /* TODO(undefined): { introducesError: boolean; node: T; sym?: undefined; } | { introducesError: boolean; node: T; sym: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined; } */ TODO {
            introducesError := /* TODO(FalseKeyword): false */ TODO
            leftmost := getFirstIdentifier(node)
            if /* TODO(BinaryExpression): isInJSFile(node) && (isExportsIdentifier(leftmost) || isModuleExportsAccessExpression(leftmost.parent) || (isQualifiedName(leftmost.parent) && isModuleIdentifier(leftmost.parent.left) && isExportsIdentifier(leftmost.parent.right))) */ TODO {
                /* TODO(ExpressionStatement): introducesError = true; */
                 /* TODO(ObjectLiteralExpression): { introducesError, node } */ TODO
            }
            meaning := getMeaningOfEntityNameReference(node)
            var sym *Symbol
            if isThisIdentifier(leftmost) {
                /* TODO(ExpressionStatement): sym = getSymbolOfDeclaration(getThisContainer(leftmost, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false)); */
                if /* TODO(BinaryExpression): isSymbolAccessible(sym, leftmost, meaning, /*shouldComputeAliasesToMakeVisible* / false).accessibility !== SymbolAccessibility.Accessible */ TODO {
                    /* TODO(ExpressionStatement): introducesError = true; */
                    /* TODO(ExpressionStatement): context.tracker.reportInaccessibleThisError(); */
                }
                 /* TODO(ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
            }
            /* TODO(ExpressionStatement): sym = resolveEntityName(leftmost, meaning, /*ignoreErrors* / true, /*dontResolveAlias* / true); */
            if /* TODO(BinaryExpression): context.enclosingDeclaration &&                 !(sym && sym.flags & SymbolFlags.TypeParameter) */ TODO {
                /* TODO(ExpressionStatement): sym = getExportSymbolOfValueSymbolIfExported(sym); */
                symAtLocation := resolveEntityName(leftmost, meaning, /* TODO(TrueKeyword): true */ TODO, /* TODO(TrueKeyword): true */ TODO, /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO)
                if /* TODO(BinaryExpression): symAtLocation === unknownSymbol ||                     // If the symbol is not found, but was not found in the original scope either we probably have an error, don't reuse the node                     (symAtLocation === undefined && sym !== undefined) ||                     // If the symbol is found both in declaration scope and in current scope then it shoudl point to the same reference                     (symAtLocation && sym && !getSymbolIfSameReference(getExportSymbolOfValueSymbolIfExported(symAtLocation), sym)) */ TODO {
                    if /* TODO(BinaryExpression): symAtLocation !== unknownSymbol */ TODO {
                        /* TODO(ExpressionStatement): context.tracker.reportInferenceFallback(node); */
                    }
                    /* TODO(ExpressionStatement): introducesError = true; */
                     /* TODO(ObjectLiteralExpression): { introducesError, node, sym } */ TODO
                } else {
                    /* TODO(ExpressionStatement): sym = symAtLocation; */
                }
            }
            if sym {
                if /* TODO(BinaryExpression): sym.flags & SymbolFlags.FunctionScopedVariable                     && sym.valueDeclaration */ TODO {
                    if /* TODO(BinaryExpression): isPartOfParameterDeclaration(sym.valueDeclaration) || isJSDocParameterTag(sym.valueDeclaration) */ TODO {
                         /* TODO(ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
                    }
                }
                if /* TODO(BinaryExpression): !(sym.flags & SymbolFlags.TypeParameter) && // Type parameters are visible in the current context if they are are resolvable                     !isDeclarationName(node) &&                     isSymbolAccessible(sym, context.enclosingDeclaration, meaning, /*shouldComputeAliasesToMakeVisible* / false).accessibility !== SymbolAccessibility.Accessible */ TODO {
                    /* TODO(ExpressionStatement): context.tracker.reportInferenceFallback(node); */
                    /* TODO(ExpressionStatement): introducesError = true; */
                } else {
                    /* TODO(ExpressionStatement): context.tracker.trackSymbol(sym, context.enclosingDeclaration, meaning); */
                }
                 /* TODO(ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
            }
             /* TODO(ObjectLiteralExpression): { introducesError, node } */ TODO
            attachSymbolToLeftmostIdentifier := func(node Node) Node {
                if /* TODO(BinaryExpression): node === leftmost */ TODO {
                    type_ := getDeclaredTypeOfSymbol(/* TODO(NonNullExpression): sym! */ TODO)
                    name := /* TODO(ConditionalExpression): sym!.flags & SymbolFlags.TypeParameter ? typeParameterToName(type, context) : factory.cloneNode(node as Identifier) */ TODO
                    /* TODO(ExpressionStatement): name.symbol = sym!; */
                     setTextRange(context, setEmitFlags(name, /* TODO(PropertyAccessExpression): EmitFlags.NoAsciiEscaping */ TODO), node)
                }
                updated := visitEachChildWorker(node, /* TODO(ArrowFunction): c => attachSymbolToLeftmostIdentifier(c) */ TODO, undefined)
                if /* TODO(BinaryExpression): updated !== node */ TODO {
                    /* TODO(ExpressionStatement): setTextRange(context, updated, node); */
                }
                 updated
            }
        }
        serializeTypeName := func(context NodeBuilderContext, node EntityName, isTypeOf bool, typeArguments []TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
            meaning := /* TODO(ConditionalExpression): isTypeOf ? SymbolFlags.Value : SymbolFlags.Type */ TODO
            symbol := resolveEntityName(node, meaning, /* TODO(TrueKeyword): true */ TODO)
            if /* TODO(PrefixUnaryExpression): !symbol */ TODO {
                /* TODO(Identifier): undefined */
            }
            resolvedSymbol := /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol */ TODO
            if /* TODO(BinaryExpression): isSymbolAccessible(symbol, context.enclosingDeclaration, meaning, /*shouldComputeAliasesToMakeVisible* / false).accessibility !== SymbolAccessibility.Accessible */ TODO {
                /* TODO(Identifier): undefined */
            }
             symbolToTypeNode(resolvedSymbol, context, meaning, typeArguments)
        }
        canReuseTypeNode := func(context NodeBuilderContext, existing TypeNode) /* TODO(undefined): number | boolean */ TODO {
            if isInJSFile(existing) {
                if isLiteralImportTypeNode(existing) {
                    /* TODO(ExpressionStatement): void getTypeFromImportTypeNode(existing); */
                    nodeSymbol := /* TODO(PropertyAccessExpression): getNodeLinks(existing).resolvedSymbol */ TODO
                     /* TODO(ParenthesizedExpression): (                         !nodeSymbol ||                         !(                             // The import type resolved using jsdoc fallback logic                             (!existing.isTypeOf && !(nodeSymbol.flags & SymbolFlags.Type)) ||                             // The import type had type arguments autofilled by js fallback logic                             !(length(existing.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))                         )                     ) */ TODO
                }
            }
            if isThisTypeNode(existing) {
                if /* TODO(BinaryExpression): context.mapper === undefined */ TODO {
                    /* TODO(TrueKeyword): true */
                }
                type_ := getTypeFromTypeNode(context, existing, /* TODO(TrueKeyword): true */ TODO)
                 /* TODO(PrefixUnaryExpression): !!type */ TODO
            }
            if isTypeReferenceNode(existing) {
                if isConstTypeReference(existing) {
                    /* TODO(FalseKeyword): false */
                }
                type_ := getTypeFromTypeReference(existing)
                symbol := /* TODO(PropertyAccessExpression): getNodeLinks(existing).resolvedSymbol */ TODO
                if /* TODO(PrefixUnaryExpression): !symbol */ TODO {
                    /* TODO(FalseKeyword): false */
                }
                if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeParameter */ TODO {
                    type_ := getDeclaredTypeOfSymbol(symbol)
                    if /* TODO(BinaryExpression): context.mapper && getMappedType(type, context.mapper) !== type */ TODO {
                         /* TODO(FalseKeyword): false */ TODO
                    }
                }
                if isInJSDoc(existing) {
                     /* TODO(BinaryExpression): existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type)                         && !getIntendedTypeFromJSDocTypeReference(existing) // We should probably allow the reuse of JSDoc reference types such as String Number etc                         && (symbol.flags & SymbolFlags.Type) */ TODO
                }
            }
            if /* TODO(BinaryExpression): isTypeOperatorNode(existing) &&                 existing.operator === SyntaxKind.UniqueKeyword &&                 existing.type.kind === SyntaxKind.SymbolKeyword */ TODO {
                effectiveEnclosingContext := /* TODO(BinaryExpression): context.enclosingDeclaration && getEnclosingDeclarationIgnoringFakeScope(context.enclosingDeclaration) */ TODO
                 /* TODO(PrefixUnaryExpression): !!findAncestor(existing, n => n === effectiveEnclosingContext) */ TODO
            }
             /* TODO(TrueKeyword): true */ TODO
        }
        serializeExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
            type_ := getTypeFromTypeNode(context, typeNode)
             typeToTypeNodeHelper(type_, context)
        }
        tryReuseExistingTypeNodeHelper := func(context NodeBuilderContext, existing TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
            if /* TODO(BinaryExpression): cancellationToken && cancellationToken.throwIfCancellationRequested */ TODO {
                /* TODO(ExpressionStatement): cancellationToken.throwIfCancellationRequested(); */
            }
            hadError := /* TODO(FalseKeyword): false */ TODO
            TODO_IDENTIFIER := createRecoveryBoundary()
            transformed := visitNode(existing, visitExistingNodeTreeSymbols, isTypeNode)
            if /* TODO(PrefixUnaryExpression): !finalizeBoundary() */ TODO {
                 undefined
            }
            /* TODO(ExpressionStatement): context.approximateLength += existing.end - existing.pos; */
             transformed
            visitExistingNodeTreeSymbols := func(node Node) Node {
                if hadError {
                    /* TODO(Identifier): node */
                }
                recover := startRecoveryScope()
                onExitNewScope := /* TODO(ConditionalExpression): isNewScopeNode(node) ? onEnterNewScope(node) : undefined */ TODO
                result := visitExistingNodeTreeSymbolsWorker(node)
                /* TODO(ExpressionStatement): onExitNewScope?.(); */
                if hadError {
                    if /* TODO(BinaryExpression): isTypeNode(node) && !isTypePredicateNode(node) */ TODO {
                        /* TODO(ExpressionStatement): recover(); */
                         serializeExistingTypeNode(context, node)
                    }
                     node
                }
                 /* TODO(ConditionalExpression): result ? setTextRange(context, result, node) : undefined */ TODO
            }
            createRecoveryBoundary := func() /* TODO(undefined): { startRecoveryScope: () => () => void; finalizeBoundary: () => boolean; } */ TODO {
                var trackedSymbols []TrackedSymbol
                var unreportedErrors []func() 
                oldTracker := /* TODO(PropertyAccessExpression): context.tracker */ TODO
                oldTrackedSymbols := /* TODO(PropertyAccessExpression): context.trackedSymbols */ TODO
                /* TODO(ExpressionStatement): context.trackedSymbols = undefined; */
                oldEncounteredError := /* TODO(PropertyAccessExpression): context.encounteredError */ TODO
                /* TODO(ExpressionStatement): context.tracker = new SymbolTrackerImpl(context, {                     ...oldTracker.inner,                     reportCyclicStructureError() {                         markError(() => oldTracker.reportCyclicStructureError());                     },                     reportInaccessibleThisError() {                         markError(() => oldTracker.reportInaccessibleThisError());                     },                     reportInaccessibleUniqueSymbolError() {                         markError(() => oldTracker.reportInaccessibleUniqueSymbolError());                     },                     reportLikelyUnsafeImportRequiredError(specifier) {                         markError(() => oldTracker.reportLikelyUnsafeImportRequiredError(specifier));                     },                     reportNonSerializableProperty(name) {                         markError(() => oldTracker.reportNonSerializableProperty(name));                     },                     trackSymbol(sym, decl, meaning) {                         (trackedSymbols ??= []).push([sym, decl, meaning]);                         return false;                     },                     moduleResolverHost: context.tracker.moduleResolverHost,                 }, context.tracker.moduleResolverHost); */
                 /* TODO(ObjectLiteralExpression): {                     startRecoveryScope,                     finalizeBoundary,                 } */ TODO
                markError := func(unreportedError func() ) {
                    /* TODO(ExpressionStatement): hadError = true; */
                    /* TODO(ExpressionStatement): (unreportedErrors ??= []).push(unreportedError); */
                }
                startRecoveryScope := func() /* TODO(undefined): () => void */ TODO {
                    trackedSymbolsTop := /* TODO(BinaryExpression): trackedSymbols?.length ?? 0 */ TODO
                    unreportedErrorsTop := /* TODO(BinaryExpression): unreportedErrors?.length ?? 0 */ TODO
                     /* TODO(ArrowFunction): () => {                         hadError = false;                         // Reset the tracked symbols to before the error                         if (trackedSymbols) {                             trackedSymbols.length = trackedSymbolsTop;                         }                         if (unreportedErrors) {                             unreportedErrors.length = unreportedErrorsTop;                         }                     } */ TODO
                }
                finalizeBoundary := func() /* TODO(undefined): boolean */ TODO {
                    /* TODO(ExpressionStatement): context.tracker = oldTracker; */
                    /* TODO(ExpressionStatement): context.trackedSymbols = oldTrackedSymbols; */
                    /* TODO(ExpressionStatement): context.encounteredError = oldEncounteredError; */
                    /* TODO(ExpressionStatement): unreportedErrors?.forEach(fn => fn()); */
                    if hadError {
                         /* TODO(FalseKeyword): false */ TODO
                    }
                    /* TODO(ExpressionStatement): trackedSymbols?.forEach(                         ([symbol, enclosingDeclaration, meaning]) =>                             context.tracker.trackSymbol(                                 symbol,                                 enclosingDeclaration,                                 meaning,                             ),                     ); */
                     /* TODO(TrueKeyword): true */ TODO
                }
            }
            onEnterNewScope := func(node /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO(undefined): () => void */ TODO {
                 enterNewScope(context, node, getParametersInScope(node), getTypeParametersInScope(node))
            }
            tryVisitSimpleTypeNode := func(node TypeNode) *TypeNode {
                innerNode := skipTypeParentheses(node)
                /* TODO(SwitchStatement): switch (innerNode.kind) {                     case SyntaxKind.TypeReference:                         return tryVisitTypeReference(innerNode as TypeReferenceNode);                     case SyntaxKind.TypeQuery:                         return tryVisitTypeQuery(innerNode as TypeQueryNode);                     case SyntaxKind.IndexedAccessType:                         return tryVisitIndexedAccess(innerNode as IndexedAccessTypeNode);                     case SyntaxKind.TypeOperator:                         const typeOperatorNode = innerNode as TypeOperatorNode;                         if (typeOperatorNode.operator === SyntaxKind.KeyOfKeyword) {                             return tryVisitKeyOf(typeOperatorNode);                         }                 } */
                 visitNode(node, visitExistingNodeTreeSymbols, isTypeNode)
            }
            tryVisitIndexedAccess := func(node IndexedAccessTypeNode) *TypeNode {
                resultObjectType := tryVisitSimpleTypeNode(/* TODO(PropertyAccessExpression): node.objectType */ TODO)
                if /* TODO(BinaryExpression): resultObjectType === undefined */ TODO {
                     undefined
                }
                 /* TODO(PropertyAccessExpression): factory.updateIndexedAccessTypeNode */ TODO(node, resultObjectType, /* TODO(NonNullExpression): visitNode(node.indexType, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO)
            }
            tryVisitKeyOf := func(node TypeOperatorNode) *TypeNode {
                /* TODO(ExpressionStatement): Debug.assertEqual(node.operator, SyntaxKind.KeyOfKeyword); */
                type_ := tryVisitSimpleTypeNode(/* TODO(PropertyAccessExpression): node.type */ TODO)
                if /* TODO(BinaryExpression): type === undefined */ TODO {
                     undefined
                }
                 /* TODO(PropertyAccessExpression): factory.updateTypeOperatorNode */ TODO(node, type_)
            }
            tryVisitTypeQuery := func(node TypeQueryNode) *TypeNode {
                TODO_IDENTIFIER := trackExistingEntityName(/* TODO(PropertyAccessExpression): node.exprName */ TODO, context)
                if /* TODO(PrefixUnaryExpression): !introducesError */ TODO {
                     /* TODO(PropertyAccessExpression): factory.updateTypeQueryNode */ TODO(node, exprName, visitNodes(/* TODO(PropertyAccessExpression): node.typeArguments */ TODO, visitExistingNodeTreeSymbols, isTypeNode))
                }
                serializedName := serializeTypeName(context, /* TODO(PropertyAccessExpression): node.exprName */ TODO, /* TODO(TrueKeyword): true */ TODO)
                if serializedName {
                     setTextRange(context, serializedName, /* TODO(PropertyAccessExpression): node.exprName */ TODO)
                }
            }
            tryVisitTypeReference := func(node TypeReferenceNode) *TypeNode {
                if canReuseTypeNode(context, node) {
                    TODO_IDENTIFIER := trackExistingEntityName(/* TODO(PropertyAccessExpression): node.typeName */ TODO, context)
                    typeArguments := visitNodes(/* TODO(PropertyAccessExpression): node.typeArguments */ TODO, visitExistingNodeTreeSymbols, isTypeNode)
                    if /* TODO(PrefixUnaryExpression): !introducesError */ TODO {
                        updated := /* TODO(PropertyAccessExpression): factory.updateTypeReferenceNode */ TODO(node, newName, typeArguments)
                         setTextRange(context, updated, node)
                    } else {
                        serializedName := serializeTypeName(context, /* TODO(PropertyAccessExpression): node.typeName */ TODO, /* TODO(FalseKeyword): false */ TODO, typeArguments)
                        if serializedName {
                             setTextRange(context, serializedName, /* TODO(PropertyAccessExpression): node.typeName */ TODO)
                        }
                    }
                }
            }
            visitExistingNodeTreeSymbolsWorker := func(node Node) Node {
                if isJSDocTypeExpression(node) {
                     visitNode(/* TODO(PropertyAccessExpression): node.type */ TODO, visitExistingNodeTreeSymbols, isTypeNode)
                }
                if /* TODO(BinaryExpression): isJSDocAllType(node) || node.kind === SyntaxKind.JSDocNamepathType */ TODO {
                     /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO)
                }
                if isJSDocUnknownType(node) {
                     /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.UnknownKeyword */ TODO)
                }
                if isJSDocNullableType(node) {
                     /* TODO(PropertyAccessExpression): factory.createUnionTypeNode */ TODO(/* TODO(ArrayLiteralExpression): [visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)!, factory.createLiteralTypeNode(factory.createNull())] */ TODO)
                }
                if isJSDocOptionalType(node) {
                     /* TODO(PropertyAccessExpression): factory.createUnionTypeNode */ TODO(/* TODO(ArrayLiteralExpression): [visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)!, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)] */ TODO)
                }
                if isJSDocNonNullableType(node) {
                     visitNode(/* TODO(PropertyAccessExpression): node.type */ TODO, visitExistingNodeTreeSymbols)
                }
                if isJSDocVariadicType(node) {
                     /* TODO(PropertyAccessExpression): factory.createArrayTypeNode */ TODO(/* TODO(NonNullExpression): visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO)
                }
                if isJSDocTypeLiteral(node) {
                     /* TODO(PropertyAccessExpression): factory.createTypeLiteralNode */ TODO(map_(/* TODO(PropertyAccessExpression): node.jsDocPropertyTags */ TODO, /* TODO(ArrowFunction): t => {                         const name = visitNode(isIdentifier(t.name) ? t.name : t.name.right, visitExistingNodeTreeSymbols, isIdentifier)!;                         const typeViaParent = getTypeOfPropertyOfType(getTypeFromTypeNode(context, node), name.escapedText);                         const overrideTypeNode = typeViaParent && t.typeExpression && getTypeFromTypeNode(context, t.typeExpression.type) !== typeViaParent ? typeToTypeNodeHelper(typeViaParent, context) : undefined;                          return factory.createPropertySignature(                             /*modifiers* / undefined,                             name,                             t.isBracketed || t.typeExpression && isJSDocOptionalType(t.typeExpression.type) ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                             overrideTypeNode || (t.typeExpression && visitNode(t.typeExpression.type, visitExistingNodeTreeSymbols, isTypeNode)) || factory.createKeywordTypeNode(SyntaxKind.AnyKeyword),                         );                     } */ TODO))
                }
                if /* TODO(BinaryExpression): isTypeReferenceNode(node) && isIdentifier(node.typeName) && node.typeName.escapedText === "" */ TODO {
                     setOriginalNode(/* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO), node)
                }
                if /* TODO(BinaryExpression): (isExpressionWithTypeArguments(node) || isTypeReferenceNode(node)) && isJSDocIndexSignature(node) */ TODO {
                     /* TODO(PropertyAccessExpression): factory.createTypeLiteralNode */ TODO(/* TODO(ArrayLiteralExpression): [factory.createIndexSignature(                         /*modifiers* / undefined,                         [factory.createParameterDeclaration(                             /*modifiers* / undefined,                             /*dotDotDotToken* / undefined,                             "x",                             /*questionToken* / undefined,                             visitNode(node.typeArguments![0], visitExistingNodeTreeSymbols, isTypeNode),                         )],                         visitNode(node.typeArguments![1], visitExistingNodeTreeSymbols, isTypeNode),                     )] */ TODO)
                }
                if isJSDocFunctionType(node) {
                    if isJSDocConstructSignature(node) {
                        var newTypeNode *TypeNode
                         /* TODO(PropertyAccessExpression): factory.createConstructorTypeNode */ TODO(undefined, visitNodes(/* TODO(PropertyAccessExpression): node.typeParameters */ TODO, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), mapDefined(/* TODO(PropertyAccessExpression): node.parameters */ TODO, /* TODO(ArrowFunction): (p, i) =>                                 p.name && isIdentifier(p.name) && p.name.escapedText === "new" ? (newTypeNode = p.type, undefined) : factory.createParameterDeclaration(                                     /*modifiers* / undefined,                                     getEffectiveDotDotDotForParameter(p),                                     setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p),                                     factory.cloneNode(p.questionToken),                                     visitNode(p.type, visitExistingNodeTreeSymbols, isTypeNode),                                     /*initializer* / undefined,                                 ) */ TODO), /* TODO(BinaryExpression): visitNode(newTypeNode || node.type, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKind.AnyKeyword) */ TODO)
                    } else {
                         /* TODO(PropertyAccessExpression): factory.createFunctionTypeNode */ TODO(visitNodes(/* TODO(PropertyAccessExpression): node.typeParameters */ TODO, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), map_(/* TODO(PropertyAccessExpression): node.parameters */ TODO, /* TODO(ArrowFunction): (p, i) =>                                 factory.createParameterDeclaration(                                     /*modifiers* / undefined,                                     getEffectiveDotDotDotForParameter(p),                                     setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p),                                     factory.cloneNode(p.questionToken),                                     visitNode(p.type, visitExistingNodeTreeSymbols, isTypeNode),                                     /*initializer* / undefined,                                 ) */ TODO), /* TODO(BinaryExpression): visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKind.AnyKeyword) */ TODO)
                    }
                }
                if isThisTypeNode(node) {
                    if canReuseTypeNode(context, node) {
                         node
                    }
                    /* TODO(ExpressionStatement): hadError = true; */
                     node
                }
                if isTypeParameterDeclaration(node) {
                     /* TODO(PropertyAccessExpression): factory.updateTypeParameterDeclaration */ TODO(node, visitNodes(/* TODO(PropertyAccessExpression): node.modifiers */ TODO, visitExistingNodeTreeSymbols, isModifier), setTextRange(context, typeParameterToName(getDeclaredTypeOfSymbol(getSymbolOfDeclaration(node)), context), node), visitNode(/* TODO(PropertyAccessExpression): node.constraint */ TODO, visitExistingNodeTreeSymbols, isTypeNode), visitNode(/* TODO(PropertyAccessExpression): node.default */ TODO, visitExistingNodeTreeSymbols, isTypeNode))
                }
                if isIndexedAccessTypeNode(node) {
                    result := tryVisitIndexedAccess(node)
                    if /* TODO(PrefixUnaryExpression): !result */ TODO {
                        /* TODO(ExpressionStatement): hadError = true; */
                         node
                    }
                     result
                }
                if isTypeReferenceNode(node) {
                    result := tryVisitTypeReference(node)
                    if result {
                         result
                    }
                    /* TODO(ExpressionStatement): hadError = true; */
                     node
                }
                if isLiteralImportTypeNode(node) {
                    nodeSymbol := /* TODO(PropertyAccessExpression): getNodeLinks(node).resolvedSymbol */ TODO
                    if /* TODO(BinaryExpression): isInJSDoc(node) &&                         nodeSymbol &&                         (                             // The import type resolved using jsdoc fallback logic                             (!node.isTypeOf && !(nodeSymbol.flags & SymbolFlags.Type)) ||                             // The import type had type arguments autofilled by js fallback logic                             !(length(node.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))                         ) */ TODO {
                         setTextRange(context, typeToTypeNodeHelper(getTypeFromTypeNode(context, node), context), node)
                    }
                     /* TODO(PropertyAccessExpression): factory.updateImportTypeNode */ TODO(node, /* TODO(PropertyAccessExpression): factory.updateLiteralTypeNode */ TODO(/* TODO(PropertyAccessExpression): node.argument */ TODO, rewriteModuleSpecifier(node, /* TODO(PropertyAccessExpression): node.argument.literal */ TODO)), visitNode(/* TODO(PropertyAccessExpression): node.attributes */ TODO, visitExistingNodeTreeSymbols, isImportAttributes), visitNode(/* TODO(PropertyAccessExpression): node.qualifier */ TODO, visitExistingNodeTreeSymbols, isEntityName), visitNodes(/* TODO(PropertyAccessExpression): node.typeArguments */ TODO, visitExistingNodeTreeSymbols, isTypeNode), /* TODO(PropertyAccessExpression): node.isTypeOf */ TODO)
                }
                if /* TODO(BinaryExpression): isNamedDeclaration(node) && node.name.kind === SyntaxKind.ComputedPropertyName && !isLateBindableName(node.name) */ TODO {
                    if /* TODO(PrefixUnaryExpression): !hasDynamicName(node) */ TODO {
                         visitEachChild(node, visitExistingNodeTreeSymbols)
                    }
                    if /* TODO(PrefixUnaryExpression): !(context.internalFlags & InternalNodeBuilderFlags.AllowUnresolvedNames && isEntityNameExpression(node.name.expression) && checkComputedPropertyName(node.name).flags & TypeFlags.Any) */ TODO {
                         undefined
                    }
                }
                if /* TODO(BinaryExpression): (isFunctionLike(node) && !node.type)                     || (isPropertyDeclaration(node) && !node.type && !node.initializer)                     || (isPropertySignature(node) && !node.type && !node.initializer)                     || (isParameter(node) && !node.type && !node.initializer) */ TODO {
                    visited := visitEachChild(node, visitExistingNodeTreeSymbols)
                    if /* TODO(BinaryExpression): visited === node */ TODO {
                        /* TODO(ExpressionStatement): visited = setTextRange(context, factory.cloneNode(node), node); */
                    }
                    /* TODO(ExpressionStatement): (visited as Mutable<typeof visited>).type = factory.createKeywordTypeNode(SyntaxKind.AnyKeyword); */
                    if isParameter(node) {
                        /* TODO(ExpressionStatement): (visited as Mutable<ParameterDeclaration>).modifiers = undefined; */
                    }
                     visited
                }
                if isTypeQueryNode(node) {
                    result := tryVisitTypeQuery(node)
                    if /* TODO(PrefixUnaryExpression): !result */ TODO {
                        /* TODO(ExpressionStatement): hadError = true; */
                         node
                    }
                     result
                }
                if /* TODO(BinaryExpression): isComputedPropertyName(node) && isEntityNameExpression(node.expression) */ TODO {
                    TODO_IDENTIFIER := trackExistingEntityName(/* TODO(PropertyAccessExpression): node.expression */ TODO, context)
                    if /* TODO(PrefixUnaryExpression): !introducesError */ TODO {
                         /* TODO(PropertyAccessExpression): factory.updateComputedPropertyName */ TODO(node, result)
                    } else {
                        type_ := getWidenedType(getRegularTypeOfExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO))
                        computedPropertyNameType := typeToTypeNodeHelper(type_, context)
                        literal
                        if isLiteralTypeNode(computedPropertyNameType) {
                            /* TODO(ExpressionStatement): literal = computedPropertyNameType.literal; */
                        } else {
                            evaluated := evaluateEntityNameExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO)
                            literalNode := /* TODO(ConditionalExpression): typeof evaluated.value === "string" ? factory.createStringLiteral(evaluated.value, /*isSingleQuote* / undefined) :                                 typeof evaluated.value === "number" ? factory.createNumericLiteral(evaluated.value, /*numericLiteralFlags* / 0) :                                 undefined */ TODO
                            if /* TODO(PrefixUnaryExpression): !literalNode */ TODO {
                                if isImportTypeNode(computedPropertyNameType) {
                                    /* TODO(ExpressionStatement): trackComputedName(node.expression, context.enclosingDeclaration, context); */
                                }
                                 node
                            }
                            /* TODO(ExpressionStatement): literal = literalNode; */
                        }
                        if /* TODO(BinaryExpression): literal.kind === SyntaxKind.StringLiteral && isIdentifierText(literal.text, getEmitScriptTarget(compilerOptions)) */ TODO {
                             /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(/* TODO(PropertyAccessExpression): literal.text */ TODO)
                        }
                        if /* TODO(BinaryExpression): literal.kind === SyntaxKind.NumericLiteral && !literal.text.startsWith("-") */ TODO {
                             literal
                        }
                         /* TODO(PropertyAccessExpression): factory.updateComputedPropertyName */ TODO(node, literal)
                    }
                }
                if isTypePredicateNode(node) {
                    parameterName
                    if isIdentifier(/* TODO(PropertyAccessExpression): node.parameterName */ TODO) {
                        TODO_IDENTIFIER := trackExistingEntityName(/* TODO(PropertyAccessExpression): node.parameterName */ TODO, context)
                        /* TODO(ExpressionStatement): hadError = hadError || introducesError; */
                        /* TODO(ExpressionStatement): parameterName = result; */
                    } else {
                        /* TODO(ExpressionStatement): parameterName = factory.cloneNode(node.parameterName); */
                    }
                     /* TODO(PropertyAccessExpression): factory.updateTypePredicateNode */ TODO(node, /* TODO(PropertyAccessExpression): factory.cloneNode */ TODO(/* TODO(PropertyAccessExpression): node.assertsModifier */ TODO), parameterName, visitNode(/* TODO(PropertyAccessExpression): node.type */ TODO, visitExistingNodeTreeSymbols, isTypeNode))
                }
                if /* TODO(BinaryExpression): isTupleTypeNode(node) || isTypeLiteralNode(node) || isMappedTypeNode(node) */ TODO {
                    visited := visitEachChild(node, visitExistingNodeTreeSymbols)
                    clone := setTextRange(context, /* TODO(ConditionalExpression): visited === node ? factory.cloneNode(node) : visited */ TODO, node)
                    flags := getEmitFlags(clone)
                    /* TODO(ExpressionStatement): setEmitFlags(clone, flags | (context.flags & NodeBuilderFlags.MultilineObjectLiterals && isTypeLiteralNode(node) ? 0 : EmitFlags.SingleLine)); */
                     clone
                }
                if /* TODO(BinaryExpression): isStringLiteral(node) && !!(context.flags & NodeBuilderFlags.UseSingleQuotesForStringLiteralType) && !node.singleQuote */ TODO {
                    clone := /* TODO(PropertyAccessExpression): factory.cloneNode */ TODO(node)
                    /* TODO(ExpressionStatement): (clone as Mutable<typeof clone>).singleQuote = true; */
                     clone
                }
                if isConditionalTypeNode(node) {
                    checkType := /* TODO(NonNullExpression): visitNode(node.checkType, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO
                    disposeScope := onEnterNewScope(node)
                    extendType := /* TODO(NonNullExpression): visitNode(node.extendsType, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO
                    trueType := /* TODO(NonNullExpression): visitNode(node.trueType, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO
                    /* TODO(ExpressionStatement): disposeScope(); */
                    falseType := /* TODO(NonNullExpression): visitNode(node.falseType, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO
                     /* TODO(PropertyAccessExpression): factory.updateConditionalTypeNode */ TODO(node, checkType, extendType, trueType, falseType)
                }
                if isTypeOperatorNode(node) {
                    if /* TODO(BinaryExpression): node.operator === SyntaxKind.UniqueKeyword && node.type.kind === SyntaxKind.SymbolKeyword */ TODO {
                        if /* TODO(PrefixUnaryExpression): !canReuseTypeNode(context, node) */ TODO {
                            /* TODO(ExpressionStatement): hadError = true; */
                             node
                        }
                    } else if /* TODO(BinaryExpression): node.operator === SyntaxKind.KeyOfKeyword */ TODO {
                        result := tryVisitKeyOf(node)
                        if /* TODO(PrefixUnaryExpression): !result */ TODO {
                            /* TODO(ExpressionStatement): hadError = true; */
                             node
                        }
                         result
                    }
                }
                 visitEachChild(node, visitExistingNodeTreeSymbols)
                // OVERLOAD: visitEachChild := func(node T, visitor Visitor) T
                // OVERLOAD: visitEachChild := func(node *T, visitor Visitor) *T
                visitEachChild := func(node *T, visitor Visitor) *T {
                    nonlocalNode := /* TODO(BinaryExpression): !context.enclosingFile || context.enclosingFile !== getSourceFileOfNode(node) */ TODO
                     visitEachChildWorker(node, visitor, undefined, /* TODO(ConditionalExpression): nonlocalNode ? visitNodesWithoutCopyingPositions : undefined */ TODO)
                }
                visitNodesWithoutCopyingPositions := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
                    result := visitNodes(nodes, visitor, test, start, count)
                    if result {
                        if /* TODO(BinaryExpression): result.pos !== -1 || result.end !== -1 */ TODO {
                            if /* TODO(BinaryExpression): result === nodes */ TODO {
                                /* TODO(ExpressionStatement): result = factory.createNodeArray(nodes.slice(), nodes.hasTrailingComma); */
                            }
                            /* TODO(ExpressionStatement): setTextRangePosEnd(result, -1, -1); */
                        }
                    }
                     result
                }
                getEffectiveDotDotDotForParameter := func(p ParameterDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DotDotDotToken | undefined */ TODO {
                     /* TODO(BinaryExpression): p.dotDotDotToken || (p.type && isJSDocVariadicType(p.type) ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined) */ TODO
                }
                getNameForJSDocFunctionParameter := func(p ParameterDeclaration, index number) /* TODO(undefined): string */ TODO {
                     /* TODO(ConditionalExpression): p.name && isIdentifier(p.name) && p.name.escapedText === "this" ? "this"                         : getEffectiveDotDotDotForParameter(p) ? `args`                         : `arg${index}` */ TODO
                }
                rewriteModuleSpecifier := func(parent ImportTypeNode, lit StringLiteral) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral */ TODO {
                    if /* TODO(BinaryExpression): context.bundled || context.enclosingFile !== getSourceFileOfNode(lit) */ TODO {
                        name := /* TODO(PropertyAccessExpression): lit.text */ TODO
                        nodeSymbol := /* TODO(PropertyAccessExpression): getNodeLinks(node).resolvedSymbol */ TODO
                        meaning := /* TODO(ConditionalExpression): parent.isTypeOf ? SymbolFlags.Value : SymbolFlags.Type */ TODO
                        parentSymbol := /* TODO(BinaryExpression): nodeSymbol                             && isSymbolAccessible(nodeSymbol, context.enclosingDeclaration, meaning, /*shouldComputeAliasesToMakeVisible* / false).accessibility === SymbolAccessibility.Accessible                             && lookupSymbolChain(nodeSymbol, context, meaning, /*yieldModuleSymbol* / true)[0] */ TODO
                        if /* TODO(BinaryExpression): parentSymbol && isExternalModuleSymbol(parentSymbol) */ TODO {
                            /* TODO(ExpressionStatement): name = getSpecifierForModuleSymbol(parentSymbol, context); */
                        } else {
                            targetFile := getExternalModuleFileFromDeclaration(parent)
                            if targetFile {
                                /* TODO(ExpressionStatement): name = getSpecifierForModuleSymbol(targetFile.symbol, context); */
                            }
                        }
                        if /* TODO(PropertyAccessExpression): name.includes */ TODO("/node_modules/") {
                            /* TODO(ExpressionStatement): context.encounteredError = true; */
                            if /* TODO(PropertyAccessExpression): context.tracker.reportLikelyUnsafeImportRequiredError */ TODO {
                                /* TODO(ExpressionStatement): context.tracker.reportLikelyUnsafeImportRequiredError(name); */
                            }
                        }
                        if /* TODO(BinaryExpression): name !== lit.text */ TODO {
                             setOriginalNode(/* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(name), lit)
                        }
                    }
                     /* TODO(NonNullExpression): visitNode(lit, visitExistingNodeTreeSymbols, isStringLiteral)! */ TODO
                }
            }
        }
        symbolTableToDeclarationStatements := func(symbolTable SymbolTable, context NodeBuilderContext) []Statement {
            serializePropertySymbolForClass := makeSerializePropertySymbol(/* TODO(PropertyAccessExpression): factory.createPropertyDeclaration */ TODO, /* TODO(PropertyAccessExpression): SyntaxKind.MethodDeclaration */ TODO, /* TODO(TrueKeyword): true */ TODO)
            serializePropertySymbolForInterfaceWorker := makeSerializePropertySymbol(/* TODO(ArrowFunction): (mods, name, question, type) => factory.createPropertySignature(mods, name, question, type) */ TODO, /* TODO(PropertyAccessExpression): SyntaxKind.MethodSignature */ TODO, /* TODO(FalseKeyword): false */ TODO)
            enclosingDeclaration := /* TODO(NonNullExpression): context.enclosingDeclaration! */ TODO
            var results []Statement = /* TODO(ArrayLiteralExpression): [] */ TODO
            visitedSymbols := /* TODO(NewExpression): new Set<number>() */ TODO
            var deferredPrivatesStack []Map[SymbolId, Symbol] = /* TODO(ArrayLiteralExpression): [] */ TODO
            oldcontext := context
            /* TODO(ExpressionStatement): context = {                 ...oldcontext,                 usedSymbolNames: new Set(oldcontext.usedSymbolNames),                 remappedSymbolNames: new Map(),                 remappedSymbolReferences: new Map(oldcontext.remappedSymbolReferences?.entries()),                 tracker: undefined!,             }; */
            var tracker SymbolTracker = /* TODO(ObjectLiteralExpression): {                 ...oldcontext.tracker.inner,                 trackSymbol: (sym, decl, meaning) => {                     if (context.remappedSymbolNames?.has(getSymbolId(sym))) return false; // If the context has a remapped name for the symbol, it *should* mean it's been made visible                     const accessibleResult = isSymbolAccessible(sym, decl, meaning, /*shouldComputeAliasesToMakeVisible* / false);                     if (accessibleResult.accessibility === SymbolAccessibility.Accessible) {                         // Lookup the root symbol of the chain of refs we'll use to access it and serialize it                         const chain = lookupSymbolChainWorker(sym, context, meaning);                         if (!(sym.flags & SymbolFlags.Property)) {                             // Only include referenced privates in the same file. Weird JS aliases may expose privates                             // from other files - assume JS transforms will make those available via expected means                             const root = chain[0];                             const contextFile = getSourceFileOfNode(oldcontext.enclosingDeclaration);                             if (some(root.declarations, d => getSourceFileOfNode(d) === contextFile)) {                                 includePrivateSymbol(root);                             }                         }                     }                     else if (oldcontext.tracker.inner?.trackSymbol) {                         return oldcontext.tracker.inner.trackSymbol(sym, decl, meaning);                     }                     return false;                 },             } */ TODO
            /* TODO(ExpressionStatement): context.tracker = new SymbolTrackerImpl(context, tracker, oldcontext.tracker.moduleResolverHost); */
            /* TODO(ExpressionStatement): forEachEntry(symbolTable, (symbol, name) => {                 const baseName = unescapeLeadingUnderscores(name);                 void getInternalSymbolName(symbol, baseName); // Called to cache values into `usedSymbolNames` and `remappedSymbolNames`             }); */
            addingDeclare := /* TODO(PrefixUnaryExpression): !context.bundled */ TODO
            exportEquals := /* TODO(PropertyAccessExpression): symbolTable.get */ TODO(/* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO)
            if /* TODO(BinaryExpression): exportEquals && symbolTable.size > 1 && exportEquals.flags & (SymbolFlags.Alias | SymbolFlags.Module) */ TODO {
                /* TODO(ExpressionStatement): symbolTable = createSymbolTable(); */
                /* TODO(ExpressionStatement): symbolTable.set(InternalSymbolName.ExportEquals, exportEquals); */
            }
            /* TODO(ExpressionStatement): visitSymbolTable(symbolTable); */
             mergeRedundantStatements(results)
            isIdentifierAndNotUndefined := func(node Node) /* TODO(TypePredicate): node is Identifier */ TODO {
                 /* TODO(BinaryExpression): !!node && node.kind === SyntaxKind.Identifier */ TODO
            }
            getNamesOfDeclaration := func(statement Statement) []Identifier {
                if isVariableStatement(statement) {
                     filter(map_(/* TODO(PropertyAccessExpression): statement.declarationList.declarations */ TODO, getNameOfDeclaration), isIdentifierAndNotUndefined)
                }
                 filter(/* TODO(ArrayLiteralExpression): [getNameOfDeclaration(statement as DeclarationStatement)] */ TODO, isIdentifierAndNotUndefined)
            }
            flattenExportAssignedNamespace := func(statements []Statement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
                exportAssignment := find(statements, isExportAssignment)
                nsIndex := findIndex(statements, isModuleDeclaration)
                ns := /* TODO(ConditionalExpression): nsIndex !== -1 ? statements[nsIndex] as ModuleDeclaration : undefined */ TODO
                if /* TODO(BinaryExpression): ns && exportAssignment && exportAssignment.isExportEquals &&                     isIdentifier(exportAssignment.expression) && isIdentifier(ns.name) && idText(ns.name) === idText(exportAssignment.expression) &&                     ns.body && isModuleBlock(ns.body) */ TODO {
                    excessExports := filter(statements, /* TODO(ArrowFunction): s => !!(getEffectiveModifierFlags(s) & ModifierFlags.Export) */ TODO)
                    name := /* TODO(PropertyAccessExpression): ns.name */ TODO
                    body := /* TODO(PropertyAccessExpression): ns.body */ TODO
                    if length(excessExports) {
                        /* TODO(ExpressionStatement): ns = factory.updateModuleDeclaration(                             ns,                             ns.modifiers,                             ns.name,                             body = factory.updateModuleBlock(                                 body,                                 factory.createNodeArray([                                     ...ns.body.statements,                                     factory.createExportDeclaration(                                         /*modifiers* / undefined,                                         /*isTypeOnly* / false,                                         factory.createNamedExports(map(flatMap(excessExports, e => getNamesOfDeclaration(e)), id => factory.createExportSpecifier(/*isTypeOnly* / false, /*propertyName* / undefined, id))),                                         /*moduleSpecifier* / undefined,                                     ),                                 ]),                             ),                         ); */
                        /* TODO(ExpressionStatement): statements = [...statements.slice(0, nsIndex), ns, ...statements.slice(nsIndex + 1)]; */
                    }
                    if /* TODO(PrefixUnaryExpression): !find(statements, s => s !== ns && nodeHasName(s, name)) */ TODO {
                        /* TODO(ExpressionStatement): results = []; */
                        mixinExportFlag := /* TODO(PrefixUnaryExpression): !some(body.statements, s => hasSyntacticModifier(s, ModifierFlags.Export) || isExportAssignment(s) || isExportDeclaration(s)) */ TODO
                        /* TODO(ExpressionStatement): forEach(body.statements, s => {                             addResult(s, mixinExportFlag ? ModifierFlags.Export : ModifierFlags.None); // Recalculates the ambient (and export, if applicable from above) flag                         }); */
                        /* TODO(ExpressionStatement): statements = [...filter(statements, s => s !== ns && s !== exportAssignment), ...results]; */
                    }
                }
                 statements
            }
            mergeExportDeclarations := func(statements []Statement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
                exports := filter(statements, /* TODO(ArrowFunction): d => isExportDeclaration(d) && !d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause) */ TODO) /* as */ /* TODO(ArrayType): ExportDeclaration[] */
                if /* TODO(BinaryExpression): length(exports) > 1 */ TODO {
                    nonExports := filter(statements, /* TODO(ArrowFunction): d => !isExportDeclaration(d) || !!d.moduleSpecifier || !d.exportClause */ TODO)
                    /* TODO(ExpressionStatement): statements = [                         ...nonExports,                         factory.createExportDeclaration(                             /*modifiers* / undefined,                             /*isTypeOnly* / false,                             factory.createNamedExports(flatMap(exports, e => cast(e.exportClause, isNamedExports).elements)),                             /*moduleSpecifier* / undefined,                         ),                     ]; */
                }
                reexports := filter(statements, /* TODO(ArrowFunction): d => isExportDeclaration(d) && !!d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause) */ TODO) /* as */ /* TODO(ArrayType): ExportDeclaration[] */
                if /* TODO(BinaryExpression): length(reexports) > 1 */ TODO {
                    groups := group(reexports, /* TODO(ArrowFunction): decl => isStringLiteral(decl.moduleSpecifier!) ? ">" + decl.moduleSpecifier.text : ">" */ TODO)
                    if /* TODO(BinaryExpression): groups.length !== reexports.length */ TODO {
                        /* TODO(ForOfStatement): for (const group of groups) {                             if (group.length > 1) {                                 // remove group members from statements and then merge group members and add back to statements                                 statements = [                                     ...filter(statements, s => !group.includes(s as ExportDeclaration)),                                     factory.createExportDeclaration(                                         /*modifiers* / undefined,                                         /*isTypeOnly* / false,                                         factory.createNamedExports(flatMap(group, e => cast(e.exportClause, isNamedExports).elements)),                                         group[0].moduleSpecifier,                                     ),                                 ];                             }                         } */
                    }
                }
                 statements
            }
            inlineExportModifiers := func(statements []Statement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
                index := findIndex(statements, /* TODO(ArrowFunction): d => isExportDeclaration(d) && !d.moduleSpecifier && !d.attributes && !!d.exportClause && isNamedExports(d.exportClause) */ TODO)
                if /* TODO(BinaryExpression): index >= 0 */ TODO {
                    exportDecl := /* TODO(ElementAccessExpression): statements[index] */ TODO /* as */ /* TODO(IntersectionType): ExportDeclaration & { readonly exportClause: NamedExports; } */
                    replacements := mapDefined(/* TODO(PropertyAccessExpression): exportDecl.exportClause.elements */ TODO, /* TODO(ArrowFunction): e => {                         if (!e.propertyName && e.name.kind !== SyntaxKind.StringLiteral) {                             // export {name} - look thru `statements` for `name`, and if all results can take an `export` modifier, do so and filter it                             const name = e.name;                             const indices = indicesOf(statements);                             const associatedIndices = filter(indices, i => nodeHasName(statements[i], name));                             if (length(associatedIndices) && every(associatedIndices, i => canHaveExportModifier(statements[i]))) {                                 for (const index of associatedIndices) {                                     statements[index] = addExportModifier(statements[index] as Extract<HasModifiers, Statement>);                                 }                                 return undefined;                             }                         }                         return e;                     } */ TODO)
                    if /* TODO(PrefixUnaryExpression): !length(replacements) */ TODO {
                        /* TODO(ExpressionStatement): orderedRemoveItemAt(statements, index); */
                    } else {
                        /* TODO(ExpressionStatement): statements[index] = factory.updateExportDeclaration(                             exportDecl,                             exportDecl.modifiers,                             exportDecl.isTypeOnly,                             factory.updateNamedExports(                                 exportDecl.exportClause,                                 replacements,                             ),                             exportDecl.moduleSpecifier,                             exportDecl.attributes,                         ); */
                    }
                }
                 statements
            }
            mergeRedundantStatements := func(statements []Statement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
                /* TODO(ExpressionStatement): statements = flattenExportAssignedNamespace(statements); */
                /* TODO(ExpressionStatement): statements = mergeExportDeclarations(statements); */
                /* TODO(ExpressionStatement): statements = inlineExportModifiers(statements); */
                if /* TODO(BinaryExpression): enclosingDeclaration &&                     ((isSourceFile(enclosingDeclaration) && isExternalOrCommonJsModule(enclosingDeclaration)) || isModuleDeclaration(enclosingDeclaration)) &&                     (!some(statements, isExternalModuleIndicator) || (!hasScopeMarker(statements) && some(statements, needsScopeMarker))) */ TODO {
                    /* TODO(ExpressionStatement): statements.push(createEmptyExports(factory)); */
                }
                 statements
            }
            addExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportEqualsDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ModuleDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").EnumDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeAliasDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableStatement */ TODO {
                flags := /* TODO(BinaryExpression): (getEffectiveModifierFlags(node) | ModifierFlags.Export) & ~ModifierFlags.Ambient */ TODO
                 /* TODO(PropertyAccessExpression): factory.replaceModifiers */ TODO(node, flags)
            }
            removeExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportEqualsDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ModuleDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").EnumDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeAliasDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableStatement */ TODO {
                flags := /* TODO(BinaryExpression): getEffectiveModifierFlags(node) & ~ModifierFlags.Export */ TODO
                 /* TODO(PropertyAccessExpression): factory.replaceModifiers */ TODO(node, flags)
            }
            visitSymbolTable := func(symbolTable SymbolTable, suppressNewPrivateContext bool, propertyAsAlias bool) {
                if /* TODO(PrefixUnaryExpression): !suppressNewPrivateContext */ TODO {
                    /* TODO(ExpressionStatement): deferredPrivatesStack.push(new Map()); */
                }
                /* TODO(ExpressionStatement): symbolTable.forEach((symbol: Symbol) => {                     serializeSymbol(symbol, /*isPrivate* / false, !!propertyAsAlias);                 }); */
                if /* TODO(PrefixUnaryExpression): !suppressNewPrivateContext */ TODO {
                    /* TODO(ExpressionStatement): deferredPrivatesStack[deferredPrivatesStack.length - 1].forEach((symbol: Symbol) => {                         serializeSymbol(symbol, /*isPrivate* / true, !!propertyAsAlias);                     }); */
                    /* TODO(ExpressionStatement): deferredPrivatesStack.pop(); */
                }
            }
            serializeSymbol := func(symbol Symbol, isPrivate bool, propertyAsAlias bool) {
                /* TODO(ExpressionStatement): void getPropertiesOfType(getTypeOfSymbol(symbol)); */
                visitedSym := getMergedSymbol(symbol)
                if /* TODO(PropertyAccessExpression): visitedSymbols.has */ TODO(getSymbolId(visitedSym)) {

                }
                /* TODO(ExpressionStatement): visitedSymbols.add(getSymbolId(visitedSym)); */
                skipMembershipCheck := /* TODO(PrefixUnaryExpression): !isPrivate */ TODO
                if /* TODO(BinaryExpression): skipMembershipCheck || (!!length(symbol.declarations) && some(symbol.declarations, d => !!findAncestor(d, n => n === enclosingDeclaration))) */ TODO {
                    scopeCleanup := cloneNodeBuilderContext(context)
                    /* TODO(ExpressionStatement): serializeSymbolWorker(symbol, isPrivate, propertyAsAlias); */
                    /* TODO(ExpressionStatement): scopeCleanup(); */
                }
            }
            serializeSymbolWorker := func(symbol Symbol, isPrivate bool, propertyAsAlias bool, escapedSymbolName /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO /* = */ /* TODO(PropertyAccessExpression): symbol.escapedName */) {
                symbolName := unescapeLeadingUnderscores(escapedSymbolName)
                isDefault := /* TODO(BinaryExpression): escapedSymbolName === InternalSymbolName.Default */ TODO
                if /* TODO(BinaryExpression): isPrivate && !(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier) && isStringANonContextualKeyword(symbolName) && !isDefault */ TODO {
                    /* TODO(ExpressionStatement): context.encounteredError = true; */

                }
                needsPostExportDefault := /* TODO(BinaryExpression): isDefault && !!(                     symbol.flags & SymbolFlags.ExportDoesNotSupportDefaultModifier                     || (symbol.flags & SymbolFlags.Function && length(getPropertiesOfType(getTypeOfSymbol(symbol))))                 ) && !(symbol.flags & SymbolFlags.Alias) */ TODO
                needsExportDeclaration := /* TODO(BinaryExpression): !needsPostExportDefault && !isPrivate && isStringANonContextualKeyword(symbolName) && !isDefault */ TODO
                if /* TODO(BinaryExpression): needsPostExportDefault || needsExportDeclaration */ TODO {
                    /* TODO(ExpressionStatement): isPrivate = true; */
                }
                modifierFlags := /* TODO(BinaryExpression): (!isPrivate ? ModifierFlags.Export : 0) | (isDefault && !needsPostExportDefault ? ModifierFlags.Default : 0) */ TODO
                isConstMergedWithNS := /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Module &&                     symbol.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.FunctionScopedVariable | SymbolFlags.Property) &&                     escapedSymbolName !== InternalSymbolName.ExportEquals */ TODO
                isConstMergedWithNSPrintableAsSignatureMerge := /* TODO(BinaryExpression): isConstMergedWithNS && isTypeRepresentableAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol) */ TODO
                if /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Function | SymbolFlags.Method) || isConstMergedWithNSPrintableAsSignatureMerge */ TODO {
                    /* TODO(ExpressionStatement): serializeAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol, getInternalSymbolName(symbol, symbolName), modifierFlags); */
                }
                if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeAlias */ TODO {
                    /* TODO(ExpressionStatement): serializeTypeAlias(symbol, symbolName, modifierFlags); */
                }
                if /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.FunctionScopedVariable | SymbolFlags.Property | SymbolFlags.Accessor)                     && escapedSymbolName !== InternalSymbolName.ExportEquals                     && !(symbol.flags & SymbolFlags.Prototype)                     && !(symbol.flags & SymbolFlags.Class)                     && !(symbol.flags & SymbolFlags.Method)                     && !isConstMergedWithNSPrintableAsSignatureMerge */ TODO {
                    if propertyAsAlias {
                        createdExport := serializeMaybeAliasAssignment(symbol)
                        if createdExport {
                            /* TODO(ExpressionStatement): needsExportDeclaration = false; */
                            /* TODO(ExpressionStatement): needsPostExportDefault = false; */
                        }
                    } else {
                        type_ := getTypeOfSymbol(symbol)
                        localName := getInternalSymbolName(symbol, symbolName)
                        if /* TODO(BinaryExpression): type.symbol && type.symbol !== symbol && type.symbol.flags & SymbolFlags.Function && some(type.symbol.declarations, isFunctionExpressionOrArrowFunction) && (type.symbol.members?.size || type.symbol.exports?.size) */ TODO {
                            if /* TODO(PrefixUnaryExpression): !context.remappedSymbolReferences */ TODO {
                                /* TODO(ExpressionStatement): context.remappedSymbolReferences = new Map(); */
                            }
                            /* TODO(ExpressionStatement): context.remappedSymbolReferences.set(getSymbolId(type.symbol), symbol); */
                            /* TODO(ExpressionStatement): serializeSymbolWorker(type.symbol, isPrivate, propertyAsAlias, escapedSymbolName); */
                            /* TODO(ExpressionStatement): context.remappedSymbolReferences.delete(getSymbolId(type.symbol)); */
                        } else if /* TODO(BinaryExpression): !(symbol.flags & SymbolFlags.Function) && isTypeRepresentableAsFunctionNamespaceMerge(type, symbol) */ TODO {
                            /* TODO(ExpressionStatement): serializeAsFunctionNamespaceMerge(type, symbol, localName, modifierFlags); */
                        } else {
                            flags := /* TODO(ConditionalExpression): !(symbol.flags & SymbolFlags.BlockScopedVariable)                                 ? symbol.parent?.valueDeclaration && isSourceFile(symbol.parent?.valueDeclaration)                                     ? NodeFlags.Const // exports are immutable in es6, which is what we emulate and check; so it's safe to mark all exports as `const` (there's no difference to consumers, but it allows unique symbol type declarations)                                     : undefined                                 : isConstantVariable(symbol)                                 ? NodeFlags.Const                                 : NodeFlags.Let */ TODO
                            name := /* TODO(ConditionalExpression): (needsPostExportDefault || !(symbol.flags & SymbolFlags.Property)) ? localName : getUnusedName(localName, symbol) */ TODO
                            var textRange Node = /* TODO(BinaryExpression): symbol.declarations && find(symbol.declarations, d => isVariableDeclaration(d)) */ TODO
                            if /* TODO(BinaryExpression): textRange && isVariableDeclarationList(textRange.parent) && textRange.parent.declarations.length === 1 */ TODO {
                                /* TODO(ExpressionStatement): textRange = textRange.parent.parent; */
                            }
                            propertyAccessRequire := /* TODO(PropertyAccessExpression): symbol.declarations?.find */ TODO(isPropertyAccessExpression)
                            if /* TODO(BinaryExpression): propertyAccessRequire && isBinaryExpression(propertyAccessRequire.parent) && isIdentifier(propertyAccessRequire.parent.right)                                 && type.symbol?.valueDeclaration && isSourceFile(type.symbol.valueDeclaration) */ TODO {
                                alias := /* TODO(ConditionalExpression): localName === propertyAccessRequire.parent.right.escapedText ? undefined : propertyAccessRequire.parent.right */ TODO
                                /* TODO(ExpressionStatement): addResult(                                     factory.createExportDeclaration(                                         /*modifiers* / undefined,                                         /*isTypeOnly* / false,                                         factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly* / false, alias, localName)]),                                     ),                                     ModifierFlags.None,                                 ); */
                                /* TODO(ExpressionStatement): context.tracker.trackSymbol(type.symbol, context.enclosingDeclaration, SymbolFlags.Value); */
                            } else {
                                statement := setTextRange(context, /* TODO(PropertyAccessExpression): factory.createVariableStatement */ TODO(undefined, /* TODO(PropertyAccessExpression): factory.createVariableDeclarationList */ TODO(/* TODO(ArrayLiteralExpression): [                                             factory.createVariableDeclaration(name, /*exclamationToken* / undefined, serializeTypeForDeclaration(context, /*declaration* / undefined, type, symbol)),                                         ] */ TODO, flags)), textRange)
                                /* TODO(ExpressionStatement): addResult(statement, name !== localName ? modifierFlags & ~ModifierFlags.Export : modifierFlags); */
                                if /* TODO(BinaryExpression): name !== localName && !isPrivate */ TODO {
                                    /* TODO(ExpressionStatement): addResult(                                         factory.createExportDeclaration(                                             /*modifiers* / undefined,                                             /*isTypeOnly* / false,                                             factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly* / false, name, localName)]),                                         ),                                         ModifierFlags.None,                                     ); */
                                    /* TODO(ExpressionStatement): needsExportDeclaration = false; */
                                    /* TODO(ExpressionStatement): needsPostExportDefault = false; */
                                }
                            }
                        }
                    }
                }
                if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Enum */ TODO {
                    /* TODO(ExpressionStatement): serializeEnum(symbol, symbolName, modifierFlags); */
                }
                if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Class */ TODO {
                    if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Property                         && symbol.valueDeclaration                         && isBinaryExpression(symbol.valueDeclaration.parent)                         && isClassExpression(symbol.valueDeclaration.parent.right) */ TODO {
                        /* TODO(ExpressionStatement): serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags); */
                    } else {
                        /* TODO(ExpressionStatement): serializeAsClass(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags); */
                    }
                }
                if /* TODO(BinaryExpression): (symbol.flags & (SymbolFlags.ValueModule | SymbolFlags.NamespaceModule) && (!isConstMergedWithNS || isTypeOnlyNamespace(symbol))) || isConstMergedWithNSPrintableAsSignatureMerge */ TODO {
                    /* TODO(ExpressionStatement): serializeModule(symbol, symbolName, modifierFlags); */
                }
                if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Interface && !(symbol.flags & SymbolFlags.Class) */ TODO {
                    /* TODO(ExpressionStatement): serializeInterface(symbol, symbolName, modifierFlags); */
                }
                if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO {
                    /* TODO(ExpressionStatement): serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags); */
                }
                if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Property && symbol.escapedName === InternalSymbolName.ExportEquals */ TODO {
                    /* TODO(ExpressionStatement): serializeMaybeAliasAssignment(symbol); */
                }
                if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ExportStar */ TODO {
                    if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
                        /* TODO(ForOfStatement): for (const node of symbol.declarations) {                             const resolvedModule = resolveExternalModuleName(node, (node as ExportDeclaration).moduleSpecifier!);                             if (!resolvedModule) continue;                             addResult(factory.createExportDeclaration(/*modifiers* / undefined, /*isTypeOnly* / (node as ExportDeclaration).isTypeOnly, /*exportClause* / undefined, factory.createStringLiteral(getSpecifierForModuleSymbol(resolvedModule, context))), ModifierFlags.None);                         } */
                    }
                }
                if needsPostExportDefault {
                    /* TODO(ExpressionStatement): addResult(factory.createExportAssignment(/*modifiers* / undefined, /*isExportEquals* / false, factory.createIdentifier(getInternalSymbolName(symbol, symbolName))), ModifierFlags.None); */
                } else if needsExportDeclaration {
                    /* TODO(ExpressionStatement): addResult(                         factory.createExportDeclaration(                             /*modifiers* / undefined,                             /*isTypeOnly* / false,                             factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly* / false, getInternalSymbolName(symbol, symbolName), symbolName)]),                         ),                         ModifierFlags.None,                     ); */
                }
            }
            includePrivateSymbol := func(symbol Symbol) {
                if some(/* TODO(PropertyAccessExpression): symbol.declarations */ TODO, isPartOfParameterDeclaration) {
                }
                /* TODO(ExpressionStatement): Debug.assertIsDefined(deferredPrivatesStack[deferredPrivatesStack.length - 1]); */
                /* TODO(ExpressionStatement): getUnusedName(unescapeLeadingUnderscores(symbol.escapedName), symbol); */
                isExternalImportAlias := /* TODO(BinaryExpression): !!(symbol.flags & SymbolFlags.Alias) && !some(symbol.declarations, d =>                     !!findAncestor(d, isExportDeclaration) ||                     isNamespaceExport(d) ||                     (isImportEqualsDeclaration(d) && !isExternalModuleReference(d.moduleReference))) */ TODO
                /* TODO(ExpressionStatement): deferredPrivatesStack[isExternalImportAlias ? 0 : (deferredPrivatesStack.length - 1)].set(getSymbolId(symbol), symbol); */
            }
            isExportingScope := func(enclosingDeclaration Node) /* TODO(undefined): boolean */ TODO {
                 /* TODO(ParenthesizedExpression): ((isSourceFile(enclosingDeclaration) && (isExternalOrCommonJsModule(enclosingDeclaration) || isJsonSourceFile(enclosingDeclaration))) ||                     (isAmbientModule(enclosingDeclaration) && !isGlobalScopeAugmentation(enclosingDeclaration))) */ TODO
            }
            addResult := func(node Statement, additionalModifierFlags ModifierFlags) {
                if canHaveModifiers(node) {
                    var newModifierFlags ModifierFlags = /* TODO(PropertyAccessExpression): ModifierFlags.None */ TODO
                    enclosingDeclaration := /* TODO(BinaryExpression): context.enclosingDeclaration &&                         (isJSDocTypeAlias(context.enclosingDeclaration) ? getSourceFileOfNode(context.enclosingDeclaration) : context.enclosingDeclaration) */ TODO
                    if /* TODO(BinaryExpression): additionalModifierFlags & ModifierFlags.Export &&                         enclosingDeclaration && (isExportingScope(enclosingDeclaration) || isModuleDeclaration(enclosingDeclaration)) &&                         canHaveExportModifier(node) */ TODO {
                        /* TODO(ExpressionStatement): newModifierFlags |= ModifierFlags.Export; */
                    }
                    if /* TODO(BinaryExpression): addingDeclare && !(newModifierFlags & ModifierFlags.Export) &&                         (!enclosingDeclaration || !(enclosingDeclaration.flags & NodeFlags.Ambient)) &&                         (isEnumDeclaration(node) || isVariableStatement(node) || isFunctionDeclaration(node) || isClassDeclaration(node) || isModuleDeclaration(node)) */ TODO {
                        /* TODO(ExpressionStatement): newModifierFlags |= ModifierFlags.Ambient; */
                    }
                    if /* TODO(BinaryExpression): (additionalModifierFlags & ModifierFlags.Default) && (isClassDeclaration(node) || isInterfaceDeclaration(node) || isFunctionDeclaration(node)) */ TODO {
                        /* TODO(ExpressionStatement): newModifierFlags |= ModifierFlags.Default; */
                    }
                    if newModifierFlags {
                        /* TODO(ExpressionStatement): node = factory.replaceModifiers(node, newModifierFlags | getEffectiveModifierFlags(node)); */
                    }
                }
                /* TODO(ExpressionStatement): results.push(node); */
            }
            serializeTypeAlias := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
                aliasType := getDeclaredTypeOfTypeAlias(symbol)
                typeParams := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).typeParameters */ TODO
                typeParamDecls := map_(typeParams, /* TODO(ArrowFunction): p => typeParameterToDeclaration(p, context) */ TODO)
                jsdocAliasDecl := /* TODO(PropertyAccessExpression): symbol.declarations?.find */ TODO(isJSDocTypeAlias)
                commentText := getTextOfJSDocComment(/* TODO(ConditionalExpression): jsdocAliasDecl ? jsdocAliasDecl.comment || jsdocAliasDecl.parent.comment : undefined */ TODO)
                restoreFlags := saveRestoreFlags(context)
                /* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.InTypeAlias; */
                oldEnclosingDecl := /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO
                /* TODO(ExpressionStatement): context.enclosingDeclaration = jsdocAliasDecl; */
                typeNode := /* TODO(BinaryExpression): jsdocAliasDecl && jsdocAliasDecl.typeExpression                         && isJSDocTypeExpression(jsdocAliasDecl.typeExpression)                         && tryReuseExistingNonParameterTypeNode(context, jsdocAliasDecl.typeExpression.type, aliasType, /*host* / undefined)                     || typeToTypeNodeHelper(aliasType, context) */ TODO
                /* TODO(ExpressionStatement): addResult(                     setSyntheticLeadingComments(                         factory.createTypeAliasDeclaration(/*modifiers* / undefined, getInternalSymbolName(symbol, symbolName), typeParamDecls, typeNode),                         !commentText ? [] : [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }],                     ),                     modifierFlags,                 ); */
                /* TODO(ExpressionStatement): restoreFlags(); */
                /* TODO(ExpressionStatement): context.enclosingDeclaration = oldEnclosingDecl; */
            }
            serializeInterface := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
                interfaceType := getDeclaredTypeOfClassOrInterface(symbol)
                localParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
                typeParamDecls := map_(localParams, /* TODO(ArrowFunction): p => typeParameterToDeclaration(p, context) */ TODO)
                baseTypes := getBaseTypes(interfaceType)
                baseType := /* TODO(ConditionalExpression): length(baseTypes) ? getIntersectionType(baseTypes) : undefined */ TODO
                members := flatMap(getPropertiesOfType(interfaceType), /* TODO(ArrowFunction): p => serializePropertySymbolForInterface(p, baseType) */ TODO)
                callSignatures := serializeSignatures(/* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO, interfaceType, baseType, /* TODO(PropertyAccessExpression): SyntaxKind.CallSignature */ TODO) /* as */ /* TODO(ArrayType): CallSignatureDeclaration[] */
                constructSignatures := serializeSignatures(/* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO, interfaceType, baseType, /* TODO(PropertyAccessExpression): SyntaxKind.ConstructSignature */ TODO) /* as */ /* TODO(ArrayType): ConstructSignatureDeclaration[] */
                indexSignatures := serializeIndexSignatures(interfaceType, baseType)
                heritageClauses := /* TODO(ConditionalExpression): !length(baseTypes) ? undefined : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, mapDefined(baseTypes, b => trySerializeAsTypeReference(b, SymbolFlags.Value)))] */ TODO
                /* TODO(ExpressionStatement): addResult(                     factory.createInterfaceDeclaration(                         /*modifiers* / undefined,                         getInternalSymbolName(symbol, symbolName),                         typeParamDecls,                         heritageClauses,                         [...indexSignatures, ...constructSignatures, ...callSignatures, ...members],                     ),                     modifierFlags,                 ); */
            }
            getNamespaceMembersForSerialization := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
                exports := arrayFrom(/* TODO(PropertyAccessExpression): getExportsOfSymbol(symbol).values */ TODO())
                merged := getMergedSymbol(symbol)
                if /* TODO(BinaryExpression): merged !== symbol */ TODO {
                    membersSet := /* TODO(NewExpression): new Set(exports) */ TODO
                    /* TODO(ForOfStatement): for (const exported of getExportsOfSymbol(merged).values()) {                         if (!(getSymbolFlags(resolveSymbol(exported)) & SymbolFlags.Value)) {                             membersSet.add(exported);                         }                     } */
                    /* TODO(ExpressionStatement): exports = arrayFrom(membersSet); */
                }
                 filter(exports, /* TODO(ArrowFunction): m => isNamespaceMember(m) && isIdentifierText(m.escapedName as string, ScriptTarget.ESNext) */ TODO)
            }
            isTypeOnlyNamespace := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
                 every(getNamespaceMembersForSerialization(symbol), /* TODO(ArrowFunction): m => !(getSymbolFlags(resolveSymbol(m)) & SymbolFlags.Value) */ TODO)
            }
            serializeModule := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
                members := getNamespaceMembersForSerialization(symbol)
                locationMap := arrayToMultiMap(members, /* TODO(ArrowFunction): m => m.parent && m.parent === symbol ? "real" : "merged" */ TODO)
                realMembers := /* TODO(BinaryExpression): locationMap.get("real") || emptyArray */ TODO
                mergedMembers := /* TODO(BinaryExpression): locationMap.get("merged") || emptyArray */ TODO
                if length(realMembers) {
                    localName := getInternalSymbolName(symbol, symbolName)
                    /* TODO(ExpressionStatement): serializeAsNamespaceDeclaration(realMembers, localName, modifierFlags, !!(symbol.flags & (SymbolFlags.Function | SymbolFlags.Assignment))); */
                }
                if length(mergedMembers) {
                    containingFile := getSourceFileOfNode(/* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO)
                    localName := getInternalSymbolName(symbol, symbolName)
                    nsBody := /* TODO(PropertyAccessExpression): factory.createModuleBlock */ TODO(/* TODO(ArrayLiteralExpression): [factory.createExportDeclaration(                         /*modifiers* / undefined,                         /*isTypeOnly* / false,                         factory.createNamedExports(mapDefined(filter(mergedMembers, n => n.escapedName !== InternalSymbolName.ExportEquals), s => {                             const name = unescapeLeadingUnderscores(s.escapedName);                             const localName = getInternalSymbolName(s, name);                             const aliasDecl = s.declarations && getDeclarationOfAliasSymbol(s);                             if (containingFile && (aliasDecl ? containingFile !== getSourceFileOfNode(aliasDecl) : !some(s.declarations, d => getSourceFileOfNode(d) === containingFile))) {                                 context.tracker?.reportNonlocalAugmentation?.(containingFile, symbol, s);                                 return undefined;                             }                             const target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, /*dontRecursivelyResolve* / true);                             includePrivateSymbol(target || s);                             const targetName = target ? getInternalSymbolName(target, unescapeLeadingUnderscores(target.escapedName)) : localName;                             return factory.createExportSpecifier(/*isTypeOnly* / false, name === targetName ? undefined : targetName, name);                         })),                     )] */ TODO)
                    /* TODO(ExpressionStatement): addResult(                         factory.createModuleDeclaration(                             /*modifiers* / undefined,                             factory.createIdentifier(localName),                             nsBody,                             NodeFlags.Namespace,                         ),                         ModifierFlags.None,                     ); */
                }
            }
            serializeEnum := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
                /* TODO(ExpressionStatement): addResult(                     factory.createEnumDeclaration(                         factory.createModifiersFromModifierFlags(isConstEnumSymbol(symbol) ? ModifierFlags.Const : 0),                         getInternalSymbolName(symbol, symbolName),                         map(filter(getPropertiesOfType(getTypeOfSymbol(symbol)), p => !!(p.flags & SymbolFlags.EnumMember)), p => {                             // TODO: Handle computed names                             // I hate that to get the initialized value we need to walk back to the declarations here; but there's no                             // other way to get the possible const value of an enum member that I'm aware of, as the value is cached                             // _on the declaration_, not on the declaration's symbol...                             const initializedValue = p.declarations && p.declarations[0] && isEnumMember(p.declarations[0]) ? getConstantValue(p.declarations[0]) : undefined;                             return factory.createEnumMember(                                 unescapeLeadingUnderscores(p.escapedName),                                 initializedValue === undefined ? undefined :                                     typeof initializedValue === "string" ? factory.createStringLiteral(initializedValue) :                                     factory.createNumericLiteral(initializedValue),                             );                         }),                     ),                     modifierFlags,                 ); */
            }
            serializeAsFunctionNamespaceMerge := func(type_ Type, symbol Symbol, localName string, modifierFlags ModifierFlags) {
                signatures := getSignaturesOfType(type_, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
                /* TODO(ForOfStatement): for (const sig of signatures) {                     // Each overload becomes a separate function declaration, in order                     const decl = signatureToSignatureDeclarationHelper(sig, SyntaxKind.FunctionDeclaration, context, { name: factory.createIdentifier(localName) }) as FunctionDeclaration;                     addResult(setTextRange(context, decl, getSignatureTextRangeLocation(sig)), modifierFlags);                 } */
                if /* TODO(PrefixUnaryExpression): !(symbol.flags & (SymbolFlags.ValueModule | SymbolFlags.NamespaceModule) && !!symbol.exports && !!symbol.exports.size) */ TODO {
                    props := filter(getPropertiesOfType(type_), isNamespaceMember)
                    /* TODO(ExpressionStatement): serializeAsNamespaceDeclaration(props, localName, modifierFlags, /*suppressNewPrivateContext* / true); */
                }
            }
            getSignatureTextRangeLocation := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclarationList | import("/home/jabaile/work/TypeScript/src/compiler/types").CatchClause | undefined */ TODO {
                if /* TODO(BinaryExpression): signature.declaration && signature.declaration.parent */ TODO {
                    if /* TODO(BinaryExpression): isBinaryExpression(signature.declaration.parent) && getAssignmentDeclarationKind(signature.declaration.parent) === AssignmentDeclarationKind.Property */ TODO {
                         /* TODO(PropertyAccessExpression): signature.declaration.parent */ TODO
                    }
                    if /* TODO(BinaryExpression): isVariableDeclaration(signature.declaration.parent) && signature.declaration.parent.parent */ TODO {
                         /* TODO(PropertyAccessExpression): signature.declaration.parent.parent */ TODO
                    }
                }
                 /* TODO(PropertyAccessExpression): signature.declaration */ TODO
            }
            serializeAsNamespaceDeclaration := func(props []Symbol, localName string, modifierFlags ModifierFlags, suppressNewPrivateContext bool) {
                if length(props) {
                    localVsRemoteMap := arrayToMultiMap(props, /* TODO(ArrowFunction): p => !length(p.declarations) || some(p.declarations, d => getSourceFileOfNode(d) === getSourceFileOfNode(context.enclosingDeclaration!)) ? "local" : "remote" */ TODO)
                    localProps := /* TODO(BinaryExpression): localVsRemoteMap.get("local") || emptyArray */ TODO
                    fakespace := /* TODO(PropertyAccessExpression): parseNodeFactory.createModuleDeclaration */ TODO(undefined, /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(localName), /* TODO(PropertyAccessExpression): factory.createModuleBlock */ TODO(/* TODO(ArrayLiteralExpression): [] */ TODO), /* TODO(PropertyAccessExpression): NodeFlags.Namespace */ TODO)
                    /* TODO(ExpressionStatement): setParent(fakespace, enclosingDeclaration as SourceFile | NamespaceDeclaration); */
                    /* TODO(ExpressionStatement): fakespace.locals = createSymbolTable(props); */
                    /* TODO(ExpressionStatement): fakespace.symbol = props[0].parent!; */
                    oldResults := results
                    /* TODO(ExpressionStatement): results = []; */
                    oldAddingDeclare := addingDeclare
                    /* TODO(ExpressionStatement): addingDeclare = false; */
                    subcontext := /* TODO(ObjectLiteralExpression): { ...context, enclosingDeclaration: fakespace } */ TODO
                    oldContext := context
                    /* TODO(ExpressionStatement): context = subcontext; */
                    /* TODO(ExpressionStatement): visitSymbolTable(createSymbolTable(localProps), suppressNewPrivateContext, /*propertyAsAlias* / true); */
                    /* TODO(ExpressionStatement): context = oldContext; */
                    /* TODO(ExpressionStatement): addingDeclare = oldAddingDeclare; */
                    declarations := results
                    /* TODO(ExpressionStatement): results = oldResults; */
                    defaultReplaced := map_(declarations, /* TODO(ArrowFunction): d =>                         isExportAssignment(d) && !d.isExportEquals && isIdentifier(d.expression) ? factory.createExportDeclaration(                             /*modifiers* / undefined,                             /*isTypeOnly* / false,                             factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly* / false, d.expression, factory.createIdentifier(InternalSymbolName.Default))]),                         ) : d */ TODO)
                    exportModifierStripped := /* TODO(ConditionalExpression): every(defaultReplaced, d => hasSyntacticModifier(d, ModifierFlags.Export)) ? map(defaultReplaced as Extract<HasModifiers, Statement>[], removeExportModifier) : defaultReplaced */ TODO
                    /* TODO(ExpressionStatement): fakespace = factory.updateModuleDeclaration(                         fakespace,                         fakespace.modifiers,                         fakespace.name,                         factory.createModuleBlock(exportModifierStripped),                     ); */
                    /* TODO(ExpressionStatement): addResult(fakespace, modifierFlags); */
                }
            }
            isNamespaceMember := func(p Symbol) /* TODO(undefined): boolean */ TODO {
                 /* TODO(BinaryExpression): !!(p.flags & (SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias)) ||                     !(p.flags & SymbolFlags.Prototype || p.escapedName === "prototype" || p.valueDeclaration && isStatic(p.valueDeclaration) && isClassLike(p.valueDeclaration.parent)) */ TODO
            }
            sanitizeJSDocImplements := func(clauses []ExpressionWithTypeArguments) /* TODO(ArrayType): ExpressionWithTypeArguments[] */ any {
                result := mapDefined(clauses, /* TODO(ArrowFunction): e => {                     const oldEnclosing = context.enclosingDeclaration;                     context.enclosingDeclaration = e;                     let expr = e.expression;                     if (isEntityNameExpression(expr)) {                         if (isIdentifier(expr) && idText(expr) === "") {                             return cleanup(/*result* / undefined); // Empty heritage clause, should be an error, but prefer emitting no heritage clauses to reemitting the empty one                         }                         let introducesError: boolean;                         ({ introducesError, node: expr } = trackExistingEntityName(expr, context));                         if (introducesError) {                             return cleanup(/*result* / undefined);                         }                     }                     return cleanup(factory.createExpressionWithTypeArguments(                         expr,                         map(e.typeArguments, a =>                             tryReuseExistingNonParameterTypeNode(context, a, getTypeFromTypeNode(context, a))                             || typeToTypeNodeHelper(getTypeFromTypeNode(context, a), context)),                     ));                      function cleanup<T>(result: T): T {                         context.enclosingDeclaration = oldEnclosing;                         return result;                     }                 } */ TODO)
                if /* TODO(BinaryExpression): result.length === clauses.length */ TODO {
                     result
                }
                 undefined
            }
            serializeAsClass := func(symbol Symbol, localName string, modifierFlags ModifierFlags) {
                originalDecl := /* TODO(PropertyAccessExpression): symbol.declarations?.find */ TODO(isClassLike)
                oldEnclosing := /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO
                /* TODO(ExpressionStatement): context.enclosingDeclaration = originalDecl || oldEnclosing; */
                localParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
                typeParamDecls := map_(localParams, /* TODO(ArrowFunction): p => typeParameterToDeclaration(p, context) */ TODO)
                classType := getTypeWithThisArgument(getDeclaredTypeOfClassOrInterface(symbol)) /* as */ /* TODO(TypeReference): InterfaceType */
                baseTypes := getBaseTypes(classType)
                originalImplements := /* TODO(BinaryExpression): originalDecl && getEffectiveImplementsTypeNodes(originalDecl) */ TODO
                implementsExpressions := /* TODO(BinaryExpression): originalImplements && sanitizeJSDocImplements(originalImplements)                     || mapDefined(getImplementsTypes(classType), serializeImplementedType) */ TODO
                staticType := getTypeOfSymbol(symbol)
                isClass := /* TODO(BinaryExpression): !!staticType.symbol?.valueDeclaration && isClassLike(staticType.symbol.valueDeclaration) */ TODO
                staticBaseType := /* TODO(ConditionalExpression): isClass                     ? getBaseConstructorTypeOfClass(staticType as InterfaceType)                     : anyType */ TODO
                heritageClauses := /* TODO(ArrayLiteralExpression): [                     ...!length(baseTypes) ? [] : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, map(baseTypes, b => serializeBaseType(b, staticBaseType, localName)))],                     ...!length(implementsExpressions) ? [] : [factory.createHeritageClause(SyntaxKind.ImplementsKeyword, implementsExpressions)],                 ] */ TODO
                symbolProps := getNonInheritedProperties(classType, baseTypes, getPropertiesOfType(classType))
                publicSymbolProps := filter(symbolProps, /* TODO(ArrowFunction): s => {                     // `valueDeclaration` could be undefined if inherited from                     // a union/intersection base type, but inherited properties                     // don't matter here.                     const valueDecl = s.valueDeclaration;                     return !!valueDecl && !(isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name));                 } */ TODO)
                hasPrivateIdentifier := some(symbolProps, /* TODO(ArrowFunction): s => {                     // `valueDeclaration` could be undefined if inherited from                     // a union/intersection base type, but inherited properties                     // don't matter here.                     const valueDecl = s.valueDeclaration;                     return !!valueDecl && isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name);                 } */ TODO)
                privateProperties := /* TODO(ConditionalExpression): hasPrivateIdentifier ?                     [factory.createPropertyDeclaration(                         /*modifiers* / undefined,                         factory.createPrivateIdentifier("#private"),                         /*questionOrExclamationToken* / undefined,                         /*type* / undefined,                         /*initializer* / undefined,                     )] :                     emptyArray */ TODO
                publicProperties := flatMap(publicSymbolProps, /* TODO(ArrowFunction): p => serializePropertySymbolForClass(p, /*isStatic* / false, baseTypes[0]) */ TODO)
                staticMembers := flatMap(filter(getPropertiesOfType(staticType), /* TODO(ArrowFunction): p => !(p.flags & SymbolFlags.Prototype) && p.escapedName !== "prototype" && !isNamespaceMember(p) */ TODO), /* TODO(ArrowFunction): p => serializePropertySymbolForClass(p, /*isStatic* / true, staticBaseType) */ TODO)
                isNonConstructableClassLikeInJsFile := /* TODO(BinaryExpression): !isClass &&                     !!symbol.valueDeclaration &&                     isInJSFile(symbol.valueDeclaration) &&                     !some(getSignaturesOfType(staticType, SignatureKind.Construct)) */ TODO
                constructors := /* TODO(ConditionalExpression): isNonConstructableClassLikeInJsFile ?                     [factory.createConstructorDeclaration(factory.createModifiersFromModifierFlags(ModifierFlags.Private), [], /*body* / undefined)] :                     serializeSignatures(SignatureKind.Construct, staticType, staticBaseType, SyntaxKind.Constructor) as ConstructorDeclaration[] */ TODO
                indexSignatures := serializeIndexSignatures(classType, /* TODO(ElementAccessExpression): baseTypes[0] */ TODO)
                /* TODO(ExpressionStatement): context.enclosingDeclaration = oldEnclosing; */
                /* TODO(ExpressionStatement): addResult(                     setTextRange(                         context,                         factory.createClassDeclaration(                             /*modifiers* / undefined,                             localName,                             typeParamDecls,                             heritageClauses,                             [...indexSignatures, ...staticMembers, ...constructors, ...publicProperties, ...privateProperties],                         ),                         symbol.declarations && filter(symbol.declarations, d => isClassDeclaration(d) || isClassExpression(d))[0],                     ),                     modifierFlags,                 ); */
            }
            getSomeTargetNameFromDeclarations := func(declarations /* TODO(ArrayType): Declaration[] */ any) /* TODO(undefined): string | undefined */ TODO {
                 firstDefined(declarations, /* TODO(ArrowFunction): d => {                     if (isImportSpecifier(d) || isExportSpecifier(d)) {                         return moduleExportNameTextUnescaped(d.propertyName || d.name);                     }                     if (isBinaryExpression(d) || isExportAssignment(d)) {                         const expression = isExportAssignment(d) ? d.expression : d.right;                         if (isPropertyAccessExpression(expression)) {                             return idText(expression.name);                         }                     }                     if (isAliasSymbolDeclaration(d)) {                         // This is... heuristic, at best. But it's probably better than always printing the name of the shorthand ambient module.                         const name = getNameOfDeclaration(d);                         if (name && isIdentifier(name)) {                             return idText(name);                         }                     }                     return undefined;                 } */ TODO)
            }
            serializeAsAlias := func(symbol Symbol, localName string, modifierFlags ModifierFlags) /* TODO(undefined): undefined */ TODO {
                node := getDeclarationOfAliasSymbol(symbol)
                if /* TODO(PrefixUnaryExpression): !node */ TODO {
                    /* TODO(CallExpression): Debug.fail() */
                }
                target := getMergedSymbol(getTargetOfAliasDeclaration(node, /* TODO(TrueKeyword): true */ TODO))
                if /* TODO(PrefixUnaryExpression): !target */ TODO {

                }
                verbatimTargetName := /* TODO(BinaryExpression): isShorthandAmbientModuleSymbol(target) && getSomeTargetNameFromDeclarations(symbol.declarations) || unescapeLeadingUnderscores(target.escapedName) */ TODO
                if /* TODO(BinaryExpression): verbatimTargetName === InternalSymbolName.ExportEquals && allowSyntheticDefaultImports */ TODO {
                    /* TODO(ExpressionStatement): verbatimTargetName = InternalSymbolName.Default; */
                }
                targetName := getInternalSymbolName(target, verbatimTargetName)
                /* TODO(ExpressionStatement): includePrivateSymbol(target); */
                /* TODO(SwitchStatement): switch (node.kind) {                     case SyntaxKind.BindingElement:                         if (node.parent?.parent?.kind === SyntaxKind.VariableDeclaration) {                             // const { SomeClass } = require('./lib');                             const specifier = getSpecifierForModuleSymbol(target.parent || target, context); // './lib'                             const { propertyName } = node as BindingElement;                             addResult(                                 factory.createImportDeclaration(                                     /*modifiers* / undefined,                                     factory.createImportClause(                                         /*isTypeOnly* / false,                                         /*name* / undefined,                                         factory.createNamedImports([factory.createImportSpecifier(                                             /*isTypeOnly* / false,                                             propertyName && isIdentifier(propertyName) ? factory.createIdentifier(idText(propertyName)) : undefined,                                             factory.createIdentifier(localName),                                         )]),                                     ),                                     factory.createStringLiteral(specifier),                                     /*attributes* / undefined,                                 ),                                 ModifierFlags.None,                             );                             break;                         }                         // We don't know how to serialize this (nested?) binding element                         Debug.failBadSyntaxKind(node.parent?.parent || node, "Unhandled binding element grandparent kind in declaration serialization");                         break;                     case SyntaxKind.ShorthandPropertyAssignment:                         if (node.parent?.parent?.kind === SyntaxKind.BinaryExpression) {                             // module.exports = { SomeClass }                             serializeExportSpecifier(                                 unescapeLeadingUnderscores(symbol.escapedName),                                 targetName,                             );                         }                         break;                     case SyntaxKind.VariableDeclaration:                         // commonjs require: const x = require('y')                         if (isPropertyAccessExpression((node as VariableDeclaration).initializer!)) {                             // const x = require('y').z                             const initializer = (node as VariableDeclaration).initializer! as PropertyAccessExpression; // require('y').z                             const uniqueName = factory.createUniqueName(localName); // _x                             const specifier = getSpecifierForModuleSymbol(target.parent || target, context); // 'y'                             // import _x = require('y');                             addResult(                                 factory.createImportEqualsDeclaration(                                     /*modifiers* / undefined,                                     /*isTypeOnly* / false,                                     uniqueName,                                     factory.createExternalModuleReference(factory.createStringLiteral(specifier)),                                 ),                                 ModifierFlags.None,                             );                             // import x = _x.z                             addResult(                                 factory.createImportEqualsDeclaration(                                     /*modifiers* / undefined,                                     /*isTypeOnly* / false,                                     factory.createIdentifier(localName),                                     factory.createQualifiedName(uniqueName, initializer.name as Identifier),                                 ),                                 modifierFlags,                             );                             break;                         }                         // else fall through and treat commonjs require just like import=                     case SyntaxKind.ImportEqualsDeclaration:                         // This _specifically_ only exists to handle json declarations - where we make aliases, but since                         // we emit no declarations for the json document, must not refer to it in the declarations                         if (target.escapedName === InternalSymbolName.ExportEquals && some(target.declarations, d => isSourceFile(d) && isJsonSourceFile(d))) {                             serializeMaybeAliasAssignment(symbol);                             break;                         }                         // Could be a local `import localName = ns.member` or                         // an external `import localName = require("whatever")`                         const isLocalImport = !(target.flags & SymbolFlags.ValueModule) && !isVariableDeclaration(node);                         addResult(                             factory.createImportEqualsDeclaration(                                 /*modifiers* / undefined,                                 /*isTypeOnly* / false,                                 factory.createIdentifier(localName),                                 isLocalImport                                     ? symbolToName(target, context, SymbolFlags.All, /*expectsIdentifier* / false)                                     : factory.createExternalModuleReference(factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))),                             ),                             isLocalImport ? modifierFlags : ModifierFlags.None,                         );                         break;                     case SyntaxKind.NamespaceExportDeclaration:                         // export as namespace foo                         // TODO: Not part of a file's local or export symbol tables                         // Is bound into file.symbol.globalExports instead, which we don't currently traverse                         addResult(factory.createNamespaceExportDeclaration(idText((node as NamespaceExportDeclaration).name)), ModifierFlags.None);                         break;                     case SyntaxKind.ImportClause: {                         const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context); // generate specifier (even though we're reusing and existing one) for ambient module reference include side effects                         const specifier = context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as ImportClause).parent.moduleSpecifier;                         const attributes = isImportDeclaration(node.parent) ? node.parent.attributes : undefined;                         const isTypeOnly = isJSDocImportTag((node as ImportClause).parent);                         addResult(                             factory.createImportDeclaration(                                 /*modifiers* / undefined,                                 factory.createImportClause(isTypeOnly, factory.createIdentifier(localName), /*namedBindings* / undefined),                                 specifier,                                 attributes,                             ),                             ModifierFlags.None,                         );                         break;                     }                     case SyntaxKind.NamespaceImport: {                         const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context); // generate specifier (even though we're reusing and existing one) for ambient module reference include side effects                         const specifier = context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as NamespaceImport).parent.parent.moduleSpecifier;                         const isTypeOnly = isJSDocImportTag((node as NamespaceImport).parent.parent);                         addResult(                             factory.createImportDeclaration(                                 /*modifiers* / undefined,                                 factory.createImportClause(isTypeOnly, /*name* / undefined, factory.createNamespaceImport(factory.createIdentifier(localName))),                                 specifier,                                 (node as ImportClause).parent.attributes,                             ),                             ModifierFlags.None,                         );                         break;                     }                     case SyntaxKind.NamespaceExport:                         addResult(                             factory.createExportDeclaration(                                 /*modifiers* / undefined,                                 /*isTypeOnly* / false,                                 factory.createNamespaceExport(factory.createIdentifier(localName)),                                 factory.createStringLiteral(getSpecifierForModuleSymbol(target, context)),                             ),                             ModifierFlags.None,                         );                         break;                     case SyntaxKind.ImportSpecifier: {                         const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context); // generate specifier (even though we're reusing and existing one) for ambient module reference include side effects                         const specifier = context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as ImportSpecifier).parent.parent.parent.moduleSpecifier;                         const isTypeOnly = isJSDocImportTag((node as ImportSpecifier).parent.parent.parent);                         addResult(                             factory.createImportDeclaration(                                 /*modifiers* / undefined,                                 factory.createImportClause(                                     isTypeOnly,                                     /*name* / undefined,                                     factory.createNamedImports([                                         factory.createImportSpecifier(                                             /*isTypeOnly* / false,                                             localName !== verbatimTargetName ? factory.createIdentifier(verbatimTargetName) : undefined,                                             factory.createIdentifier(localName),                                         ),                                     ]),                                 ),                                 specifier,                                 (node as ImportSpecifier).parent.parent.parent.attributes,                             ),                             ModifierFlags.None,                         );                         break;                     }                     case SyntaxKind.ExportSpecifier:                         // does not use localName because the symbol name in this case refers to the name in the exports table,                         // which we must exactly preserve                         const specifier = (node.parent.parent as ExportDeclaration).moduleSpecifier;                         if (specifier) {                             const propertyName = (node as ExportSpecifier).propertyName;                             if (propertyName && moduleExportNameIsDefault(propertyName)) {                                 verbatimTargetName = InternalSymbolName.Default;                             }                         }                         // targetName is only used when the target is local, as otherwise the target is an alias that points at                         // another file                         serializeExportSpecifier(                             unescapeLeadingUnderscores(symbol.escapedName),                             specifier ? verbatimTargetName : targetName,                             specifier && isStringLiteralLike(specifier) ? factory.createStringLiteral(specifier.text) : undefined,                         );                         break;                     case SyntaxKind.ExportAssignment:                         serializeMaybeAliasAssignment(symbol);                         break;                     case SyntaxKind.BinaryExpression:                     case SyntaxKind.PropertyAccessExpression:                     case SyntaxKind.ElementAccessExpression:                         // Could be best encoded as though an export specifier or as though an export assignment                         // If name is default or export=, do an export assignment                         // Otherwise do an export specifier                         if (symbol.escapedName === InternalSymbolName.Default || symbol.escapedName === InternalSymbolName.ExportEquals) {                             serializeMaybeAliasAssignment(symbol);                         }                         else {                             serializeExportSpecifier(localName, targetName);                         }                         break;                     default:                         return Debug.failBadSyntaxKind(node, "Unhandled alias declaration kind in symbol serializer!");                 } */
            }
            serializeExportSpecifier := func(localName string, targetName string, specifier Expression) {
                /* TODO(ExpressionStatement): addResult(                     factory.createExportDeclaration(                         /*modifiers* / undefined,                         /*isTypeOnly* / false,                         factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly* / false, localName !== targetName ? targetName : undefined, localName)]),                         specifier,                     ),                     ModifierFlags.None,                 ); */
            }
            serializeMaybeAliasAssignment := func(symbol Symbol) bool {
                if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Prototype */ TODO {
                     /* TODO(FalseKeyword): false */ TODO
                }
                name := unescapeLeadingUnderscores(/* TODO(PropertyAccessExpression): symbol.escapedName */ TODO)
                isExportEquals := /* TODO(BinaryExpression): name === InternalSymbolName.ExportEquals */ TODO
                isDefault := /* TODO(BinaryExpression): name === InternalSymbolName.Default */ TODO
                isExportAssignmentCompatibleSymbolName := /* TODO(BinaryExpression): isExportEquals || isDefault */ TODO
                aliasDecl := /* TODO(BinaryExpression): symbol.declarations && getDeclarationOfAliasSymbol(symbol) */ TODO
                target := /* TODO(BinaryExpression): aliasDecl && getTargetOfAliasDeclaration(aliasDecl, /*dontRecursivelyResolve* / true) */ TODO
                if /* TODO(BinaryExpression): target && length(target.declarations) && some(target.declarations, d => getSourceFileOfNode(d) === getSourceFileOfNode(enclosingDeclaration)) */ TODO {
                    expr := /* TODO(BinaryExpression): aliasDecl && ((isExportAssignment(aliasDecl) || isBinaryExpression(aliasDecl)) ? getExportAssignmentExpression(aliasDecl) : getPropertyAssignmentAliasLikeExpression(aliasDecl as ShorthandPropertyAssignment | PropertyAssignment | PropertyAccessExpression)) */ TODO
                    first := /* TODO(ConditionalExpression): expr && isEntityNameExpression(expr) ? getFirstNonModuleExportsIdentifier(expr) : undefined */ TODO
                    referenced := /* TODO(BinaryExpression): first && resolveEntityName(first, SymbolFlags.All, /*ignoreErrors* / true, /*dontResolveAlias* / true, enclosingDeclaration) */ TODO
                    if /* TODO(BinaryExpression): referenced || target */ TODO {
                        /* TODO(ExpressionStatement): includePrivateSymbol(referenced || target); */
                    }
                    prevDisableTrackSymbol := /* TODO(PropertyAccessExpression): context.tracker.disableTrackSymbol */ TODO
                    /* TODO(ExpressionStatement): context.tracker.disableTrackSymbol = true; */
                    if isExportAssignmentCompatibleSymbolName {
                        /* TODO(ExpressionStatement): results.push(factory.createExportAssignment(                             /*modifiers* / undefined,                             isExportEquals,                             symbolToExpression(target, context, SymbolFlags.All),                         )); */
                    } else {
                        if /* TODO(BinaryExpression): first === expr && first */ TODO {
                            /* TODO(ExpressionStatement): serializeExportSpecifier(name, idText(first)); */
                        } else if /* TODO(BinaryExpression): expr && isClassExpression(expr) */ TODO {
                            /* TODO(ExpressionStatement): serializeExportSpecifier(name, getInternalSymbolName(target, symbolName(target))); */
                        } else {
                            varName := getUnusedName(name, symbol)
                            /* TODO(ExpressionStatement): addResult(                                 factory.createImportEqualsDeclaration(                                     /*modifiers* / undefined,                                     /*isTypeOnly* / false,                                     factory.createIdentifier(varName),                                     symbolToName(target, context, SymbolFlags.All, /*expectsIdentifier* / false),                                 ),                                 ModifierFlags.None,                             ); */
                            /* TODO(ExpressionStatement): serializeExportSpecifier(name, varName); */
                        }
                    }
                    /* TODO(ExpressionStatement): context.tracker.disableTrackSymbol = prevDisableTrackSymbol; */
                     /* TODO(TrueKeyword): true */ TODO
                } else {
                    varName := getUnusedName(name, symbol)
                    typeToSerialize := getWidenedType(getTypeOfSymbol(getMergedSymbol(symbol)))
                    if isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, symbol) {
                        /* TODO(ExpressionStatement): serializeAsFunctionNamespaceMerge(typeToSerialize, symbol, varName, isExportAssignmentCompatibleSymbolName ? ModifierFlags.None : ModifierFlags.Export); */
                    } else {
                        flags := /* TODO(ConditionalExpression): context.enclosingDeclaration?.kind === SyntaxKind.ModuleDeclaration && (!(symbol.flags & SymbolFlags.Accessor) || symbol.flags & SymbolFlags.SetAccessor) ? NodeFlags.Let : NodeFlags.Const */ TODO
                        statement := /* TODO(PropertyAccessExpression): factory.createVariableStatement */ TODO(undefined, /* TODO(PropertyAccessExpression): factory.createVariableDeclarationList */ TODO(/* TODO(ArrayLiteralExpression): [                                 factory.createVariableDeclaration(varName, /*exclamationToken* / undefined, serializeTypeForDeclaration(context, /*declaration* / undefined, typeToSerialize, symbol)),                             ] */ TODO, flags))
                        /* TODO(ExpressionStatement): addResult(                             statement,                             target && target.flags & SymbolFlags.Property && target.escapedName === InternalSymbolName.ExportEquals ? ModifierFlags.Ambient                                 : name === varName ? ModifierFlags.Export                                 : ModifierFlags.None,                         ); */
                    }
                    if isExportAssignmentCompatibleSymbolName {
                        /* TODO(ExpressionStatement): results.push(factory.createExportAssignment(                             /*modifiers* / undefined,                             isExportEquals,                             factory.createIdentifier(varName),                         )); */
                         /* TODO(TrueKeyword): true */ TODO
                    } else if /* TODO(BinaryExpression): name !== varName */ TODO {
                        /* TODO(ExpressionStatement): serializeExportSpecifier(name, varName); */
                         /* TODO(TrueKeyword): true */ TODO
                    }
                     /* TODO(FalseKeyword): false */ TODO
                }
            }
            isTypeRepresentableAsFunctionNamespaceMerge := func(typeToSerialize Type, hostSymbol Symbol) /* TODO(undefined): boolean | 0 */ TODO {
                ctxSrc := getSourceFileOfNode(/* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO)
                 /* TODO(BinaryExpression): getObjectFlags(typeToSerialize) & (ObjectFlags.Anonymous | ObjectFlags.Mapped) &&                     !some(typeToSerialize.symbol?.declarations, isTypeNode) && // If the type comes straight from a type node, we shouldn't try to break it up                     !length(getIndexInfosOfType(typeToSerialize)) &&                     !isClassInstanceSide(typeToSerialize) && // While a class instance is potentially representable as a NS, prefer printing a reference to the instance type and serializing the class                     !!(length(filter(getPropertiesOfType(typeToSerialize), isNamespaceMember)) || length(getSignaturesOfType(typeToSerialize, SignatureKind.Call))) &&                     !length(getSignaturesOfType(typeToSerialize, SignatureKind.Construct)) && // TODO: could probably serialize as function + ns + class, now that that's OK                     !getDeclarationWithTypeAnnotation(hostSymbol, enclosingDeclaration) &&                     !(typeToSerialize.symbol && some(typeToSerialize.symbol.declarations, d => getSourceFileOfNode(d) !== ctxSrc)) &&                     !some(getPropertiesOfType(typeToSerialize), p => isLateBoundName(p.escapedName)) &&                     !some(getPropertiesOfType(typeToSerialize), p => some(p.declarations, d => getSourceFileOfNode(d) !== ctxSrc)) &&                     every(getPropertiesOfType(typeToSerialize), p => {                         if (!isIdentifierText(symbolName(p), languageVersion)) {                             return false;                         }                         if (!(p.flags & SymbolFlags.Accessor)) {                             return true;                         }                         return getNonMissingTypeOfSymbol(p) === getWriteTypeOfSymbol(p);                     }) */ TODO
            }
            // OVERLOAD: makeSerializePropertySymbol := func(createProperty func(modifiers /* TODO(TypeOperator): readonly Modifier[] */ any, name /* TODO(UnionType): string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer *Expression) T, methodKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO, useAccessors /* TODO(LiteralType): true */ TODO) func(p Symbol, isStatic bool, baseType *Type) /* TODO(UnionType): T | AccessorDeclaration | (T | AccessorDeclaration)[] */ any
            // OVERLOAD: makeSerializePropertySymbol := func(createProperty func(modifiers /* TODO(TypeOperator): readonly Modifier[] */ any, name /* TODO(UnionType): string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer *Expression) T, methodKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO, useAccessors /* TODO(LiteralType): false */ TODO) func(p Symbol, isStatic bool, baseType *Type) /* TODO(UnionType): T | T[] */ any
            makeSerializePropertySymbol := func(createProperty func(modifiers /* TODO(TypeOperator): readonly Modifier[] */ any, name /* TODO(UnionType): string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer *Expression) T, methodKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO, useAccessors bool) func(p Symbol, isStatic bool, baseType *Type) /* TODO(UnionType): T | AccessorDeclaration | (T | AccessorDeclaration)[] */ any {
                 /* TODO(FunctionExpression): function serializePropertySymbol(p: Symbol, isStatic: boolean, baseType: Type | undefined): T | AccessorDeclaration | (T | AccessorDeclaration)[] {                     const modifierFlags = getDeclarationModifierFlagsFromSymbol(p);                     const isPrivate = !!(modifierFlags & ModifierFlags.Private);                     if (isStatic && (p.flags & (SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias))) {                         // Only value-only-meaning symbols can be correctly encoded as class statics, type/namespace/alias meaning symbols                         // need to be merged namespace members                         return [];                     }                     if (                         p.flags & SymbolFlags.Prototype || p.escapedName === "constructor" ||                         (baseType && getPropertyOfType(baseType, p.escapedName)                             && isReadonlySymbol(getPropertyOfType(baseType, p.escapedName)!) === isReadonlySymbol(p)                             && (p.flags & SymbolFlags.Optional) === (getPropertyOfType(baseType, p.escapedName)!.flags & SymbolFlags.Optional)                             && isTypeIdenticalTo(getTypeOfSymbol(p), getTypeOfPropertyOfType(baseType, p.escapedName)!))                     ) {                         return [];                     }                     const flag = (modifierFlags & ~ModifierFlags.Async) | (isStatic ? ModifierFlags.Static : 0);                     const name = getPropertyNameNodeForSymbol(p, context);                     const firstPropertyLikeDecl = p.declarations?.find(or(isPropertyDeclaration, isAccessor, isVariableDeclaration, isPropertySignature, isBinaryExpression, isPropertyAccessExpression));                     if (p.flags & SymbolFlags.Accessor && useAccessors) {                         const result: AccessorDeclaration[] = [];                         if (p.flags & SymbolFlags.SetAccessor) {                             const setter = p.declarations && forEach(p.declarations, d => {                                 if (d.kind === SyntaxKind.SetAccessor) {                                     return d as SetAccessorDeclaration;                                 }                                 if (isCallExpression(d) && isBindableObjectDefinePropertyCall(d)) {                                     return forEach(d.arguments[2].properties, propDecl => {                                         const id = getNameOfDeclaration(propDecl);                                         if (!!id && isIdentifier(id) && idText(id) === "set") {                                             return propDecl;                                         }                                     });                                 }                             });                              Debug.assert(!!setter);                             const paramSymbol = isFunctionLikeDeclaration(setter) ? getSignatureFromDeclaration(setter).parameters[0] : undefined;                              result.push(setTextRange(                                 context,                                 factory.createSetAccessorDeclaration(                                     factory.createModifiersFromModifierFlags(flag),                                     name,                                     [factory.createParameterDeclaration(                                         /*modifiers* / undefined,                                         /*dotDotDotToken* / undefined,                                         paramSymbol ? parameterToParameterDeclarationName(paramSymbol, getEffectiveParameterDeclaration(paramSymbol), context) : "value",                                         /*questionToken* / undefined,                                         isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getWriteTypeOfSymbol(p), p),                                     )],                                     /*body* / undefined,                                 ),                                 p.declarations?.find(isSetAccessor) || firstPropertyLikeDecl,                             ));                         }                         if (p.flags & SymbolFlags.GetAccessor) {                             const isPrivate = modifierFlags & ModifierFlags.Private;                             result.push(setTextRange(                                 context,                                 factory.createGetAccessorDeclaration(                                     factory.createModifiersFromModifierFlags(flag),                                     name,                                     [],                                     isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getTypeOfSymbol(p), p),                                     /*body* / undefined,                                 ),                                 p.declarations?.find(isGetAccessor) || firstPropertyLikeDecl,                             ));                         }                         return result;                     }                     // This is an else/if as accessors and properties can't merge in TS, but might in JS                     // If this happens, we assume the accessor takes priority, as it imposes more constraints                     else if (p.flags & (SymbolFlags.Property | SymbolFlags.Variable | SymbolFlags.Accessor)) {                         return setTextRange(                             context,                             createProperty(                                 factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag),                                 name,                                 p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                 isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getWriteTypeOfSymbol(p), p),                                 // TODO: https://github.com/microsoft/TypeScript/pull/32372#discussion_r328386357                                 // interface members can't have initializers, however class members _can_                                 /*initializer* / undefined,                             ),                             p.declarations?.find(or(isPropertyDeclaration, isVariableDeclaration)) || firstPropertyLikeDecl,                         );                     }                     if (p.flags & (SymbolFlags.Method | SymbolFlags.Function)) {                         const type = getTypeOfSymbol(p);                         const signatures = getSignaturesOfType(type, SignatureKind.Call);                         if (flag & ModifierFlags.Private) {                             return setTextRange(                                 context,                                 createProperty(                                     factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag),                                     name,                                     p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                     /*type* / undefined,                                     /*initializer* / undefined,                                 ),                                 p.declarations?.find(isFunctionLikeDeclaration) || signatures[0] && signatures[0].declaration || p.declarations && p.declarations[0],                             );                         }                          const results = [];                         for (const sig of signatures) {                             // Each overload becomes a separate method declaration, in order                             const decl = signatureToSignatureDeclarationHelper(                                 sig,                                 methodKind,                                 context,                                 {                                     name,                                     questionToken: p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                     modifiers: flag ? factory.createModifiersFromModifierFlags(flag) : undefined,                                 },                             );                             const location = sig.declaration && isPrototypePropertyAssignment(sig.declaration.parent) ? sig.declaration.parent : sig.declaration;                             results.push(setTextRange(context, decl, location));                         }                         return results as unknown as T[];                     }                     // The `Constructor`'s symbol isn't in the class's properties lists, obviously, since it's a signature on the static                     return Debug.fail(`Unhandled class member kind! ${(p as any).__debugFlags || p.flags}`);                 } */ TODO
            }
            serializePropertySymbolForInterface := func(p Symbol, baseType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement[] */ TODO {
                 serializePropertySymbolForInterfaceWorker(p, /* TODO(FalseKeyword): false */ TODO, baseType)
            }
            serializeSignatures := func(kind SignatureKind, input Type, baseType *Type, outputKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO) /* TODO(undefined): (import("/home/jabaile/work/TypeScript/src/compiler/types").CallSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").MethodSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocFunctionType | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").MethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").GetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").ArrowFunction)[] */ TODO {
                signatures := getSignaturesOfType(input, kind)
                if /* TODO(BinaryExpression): kind === SignatureKind.Construct */ TODO {
                    if /* TODO(BinaryExpression): !baseType && every(signatures, s => length(s.parameters) === 0) */ TODO {
                         /* TODO(ArrayLiteralExpression): [] */ TODO
                    }
                    if baseType {
                        baseSigs := getSignaturesOfType(baseType, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO)
                        if /* TODO(BinaryExpression): !length(baseSigs) && every(signatures, s => length(s.parameters) === 0) */ TODO {
                             /* TODO(ArrayLiteralExpression): [] */ TODO
                        }
                        if /* TODO(BinaryExpression): baseSigs.length === signatures.length */ TODO {
                            failed := /* TODO(FalseKeyword): false */ TODO
                            /* TODO(ForStatement): for (let i = 0; i < baseSigs.length; i++) {                                 if (!compareSignaturesIdentical(signatures[i], baseSigs[i], /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true, compareTypesIdentical)) {                                     failed = true;                                     break;                                 }                             } */
                            if /* TODO(PrefixUnaryExpression): !failed */ TODO {
                                 /* TODO(ArrayLiteralExpression): [] */ TODO
                            }
                        }
                    }
                    var privateProtected ModifierFlags = 0
                    /* TODO(ForOfStatement): for (const s of signatures) {                         if (s.declaration) {                             privateProtected |= getSelectedEffectiveModifierFlags(s.declaration, ModifierFlags.Private | ModifierFlags.Protected);                         }                     } */
                    if privateProtected {
                         /* TODO(ArrayLiteralExpression): [setTextRange(                             context,                             factory.createConstructorDeclaration(                                 factory.createModifiersFromModifierFlags(privateProtected),                                 /*parameters* / [],                                 /*body* / undefined,                             ),                             signatures[0].declaration,                         )] */ TODO
                    }
                }
                results := /* TODO(ArrayLiteralExpression): [] */ TODO
                /* TODO(ForOfStatement): for (const sig of signatures) {                     // Each overload becomes a separate constructor declaration, in order                     const decl = signatureToSignatureDeclarationHelper(sig, outputKind, context);                     results.push(setTextRange(context, decl, sig.declaration));                 } */
                 results
            }
            serializeIndexSignatures := func(input Type, baseType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration[] */ TODO {
                var results []IndexSignatureDeclaration = /* TODO(ArrayLiteralExpression): [] */ TODO
                /* TODO(ForOfStatement): for (const info of getIndexInfosOfType(input)) {                     if (baseType) {                         const baseInfo = getIndexInfoOfType(baseType, info.keyType);                         if (baseInfo) {                             if (isTypeIdenticalTo(info.type, baseInfo.type)) {                                 continue; // elide identical index signatures                             }                         }                     }                     results.push(indexInfoToIndexSignatureDeclarationHelper(info, context, /*typeNode* / undefined));                 } */
                 results
            }
            serializeBaseType := func(t Type, staticType Type, rootName string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments */ TODO {
                ref := trySerializeAsTypeReference(t, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO)
                if ref {
                     ref
                }
                tempName := getUnusedName(/* TODO(TemplateExpression): `${rootName}_base` */ TODO)
                statement := /* TODO(PropertyAccessExpression): factory.createVariableStatement */ TODO(undefined, /* TODO(PropertyAccessExpression): factory.createVariableDeclarationList */ TODO(/* TODO(ArrayLiteralExpression): [                         factory.createVariableDeclaration(tempName, /*exclamationToken* / undefined, typeToTypeNodeHelper(staticType, context)),                     ] */ TODO, /* TODO(PropertyAccessExpression): NodeFlags.Const */ TODO))
                /* TODO(ExpressionStatement): addResult(statement, ModifierFlags.None); */
                 /* TODO(PropertyAccessExpression): factory.createExpressionWithTypeArguments */ TODO(/* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(tempName), undefined)
            }
            trySerializeAsTypeReference := func(t Type, flags SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments | undefined */ TODO {
                var typeArgs /* TODO(ArrayType): TypeNode[] */ any
                var reference *Expression
                if /* TODO(BinaryExpression): (t as TypeReference).target && isSymbolAccessibleByFlags((t as TypeReference).target.symbol, enclosingDeclaration, flags) */ TODO {
                    /* TODO(ExpressionStatement): typeArgs = map(getTypeArguments(t as TypeReference), t => typeToTypeNodeHelper(t, context)); */
                    /* TODO(ExpressionStatement): reference = symbolToExpression((t as TypeReference).target.symbol, context, SymbolFlags.Type); */
                } else if /* TODO(BinaryExpression): t.symbol && isSymbolAccessibleByFlags(t.symbol, enclosingDeclaration, flags) */ TODO {
                    /* TODO(ExpressionStatement): reference = symbolToExpression(t.symbol, context, SymbolFlags.Type); */
                }
                if reference {
                     /* TODO(PropertyAccessExpression): factory.createExpressionWithTypeArguments */ TODO(reference, typeArgs)
                }
            }
            serializeImplementedType := func(t Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments | undefined */ TODO {
                ref := trySerializeAsTypeReference(t, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO)
                if ref {
                     ref
                }
                if /* TODO(PropertyAccessExpression): t.symbol */ TODO {
                     /* TODO(PropertyAccessExpression): factory.createExpressionWithTypeArguments */ TODO(symbolToExpression(/* TODO(PropertyAccessExpression): t.symbol */ TODO, context, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO), undefined)
                }
            }
            getUnusedName := func(input string, symbol Symbol) string {
                id := /* TODO(ConditionalExpression): symbol ? getSymbolId(symbol) : undefined */ TODO
                if id {
                    if /* TODO(PropertyAccessExpression): context.remappedSymbolNames!.has */ TODO(id) {
                         /* TODO(NonNullExpression): context.remappedSymbolNames!.get(id)! */ TODO
                    }
                }
                if symbol {
                    /* TODO(ExpressionStatement): input = getNameCandidateWorker(symbol, input); */
                }
                i := 0
                original := input
                /* TODO(WhileStatement): while (context.usedSymbolNames?.has(input)) {                     i++;                     input = `${original}_${i}`;                 } */
                /* TODO(ExpressionStatement): context.usedSymbolNames?.add(input); */
                if id {
                    /* TODO(ExpressionStatement): context.remappedSymbolNames!.set(id, input); */
                }
                 input
            }
            getNameCandidateWorker := func(symbol Symbol, localName string) /* TODO(undefined): string */ TODO {
                if /* TODO(BinaryExpression): localName === InternalSymbolName.Default || localName === InternalSymbolName.Class || localName === InternalSymbolName.Function */ TODO {
                    restoreFlags := saveRestoreFlags(context)
                    /* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.InInitialEntityName; */
                    nameCandidate := getNameOfSymbolAsWritten(symbol, context)
                    /* TODO(ExpressionStatement): restoreFlags(); */
                    /* TODO(ExpressionStatement): localName = nameCandidate.length > 0 && isSingleOrDoubleQuote(nameCandidate.charCodeAt(0)) ? stripQuotes(nameCandidate) : nameCandidate; */
                }
                if /* TODO(BinaryExpression): localName === InternalSymbolName.Default */ TODO {
                    /* TODO(ExpressionStatement): localName = "_default"; */
                } else if /* TODO(BinaryExpression): localName === InternalSymbolName.ExportEquals */ TODO {
                    /* TODO(ExpressionStatement): localName = "_exports"; */
                }
                /* TODO(ExpressionStatement): localName = isIdentifierText(localName, languageVersion) && !isStringANonContextualKeyword(localName) ? localName : "_" + localName.replace(/[^a-z0-9]/gi, "_"); */
                 localName
            }
            getInternalSymbolName := func(symbol Symbol, localName string) /* TODO(undefined): string */ TODO {
                id := getSymbolId(symbol)
                if /* TODO(PropertyAccessExpression): context.remappedSymbolNames!.has */ TODO(id) {
                     /* TODO(NonNullExpression): context.remappedSymbolNames!.get(id)! */ TODO
                }
                /* TODO(ExpressionStatement): localName = getNameCandidateWorker(symbol, localName); */
                /* TODO(ExpressionStatement): context.remappedSymbolNames!.set(id, localName); */
                 localName
            }
        }
    }
    typePredicateToString := func(typePredicate TypePredicate, enclosingDeclaration Node, flags TypeFormatFlags /* = */ /* TODO(PropertyAccessExpression): TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter) string {
         /* TODO(ConditionalExpression): writer ? typePredicateToStringWorker(writer).getText() : usingSingleLineStringWriter(typePredicateToStringWorker) */ TODO
        typePredicateToStringWorker := func(writer EmitTextWriter) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ TODO {
            nodeBuilderFlags := /* TODO(BinaryExpression): toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | NodeBuilderFlags.WriteTypeParametersInQualifiedName */ TODO
            predicate := /* TODO(NonNullExpression): nodeBuilder.typePredicateToTypePredicateNode(typePredicate, enclosingDeclaration, nodeBuilderFlags)! */ TODO
            printer := createPrinterWithRemoveComments()
            sourceFile := /* TODO(BinaryExpression): enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration) */ TODO
            /* TODO(ExpressionStatement): printer.writeNode(EmitHint.Unspecified, predicate, /*sourceFile* / sourceFile, writer); */
             writer
        }
    }
    formatUnionTypes := func(types []Type) []Type {
        var result []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        flags := 0 /* as */ /* TODO(TypeReference): TypeFlags */
        /* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             const t = types[i];             flags |= t.flags;             if (!(t.flags & TypeFlags.Nullable)) {                 if (t.flags & (TypeFlags.BooleanLiteral | TypeFlags.EnumLike)) {                     const baseType = t.flags & TypeFlags.BooleanLiteral ? booleanType : getBaseTypeOfEnumLikeType(t as LiteralType);                     if (baseType.flags & TypeFlags.Union) {                         const count = (baseType as UnionType).types.length;                         if (i + count <= types.length && getRegularTypeOfLiteralType(types[i + count - 1]) === getRegularTypeOfLiteralType((baseType as UnionType).types[count - 1])) {                             result.push(baseType);                             i += count - 1;                             continue;                         }                     }                 }                 result.push(t);             }         } */
        if /* TODO(BinaryExpression): flags & TypeFlags.Null */ TODO {
            /* TODO(CallExpression): result.push(nullType) */
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.Undefined */ TODO {
            /* TODO(CallExpression): result.push(undefinedType) */
        }
         /* TODO(BinaryExpression): result || types */ TODO
    }
    visibilityToString := func(flags ModifierFlags) string {
        if /* TODO(BinaryExpression): flags === ModifierFlags.Private */ TODO {
             "private"
        }
        if /* TODO(BinaryExpression): flags === ModifierFlags.Protected */ TODO {
             "protected"
        }
         "public"
    }
    getTypeAliasForTypeLiteral := func(type_ Type) *Symbol {
        if /* TODO(BinaryExpression): type.symbol && type.symbol.flags & SymbolFlags.TypeLiteral && type.symbol.declarations */ TODO {
            node := walkUpParenthesizedTypes(/* TODO(PropertyAccessExpression): type.symbol.declarations[0].parent */ TODO)
            if isTypeAliasDeclaration(node) {
                 getSymbolOfDeclaration(node)
            }
        }
         undefined
    }
    isTopLevelInExternalModuleAugmentation := func(node Node) bool {
         /* TODO(BinaryExpression): node && node.parent &&             node.parent.kind === SyntaxKind.ModuleBlock &&             isExternalModuleAugmentation(node.parent.parent) */ TODO
    }
    isDefaultBindingContext := func(location Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): location.kind === SyntaxKind.SourceFile || isAmbientModule(location) */ TODO
    }
    getNameOfSymbolFromNameType := func(symbol Symbol, context NodeBuilderContext) /* TODO(undefined): string | undefined */ TODO {
        nameType := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).nameType */ TODO
        if nameType {
            if /* TODO(BinaryExpression): nameType.flags & TypeFlags.StringOrNumberLiteral */ TODO {
                name := /* TODO(BinaryExpression): "" + (nameType as StringLiteralType | NumberLiteralType).value */ TODO
                if /* TODO(BinaryExpression): !isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && !isNumericLiteralName(name) */ TODO {
                     /* TODO(TemplateExpression): `"${escapeString(name, CharacterCodes.doubleQuote)}"` */ TODO
                }
                if /* TODO(BinaryExpression): isNumericLiteralName(name) && startsWith(name, "-") */ TODO {
                     /* TODO(TemplateExpression): `[${name}]` */ TODO
                }
                 name
            }
            if /* TODO(BinaryExpression): nameType.flags & TypeFlags.UniqueESSymbol */ TODO {
                 /* TODO(TemplateExpression): `[${getNameOfSymbolAsWritten((nameType as UniqueESSymbolType).symbol, context)}]` */ TODO
            }
        }
    }
    getNameOfSymbolAsWritten := func(symbol Symbol, context NodeBuilderContext) string {
        if /* TODO(PropertyAccessExpression): context?.remappedSymbolReferences?.has */ TODO(getSymbolId(symbol)) {
            /* TODO(ExpressionStatement): symbol = context.remappedSymbolReferences.get(getSymbolId(symbol))!; */
        }
        if /* TODO(BinaryExpression): context && symbol.escapedName === InternalSymbolName.Default && !(context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope) &&             // If it's not the first part of an entity name, it must print as `default`             (!(context.flags & NodeBuilderFlags.InInitialEntityName) ||                 // if the symbol is synthesized, it will only be referenced externally it must print as `default`                 !symbol.declarations ||                 // if not in the same binding context (source file, module declaration), it must print as `default`                 (context.enclosingDeclaration && findAncestor(symbol.declarations[0], isDefaultBindingContext) !== findAncestor(context.enclosingDeclaration, isDefaultBindingContext))) */ TODO {
             "default"
        }
        if /* TODO(BinaryExpression): symbol.declarations && symbol.declarations.length */ TODO {
            declaration := firstDefined(/* TODO(PropertyAccessExpression): symbol.declarations */ TODO, /* TODO(ArrowFunction): d => getNameOfDeclaration(d) ? d : undefined */ TODO)
            name := /* TODO(BinaryExpression): declaration && getNameOfDeclaration(declaration) */ TODO
            if /* TODO(BinaryExpression): declaration && name */ TODO {
                if /* TODO(BinaryExpression): isCallExpression(declaration) && isBindableObjectDefinePropertyCall(declaration) */ TODO {
                     symbolName(symbol)
                }
                if /* TODO(BinaryExpression): isComputedPropertyName(name) && !(getCheckFlags(symbol) & CheckFlags.Late) */ TODO {
                    nameType := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).nameType */ TODO
                    if /* TODO(BinaryExpression): nameType && nameType.flags & TypeFlags.StringOrNumberLiteral */ TODO {
                        result := getNameOfSymbolFromNameType(symbol, context)
                        if /* TODO(BinaryExpression): result !== undefined */ TODO {
                             result
                        }
                    }
                }
                 declarationNameToString(name)
            }
            if /* TODO(PrefixUnaryExpression): !declaration */ TODO {
                /* TODO(ExpressionStatement): declaration = symbol.declarations[0]; */
            }
            if /* TODO(BinaryExpression): declaration.parent && declaration.parent.kind === SyntaxKind.VariableDeclaration */ TODO {
                 declarationNameToString(/* TODO(PropertyAccessExpression): (declaration.parent as VariableDeclaration).name */ TODO)
            }
            /* TODO(SwitchStatement): switch (declaration.kind) {                 case SyntaxKind.ClassExpression:                 case SyntaxKind.FunctionExpression:                 case SyntaxKind.ArrowFunction:                     if (context && !context.encounteredError && !(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier)) {                         context.encounteredError = true;                     }                     return declaration.kind === SyntaxKind.ClassExpression ? "(Anonymous class)" : "(Anonymous function)";             } */
        }
        name := getNameOfSymbolFromNameType(symbol, context)
         /* TODO(ConditionalExpression): name !== undefined ? name : symbolName(symbol) */ TODO
    }
    isDeclarationVisible := func(node Node) bool {
        if node {
            links := getNodeLinks(node)
            if /* TODO(BinaryExpression): links.isVisible === undefined */ TODO {
                /* TODO(ExpressionStatement): links.isVisible = !!determineIfDeclarationIsVisible(); */
            }
             /* TODO(PropertyAccessExpression): links.isVisible */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
        determineIfDeclarationIsVisible := func() /* TODO(undefined): boolean */ TODO {
            /* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.JSDocCallbackTag:                 case SyntaxKind.JSDocTypedefTag:                 case SyntaxKind.JSDocEnumTag:                     // Top-level jsdoc type aliases are considered exported                     // First parent is comment node, second is hosting declaration or token; we only care about those tokens or declarations whose parent is a source file                     return !!(node.parent && node.parent.parent && node.parent.parent.parent && isSourceFile(node.parent.parent.parent));                 case SyntaxKind.BindingElement:                     return isDeclarationVisible(node.parent.parent);                 case SyntaxKind.VariableDeclaration:                     if (                         isBindingPattern((node as VariableDeclaration).name) &&                         !((node as VariableDeclaration).name as BindingPattern).elements.length                     ) {                         // If the binding pattern is empty, this variable declaration is not visible                         return false;                     }                     // falls through                 case SyntaxKind.ModuleDeclaration:                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.InterfaceDeclaration:                 case SyntaxKind.TypeAliasDeclaration:                 case SyntaxKind.FunctionDeclaration:                 case SyntaxKind.EnumDeclaration:                 case SyntaxKind.ImportEqualsDeclaration:                     // external module augmentation is always visible                     if (isExternalModuleAugmentation(node)) {                         return true;                     }                     const parent = getDeclarationContainer(node);                     // If the node is not exported or it is not ambient module element (except import declaration)                     if (                         !(getCombinedModifierFlagsCached(node as Declaration) & ModifierFlags.Export) &&                         !(node.kind !== SyntaxKind.ImportEqualsDeclaration && parent.kind !== SyntaxKind.SourceFile && parent.flags & NodeFlags.Ambient)                     ) {                         return isGlobalSourceFile(parent);                     }                     // Exported members/ambient module elements (exception import declaration) are visible if parent is visible                     return isDeclarationVisible(parent);                  case SyntaxKind.PropertyDeclaration:                 case SyntaxKind.PropertySignature:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.MethodSignature:                     if (hasEffectiveModifier(node, ModifierFlags.Private | ModifierFlags.Protected)) {                         // Private/protected properties/methods are not visible                         return false;                     }                     // Public properties/methods are visible if its parents are visible, so:                     // falls through                  case SyntaxKind.Constructor:                 case SyntaxKind.ConstructSignature:                 case SyntaxKind.CallSignature:                 case SyntaxKind.IndexSignature:                 case SyntaxKind.Parameter:                 case SyntaxKind.ModuleBlock:                 case SyntaxKind.FunctionType:                 case SyntaxKind.ConstructorType:                 case SyntaxKind.TypeLiteral:                 case SyntaxKind.TypeReference:                 case SyntaxKind.ArrayType:                 case SyntaxKind.TupleType:                 case SyntaxKind.UnionType:                 case SyntaxKind.IntersectionType:                 case SyntaxKind.ParenthesizedType:                 case SyntaxKind.NamedTupleMember:                     return isDeclarationVisible(node.parent);                  // Default binding, import specifier and namespace import is visible                 // only on demand so by default it is not visible                 case SyntaxKind.ImportClause:                 case SyntaxKind.NamespaceImport:                 case SyntaxKind.ImportSpecifier:                     return false;                  // Type parameters are always visible                 case SyntaxKind.TypeParameter:                  // Source file and namespace export are always visible                 // falls through                 case SyntaxKind.SourceFile:                 case SyntaxKind.NamespaceExportDeclaration:                     return true;                  // Export assignments do not create name bindings outside the module                 case SyntaxKind.ExportAssignment:                     return false;                  default:                     return false;             } */
        }
    }
    collectLinkedAliases := func(node ModuleExportName, setVisibility bool) /* TODO(ArrayType): Node[] */ any {
        var exportSymbol *Symbol
        if /* TODO(BinaryExpression): node.kind !== SyntaxKind.StringLiteral && node.parent && node.parent.kind === SyntaxKind.ExportAssignment */ TODO {
            /* TODO(ExpressionStatement): exportSymbol = resolveName(node, node, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, /*nameNotFoundMessage* / undefined, /*isUse* / false); */
        } else if /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.ExportSpecifier */ TODO {
            /* TODO(ExpressionStatement): exportSymbol = getTargetOfExportSpecifier(node.parent as ExportSpecifier, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias); */
        }
        var result /* TODO(ArrayType): Node[] */ any
        var visited *Set[number]
        if exportSymbol {
            /* TODO(ExpressionStatement): visited = new Set(); */
            /* TODO(ExpressionStatement): visited.add(getSymbolId(exportSymbol)); */
            /* TODO(ExpressionStatement): buildVisibleNodeList(exportSymbol.declarations); */
        }
         result
        buildVisibleNodeList := func(declarations /* TODO(ArrayType): Declaration[] */ any) {
            /* TODO(ExpressionStatement): forEach(declarations, declaration => {                 const resultNode = getAnyImportSyntax(declaration) || declaration;                 if (setVisibility) {                     getNodeLinks(declaration).isVisible = true;                 }                 else {                     result = result || [];                     pushIfUnique(result, resultNode);                 }                  if (isInternalModuleImportEqualsDeclaration(declaration)) {                     // Add the referenced top container visible                     const internalModuleReference = declaration.moduleReference as Identifier | QualifiedName;                     const firstIdentifier = getFirstIdentifier(internalModuleReference);                     const importSymbol = resolveName(declaration, firstIdentifier.escapedText, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*nameNotFoundMessage* / undefined, /*isUse* / false);                     if (importSymbol && visited) {                         if (tryAddToSet(visited, getSymbolId(importSymbol))) {                             buildVisibleNodeList(importSymbol.declarations);                         }                     }                 }             }); */
        }
    }
    pushTypeResolution := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
        resolutionCycleStartIndex := findResolutionCycleStartIndex(target, propertyName)
        if /* TODO(BinaryExpression): resolutionCycleStartIndex >= 0 */ TODO {
            TODO_IDENTIFIER := resolutionTargets
            /* TODO(ForStatement): for (let i = resolutionCycleStartIndex; i < length; i++) {                 resolutionResults[i] = false;             } */
             /* TODO(FalseKeyword): false */ TODO
        }
        /* TODO(ExpressionStatement): resolutionTargets.push(target); */
        /* TODO(ExpressionStatement): resolutionResults.push(/*items* / true); */
        /* TODO(ExpressionStatement): resolutionPropertyNames.push(propertyName); */
         /* TODO(TrueKeyword): true */ TODO
    }
    findResolutionCycleStartIndex := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) number {
        /* TODO(ForStatement): for (let i = resolutionTargets.length - 1; i >= resolutionStart; i--) {             if (resolutionTargetHasProperty(resolutionTargets[i], resolutionPropertyNames[i])) {                 return -1;             }             if (resolutionTargets[i] === target && resolutionPropertyNames[i] === propertyName) {                 return i;             }         } */
         /* TODO(PrefixUnaryExpression): -1 */ TODO
    }
    resolutionTargetHasProperty := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
        /* TODO(SwitchStatement): switch (propertyName) {             case TypeSystemPropertyName.Type:                 return !!getSymbolLinks(target as Symbol).type;             case TypeSystemPropertyName.DeclaredType:                 return !!getSymbolLinks(target as Symbol).declaredType;             case TypeSystemPropertyName.ResolvedBaseConstructorType:                 return !!(target as InterfaceType).resolvedBaseConstructorType;             case TypeSystemPropertyName.ResolvedReturnType:                 return !!(target as Signature).resolvedReturnType;             case TypeSystemPropertyName.ImmediateBaseConstraint:                 return !!(target as Type).immediateBaseConstraint;             case TypeSystemPropertyName.ResolvedTypeArguments:                 return !!(target as TypeReference).resolvedTypeArguments;             case TypeSystemPropertyName.ResolvedBaseTypes:                 return !!(target as InterfaceType).baseTypesResolved;             case TypeSystemPropertyName.WriteType:                 return !!getSymbolLinks(target as Symbol).writeType;             case TypeSystemPropertyName.ParameterInitializerContainsUndefined:                 return getNodeLinks(target as ParameterDeclaration).parameterInitializerContainsUndefined !== undefined;         } */
         /* TODO(PropertyAccessExpression): Debug.assertNever */ TODO(propertyName)
    }
    popTypeResolution := func() bool {
        /* TODO(ExpressionStatement): resolutionTargets.pop(); */
        /* TODO(ExpressionStatement): resolutionPropertyNames.pop(); */
         /* TODO(NonNullExpression): resolutionResults.pop()! */ TODO
    }
    getDeclarationContainer := func(node Node) Node {
         /* TODO(PropertyAccessExpression): findAncestor(getRootDeclaration(node), node => {             switch (node.kind) {                 case SyntaxKind.VariableDeclaration:                 case SyntaxKind.VariableDeclarationList:                 case SyntaxKind.ImportSpecifier:                 case SyntaxKind.NamedImports:                 case SyntaxKind.NamespaceImport:                 case SyntaxKind.ImportClause:                     return false;                 default:                     return true;             }         })!.parent */ TODO
    }
    getTypeOfPrototypeProperty := func(prototype Symbol) Type {
        classType := getDeclaredTypeOfSymbol(/* TODO(NonNullExpression): getParentOfSymbol(prototype)! */ TODO) /* as */ /* TODO(TypeReference): InterfaceType */
         /* TODO(ConditionalExpression): classType.typeParameters ? createTypeReference(classType as GenericType, map(classType.typeParameters, _ => anyType)) : classType */ TODO
    }
    getTypeOfPropertyOfType := func(type_ Type, name __String) *Type {
        prop := getPropertyOfType(type_, name)
         /* TODO(ConditionalExpression): prop ? getTypeOfSymbol(prop) : undefined */ TODO
    }
    getTypeOfPropertyOrIndexSignatureOfType := func(type_ Type, name __String) *Type {
        propType
         /* TODO(BinaryExpression): getTypeOfPropertyOfType(type, name) ||             (propType = getApplicableIndexInfoForName(type, name)?.type) &&                 addOptionality(propType, /*isProperty* / true, /*isOptional* / true) */ TODO
    }
    isTypeAny := func(type_ *Type) /* TODO(undefined): boolean | undefined */ TODO {
         /* TODO(BinaryExpression): type && (type.flags & TypeFlags.Any) !== 0 */ TODO
    }
    isErrorType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): type === errorType || !!(type.flags & TypeFlags.Any && type.aliasSymbol) */ TODO
    }
    getTypeForBindingElementParent := func(node BindingElementGrandparent, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(BinaryExpression): checkMode !== CheckMode.Normal */ TODO {
             getTypeForVariableLikeDeclaration(node, /* TODO(FalseKeyword): false */ TODO, checkMode)
        }
        symbol := getSymbolOfDeclaration(node)
         /* TODO(BinaryExpression): symbol && getSymbolLinks(symbol).type || getTypeForVariableLikeDeclaration(node, /*includeOptionality* / false, checkMode) */ TODO
    }
    getRestType := func(source Type, properties []PropertyName, symbol *Symbol) Type {
        /* TODO(ExpressionStatement): source = filterType(source, t => !(t.flags & TypeFlags.Nullable)); */
        if /* TODO(BinaryExpression): source.flags & TypeFlags.Never */ TODO {
             emptyObjectType
        }
        if /* TODO(BinaryExpression): source.flags & TypeFlags.Union */ TODO {
             mapType(source, /* TODO(ArrowFunction): t => getRestType(t, properties, symbol) */ TODO)
        }
        omitKeyType := getUnionType(map_(properties, getLiteralTypeFromPropertyName))
        var spreadableProperties []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
        var unspreadableToRestKeys []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForOfStatement): for (const prop of getPropertiesOfType(source)) {             const literalTypeFromProperty = getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique);             if (                 !isTypeAssignableTo(literalTypeFromProperty, omitKeyType)                 && !(getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlags.Private | ModifierFlags.Protected))                 && isSpreadableProperty(prop)             ) {                 spreadableProperties.push(prop);             }             else {                 unspreadableToRestKeys.push(literalTypeFromProperty);             }         } */
        if /* TODO(BinaryExpression): isGenericObjectType(source) || isGenericIndexType(omitKeyType) */ TODO {
            if /* TODO(PropertyAccessExpression): unspreadableToRestKeys.length */ TODO {
                /* TODO(ExpressionStatement): omitKeyType = getUnionType([omitKeyType, ...unspreadableToRestKeys]); */
            }
            if /* TODO(BinaryExpression): omitKeyType.flags & TypeFlags.Never */ TODO {
                 source
            }
            omitTypeAlias := getGlobalOmitSymbol()
            if /* TODO(PrefixUnaryExpression): !omitTypeAlias */ TODO {
                 errorType
            }
             getTypeAliasInstantiation(omitTypeAlias, /* TODO(ArrayLiteralExpression): [source, omitKeyType] */ TODO)
        }
        members := createSymbolTable()
        /* TODO(ForOfStatement): for (const prop of spreadableProperties) {             members.set(prop.escapedName, getSpreadSymbol(prop, /*readonly* / false));         } */
        result := createAnonymousType(symbol, members, emptyArray, emptyArray, getIndexInfosOfType(source))
        /* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.ObjectRestType; */
         result
    }
    isGenericTypeWithUndefinedConstraint := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !!(type.flags & TypeFlags.Instantiable) && maybeTypeOfKind(getBaseConstraintOfType(type) || unknownType, TypeFlags.Undefined) */ TODO
    }
    getNonUndefinedType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        typeOrConstraint := /* TODO(ConditionalExpression): someType(type, isGenericTypeWithUndefinedConstraint) ? mapType(type, t => t.flags & TypeFlags.Instantiable ? getBaseConstraintOrType(t) : t) : type */ TODO
         getTypeWithFacts(typeOrConstraint, /* TODO(PropertyAccessExpression): TypeFacts.NEUndefined */ TODO)
    }
    getFlowTypeOfDestructuring := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any, declaredType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        reference := getSyntheticElementAccess(node)
         /* TODO(ConditionalExpression): reference ? getFlowTypeOfReference(reference, declaredType) : declaredType */ TODO
    }
    getSyntheticElementAccess := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) *ElementAccessExpression {
        parentAccess := getParentElementAccess(node)
        if /* TODO(BinaryExpression): parentAccess && canHaveFlowNode(parentAccess) && parentAccess.flowNode */ TODO {
            propName := getDestructuringPropertyName(node)
            if propName {
                literal := setTextRangeWorker(/* TODO(PropertyAccessExpression): parseNodeFactory.createStringLiteral */ TODO(propName), node)
                lhsExpr := /* TODO(ConditionalExpression): isLeftHandSideExpression(parentAccess) ? parentAccess : parseNodeFactory.createParenthesizedExpression(parentAccess) */ TODO
                result := setTextRangeWorker(/* TODO(PropertyAccessExpression): parseNodeFactory.createElementAccessExpression */ TODO(lhsExpr, literal), node)
                /* TODO(ExpressionStatement): setParent(literal, result); */
                /* TODO(ExpressionStatement): setParent(result, node); */
                if /* TODO(BinaryExpression): lhsExpr !== parentAccess */ TODO {
                    /* TODO(ExpressionStatement): setParent(lhsExpr, result); */
                }
                /* TODO(ExpressionStatement): result.flowNode = parentAccess.flowNode; */
                 result
            }
        }
    }
    getParentElementAccess := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ TODO {
        ancestor := /* TODO(PropertyAccessExpression): node.parent.parent */ TODO
        /* TODO(SwitchStatement): switch (ancestor.kind) {             case SyntaxKind.BindingElement:             case SyntaxKind.PropertyAssignment:                 return getSyntheticElementAccess(ancestor as BindingElement | PropertyAssignment);             case SyntaxKind.ArrayLiteralExpression:                 return getSyntheticElementAccess(node.parent as Expression);             case SyntaxKind.VariableDeclaration:                 return (ancestor as VariableDeclaration).initializer;             case SyntaxKind.BinaryExpression:                 return (ancestor as BinaryExpression).right;         } */
    }
    getDestructuringPropertyName := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) /* TODO(undefined): string | undefined */ TODO {
        parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.BindingElement && parent.kind === SyntaxKind.ObjectBindingPattern */ TODO {
             getLiteralPropertyNameText(/* TODO(BinaryExpression): (node as BindingElement).propertyName || (node as BindingElement).name as Identifier */ TODO)
        }
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.PropertyAssignment || node.kind === SyntaxKind.ShorthandPropertyAssignment */ TODO {
             getLiteralPropertyNameText(/* TODO(PropertyAccessExpression): (node as PropertyAssignment | ShorthandPropertyAssignment).name */ TODO)
        }
         /* TODO(BinaryExpression): "" + ((parent as BindingPattern | ArrayLiteralExpression).elements as NodeArray<Node>).indexOf(node) */ TODO
    }
    getLiteralPropertyNameText := func(name PropertyName) /* TODO(undefined): string | undefined */ TODO {
        type_ := getLiteralTypeFromPropertyName(name)
         /* TODO(ConditionalExpression): type.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral) ? "" + (type as StringLiteralType | NumberLiteralType).value : undefined */ TODO
    }
    getTypeForBindingElement := func(declaration BindingElement) *Type {
        checkMode := /* TODO(ConditionalExpression): declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */ TODO
        parentType := getTypeForBindingElementParent(/* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO, checkMode)
         /* TODO(BinaryExpression): parentType && getBindingElementTypeFromParentType(declaration, parentType, /*noTupleBoundsCheck* / false) */ TODO
    }
    getBindingElementTypeFromParentType := func(declaration BindingElement, parentType Type, noTupleBoundsCheck bool) Type {
        if isTypeAny(parentType) {
             parentType
        }
        pattern := /* TODO(PropertyAccessExpression): declaration.parent */ TODO
        if /* TODO(BinaryExpression): strictNullChecks && declaration.flags & NodeFlags.Ambient && isPartOfParameterDeclaration(declaration) */ TODO {
            /* TODO(ExpressionStatement): parentType = getNonNullableType(parentType); */
        } else if /* TODO(BinaryExpression): strictNullChecks && pattern.parent.initializer && !(hasTypeFacts(getTypeOfInitializer(pattern.parent.initializer), TypeFacts.EQUndefined)) */ TODO {
            /* TODO(ExpressionStatement): parentType = getTypeWithFacts(parentType, TypeFacts.NEUndefined); */
        }
        accessFlags := /* TODO(BinaryExpression): AccessFlags.ExpressionPosition | (noTupleBoundsCheck || hasDefaultValue(declaration) ? AccessFlags.AllowMissing : 0) */ TODO
        var type_ *Type
        if /* TODO(BinaryExpression): pattern.kind === SyntaxKind.ObjectBindingPattern */ TODO {
            if /* TODO(PropertyAccessExpression): declaration.dotDotDotToken */ TODO {
                /* TODO(ExpressionStatement): parentType = getReducedType(parentType); */
                if /* TODO(BinaryExpression): parentType.flags & TypeFlags.Unknown || !isValidSpreadType(parentType) */ TODO {
                    /* TODO(ExpressionStatement): error(declaration, Diagnostics.Rest_types_may_only_be_created_from_object_types); */
                     errorType
                }
                var literalMembers []PropertyName = /* TODO(ArrayLiteralExpression): [] */ TODO
                /* TODO(ForOfStatement): for (const element of pattern.elements) {                     if (!element.dotDotDotToken) {                         literalMembers.push(element.propertyName || element.name as Identifier);                     }                 } */
                /* TODO(ExpressionStatement): type = getRestType(parentType, literalMembers, declaration.symbol); */
            } else {
                name := /* TODO(BinaryExpression): declaration.propertyName || declaration.name as Identifier */ TODO
                indexType := getLiteralTypeFromPropertyName(name)
                declaredType := getIndexedAccessType(parentType, indexType, accessFlags, name)
                /* TODO(ExpressionStatement): type = getFlowTypeOfDestructuring(declaration, declaredType); */
            }
        } else {
            elementType := checkIteratedTypeOrElementType(/* TODO(BinaryExpression): IterationUse.Destructuring | (declaration.dotDotDotToken ? 0 : IterationUse.PossiblyOutOfBounds) */ TODO, parentType, undefinedType, pattern)
            index := /* TODO(PropertyAccessExpression): pattern.elements.indexOf */ TODO(declaration)
            if /* TODO(PropertyAccessExpression): declaration.dotDotDotToken */ TODO {
                baseConstraint := mapType(parentType, /* TODO(ArrowFunction): t => t.flags & TypeFlags.InstantiableNonPrimitive ? getBaseConstraintOrType(t) : t */ TODO)
                /* TODO(ExpressionStatement): type = everyType(baseConstraint, isTupleType) ?                     mapType(baseConstraint, t => sliceTupleType(t as TupleTypeReference, index)) :                     createArrayType(elementType); */
            } else if isArrayLikeType(parentType) {
                indexType := getNumberLiteralType(index)
                declaredType := /* TODO(BinaryExpression): getIndexedAccessTypeOrUndefined(parentType, indexType, accessFlags, declaration.name) || errorType */ TODO
                /* TODO(ExpressionStatement): type = getFlowTypeOfDestructuring(declaration, declaredType); */
            } else {
                /* TODO(ExpressionStatement): type = elementType; */
            }
        }
        if /* TODO(PrefixUnaryExpression): !declaration.initializer */ TODO {
             type_
        }
        if getEffectiveTypeAnnotationNode(walkUpBindingElementsAndPatterns(declaration)) {
             /* TODO(ConditionalExpression): strictNullChecks && !(hasTypeFacts(checkDeclarationInitializer(declaration, CheckMode.Normal), TypeFacts.IsUndefined)) ? getNonUndefinedType(type) : type */ TODO
        }
         widenTypeInferredFromInitializer(declaration, getUnionType(/* TODO(ArrayLiteralExpression): [getNonUndefinedType(type), checkDeclarationInitializer(declaration, CheckMode.Normal)] */ TODO, /* TODO(PropertyAccessExpression): UnionReduction.Subtype */ TODO))
    }
    getTypeForDeclarationFromJSDocComment := func(declaration Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        jsdocType := getJSDocType(declaration)
        if jsdocType {
             getTypeFromTypeNode(jsdocType)
        }
         undefined
    }
    isNullOrUndefined := func(node Expression) /* TODO(undefined): boolean */ TODO {
        expr := skipParentheses(node, /* TODO(TrueKeyword): true */ TODO)
         /* TODO(BinaryExpression): expr.kind === SyntaxKind.NullKeyword || expr.kind === SyntaxKind.Identifier && getResolvedSymbol(expr as Identifier) === undefinedSymbol */ TODO
    }
    isEmptyArrayLiteral := func(node Expression) /* TODO(undefined): boolean */ TODO {
        expr := skipParentheses(node, /* TODO(TrueKeyword): true */ TODO)
         /* TODO(BinaryExpression): expr.kind === SyntaxKind.ArrayLiteralExpression && (expr as ArrayLiteralExpression).elements.length === 0 */ TODO
    }
    addOptionality := func(type_ Type, isProperty /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, isOptional /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) Type {
         /* TODO(ConditionalExpression): strictNullChecks && isOptional ? getOptionalType(type, isProperty) : type */ TODO
    }
    getTypeForVariableLikeDeclaration := func(declaration /* TODO(UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, includeOptionality bool, checkMode CheckMode) *Type {
        if /* TODO(BinaryExpression): isVariableDeclaration(declaration) && declaration.parent.parent.kind === SyntaxKind.ForInStatement */ TODO {
            indexType := getIndexType(getNonNullableTypeIfNeeded(checkExpression(/* TODO(PropertyAccessExpression): declaration.parent.parent.expression */ TODO, checkMode)))
             /* TODO(ConditionalExpression): indexType.flags & (TypeFlags.TypeParameter | TypeFlags.Index) ? getExtractStringType(indexType) : stringType */ TODO
        }
        if /* TODO(BinaryExpression): isVariableDeclaration(declaration) && declaration.parent.parent.kind === SyntaxKind.ForOfStatement */ TODO {
            forOfStatement := /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO
             /* TODO(BinaryExpression): checkRightHandSideOfForOf(forOfStatement) || anyType */ TODO
        }
        if isBindingPattern(/* TODO(PropertyAccessExpression): declaration.parent */ TODO) {
             getTypeForBindingElement(declaration /* as */ /* TODO(TypeReference): BindingElement */)
        }
        isProperty := /* TODO(BinaryExpression): (isPropertyDeclaration(declaration) && !hasAccessorModifier(declaration)) || isPropertySignature(declaration) || isJSDocPropertyTag(declaration) */ TODO
        isOptional := /* TODO(BinaryExpression): includeOptionality && isOptionalDeclaration(declaration) */ TODO
        declaredType := tryGetTypeFromEffectiveTypeNode(declaration)
        if isCatchClauseVariableDeclarationOrBindingElement(declaration) {
            if declaredType {
                 /* TODO(ConditionalExpression): isTypeAny(declaredType) || declaredType === unknownType ? declaredType : errorType */ TODO
            }
             /* TODO(ConditionalExpression): useUnknownInCatchVariables ? unknownType : anyType */ TODO
        }
        if declaredType {
             addOptionality(declaredType, isProperty, isOptional)
        }
        if /* TODO(BinaryExpression): (noImplicitAny || isInJSFile(declaration)) &&             isVariableDeclaration(declaration) && !isBindingPattern(declaration.name) &&             !(getCombinedModifierFlagsCached(declaration) & ModifierFlags.Export) && !(declaration.flags & NodeFlags.Ambient) */ TODO {
            if /* TODO(BinaryExpression): !(getCombinedNodeFlagsCached(declaration) & NodeFlags.Constant) && (!declaration.initializer || isNullOrUndefined(declaration.initializer)) */ TODO {
                 autoType
            }
            if /* TODO(BinaryExpression): declaration.initializer && isEmptyArrayLiteral(declaration.initializer) */ TODO {
                 autoArrayType
            }
        }
        if isParameter(declaration) {
            if /* TODO(PrefixUnaryExpression): !declaration.symbol */ TODO {

            }
            func_ := /* TODO(PropertyAccessExpression): declaration.parent */ TODO /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */
            if /* TODO(BinaryExpression): func.kind === SyntaxKind.SetAccessor && hasBindableName(func) */ TODO {
                getter := getDeclarationOfKind(getSymbolOfDeclaration(/* TODO(PropertyAccessExpression): declaration.parent */ TODO), /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */ TODO)
                if getter {
                    getterSignature := getSignatureFromDeclaration(getter)
                    thisParameter := getAccessorThisParameter(func_ /* as */ /* TODO(TypeReference): AccessorDeclaration */)
                    if /* TODO(BinaryExpression): thisParameter && declaration === thisParameter */ TODO {
                        /* TODO(ExpressionStatement): Debug.assert(!thisParameter.type); */
                         getTypeOfSymbol(/* TODO(NonNullExpression): getterSignature.thisParameter! */ TODO)
                    }
                     getReturnTypeOfSignature(getterSignature)
                }
            }
            parameterTypeOfTypeTag := getParameterTypeOfTypeTag(func_, declaration)
            if parameterTypeOfTypeTag {
                /* TODO(Identifier): parameterTypeOfTypeTag */
            }
            type_ := /* TODO(ConditionalExpression): declaration.symbol.escapedName === InternalSymbolName.This ? getContextualThisParameterType(func) : getContextuallyTypedParameterType(declaration) */ TODO
            if type_ {
                 addOptionality(type_, /* TODO(FalseKeyword): false */ TODO, isOptional)
            }
        }
        if /* TODO(BinaryExpression): hasOnlyExpressionInitializer(declaration) && !!declaration.initializer */ TODO {
            if /* TODO(BinaryExpression): isInJSFile(declaration) && !isParameter(declaration) */ TODO {
                containerObjectType := getJSContainerObjectType(declaration, getSymbolOfDeclaration(declaration), getDeclaredExpandoInitializer(declaration))
                if containerObjectType {
                     containerObjectType
                }
            }
            type_ := widenTypeInferredFromInitializer(declaration, checkDeclarationInitializer(declaration, checkMode))
             addOptionality(type_, isProperty, isOptional)
        }
        if /* TODO(BinaryExpression): isPropertyDeclaration(declaration) && (noImplicitAny || isInJSFile(declaration)) */ TODO {
            if /* TODO(PrefixUnaryExpression): !hasStaticModifier(declaration) */ TODO {
                constructor := findConstructorDeclaration(/* TODO(PropertyAccessExpression): declaration.parent */ TODO)
                type_ := /* TODO(ConditionalExpression): constructor ? getFlowTypeInConstructor(declaration.symbol, constructor) :                     getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :                     undefined */ TODO
                 /* TODO(BinaryExpression): type && addOptionality(type, /*isProperty* / true, isOptional) */ TODO
            } else {
                staticBlocks := filter(/* TODO(PropertyAccessExpression): declaration.parent.members */ TODO, isClassStaticBlockDeclaration)
                type_ := /* TODO(ConditionalExpression): staticBlocks.length ? getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks) :                     getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :                     undefined */ TODO
                 /* TODO(BinaryExpression): type && addOptionality(type, /*isProperty* / true, isOptional) */ TODO
            }
        }
        if isJsxAttribute(declaration) {
             trueType
        }
        if isBindingPattern(/* TODO(PropertyAccessExpression): declaration.name */ TODO) {
             getTypeFromBindingPattern(/* TODO(PropertyAccessExpression): declaration.name */ TODO, /* TODO(FalseKeyword): false */ TODO, /* TODO(TrueKeyword): true */ TODO)
        }
         undefined
    }
    isConstructorDeclaredProperty := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration) */ TODO {
            links := getSymbolLinks(symbol)
            if /* TODO(BinaryExpression): links.isConstructorDeclaredProperty === undefined */ TODO {
                /* TODO(ExpressionStatement): links.isConstructorDeclaredProperty = false; */
                /* TODO(ExpressionStatement): links.isConstructorDeclaredProperty = !!getDeclaringConstructor(symbol) && every(symbol.declarations, declaration =>                     isBinaryExpression(declaration) &&                     isPossiblyAliasedThisProperty(declaration) &&                     (declaration.left.kind !== SyntaxKind.ElementAccessExpression || isStringOrNumericLiteralLike((declaration.left as ElementAccessExpression).argumentExpression)) &&                     !getAnnotatedTypeForAssignmentDeclaration(/*declaredType* / undefined, declaration, symbol, declaration)); */
            }
             /* TODO(PropertyAccessExpression): links.isConstructorDeclaredProperty */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isAutoTypedProperty := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
        declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
         /* TODO(BinaryExpression): declaration && isPropertyDeclaration(declaration) && !getEffectiveTypeAnnotationNode(declaration) &&             !declaration.initializer && (noImplicitAny || isInJSFile(declaration)) */ TODO
    }
    getDeclaringConstructor := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorDeclaration | undefined */ TODO {
        if /* TODO(PrefixUnaryExpression): !symbol.declarations */ TODO {

        }
        /* TODO(ForOfStatement): for (const declaration of symbol.declarations) {             const container = getThisContainer(declaration, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false);             if (container && (container.kind === SyntaxKind.Constructor || isJSConstructor(container))) {                 return container as ConstructorDeclaration;             }         } */
    }
    getFlowTypeFromCommonJSExport := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        file := getSourceFileOfNode(/* TODO(ElementAccessExpression): symbol.declarations![0] */ TODO)
        accessName := unescapeLeadingUnderscores(/* TODO(PropertyAccessExpression): symbol.escapedName */ TODO)
        areAllModuleExports := /* TODO(PropertyAccessExpression): symbol.declarations!.every */ TODO(/* TODO(ArrowFunction): d => isInJSFile(d) && isAccessExpression(d) && isModuleExportsAccessExpression(d.expression) */ TODO)
        reference := /* TODO(ConditionalExpression): areAllModuleExports             ? factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(factory.createIdentifier("module"), factory.createIdentifier("exports")), accessName)             : factory.createPropertyAccessExpression(factory.createIdentifier("exports"), accessName) */ TODO
        if areAllModuleExports {
            /* TODO(ExpressionStatement): setParent((reference.expression as PropertyAccessExpression).expression, reference.expression); */
        }
        /* TODO(ExpressionStatement): setParent(reference.expression, reference); */
        /* TODO(ExpressionStatement): setParent(reference, file); */
        /* TODO(ExpressionStatement): reference.flowNode = file.endFlowNode; */
         getFlowTypeOfReference(reference, autoType, undefinedType)
    }
    getFlowTypeInStaticBlocks := func(symbol Symbol, staticBlocks []ClassStaticBlockDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        accessName := /* TODO(ConditionalExpression): startsWith(symbol.escapedName as string, "__#")             ? factory.createPrivateIdentifier((symbol.escapedName as string).split("@")[1])             : unescapeLeadingUnderscores(symbol.escapedName) */ TODO
        /* TODO(ForOfStatement): for (const staticBlock of staticBlocks) {             const reference = factory.createPropertyAccessExpression(factory.createThis(), accessName);             setParent(reference.expression, reference);             setParent(reference, staticBlock);             reference.flowNode = staticBlock.returnFlowNode;             const flowType = getFlowTypeOfProperty(reference, symbol);             if (noImplicitAny && (flowType === autoType || flowType === autoArrayType)) {                 error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));             }             // We don't infer a type if assignments are only null or undefined.             if (everyType(flowType, isNullableType)) {                 continue;             }             return convertAutoToAny(flowType);         } */
    }
    getFlowTypeInConstructor := func(symbol Symbol, constructor ConstructorDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        accessName := /* TODO(ConditionalExpression): startsWith(symbol.escapedName as string, "__#")             ? factory.createPrivateIdentifier((symbol.escapedName as string).split("@")[1])             : unescapeLeadingUnderscores(symbol.escapedName) */ TODO
        reference := /* TODO(PropertyAccessExpression): factory.createPropertyAccessExpression */ TODO(/* TODO(PropertyAccessExpression): factory.createThis */ TODO(), accessName)
        /* TODO(ExpressionStatement): setParent(reference.expression, reference); */
        /* TODO(ExpressionStatement): setParent(reference, constructor); */
        /* TODO(ExpressionStatement): reference.flowNode = constructor.returnFlowNode; */
        flowType := getFlowTypeOfProperty(reference, symbol)
        if /* TODO(BinaryExpression): noImplicitAny && (flowType === autoType || flowType === autoArrayType) */ TODO {
            /* TODO(ExpressionStatement): error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType)); */
        }
         /* TODO(ConditionalExpression): everyType(flowType, isNullableType) ? undefined : convertAutoToAny(flowType) */ TODO
    }
    getFlowTypeOfProperty := func(reference Node, prop *Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        initialType := /* TODO(BinaryExpression): prop?.valueDeclaration                 && (!isAutoTypedProperty(prop) || getEffectiveModifierFlags(prop.valueDeclaration) & ModifierFlags.Ambient)                 && getTypeOfPropertyInBaseClass(prop)             || undefinedType */ TODO
         getFlowTypeOfReference(reference, autoType, initialType)
    }
    getWidenedTypeForAssignmentDeclaration := func(symbol Symbol, resolvedSymbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        container := getAssignedExpandoInitializer(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
        if container {
            tag := /* TODO(ConditionalExpression): isInJSFile(container) ? getJSDocTypeTag(container) : undefined */ TODO
            if /* TODO(BinaryExpression): tag && tag.typeExpression */ TODO {
                 getTypeFromTypeNode(/* TODO(PropertyAccessExpression): tag.typeExpression */ TODO)
            }
            containerObjectType := /* TODO(BinaryExpression): symbol.valueDeclaration && getJSContainerObjectType(symbol.valueDeclaration, symbol, container) */ TODO
             /* TODO(BinaryExpression): containerObjectType || getWidenedLiteralType(checkExpressionCached(container)) */ TODO
        }
        type_
        definedInConstructor := /* TODO(FalseKeyword): false */ TODO
        definedInMethod := /* TODO(FalseKeyword): false */ TODO
        if isConstructorDeclaredProperty(symbol) {
            /* TODO(ExpressionStatement): type = getFlowTypeInConstructor(symbol, getDeclaringConstructor(symbol)!); */
        }
        if /* TODO(PrefixUnaryExpression): !type */ TODO {
            var types /* TODO(ArrayType): Type[] */ any
            if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
                var jsdocType *Type
                /* TODO(ForOfStatement): for (const declaration of symbol.declarations) {                     const expression = (isBinaryExpression(declaration) || isCallExpression(declaration)) ? declaration :                         isAccessExpression(declaration) ? isBinaryExpression(declaration.parent) ? declaration.parent : declaration :                         undefined;                     if (!expression) {                         continue; // Non-assignment declaration merged in (eg, an Identifier to mark the thing as a namespace) - skip over it and pull type info from elsewhere                     }                      const kind = isAccessExpression(expression)                         ? getAssignmentDeclarationPropertyAccessKind(expression)                         : getAssignmentDeclarationKind(expression);                     if (kind === AssignmentDeclarationKind.ThisProperty || isBinaryExpression(expression) && isPossiblyAliasedThisProperty(expression, kind)) {                         if (isDeclarationInConstructor(expression)) {                             definedInConstructor = true;                         }                         else {                             definedInMethod = true;                         }                     }                     if (!isCallExpression(expression)) {                         jsdocType = getAnnotatedTypeForAssignmentDeclaration(jsdocType, expression, symbol, declaration);                     }                     if (!jsdocType) {                         (types || (types = [])).push((isBinaryExpression(expression) || isCallExpression(expression)) ? getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) : neverType);                     }                 } */
                /* TODO(ExpressionStatement): type = jsdocType; */
            }
            if /* TODO(PrefixUnaryExpression): !type */ TODO {
                if /* TODO(PrefixUnaryExpression): !length(types) */ TODO {
                     errorType
                }
                constructorTypes := /* TODO(ConditionalExpression): definedInConstructor && symbol.declarations ? getConstructorDefinedThisAssignmentTypes(types!, symbol.declarations) : undefined */ TODO
                if definedInMethod {
                    propType := getTypeOfPropertyInBaseClass(symbol)
                    if propType {
                        /* TODO(ExpressionStatement): (constructorTypes || (constructorTypes = [])).push(propType); */
                        /* TODO(ExpressionStatement): definedInConstructor = true; */
                    }
                }
                sourceTypes := /* TODO(ConditionalExpression): some(constructorTypes, t => !!(t.flags & ~TypeFlags.Nullable)) ? constructorTypes : types */ TODO
                /* TODO(ExpressionStatement): type = getUnionType(sourceTypes!); */
            }
        }
        widened := getWidenedType(addOptionality(type_, /* TODO(FalseKeyword): false */ TODO, /* TODO(BinaryExpression): definedInMethod && !definedInConstructor */ TODO))
        if /* TODO(BinaryExpression): symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && filterType(widened, t => !!(t.flags & ~TypeFlags.Nullable)) === neverType */ TODO {
            /* TODO(ExpressionStatement): reportImplicitAny(symbol.valueDeclaration, anyType); */
             anyType
        }
         widened
    }
    getJSContainerObjectType := func(decl Node, symbol Symbol, init *Expression) *Type {
        if /* TODO(BinaryExpression): !isInJSFile(decl) || !init || !isObjectLiteralExpression(init) || init.properties.length */ TODO {
             undefined
        }
        exports := createSymbolTable()
        /* TODO(WhileStatement): while (isBinaryExpression(decl) || isPropertyAccessExpression(decl)) {             const s = getSymbolOfNode(decl);             if (s?.exports?.size) {                 mergeSymbolTable(exports, s.exports);             }             decl = isBinaryExpression(decl) ? decl.parent : decl.parent.parent;         } */
        s := getSymbolOfNode(decl)
        if /* TODO(PropertyAccessExpression): s?.exports?.size */ TODO {
            /* TODO(ExpressionStatement): mergeSymbolTable(exports, s.exports); */
        }
        type_ := createAnonymousType(symbol, exports, emptyArray, emptyArray, emptyArray)
        /* TODO(ExpressionStatement): type.objectFlags |= ObjectFlags.JSLiteral; */
         type_
    }
    getAnnotatedTypeForAssignmentDeclaration := func(declaredType *Type, expression Expression, symbol Symbol, declaration Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        typeNode := getEffectiveTypeAnnotationNode(/* TODO(PropertyAccessExpression): expression.parent */ TODO)
        if typeNode {
            type_ := getWidenedType(getTypeFromTypeNode(typeNode))
            if /* TODO(PrefixUnaryExpression): !declaredType */ TODO {
                 type_
            } else if /* TODO(BinaryExpression): !isErrorType(declaredType) && !isErrorType(type) && !isTypeIdenticalTo(declaredType, type) */ TODO {
                /* TODO(ExpressionStatement): errorNextVariableOrPropertyDeclarationMustHaveSameType(/*firstDeclaration* / undefined, declaredType, declaration, type); */
            }
        }
        if /* TODO(PropertyAccessExpression): symbol.parent?.valueDeclaration */ TODO {
            possiblyAnnotatedSymbol := getFunctionExpressionParentSymbolOrSymbol(/* TODO(PropertyAccessExpression): symbol.parent */ TODO)
            if /* TODO(PropertyAccessExpression): possiblyAnnotatedSymbol.valueDeclaration */ TODO {
                typeNode := getEffectiveTypeAnnotationNode(/* TODO(PropertyAccessExpression): possiblyAnnotatedSymbol.valueDeclaration */ TODO)
                if typeNode {
                    annotationSymbol := getPropertyOfType(getTypeFromTypeNode(typeNode), /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO)
                    if annotationSymbol {
                         getNonMissingTypeOfSymbol(annotationSymbol)
                    }
                }
            }
        }
         declaredType
    }
    getInitializerTypeFromAssignmentDeclaration := func(symbol Symbol, resolvedSymbol *Symbol, expression /* TODO(UnionType): BinaryExpression | CallExpression */ any, kind AssignmentDeclarationKind) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if isCallExpression(expression) {
            if resolvedSymbol {
                 getTypeOfSymbol(resolvedSymbol)
            }
            objectLitType := checkExpressionCached(/* TODO(ElementAccessExpression): (expression as BindableObjectDefinePropertyCall).arguments[2] */ TODO)
            valueType := getTypeOfPropertyOfType(objectLitType, "value" /* as */ /* TODO(TypeReference): __String */)
            if valueType {
                 valueType
            }
            getFunc := getTypeOfPropertyOfType(objectLitType, "get" /* as */ /* TODO(TypeReference): __String */)
            if getFunc {
                getSig := getSingleCallSignature(getFunc)
                if getSig {
                     getReturnTypeOfSignature(getSig)
                }
            }
            setFunc := getTypeOfPropertyOfType(objectLitType, "set" /* as */ /* TODO(TypeReference): __String */)
            if setFunc {
                setSig := getSingleCallSignature(setFunc)
                if setSig {
                     getTypeOfFirstParameterOfSignature(setSig)
                }
            }
             anyType
        }
        if containsSameNamedThisProperty(/* TODO(PropertyAccessExpression): expression.left */ TODO, /* TODO(PropertyAccessExpression): expression.right */ TODO) {
             anyType
        }
        isDirectExport := /* TODO(BinaryExpression): kind === AssignmentDeclarationKind.ExportsProperty && (isPropertyAccessExpression(expression.left) || isElementAccessExpression(expression.left)) && (isModuleExportsAccessExpression(expression.left.expression) || (isIdentifier(expression.left.expression) && isExportsIdentifier(expression.left.expression))) */ TODO
        type_ := /* TODO(ConditionalExpression): resolvedSymbol ? getTypeOfSymbol(resolvedSymbol)             : isDirectExport ? getRegularTypeOfLiteralType(checkExpressionCached(expression.right))             : getWidenedLiteralType(checkExpressionCached(expression.right)) */ TODO
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Object &&             kind === AssignmentDeclarationKind.ModuleExports &&             symbol.escapedName === InternalSymbolName.ExportEquals */ TODO {
            exportedType := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
            members := createSymbolTable()
            /* TODO(ExpressionStatement): copyEntries(exportedType.members, members); */
            initialSize := /* TODO(PropertyAccessExpression): members.size */ TODO
            if /* TODO(BinaryExpression): resolvedSymbol && !resolvedSymbol.exports */ TODO {
                /* TODO(ExpressionStatement): resolvedSymbol.exports = createSymbolTable(); */
            }
            /* TODO(ExpressionStatement): (resolvedSymbol || symbol).exports!.forEach((s, name) => {                 const exportedMember = members.get(name)!;                 if (exportedMember && exportedMember !== s && !(s.flags & SymbolFlags.Alias)) {                     if (s.flags & SymbolFlags.Value && exportedMember.flags & SymbolFlags.Value) {                         // If the member has an additional value-like declaration, union the types from the two declarations,                         // but issue an error if they occurred in two different files. The purpose is to support a JS file with                         // a pattern like:                         //                         // module.exports = { a: true };                         // module.exports.a = 3;                         //                         // but we may have a JS file with `module.exports = { a: true }` along with a TypeScript module augmentation                         // declaring an `export const a: number`. In that case, we issue a duplicate identifier error, because                         // it's unclear what that's supposed to mean, so it's probably a mistake.                         if (s.valueDeclaration && exportedMember.valueDeclaration && getSourceFileOfNode(s.valueDeclaration) !== getSourceFileOfNode(exportedMember.valueDeclaration)) {                             const unescapedName = unescapeLeadingUnderscores(s.escapedName);                             const exportedMemberName = tryCast(exportedMember.valueDeclaration, isNamedDeclaration)?.name || exportedMember.valueDeclaration;                             addRelatedInfo(                                 error(s.valueDeclaration, Diagnostics.Duplicate_identifier_0, unescapedName),                                 createDiagnosticForNode(exportedMemberName, Diagnostics._0_was_also_declared_here, unescapedName),                             );                             addRelatedInfo(                                 error(exportedMemberName, Diagnostics.Duplicate_identifier_0, unescapedName),                                 createDiagnosticForNode(s.valueDeclaration, Diagnostics._0_was_also_declared_here, unescapedName),                             );                         }                         const union = createSymbol(s.flags | exportedMember.flags, name);                         union.links.type = getUnionType([getTypeOfSymbol(s), getTypeOfSymbol(exportedMember)]);                         union.valueDeclaration = exportedMember.valueDeclaration;                         union.declarations = concatenate(exportedMember.declarations, s.declarations);                         members.set(name, union);                     }                     else {                         members.set(name, mergeSymbol(s, exportedMember));                     }                 }                 else {                     members.set(name, s);                 }             }); */
            result := createAnonymousType(/* TODO(ConditionalExpression): initialSize !== members.size ? undefined : exportedType.symbol */ TODO, members, /* TODO(PropertyAccessExpression): exportedType.callSignatures */ TODO, /* TODO(PropertyAccessExpression): exportedType.constructSignatures */ TODO, /* TODO(PropertyAccessExpression): exportedType.indexInfos */ TODO)
            if /* TODO(BinaryExpression): initialSize === members.size */ TODO {
                if /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO {
                    /* TODO(ExpressionStatement): result.aliasSymbol = type.aliasSymbol; */
                    /* TODO(ExpressionStatement): result.aliasTypeArguments = type.aliasTypeArguments; */
                }
                if /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.Reference */ TODO {
                    /* TODO(ExpressionStatement): result.aliasSymbol = (type as TypeReference).symbol; */
                    args := getTypeArguments(type_ /* as */ /* TODO(TypeReference): TypeReference */)
                    /* TODO(ExpressionStatement): result.aliasTypeArguments = length(args) ? args : undefined; */
                }
            }
            /* TODO(ExpressionStatement): result.objectFlags |= getPropagatingFlagsOfTypes([type]) | getObjectFlags(type) & (ObjectFlags.JSLiteral | ObjectFlags.ArrayLiteral | ObjectFlags.ObjectLiteral); */
            if /* TODO(BinaryExpression): result.symbol && result.symbol.flags & SymbolFlags.Class && type === getDeclaredTypeOfClassOrInterface(result.symbol) */ TODO {
                /* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.IsClassInstanceClone; */
            }
             result
        }
        if isEmptyArrayLiteralType(type_) {
            /* TODO(ExpressionStatement): reportImplicitAny(expression, anyArrayType); */
             anyArrayType
        }
         type_
    }
    containsSameNamedThisProperty := func(thisProperty Expression, expression Expression) /* TODO(undefined): boolean | undefined */ TODO {
         /* TODO(BinaryExpression): isPropertyAccessExpression(thisProperty)             && thisProperty.expression.kind === SyntaxKind.ThisKeyword             && forEachChildRecursively(expression, n => isMatchingReference(thisProperty, n)) */ TODO
    }
    isDeclarationInConstructor := func(expression Expression) /* TODO(undefined): boolean */ TODO {
        thisContainer := getThisContainer(expression, /* TODO(FalseKeyword): false */ TODO, /* TODO(FalseKeyword): false */ TODO)
         /* TODO(BinaryExpression): thisContainer.kind === SyntaxKind.Constructor ||             thisContainer.kind === SyntaxKind.FunctionDeclaration ||             (thisContainer.kind === SyntaxKind.FunctionExpression && !isPrototypePropertyAssignment(thisContainer.parent)) */ TODO
    }
    getConstructorDefinedThisAssignmentTypes := func(types []Type, declarations []Declaration) /* TODO(ArrayType): Type[] */ any {
        /* TODO(ExpressionStatement): Debug.assert(types.length === declarations.length); */
         /* TODO(PropertyAccessExpression): types.filter */ TODO(/* TODO(ArrowFunction): (_, i) => {             const declaration = declarations[i];             const expression = isBinaryExpression(declaration) ? declaration :                 isBinaryExpression(declaration.parent) ? declaration.parent : undefined;             return expression && isDeclarationInConstructor(expression);         } */ TODO)
    }
    getTypeFromBindingElement := func(element BindingElement, includePatternInType bool, reportErrors bool) Type {
        if /* TODO(PropertyAccessExpression): element.initializer */ TODO {
            contextualType := /* TODO(ConditionalExpression): isBindingPattern(element.name) ? getTypeFromBindingPattern(element.name, /*includePatternInType* / true, /*reportErrors* / false) : unknownType */ TODO
             addOptionality(widenTypeInferredFromInitializer(element, checkDeclarationInitializer(element, /* TODO(PropertyAccessExpression): CheckMode.Normal */ TODO, contextualType)))
        }
        if isBindingPattern(/* TODO(PropertyAccessExpression): element.name */ TODO) {
             getTypeFromBindingPattern(/* TODO(PropertyAccessExpression): element.name */ TODO, includePatternInType, reportErrors)
        }
        if /* TODO(BinaryExpression): reportErrors && !declarationBelongsToPrivateAmbientMember(element) */ TODO {
            /* TODO(ExpressionStatement): reportImplicitAny(element, anyType); */
        }
         /* TODO(ConditionalExpression): includePatternInType ? nonInferrableAnyType : anyType */ TODO
    }
    getTypeFromObjectBindingPattern := func(pattern ObjectBindingPattern, includePatternInType bool, reportErrors bool) Type {
        members := createSymbolTable()
        var stringIndexInfo *IndexInfo
        objectFlags := /* TODO(BinaryExpression): ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral */ TODO
        /* TODO(ExpressionStatement): forEach(pattern.elements, e => {             const name = e.propertyName || e.name as Identifier;             if (e.dotDotDotToken) {                 stringIndexInfo = createIndexInfo(stringType, anyType, /*isReadonly* / false);                 return;             }              const exprType = getLiteralTypeFromPropertyName(name);             if (!isTypeUsableAsPropertyName(exprType)) {                 // do not include computed properties in the implied type                 objectFlags |= ObjectFlags.ObjectLiteralPatternWithComputedProperties;                 return;             }             const text = getPropertyNameFromType(exprType);             const flags = SymbolFlags.Property | (e.initializer ? SymbolFlags.Optional : 0);             const symbol = createSymbol(flags, text);             symbol.links.type = getTypeFromBindingElement(e, includePatternInType, reportErrors);             symbol.links.bindingElement = e;             members.set(symbol.escapedName, symbol);         }); */
        result := createAnonymousType(undefined, members, emptyArray, emptyArray, /* TODO(ConditionalExpression): stringIndexInfo ? [stringIndexInfo] : emptyArray */ TODO)
        /* TODO(ExpressionStatement): result.objectFlags |= objectFlags; */
        if includePatternInType {
            /* TODO(ExpressionStatement): result.pattern = pattern; */
            /* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.ContainsObjectOrArrayLiteral; */
        }
         result
    }
    getTypeFromArrayBindingPattern := func(pattern BindingPattern, includePatternInType bool, reportErrors bool) Type {
        elements := /* TODO(PropertyAccessExpression): pattern.elements */ TODO
        lastElement := lastOrUndefined(elements)
        restElement := /* TODO(ConditionalExpression): lastElement && lastElement.kind === SyntaxKind.BindingElement && lastElement.dotDotDotToken ? lastElement : undefined */ TODO
        if /* TODO(BinaryExpression): elements.length === 0 || elements.length === 1 && restElement */ TODO {
             /* TODO(ConditionalExpression): languageVersion >= ScriptTarget.ES2015 ? createIterableType(anyType) : anyArrayType */ TODO
        }
        elementTypes := map_(elements, /* TODO(ArrowFunction): e => isOmittedExpression(e) ? anyType : getTypeFromBindingElement(e, includePatternInType, reportErrors) */ TODO)
        minLength := /* TODO(BinaryExpression): findLastIndex(elements, e => !(e === restElement || isOmittedExpression(e) || hasDefaultValue(e)), elements.length - 1) + 1 */ TODO
        elementFlags := map_(elements, /* TODO(ArrowFunction): (e, i) => e === restElement ? ElementFlags.Rest : i >= minLength ? ElementFlags.Optional : ElementFlags.Required */ TODO)
        result := createTupleType(elementTypes, elementFlags) /* as */ /* TODO(TypeReference): TypeReference */
        if includePatternInType {
            /* TODO(ExpressionStatement): result = cloneTypeReference(result); */
            /* TODO(ExpressionStatement): result.pattern = pattern; */
            /* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.ContainsObjectOrArrayLiteral; */
        }
         result
    }
    getTypeFromBindingPattern := func(pattern BindingPattern, includePatternInType /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, reportErrors /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) Type {
        if includePatternInType {
            /* TODO(CallExpression): contextualBindingPatterns.push(pattern) */
        }
        result := /* TODO(ConditionalExpression): pattern.kind === SyntaxKind.ObjectBindingPattern             ? getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors)             : getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors) */ TODO
        if includePatternInType {
            /* TODO(CallExpression): contextualBindingPatterns.pop() */
        }
         result
    }
    getWidenedTypeForVariableLikeDeclaration := func(declaration /* TODO(UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, reportErrors bool) Type {
         widenTypeForVariableLikeDeclaration(getTypeForVariableLikeDeclaration(declaration, /* TODO(TrueKeyword): true */ TODO, /* TODO(PropertyAccessExpression): CheckMode.Normal */ TODO), declaration, reportErrors)
    }
    getTypeFromImportAttributes := func(node ImportAttributes) Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            symbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.ObjectLiteral */ TODO, /* TODO(PropertyAccessExpression): InternalSymbolName.ImportAttributes */ TODO)
            members := createSymbolTable()
            /* TODO(ExpressionStatement): forEach(node.elements, attr => {                 const member = createSymbol(SymbolFlags.Property, getNameFromImportAttribute(attr));                 member.parent = symbol;                 member.links.type = checkImportAttribute(attr);                 member.links.target = member;                 members.set(member.escapedName, member);             }); */
            type_ := createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
            /* TODO(ExpressionStatement): type.objectFlags |= ObjectFlags.ObjectLiteral | ObjectFlags.NonInferrableType; */
            /* TODO(ExpressionStatement): links.resolvedType = type; */
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    isGlobalSymbolConstructor := func(node Node) /* TODO(undefined): boolean | undefined */ TODO {
        symbol := getSymbolOfNode(node)
        globalSymbol := getGlobalESSymbolConstructorTypeSymbol(/* TODO(FalseKeyword): false */ TODO)
         /* TODO(BinaryExpression): globalSymbol && symbol && symbol === globalSymbol */ TODO
    }
    widenTypeForVariableLikeDeclaration := func(type_ *Type, declaration /* TODO(AnyKeyword): any */ TODO, reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if type_ {
            if /* TODO(BinaryExpression): type.flags & TypeFlags.ESSymbol && isGlobalSymbolConstructor(declaration.parent) */ TODO {
                /* TODO(ExpressionStatement): type = getESSymbolLikeTypeForNode(declaration); */
            }
            if reportErrors {
                /* TODO(ExpressionStatement): reportErrorsFromWidening(declaration, type); */
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.UniqueESSymbol && (isBindingElement(declaration) || !declaration.type) && type.symbol !== getSymbolOfDeclaration(declaration) */ TODO {
                /* TODO(ExpressionStatement): type = esSymbolType; */
            }
             getWidenedType(type_)
        }
        /* TODO(ExpressionStatement): type = isParameter(declaration) && declaration.dotDotDotToken ? anyArrayType : anyType; */
        if reportErrors {
            if /* TODO(PrefixUnaryExpression): !declarationBelongsToPrivateAmbientMember(declaration) */ TODO {
                /* TODO(ExpressionStatement): reportImplicitAny(declaration, type); */
            }
        }
         type_
    }
    declarationBelongsToPrivateAmbientMember := func(declaration VariableLikeDeclaration) /* TODO(undefined): boolean */ TODO {
        root := getRootDeclaration(declaration)
        memberDeclaration := /* TODO(ConditionalExpression): root.kind === SyntaxKind.Parameter ? root.parent : root */ TODO
         isPrivateWithinAmbient(memberDeclaration)
    }
    tryGetTypeFromEffectiveTypeNode := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        typeNode := getEffectiveTypeAnnotationNode(node)
        if typeNode {
             getTypeFromTypeNode(typeNode)
        }
    }
    isParameterOfContextSensitiveSignature := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
        decl := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
        if /* TODO(PrefixUnaryExpression): !decl */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if isBindingElement(decl) {
            /* TODO(ExpressionStatement): decl = walkUpBindingElementsAndPatterns(decl); */
        }
        if isParameter(decl) {
             isContextSensitiveFunctionOrObjectLiteralMethod(/* TODO(PropertyAccessExpression): decl.parent */ TODO)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    getTypeOfVariableOrParameterOrProperty := func(symbol Symbol) Type {
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.type */ TODO {
            type_ := getTypeOfVariableOrParameterOrPropertyWorker(symbol)
            if /* TODO(BinaryExpression): !links.type && !isParameterOfContextSensitiveSignature(symbol) */ TODO {
                /* TODO(ExpressionStatement): links.type = type; */
            }
             type_
        }
         /* TODO(PropertyAccessExpression): links.type */ TODO
    }
    getTypeOfVariableOrParameterOrPropertyWorker := func(symbol Symbol) Type {
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Prototype */ TODO {
             getTypeOfPrototypeProperty(symbol)
        }
        if /* TODO(BinaryExpression): symbol === requireSymbol */ TODO {
             anyType
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ModuleExports && symbol.valueDeclaration */ TODO {
            fileSymbol := getSymbolOfDeclaration(getSourceFileOfNode(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO))
            result := createSymbol(/* TODO(PropertyAccessExpression): fileSymbol.flags */ TODO, "exports" /* as */ /* TODO(TypeReference): __String */)
            /* TODO(ExpressionStatement): result.declarations = fileSymbol.declarations ? fileSymbol.declarations.slice() : []; */
            /* TODO(ExpressionStatement): result.parent = symbol; */
            /* TODO(ExpressionStatement): result.links.target = fileSymbol; */
            if /* TODO(PropertyAccessExpression): fileSymbol.valueDeclaration */ TODO {
                /* TODO(BinaryExpression): result.valueDeclaration = fileSymbol.valueDeclaration */
            }
            if /* TODO(PropertyAccessExpression): fileSymbol.members */ TODO {
                /* TODO(BinaryExpression): result.members = new Map(fileSymbol.members) */
            }
            if /* TODO(PropertyAccessExpression): fileSymbol.exports */ TODO {
                /* TODO(BinaryExpression): result.exports = new Map(fileSymbol.exports) */
            }
            members := createSymbolTable()
            /* TODO(ExpressionStatement): members.set("exports" as __String, result); */
             createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
        }
        /* TODO(ExpressionStatement): Debug.assertIsDefined(symbol.valueDeclaration); */
        declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
        if /* TODO(BinaryExpression): isSourceFile(declaration) && isJsonSourceFile(declaration) */ TODO {
            if /* TODO(PrefixUnaryExpression): !declaration.statements.length */ TODO {
                 emptyObjectType
            }
             getWidenedType(getWidenedLiteralType(checkExpression(/* TODO(PropertyAccessExpression): declaration.statements[0].expression */ TODO)))
        }
        if isAccessor(declaration) {
             getTypeOfAccessors(symbol)
        }
        if /* TODO(PrefixUnaryExpression): !pushTypeResolution(symbol, TypeSystemPropertyName.Type) */ TODO {
            if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ValueModule && !(symbol.flags & SymbolFlags.Assignment) */ TODO {
                 getTypeOfFuncClassEnumModule(symbol)
            }
             reportCircularityError(symbol)
        }
        var type_ Type
        if /* TODO(BinaryExpression): declaration.kind === SyntaxKind.ExportAssignment */ TODO {
            /* TODO(ExpressionStatement): type = widenTypeForVariableLikeDeclaration(tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionCached((declaration as ExportAssignment).expression), declaration); */
        } else if /* TODO(BinaryExpression): isBinaryExpression(declaration) ||             (isInJSFile(declaration) &&                 (isCallExpression(declaration) || (isPropertyAccessExpression(declaration) || isBindableStaticElementAccessExpression(declaration)) && isBinaryExpression(declaration.parent))) */ TODO {
            /* TODO(ExpressionStatement): type = getWidenedTypeForAssignmentDeclaration(symbol); */
        } else if /* TODO(BinaryExpression): isPropertyAccessExpression(declaration)             || isElementAccessExpression(declaration)             || isIdentifier(declaration)             || isStringLiteralLike(declaration)             || isNumericLiteral(declaration)             || isClassDeclaration(declaration)             || isFunctionDeclaration(declaration)             || (isMethodDeclaration(declaration) && !isObjectLiteralMethod(declaration))             || isMethodSignature(declaration)             || isSourceFile(declaration) */ TODO {
            if /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule) */ TODO {
                 getTypeOfFuncClassEnumModule(symbol)
            }
            /* TODO(ExpressionStatement): type = isBinaryExpression(declaration.parent) ?                 getWidenedTypeForAssignmentDeclaration(symbol) :                 tryGetTypeFromEffectiveTypeNode(declaration) || anyType; */
        } else if isPropertyAssignment(declaration) {
            /* TODO(ExpressionStatement): type = tryGetTypeFromEffectiveTypeNode(declaration) || checkPropertyAssignment(declaration); */
        } else if isJsxAttribute(declaration) {
            /* TODO(ExpressionStatement): type = tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(declaration); */
        } else if isShorthandPropertyAssignment(declaration) {
            /* TODO(ExpressionStatement): type = tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(declaration.name, CheckMode.Normal); */
        } else if isObjectLiteralMethod(declaration) {
            /* TODO(ExpressionStatement): type = tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(declaration, CheckMode.Normal); */
        } else if /* TODO(BinaryExpression): isParameter(declaration)             || isPropertyDeclaration(declaration)             || isPropertySignature(declaration)             || isVariableDeclaration(declaration)             || isBindingElement(declaration)             || isJSDocPropertyLikeTag(declaration) */ TODO {
            /* TODO(ExpressionStatement): type = getWidenedTypeForVariableLikeDeclaration(declaration, /*reportErrors* / true); */
        } else if isEnumDeclaration(declaration) {
            /* TODO(ExpressionStatement): type = getTypeOfFuncClassEnumModule(symbol); */
        } else if isEnumMember(declaration) {
            /* TODO(ExpressionStatement): type = getTypeOfEnumMember(symbol); */
        } else {
             /* TODO(PropertyAccessExpression): Debug.fail */ TODO(/* TODO(BinaryExpression): "Unhandled declaration kind! " + Debug.formatSyntaxKind(declaration.kind) + " for " + Debug.formatSymbol(symbol) */ TODO)
        }
        if /* TODO(PrefixUnaryExpression): !popTypeResolution() */ TODO {
            if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ValueModule && !(symbol.flags & SymbolFlags.Assignment) */ TODO {
                 getTypeOfFuncClassEnumModule(symbol)
            }
             reportCircularityError(symbol)
        }
         type_
    }
    getAnnotatedAccessorTypeNode := func(accessor /* TODO(UnionType): AccessorDeclaration | PropertyDeclaration | undefined */ any) *TypeNode {
        if accessor {
            /* TODO(SwitchStatement): switch (accessor.kind) {                 case SyntaxKind.GetAccessor:                     const getterTypeAnnotation = getEffectiveReturnTypeNode(accessor);                     return getterTypeAnnotation;                 case SyntaxKind.SetAccessor:                     const setterTypeAnnotation = getEffectiveSetAccessorTypeAnnotationNode(accessor);                     return setterTypeAnnotation;                 case SyntaxKind.PropertyDeclaration:                     Debug.assert(hasAccessorModifier(accessor));                     const accessorTypeAnnotation = getEffectiveTypeAnnotationNode(accessor);                     return accessorTypeAnnotation;             } */
        }
         undefined
    }
    getAnnotatedAccessorType := func(accessor /* TODO(UnionType): AccessorDeclaration | PropertyDeclaration | undefined */ any) *Type {
        node := getAnnotatedAccessorTypeNode(accessor)
         /* TODO(BinaryExpression): node && getTypeFromTypeNode(node) */ TODO
    }
    getAnnotatedAccessorThisParameter := func(accessor AccessorDeclaration) *Symbol {
        parameter := getAccessorThisParameter(accessor)
         /* TODO(BinaryExpression): parameter && parameter.symbol */ TODO
    }
    getThisTypeOfDeclaration := func(declaration SignatureDeclaration) *Type {
         getThisTypeOfSignature(getSignatureFromDeclaration(declaration))
    }
    getTypeOfAccessors := func(symbol Symbol) Type {
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.type */ TODO {
            if /* TODO(PrefixUnaryExpression): !pushTypeResolution(symbol, TypeSystemPropertyName.Type) */ TODO {
                 errorType
            }
            getter := getDeclarationOfKind(symbol, /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */ TODO)
            setter := getDeclarationOfKind(symbol, /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */ TODO)
            accessor := tryCast(getDeclarationOfKind(symbol, /* TODO(PropertyAccessExpression): SyntaxKind.PropertyDeclaration */ TODO), isAutoAccessorPropertyDeclaration)
            type_ := /* TODO(BinaryExpression): getter && isInJSFile(getter) && getTypeForDeclarationFromJSDocComment(getter) ||                 getAnnotatedAccessorType(getter) ||                 getAnnotatedAccessorType(setter) ||                 getAnnotatedAccessorType(accessor) ||                 getter && getter.body && getReturnTypeFromBody(getter) ||                 accessor && accessor.initializer && getWidenedTypeForVariableLikeDeclaration(accessor, /*reportErrors* / true) */ TODO
            if /* TODO(PrefixUnaryExpression): !type */ TODO {
                if /* TODO(BinaryExpression): setter && !isPrivateWithinAmbient(setter) */ TODO {
                    /* TODO(ExpressionStatement): errorOrSuggestion(noImplicitAny, setter, Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation, symbolToString(symbol)); */
                } else if /* TODO(BinaryExpression): getter && !isPrivateWithinAmbient(getter) */ TODO {
                    /* TODO(ExpressionStatement): errorOrSuggestion(noImplicitAny, getter, Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation, symbolToString(symbol)); */
                } else if /* TODO(BinaryExpression): accessor && !isPrivateWithinAmbient(accessor) */ TODO {
                    /* TODO(ExpressionStatement): errorOrSuggestion(noImplicitAny, accessor, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), "any"); */
                }
                /* TODO(ExpressionStatement): type = anyType; */
            }
            if /* TODO(PrefixUnaryExpression): !popTypeResolution() */ TODO {
                if getAnnotatedAccessorTypeNode(getter) {
                    /* TODO(ExpressionStatement): error(getter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol)); */
                } else if getAnnotatedAccessorTypeNode(setter) {
                    /* TODO(ExpressionStatement): error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol)); */
                } else if getAnnotatedAccessorTypeNode(accessor) {
                    /* TODO(ExpressionStatement): error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol)); */
                } else if /* TODO(BinaryExpression): getter && noImplicitAny */ TODO {
                    /* TODO(ExpressionStatement): error(getter, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, symbolToString(symbol)); */
                }
                /* TODO(ExpressionStatement): type = anyType; */
            }
            /* TODO(ExpressionStatement): links.type ??= type; */
        }
         /* TODO(PropertyAccessExpression): links.type */ TODO
    }
    getWriteTypeOfAccessors := func(symbol Symbol) Type {
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.writeType */ TODO {
            if /* TODO(PrefixUnaryExpression): !pushTypeResolution(symbol, TypeSystemPropertyName.WriteType) */ TODO {
                 errorType
            }
            setter := /* TODO(BinaryExpression): getDeclarationOfKind<AccessorDeclaration>(symbol, SyntaxKind.SetAccessor)                 ?? tryCast(getDeclarationOfKind<PropertyDeclaration>(symbol, SyntaxKind.PropertyDeclaration), isAutoAccessorPropertyDeclaration) */ TODO
            writeType := getAnnotatedAccessorType(setter)
            if /* TODO(PrefixUnaryExpression): !popTypeResolution() */ TODO {
                if getAnnotatedAccessorTypeNode(setter) {
                    /* TODO(ExpressionStatement): error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol)); */
                }
                /* TODO(ExpressionStatement): writeType = anyType; */
            }
            /* TODO(ExpressionStatement): links.writeType ??= writeType || getTypeOfAccessors(symbol); */
        }
         /* TODO(PropertyAccessExpression): links.writeType */ TODO
    }
    getBaseTypeVariableOfClass := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        baseConstructorType := getBaseConstructorTypeOfClass(getDeclaredTypeOfClassOrInterface(symbol))
         /* TODO(ConditionalExpression): baseConstructorType.flags & TypeFlags.TypeVariable ? baseConstructorType :             baseConstructorType.flags & TypeFlags.Intersection ? find((baseConstructorType as IntersectionType).types, t => !!(t.flags & TypeFlags.TypeVariable)) :             undefined */ TODO
    }
    getTypeOfFuncClassEnumModule := func(symbol Symbol) Type {
        links := getSymbolLinks(symbol)
        originalLinks := links
        if /* TODO(PrefixUnaryExpression): !links.type */ TODO {
            expando := /* TODO(BinaryExpression): symbol.valueDeclaration && getSymbolOfExpando(symbol.valueDeclaration, /*allowDeclaration* / false) */ TODO
            if expando {
                merged := mergeJSSymbols(symbol, expando)
                if merged {
                    /* TODO(ExpressionStatement): symbol = merged; */
                    /* TODO(ExpressionStatement): links = merged.links; */
                }
            }
            /* TODO(ExpressionStatement): originalLinks.type = links.type = getTypeOfFuncClassEnumModuleWorker(symbol); */
        }
         /* TODO(PropertyAccessExpression): links.type */ TODO
    }
    getTypeOfFuncClassEnumModuleWorker := func(symbol Symbol) Type {
        declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Module && isShorthandAmbientModuleSymbol(symbol) */ TODO {
             anyType
        } else if /* TODO(BinaryExpression): declaration && (declaration.kind === SyntaxKind.BinaryExpression ||                 isAccessExpression(declaration) &&                     declaration.parent.kind === SyntaxKind.BinaryExpression) */ TODO {
             getWidenedTypeForAssignmentDeclaration(symbol)
        } else if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ValueModule && declaration && isSourceFile(declaration) && declaration.commonJsModuleIndicator */ TODO {
            resolvedModule := resolveExternalModuleSymbol(symbol)
            if /* TODO(BinaryExpression): resolvedModule !== symbol */ TODO {
                if /* TODO(PrefixUnaryExpression): !pushTypeResolution(symbol, TypeSystemPropertyName.Type) */ TODO {
                     errorType
                }
                exportEquals := getMergedSymbol(/* TODO(NonNullExpression): symbol.exports!.get(InternalSymbolName.ExportEquals)! */ TODO)
                type_ := getWidenedTypeForAssignmentDeclaration(exportEquals, /* TODO(ConditionalExpression): exportEquals === resolvedModule ? undefined : resolvedModule */ TODO)
                if /* TODO(PrefixUnaryExpression): !popTypeResolution() */ TODO {
                     reportCircularityError(symbol)
                }
                 type_
            }
        }
        type_ := createObjectType(/* TODO(PropertyAccessExpression): ObjectFlags.Anonymous */ TODO, symbol)
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Class */ TODO {
            baseTypeVariable := getBaseTypeVariableOfClass(symbol)
             /* TODO(ConditionalExpression): baseTypeVariable ? getIntersectionType([type, baseTypeVariable]) : type */ TODO
        } else {
             /* TODO(ConditionalExpression): strictNullChecks && symbol.flags & SymbolFlags.Optional ? getOptionalType(type, /*isProperty* / true) : type */ TODO
        }
    }
    getTypeOfEnumMember := func(symbol Symbol) Type {
        links := getSymbolLinks(symbol)
         /* TODO(BinaryExpression): links.type || (links.type = getDeclaredTypeOfEnumMember(symbol)) */ TODO
    }
    getTypeOfAlias := func(symbol Symbol) Type {
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.type */ TODO {
            if /* TODO(PrefixUnaryExpression): !pushTypeResolution(symbol, TypeSystemPropertyName.Type) */ TODO {
                 errorType
            }
            targetSymbol := resolveAlias(symbol)
            exportSymbol := /* TODO(BinaryExpression): symbol.declarations && getTargetOfAliasDeclaration(getDeclarationOfAliasSymbol(symbol)!, /*dontRecursivelyResolve* / true) */ TODO
            declaredType := firstDefined(/* TODO(PropertyAccessExpression): exportSymbol?.declarations */ TODO, /* TODO(ArrowFunction): d => isExportAssignment(d) ? tryGetTypeFromEffectiveTypeNode(d) : undefined */ TODO)
            /* TODO(ExpressionStatement): links.type ??= exportSymbol?.declarations && isDuplicatedCommonJSExport(exportSymbol.declarations) && symbol.declarations!.length ? getFlowTypeFromCommonJSExport(exportSymbol)                 : isDuplicatedCommonJSExport(symbol.declarations) ? autoType                 : declaredType ? declaredType                 : getSymbolFlags(targetSymbol) & SymbolFlags.Value ? getTypeOfSymbol(targetSymbol)                 : errorType; */
            if /* TODO(PrefixUnaryExpression): !popTypeResolution() */ TODO {
                /* TODO(ExpressionStatement): reportCircularityError(exportSymbol ?? symbol); */
                 /* TODO(BinaryExpression): links.type ??= errorType */ TODO
            }
        }
         /* TODO(PropertyAccessExpression): links.type */ TODO
    }
    getTypeOfInstantiatedSymbol := func(symbol Symbol) Type {
        links := getSymbolLinks(symbol)
         /* TODO(BinaryExpression): links.type || (links.type = instantiateType(getTypeOfSymbol(links.target!), links.mapper)) */ TODO
    }
    getWriteTypeOfInstantiatedSymbol := func(symbol Symbol) Type {
        links := getSymbolLinks(symbol)
         /* TODO(BinaryExpression): links.writeType || (links.writeType = instantiateType(getWriteTypeOfSymbol(links.target!), links.mapper)) */ TODO
    }
    reportCircularityError := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
        declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
        if declaration {
            if getEffectiveTypeAnnotationNode(declaration) {
                /* TODO(ExpressionStatement): error(symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol)); */
                 errorType
            }
            if /* TODO(BinaryExpression): noImplicitAny && (declaration.kind !== SyntaxKind.Parameter || (declaration as HasInitializer).initializer) */ TODO {
                /* TODO(ExpressionStatement): error(symbol.valueDeclaration, Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer, symbolToString(symbol)); */
            }
        } else if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO {
            node := getDeclarationOfAliasSymbol(symbol)
            if node {
                /* TODO(ExpressionStatement): error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol)); */
            }
        }
         anyType
    }
    getTypeOfSymbolWithDeferredType := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.type */ TODO {
            /* TODO(ExpressionStatement): Debug.assertIsDefined(links.deferralParent); */
            /* TODO(ExpressionStatement): Debug.assertIsDefined(links.deferralConstituents); */
            /* TODO(ExpressionStatement): links.type = links.deferralParent.flags & TypeFlags.Union ? getUnionType(links.deferralConstituents) : getIntersectionType(links.deferralConstituents); */
        }
         /* TODO(PropertyAccessExpression): links.type */ TODO
    }
    getWriteTypeOfSymbolWithDeferredType := func(symbol Symbol) *Type {
        links := getSymbolLinks(symbol)
        if /* TODO(BinaryExpression): !links.writeType && links.deferralWriteConstituents */ TODO {
            /* TODO(ExpressionStatement): Debug.assertIsDefined(links.deferralParent); */
            /* TODO(ExpressionStatement): Debug.assertIsDefined(links.deferralConstituents); */
            /* TODO(ExpressionStatement): links.writeType = links.deferralParent.flags & TypeFlags.Union ? getUnionType(links.deferralWriteConstituents) : getIntersectionType(links.deferralWriteConstituents); */
        }
         /* TODO(PropertyAccessExpression): links.writeType */ TODO
    }
    getWriteTypeOfSymbol := func(symbol Symbol) Type {
        checkFlags := getCheckFlags(symbol)
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Property */ TODO {
             /* TODO(ConditionalExpression): checkFlags & CheckFlags.SyntheticProperty ?                 checkFlags & CheckFlags.DeferredType ?                     getWriteTypeOfSymbolWithDeferredType(symbol) || getTypeOfSymbolWithDeferredType(symbol) :                     // NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.SyntheticProperty                     (symbol as TransientSymbol).links.writeType || (symbol as TransientSymbol).links.type! :                 removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlags.Optional)) */ TODO
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Accessor */ TODO {
             /* TODO(ConditionalExpression): checkFlags & CheckFlags.Instantiated ?                 getWriteTypeOfInstantiatedSymbol(symbol) :                 getWriteTypeOfAccessors(symbol) */ TODO
        }
         getTypeOfSymbol(symbol)
    }
    getTypeOfSymbol := func(symbol Symbol) Type {
        checkFlags := getCheckFlags(symbol)
        if /* TODO(BinaryExpression): checkFlags & CheckFlags.DeferredType */ TODO {
             getTypeOfSymbolWithDeferredType(symbol)
        }
        if /* TODO(BinaryExpression): checkFlags & CheckFlags.Instantiated */ TODO {
             getTypeOfInstantiatedSymbol(symbol)
        }
        if /* TODO(BinaryExpression): checkFlags & CheckFlags.Mapped */ TODO {
             getTypeOfMappedSymbol(symbol /* as */ /* TODO(TypeReference): MappedSymbol */)
        }
        if /* TODO(BinaryExpression): checkFlags & CheckFlags.ReverseMapped */ TODO {
             getTypeOfReverseMappedSymbol(symbol /* as */ /* TODO(TypeReference): ReverseMappedSymbol */)
        }
        if /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Variable | SymbolFlags.Property) */ TODO {
             getTypeOfVariableOrParameterOrProperty(symbol)
        }
        if /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule) */ TODO {
             getTypeOfFuncClassEnumModule(symbol)
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.EnumMember */ TODO {
             getTypeOfEnumMember(symbol)
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Accessor */ TODO {
             getTypeOfAccessors(symbol)
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO {
             getTypeOfAlias(symbol)
        }
         errorType
    }
    getNonMissingTypeOfSymbol := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         removeMissingType(getTypeOfSymbol(symbol), /* TODO(PrefixUnaryExpression): !!(symbol.flags & SymbolFlags.Optional) */ TODO)
    }
    isReferenceToSomeType := func(type_ Type, targets []Type) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): type === undefined || (getObjectFlags(type) & ObjectFlags.Reference) === 0 */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        /* TODO(ForOfStatement): for (const target of targets) {             if ((type as TypeReference).target === target) {                 return true;             }         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    isReferenceToType := func(type_ Type, target Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): type !== undefined             && target !== undefined             && (getObjectFlags(type) & ObjectFlags.Reference) !== 0             && (type as TypeReference).target === target */ TODO
    }
    getTargetType := func(type_ Type) Type {
         /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).target : type */ TODO
    }
    hasBaseType := func(type_ Type, checkBase *Type) /* TODO(undefined): boolean */ TODO {
         check(type_)
        check := func(type_ Type) bool {
            if /* TODO(BinaryExpression): getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference) */ TODO {
                target := getTargetType(type_) /* as */ /* TODO(TypeReference): InterfaceType */
                 /* TODO(BinaryExpression): target === checkBase || some(getBaseTypes(target), check) */ TODO
            } else if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
                 some(/* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, check)
            }
             /* TODO(FalseKeyword): false */ TODO
        }
    }
    appendTypeParameters := func(typeParameters /* TODO(ArrayType): TypeParameter[] */ any, declarations []TypeParameterDeclaration) /* TODO(ArrayType): TypeParameter[] */ any {
        /* TODO(ForOfStatement): for (const declaration of declarations) {             typeParameters = appendIfUnique(typeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(declaration)));         } */
         typeParameters
    }
    getOuterTypeParameters := func(node Node, includeThisTypes bool) /* TODO(ArrayType): TypeParameter[] */ any {
        /* TODO(WhileStatement): while (true) {             node = node.parent; // TODO: GH#18217 Use SourceFile kind check instead             if (node && isBinaryExpression(node)) {                 // prototype assignments get the outer type parameters of their constructor function                 const assignmentKind = getAssignmentDeclarationKind(node);                 if (assignmentKind === AssignmentDeclarationKind.Prototype || assignmentKind === AssignmentDeclarationKind.PrototypeProperty) {                     const symbol = getSymbolOfDeclaration(node.left as BindableStaticNameExpression | PropertyAssignment);                     if (symbol && symbol.parent && !findAncestor(symbol.parent.valueDeclaration, d => node === d)) {                         node = symbol.parent.valueDeclaration!;                     }                 }             }             if (!node) {                 return undefined;             }             const kind = node.kind;             switch (kind) {                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression:                 case SyntaxKind.InterfaceDeclaration:                 case SyntaxKind.CallSignature:                 case SyntaxKind.ConstructSignature:                 case SyntaxKind.MethodSignature:                 case SyntaxKind.FunctionType:                 case SyntaxKind.ConstructorType:                 case SyntaxKind.JSDocFunctionType:                 case SyntaxKind.FunctionDeclaration:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.FunctionExpression:                 case SyntaxKind.ArrowFunction:                 case SyntaxKind.TypeAliasDeclaration:                 case SyntaxKind.JSDocTemplateTag:                 case SyntaxKind.JSDocTypedefTag:                 case SyntaxKind.JSDocEnumTag:                 case SyntaxKind.JSDocCallbackTag:                 case SyntaxKind.MappedType:                 case SyntaxKind.ConditionalType: {                     const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);                     if ((kind === SyntaxKind.FunctionExpression || kind === SyntaxKind.ArrowFunction || isObjectLiteralMethod(node)) && isContextSensitive(node as Expression | MethodDeclaration)) {                         const signature = firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node as FunctionLikeDeclaration)), SignatureKind.Call));                         if (signature && signature.typeParameters) {                             return [...(outerTypeParameters || emptyArray), ...signature.typeParameters];                         }                     }                     if (kind === SyntaxKind.MappedType) {                         return append(outerTypeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration((node as MappedTypeNode).typeParameter)));                     }                     else if (kind === SyntaxKind.ConditionalType) {                         return concatenate(outerTypeParameters, getInferTypeParameters(node as ConditionalTypeNode));                     }                     const outerAndOwnTypeParameters = appendTypeParameters(outerTypeParameters, getEffectiveTypeParameterDeclarations(node as DeclarationWithTypeParameters));                     const thisType = includeThisTypes &&                         (kind === SyntaxKind.ClassDeclaration || kind === SyntaxKind.ClassExpression || kind === SyntaxKind.InterfaceDeclaration || isJSConstructor(node)) &&                         getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node as ClassLikeDeclaration | InterfaceDeclaration)).thisType;                     return thisType ? append(outerAndOwnTypeParameters, thisType) : outerAndOwnTypeParameters;                 }                 case SyntaxKind.JSDocParameterTag:                     const paramSymbol = getParameterSymbolFromJSDoc(node as JSDocParameterTag);                     if (paramSymbol) {                         node = paramSymbol.valueDeclaration!;                     }                     break;                 case SyntaxKind.JSDoc: {                     const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);                     return (node as JSDoc).tags                         ? appendTypeParameters(outerTypeParameters, flatMap((node as JSDoc).tags, t => isJSDocTemplateTag(t) ? t.typeParameters : undefined))                         : outerTypeParameters;                 }             }         } */
    }
    getOuterTypeParametersOfClassOrInterface := func(symbol Symbol) /* TODO(ArrayType): TypeParameter[] */ any {
        declaration := /* TODO(ConditionalExpression): (symbol.flags & SymbolFlags.Class || symbol.flags & SymbolFlags.Function)             ? symbol.valueDeclaration             : symbol.declarations?.find(decl => {                 if (decl.kind === SyntaxKind.InterfaceDeclaration) {                     return true;                 }                 if (decl.kind !== SyntaxKind.VariableDeclaration) {                     return false;                 }                 const initializer = (decl as VariableDeclaration).initializer;                 return !!initializer && (initializer.kind === SyntaxKind.FunctionExpression || initializer.kind === SyntaxKind.ArrowFunction);             })! */ TODO
        /* TODO(ExpressionStatement): Debug.assert(!!declaration, "Class was missing valueDeclaration -OR- non-class had no interface declarations"); */
         getOuterTypeParameters(declaration)
    }
    getLocalTypeParametersOfClassOrInterfaceOrTypeAlias := func(symbol Symbol) /* TODO(ArrayType): TypeParameter[] */ any {
        if /* TODO(PrefixUnaryExpression): !symbol.declarations */ TODO {

        }
        var result /* TODO(ArrayType): TypeParameter[] */ any
        /* TODO(ForOfStatement): for (const node of symbol.declarations) {             if (                 node.kind === SyntaxKind.InterfaceDeclaration ||                 node.kind === SyntaxKind.ClassDeclaration ||                 node.kind === SyntaxKind.ClassExpression ||                 isJSConstructor(node) ||                 isTypeAlias(node)             ) {                 const declaration = node as InterfaceDeclaration | TypeAliasDeclaration | JSDocTypedefTag | JSDocCallbackTag;                 result = appendTypeParameters(result, getEffectiveTypeParameterDeclarations(declaration));             }         } */
         result
    }
    getTypeParametersOfClassOrInterface := func(symbol Symbol) /* TODO(ArrayType): TypeParameter[] */ any {
         concatenate(getOuterTypeParametersOfClassOrInterface(symbol), getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol))
    }
    isMixinConstructorType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
        signatures := getSignaturesOfType(type_, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO)
        if /* TODO(BinaryExpression): signatures.length === 1 */ TODO {
            s := /* TODO(ElementAccessExpression): signatures[0] */ TODO
            if /* TODO(BinaryExpression): !s.typeParameters && s.parameters.length === 1 && signatureHasRestParameter(s) */ TODO {
                paramType := getTypeOfParameter(/* TODO(ElementAccessExpression): s.parameters[0] */ TODO)
                 /* TODO(BinaryExpression): isTypeAny(paramType) || getElementTypeOfArrayType(paramType) === anyType */ TODO
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isConstructorType := func(type_ Type) bool {
        if /* TODO(BinaryExpression): getSignaturesOfType(type, SignatureKind.Construct).length > 0 */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.TypeVariable */ TODO {
            constraint := getBaseConstraintOfType(type_)
             /* TODO(BinaryExpression): !!constraint && isMixinConstructorType(constraint) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    getBaseTypeNodeOfClass := func(type_ InterfaceType) *ExpressionWithTypeArguments {
        decl := getClassLikeDeclarationOfSymbol(/* TODO(PropertyAccessExpression): type.symbol */ TODO)
         /* TODO(BinaryExpression): decl && getEffectiveBaseTypeNode(decl) */ TODO
    }
    getConstructorsForTypeArguments := func(type_ Type, typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any, location Node) []Signature {
        typeArgCount := length(typeArgumentNodes)
        isJavascript := isInJSFile(location)
         filter(getSignaturesOfType(type_, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO), /* TODO(ArrowFunction): sig => (isJavascript || typeArgCount >= getMinTypeArgumentCount(sig.typeParameters)) && typeArgCount <= length(sig.typeParameters) */ TODO)
    }
    getInstantiatedConstructorsForTypeArguments := func(type_ Type, typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any, location Node) []Signature {
        signatures := getConstructorsForTypeArguments(type_, typeArgumentNodes, location)
        typeArguments := map_(typeArgumentNodes, getTypeFromTypeNode)
         sameMap(signatures, /* TODO(ArrowFunction): sig => some(sig.typeParameters) ? getSignatureInstantiation(sig, typeArguments, isInJSFile(location)) : sig */ TODO)
    }
    getBaseConstructorTypeOfClass := func(type_ InterfaceType) Type {
        if /* TODO(PrefixUnaryExpression): !type.resolvedBaseConstructorType */ TODO {
            decl := getClassLikeDeclarationOfSymbol(/* TODO(PropertyAccessExpression): type.symbol */ TODO)
            extended := /* TODO(BinaryExpression): decl && getEffectiveBaseTypeNode(decl) */ TODO
            baseTypeNode := getBaseTypeNodeOfClass(type_)
            if /* TODO(PrefixUnaryExpression): !baseTypeNode */ TODO {
                 /* TODO(BinaryExpression): type.resolvedBaseConstructorType = undefinedType */ TODO
            }
            if /* TODO(PrefixUnaryExpression): !pushTypeResolution(type, TypeSystemPropertyName.ResolvedBaseConstructorType) */ TODO {
                 errorType
            }
            baseConstructorType := checkExpression(/* TODO(PropertyAccessExpression): baseTypeNode.expression */ TODO)
            if /* TODO(BinaryExpression): extended && baseTypeNode !== extended */ TODO {
                /* TODO(ExpressionStatement): Debug.assert(!extended.typeArguments); */
                /* TODO(ExpressionStatement): checkExpression(extended.expression); */
            }
            if /* TODO(BinaryExpression): baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection) */ TODO {
                /* TODO(ExpressionStatement): resolveStructuredTypeMembers(baseConstructorType as ObjectType); */
            }
            if /* TODO(PrefixUnaryExpression): !popTypeResolution() */ TODO {
                /* TODO(ExpressionStatement): error(type.symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type.symbol)); */
                 /* TODO(BinaryExpression): type.resolvedBaseConstructorType ??= errorType */ TODO
            }
            if /* TODO(BinaryExpression): !(baseConstructorType.flags & TypeFlags.Any) && baseConstructorType !== nullWideningType && !isConstructorType(baseConstructorType) */ TODO {
                err := error(/* TODO(PropertyAccessExpression): baseTypeNode.expression */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_not_a_constructor_function_type */ TODO, typeToString(baseConstructorType))
                if /* TODO(BinaryExpression): baseConstructorType.flags & TypeFlags.TypeParameter */ TODO {
                    constraint := getConstraintFromTypeParameter(baseConstructorType)
                    var ctorReturn Type = unknownType
                    if constraint {
                        ctorSig := getSignaturesOfType(constraint, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO)
                        if /* TODO(ElementAccessExpression): ctorSig[0] */ TODO {
                            /* TODO(ExpressionStatement): ctorReturn = getReturnTypeOfSignature(ctorSig[0]); */
                        }
                    }
                    if /* TODO(PropertyAccessExpression): baseConstructorType.symbol.declarations */ TODO {
                        /* TODO(ExpressionStatement): addRelatedInfo(err, createDiagnosticForNode(baseConstructorType.symbol.declarations[0], Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1, symbolToString(baseConstructorType.symbol), typeToString(ctorReturn))); */
                    }
                }
                 /* TODO(BinaryExpression): type.resolvedBaseConstructorType ??= errorType */ TODO
            }
            /* TODO(ExpressionStatement): type.resolvedBaseConstructorType ??= baseConstructorType; */
        }
         /* TODO(PropertyAccessExpression): type.resolvedBaseConstructorType */ TODO
    }
    getImplementsTypes := func(type_ InterfaceType) []BaseType {
        var resolvedImplementsTypes []BaseType = emptyArray
        if /* TODO(PropertyAccessExpression): type.symbol.declarations */ TODO {
            /* TODO(ForOfStatement): for (const declaration of type.symbol.declarations) {                 const implementsTypeNodes = getEffectiveImplementsTypeNodes(declaration as ClassLikeDeclaration);                 if (!implementsTypeNodes) continue;                 for (const node of implementsTypeNodes) {                     const implementsType = getTypeFromTypeNode(node);                     if (!isErrorType(implementsType)) {                         if (resolvedImplementsTypes === emptyArray) {                             resolvedImplementsTypes = [implementsType as ObjectType];                         }                         else {                             resolvedImplementsTypes.push(implementsType);                         }                     }                 }             } */
        }
         resolvedImplementsTypes
    }
    reportCircularBaseType := func(node Node, type_ Type) {
        /* TODO(ExpressionStatement): error(node, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, /*enclosingDeclaration* / undefined, TypeFormatFlags.WriteArrayAsGenericType)); */
    }
    getBaseTypes := func(type_ InterfaceType) []BaseType {
        if /* TODO(PrefixUnaryExpression): !type.baseTypesResolved */ TODO {
            if pushTypeResolution(type_, /* TODO(PropertyAccessExpression): TypeSystemPropertyName.ResolvedBaseTypes */ TODO) {
                if /* TODO(BinaryExpression): type.objectFlags & ObjectFlags.Tuple */ TODO {
                    /* TODO(ExpressionStatement): type.resolvedBaseTypes = [getTupleBaseType(type as TupleType)]; */
                } else if /* TODO(BinaryExpression): type.symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface) */ TODO {
                    if /* TODO(BinaryExpression): type.symbol.flags & SymbolFlags.Class */ TODO {
                        /* TODO(ExpressionStatement): resolveBaseTypesOfClass(type); */
                    }
                    if /* TODO(BinaryExpression): type.symbol.flags & SymbolFlags.Interface */ TODO {
                        /* TODO(ExpressionStatement): resolveBaseTypesOfInterface(type); */
                    }
                } else {
                    /* TODO(ExpressionStatement): Debug.fail("type must be class or interface"); */
                }
                if /* TODO(BinaryExpression): !popTypeResolution() && type.symbol.declarations */ TODO {
                    /* TODO(ForOfStatement): for (const declaration of type.symbol.declarations) {                         if (declaration.kind === SyntaxKind.ClassDeclaration || declaration.kind === SyntaxKind.InterfaceDeclaration) {                             reportCircularBaseType(declaration, type);                         }                     } */
                }
            }
            /* TODO(ExpressionStatement): type.baseTypesResolved = true; */
        }
         /* TODO(PropertyAccessExpression): type.resolvedBaseTypes */ TODO
    }
    getTupleBaseType := func(type_ TupleType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
        elementTypes := sameMap(/* TODO(PropertyAccessExpression): type.typeParameters */ TODO, /* TODO(ArrowFunction): (t, i) => type.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t */ TODO)
         createArrayType(getUnionType(/* TODO(BinaryExpression): elementTypes || emptyArray */ TODO), /* TODO(PropertyAccessExpression): type.readonly */ TODO)
    }
    resolveBaseTypesOfClass := func(type_ InterfaceType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BaseType[] */ TODO {
        /* TODO(ExpressionStatement): type.resolvedBaseTypes = resolvingEmptyArray; */
        baseConstructorType := getApparentType(getBaseConstructorTypeOfClass(type_))
        if /* TODO(PrefixUnaryExpression): !(baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.Any)) */ TODO {
             /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
        }
        baseTypeNode := /* TODO(NonNullExpression): getBaseTypeNodeOfClass(type)! */ TODO
        var baseType Type
        originalBaseType := /* TODO(ConditionalExpression): baseConstructorType.symbol ? getDeclaredTypeOfSymbol(baseConstructorType.symbol) : undefined */ TODO
        if /* TODO(BinaryExpression): baseConstructorType.symbol && baseConstructorType.symbol.flags & SymbolFlags.Class &&             areAllOuterTypeParametersApplied(originalBaseType!) */ TODO {
            /* TODO(ExpressionStatement): baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol); */
        } else if /* TODO(BinaryExpression): baseConstructorType.flags & TypeFlags.Any */ TODO {
            /* TODO(ExpressionStatement): baseType = baseConstructorType; */
        } else {
            constructors := getInstantiatedConstructorsForTypeArguments(baseConstructorType, /* TODO(PropertyAccessExpression): baseTypeNode.typeArguments */ TODO, baseTypeNode)
            if /* TODO(PrefixUnaryExpression): !constructors.length */ TODO {
                /* TODO(ExpressionStatement): error(baseTypeNode.expression, Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments); */
                 /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
            }
            /* TODO(ExpressionStatement): baseType = getReturnTypeOfSignature(constructors[0]); */
        }
        if isErrorType(baseType) {
             /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
        }
        reducedBaseType := getReducedType(baseType)
        if /* TODO(PrefixUnaryExpression): !isValidBaseType(reducedBaseType) */ TODO {
            elaboration := elaborateNeverIntersection(undefined, baseType)
            diagnostic := chainDiagnosticMessages(elaboration, /* TODO(PropertyAccessExpression): Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members */ TODO, typeToString(reducedBaseType))
            /* TODO(ExpressionStatement): diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(baseTypeNode.expression), baseTypeNode.expression, diagnostic)); */
             /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
        }
        if /* TODO(BinaryExpression): type === reducedBaseType || hasBaseType(reducedBaseType, type) */ TODO {
            /* TODO(ExpressionStatement): error(type.symbol.valueDeclaration, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, /*enclosingDeclaration* / undefined, TypeFormatFlags.WriteArrayAsGenericType)); */
             /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
        }
        if /* TODO(BinaryExpression): type.resolvedBaseTypes === resolvingEmptyArray */ TODO {
            /* TODO(ExpressionStatement): type.members = undefined; */
        }
         /* TODO(BinaryExpression): type.resolvedBaseTypes = [reducedBaseType] */ TODO
    }
    areAllOuterTypeParametersApplied := func(type_ Type) bool {
        outerTypeParameters := /* TODO(PropertyAccessExpression): (type as InterfaceType).outerTypeParameters */ TODO
        if outerTypeParameters {
            last := /* TODO(BinaryExpression): outerTypeParameters.length - 1 */ TODO
            typeArguments := getTypeArguments(type_ /* as */ /* TODO(TypeReference): TypeReference */)
             /* TODO(BinaryExpression): outerTypeParameters[last].symbol !== typeArguments[last].symbol */ TODO
        }
         /* TODO(TrueKeyword): true */ TODO
    }
    isValidBaseType := func(type_ Type) /* TODO(TypePredicate): type is BaseType */ TODO {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.TypeParameter */ TODO {
            constraint := getBaseConstraintOfType(type_)
            if constraint {
                 isValidBaseType(constraint)
            }
        }
         /* TODO(PrefixUnaryExpression): !!(type.flags & (TypeFlags.Object | TypeFlags.NonPrimitive | TypeFlags.Any) && !isGenericMappedType(type) ||             type.flags & TypeFlags.Intersection && every((type as IntersectionType).types, isValidBaseType)) */ TODO
    }
    resolveBaseTypesOfInterface := func(type_ InterfaceType) {
        /* TODO(ExpressionStatement): type.resolvedBaseTypes = type.resolvedBaseTypes || emptyArray; */
        if /* TODO(PropertyAccessExpression): type.symbol.declarations */ TODO {
            /* TODO(ForOfStatement): for (const declaration of type.symbol.declarations) {                 if (declaration.kind === SyntaxKind.InterfaceDeclaration && getInterfaceBaseTypeNodes(declaration as InterfaceDeclaration)) {                     for (const node of getInterfaceBaseTypeNodes(declaration as InterfaceDeclaration)!) {                         const baseType = getReducedType(getTypeFromTypeNode(node));                         if (!isErrorType(baseType)) {                             if (isValidBaseType(baseType)) {                                 if (type !== baseType && !hasBaseType(baseType, type)) {                                     if (type.resolvedBaseTypes === emptyArray) {                                         type.resolvedBaseTypes = [baseType as ObjectType];                                     }                                     else {                                         type.resolvedBaseTypes.push(baseType);                                     }                                 }                                 else {                                     reportCircularBaseType(declaration, type);                                 }                             }                             else {                                 error(node, Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members);                             }                         }                     }                 }             } */
        }
    }
    isThislessInterface := func(symbol Symbol) bool {
        if /* TODO(PrefixUnaryExpression): !symbol.declarations */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        /* TODO(ForOfStatement): for (const declaration of symbol.declarations) {             if (declaration.kind === SyntaxKind.InterfaceDeclaration) {                 if (declaration.flags & NodeFlags.ContainsThis) {                     return false;                 }                 const baseTypeNodes = getInterfaceBaseTypeNodes(declaration as InterfaceDeclaration);                 if (baseTypeNodes) {                     for (const node of baseTypeNodes) {                         if (isEntityNameExpression(node.expression)) {                             const baseSymbol = resolveEntityName(node.expression, SymbolFlags.Type, /*ignoreErrors* / true);                             if (!baseSymbol || !(baseSymbol.flags & SymbolFlags.Interface) || getDeclaredTypeOfClassOrInterface(baseSymbol).thisType) {                                 return false;                             }                         }                     }                 }             }         } */
         /* TODO(TrueKeyword): true */ TODO
    }
    getDeclaredTypeOfClassOrInterface := func(symbol Symbol) InterfaceType {
        links := getSymbolLinks(symbol)
        originalLinks := links
        if /* TODO(PrefixUnaryExpression): !links.declaredType */ TODO {
            kind := /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Class ? ObjectFlags.Class : ObjectFlags.Interface */ TODO
            merged := mergeJSSymbols(symbol, /* TODO(BinaryExpression): symbol.valueDeclaration && getAssignedClassSymbol(symbol.valueDeclaration) */ TODO)
            if merged {
                /* TODO(ExpressionStatement): symbol = merged; */
                /* TODO(ExpressionStatement): links = merged.links; */
            }
            type_ := /* TODO(BinaryExpression): originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol) as InterfaceType */ TODO
            outerTypeParameters := getOuterTypeParametersOfClassOrInterface(symbol)
            localTypeParameters := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
            if /* TODO(BinaryExpression): outerTypeParameters || localTypeParameters || kind === ObjectFlags.Class || !isThislessInterface(symbol) */ TODO {
                /* TODO(ExpressionStatement): type.objectFlags |= ObjectFlags.Reference; */
                /* TODO(ExpressionStatement): type.typeParameters = concatenate(outerTypeParameters, localTypeParameters); */
                /* TODO(ExpressionStatement): type.outerTypeParameters = outerTypeParameters; */
                /* TODO(ExpressionStatement): type.localTypeParameters = localTypeParameters; */
                /* TODO(ExpressionStatement): (type as GenericType).instantiations = new Map<string, TypeReference>(); */
                /* TODO(ExpressionStatement): (type as GenericType).instantiations.set(getTypeListId(type.typeParameters), type as GenericType); */
                /* TODO(ExpressionStatement): (type as GenericType).target = type as GenericType; */
                /* TODO(ExpressionStatement): (type as GenericType).resolvedTypeArguments = type.typeParameters; */
                /* TODO(ExpressionStatement): type.thisType = createTypeParameter(symbol); */
                /* TODO(ExpressionStatement): type.thisType.isThisType = true; */
                /* TODO(ExpressionStatement): type.thisType.constraint = type; */
            }
        }
         /* TODO(PropertyAccessExpression): links.declaredType */ TODO /* as */ /* TODO(TypeReference): InterfaceType */
    }
    getDeclaredTypeOfTypeAlias := func(symbol Symbol) Type {
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.declaredType */ TODO {
            if /* TODO(PrefixUnaryExpression): !pushTypeResolution(symbol, TypeSystemPropertyName.DeclaredType) */ TODO {
                 errorType
            }
            declaration := /* TODO(PropertyAccessExpression): Debug.checkDefined */ TODO(/* TODO(PropertyAccessExpression): symbol.declarations?.find */ TODO(isTypeAlias), "Type alias symbol with no valid declaration found")
            typeNode := /* TODO(ConditionalExpression): isJSDocTypeAlias(declaration) ? declaration.typeExpression : declaration.type */ TODO
            type_ := /* TODO(ConditionalExpression): typeNode ? getTypeFromTypeNode(typeNode) : errorType */ TODO
            if popTypeResolution() {
                typeParameters := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
                if typeParameters {
                    /* TODO(ExpressionStatement): links.typeParameters = typeParameters; */
                    /* TODO(ExpressionStatement): links.instantiations = new Map<string, Type>(); */
                    /* TODO(ExpressionStatement): links.instantiations.set(getTypeListId(typeParameters), type); */
                }
                if /* TODO(BinaryExpression): type === intrinsicMarkerType && symbol.escapedName === "BuiltinIteratorReturn" */ TODO {
                    /* TODO(ExpressionStatement): type = getBuiltinIteratorReturnType(); */
                }
            } else {
                /* TODO(ExpressionStatement): type = errorType; */
                if /* TODO(BinaryExpression): declaration.kind === SyntaxKind.JSDocEnumTag */ TODO {
                    /* TODO(ExpressionStatement): error(declaration.typeExpression.type, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol)); */
                } else {
                    /* TODO(ExpressionStatement): error(isNamedDeclaration(declaration) ? declaration.name || declaration : declaration, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol)); */
                }
            }
            /* TODO(ExpressionStatement): links.declaredType ??= type; */
        }
         /* TODO(PropertyAccessExpression): links.declaredType */ TODO
    }
    getBaseTypeOfEnumLikeType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike && type.symbol.flags & SymbolFlags.EnumMember ? getDeclaredTypeOfSymbol(getParentOfSymbol(type.symbol)!) : type */ TODO
    }
    getDeclaredTypeOfEnum := func(symbol Symbol) Type {
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.declaredType */ TODO {
            var memberTypeList []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
            if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
                /* TODO(ForOfStatement): for (const declaration of symbol.declarations) {                     if (declaration.kind === SyntaxKind.EnumDeclaration) {                         for (const member of (declaration as EnumDeclaration).members) {                             if (hasBindableName(member)) {                                 const memberSymbol = getSymbolOfDeclaration(member);                                 const value = getEnumMemberValue(member).value;                                 const memberType = getFreshTypeOfLiteralType(                                     value !== undefined ?                                         getEnumLiteralType(value, getSymbolId(symbol), memberSymbol) :                                         createComputedEnumType(memberSymbol),                                 );                                 getSymbolLinks(memberSymbol).declaredType = memberType;                                 memberTypeList.push(getRegularTypeOfLiteralType(memberType));                             }                         }                     }                 } */
            }
            enumType := /* TODO(ConditionalExpression): memberTypeList.length ?                 getUnionType(memberTypeList, UnionReduction.Literal, symbol, /*aliasTypeArguments* / undefined) :                 createComputedEnumType(symbol) */ TODO
            if /* TODO(BinaryExpression): enumType.flags & TypeFlags.Union */ TODO {
                /* TODO(ExpressionStatement): enumType.flags |= TypeFlags.EnumLiteral; */
                /* TODO(ExpressionStatement): enumType.symbol = symbol; */
            }
            /* TODO(ExpressionStatement): links.declaredType = enumType; */
        }
         /* TODO(PropertyAccessExpression): links.declaredType */ TODO
    }
    createComputedEnumType := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EnumType */ TODO {
        regularType := createTypeWithSymbol(/* TODO(PropertyAccessExpression): TypeFlags.Enum */ TODO, symbol) /* as */ /* TODO(TypeReference): EnumType */
        freshType := createTypeWithSymbol(/* TODO(PropertyAccessExpression): TypeFlags.Enum */ TODO, symbol) /* as */ /* TODO(TypeReference): EnumType */
        /* TODO(ExpressionStatement): regularType.regularType = regularType; */
        /* TODO(ExpressionStatement): regularType.freshType = freshType; */
        /* TODO(ExpressionStatement): freshType.regularType = regularType; */
        /* TODO(ExpressionStatement): freshType.freshType = freshType; */
         regularType
    }
    getDeclaredTypeOfEnumMember := func(symbol Symbol) Type {
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.declaredType */ TODO {
            enumType := getDeclaredTypeOfEnum(/* TODO(NonNullExpression): getParentOfSymbol(symbol)! */ TODO)
            if /* TODO(PrefixUnaryExpression): !links.declaredType */ TODO {
                /* TODO(ExpressionStatement): links.declaredType = enumType; */
            }
        }
         /* TODO(PropertyAccessExpression): links.declaredType */ TODO
    }
    getDeclaredTypeOfTypeParameter := func(symbol Symbol) TypeParameter {
        links := getSymbolLinks(symbol)
         /* TODO(BinaryExpression): links.declaredType || (links.declaredType = createTypeParameter(symbol)) */ TODO
    }
    getDeclaredTypeOfAlias := func(symbol Symbol) Type {
        links := getSymbolLinks(symbol)
         /* TODO(BinaryExpression): links.declaredType || (links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol))) */ TODO
    }
    getDeclaredTypeOfSymbol := func(symbol Symbol) Type {
         /* TODO(BinaryExpression): tryGetDeclaredTypeOfSymbol(symbol) || errorType */ TODO
    }
    tryGetDeclaredTypeOfSymbol := func(symbol Symbol) *Type {
        if /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface) */ TODO {
             getDeclaredTypeOfClassOrInterface(symbol)
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeAlias */ TODO {
             getDeclaredTypeOfTypeAlias(symbol)
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeParameter */ TODO {
             getDeclaredTypeOfTypeParameter(symbol)
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Enum */ TODO {
             getDeclaredTypeOfEnum(symbol)
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.EnumMember */ TODO {
             getDeclaredTypeOfEnumMember(symbol)
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO {
             getDeclaredTypeOfAlias(symbol)
        }
         undefined
    }
    isThislessType := func(node TypeNode) bool {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AnyKeyword:             case SyntaxKind.UnknownKeyword:             case SyntaxKind.StringKeyword:             case SyntaxKind.NumberKeyword:             case SyntaxKind.BigIntKeyword:             case SyntaxKind.BooleanKeyword:             case SyntaxKind.SymbolKeyword:             case SyntaxKind.ObjectKeyword:             case SyntaxKind.VoidKeyword:             case SyntaxKind.UndefinedKeyword:             case SyntaxKind.NeverKeyword:             case SyntaxKind.LiteralType:                 return true;             case SyntaxKind.ArrayType:                 return isThislessType((node as ArrayTypeNode).elementType);             case SyntaxKind.TypeReference:                 return !(node as TypeReferenceNode).typeArguments || (node as TypeReferenceNode).typeArguments!.every(isThislessType);         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    isThislessTypeParameter := func(node TypeParameterDeclaration) /* TODO(undefined): boolean */ TODO {
        constraint := getEffectiveConstraintOfTypeParameter(node)
         /* TODO(BinaryExpression): !constraint || isThislessType(constraint) */ TODO
    }
    isThislessVariableLikeDeclaration := func(node VariableLikeDeclaration) bool {
        typeNode := getEffectiveTypeAnnotationNode(node)
         /* TODO(ConditionalExpression): typeNode ? isThislessType(typeNode) : !hasInitializer(node) */ TODO
    }
    isThislessFunctionLikeDeclaration := func(node FunctionLikeDeclaration) bool {
        returnType := getEffectiveReturnTypeNode(node)
        typeParameters := getEffectiveTypeParameterDeclarations(node)
         /* TODO(BinaryExpression): (node.kind === SyntaxKind.Constructor || (!!returnType && isThislessType(returnType))) &&             node.parameters.every(isThislessVariableLikeDeclaration) &&             typeParameters.every(isThislessTypeParameter) */ TODO
    }
    isThisless := func(symbol Symbol) bool {
        if /* TODO(BinaryExpression): symbol.declarations && symbol.declarations.length === 1 */ TODO {
            declaration := /* TODO(ElementAccessExpression): symbol.declarations[0] */ TODO
            if declaration {
                /* TODO(SwitchStatement): switch (declaration.kind) {                     case SyntaxKind.PropertyDeclaration:                     case SyntaxKind.PropertySignature:                         return isThislessVariableLikeDeclaration(declaration as VariableLikeDeclaration);                     case SyntaxKind.MethodDeclaration:                     case SyntaxKind.MethodSignature:                     case SyntaxKind.Constructor:                     case SyntaxKind.GetAccessor:                     case SyntaxKind.SetAccessor:                         return isThislessFunctionLikeDeclaration(declaration as FunctionLikeDeclaration | AccessorDeclaration);                 } */
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    createInstantiatedSymbolTable := func(symbols []Symbol, mapper TypeMapper, mappingThisOnly bool) SymbolTable {
        result := createSymbolTable()
        /* TODO(ForOfStatement): for (const symbol of symbols) {             result.set(symbol.escapedName, mappingThisOnly && isThisless(symbol) ? symbol : instantiateSymbol(symbol, mapper));         } */
         result
    }
    addInheritedMembers := func(symbols SymbolTable, baseSymbols []Symbol) {
        /* TODO(ForOfStatement): for (const base of baseSymbols) {             if (isStaticPrivateIdentifierProperty(base)) {                 continue;             }             const derived = symbols.get(base.escapedName);             if (                 !derived                 // non-constructor/static-block assignment declarations are ignored here; they're not treated as overrides                 || derived.valueDeclaration                     && isBinaryExpression(derived.valueDeclaration)                     && !isConstructorDeclaredProperty(derived)                     && !getContainingClassStaticBlock(derived.valueDeclaration)             ) {                 symbols.set(base.escapedName, base);                 symbols.set(base.escapedName, base);             }         } */
    }
    isStaticPrivateIdentifierProperty := func(s Symbol) bool {
         /* TODO(BinaryExpression): !!s.valueDeclaration && isPrivateIdentifierClassElementDeclaration(s.valueDeclaration) && isStatic(s.valueDeclaration) */ TODO
    }
    resolveDeclaredMembers := func(type_ InterfaceType) InterfaceTypeWithDeclaredMembers {
        if /* TODO(PrefixUnaryExpression): !(type as InterfaceTypeWithDeclaredMembers).declaredProperties */ TODO {
            symbol := /* TODO(PropertyAccessExpression): type.symbol */ TODO
            members := getMembersOfSymbol(symbol)
            /* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredProperties = getNamedMembers(members); */
            /* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredCallSignatures = emptyArray; */
            /* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredConstructSignatures = emptyArray; */
            /* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredIndexInfos = emptyArray; */
            /* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredCallSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.Call)); */
            /* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredConstructSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.New)); */
            /* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredIndexInfos = getIndexInfosOfSymbol(symbol); */
        }
         type_ /* as */ /* TODO(TypeReference): InterfaceTypeWithDeclaredMembers */
    }
    isLateBindableName := func(node DeclarationName) /* TODO(TypePredicate): node is LateBoundName */ TODO {
        if /* TODO(BinaryExpression): !isComputedPropertyName(node) && !isElementAccessExpression(node) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        expr := /* TODO(ConditionalExpression): isComputedPropertyName(node) ? node.expression : node.argumentExpression */ TODO
         /* TODO(BinaryExpression): isEntityNameExpression(expr)             && isTypeUsableAsPropertyName(isComputedPropertyName(node) ? checkComputedPropertyName(node) : checkExpressionCached(expr)) */ TODO
    }
    isLateBoundName := func(name __String) bool {
         /* TODO(BinaryExpression): (name as string).charCodeAt(0) === CharacterCodes._ &&             (name as string).charCodeAt(1) === CharacterCodes._ &&             (name as string).charCodeAt(2) === CharacterCodes.at */ TODO
    }
    hasLateBindableName := func(node Declaration) /* TODO(TypePredicate): node is LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ TODO {
        name := getNameOfDeclaration(node)
         /* TODO(BinaryExpression): !!name && isLateBindableName(name) */ TODO
    }
    hasBindableName := func(node Declaration) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !hasDynamicName(node) || hasLateBindableName(node) */ TODO
    }
    isNonBindableDynamicName := func(node DeclarationName) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isDynamicName(node) && !isLateBindableName(node) */ TODO
    }
    addDeclarationToLateBoundSymbol := func(symbol Symbol, member /* TODO(UnionType): LateBoundDeclaration | BinaryExpression */ any, symbolFlags SymbolFlags) {
        /* TODO(ExpressionStatement): Debug.assert(!!(getCheckFlags(symbol) & CheckFlags.Late), "Expected a late-bound symbol."); */
        /* TODO(ExpressionStatement): symbol.flags |= symbolFlags; */
        /* TODO(ExpressionStatement): getSymbolLinks(member.symbol).lateSymbol = symbol; */
        if /* TODO(PrefixUnaryExpression): !symbol.declarations */ TODO {
            /* TODO(ExpressionStatement): symbol.declarations = [member]; */
        } else if /* TODO(PrefixUnaryExpression): !member.symbol.isReplaceableByMethod */ TODO {
            /* TODO(ExpressionStatement): symbol.declarations.push(member); */
        }
        if /* TODO(BinaryExpression): symbolFlags & SymbolFlags.Value */ TODO {
            if /* TODO(BinaryExpression): !symbol.valueDeclaration || symbol.valueDeclaration.kind !== member.kind */ TODO {
                /* TODO(ExpressionStatement): symbol.valueDeclaration = member; */
            }
        }
    }
    lateBindMember := func(parent Symbol, earlySymbols *SymbolTable, lateSymbols Map[__String, TransientSymbol], decl /* TODO(UnionType): LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
        /* TODO(ExpressionStatement): Debug.assert(!!decl.symbol, "The member is expected to have a symbol."); */
        links := getNodeLinks(decl)
        if /* TODO(PrefixUnaryExpression): !links.resolvedSymbol */ TODO {
            /* TODO(ExpressionStatement): links.resolvedSymbol = decl.symbol; */
            declName := /* TODO(ConditionalExpression): isBinaryExpression(decl) ? decl.left : decl.name */ TODO
            type_ := /* TODO(ConditionalExpression): isElementAccessExpression(declName) ? checkExpressionCached(declName.argumentExpression) : checkComputedPropertyName(declName) */ TODO
            if isTypeUsableAsPropertyName(type_) {
                memberName := getPropertyNameFromType(type_)
                symbolFlags := /* TODO(PropertyAccessExpression): decl.symbol.flags */ TODO
                lateSymbol := /* TODO(PropertyAccessExpression): lateSymbols.get */ TODO(memberName)
                if /* TODO(PrefixUnaryExpression): !lateSymbol */ TODO {
                    /* TODO(CallExpression): lateSymbols.set(memberName, lateSymbol = createSymbol(SymbolFlags.None, memberName, CheckFlags.Late)) */
                }
                earlySymbol := /* TODO(BinaryExpression): earlySymbols && earlySymbols.get(memberName) */ TODO
                if /* TODO(BinaryExpression): !(parent.flags & SymbolFlags.Class) && lateSymbol.flags & getExcludedSymbolFlags(symbolFlags) */ TODO {
                    declarations := /* TODO(ConditionalExpression): earlySymbol ? concatenate(earlySymbol.declarations, lateSymbol.declarations) : lateSymbol.declarations */ TODO
                    name := /* TODO(BinaryExpression): !(type.flags & TypeFlags.UniqueESSymbol) && unescapeLeadingUnderscores(memberName) || declarationNameToString(declName) */ TODO
                    /* TODO(ExpressionStatement): forEach(declarations, declaration => error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Property_0_was_also_declared_here, name)); */
                    /* TODO(ExpressionStatement): error(declName || decl, Diagnostics.Duplicate_property_0, name); */
                    /* TODO(ExpressionStatement): lateSymbol = createSymbol(SymbolFlags.None, memberName, CheckFlags.Late); */
                }
                /* TODO(ExpressionStatement): lateSymbol.links.nameType = type; */
                /* TODO(ExpressionStatement): addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags); */
                if /* TODO(PropertyAccessExpression): lateSymbol.parent */ TODO {
                    /* TODO(ExpressionStatement): Debug.assert(lateSymbol.parent === parent, "Existing symbol parent should match new one"); */
                } else {
                    /* TODO(ExpressionStatement): lateSymbol.parent = parent; */
                }
                 /* TODO(BinaryExpression): links.resolvedSymbol = lateSymbol */ TODO
            }
        }
         /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO
    }
    getResolvedMembersOrExportsOfSymbol := func(symbol Symbol, resolutionKind MembersOrExportsResolutionKind) Map[__String, Symbol] {
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links[resolutionKind] */ TODO {
            isStatic := /* TODO(BinaryExpression): resolutionKind === MembersOrExportsResolutionKind.resolvedExports */ TODO
            earlySymbols := /* TODO(ConditionalExpression): !isStatic ? symbol.members :                 symbol.flags & SymbolFlags.Module ? getExportsOfModuleWorker(symbol).exports :                 symbol.exports */ TODO
            /* TODO(ExpressionStatement): links[resolutionKind] = earlySymbols || emptySymbols; */
            lateSymbols := createSymbolTable() /* as */ /* TODO(TypeReference): Map<__String, TransientSymbol> */
            /* TODO(ForOfStatement): for (const decl of symbol.declarations || emptyArray) {                 const members = getMembersOfDeclaration(decl);                 if (members) {                     for (const member of members) {                         if (isStatic === hasStaticModifier(member)) {                             if (hasLateBindableName(member)) {                                 lateBindMember(symbol, earlySymbols, lateSymbols, member);                             }                         }                     }                 }             } */
            assignments := /* TODO(PropertyAccessExpression): getFunctionExpressionParentSymbolOrSymbol(symbol).assignmentDeclarationMembers */ TODO
            if assignments {
                decls := arrayFrom(/* TODO(PropertyAccessExpression): assignments.values */ TODO())
                /* TODO(ForOfStatement): for (const member of decls) {                     const assignmentKind = getAssignmentDeclarationKind(member as BinaryExpression | CallExpression);                     const isInstanceMember = assignmentKind === AssignmentDeclarationKind.PrototypeProperty                         || isBinaryExpression(member) && isPossiblyAliasedThisProperty(member, assignmentKind)                         || assignmentKind === AssignmentDeclarationKind.ObjectDefinePrototypeProperty                         || assignmentKind === AssignmentDeclarationKind.Prototype; // A straight `Prototype` assignment probably can never have a computed name                     if (isStatic === !isInstanceMember) {                         if (hasLateBindableName(member)) {                             lateBindMember(symbol, earlySymbols, lateSymbols, member);                         }                     }                 } */
            }
            resolved := combineSymbolTables(earlySymbols, lateSymbols)
            if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Transient && links.cjsExportMerged && symbol.declarations */ TODO {
                /* TODO(ForOfStatement): for (const decl of symbol.declarations) {                     const original = getSymbolLinks(decl.symbol)[resolutionKind];                     if (!resolved) {                         resolved = original;                         continue;                     }                     if (!original) continue;                     original.forEach((s, name) => {                         const existing = resolved!.get(name);                         if (!existing) resolved!.set(name, s);                         else if (existing === s) return;                         else resolved!.set(name, mergeSymbol(existing, s));                     });                 } */
            }
            /* TODO(ExpressionStatement): links[resolutionKind] = resolved || emptySymbols; */
        }
         /* TODO(ElementAccessExpression): links[resolutionKind] */ TODO
    }
    getMembersOfSymbol := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ TODO {
         /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.LateBindingContainer             ? getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKind.resolvedMembers)             : symbol.members || emptySymbols */ TODO
    }
    getLateBoundSymbol := func(symbol Symbol) Symbol {
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ClassMember && symbol.escapedName === InternalSymbolName.Computed */ TODO {
            links := getSymbolLinks(symbol)
            if /* TODO(BinaryExpression): !links.lateSymbol && some(symbol.declarations, hasLateBindableName) */ TODO {
                parent := /* TODO(NonNullExpression): getMergedSymbol(symbol.parent)! */ TODO
                if some(/* TODO(PropertyAccessExpression): symbol.declarations */ TODO, hasStaticModifier) {
                    /* TODO(ExpressionStatement): getExportsOfSymbol(parent); */
                } else {
                    /* TODO(ExpressionStatement): getMembersOfSymbol(parent); */
                }
            }
             /* TODO(BinaryExpression): links.lateSymbol || (links.lateSymbol = symbol) */ TODO
        }
         symbol
    }
    getTypeWithThisArgument := func(type_ Type, thisArgument Type, needApparentType bool) Type {
        if /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.Reference */ TODO {
            target := /* TODO(PropertyAccessExpression): (type as TypeReference).target */ TODO
            typeArguments := getTypeArguments(type_ /* as */ /* TODO(TypeReference): TypeReference */)
             /* TODO(ConditionalExpression): length(target.typeParameters) === length(typeArguments) ? createTypeReference(target, concatenate(typeArguments, [thisArgument || target.thisType!])) : type */ TODO
        } else if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
            types := sameMap(/* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, /* TODO(ArrowFunction): t => getTypeWithThisArgument(t, thisArgument, needApparentType) */ TODO)
             /* TODO(ConditionalExpression): types !== (type as IntersectionType).types ? getIntersectionType(types) : type */ TODO
        }
         /* TODO(ConditionalExpression): needApparentType ? getApparentType(type) : type */ TODO
    }
    resolveObjectTypeMembers := func(type_ ObjectType, source InterfaceTypeWithDeclaredMembers, typeParameters []TypeParameter, typeArguments []Type) {
        var mapper *TypeMapper
        var members SymbolTable
        var callSignatures []Signature
        var constructSignatures []Signature
        var indexInfos []IndexInfo
        if rangeEquals(typeParameters, typeArguments, 0, /* TODO(PropertyAccessExpression): typeParameters.length */ TODO) {
            /* TODO(ExpressionStatement): members = source.symbol ? getMembersOfSymbol(source.symbol) : createSymbolTable(source.declaredProperties); */
            /* TODO(ExpressionStatement): callSignatures = source.declaredCallSignatures; */
            /* TODO(ExpressionStatement): constructSignatures = source.declaredConstructSignatures; */
            /* TODO(ExpressionStatement): indexInfos = source.declaredIndexInfos; */
        } else {
            /* TODO(ExpressionStatement): mapper = createTypeMapper(typeParameters, typeArguments); */
            /* TODO(ExpressionStatement): members = createInstantiatedSymbolTable(source.declaredProperties, mapper, /*mappingThisOnly* / typeParameters.length === 1); */
            /* TODO(ExpressionStatement): callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper); */
            /* TODO(ExpressionStatement): constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper); */
            /* TODO(ExpressionStatement): indexInfos = instantiateIndexInfos(source.declaredIndexInfos, mapper); */
        }
        baseTypes := getBaseTypes(source)
        if /* TODO(PropertyAccessExpression): baseTypes.length */ TODO {
            if /* TODO(BinaryExpression): source.symbol && members === getMembersOfSymbol(source.symbol) */ TODO {
                symbolTable := createSymbolTable(/* TODO(PropertyAccessExpression): source.declaredProperties */ TODO)
                sourceIndex := getIndexSymbol(/* TODO(PropertyAccessExpression): source.symbol */ TODO)
                if sourceIndex {
                    /* TODO(ExpressionStatement): symbolTable.set(InternalSymbolName.Index, sourceIndex); */
                }
                /* TODO(ExpressionStatement): members = symbolTable; */
            }
            /* TODO(ExpressionStatement): setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos); */
            thisArgument := lastOrUndefined(typeArguments)
            /* TODO(ForOfStatement): for (const baseType of baseTypes) {                 const instantiatedBaseType = thisArgument ? getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument) : baseType;                 addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType));                 callSignatures = concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKind.Call));                 constructSignatures = concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKind.Construct));                 const inheritedIndexInfos = instantiatedBaseType !== anyType ? getIndexInfosOfType(instantiatedBaseType) : [createIndexInfo(stringType, anyType, /*isReadonly* / false)];                 indexInfos = concatenate(indexInfos, filter(inheritedIndexInfos, info => !findIndexInfo(indexInfos, info.keyType)));             } */
        }
        /* TODO(ExpressionStatement): setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos); */
    }
    resolveClassOrInterfaceMembers := func(type_ InterfaceType) {
        /* TODO(ExpressionStatement): resolveObjectTypeMembers(type, resolveDeclaredMembers(type), emptyArray, emptyArray); */
    }
    resolveTypeReferenceMembers := func(type_ TypeReference) {
        source := resolveDeclaredMembers(/* TODO(PropertyAccessExpression): type.target */ TODO)
        typeParameters := concatenate(/* TODO(NonNullExpression): source.typeParameters! */ TODO, /* TODO(ArrayLiteralExpression): [source.thisType!] */ TODO)
        typeArguments := getTypeArguments(type_)
        paddedTypeArguments := /* TODO(ConditionalExpression): typeArguments.length === typeParameters.length ? typeArguments : concatenate(typeArguments, [type]) */ TODO
        /* TODO(ExpressionStatement): resolveObjectTypeMembers(type, source, typeParameters, paddedTypeArguments); */
    }
    createSignature := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature | undefined */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, thisParameter *Symbol, parameters []Symbol, resolvedReturnType *Type, resolvedTypePredicate *TypePredicate, minArgumentCount number, flags SignatureFlags) Signature {
        sig := /* TODO(NewExpression): new Signature(checker, flags) */ TODO
        /* TODO(ExpressionStatement): sig.declaration = declaration; */
        /* TODO(ExpressionStatement): sig.typeParameters = typeParameters; */
        /* TODO(ExpressionStatement): sig.parameters = parameters; */
        /* TODO(ExpressionStatement): sig.thisParameter = thisParameter; */
        /* TODO(ExpressionStatement): sig.resolvedReturnType = resolvedReturnType; */
        /* TODO(ExpressionStatement): sig.resolvedTypePredicate = resolvedTypePredicate; */
        /* TODO(ExpressionStatement): sig.minArgumentCount = minArgumentCount; */
        /* TODO(ExpressionStatement): sig.resolvedMinArgumentCount = undefined; */
        /* TODO(ExpressionStatement): sig.target = undefined; */
        /* TODO(ExpressionStatement): sig.mapper = undefined; */
        /* TODO(ExpressionStatement): sig.compositeSignatures = undefined; */
        /* TODO(ExpressionStatement): sig.compositeKind = undefined; */
         sig
    }
    cloneSignature := func(sig Signature) Signature {
        result := createSignature(/* TODO(PropertyAccessExpression): sig.declaration */ TODO, /* TODO(PropertyAccessExpression): sig.typeParameters */ TODO, /* TODO(PropertyAccessExpression): sig.thisParameter */ TODO, /* TODO(PropertyAccessExpression): sig.parameters */ TODO, undefined, undefined, /* TODO(PropertyAccessExpression): sig.minArgumentCount */ TODO, /* TODO(BinaryExpression): sig.flags & SignatureFlags.PropagatingFlags */ TODO)
        /* TODO(ExpressionStatement): result.target = sig.target; */
        /* TODO(ExpressionStatement): result.mapper = sig.mapper; */
        /* TODO(ExpressionStatement): result.compositeSignatures = sig.compositeSignatures; */
        /* TODO(ExpressionStatement): result.compositeKind = sig.compositeKind; */
         result
    }
    createUnionSignature := func(signature Signature, unionSignatures []Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
        result := cloneSignature(signature)
        /* TODO(ExpressionStatement): result.compositeSignatures = unionSignatures; */
        /* TODO(ExpressionStatement): result.compositeKind = TypeFlags.Union; */
        /* TODO(ExpressionStatement): result.target = undefined; */
        /* TODO(ExpressionStatement): result.mapper = undefined; */
         result
    }
    getOptionalCallSignature := func(signature Signature, callChainFlags SignatureFlags) Signature {
        if /* TODO(BinaryExpression): (signature.flags & SignatureFlags.CallChainFlags) === callChainFlags */ TODO {
             signature
        }
        if /* TODO(PrefixUnaryExpression): !signature.optionalCallSignatureCache */ TODO {
            /* TODO(ExpressionStatement): signature.optionalCallSignatureCache = {}; */
        }
        key := /* TODO(ConditionalExpression): callChainFlags === SignatureFlags.IsInnerCallChain ? "inner" : "outer" */ TODO
         /* TODO(BinaryExpression): signature.optionalCallSignatureCache[key]             || (signature.optionalCallSignatureCache[key] = createOptionalCallSignature(signature, callChainFlags)) */ TODO
    }
    createOptionalCallSignature := func(signature Signature, callChainFlags SignatureFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
        /* TODO(ExpressionStatement): Debug.assert(callChainFlags === SignatureFlags.IsInnerCallChain || callChainFlags === SignatureFlags.IsOuterCallChain, "An optional call signature can either be for an inner call chain or an outer call chain, but not both."); */
        result := cloneSignature(signature)
        /* TODO(ExpressionStatement): result.flags |= callChainFlags; */
         result
    }
    getExpandedParameters := func(sig Signature, skipUnionExpanding bool) [][]Symbol {
        if signatureHasRestParameter(sig) {
            restIndex := /* TODO(BinaryExpression): sig.parameters.length - 1 */ TODO
            restSymbol := /* TODO(ElementAccessExpression): sig.parameters[restIndex] */ TODO
            restType := getTypeOfSymbol(restSymbol)
            if isTupleType(restType) {
                 /* TODO(ArrayLiteralExpression): [expandSignatureParametersWithTupleMembers(restType, restIndex, restSymbol)] */ TODO
            } else if /* TODO(BinaryExpression): !skipUnionExpanding && restType.flags & TypeFlags.Union && every((restType as UnionType).types, isTupleType) */ TODO {
                 map_(/* TODO(PropertyAccessExpression): (restType as UnionType).types */ TODO, /* TODO(ArrowFunction): t => expandSignatureParametersWithTupleMembers(t as TupleTypeReference, restIndex, restSymbol) */ TODO)
            }
        }
         /* TODO(ArrayLiteralExpression): [sig.parameters] */ TODO
        expandSignatureParametersWithTupleMembers := func(restType TupleTypeReference, restIndex number, restSymbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
            elementTypes := getTypeArguments(restType)
            associatedNames := getUniqAssociatedNamesFromTupleType(restType, restSymbol)
            restParams := map_(elementTypes, /* TODO(ArrowFunction): (t, i) => {                 // Lookup the label from the individual tuple passed in before falling back to the signature `rest` parameter name                 const name = associatedNames && associatedNames[i] ? associatedNames[i] :                     getParameterNameAtPosition(sig, restIndex + i, restType);                 const flags = restType.target.elementFlags[i];                 const checkFlags = flags & ElementFlags.Variable ? CheckFlags.RestParameter :                     flags & ElementFlags.Optional ? CheckFlags.OptionalParameter : 0;                 const symbol = createSymbol(SymbolFlags.FunctionScopedVariable, name, checkFlags);                 symbol.links.type = flags & ElementFlags.Rest ? createArrayType(t) : t;                 return symbol;             } */ TODO)
             concatenate(/* TODO(PropertyAccessExpression): sig.parameters.slice */ TODO(0, restIndex), restParams)
        }
        getUniqAssociatedNamesFromTupleType := func(type_ TupleTypeReference, restSymbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String[] | undefined */ TODO {
            names := map_(/* TODO(PropertyAccessExpression): type.target.labeledElementDeclarations */ TODO, /* TODO(ArrowFunction): (labeledElement, i) => getTupleElementLabel(labeledElement, i, type.target.elementFlags[i], restSymbol) */ TODO)
            if names {
                var duplicates []number = /* TODO(ArrayLiteralExpression): [] */ TODO
                uniqueNames := /* TODO(NewExpression): new Set<__String>() */ TODO
                /* TODO(ForStatement): for (let i = 0; i < names.length; i++) {                     const name = names[i];                     if (!tryAddToSet(uniqueNames, name)) {                         duplicates.push(i);                     }                 } */
                counters := /* TODO(NewExpression): new Map<__String, number>() */ TODO
                /* TODO(ForOfStatement): for (const i of duplicates) {                     let counter = counters.get(names[i]) ?? 1;                     let name: __String;                     while (!tryAddToSet(uniqueNames, name = `${names[i]}_${counter}` as __String)) {                         counter++;                     }                     names[i] = name;                     counters.set(names[i], counter + 1);                 } */
            }
             names
        }
    }
    getDefaultConstructSignatures := func(classType InterfaceType) []Signature {
        baseConstructorType := getBaseConstructorTypeOfClass(classType)
        baseSignatures := getSignaturesOfType(baseConstructorType, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO)
        declaration := getClassLikeDeclarationOfSymbol(/* TODO(PropertyAccessExpression): classType.symbol */ TODO)
        isAbstract := /* TODO(BinaryExpression): !!declaration && hasSyntacticModifier(declaration, ModifierFlags.Abstract) */ TODO
        if /* TODO(BinaryExpression): baseSignatures.length === 0 */ TODO {
             /* TODO(ArrayLiteralExpression): [createSignature(/*declaration* / undefined, classType.localTypeParameters, /*thisParameter* / undefined, emptyArray, classType, /*resolvedTypePredicate* / undefined, 0, isAbstract ? SignatureFlags.Abstract : SignatureFlags.None)] */ TODO
        }
        baseTypeNode := /* TODO(NonNullExpression): getBaseTypeNodeOfClass(classType)! */ TODO
        isJavaScript := isInJSFile(baseTypeNode)
        typeArguments := typeArgumentsFromTypeReferenceNode(baseTypeNode)
        typeArgCount := length(typeArguments)
        var result []Signature = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForOfStatement): for (const baseSig of baseSignatures) {             const minTypeArgumentCount = getMinTypeArgumentCount(baseSig.typeParameters);             const typeParamCount = length(baseSig.typeParameters);             if (isJavaScript || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount) {                 const sig = typeParamCount ? createSignatureInstantiation(baseSig, fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript)) : cloneSignature(baseSig);                 sig.typeParameters = classType.localTypeParameters;                 sig.resolvedReturnType = classType;                 sig.flags = isAbstract ? sig.flags | SignatureFlags.Abstract : sig.flags & ~SignatureFlags.Abstract;                 result.push(sig);             }         } */
         result
    }
    findMatchingSignature := func(signatureList []Signature, signature Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool) *Signature {
        /* TODO(ForOfStatement): for (const s of signatureList) {             if (compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes, partialMatch ? compareTypesSubtypeOf : compareTypesIdentical)) {                 return s;             }         } */
    }
    findMatchingSignatures := func(signatureLists [][]Signature, signature Signature, listIndex number) /* TODO(ArrayType): Signature[] */ any {
        if /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO {
            if /* TODO(BinaryExpression): listIndex > 0 */ TODO {
                 undefined
            }
            /* TODO(ForStatement): for (let i = 1; i < signatureLists.length; i++) {                 if (!findMatchingSignature(signatureLists[i], signature, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / false)) {                     return undefined;                 }             } */
             /* TODO(ArrayLiteralExpression): [signature] */ TODO
        }
        var result /* TODO(ArrayType): Signature[] */ any
        /* TODO(ForStatement): for (let i = 0; i < signatureLists.length; i++) {             // Allow matching non-generic signatures to have excess parameters (as a fallback if exact parameter match is not found) and different return types.             // Prefer matching this types if possible.             const match = i === listIndex                 ? signature                 : findMatchingSignature(signatureLists[i], signature, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true)                     || findMatchingSignature(signatureLists[i], signature, /*partialMatch* / true, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true);             if (!match) {                 return undefined;             }             result = appendIfUnique(result, match);         } */
         result
    }
    getUnionSignatures := func(signatureLists [][]Signature) []Signature {
        var result /* TODO(ArrayType): Signature[] */ any
        var indexWithLengthOverOne /* TODO(NumberKeyword): number */ any
        /* TODO(ForStatement): for (let i = 0; i < signatureLists.length; i++) {             if (signatureLists[i].length === 0) return emptyArray;             if (signatureLists[i].length > 1) {                 indexWithLengthOverOne = indexWithLengthOverOne === undefined ? i : -1; // -1 is a signal there are multiple overload sets             }             for (const signature of signatureLists[i]) {                 // Only process signatures with parameter lists that aren't already in the result list                 if (!result || !findMatchingSignature(result, signature, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true)) {                     const unionSignatures = findMatchingSignatures(signatureLists, signature, i);                     if (unionSignatures) {                         let s = signature;                         // Union the result types when more than one signature matches                         if (unionSignatures.length > 1) {                             let thisParameter = signature.thisParameter;                             const firstThisParameterOfUnionSignatures = forEach(unionSignatures, sig => sig.thisParameter);                             if (firstThisParameterOfUnionSignatures) {                                 const thisType = getIntersectionType(mapDefined(unionSignatures, sig => sig.thisParameter && getTypeOfSymbol(sig.thisParameter)));                                 thisParameter = createSymbolWithType(firstThisParameterOfUnionSignatures, thisType);                             }                             s = createUnionSignature(signature, unionSignatures);                             s.thisParameter = thisParameter;                         }                         (result || (result = [])).push(s);                     }                 }             }         } */
        if /* TODO(BinaryExpression): !length(result) && indexWithLengthOverOne !== -1 */ TODO {
            masterList := /* TODO(ElementAccessExpression): signatureLists[indexWithLengthOverOne !== undefined ? indexWithLengthOverOne : 0] */ TODO
            var results /* TODO(ArrayType): Signature[] */ any = /* TODO(PropertyAccessExpression): masterList.slice */ TODO()
            /* TODO(ForOfStatement): for (const signatures of signatureLists) {                 if (signatures !== masterList) {                     const signature = signatures[0];                     Debug.assert(!!signature, "getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass");                     results = !!signature.typeParameters && some(results, s => !!s.typeParameters && !compareTypeParametersIdentical(signature.typeParameters, s.typeParameters)) ? undefined : map(results, sig => combineSignaturesOfUnionMembers(sig, signature));                     if (!results) {                         break;                     }                 }             } */
            /* TODO(ExpressionStatement): result = results; */
        }
         /* TODO(BinaryExpression): result || emptyArray */ TODO
    }
    compareTypeParametersIdentical := func(sourceParams /* TODO(TypeOperator): readonly TypeParameter[] */ any, targetParams /* TODO(TypeOperator): readonly TypeParameter[] */ any) bool {
        if /* TODO(BinaryExpression): length(sourceParams) !== length(targetParams) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): !sourceParams || !targetParams */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        mapper := createTypeMapper(targetParams, sourceParams)
        /* TODO(ForStatement): for (let i = 0; i < sourceParams.length; i++) {             const source = sourceParams[i];             const target = targetParams[i];             if (source === target) continue;             // We instantiate the target type parameter constraints into the source types so we can recognize `<T, U extends T>` as the same as `<A, B extends A>`             if (!isTypeIdenticalTo(getConstraintFromTypeParameter(source) || unknownType, instantiateType(getConstraintFromTypeParameter(target) || unknownType, mapper))) return false;             // We don't compare defaults - we just use the type parameter defaults from the first signature that seems to match.             // It might make sense to combine these defaults in the future, but doing so intelligently requires knowing             // if the parameter is used covariantly or contravariantly (so we intersect if it's used like a parameter or union if used like a return type)             // and, since it's just an inference _default_, just picking one arbitrarily works OK.         } */
         /* TODO(TrueKeyword): true */ TODO
    }
    combineUnionThisParam := func(left *Symbol, right *Symbol, mapper *TypeMapper) *Symbol {
        if /* TODO(BinaryExpression): !left || !right */ TODO {
             /* TODO(BinaryExpression): left || right */ TODO
        }
        thisType := getIntersectionType(/* TODO(ArrayLiteralExpression): [getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)] */ TODO)
         createSymbolWithType(left, thisType)
    }
    combineUnionParameters := func(left Signature, right Signature, mapper *TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
        leftCount := getParameterCount(left)
        rightCount := getParameterCount(right)
        longest := /* TODO(ConditionalExpression): leftCount >= rightCount ? left : right */ TODO
        shorter := /* TODO(ConditionalExpression): longest === left ? right : left */ TODO
        longestCount := /* TODO(ConditionalExpression): longest === left ? leftCount : rightCount */ TODO
        eitherHasEffectiveRest := /* TODO(BinaryExpression): hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right) */ TODO
        needsExtraRestElement := /* TODO(BinaryExpression): eitherHasEffectiveRest && !hasEffectiveRestParameter(longest) */ TODO
        params := /* TODO(NewExpression): new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0)) */ TODO
        /* TODO(ForStatement): for (let i = 0; i < longestCount; i++) {             let longestParamType = tryGetTypeAtPosition(longest, i)!;             if (longest === right) {                 longestParamType = instantiateType(longestParamType, mapper);             }             let shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;             if (shorter === right) {                 shorterParamType = instantiateType(shorterParamType, mapper);             }             const unionParamType = getIntersectionType([longestParamType, shorterParamType]);             const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);             const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);             const leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);             const rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);              const paramName = leftName === rightName ? leftName :                 !leftName ? rightName :                 !rightName ? leftName :                 undefined;             const paramSymbol = createSymbol(                 SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0),                 paramName || `arg${i}` as __String,                 isRestParam ? CheckFlags.RestParameter : isOptional ? CheckFlags.OptionalParameter : 0,             );             paramSymbol.links.type = isRestParam ? createArrayType(unionParamType) : unionParamType;             params[i] = paramSymbol;         } */
        if needsExtraRestElement {
            restParamSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.FunctionScopedVariable */ TODO, "args" /* as */ /* TODO(TypeReference): __String */, /* TODO(PropertyAccessExpression): CheckFlags.RestParameter */ TODO)
            /* TODO(ExpressionStatement): restParamSymbol.links.type = createArrayType(getTypeAtPosition(shorter, longestCount)); */
            if /* TODO(BinaryExpression): shorter === right */ TODO {
                /* TODO(ExpressionStatement): restParamSymbol.links.type = instantiateType(restParamSymbol.links.type, mapper); */
            }
            /* TODO(ExpressionStatement): params[longestCount] = restParamSymbol; */
        }
         params
    }
    combineSignaturesOfUnionMembers := func(left Signature, right Signature) Signature {
        typeParams := /* TODO(BinaryExpression): left.typeParameters || right.typeParameters */ TODO
        var paramMapper *TypeMapper
        if /* TODO(BinaryExpression): left.typeParameters && right.typeParameters */ TODO {
            /* TODO(ExpressionStatement): paramMapper = createTypeMapper(right.typeParameters, left.typeParameters); */
        }
        declaration := /* TODO(PropertyAccessExpression): left.declaration */ TODO
        params := combineUnionParameters(left, right, paramMapper)
        thisParam := combineUnionThisParam(/* TODO(PropertyAccessExpression): left.thisParameter */ TODO, /* TODO(PropertyAccessExpression): right.thisParameter */ TODO, paramMapper)
        minArgCount := /* TODO(PropertyAccessExpression): Math.max */ TODO(/* TODO(PropertyAccessExpression): left.minArgumentCount */ TODO, /* TODO(PropertyAccessExpression): right.minArgumentCount */ TODO)
        result := createSignature(declaration, typeParams, thisParam, params, undefined, undefined, minArgCount, /* TODO(BinaryExpression): (left.flags | right.flags) & SignatureFlags.PropagatingFlags */ TODO)
        /* TODO(ExpressionStatement): result.compositeKind = TypeFlags.Union; */
        /* TODO(ExpressionStatement): result.compositeSignatures = concatenate(left.compositeKind !== TypeFlags.Intersection && left.compositeSignatures || [left], [right]); */
        if paramMapper {
            /* TODO(ExpressionStatement): result.mapper = left.compositeKind !== TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper; */
        } else if /* TODO(BinaryExpression): left.compositeKind !== TypeFlags.Intersection && left.mapper && left.compositeSignatures */ TODO {
            /* TODO(ExpressionStatement): result.mapper = left.mapper; */
        }
         result
    }
    getUnionIndexInfos := func(types []Type) []IndexInfo {
        sourceInfos := getIndexInfosOfType(/* TODO(ElementAccessExpression): types[0] */ TODO)
        if sourceInfos {
            result := /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(ForOfStatement): for (const info of sourceInfos) {                 const indexType = info.keyType;                 if (every(types, t => !!getIndexInfoOfType(t, indexType))) {                     result.push(createIndexInfo(indexType, getUnionType(map(types, t => getIndexTypeOfType(t, indexType)!)), some(types, t => getIndexInfoOfType(t, indexType)!.isReadonly)));                 }             } */
             result
        }
         emptyArray
    }
    resolveUnionTypeMembers := func(type_ UnionType) {
        callSignatures := getUnionSignatures(map_(/* TODO(PropertyAccessExpression): type.types */ TODO, /* TODO(ArrowFunction): t => t === globalFunctionType ? [unknownSignature] : getSignaturesOfType(t, SignatureKind.Call) */ TODO))
        constructSignatures := getUnionSignatures(map_(/* TODO(PropertyAccessExpression): type.types */ TODO, /* TODO(ArrowFunction): t => getSignaturesOfType(t, SignatureKind.Construct) */ TODO))
        indexInfos := getUnionIndexInfos(/* TODO(PropertyAccessExpression): type.types */ TODO)
        /* TODO(ExpressionStatement): setStructuredTypeMembers(type, emptySymbols, callSignatures, constructSignatures, indexInfos); */
    }
    // OVERLOAD: intersectTypes := func(type1 Type, type2 Type) Type
    // OVERLOAD: intersectTypes := func(type1 *Type, type2 *Type) *Type
    intersectTypes := func(type1 *Type, type2 *Type) *Type {
         /* TODO(ConditionalExpression): !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]) */ TODO
    }
    findMixins := func(types []Type) []bool {
        constructorTypeCount := countWhere(types, /* TODO(ArrowFunction): t => getSignaturesOfType(t, SignatureKind.Construct).length > 0 */ TODO)
        mixinFlags := map_(types, isMixinConstructorType)
        if /* TODO(BinaryExpression): constructorTypeCount > 0 && constructorTypeCount === countWhere(mixinFlags, b => b) */ TODO {
            firstMixinIndex := /* TODO(PropertyAccessExpression): mixinFlags.indexOf */ TODO(/* TODO(TrueKeyword): true */ TODO)
            /* TODO(ExpressionStatement): mixinFlags[firstMixinIndex] = false; */
        }
         mixinFlags
    }
    includeMixinType := func(type_ Type, types []Type, mixinFlags []bool, index number) Type {
        var mixedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             if (i === index) {                 mixedTypes.push(type);             }             else if (mixinFlags[i]) {                 mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], SignatureKind.Construct)[0]));             }         } */
         getIntersectionType(mixedTypes)
    }
    resolveIntersectionTypeMembers := func(type_ IntersectionType) {
        var callSignatures /* TODO(ArrayType): Signature[] */ any
        var constructSignatures /* TODO(ArrayType): Signature[] */ any
        var indexInfos /* TODO(ArrayType): IndexInfo[] */ any
        types := /* TODO(PropertyAccessExpression): type.types */ TODO
        mixinFlags := findMixins(types)
        mixinCount := countWhere(mixinFlags, /* TODO(ArrowFunction): b => b */ TODO)
        /* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             const t = type.types[i];             // When an intersection type contains mixin constructor types, the construct signatures from             // those types are discarded and their return types are mixed into the return types of all             // other construct signatures in the intersection type. For example, the intersection type             // '{ new(...args: any[]) => A } & { new(s: string) => B }' has a single construct signature             // 'new(s: string) => A & B'.             if (!mixinFlags[i]) {                 let signatures = getSignaturesOfType(t, SignatureKind.Construct);                 if (signatures.length && mixinCount > 0) {                     signatures = map(signatures, s => {                         const clone = cloneSignature(s);                         clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i);                         return clone;                     });                 }                 constructSignatures = appendSignatures(constructSignatures, signatures);             }             callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, SignatureKind.Call));             indexInfos = reduceLeft(getIndexInfosOfType(t), (infos, newInfo) => appendIndexInfo(infos, newInfo, /*union* / false), indexInfos);         } */
        /* TODO(ExpressionStatement): setStructuredTypeMembers(type, emptySymbols, callSignatures || emptyArray, constructSignatures || emptyArray, indexInfos || emptyArray); */
    }
    appendSignatures := func(signatures /* TODO(ArrayType): Signature[] */ any, newSignatures []Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] | undefined */ TODO {
        /* TODO(ForOfStatement): for (const sig of newSignatures) {             if (!signatures || every(signatures, s => !compareSignaturesIdentical(s, sig, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / false, compareTypesIdentical))) {                 signatures = append(signatures, sig);             }         } */
         signatures
    }
    appendIndexInfo := func(indexInfos /* TODO(ArrayType): IndexInfo[] */ any, newInfo IndexInfo, union bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo[] */ TODO {
        if indexInfos {
            /* TODO(ForStatement): for (let i = 0; i < indexInfos.length; i++) {                 const info = indexInfos[i];                 if (info.keyType === newInfo.keyType) {                     indexInfos[i] = createIndexInfo(info.keyType, union ? getUnionType([info.type, newInfo.type]) : getIntersectionType([info.type, newInfo.type]), union ? info.isReadonly || newInfo.isReadonly : info.isReadonly && newInfo.isReadonly);                     return indexInfos;                 }             } */
        }
         append(indexInfos, newInfo)
    }
    resolveAnonymousTypeMembers := func(type_ AnonymousType) {
        if /* TODO(PropertyAccessExpression): type.target */ TODO {
            /* TODO(ExpressionStatement): setStructuredTypeMembers(type, emptySymbols, emptyArray, emptyArray, emptyArray); */
            members := createInstantiatedSymbolTable(getPropertiesOfObjectType(/* TODO(PropertyAccessExpression): type.target */ TODO), /* TODO(NonNullExpression): type.mapper! */ TODO, /* TODO(FalseKeyword): false */ TODO)
            callSignatures := instantiateSignatures(getSignaturesOfType(/* TODO(PropertyAccessExpression): type.target */ TODO, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO), /* TODO(NonNullExpression): type.mapper! */ TODO)
            constructSignatures := instantiateSignatures(getSignaturesOfType(/* TODO(PropertyAccessExpression): type.target */ TODO, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO), /* TODO(NonNullExpression): type.mapper! */ TODO)
            indexInfos := instantiateIndexInfos(getIndexInfosOfType(/* TODO(PropertyAccessExpression): type.target */ TODO), /* TODO(NonNullExpression): type.mapper! */ TODO)
            /* TODO(ExpressionStatement): setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos); */

        }
        symbol := getMergedSymbol(/* TODO(PropertyAccessExpression): type.symbol */ TODO)
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeLiteral */ TODO {
            /* TODO(ExpressionStatement): setStructuredTypeMembers(type, emptySymbols, emptyArray, emptyArray, emptyArray); */
            members := getMembersOfSymbol(symbol)
            callSignatures := getSignaturesOfSymbol(/* TODO(PropertyAccessExpression): members.get */ TODO(/* TODO(PropertyAccessExpression): InternalSymbolName.Call */ TODO))
            constructSignatures := getSignaturesOfSymbol(/* TODO(PropertyAccessExpression): members.get */ TODO(/* TODO(PropertyAccessExpression): InternalSymbolName.New */ TODO))
            indexInfos := getIndexInfosOfSymbol(symbol)
            /* TODO(ExpressionStatement): setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos); */

        }
        members := getExportsOfSymbol(symbol)
        var indexInfos /* TODO(ArrayType): IndexInfo[] */ any
        if /* TODO(BinaryExpression): symbol === globalThisSymbol */ TODO {
            varsOnly := /* TODO(NewExpression): new Map<__String, Symbol>() */ TODO
            /* TODO(ExpressionStatement): members.forEach(p => {                 if (!(p.flags & SymbolFlags.BlockScoped) && !(p.flags & SymbolFlags.ValueModule && p.declarations?.length && every(p.declarations, isAmbientModule))) {                     varsOnly.set(p.escapedName, p);                 }             }); */
            /* TODO(ExpressionStatement): members = varsOnly; */
        }
        var baseConstructorIndexInfo *IndexInfo
        /* TODO(ExpressionStatement): setStructuredTypeMembers(type, members, emptyArray, emptyArray, emptyArray); */
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Class */ TODO {
            classType := getDeclaredTypeOfClassOrInterface(symbol)
            baseConstructorType := getBaseConstructorTypeOfClass(classType)
            if /* TODO(BinaryExpression): baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.TypeVariable) */ TODO {
                /* TODO(ExpressionStatement): members = createSymbolTable(getNamedOrIndexSignatureMembers(members)); */
                /* TODO(ExpressionStatement): addInheritedMembers(members, getPropertiesOfType(baseConstructorType)); */
            } else if /* TODO(BinaryExpression): baseConstructorType === anyType */ TODO {
                /* TODO(ExpressionStatement): baseConstructorIndexInfo = createIndexInfo(stringType, anyType, /*isReadonly* / false); */
            }
        }
        indexSymbol := getIndexSymbolFromSymbolTable(members)
        if indexSymbol {
            /* TODO(ExpressionStatement): indexInfos = getIndexInfosOfIndexSymbol(indexSymbol); */
        } else {
            if baseConstructorIndexInfo {
                /* TODO(ExpressionStatement): indexInfos = append(indexInfos, baseConstructorIndexInfo); */
            }
            if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Enum && (getDeclaredTypeOfSymbol(symbol).flags & TypeFlags.Enum ||                     some(type.properties, prop => !!(getTypeOfSymbol(prop).flags & TypeFlags.NumberLike))) */ TODO {
                /* TODO(ExpressionStatement): indexInfos = append(indexInfos, enumNumberIndexInfo); */
            }
        }
        /* TODO(ExpressionStatement): setStructuredTypeMembers(type, members, emptyArray, emptyArray, indexInfos || emptyArray); */
        if /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Function | SymbolFlags.Method) */ TODO {
            /* TODO(ExpressionStatement): type.callSignatures = getSignaturesOfSymbol(symbol); */
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Class */ TODO {
            classType := getDeclaredTypeOfClassOrInterface(symbol)
            constructSignatures := /* TODO(ConditionalExpression): symbol.members ? getSignaturesOfSymbol(symbol.members.get(InternalSymbolName.Constructor)) : emptyArray */ TODO
            if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Function */ TODO {
                /* TODO(ExpressionStatement): constructSignatures = addRange(                     constructSignatures.slice(),                     mapDefined(                         type.callSignatures,                         sig =>                             isJSConstructor(sig.declaration) ?                                 createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType, /*resolvedTypePredicate* / undefined, sig.minArgumentCount, sig.flags & SignatureFlags.PropagatingFlags) :                                 undefined,                     ),                 ); */
            }
            if /* TODO(PrefixUnaryExpression): !constructSignatures.length */ TODO {
                /* TODO(ExpressionStatement): constructSignatures = getDefaultConstructSignatures(classType); */
            }
            /* TODO(ExpressionStatement): type.constructSignatures = constructSignatures; */
        }
    }
    type ReplaceableIndexedAccessType /* TODO(IntersectionType): IndexedAccessType & { objectType: TypeParameter; indexType: TypeParameter; } */ TODO
    replaceIndexedAccess := func(instantiable Type, type_ ReplaceableIndexedAccessType, replacement Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         instantiateType(instantiable, createTypeMapper(/* TODO(ArrayLiteralExpression): [type.indexType, type.objectType] */ TODO, /* TODO(ArrayLiteralExpression): [getNumberLiteralType(0), createTupleType([replacement])] */ TODO))
    }
    getLimitedConstraint := func(type_ ReverseMappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        constraint := getConstraintTypeFromMappedType(/* TODO(PropertyAccessExpression): type.mappedType */ TODO)
        if /* TODO(PrefixUnaryExpression): !(constraint.flags & TypeFlags.Union || constraint.flags & TypeFlags.Intersection) */ TODO {

        }
        origin := /* TODO(ConditionalExpression): (constraint.flags & TypeFlags.Union) ? (constraint as UnionType).origin : (constraint as IntersectionType) */ TODO
        if /* TODO(BinaryExpression): !origin || !(origin.flags & TypeFlags.Intersection) */ TODO {

        }
        limitedConstraint := getIntersectionType(/* TODO(PropertyAccessExpression): (origin as IntersectionType).types.filter */ TODO(/* TODO(ArrowFunction): t => t !== type.constraintType */ TODO))
         /* TODO(ConditionalExpression): limitedConstraint !== neverType ? limitedConstraint : undefined */ TODO
    }
    resolveReverseMappedTypeMembers := func(type_ ReverseMappedType) {
        indexInfo := getIndexInfoOfType(/* TODO(PropertyAccessExpression): type.source */ TODO, stringType)
        modifiers := getMappedTypeModifiers(/* TODO(PropertyAccessExpression): type.mappedType */ TODO)
        readonlyMask := /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeReadonly ? false : true */ TODO
        optionalMask := /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeOptional ? 0 : SymbolFlags.Optional */ TODO
        indexInfos := /* TODO(ConditionalExpression): indexInfo ? [createIndexInfo(stringType, inferReverseMappedType(indexInfo.type, type.mappedType, type.constraintType) || unknownType, readonlyMask && indexInfo.isReadonly)] : emptyArray */ TODO
        members := createSymbolTable()
        limitedConstraint := getLimitedConstraint(type_)
        /* TODO(ForOfStatement): for (const prop of getPropertiesOfType(type.source)) {             // In case of a reverse mapped type with an intersection constraint, if we were able to             // extract the filtering type literals we skip those properties that are not assignable to them,             // because the extra properties wouldn't get through the application of the mapped type anyway             if (limitedConstraint) {                 const propertyNameType = getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique);                 if (!isTypeAssignableTo(propertyNameType, limitedConstraint)) {                     continue;                 }             }             const checkFlags = CheckFlags.ReverseMapped | (readonlyMask && isReadonlySymbol(prop) ? CheckFlags.Readonly : 0);             const inferredProp = createSymbol(SymbolFlags.Property | prop.flags & optionalMask, prop.escapedName, checkFlags) as ReverseMappedSymbol;             inferredProp.declarations = prop.declarations;             inferredProp.links.nameType = getSymbolLinks(prop).nameType;             inferredProp.links.propertyType = getTypeOfSymbol(prop);             if (                 type.constraintType.type.flags & TypeFlags.IndexedAccess                 && (type.constraintType.type as IndexedAccessType).objectType.flags & TypeFlags.TypeParameter                 && (type.constraintType.type as IndexedAccessType).indexType.flags & TypeFlags.TypeParameter             ) {                 // A reverse mapping of `{[K in keyof T[K_1]]: T[K_1]}` is the same as that of `{[K in keyof T]: T}`, since all we care about is                 // inferring to the "type parameter" (or indexed access) shared by the constraint and template. So, to reduce the number of                 // type identities produced, we simplify such indexed access occurences                 const newTypeParam = (type.constraintType.type as IndexedAccessType).objectType;                 const newMappedType = replaceIndexedAccess(type.mappedType, type.constraintType.type as ReplaceableIndexedAccessType, newTypeParam);                 inferredProp.links.mappedType = newMappedType as MappedType;                 inferredProp.links.constraintType = getIndexType(newTypeParam) as IndexType;             }             else {                 inferredProp.links.mappedType = type.mappedType;                 inferredProp.links.constraintType = type.constraintType;             }             members.set(prop.escapedName, inferredProp);         } */
        /* TODO(ExpressionStatement): setStructuredTypeMembers(type, members, emptyArray, emptyArray, indexInfos); */
    }
    getLowerBoundOfKeyType := func(type_ Type) Type {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Index */ TODO {
            t := getApparentType(/* TODO(PropertyAccessExpression): (type as IndexType).type */ TODO)
             /* TODO(ConditionalExpression): isGenericTupleType(t) ? getKnownKeysOfTupleType(t) : getIndexType(t) */ TODO
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Conditional */ TODO {
            if /* TODO(PropertyAccessExpression): (type as ConditionalType).root.isDistributive */ TODO {
                checkType := /* TODO(PropertyAccessExpression): (type as ConditionalType).checkType */ TODO
                constraint := getLowerBoundOfKeyType(checkType)
                if /* TODO(BinaryExpression): constraint !== checkType */ TODO {
                     getConditionalTypeInstantiation(type_ /* as */ /* TODO(TypeReference): ConditionalType */, prependTypeMapping(/* TODO(PropertyAccessExpression): (type as ConditionalType).root.checkType */ TODO, constraint, /* TODO(PropertyAccessExpression): (type as ConditionalType).mapper */ TODO), /* TODO(FalseKeyword): false */ TODO)
                }
            }
             type_
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
             mapType(type_ /* as */ /* TODO(TypeReference): UnionType */, getLowerBoundOfKeyType, /* TODO(TrueKeyword): true */ TODO)
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
            types := /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO
            if /* TODO(BinaryExpression): types.length === 2 && !!(types[0].flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.BigInt)) && types[1] === emptyTypeLiteralType */ TODO {
                 type_
            }
             getIntersectionType(sameMap(/* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, getLowerBoundOfKeyType))
        }
         type_
    }
    getIsLateCheckFlag := func(s Symbol) CheckFlags {
         /* TODO(BinaryExpression): getCheckFlags(s) & CheckFlags.Late */ TODO
    }
    forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType := func(type_ Type, include TypeFlags, stringsOnly bool, cb func(keyType Type) ) {
        /* TODO(ForOfStatement): for (const prop of getPropertiesOfType(type)) {             cb(getLiteralTypeFromProperty(prop, include));         } */
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Any */ TODO {
            /* TODO(ExpressionStatement): cb(stringType); */
        } else {
            /* TODO(ForOfStatement): for (const info of getIndexInfosOfType(type)) {                 if (!stringsOnly || info.keyType.flags & (TypeFlags.String | TypeFlags.TemplateLiteral)) {                     cb(info.keyType);                 }             } */
        }
    }
    resolveMappedTypeMembers := func(type_ MappedType) {
        var members SymbolTable = createSymbolTable()
        var indexInfos /* TODO(ArrayType): IndexInfo[] */ any
        /* TODO(ExpressionStatement): setStructuredTypeMembers(type, emptySymbols, emptyArray, emptyArray, emptyArray); */
        typeParameter := getTypeParameterFromMappedType(type_)
        constraintType := getConstraintTypeFromMappedType(type_)
        mappedType := /* TODO(BinaryExpression): (type.target as MappedType) || type */ TODO
        nameType := getNameTypeFromMappedType(mappedType)
        shouldLinkPropDeclarations := /* TODO(BinaryExpression): getMappedTypeNameTypeKind(mappedType) !== MappedTypeNameTypeKind.Remapping */ TODO
        templateType := getTemplateTypeFromMappedType(mappedType)
        modifiersType := getApparentType(getModifiersTypeFromMappedType(type_))
        templateModifiers := getMappedTypeModifiers(type_)
        include := /* TODO(PropertyAccessExpression): TypeFlags.StringOrNumberLiteralOrUnique */ TODO
        if isMappedTypeWithKeyofConstraintDeclaration(type_) {
            /* TODO(ExpressionStatement): forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, include, /*stringsOnly* / false, addMemberForKeyType); */
        } else {
            /* TODO(ExpressionStatement): forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType); */
        }
        /* TODO(ExpressionStatement): setStructuredTypeMembers(type, members, emptyArray, emptyArray, indexInfos || emptyArray); */
        addMemberForKeyType := func(keyType Type) {
            propNameType := /* TODO(ConditionalExpression): nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType */ TODO
            /* TODO(ExpressionStatement): forEachType(propNameType, t => addMemberForKeyTypeWorker(keyType, t)); */
        }
        addMemberForKeyTypeWorker := func(keyType Type, propNameType Type) {
            if isTypeUsableAsPropertyName(propNameType) {
                propName := getPropertyNameFromType(propNameType)
                existingProp := /* TODO(PropertyAccessExpression): members.get */ TODO(propName) /* as */ /* TODO(UnionType): MappedSymbol | undefined */
                if existingProp {
                    /* TODO(ExpressionStatement): existingProp.links.nameType = getUnionType([existingProp.links.nameType!, propNameType]); */
                    /* TODO(ExpressionStatement): existingProp.links.keyType = getUnionType([existingProp.links.keyType, keyType]); */
                } else {
                    modifiersProp := /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(keyType) ? getPropertyOfType(modifiersType, getPropertyNameFromType(keyType)) : undefined */ TODO
                    isOptional := /* TODO(PrefixUnaryExpression): !!(templateModifiers & MappedTypeModifiers.IncludeOptional ||                         !(templateModifiers & MappedTypeModifiers.ExcludeOptional) && modifiersProp && modifiersProp.flags & SymbolFlags.Optional) */ TODO
                    isReadonly := /* TODO(PrefixUnaryExpression): !!(templateModifiers & MappedTypeModifiers.IncludeReadonly ||                         !(templateModifiers & MappedTypeModifiers.ExcludeReadonly) && modifiersProp && isReadonlySymbol(modifiersProp)) */ TODO
                    stripOptional := /* TODO(BinaryExpression): strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags & SymbolFlags.Optional */ TODO
                    var lateFlag CheckFlags = /* TODO(ConditionalExpression): modifiersProp ? getIsLateCheckFlag(modifiersProp) : 0 */ TODO
                    prop := createSymbol(/* TODO(BinaryExpression): SymbolFlags.Property | (isOptional ? SymbolFlags.Optional : 0) */ TODO, propName, /* TODO(BinaryExpression): lateFlag | CheckFlags.Mapped | (isReadonly ? CheckFlags.Readonly : 0) | (stripOptional ? CheckFlags.StripOptional : 0) */ TODO) /* as */ /* TODO(TypeReference): MappedSymbol */
                    /* TODO(ExpressionStatement): prop.links.mappedType = type; */
                    /* TODO(ExpressionStatement): prop.links.nameType = propNameType; */
                    /* TODO(ExpressionStatement): prop.links.keyType = keyType; */
                    if modifiersProp {
                        /* TODO(ExpressionStatement): prop.links.syntheticOrigin = modifiersProp; */
                        /* TODO(ExpressionStatement): prop.declarations = shouldLinkPropDeclarations ? modifiersProp.declarations : undefined; */
                    }
                    /* TODO(ExpressionStatement): members.set(propName, prop); */
                }
            } else if /* TODO(BinaryExpression): isValidIndexKeyType(propNameType) || propNameType.flags & (TypeFlags.Any | TypeFlags.Enum) */ TODO {
                indexKeyType := /* TODO(ConditionalExpression): propNameType.flags & (TypeFlags.Any | TypeFlags.String) ? stringType :                     propNameType.flags & (TypeFlags.Number | TypeFlags.Enum) ? numberType :                     propNameType */ TODO
                propType := instantiateType(templateType, appendTypeMapping(/* TODO(PropertyAccessExpression): type.mapper */ TODO, typeParameter, keyType))
                modifiersIndexInfo := getApplicableIndexInfo(modifiersType, propNameType)
                isReadonly := /* TODO(PrefixUnaryExpression): !!(templateModifiers & MappedTypeModifiers.IncludeReadonly ||                     !(templateModifiers & MappedTypeModifiers.ExcludeReadonly) && modifiersIndexInfo?.isReadonly) */ TODO
                indexInfo := createIndexInfo(indexKeyType, propType, isReadonly)
                /* TODO(ExpressionStatement): indexInfos = appendIndexInfo(indexInfos, indexInfo, /*union* / true); */
            }
        }
    }
    getTypeOfMappedSymbol := func(symbol MappedSymbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(PrefixUnaryExpression): !symbol.links.type */ TODO {
            mappedType := /* TODO(PropertyAccessExpression): symbol.links.mappedType */ TODO
            if /* TODO(PrefixUnaryExpression): !pushTypeResolution(symbol, TypeSystemPropertyName.Type) */ TODO {
                /* TODO(ExpressionStatement): mappedType.containsError = true; */
                 errorType
            }
            templateType := getTemplateTypeFromMappedType(/* TODO(BinaryExpression): mappedType.target as MappedType || mappedType */ TODO)
            mapper := appendTypeMapping(/* TODO(PropertyAccessExpression): mappedType.mapper */ TODO, getTypeParameterFromMappedType(mappedType), /* TODO(PropertyAccessExpression): symbol.links.keyType */ TODO)
            propType := instantiateType(templateType, mapper)
            type_ := /* TODO(ConditionalExpression): strictNullChecks && symbol.flags & SymbolFlags.Optional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void) ? getOptionalType(propType, /*isProperty* / true) :                 symbol.links.checkFlags & CheckFlags.StripOptional ? removeMissingOrUndefinedType(propType) :                 propType */ TODO
            if /* TODO(PrefixUnaryExpression): !popTypeResolution() */ TODO {
                /* TODO(ExpressionStatement): error(currentNode, Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1, symbolToString(symbol), typeToString(mappedType)); */
                /* TODO(ExpressionStatement): type = errorType; */
            }
            /* TODO(ExpressionStatement): symbol.links.type ??= type; */
        }
         /* TODO(PropertyAccessExpression): symbol.links.type */ TODO
    }
    getTypeParameterFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
         /* TODO(BinaryExpression): type.typeParameter ||             (type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(type.declaration.typeParameter))) */ TODO
    }
    getConstraintTypeFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(BinaryExpression): type.constraintType ||             (type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType) */ TODO
    }
    getNameTypeFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
         /* TODO(ConditionalExpression): type.declaration.nameType ?             type.nameType || (type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper)) :             undefined */ TODO
    }
    getTemplateTypeFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(BinaryExpression): type.templateType ||             (type.templateType = type.declaration.type ?                 instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), /*isProperty* / true, !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional)), type.mapper) :                 errorType) */ TODO
    }
    getConstraintDeclarationForMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
         getEffectiveConstraintOfTypeParameter(/* TODO(PropertyAccessExpression): type.declaration.typeParameter */ TODO)
    }
    isMappedTypeWithKeyofConstraintDeclaration := func(type_ MappedType) /* TODO(undefined): boolean */ TODO {
        constraintDeclaration := /* TODO(NonNullExpression): getConstraintDeclarationForMappedType(type)! */ TODO
         /* TODO(BinaryExpression): constraintDeclaration.kind === SyntaxKind.TypeOperator &&             (constraintDeclaration as TypeOperatorNode).operator === SyntaxKind.KeyOfKeyword */ TODO
    }
    getModifiersTypeFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(PrefixUnaryExpression): !type.modifiersType */ TODO {
            if isMappedTypeWithKeyofConstraintDeclaration(type_) {
                /* TODO(ExpressionStatement): type.modifiersType = instantiateType(getTypeFromTypeNode((getConstraintDeclarationForMappedType(type) as TypeOperatorNode).type), type.mapper); */
            } else {
                declaredType := getTypeFromMappedTypeNode(/* TODO(PropertyAccessExpression): type.declaration */ TODO) /* as */ /* TODO(TypeReference): MappedType */
                constraint := getConstraintTypeFromMappedType(declaredType)
                extendedConstraint := /* TODO(ConditionalExpression): constraint && constraint.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(constraint as TypeParameter) : constraint */ TODO
                /* TODO(ExpressionStatement): type.modifiersType = extendedConstraint && extendedConstraint.flags & TypeFlags.Index ? instantiateType((extendedConstraint as IndexType).type, type.mapper) : unknownType; */
            }
        }
         /* TODO(PropertyAccessExpression): type.modifiersType */ TODO
    }
    getMappedTypeModifiers := func(type_ MappedType) MappedTypeModifiers {
        declaration := /* TODO(PropertyAccessExpression): type.declaration */ TODO
         /* TODO(BinaryExpression): (declaration.readonlyToken ? declaration.readonlyToken.kind === SyntaxKind.MinusToken ? MappedTypeModifiers.ExcludeReadonly : MappedTypeModifiers.IncludeReadonly : 0) |             (declaration.questionToken ? declaration.questionToken.kind === SyntaxKind.MinusToken ? MappedTypeModifiers.ExcludeOptional : MappedTypeModifiers.IncludeOptional : 0) */ TODO
    }
    getMappedTypeOptionality := func(type_ MappedType) number {
        modifiers := getMappedTypeModifiers(type_)
         /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.ExcludeOptional ? -1 : modifiers & MappedTypeModifiers.IncludeOptional ? 1 : 0 */ TODO
    }
    getCombinedMappedTypeOptionality := func(type_ Type) number {
        if /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.Mapped */ TODO {
             /* TODO(BinaryExpression): getMappedTypeOptionality(type as MappedType) || getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(type as MappedType)) */ TODO
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
            optionality := getCombinedMappedTypeOptionality(/* TODO(ElementAccessExpression): (type as IntersectionType).types[0] */ TODO)
             /* TODO(ConditionalExpression): every((type as IntersectionType).types, (t, i) => i === 0 || getCombinedMappedTypeOptionality(t) === optionality) ? optionality : 0 */ TODO
        }
         0
    }
    isPartialMappedType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(getObjectFlags(type) & ObjectFlags.Mapped && getMappedTypeModifiers(type as MappedType) & MappedTypeModifiers.IncludeOptional) */ TODO
    }
    isGenericMappedType := func(type_ Type) /* TODO(TypePredicate): type is MappedType */ TODO {
        if /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.Mapped */ TODO {
            constraint := getConstraintTypeFromMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */)
            if isGenericIndexType(constraint) {
                 /* TODO(TrueKeyword): true */ TODO
            }
            nameType := getNameTypeFromMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */)
            if /* TODO(BinaryExpression): nameType && isGenericIndexType(instantiateType(nameType, makeUnaryTypeMapper(getTypeParameterFromMappedType(type as MappedType), constraint))) */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    getMappedTypeNameTypeKind := func(type_ MappedType) MappedTypeNameTypeKind {
        nameType := getNameTypeFromMappedType(type_)
        if /* TODO(PrefixUnaryExpression): !nameType */ TODO {
             /* TODO(PropertyAccessExpression): MappedTypeNameTypeKind.None */ TODO
        }
         /* TODO(ConditionalExpression): isTypeAssignableTo(nameType, getTypeParameterFromMappedType(type)) ? MappedTypeNameTypeKind.Filtering : MappedTypeNameTypeKind.Remapping */ TODO
    }
    resolveStructuredTypeMembers := func(type_ StructuredType) ResolvedType {
        if /* TODO(PrefixUnaryExpression): !(type as ResolvedType).members */ TODO {
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
                if /* TODO(BinaryExpression): (type as ObjectType).objectFlags & ObjectFlags.Reference */ TODO {
                    /* TODO(ExpressionStatement): resolveTypeReferenceMembers(type as TypeReference); */
                } else if /* TODO(BinaryExpression): (type as ObjectType).objectFlags & ObjectFlags.ClassOrInterface */ TODO {
                    /* TODO(ExpressionStatement): resolveClassOrInterfaceMembers(type as InterfaceType); */
                } else if /* TODO(BinaryExpression): (type as ReverseMappedType).objectFlags & ObjectFlags.ReverseMapped */ TODO {
                    /* TODO(ExpressionStatement): resolveReverseMappedTypeMembers(type as ReverseMappedType); */
                } else if /* TODO(BinaryExpression): (type as ObjectType).objectFlags & ObjectFlags.Anonymous */ TODO {
                    /* TODO(ExpressionStatement): resolveAnonymousTypeMembers(type as AnonymousType); */
                } else if /* TODO(BinaryExpression): (type as MappedType).objectFlags & ObjectFlags.Mapped */ TODO {
                    /* TODO(ExpressionStatement): resolveMappedTypeMembers(type as MappedType); */
                } else {
                    /* TODO(ExpressionStatement): Debug.fail("Unhandled object type " + Debug.formatObjectFlags(type.objectFlags)); */
                }
            } else if /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
                /* TODO(ExpressionStatement): resolveUnionTypeMembers(type as UnionType); */
            } else if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
                /* TODO(ExpressionStatement): resolveIntersectionTypeMembers(type as IntersectionType); */
            } else {
                /* TODO(ExpressionStatement): Debug.fail("Unhandled type " + Debug.formatTypeFlags(type.flags)); */
            }
        }
         type_ /* as */ /* TODO(TypeReference): ResolvedType */
    }
    getPropertiesOfObjectType := func(type_ Type) []Symbol {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
             /* TODO(PropertyAccessExpression): resolveStructuredTypeMembers(type as ObjectType).properties */ TODO
        }
         emptyArray
    }
    getPropertyOfObjectType := func(type_ Type, name __String) *Symbol {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
            resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
            symbol := /* TODO(PropertyAccessExpression): resolved.members.get */ TODO(name)
            if /* TODO(BinaryExpression): symbol && symbolIsValue(symbol) */ TODO {
                 symbol
            }
        }
    }
    getPropertiesOfUnionOrIntersectionType := func(type_ UnionOrIntersectionType) []Symbol {
        if /* TODO(PrefixUnaryExpression): !type.resolvedProperties */ TODO {
            members := createSymbolTable()
            /* TODO(ForOfStatement): for (const current of type.types) {                 for (const prop of getPropertiesOfType(current)) {                     if (!members.has(prop.escapedName)) {                         const combinedProp = getPropertyOfUnionOrIntersectionType(type, prop.escapedName, /*skipObjectFunctionPropertyAugment* / !!(type.flags & TypeFlags.Intersection));                         if (combinedProp) {                             members.set(prop.escapedName, combinedProp);                         }                     }                 }                 // The properties of a union type are those that are present in all constituent types, so                 // we only need to check the properties of the first type without index signature                 if (type.flags & TypeFlags.Union && getIndexInfosOfType(current).length === 0) {                     break;                 }             } */
            /* TODO(ExpressionStatement): type.resolvedProperties = getNamedMembers(members); */
        }
         /* TODO(PropertyAccessExpression): type.resolvedProperties */ TODO
    }
    getPropertiesOfType := func(type_ Type) []Symbol {
        /* TODO(ExpressionStatement): type = getReducedApparentType(type); */
         /* TODO(ConditionalExpression): type.flags & TypeFlags.UnionOrIntersection ?             getPropertiesOfUnionOrIntersectionType(type as UnionType) :             getPropertiesOfObjectType(type) */ TODO
    }
    forEachPropertyOfType := func(type_ Type, action func(symbol Symbol, escapedName __String) ) {
        /* TODO(ExpressionStatement): type = getReducedApparentType(type); */
        if /* TODO(BinaryExpression): type.flags & TypeFlags.StructuredType */ TODO {
            /* TODO(ExpressionStatement): resolveStructuredTypeMembers(type as StructuredType).members.forEach((symbol, escapedName) => {                 if (isNamedMember(symbol, escapedName)) {                     action(symbol, escapedName);                 }             }); */
        }
    }
    isTypeInvalidDueToUnionDiscriminant := func(contextualType Type, obj /* TODO(UnionType): ObjectLiteralExpression | JsxAttributes */ any) bool {
        list := /* TODO(PropertyAccessExpression): obj.properties */ TODO /* as */ /* TODO(TypeReference): NodeArray<ObjectLiteralElementLike | JsxAttributeLike> */
         /* TODO(PropertyAccessExpression): list.some */ TODO(/* TODO(ArrowFunction): property => {             const nameType = property.name && (isJsxNamespacedName(property.name) ? getStringLiteralType(getTextOfJsxAttributeName(property.name)) : getLiteralTypeFromPropertyName(property.name));             const name = nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;             const expected = name === undefined ? undefined : getTypeOfPropertyOfType(contextualType, name);             return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected);         } */ TODO)
    }
    getAllPossiblePropertiesOfTypes := func(types []Type) []Symbol {
        unionType := getUnionType(types)
        if /* TODO(PrefixUnaryExpression): !(unionType.flags & TypeFlags.Union) */ TODO {
             getAugmentedPropertiesOfType(unionType)
        }
        props := createSymbolTable()
        /* TODO(ForOfStatement): for (const memberType of types) {             for (const { escapedName } of getAugmentedPropertiesOfType(memberType)) {                 if (!props.has(escapedName)) {                     const prop = createUnionOrIntersectionProperty(unionType as UnionType, escapedName);                     // May be undefined if the property is private                     if (prop) props.set(escapedName, prop);                 }             }         } */
         arrayFrom(/* TODO(PropertyAccessExpression): props.values */ TODO())
    }
    getConstraintOfType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any) *Type {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(type as TypeParameter) :             type.flags & TypeFlags.IndexedAccess ? getConstraintOfIndexedAccess(type as IndexedAccessType) :             type.flags & TypeFlags.Conditional ? getConstraintOfConditionalType(type as ConditionalType) :             getBaseConstraintOfType(type) */ TODO
    }
    getConstraintOfTypeParameter := func(typeParameter TypeParameter) *Type {
         /* TODO(ConditionalExpression): hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(typeParameter) : undefined */ TODO
    }
    isConstMappedType := func(type_ MappedType, depth number) bool {
        typeVariable := getHomomorphicTypeVariable(type_)
         /* TODO(BinaryExpression): !!typeVariable && isConstTypeVariable(typeVariable, depth) */ TODO
    }
    isConstTypeVariable := func(type_ *Type, depth /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) bool {
         /* TODO(BinaryExpression): depth < 5 && !!(type && (             type.flags & TypeFlags.TypeParameter && some((type as TypeParameter).symbol?.declarations, d => hasSyntacticModifier(d, ModifierFlags.Const)) ||             type.flags & TypeFlags.UnionOrIntersection && some((type as UnionOrIntersectionType).types, t => isConstTypeVariable(t, depth)) ||             type.flags & TypeFlags.IndexedAccess && isConstTypeVariable((type as IndexedAccessType).objectType, depth + 1) ||             type.flags & TypeFlags.Conditional && isConstTypeVariable(getConstraintOfConditionalType(type as ConditionalType), depth + 1) ||             type.flags & TypeFlags.Substitution && isConstTypeVariable((type as SubstitutionType).baseType, depth) ||             getObjectFlags(type) & ObjectFlags.Mapped && isConstMappedType(type as MappedType, depth) ||             isGenericTupleType(type) && findIndex(getElementTypes(type), (t, i) => !!(type.target.elementFlags[i] & ElementFlags.Variadic) && isConstTypeVariable(t, depth)) >= 0         )) */ TODO
    }
    getConstraintOfIndexedAccess := func(type_ IndexedAccessType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
         /* TODO(ConditionalExpression): hasNonCircularBaseConstraint(type) ? getConstraintFromIndexedAccess(type) : undefined */ TODO
    }
    getSimplifiedTypeOrConstraint := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        simplified := getSimplifiedType(type_, /* TODO(FalseKeyword): false */ TODO)
         /* TODO(ConditionalExpression): simplified !== type ? simplified : getConstraintOfType(type) */ TODO
    }
    getConstraintFromIndexedAccess := func(type_ IndexedAccessType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if isMappedTypeGenericIndexedAccess(type_) {
             substituteIndexedMappedType(/* TODO(PropertyAccessExpression): type.objectType */ TODO /* as */ /* TODO(TypeReference): MappedType */, /* TODO(PropertyAccessExpression): type.indexType */ TODO)
        }
        indexConstraint := getSimplifiedTypeOrConstraint(/* TODO(PropertyAccessExpression): type.indexType */ TODO)
        if /* TODO(BinaryExpression): indexConstraint && indexConstraint !== type.indexType */ TODO {
            indexedAccess := getIndexedAccessTypeOrUndefined(/* TODO(PropertyAccessExpression): type.objectType */ TODO, indexConstraint, /* TODO(PropertyAccessExpression): type.accessFlags */ TODO)
            if indexedAccess {
                 indexedAccess
            }
        }
        objectConstraint := getSimplifiedTypeOrConstraint(/* TODO(PropertyAccessExpression): type.objectType */ TODO)
        if /* TODO(BinaryExpression): objectConstraint && objectConstraint !== type.objectType */ TODO {
             getIndexedAccessTypeOrUndefined(objectConstraint, /* TODO(PropertyAccessExpression): type.indexType */ TODO, /* TODO(PropertyAccessExpression): type.accessFlags */ TODO)
        }
         undefined
    }
    getDefaultConstraintOfConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(PrefixUnaryExpression): !type.resolvedDefaultConstraint */ TODO {
            trueConstraint := getInferredTrueTypeFromConditionalType(type_)
            falseConstraint := getFalseTypeFromConditionalType(type_)
            /* TODO(ExpressionStatement): type.resolvedDefaultConstraint = isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(falseConstraint) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]); */
        }
         /* TODO(PropertyAccessExpression): type.resolvedDefaultConstraint */ TODO
    }
    getConstraintOfDistributiveConditionalType := func(type_ ConditionalType) *Type {
        if /* TODO(BinaryExpression): type.resolvedConstraintOfDistributive !== undefined */ TODO {
             /* TODO(BinaryExpression): type.resolvedConstraintOfDistributive || undefined */ TODO
        }
        if /* TODO(BinaryExpression): type.root.isDistributive && type.restrictiveInstantiation !== type */ TODO {
            simplified := getSimplifiedType(/* TODO(PropertyAccessExpression): type.checkType */ TODO, /* TODO(FalseKeyword): false */ TODO)
            constraint := /* TODO(ConditionalExpression): simplified === type.checkType ? getConstraintOfType(simplified) : simplified */ TODO
            if /* TODO(BinaryExpression): constraint && constraint !== type.checkType */ TODO {
                instantiated := getConditionalTypeInstantiation(type_, prependTypeMapping(/* TODO(PropertyAccessExpression): type.root.checkType */ TODO, constraint, /* TODO(PropertyAccessExpression): type.mapper */ TODO), /* TODO(TrueKeyword): true */ TODO)
                if /* TODO(PrefixUnaryExpression): !(instantiated.flags & TypeFlags.Never) */ TODO {
                    /* TODO(ExpressionStatement): type.resolvedConstraintOfDistributive = instantiated; */
                     instantiated
                }
            }
        }
        /* TODO(ExpressionStatement): type.resolvedConstraintOfDistributive = false; */
         undefined
    }
    getConstraintFromConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(BinaryExpression): getConstraintOfDistributiveConditionalType(type) || getDefaultConstraintOfConditionalType(type) */ TODO
    }
    getConstraintOfConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
         /* TODO(ConditionalExpression): hasNonCircularBaseConstraint(type) ? getConstraintFromConditionalType(type) : undefined */ TODO
    }
    getEffectiveConstraintOfIntersection := func(types []Type, targetIsUnion bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        var constraints /* TODO(ArrayType): Type[] */ any
        hasDisjointDomainType := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForOfStatement): for (const t of types) {             if (t.flags & TypeFlags.Instantiable) {                 // We keep following constraints as long as we have an instantiable type that is known                 // not to be circular or infinite (hence we stop on index access types).                 let constraint = getConstraintOfType(t);                 while (constraint && constraint.flags & (TypeFlags.TypeParameter | TypeFlags.Index | TypeFlags.Conditional)) {                     constraint = getConstraintOfType(constraint);                 }                 if (constraint) {                     constraints = append(constraints, constraint);                     if (targetIsUnion) {                         constraints = append(constraints, t);                     }                 }             }             else if (t.flags & TypeFlags.DisjointDomains || isEmptyAnonymousObjectType(t)) {                 hasDisjointDomainType = true;             }         } */
        if /* TODO(BinaryExpression): constraints && (targetIsUnion || hasDisjointDomainType) */ TODO {
            if hasDisjointDomainType {
                /* TODO(ForOfStatement): for (const t of types) {                     if (t.flags & TypeFlags.DisjointDomains || isEmptyAnonymousObjectType(t)) {                         constraints = append(constraints, t);                     }                 } */
            }
             getNormalizedType(getIntersectionType(constraints, /* TODO(PropertyAccessExpression): IntersectionFlags.NoConstraintReduction */ TODO), /* TODO(FalseKeyword): false */ TODO)
        }
         undefined
    }
    getBaseConstraintOfType := func(type_ Type) *Type {
        if /* TODO(BinaryExpression): type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.UnionOrIntersection | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) || isGenericTupleType(type) */ TODO {
            constraint := getResolvedBaseConstraint(type_ /* as */ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */)
             /* TODO(ConditionalExpression): constraint !== noConstraintType && constraint !== circularConstraintType ? constraint : undefined */ TODO
        }
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Index ? stringNumberSymbolType : undefined */ TODO
    }
    getBaseConstraintOrType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(BinaryExpression): getBaseConstraintOfType(type) || type */ TODO
    }
    hasNonCircularBaseConstraint := func(type_ InstantiableType) bool {
         /* TODO(BinaryExpression): getResolvedBaseConstraint(type) !== circularConstraintType */ TODO
    }
    getResolvedBaseConstraint := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any) Type {
        if /* TODO(PropertyAccessExpression): type.resolvedBaseConstraint */ TODO {
             /* TODO(PropertyAccessExpression): type.resolvedBaseConstraint */ TODO
        }
        var stack []/* TODO(ObjectKeyword): object */ TODO = /* TODO(ArrayLiteralExpression): [] */ TODO
         /* TODO(BinaryExpression): type.resolvedBaseConstraint = getImmediateBaseConstraint(type) */ TODO
        getImmediateBaseConstraint := func(t Type) Type {
            if /* TODO(PrefixUnaryExpression): !t.immediateBaseConstraint */ TODO {
                if /* TODO(PrefixUnaryExpression): !pushTypeResolution(t, TypeSystemPropertyName.ImmediateBaseConstraint) */ TODO {
                     circularConstraintType
                }
                result
                identity := getRecursionIdentity(t)
                if /* TODO(BinaryExpression): stack.length < 10 || stack.length < 50 && !contains(stack, identity) */ TODO {
                    /* TODO(ExpressionStatement): stack.push(identity); */
                    /* TODO(ExpressionStatement): result = computeBaseConstraint(getSimplifiedType(t, /*writing* / false)); */
                    /* TODO(ExpressionStatement): stack.pop(); */
                }
                if /* TODO(PrefixUnaryExpression): !popTypeResolution() */ TODO {
                    if /* TODO(BinaryExpression): t.flags & TypeFlags.TypeParameter */ TODO {
                        errorNode := getConstraintDeclaration(t /* as */ /* TODO(TypeReference): TypeParameter */)
                        if errorNode {
                            diagnostic := error(errorNode, /* TODO(PropertyAccessExpression): Diagnostics.Type_parameter_0_has_a_circular_constraint */ TODO, typeToString(t))
                            if /* TODO(BinaryExpression): currentNode && !isNodeDescendantOf(errorNode, currentNode) && !isNodeDescendantOf(currentNode, errorNode) */ TODO {
                                /* TODO(ExpressionStatement): addRelatedInfo(diagnostic, createDiagnosticForNode(currentNode, Diagnostics.Circularity_originates_in_type_at_this_location)); */
                            }
                        }
                    }
                    /* TODO(ExpressionStatement): result = circularConstraintType; */
                }
                /* TODO(ExpressionStatement): t.immediateBaseConstraint ??= result || noConstraintType; */
            }
             /* TODO(PropertyAccessExpression): t.immediateBaseConstraint */ TODO
        }
        getBaseConstraint := func(t Type) *Type {
            c := getImmediateBaseConstraint(t)
             /* TODO(ConditionalExpression): c !== noConstraintType && c !== circularConstraintType ? c : undefined */ TODO
        }
        computeBaseConstraint := func(t Type) *Type {
            if /* TODO(BinaryExpression): t.flags & TypeFlags.TypeParameter */ TODO {
                constraint := getConstraintFromTypeParameter(t /* as */ /* TODO(TypeReference): TypeParameter */)
                 /* TODO(ConditionalExpression): (t as TypeParameter).isThisType || !constraint ?                     constraint :                     getBaseConstraint(constraint) */ TODO
            }
            if /* TODO(BinaryExpression): t.flags & TypeFlags.UnionOrIntersection */ TODO {
                types := /* TODO(PropertyAccessExpression): (t as UnionOrIntersectionType).types */ TODO
                var baseTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
                different := /* TODO(FalseKeyword): false */ TODO
                /* TODO(ForOfStatement): for (const type of types) {                     const baseType = getBaseConstraint(type);                     if (baseType) {                         if (baseType !== type) {                             different = true;                         }                         baseTypes.push(baseType);                     }                     else {                         different = true;                     }                 } */
                if /* TODO(PrefixUnaryExpression): !different */ TODO {
                     t
                }
                 /* TODO(ConditionalExpression): t.flags & TypeFlags.Union && baseTypes.length === types.length ? getUnionType(baseTypes) :                     t.flags & TypeFlags.Intersection && baseTypes.length ? getIntersectionType(baseTypes) :                     undefined */ TODO
            }
            if /* TODO(BinaryExpression): t.flags & TypeFlags.Index */ TODO {
                 stringNumberSymbolType
            }
            if /* TODO(BinaryExpression): t.flags & TypeFlags.TemplateLiteral */ TODO {
                types := /* TODO(PropertyAccessExpression): (t as TemplateLiteralType).types */ TODO
                constraints := mapDefined(types, getBaseConstraint)
                 /* TODO(ConditionalExpression): constraints.length === types.length ? getTemplateLiteralType((t as TemplateLiteralType).texts, constraints) : stringType */ TODO
            }
            if /* TODO(BinaryExpression): t.flags & TypeFlags.StringMapping */ TODO {
                constraint := getBaseConstraint(/* TODO(PropertyAccessExpression): (t as StringMappingType).type */ TODO)
                 /* TODO(ConditionalExpression): constraint && constraint !== (t as StringMappingType).type ? getStringMappingType((t as StringMappingType).symbol, constraint) : stringType */ TODO
            }
            if /* TODO(BinaryExpression): t.flags & TypeFlags.IndexedAccess */ TODO {
                if isMappedTypeGenericIndexedAccess(t) {
                     getBaseConstraint(substituteIndexedMappedType(/* TODO(PropertyAccessExpression): (t as IndexedAccessType).objectType */ TODO /* as */ /* TODO(TypeReference): MappedType */, /* TODO(PropertyAccessExpression): (t as IndexedAccessType).indexType */ TODO))
                }
                baseObjectType := getBaseConstraint(/* TODO(PropertyAccessExpression): (t as IndexedAccessType).objectType */ TODO)
                baseIndexType := getBaseConstraint(/* TODO(PropertyAccessExpression): (t as IndexedAccessType).indexType */ TODO)
                baseIndexedAccess := /* TODO(BinaryExpression): baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, (t as IndexedAccessType).accessFlags) */ TODO
                 /* TODO(BinaryExpression): baseIndexedAccess && getBaseConstraint(baseIndexedAccess) */ TODO
            }
            if /* TODO(BinaryExpression): t.flags & TypeFlags.Conditional */ TODO {
                constraint := getConstraintFromConditionalType(t /* as */ /* TODO(TypeReference): ConditionalType */)
                 /* TODO(BinaryExpression): constraint && getBaseConstraint(constraint) */ TODO
            }
            if /* TODO(BinaryExpression): t.flags & TypeFlags.Substitution */ TODO {
                 getBaseConstraint(getSubstitutionIntersection(t /* as */ /* TODO(TypeReference): SubstitutionType */))
            }
            if isGenericTupleType(t) {
                newElements := map_(getElementTypes(t), /* TODO(ArrowFunction): (v, i) => {                     const constraint = v.flags & TypeFlags.TypeParameter && t.target.elementFlags[i] & ElementFlags.Variadic && getBaseConstraint(v) || v;                     return constraint !== v && everyType(constraint, c => isArrayOrTupleType(c) && !isGenericTupleType(c)) ? constraint : v;                 } */ TODO)
                 createTupleType(newElements, /* TODO(PropertyAccessExpression): t.target.elementFlags */ TODO, /* TODO(PropertyAccessExpression): t.target.readonly */ TODO, /* TODO(PropertyAccessExpression): t.target.labeledElementDeclarations */ TODO)
            }
             t
        }
    }
    getApparentTypeOfIntersectionType := func(type_ IntersectionType, thisArgument Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(BinaryExpression): type === thisArgument */ TODO {
             /* TODO(BinaryExpression): type.resolvedApparentType || (type.resolvedApparentType = getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true)) */ TODO
        }
        key := /* TODO(TemplateExpression): `I${getTypeId(type)},${getTypeId(thisArgument)}` */ TODO
         /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true)) */ TODO
    }
    getResolvedTypeParameterDefault := func(typeParameter TypeParameter) *Type {
        if /* TODO(PrefixUnaryExpression): !typeParameter.default */ TODO {
            if /* TODO(PropertyAccessExpression): typeParameter.target */ TODO {
                targetDefault := getResolvedTypeParameterDefault(/* TODO(PropertyAccessExpression): typeParameter.target */ TODO)
                /* TODO(ExpressionStatement): typeParameter.default = targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType; */
            } else {
                /* TODO(ExpressionStatement): typeParameter.default = resolvingDefaultType; */
                defaultDeclaration := /* TODO(BinaryExpression): typeParameter.symbol && forEach(typeParameter.symbol.declarations, decl => isTypeParameterDeclaration(decl) && decl.default) */ TODO
                defaultType := /* TODO(ConditionalExpression): defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType */ TODO
                if /* TODO(BinaryExpression): typeParameter.default === resolvingDefaultType */ TODO {
                    /* TODO(ExpressionStatement): typeParameter.default = defaultType; */
                }
            }
        } else if /* TODO(BinaryExpression): typeParameter.default === resolvingDefaultType */ TODO {
            /* TODO(ExpressionStatement): typeParameter.default = circularConstraintType; */
        }
         /* TODO(PropertyAccessExpression): typeParameter.default */ TODO
    }
    getDefaultFromTypeParameter := func(typeParameter TypeParameter) *Type {
        defaultType := getResolvedTypeParameterDefault(typeParameter)
         /* TODO(ConditionalExpression): defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : undefined */ TODO
    }
    hasNonCircularTypeParameterDefault := func(typeParameter TypeParameter) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType */ TODO
    }
    hasTypeParameterDefault := func(typeParameter TypeParameter) bool {
         /* TODO(PrefixUnaryExpression): !!(typeParameter.symbol && forEach(typeParameter.symbol.declarations, decl => isTypeParameterDeclaration(decl) && decl.default)) */ TODO
    }
    getApparentTypeOfMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(BinaryExpression): type.resolvedApparentType || (type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type)) */ TODO
    }
    getResolvedApparentTypeOfMappedType := func(type_ MappedType) Type {
        target := /* TODO(ParenthesizedExpression): (type.target ?? type) */ TODO /* as */ /* TODO(TypeReference): MappedType */
        typeVariable := getHomomorphicTypeVariable(target)
        if /* TODO(BinaryExpression): typeVariable && !target.declaration.nameType */ TODO {
            modifiersType := getModifiersTypeFromMappedType(type_)
            baseConstraint := /* TODO(ConditionalExpression): isGenericMappedType(modifiersType) ? getApparentTypeOfMappedType(modifiersType) : getBaseConstraintOfType(modifiersType) */ TODO
            if /* TODO(BinaryExpression): baseConstraint && everyType(baseConstraint, t => isArrayOrTupleType(t) || isArrayOrTupleOrIntersection(t)) */ TODO {
                 instantiateType(target, prependTypeMapping(typeVariable, baseConstraint, /* TODO(PropertyAccessExpression): type.mapper */ TODO))
            }
        }
         type_
    }
    isArrayOrTupleOrIntersection := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !!(type.flags & TypeFlags.Intersection) && every((type as IntersectionType).types, isArrayOrTupleType) */ TODO
    }
    isMappedTypeGenericIndexedAccess := func(type_ Type) /* TODO(undefined): boolean */ TODO {
        objectType
         /* TODO(PrefixUnaryExpression): !!(type.flags & TypeFlags.IndexedAccess && getObjectFlags(objectType = (type as IndexedAccessType).objectType) & ObjectFlags.Mapped &&             !isGenericMappedType(objectType) && isGenericIndexType((type as IndexedAccessType).indexType) &&             !(getMappedTypeModifiers(objectType as MappedType) & MappedTypeModifiers.ExcludeOptional) && !(objectType as MappedType).declaration.nameType) */ TODO
    }
    getApparentType := func(type_ Type) Type {
        t := /* TODO(ConditionalExpression): type.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(type) || unknownType : type */ TODO
        objectFlags := getObjectFlags(t)
         /* TODO(ConditionalExpression): objectFlags & ObjectFlags.Mapped ? getApparentTypeOfMappedType(t as MappedType) :             objectFlags & ObjectFlags.Reference && t !== type ? getTypeWithThisArgument(t, type) :             t.flags & TypeFlags.Intersection ? getApparentTypeOfIntersectionType(t as IntersectionType, type) :             t.flags & TypeFlags.StringLike ? globalStringType :             t.flags & TypeFlags.NumberLike ? globalNumberType :             t.flags & TypeFlags.BigIntLike ? getGlobalBigIntType() :             t.flags & TypeFlags.BooleanLike ? globalBooleanType :             t.flags & TypeFlags.ESSymbolLike ? getGlobalESSymbolType() :             t.flags & TypeFlags.NonPrimitive ? emptyObjectType :             t.flags & TypeFlags.Index ? stringNumberSymbolType :             t.flags & TypeFlags.Unknown && !strictNullChecks ? emptyObjectType :             t */ TODO
    }
    getReducedApparentType := func(type_ Type) Type {
         getReducedType(getApparentType(getReducedType(type_)))
    }
    createUnionOrIntersectionProperty := func(containingType UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
        var singleProp *Symbol
        var propSet *Map[SymbolId, Symbol]
        var indexTypes /* TODO(ArrayType): Type[] */ any
        isUnion := /* TODO(BinaryExpression): containingType.flags & TypeFlags.Union */ TODO
        var optionalFlag *SymbolFlags
        syntheticFlag := /* TODO(PropertyAccessExpression): CheckFlags.SyntheticMethod */ TODO
        checkFlags := /* TODO(ConditionalExpression): isUnion ? 0 : CheckFlags.Readonly */ TODO
        mergedInstantiations := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForOfStatement): for (const current of containingType.types) {             const type = getApparentType(current);             if (!(isErrorType(type) || type.flags & TypeFlags.Never)) {                 const prop = getPropertyOfType(type, name, skipObjectFunctionPropertyAugment);                 const modifiers = prop ? getDeclarationModifierFlagsFromSymbol(prop) : 0;                 if (prop) {                     if (prop.flags & SymbolFlags.ClassMember) {                         optionalFlag ??= isUnion ? SymbolFlags.None : SymbolFlags.Optional;                         if (isUnion) {                             optionalFlag |= prop.flags & SymbolFlags.Optional;                         }                         else {                             optionalFlag &= prop.flags;                         }                     }                     if (!singleProp) {                         singleProp = prop;                     }                     else if (prop !== singleProp) {                         const isInstantiation = (getTargetSymbol(prop) || prop) === (getTargetSymbol(singleProp) || singleProp);                         // If the symbols are instances of one another with identical types - consider the symbols                         // equivalent and just use the first one, which thus allows us to avoid eliding private                         // members when intersecting a (this-)instantiations of a class with its raw base or another instance                         if (isInstantiation && compareProperties(singleProp, prop, (a, b) => a === b ? Ternary.True : Ternary.False) === Ternary.True) {                             // If we merged instantiations of a generic type, we replicate the symbol parent resetting behavior we used                             // to do when we recorded multiple distinct symbols so that we still get, eg, `Array<T>.length` printed                             // back and not `Array<string>.length` when we're looking at a `.length` access on a `string[] | number[]`                             mergedInstantiations = !!singleProp.parent && !!length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent));                         }                         else {                             if (!propSet) {                                 propSet = new Map<SymbolId, Symbol>();                                 propSet.set(getSymbolId(singleProp), singleProp);                             }                             const id = getSymbolId(prop);                             if (!propSet.has(id)) {                                 propSet.set(id, prop);                             }                         }                     }                     if (isUnion && isReadonlySymbol(prop)) {                         checkFlags |= CheckFlags.Readonly;                     }                     else if (!isUnion && !isReadonlySymbol(prop)) {                         checkFlags &= ~CheckFlags.Readonly;                     }                     checkFlags |= (!(modifiers & ModifierFlags.NonPublicAccessibilityModifier) ? CheckFlags.ContainsPublic : 0) |                         (modifiers & ModifierFlags.Protected ? CheckFlags.ContainsProtected : 0) |                         (modifiers & ModifierFlags.Private ? CheckFlags.ContainsPrivate : 0) |                         (modifiers & ModifierFlags.Static ? CheckFlags.ContainsStatic : 0);                     if (!isPrototypeProperty(prop)) {                         syntheticFlag = CheckFlags.SyntheticProperty;                     }                 }                 else if (isUnion) {                     const indexInfo = !isLateBoundName(name) && getApplicableIndexInfoForName(type, name);                     if (indexInfo) {                         checkFlags |= CheckFlags.WritePartial | (indexInfo.isReadonly ? CheckFlags.Readonly : 0);                         indexTypes = append(indexTypes, isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type);                     }                     else if (isObjectLiteralType(type) && !(getObjectFlags(type) & ObjectFlags.ContainsSpread)) {                         checkFlags |= CheckFlags.WritePartial;                         indexTypes = append(indexTypes, undefinedType);                     }                     else {                         checkFlags |= CheckFlags.ReadPartial;                     }                 }             }         } */
        if /* TODO(BinaryExpression): !singleProp ||             isUnion &&                 (propSet || checkFlags & CheckFlags.Partial) &&                 checkFlags & (CheckFlags.ContainsPrivate | CheckFlags.ContainsProtected) &&                 !(propSet && getCommonDeclarationsOfSymbols(propSet.values())) */ TODO {
             undefined
        }
        if /* TODO(BinaryExpression): !propSet && !(checkFlags & CheckFlags.ReadPartial) && !indexTypes */ TODO {
            if mergedInstantiations {
                links := /* TODO(PropertyAccessExpression): tryCast(singleProp, isTransientSymbol)?.links */ TODO
                clone := createSymbolWithType(singleProp, /* TODO(PropertyAccessExpression): links?.type */ TODO)
                /* TODO(ExpressionStatement): clone.parent = singleProp.valueDeclaration?.symbol?.parent; */
                /* TODO(ExpressionStatement): clone.links.containingType = containingType; */
                /* TODO(ExpressionStatement): clone.links.mapper = links?.mapper; */
                /* TODO(ExpressionStatement): clone.links.writeType = getWriteTypeOfSymbol(singleProp); */
                 clone
            } else {
                 singleProp
            }
        }
        props := /* TODO(ConditionalExpression): propSet ? arrayFrom(propSet.values()) : [singleProp] */ TODO
        var declarations /* TODO(ArrayType): Declaration[] */ any
        var firstType *Type
        var nameType *Type
        var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        var writeTypes /* TODO(ArrayType): Type[] */ any
        var firstValueDeclaration Declaration
        hasNonUniformValueDeclaration := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForOfStatement): for (const prop of props) {             if (!firstValueDeclaration) {                 firstValueDeclaration = prop.valueDeclaration;             }             else if (prop.valueDeclaration && prop.valueDeclaration !== firstValueDeclaration) {                 hasNonUniformValueDeclaration = true;             }             declarations = addRange(declarations, prop.declarations);             const type = getTypeOfSymbol(prop);             if (!firstType) {                 firstType = type;                 nameType = getSymbolLinks(prop).nameType;             }             const writeType = getWriteTypeOfSymbol(prop);             if (writeTypes || writeType !== type) {                 writeTypes = append(!writeTypes ? propTypes.slice() : writeTypes, writeType);             }             if (type !== firstType) {                 checkFlags |= CheckFlags.HasNonUniformType;             }             if (isLiteralType(type) || isPatternLiteralType(type)) {                 checkFlags |= CheckFlags.HasLiteralType;             }             if (type.flags & TypeFlags.Never && type !== uniqueLiteralType) {                 checkFlags |= CheckFlags.HasNeverType;             }             propTypes.push(type);         } */
        /* TODO(ExpressionStatement): addRange(propTypes, indexTypes); */
        result := createSymbol(/* TODO(BinaryExpression): SymbolFlags.Property | (optionalFlag ?? 0) */ TODO, name, /* TODO(BinaryExpression): syntheticFlag | checkFlags */ TODO)
        /* TODO(ExpressionStatement): result.links.containingType = containingType; */
        if /* TODO(BinaryExpression): !hasNonUniformValueDeclaration && firstValueDeclaration */ TODO {
            /* TODO(ExpressionStatement): result.valueDeclaration = firstValueDeclaration; */
            if /* TODO(PropertyAccessExpression): firstValueDeclaration.symbol.parent */ TODO {
                /* TODO(ExpressionStatement): result.parent = firstValueDeclaration.symbol.parent; */
            }
        }
        /* TODO(ExpressionStatement): result.declarations = declarations; */
        /* TODO(ExpressionStatement): result.links.nameType = nameType; */
        if /* TODO(BinaryExpression): propTypes.length > 2 */ TODO {
            /* TODO(ExpressionStatement): result.links.checkFlags |= CheckFlags.DeferredType; */
            /* TODO(ExpressionStatement): result.links.deferralParent = containingType; */
            /* TODO(ExpressionStatement): result.links.deferralConstituents = propTypes; */
            /* TODO(ExpressionStatement): result.links.deferralWriteConstituents = writeTypes; */
        } else {
            /* TODO(ExpressionStatement): result.links.type = isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes); */
            if writeTypes {
                /* TODO(ExpressionStatement): result.links.writeType = isUnion ? getUnionType(writeTypes) : getIntersectionType(writeTypes); */
            }
        }
         result
    }
    getUnionOrIntersectionProperty := func(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
        property := /* TODO(ConditionalExpression): skipObjectFunctionPropertyAugment ?             type.propertyCacheWithoutObjectFunctionPropertyAugment?.get(name) :             type.propertyCache?.get(name) */ TODO
        if /* TODO(PrefixUnaryExpression): !property */ TODO {
            /* TODO(ExpressionStatement): property = createUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment); */
            if property {
                properties := /* TODO(ConditionalExpression): skipObjectFunctionPropertyAugment ?                     type.propertyCacheWithoutObjectFunctionPropertyAugment ||= createSymbolTable() :                     type.propertyCache ||= createSymbolTable() */ TODO
                /* TODO(ExpressionStatement): properties.set(name, property); */
                if /* TODO(BinaryExpression): skipObjectFunctionPropertyAugment && !(getCheckFlags(property) & CheckFlags.Partial) && !type.propertyCache?.get(name) */ TODO {
                    properties := /* TODO(BinaryExpression): type.propertyCache ||= createSymbolTable() */ TODO
                    /* TODO(ExpressionStatement): properties.set(name, property); */
                }
            }
        }
         property
    }
    getCommonDeclarationsOfSymbols := func(symbols Iterable[Symbol]) /* TODO(undefined): Set<import("/home/jabaile/work/TypeScript/src/compiler/types").Node> | undefined */ TODO {
        var commonDeclarations *Set[Node]
        /* TODO(ForOfStatement): for (const symbol of symbols) {             if (!symbol.declarations) {                 return undefined;             }             if (!commonDeclarations) {                 commonDeclarations = new Set(symbol.declarations);                 continue;             }             commonDeclarations.forEach(declaration => {                 if (!contains(symbol.declarations, declaration)) {                     commonDeclarations!.delete(declaration);                 }             });             if (commonDeclarations.size === 0) {                 return undefined;             }         } */
         commonDeclarations
    }
    getPropertyOfUnionOrIntersectionType := func(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
        property := getUnionOrIntersectionProperty(type_, name, skipObjectFunctionPropertyAugment)
         /* TODO(ConditionalExpression): property && !(getCheckFlags(property) & CheckFlags.ReadPartial) ? property : undefined */ TODO
    }
    getReducedType := func(type_ Type) Type {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Union && (type as UnionType).objectFlags & ObjectFlags.ContainsIntersections */ TODO {
             /* TODO(BinaryExpression): (type as UnionType).resolvedReducedType || ((type as UnionType).resolvedReducedType = getReducedUnionType(type as UnionType)) */ TODO
        } else if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
            if /* TODO(PrefixUnaryExpression): !((type as IntersectionType).objectFlags & ObjectFlags.IsNeverIntersectionComputed) */ TODO {
                /* TODO(ExpressionStatement): (type as IntersectionType).objectFlags |= ObjectFlags.IsNeverIntersectionComputed |                     (some(getPropertiesOfUnionOrIntersectionType(type as IntersectionType), isNeverReducedProperty) ? ObjectFlags.IsNeverIntersection : 0); */
            }
             /* TODO(ConditionalExpression): (type as IntersectionType).objectFlags & ObjectFlags.IsNeverIntersection ? neverType : type */ TODO
        }
         type_
    }
    getReducedUnionType := func(unionType UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        reducedTypes := sameMap(/* TODO(PropertyAccessExpression): unionType.types */ TODO, getReducedType)
        if /* TODO(BinaryExpression): reducedTypes === unionType.types */ TODO {
             unionType
        }
        reduced := getUnionType(reducedTypes)
        if /* TODO(BinaryExpression): reduced.flags & TypeFlags.Union */ TODO {
            /* TODO(ExpressionStatement): (reduced as UnionType).resolvedReducedType = reduced; */
        }
         reduced
    }
    isNeverReducedProperty := func(prop Symbol) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop) */ TODO
    }
    isDiscriminantWithNeverType := func(prop Symbol) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !(prop.flags & SymbolFlags.Optional) &&             (getCheckFlags(prop) & (CheckFlags.Discriminant | CheckFlags.HasNeverType)) === CheckFlags.Discriminant &&             !!(getTypeOfSymbol(prop).flags & TypeFlags.Never) */ TODO
    }
    isConflictingPrivateProperty := func(prop Symbol) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !prop.valueDeclaration && !!(getCheckFlags(prop) & CheckFlags.ContainsPrivate) */ TODO
    }
    isGenericReducibleType := func(type_ Type) bool {
         /* TODO(PrefixUnaryExpression): !!(type.flags & TypeFlags.Union && (type as UnionType).objectFlags & ObjectFlags.ContainsIntersections && some((type as UnionType).types, isGenericReducibleType) ||             type.flags & TypeFlags.Intersection && isReducibleIntersection(type as IntersectionType)) */ TODO
    }
    isReducibleIntersection := func(type_ IntersectionType) /* TODO(undefined): boolean */ TODO {
        uniqueFilled := /* TODO(BinaryExpression): type.uniqueLiteralFilledInstantiation || (type.uniqueLiteralFilledInstantiation = instantiateType(type, uniqueLiteralMapper)) */ TODO
         /* TODO(BinaryExpression): getReducedType(uniqueFilled) !== uniqueFilled */ TODO
    }
    elaborateNeverIntersection := func(errorInfo *DiagnosticMessageChain, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined */ TODO {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsNeverIntersection */ TODO {
            neverProp := find(getPropertiesOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): IntersectionType */), isDiscriminantWithNeverType)
            if neverProp {
                 chainDiagnosticMessages(errorInfo, /* TODO(PropertyAccessExpression): Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents */ TODO, typeToString(type_, undefined, /* TODO(PropertyAccessExpression): TypeFormatFlags.NoTypeReduction */ TODO), symbolToString(neverProp))
            }
            privateProp := find(getPropertiesOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): IntersectionType */), isConflictingPrivateProperty)
            if privateProp {
                 chainDiagnosticMessages(errorInfo, /* TODO(PropertyAccessExpression): Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some */ TODO, typeToString(type_, undefined, /* TODO(PropertyAccessExpression): TypeFormatFlags.NoTypeReduction */ TODO), symbolToString(privateProp))
            }
        }
         errorInfo
    }
    getPropertyOfType := func(type_ Type, name __String, skipObjectFunctionPropertyAugment bool, includeTypeOnlyMembers bool) *Symbol {
        /* TODO(ExpressionStatement): type = getReducedApparentType(type); */
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
            resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
            symbol := /* TODO(PropertyAccessExpression): resolved.members.get */ TODO(name)
            if /* TODO(BinaryExpression): symbol && !includeTypeOnlyMembers && type.symbol?.flags & SymbolFlags.ValueModule && getSymbolLinks(type.symbol).typeOnlyExportStarMap?.has(name) */ TODO {
                 undefined
            }
            if /* TODO(BinaryExpression): symbol && symbolIsValue(symbol, includeTypeOnlyMembers) */ TODO {
                 symbol
            }
            if skipObjectFunctionPropertyAugment {
                /* TODO(Identifier): undefined */
            }
            functionType := /* TODO(ConditionalExpression): resolved === anyFunctionType ? globalFunctionType :                 resolved.callSignatures.length ? globalCallableFunctionType :                 resolved.constructSignatures.length ? globalNewableFunctionType :                 undefined */ TODO
            if functionType {
                symbol := getPropertyOfObjectType(functionType, name)
                if symbol {
                     symbol
                }
            }
             getPropertyOfObjectType(globalObjectType, name)
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
            prop := getPropertyOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */, name, /* TODO(TrueKeyword): true */ TODO)
            if prop {
                 prop
            }
            if /* TODO(PrefixUnaryExpression): !skipObjectFunctionPropertyAugment */ TODO {
                 getPropertyOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */, name, skipObjectFunctionPropertyAugment)
            }
             undefined
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
             getPropertyOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */, name, skipObjectFunctionPropertyAugment)
        }
         undefined
    }
    getSignaturesOfStructuredType := func(type_ Type, kind SignatureKind) []Signature {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.StructuredType */ TODO {
            resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
             /* TODO(ConditionalExpression): kind === SignatureKind.Call ? resolved.callSignatures : resolved.constructSignatures */ TODO
        }
         emptyArray
    }
    getSignaturesOfType := func(type_ Type, kind SignatureKind) []Signature {
        result := getSignaturesOfStructuredType(getReducedApparentType(type_), kind)
        if /* TODO(BinaryExpression): kind === SignatureKind.Call && !length(result) && type.flags & TypeFlags.Union */ TODO {
            if /* TODO(PropertyAccessExpression): (type as UnionType).arrayFallbackSignatures */ TODO {
                 /* TODO(NonNullExpression): (type as UnionType).arrayFallbackSignatures! */ TODO
            }
            var memberName __String
            if everyType(type_, /* TODO(ArrowFunction): t => !!t.symbol?.parent && isArrayOrTupleSymbol(t.symbol.parent) && (!memberName ? (memberName = t.symbol.escapedName, true) : memberName === t.symbol.escapedName) */ TODO) {
                arrayArg := mapType(type_, /* TODO(ArrowFunction): t => getMappedType((isReadonlyArraySymbol(t.symbol.parent) ? globalReadonlyArrayType : globalArrayType).typeParameters![0], (t as AnonymousType).mapper!) */ TODO)
                arrayType := createArrayType(arrayArg, someType(type_, /* TODO(ArrowFunction): t => isReadonlyArraySymbol(t.symbol.parent) */ TODO))
                 /* TODO(BinaryExpression): (type as UnionType).arrayFallbackSignatures = getSignaturesOfType(getTypeOfPropertyOfType(arrayType, memberName!)!, kind) */ TODO
            }
            /* TODO(ExpressionStatement): (type as UnionType).arrayFallbackSignatures = result; */
        }
         result
    }
    isArrayOrTupleSymbol := func(symbol *Symbol) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): !symbol || !globalArrayType.symbol || !globalReadonlyArrayType.symbol */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(BinaryExpression): !!getSymbolIfSameReference(symbol, globalArrayType.symbol) || !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol) */ TODO
    }
    isReadonlyArraySymbol := func(symbol *Symbol) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): !symbol || !globalReadonlyArrayType.symbol */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(PrefixUnaryExpression): !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol) */ TODO
    }
    findIndexInfo := func(indexInfos []IndexInfo, keyType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo | undefined */ TODO {
         find(indexInfos, /* TODO(ArrowFunction): info => info.keyType === keyType */ TODO)
    }
    findApplicableIndexInfo := func(indexInfos []IndexInfo, keyType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo | undefined */ TODO {
        var stringIndexInfo *IndexInfo
        var applicableInfo *IndexInfo
        var applicableInfos /* TODO(ArrayType): IndexInfo[] */ any
        /* TODO(ForOfStatement): for (const info of indexInfos) {             if (info.keyType === stringType) {                 stringIndexInfo = info;             }             else if (isApplicableIndexType(keyType, info.keyType)) {                 if (!applicableInfo) {                     applicableInfo = info;                 }                 else {                     (applicableInfos || (applicableInfos = [applicableInfo])).push(info);                 }             }         } */
         /* TODO(ConditionalExpression): applicableInfos ? createIndexInfo(unknownType, getIntersectionType(map(applicableInfos, info => info.type)), reduceLeft(applicableInfos, (isReadonly, info) => isReadonly && info.isReadonly, /*initial* / true)) :             applicableInfo ? applicableInfo :             stringIndexInfo && isApplicableIndexType(keyType, stringType) ? stringIndexInfo :             undefined */ TODO
    }
    isApplicableIndexType := func(source Type, target Type) bool {
         /* TODO(BinaryExpression): isTypeAssignableTo(source, target) ||             target === stringType && isTypeAssignableTo(source, numberType) ||             target === numberType && (source === numericStringType || !!(source.flags & TypeFlags.StringLiteral) && isNumericLiteralName((source as StringLiteralType).value)) */ TODO
    }
    getIndexInfosOfStructuredType := func(type_ Type) []IndexInfo {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.StructuredType */ TODO {
            resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
             /* TODO(PropertyAccessExpression): resolved.indexInfos */ TODO
        }
         emptyArray
    }
    getIndexInfosOfType := func(type_ Type) []IndexInfo {
         getIndexInfosOfStructuredType(getReducedApparentType(type_))
    }
    getIndexInfoOfType := func(type_ Type, keyType Type) *IndexInfo {
         findIndexInfo(getIndexInfosOfType(type_), keyType)
    }
    getIndexTypeOfType := func(type_ Type, keyType Type) *Type {
         /* TODO(PropertyAccessExpression): getIndexInfoOfType(type, keyType)?.type */ TODO
    }
    getApplicableIndexInfos := func(type_ Type, keyType Type) []IndexInfo {
         /* TODO(PropertyAccessExpression): getIndexInfosOfType(type).filter */ TODO(/* TODO(ArrowFunction): info => isApplicableIndexType(keyType, info.keyType) */ TODO)
    }
    getApplicableIndexInfo := func(type_ Type, keyType Type) *IndexInfo {
         findApplicableIndexInfo(getIndexInfosOfType(type_), keyType)
    }
    getApplicableIndexInfoForName := func(type_ Type, name __String) *IndexInfo {
         getApplicableIndexInfo(type_, /* TODO(ConditionalExpression): isLateBoundName(name) ? esSymbolType : getStringLiteralType(unescapeLeadingUnderscores(name)) */ TODO)
    }
    getTypeParametersFromDeclaration := func(declaration DeclarationWithTypeParameters) /* TODO(TypeOperator): readonly TypeParameter[] */ any {
        var result /* TODO(ArrayType): TypeParameter[] */ any
        /* TODO(ForOfStatement): for (const node of getEffectiveTypeParameterDeclarations(declaration)) {             result = appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol));         } */
         /* TODO(ConditionalExpression): result?.length ? result             : isFunctionDeclaration(declaration) ? getSignatureOfTypeTag(declaration)?.typeParameters             : undefined */ TODO
    }
    symbolsToArray := func(symbols SymbolTable) []Symbol {
        var result []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ExpressionStatement): symbols.forEach((symbol, id) => {             if (!isReservedMemberName(id)) {                 result.push(symbol);             }         }); */
         result
    }
    tryFindAmbientModule := func(moduleName string, withAugmentations bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        if isExternalModuleNameRelative(moduleName) {
             undefined
        }
        symbol := getSymbol(globals, /* TODO(BinaryExpression): '"' + moduleName + '"' */ TODO /* as */ /* TODO(TypeReference): __String */, /* TODO(PropertyAccessExpression): SymbolFlags.ValueModule */ TODO)
         /* TODO(ConditionalExpression): symbol && withAugmentations ? getMergedSymbol(symbol) : symbol */ TODO
    }
    hasEffectiveQuestionToken := func(node /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isParameter(node) && isJSDocOptionalParameter(node) */ TODO
    }
    isOptionalParameter := func(node /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) /* TODO(undefined): boolean */ TODO {
        if hasEffectiveQuestionToken(node) {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(PrefixUnaryExpression): !isParameter(node) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(PropertyAccessExpression): node.initializer */ TODO {
            signature := getSignatureFromDeclaration(/* TODO(PropertyAccessExpression): node.parent */ TODO)
            parameterIndex := /* TODO(PropertyAccessExpression): node.parent.parameters.indexOf */ TODO(node)
            /* TODO(ExpressionStatement): Debug.assert(parameterIndex >= 0); */
             /* TODO(BinaryExpression): parameterIndex >= getMinArgumentCount(signature, MinArgumentCountFlags.StrongArityForUntypedJS | MinArgumentCountFlags.VoidIsNonOptional) */ TODO
        }
        iife := getImmediatelyInvokedFunctionExpression(/* TODO(PropertyAccessExpression): node.parent */ TODO)
        if iife {
             /* TODO(BinaryExpression): !node.type &&                 !node.dotDotDotToken &&                 node.parent.parameters.indexOf(node) >= getEffectiveCallArguments(iife).length */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isOptionalPropertyDeclaration := func(node Declaration) /* TODO(undefined): false | import("/home/jabaile/work/TypeScript/src/compiler/types").QuestionToken | undefined */ TODO {
         /* TODO(BinaryExpression): isPropertyDeclaration(node) && !hasAccessorModifier(node) && node.questionToken */ TODO
    }
    createTypePredicate := func(kind TypePredicateKind, parameterName /* TODO(StringKeyword): string */ any, parameterIndex /* TODO(NumberKeyword): number */ any, type_ *Type) TypePredicate {
         /* TODO(ObjectLiteralExpression): { kind, parameterName, parameterIndex, type } */ TODO /* as */ /* TODO(TypeReference): TypePredicate */
    }
    getMinTypeArgumentCount := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any) number {
        minTypeArgumentCount := 0
        if typeParameters {
            /* TODO(ForStatement): for (let i = 0; i < typeParameters.length; i++) {                 if (!hasTypeParameterDefault(typeParameters[i])) {                     minTypeArgumentCount = i + 1;                 }             } */
        }
         minTypeArgumentCount
    }
    // OVERLOAD: fillMissingTypeArguments := func(typeArguments []Type, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, minTypeArgumentCount number, isJavaScriptImplicitAny bool) []Type
    // OVERLOAD: fillMissingTypeArguments := func(typeArguments /* TODO(TypeOperator): readonly Type[] */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, minTypeArgumentCount number, isJavaScriptImplicitAny bool) /* TODO(ArrayType): Type[] */ any
    fillMissingTypeArguments := func(typeArguments /* TODO(TypeOperator): readonly Type[] */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, minTypeArgumentCount number, isJavaScriptImplicitAny bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ TODO {
        numTypeParameters := length(typeParameters)
        if /* TODO(PrefixUnaryExpression): !numTypeParameters */ TODO {
             /* TODO(ArrayLiteralExpression): [] */ TODO
        }
        numTypeArguments := length(typeArguments)
        if /* TODO(BinaryExpression): isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters) */ TODO {
            result := /* TODO(ConditionalExpression): typeArguments ? typeArguments.slice() : [] */ TODO
            /* TODO(ForStatement): for (let i = numTypeArguments; i < numTypeParameters; i++) {                 result[i] = errorType;             } */
            baseDefaultType := getDefaultTypeArgumentType(isJavaScriptImplicitAny)
            /* TODO(ForStatement): for (let i = numTypeArguments; i < numTypeParameters; i++) {                 let defaultType = getDefaultFromTypeParameter(typeParameters![i]);                 if (isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType))) {                     defaultType = anyType;                 }                 result[i] = defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters!, result)) : baseDefaultType;             } */
            /* TODO(ExpressionStatement): result.length = typeParameters!.length; */
             result
        }
         /* TODO(BinaryExpression): typeArguments && typeArguments.slice() */ TODO
    }
    getSignatureFromDeclaration := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) Signature {
        links := getNodeLinks(declaration)
        if /* TODO(PrefixUnaryExpression): !links.resolvedSignature */ TODO {
            var parameters []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
            flags := /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO
            minArgumentCount := 0
            var thisParameter *Symbol
            var thisTag *JSDocThisTag = /* TODO(ConditionalExpression): isInJSFile(declaration) ? getJSDocThisTag(declaration) : undefined */ TODO
            hasThisParameter := /* TODO(FalseKeyword): false */ TODO
            iife := getImmediatelyInvokedFunctionExpression(declaration)
            isJSConstructSignature := isJSDocConstructSignature(declaration)
            isUntypedSignatureInJSFile := /* TODO(BinaryExpression): !iife &&                 isInJSFile(declaration) &&                 isValueSignatureDeclaration(declaration) &&                 !hasJSDocParameterTags(declaration) &&                 !getJSDocType(declaration) */ TODO
            if isUntypedSignatureInJSFile {
                /* TODO(ExpressionStatement): flags |= SignatureFlags.IsUntypedSignatureInJSFile; */
            }
            /* TODO(ForStatement): for (let i = isJSConstructSignature ? 1 : 0; i < declaration.parameters.length; i++) {                 const param = declaration.parameters[i];                 if (isInJSFile(param) && isJSDocThisTag(param)) {                     thisTag = param;                     continue;                 }                  let paramSymbol = param.symbol;                 const type = isJSDocParameterTag(param) ? (param.typeExpression && param.typeExpression.type) : param.type;                 // Include parameter symbol instead of property symbol in the signature                 if (paramSymbol && !!(paramSymbol.flags & SymbolFlags.Property) && !isBindingPattern(param.name)) {                     const resolvedSymbol = resolveName(param, paramSymbol.escapedName, SymbolFlags.Value, /*nameNotFoundMessage* / undefined, /*isUse* / false);                     paramSymbol = resolvedSymbol!;                 }                 if (i === 0 && paramSymbol.escapedName === InternalSymbolName.This) {                     hasThisParameter = true;                     thisParameter = param.symbol;                 }                 else {                     parameters.push(paramSymbol);                 }                  if (type && type.kind === SyntaxKind.LiteralType) {                     flags |= SignatureFlags.HasLiteralTypes;                 }                  // Record a new minimum argument count if this is not an optional parameter                 const isOptionalParameter = hasEffectiveQuestionToken(param) ||                     isParameter(param) && param.initializer || isRestParameter(param) ||                     iife && parameters.length > iife.arguments.length && !type;                 if (!isOptionalParameter) {                     minArgumentCount = parameters.length;                 }             } */
            if /* TODO(BinaryExpression): (declaration.kind === SyntaxKind.GetAccessor || declaration.kind === SyntaxKind.SetAccessor) &&                 hasBindableName(declaration) &&                 (!hasThisParameter || !thisParameter) */ TODO {
                otherKind := /* TODO(ConditionalExpression): declaration.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor */ TODO
                other := getDeclarationOfKind(getSymbolOfDeclaration(declaration), otherKind)
                if other {
                    /* TODO(ExpressionStatement): thisParameter = getAnnotatedAccessorThisParameter(other); */
                }
            }
            if /* TODO(BinaryExpression): thisTag && thisTag.typeExpression */ TODO {
                /* TODO(ExpressionStatement): thisParameter = createSymbolWithType(createSymbol(SymbolFlags.FunctionScopedVariable, InternalSymbolName.This), getTypeFromTypeNode(thisTag.typeExpression)); */
            }
            hostDeclaration := /* TODO(ConditionalExpression): isJSDocSignature(declaration) ? getEffectiveJSDocHost(declaration) : declaration */ TODO
            classType := /* TODO(ConditionalExpression): hostDeclaration && isConstructorDeclaration(hostDeclaration) ?                 getDeclaredTypeOfClassOrInterface(getMergedSymbol((hostDeclaration.parent as ClassDeclaration).symbol))                 : undefined */ TODO
            typeParameters := /* TODO(ConditionalExpression): classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration) */ TODO
            if /* TODO(BinaryExpression): hasRestParameter(declaration) || isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters) */ TODO {
                /* TODO(ExpressionStatement): flags |= SignatureFlags.HasRestParameter; */
            }
            if /* TODO(BinaryExpression): isConstructorTypeNode(declaration) && hasSyntacticModifier(declaration, ModifierFlags.Abstract) ||                 isConstructorDeclaration(declaration) && hasSyntacticModifier(declaration.parent, ModifierFlags.Abstract) */ TODO {
                /* TODO(ExpressionStatement): flags |= SignatureFlags.Abstract; */
            }
            /* TODO(ExpressionStatement): links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, /*resolvedReturnType* / undefined, /*resolvedTypePredicate* / undefined, minArgumentCount, flags); */
        }
         /* TODO(PropertyAccessExpression): links.resolvedSignature */ TODO
    }
    maybeAddJsSyntheticRestParameter := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any, parameters []Symbol) bool {
        if /* TODO(BinaryExpression): isJSDocSignature(declaration) || !containsArgumentsReference(declaration) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        lastParam := lastOrUndefined(/* TODO(PropertyAccessExpression): declaration.parameters */ TODO)
        lastParamTags := /* TODO(ConditionalExpression): lastParam ? getJSDocParameterTags(lastParam) : getJSDocTags(declaration).filter(isJSDocParameterTag) */ TODO
        lastParamVariadicType := firstDefined(lastParamTags, /* TODO(ArrowFunction): p => p.typeExpression && isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : undefined */ TODO)
        syntheticArgsSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Variable */ TODO, "args" /* as */ /* TODO(TypeReference): __String */, /* TODO(PropertyAccessExpression): CheckFlags.RestParameter */ TODO)
        if lastParamVariadicType {
            /* TODO(ExpressionStatement): syntheticArgsSymbol.links.type = createArrayType(getTypeFromTypeNode(lastParamVariadicType.type)); */
        } else {
            /* TODO(ExpressionStatement): syntheticArgsSymbol.links.checkFlags |= CheckFlags.DeferredType; */
            /* TODO(ExpressionStatement): syntheticArgsSymbol.links.deferralParent = neverType; */
            /* TODO(ExpressionStatement): syntheticArgsSymbol.links.deferralConstituents = [anyArrayType]; */
            /* TODO(ExpressionStatement): syntheticArgsSymbol.links.deferralWriteConstituents = [anyArrayType]; */
        }
        if lastParamVariadicType {
            /* TODO(ExpressionStatement): parameters.pop(); */
        }
        /* TODO(ExpressionStatement): parameters.push(syntheticArgsSymbol); */
         /* TODO(TrueKeyword): true */ TODO
    }
    getSignatureOfTypeTag := func(node /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
        if /* TODO(PrefixUnaryExpression): !(isInJSFile(node) && isFunctionLikeDeclaration(node)) */ TODO {
            /* TODO(Identifier): undefined */
        }
        typeTag := getJSDocTypeTag(node)
         /* TODO(BinaryExpression): typeTag?.typeExpression && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression)) */ TODO
    }
    getParameterTypeOfTypeTag := func(func_ FunctionLikeDeclaration, parameter ParameterDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        signature := getSignatureOfTypeTag(func_)
        if /* TODO(PrefixUnaryExpression): !signature */ TODO {
            /* TODO(Identifier): undefined */
        }
        pos := /* TODO(PropertyAccessExpression): func.parameters.indexOf */ TODO(parameter)
         /* TODO(ConditionalExpression): parameter.dotDotDotToken ? getRestTypeAtPosition(signature, pos) : getTypeAtPosition(signature, pos) */ TODO
    }
    getReturnTypeOfTypeTag := func(node /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        signature := getSignatureOfTypeTag(node)
         /* TODO(BinaryExpression): signature && getReturnTypeOfSignature(signature) */ TODO
    }
    containsArgumentsReference := func(declaration SignatureDeclaration) bool {
        links := getNodeLinks(declaration)
        if /* TODO(BinaryExpression): links.containsArgumentsReference === undefined */ TODO {
            if /* TODO(BinaryExpression): links.flags & NodeCheckFlags.CaptureArguments */ TODO {
                /* TODO(ExpressionStatement): links.containsArgumentsReference = true; */
            } else {
                /* TODO(ExpressionStatement): links.containsArgumentsReference = traverse((declaration as FunctionLikeDeclaration).body!); */
            }
        }
         /* TODO(PropertyAccessExpression): links.containsArgumentsReference */ TODO
        traverse := func(node Node) bool {
            if /* TODO(PrefixUnaryExpression): !node */ TODO {
                /* TODO(FalseKeyword): false */
            }
            /* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.Identifier:                     return (node as Identifier).escapedText === argumentsSymbol.escapedName && getReferencedValueSymbol(node as Identifier) === argumentsSymbol;                  case SyntaxKind.PropertyDeclaration:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                     return (node as NamedDeclaration).name!.kind === SyntaxKind.ComputedPropertyName                         && traverse((node as NamedDeclaration).name!);                  case SyntaxKind.PropertyAccessExpression:                 case SyntaxKind.ElementAccessExpression:                     return traverse((node as PropertyAccessExpression | ElementAccessExpression).expression);                  case SyntaxKind.PropertyAssignment:                     return traverse((node as PropertyAssignment).initializer);                  default:                     return !nodeStartsNewLexicalEnvironment(node) && !isPartOfTypeNode(node) && !!forEachChild(node, traverse);             } */
        }
    }
    getSignaturesOfSymbol := func(symbol *Symbol) []Signature {
        if /* TODO(BinaryExpression): !symbol || !symbol.declarations */ TODO {
            /* TODO(Identifier): emptyArray */
        }
        var result []Signature = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForStatement): for (let i = 0; i < symbol.declarations.length; i++) {             const decl = symbol.declarations[i];             if (!isFunctionLike(decl)) continue;             // Don't include signature if node is the implementation of an overloaded function. A node is considered             // an implementation node if it has a body and the previous node is of the same kind and immediately             // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).             if (i > 0 && (decl as FunctionLikeDeclaration).body) {                 const previous = symbol.declarations[i - 1];                 if (decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end) {                     continue;                 }             }             if (isInJSFile(decl) && decl.jsDoc) {                 const tags = getJSDocOverloadTags(decl);                 if (length(tags)) {                     for (const tag of tags) {                         const jsDocSignature = tag.typeExpression;                         if (jsDocSignature.type === undefined && !isConstructorDeclaration(decl)) {                             reportImplicitAny(jsDocSignature, anyType);                         }                         result.push(getSignatureFromDeclaration(jsDocSignature));                     }                     continue;                 }             }             // If this is a function or method declaration, get the signature from the @type tag for the sake of optional parameters.             // Exclude contextually-typed kinds because we already apply the @type tag to the context, plus applying it here to the initializer would supress checks that the two are compatible.             result.push(                 (!isFunctionExpressionOrArrowFunction(decl) &&                     !isObjectLiteralMethod(decl) &&                     getSignatureOfTypeTag(decl)) ||                     getSignatureFromDeclaration(decl),             );         } */
         result
    }
    resolveExternalModuleTypeByLiteral := func(name StringLiteral) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        moduleSym := resolveExternalModuleName(name, name)
        if moduleSym {
            resolvedModuleSymbol := resolveExternalModuleSymbol(moduleSym)
            if resolvedModuleSymbol {
                 getTypeOfSymbol(resolvedModuleSymbol)
            }
        }
         anyType
    }
    getThisTypeOfSignature := func(signature Signature) *Type {
        if /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO {
             getTypeOfSymbol(/* TODO(PropertyAccessExpression): signature.thisParameter */ TODO)
        }
    }
    getTypePredicateOfSignature := func(signature Signature) *TypePredicate {
        if /* TODO(PrefixUnaryExpression): !signature.resolvedTypePredicate */ TODO {
            if /* TODO(PropertyAccessExpression): signature.target */ TODO {
                targetTypePredicate := getTypePredicateOfSignature(/* TODO(PropertyAccessExpression): signature.target */ TODO)
                /* TODO(ExpressionStatement): signature.resolvedTypePredicate = targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper!) : noTypePredicate; */
            } else if /* TODO(PropertyAccessExpression): signature.compositeSignatures */ TODO {
                /* TODO(ExpressionStatement): signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate; */
            } else {
                type_ := /* TODO(BinaryExpression): signature.declaration && getEffectiveReturnTypeNode(signature.declaration) */ TODO
                var jsdocPredicate *TypePredicate
                if /* TODO(PrefixUnaryExpression): !type */ TODO {
                    jsdocSignature := getSignatureOfTypeTag(/* TODO(NonNullExpression): signature.declaration! */ TODO)
                    if /* TODO(BinaryExpression): jsdocSignature && signature !== jsdocSignature */ TODO {
                        /* TODO(ExpressionStatement): jsdocPredicate = getTypePredicateOfSignature(jsdocSignature); */
                    }
                }
                if /* TODO(BinaryExpression): type || jsdocPredicate */ TODO {
                    /* TODO(ExpressionStatement): signature.resolvedTypePredicate = type && isTypePredicateNode(type) ?                         createTypePredicateFromTypePredicateNode(type, signature) :                         jsdocPredicate || noTypePredicate; */
                } else if /* TODO(BinaryExpression): signature.declaration && isFunctionLikeDeclaration(signature.declaration) && (!signature.resolvedReturnType || signature.resolvedReturnType.flags & TypeFlags.Boolean) && getParameterCount(signature) > 0 */ TODO {
                    TODO_IDENTIFIER := signature
                    /* TODO(ExpressionStatement): signature.resolvedTypePredicate = noTypePredicate; */
                    /* TODO(ExpressionStatement): signature.resolvedTypePredicate = getTypePredicateFromBody(declaration) || noTypePredicate; */
                } else {
                    /* TODO(ExpressionStatement): signature.resolvedTypePredicate = noTypePredicate; */
                }
            }
            /* TODO(ExpressionStatement): Debug.assert(!!signature.resolvedTypePredicate); */
        }
         /* TODO(ConditionalExpression): signature.resolvedTypePredicate === noTypePredicate ? undefined : signature.resolvedTypePredicate */ TODO
    }
    createTypePredicateFromTypePredicateNode := func(node TypePredicateNode, signature Signature) TypePredicate {
        parameterName := /* TODO(PropertyAccessExpression): node.parameterName */ TODO
        type_ := /* TODO(BinaryExpression): node.type && getTypeFromTypeNode(node.type) */ TODO
         /* TODO(ConditionalExpression): parameterName.kind === SyntaxKind.ThisType ?             createTypePredicate(node.assertsModifier ? TypePredicateKind.AssertsThis : TypePredicateKind.This, /*parameterName* / undefined, /*parameterIndex* / undefined, type) :             createTypePredicate(node.assertsModifier ? TypePredicateKind.AssertsIdentifier : TypePredicateKind.Identifier, parameterName.escapedText as string, findIndex(signature.parameters, p => p.escapedName === parameterName.escapedText), type) */ TODO
    }
    getUnionOrIntersectionType := func(types []Type, kind *TypeFlags, unionReduction UnionReduction) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): kind !== TypeFlags.Intersection ? getUnionType(types, unionReduction) : getIntersectionType(types) */ TODO
    }
    getReturnTypeOfSignature := func(signature Signature) Type {
        if /* TODO(PrefixUnaryExpression): !signature.resolvedReturnType */ TODO {
            if /* TODO(PrefixUnaryExpression): !pushTypeResolution(signature, TypeSystemPropertyName.ResolvedReturnType) */ TODO {
                 errorType
            }
            type_ := /* TODO(ConditionalExpression): signature.target ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper) :                 signature.compositeSignatures ? instantiateType(getUnionOrIntersectionType(map(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, UnionReduction.Subtype), signature.mapper) :                 getReturnTypeFromAnnotation(signature.declaration!) ||                 (nodeIsMissing((signature.declaration as FunctionLikeDeclaration).body) ? anyType : getReturnTypeFromBody(signature.declaration as FunctionLikeDeclaration)) */ TODO
            if /* TODO(BinaryExpression): signature.flags & SignatureFlags.IsInnerCallChain */ TODO {
                /* TODO(ExpressionStatement): type = addOptionalTypeMarker(type); */
            } else if /* TODO(BinaryExpression): signature.flags & SignatureFlags.IsOuterCallChain */ TODO {
                /* TODO(ExpressionStatement): type = getOptionalType(type); */
            }
            if /* TODO(PrefixUnaryExpression): !popTypeResolution() */ TODO {
                if /* TODO(PropertyAccessExpression): signature.declaration */ TODO {
                    typeNode := getEffectiveReturnTypeNode(/* TODO(PropertyAccessExpression): signature.declaration */ TODO)
                    if typeNode {
                        /* TODO(ExpressionStatement): error(typeNode, Diagnostics.Return_type_annotation_circularly_references_itself); */
                    } else if noImplicitAny {
                        declaration := /* TODO(PropertyAccessExpression): signature.declaration */ TODO /* as */ /* TODO(TypeReference): Declaration */
                        name := getNameOfDeclaration(declaration)
                        if name {
                            /* TODO(ExpressionStatement): error(name, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, declarationNameToString(name)); */
                        } else {
                            /* TODO(ExpressionStatement): error(declaration, Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions); */
                        }
                    }
                }
                /* TODO(ExpressionStatement): type = anyType; */
            }
            /* TODO(ExpressionStatement): signature.resolvedReturnType ??= type; */
        }
         /* TODO(PropertyAccessExpression): signature.resolvedReturnType */ TODO
    }
    getReturnTypeFromAnnotation := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(BinaryExpression): declaration.kind === SyntaxKind.Constructor */ TODO {
             getDeclaredTypeOfClassOrInterface(getMergedSymbol(/* TODO(PropertyAccessExpression): (declaration.parent as ClassDeclaration).symbol */ TODO))
        }
        typeNode := getEffectiveReturnTypeNode(declaration)
        if isJSDocSignature(declaration) {
            root := getJSDocRoot(declaration)
            if /* TODO(BinaryExpression): root && isConstructorDeclaration(root.parent) && !typeNode */ TODO {
                 getDeclaredTypeOfClassOrInterface(getMergedSymbol(/* TODO(PropertyAccessExpression): (root.parent.parent as ClassDeclaration).symbol */ TODO))
            }
        }
        if isJSDocConstructSignature(declaration) {
             getTypeFromTypeNode(/* TODO(NonNullExpression): (declaration.parameters[0] as ParameterDeclaration).type! */ TODO)
        }
        if typeNode {
             getTypeFromTypeNode(typeNode)
        }
        if /* TODO(BinaryExpression): declaration.kind === SyntaxKind.GetAccessor && hasBindableName(declaration) */ TODO {
            jsDocType := /* TODO(BinaryExpression): isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration) */ TODO
            if jsDocType {
                 jsDocType
            }
            setter := getDeclarationOfKind(getSymbolOfDeclaration(declaration), /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */ TODO)
            setterType := getAnnotatedAccessorType(setter)
            if setterType {
                 setterType
            }
        }
         getReturnTypeOfTypeTag(declaration)
    }
    isResolvingReturnTypeOfSignature := func(signature Signature) bool {
         /* TODO(BinaryExpression): signature.compositeSignatures && some(signature.compositeSignatures, isResolvingReturnTypeOfSignature) ||             !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, TypeSystemPropertyName.ResolvedReturnType) >= 0 */ TODO
    }
    getRestTypeOfSignature := func(signature Signature) Type {
         /* TODO(BinaryExpression): tryGetRestTypeOfSignature(signature) || anyType */ TODO
    }
    tryGetRestTypeOfSignature := func(signature Signature) *Type {
        if signatureHasRestParameter(signature) {
            sigRestType := getTypeOfSymbol(/* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
            restType := /* TODO(ConditionalExpression): isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) : sigRestType */ TODO
             /* TODO(BinaryExpression): restType && getIndexTypeOfType(restType, numberType) */ TODO
        }
         undefined
    }
    getSignatureInstantiation := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any, isJavascript bool, inferredTypeParameters []TypeParameter) Signature {
        instantiatedSignature := getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments, /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO, getMinTypeArgumentCount(/* TODO(PropertyAccessExpression): signature.typeParameters */ TODO), isJavascript))
        if inferredTypeParameters {
            returnSignature := getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature))
            if returnSignature {
                newReturnSignature := cloneSignature(returnSignature)
                /* TODO(ExpressionStatement): newReturnSignature.typeParameters = inferredTypeParameters; */
                newInstantiatedSignature := cloneSignature(instantiatedSignature)
                /* TODO(ExpressionStatement): newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature); */
                 newInstantiatedSignature
            }
        }
         instantiatedSignature
    }
    getSignatureInstantiationWithoutFillingInTypeArguments := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) Signature {
        instantiations := /* TODO(BinaryExpression): signature.instantiations || (signature.instantiations = new Map<string, Signature>()) */ TODO
        id := getTypeListId(typeArguments)
        instantiation := /* TODO(PropertyAccessExpression): instantiations.get */ TODO(id)
        if /* TODO(PrefixUnaryExpression): !instantiation */ TODO {
            /* TODO(ExpressionStatement): instantiations.set(id, instantiation = createSignatureInstantiation(signature, typeArguments)); */
        }
         instantiation
    }
    createSignatureInstantiation := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) Signature {
         instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments), /* TODO(TrueKeyword): true */ TODO)
    }
    getTypeParametersForMapper := func(signature Signature) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ TODO {
         sameMap(/* TODO(PropertyAccessExpression): signature.typeParameters */ TODO, /* TODO(ArrowFunction): tp => tp.mapper ? instantiateType(tp, tp.mapper) : tp */ TODO)
    }
    createSignatureTypeMapper := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) TypeMapper {
         createTypeMapper(/* TODO(NonNullExpression): getTypeParametersForMapper(signature)! */ TODO, typeArguments)
    }
    getErasedSignature := func(signature Signature) Signature {
         /* TODO(ConditionalExpression): signature.typeParameters ?             signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) :             signature */ TODO
    }
    createErasedSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
         instantiateSignature(signature, createTypeEraser(/* TODO(NonNullExpression): signature.typeParameters! */ TODO), /* TODO(TrueKeyword): true */ TODO)
    }
    getCanonicalSignature := func(signature Signature) Signature {
         /* TODO(ConditionalExpression): signature.typeParameters ?             signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) :             signature */ TODO
    }
    createCanonicalSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
         getSignatureInstantiation(signature, map_(/* TODO(PropertyAccessExpression): signature.typeParameters */ TODO, /* TODO(ArrowFunction): tp => tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp */ TODO), isInJSFile(/* TODO(PropertyAccessExpression): signature.declaration */ TODO))
    }
    getImplementationSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
         /* TODO(ConditionalExpression): signature.typeParameters ?             signature.implementationSignatureCache ||= createImplementationSignature(signature) :             signature */ TODO
    }
    createImplementationSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
         /* TODO(ConditionalExpression): signature.typeParameters ? instantiateSignature(signature, createTypeMapper([], [])) : signature */ TODO
    }
    getBaseSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
        typeParameters := /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO
        if typeParameters {
            if /* TODO(PropertyAccessExpression): signature.baseSignatureCache */ TODO {
                 /* TODO(PropertyAccessExpression): signature.baseSignatureCache */ TODO
            }
            typeEraser := createTypeEraser(typeParameters)
            baseConstraintMapper := createTypeMapper(typeParameters, map_(typeParameters, /* TODO(ArrowFunction): tp => getConstraintOfTypeParameter(tp) || unknownType */ TODO))
            var baseConstraints []Type = map_(typeParameters, /* TODO(ArrowFunction): tp => instantiateType(tp, baseConstraintMapper) || unknownType */ TODO)
            /* TODO(ForStatement): for (let i = 0; i < typeParameters.length - 1; i++) {                 baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper);             } */
            /* TODO(ExpressionStatement): baseConstraints = instantiateTypes(baseConstraints, typeEraser); */
             /* TODO(BinaryExpression): signature.baseSignatureCache = instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints), /*eraseTypeParameters* / true) */ TODO
        }
         signature
    }
    getOrCreateTypeFromSignature := func(signature Signature, outerTypeParameters []TypeParameter) ObjectType {
        if /* TODO(PrefixUnaryExpression): !signature.isolatedSignatureType */ TODO {
            kind := /* TODO(PropertyAccessExpression): signature.declaration?.kind */ TODO
            isConstructor := /* TODO(BinaryExpression): kind === undefined || kind === SyntaxKind.Constructor || kind === SyntaxKind.ConstructSignature || kind === SyntaxKind.ConstructorType */ TODO
            type_ := createObjectType(/* TODO(BinaryExpression): ObjectFlags.Anonymous | ObjectFlags.SingleSignatureType */ TODO, createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Function */ TODO, /* TODO(PropertyAccessExpression): InternalSymbolName.Function */ TODO)) /* as */ /* TODO(TypeReference): SingleSignatureType */
            if /* TODO(BinaryExpression): signature.declaration && !nodeIsSynthesized(signature.declaration) */ TODO {
                /* TODO(ExpressionStatement): type.symbol.declarations = [signature.declaration]; */
                /* TODO(ExpressionStatement): type.symbol.valueDeclaration = signature.declaration; */
            }
            /* TODO(ExpressionStatement): outerTypeParameters ||= signature.declaration && getOuterTypeParameters(signature.declaration, /*includeThisTypes* / true); */
            /* TODO(ExpressionStatement): type.outerTypeParameters = outerTypeParameters; */
            /* TODO(ExpressionStatement): type.members = emptySymbols; */
            /* TODO(ExpressionStatement): type.properties = emptyArray; */
            /* TODO(ExpressionStatement): type.callSignatures = !isConstructor ? [signature] : emptyArray; */
            /* TODO(ExpressionStatement): type.constructSignatures = isConstructor ? [signature] : emptyArray; */
            /* TODO(ExpressionStatement): type.indexInfos = emptyArray; */
            /* TODO(ExpressionStatement): signature.isolatedSignatureType = type; */
        }
         /* TODO(PropertyAccessExpression): signature.isolatedSignatureType */ TODO
    }
    getIndexSymbol := func(symbol Symbol) *Symbol {
         /* TODO(ConditionalExpression): symbol.members ? getIndexSymbolFromSymbolTable(symbol.members) : undefined */ TODO
    }
    getIndexSymbolFromSymbolTable := func(symbolTable SymbolTable) *Symbol {
         /* TODO(PropertyAccessExpression): symbolTable.get */ TODO(/* TODO(PropertyAccessExpression): InternalSymbolName.Index */ TODO)
    }
    createIndexInfo := func(keyType Type, type_ Type, isReadonly bool, declaration IndexSignatureDeclaration) IndexInfo {
         /* TODO(ObjectLiteralExpression): { keyType, type, isReadonly, declaration } */ TODO
    }
    getIndexInfosOfSymbol := func(symbol Symbol) []IndexInfo {
        indexSymbol := getIndexSymbol(symbol)
         /* TODO(ConditionalExpression): indexSymbol ? getIndexInfosOfIndexSymbol(indexSymbol) : emptyArray */ TODO
    }
    getIndexInfosOfIndexSymbol := func(indexSymbol Symbol) []IndexInfo {
        if /* TODO(PropertyAccessExpression): indexSymbol.declarations */ TODO {
            var indexInfos []IndexInfo = /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(ForOfStatement): for (const declaration of (indexSymbol.declarations as IndexSignatureDeclaration[])) {                 if (declaration.parameters.length === 1) {                     const parameter = declaration.parameters[0];                     if (parameter.type) {                         forEachType(getTypeFromTypeNode(parameter.type), keyType => {                             if (isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos, keyType)) {                                 indexInfos.push(createIndexInfo(keyType, declaration.type ? getTypeFromTypeNode(declaration.type) : anyType, hasEffectiveModifier(declaration, ModifierFlags.Readonly), declaration));                             }                         });                     }                 }             } */
             indexInfos
        }
         emptyArray
    }
    isValidIndexKeyType := func(type_ Type) bool {
         /* TODO(BinaryExpression): !!(type.flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.ESSymbol)) || isPatternLiteralType(type) ||             !!(type.flags & TypeFlags.Intersection) && !isGenericType(type) && some((type as IntersectionType).types, isValidIndexKeyType) */ TODO
    }
    getConstraintDeclaration := func(type_ TypeParameter) *TypeNode {
         /* TODO(ElementAccessExpression): mapDefined(filter(type.symbol && type.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0] */ TODO
    }
    getInferredTypeParameterConstraint := func(typeParameter TypeParameter, omitTypeReferences bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        var inferences /* TODO(ArrayType): Type[] */ any
        if /* TODO(PropertyAccessExpression): typeParameter.symbol?.declarations */ TODO {
            /* TODO(ForOfStatement): for (const declaration of typeParameter.symbol.declarations) {                 if (declaration.parent.kind === SyntaxKind.InferType) {                     // When an 'infer T' declaration is immediately contained in a type reference node                     // (such as 'Foo<infer T>'), T's constraint is inferred from the constraint of the                     // corresponding type parameter in 'Foo'. When multiple 'infer T' declarations are                     // present, we form an intersection of the inferred constraint types.                     const [childTypeParameter = declaration.parent, grandParent] = walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent);                     if (grandParent.kind === SyntaxKind.TypeReference && !omitTypeReferences) {                         const typeReference = grandParent as TypeReferenceNode;                         const typeParameters = getTypeParametersForTypeReferenceOrImport(typeReference);                         if (typeParameters) {                             const index = typeReference.typeArguments!.indexOf(childTypeParameter as TypeNode);                             if (index < typeParameters.length) {                                 const declaredConstraint = getConstraintOfTypeParameter(typeParameters[index]);                                 if (declaredConstraint) {                                     // Type parameter constraints can reference other type parameters so                                     // constraints need to be instantiated. If instantiation produces the                                     // type parameter itself, we discard that inference. For example, in                                     //   type Foo<T extends string, U extends T> = [T, U];                                     //   type Bar<T> = T extends Foo<infer X, infer X> ? Foo<X, X> : T;                                     // the instantiated constraint for U is X, so we discard that inference.                                     const mapper = makeDeferredTypeMapper(                                         typeParameters,                                         typeParameters.map((_, index) => () => {                                             return getEffectiveTypeArgumentAtIndex(typeReference, typeParameters, index);                                         }),                                     );                                     const constraint = instantiateType(declaredConstraint, mapper);                                     if (constraint !== typeParameter) {                                         inferences = append(inferences, constraint);                                     }                                 }                             }                         }                     }                     // When an 'infer T' declaration is immediately contained in a rest parameter declaration, a rest type                     // or a named rest tuple element, we infer an 'unknown[]' constraint.                     else if (                         grandParent.kind === SyntaxKind.Parameter && (grandParent as ParameterDeclaration).dotDotDotToken ||                         grandParent.kind === SyntaxKind.RestType ||                         grandParent.kind === SyntaxKind.NamedTupleMember && (grandParent as NamedTupleMember).dotDotDotToken                     ) {                         inferences = append(inferences, createArrayType(unknownType));                     }                     // When an 'infer T' declaration is immediately contained in a string template type, we infer a 'string'                     // constraint.                     else if (grandParent.kind === SyntaxKind.TemplateLiteralTypeSpan) {                         inferences = append(inferences, stringType);                     }                     // When an 'infer T' declaration is in the constraint position of a mapped type, we infer a 'keyof any'                     // constraint.                     else if (grandParent.kind === SyntaxKind.TypeParameter && grandParent.parent.kind === SyntaxKind.MappedType) {                         inferences = append(inferences, stringNumberSymbolType);                     }                     // When an 'infer T' declaration is the template of a mapped type, and that mapped type is the extends                     // clause of a conditional whose check type is also a mapped type, give it a constraint equal to the template                     // of the check type's mapped type                     else if (                         grandParent.kind === SyntaxKind.MappedType && (grandParent as MappedTypeNode).type &&                         skipParentheses((grandParent as MappedTypeNode).type!) === declaration.parent && grandParent.parent.kind === SyntaxKind.ConditionalType &&                         (grandParent.parent as ConditionalTypeNode).extendsType === grandParent && (grandParent.parent as ConditionalTypeNode).checkType.kind === SyntaxKind.MappedType &&                         ((grandParent.parent as ConditionalTypeNode).checkType as MappedTypeNode).type                     ) {                         const checkMappedType = (grandParent.parent as ConditionalTypeNode).checkType as MappedTypeNode;                         const nodeType = getTypeFromTypeNode(checkMappedType.type!);                         inferences = append(inferences, instantiateType(nodeType, makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(checkMappedType.typeParameter)), checkMappedType.typeParameter.constraint ? getTypeFromTypeNode(checkMappedType.typeParameter.constraint) : stringNumberSymbolType)));                     }                 }             } */
        }
         /* TODO(BinaryExpression): inferences && getIntersectionType(inferences) */ TODO
    }
    getConstraintFromTypeParameter := func(typeParameter TypeParameter) *Type {
        if /* TODO(PrefixUnaryExpression): !typeParameter.constraint */ TODO {
            if /* TODO(PropertyAccessExpression): typeParameter.target */ TODO {
                targetConstraint := getConstraintOfTypeParameter(/* TODO(PropertyAccessExpression): typeParameter.target */ TODO)
                /* TODO(ExpressionStatement): typeParameter.constraint = targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType; */
            } else {
                constraintDeclaration := getConstraintDeclaration(typeParameter)
                if /* TODO(PrefixUnaryExpression): !constraintDeclaration */ TODO {
                    /* TODO(ExpressionStatement): typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType; */
                } else {
                    type_ := getTypeFromTypeNode(constraintDeclaration)
                    if /* TODO(BinaryExpression): type.flags & TypeFlags.Any && !isErrorType(type) */ TODO {
                        /* TODO(ExpressionStatement): type = constraintDeclaration.parent.parent.kind === SyntaxKind.MappedType ? stringNumberSymbolType : unknownType; */
                    }
                    /* TODO(ExpressionStatement): typeParameter.constraint = type; */
                }
            }
        }
         /* TODO(ConditionalExpression): typeParameter.constraint === noConstraintType ? undefined : typeParameter.constraint */ TODO
    }
    getParentSymbolOfTypeParameter := func(typeParameter TypeParameter) *Symbol {
        tp := /* TODO(NonNullExpression): getDeclarationOfKind<TypeParameterDeclaration>(typeParameter.symbol, SyntaxKind.TypeParameter)! */ TODO
        host := /* TODO(ConditionalExpression): isJSDocTemplateTag(tp.parent) ? getEffectiveContainerForJSDocTemplateTag(tp.parent) : tp.parent */ TODO
         /* TODO(BinaryExpression): host && getSymbolOfNode(host) */ TODO
    }
    getTypeListId := func(types /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): string */ TODO {
        result := ""
        if types {
            length := /* TODO(PropertyAccessExpression): types.length */ TODO
            i := 0
            /* TODO(WhileStatement): while (i < length) {                 const startId = types[i].id;                 let count = 1;                 while (i + count < length && types[i + count].id === startId + count) {                     count++;                 }                 if (result.length) {                     result += ",";                 }                 result += startId;                 if (count > 1) {                     result += ":" + count;                 }                 i += count;             } */
        }
         result
    }
    getAliasId := func(aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): string */ TODO {
         /* TODO(ConditionalExpression): aliasSymbol ? `@${getSymbolId(aliasSymbol)}` + (aliasTypeArguments ? `:${getTypeListId(aliasTypeArguments)}` : "") : "" */ TODO
    }
    getPropagatingFlagsOfTypes := func(types []Type, excludeKinds TypeFlags) ObjectFlags {
        var result ObjectFlags = 0
        /* TODO(ForOfStatement): for (const type of types) {             if (excludeKinds === undefined || !(type.flags & excludeKinds)) {                 result |= getObjectFlags(type);             }         } */
         /* TODO(BinaryExpression): result & ObjectFlags.PropagatingFlags */ TODO
    }
    tryCreateTypeReference := func(target GenericType, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) Type {
        if /* TODO(BinaryExpression): some(typeArguments) && target === emptyGenericType */ TODO {
             unknownType
        }
         createTypeReference(target, typeArguments)
    }
    createTypeReference := func(target GenericType, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) TypeReference {
        id := getTypeListId(typeArguments)
        type_ := /* TODO(PropertyAccessExpression): target.instantiations.get */ TODO(id)
        if /* TODO(PrefixUnaryExpression): !type */ TODO {
            /* TODO(ExpressionStatement): type = createObjectType(ObjectFlags.Reference, target.symbol) as TypeReference; */
            /* TODO(ExpressionStatement): target.instantiations.set(id, type); */
            /* TODO(ExpressionStatement): type.objectFlags |= typeArguments ? getPropagatingFlagsOfTypes(typeArguments) : 0; */
            /* TODO(ExpressionStatement): type.target = target; */
            /* TODO(ExpressionStatement): type.resolvedTypeArguments = typeArguments; */
        }
         type_
    }
    cloneTypeReference := func(source TypeReference) TypeReference {
        type_ := createTypeWithSymbol(/* TODO(PropertyAccessExpression): source.flags */ TODO, /* TODO(PropertyAccessExpression): source.symbol */ TODO) /* as */ /* TODO(TypeReference): TypeReference */
        /* TODO(ExpressionStatement): type.objectFlags = source.objectFlags; */
        /* TODO(ExpressionStatement): type.target = source.target; */
        /* TODO(ExpressionStatement): type.resolvedTypeArguments = source.resolvedTypeArguments; */
         type_
    }
    createDeferredTypeReference := func(target GenericType, node /* TODO(UnionType): TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) DeferredTypeReference {
        if /* TODO(PrefixUnaryExpression): !aliasSymbol */ TODO {
            /* TODO(ExpressionStatement): aliasSymbol = getAliasSymbolForTypeNode(node); */
            localAliasTypeArguments := getTypeArgumentsForAliasSymbol(aliasSymbol)
            /* TODO(ExpressionStatement): aliasTypeArguments = mapper ? instantiateTypes(localAliasTypeArguments, mapper) : localAliasTypeArguments; */
        }
        type_ := createObjectType(/* TODO(PropertyAccessExpression): ObjectFlags.Reference */ TODO, /* TODO(PropertyAccessExpression): target.symbol */ TODO) /* as */ /* TODO(TypeReference): DeferredTypeReference */
        /* TODO(ExpressionStatement): type.target = target; */
        /* TODO(ExpressionStatement): type.node = node; */
        /* TODO(ExpressionStatement): type.mapper = mapper; */
        /* TODO(ExpressionStatement): type.aliasSymbol = aliasSymbol; */
        /* TODO(ExpressionStatement): type.aliasTypeArguments = aliasTypeArguments; */
         type_
    }
    getTypeArguments := func(type_ TypeReference) []Type {
        if /* TODO(PrefixUnaryExpression): !type.resolvedTypeArguments */ TODO {
            if /* TODO(PrefixUnaryExpression): !pushTypeResolution(type, TypeSystemPropertyName.ResolvedTypeArguments) */ TODO {
                 /* TODO(BinaryExpression): concatenate(type.target.outerTypeParameters, type.target.localTypeParameters?.map(() => errorType)) || emptyArray */ TODO
            }
            node := /* TODO(PropertyAccessExpression): type.node */ TODO
            typeArguments := /* TODO(ConditionalExpression): !node ? emptyArray :                 node.kind === SyntaxKind.TypeReference ? concatenate(type.target.outerTypeParameters, getEffectiveTypeArguments(node, type.target.localTypeParameters!)) :                 node.kind === SyntaxKind.ArrayType ? [getTypeFromTypeNode(node.elementType)] :                 map(node.elements, getTypeFromTypeNode) */ TODO
            if popTypeResolution() {
                /* TODO(ExpressionStatement): type.resolvedTypeArguments ??= type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments; */
            } else {
                /* TODO(ExpressionStatement): type.resolvedTypeArguments ??= concatenate(type.target.outerTypeParameters, type.target.localTypeParameters?.map(() => errorType) || emptyArray); */
                /* TODO(ExpressionStatement): error(                     type.node || currentNode,                     type.target.symbol ? Diagnostics.Type_arguments_for_0_circularly_reference_themselves : Diagnostics.Tuple_type_arguments_circularly_reference_themselves,                     type.target.symbol && symbolToString(type.target.symbol),                 ); */
            }
        }
         /* TODO(PropertyAccessExpression): type.resolvedTypeArguments */ TODO
    }
    getTypeReferenceArity := func(type_ TypeReference) number {
         length(/* TODO(PropertyAccessExpression): type.target.typeParameters */ TODO)
    }
    getTypeFromClassOrInterfaceReference := func(node NodeWithTypeArguments, symbol Symbol) Type {
        type_ := getDeclaredTypeOfSymbol(getMergedSymbol(symbol)) /* as */ /* TODO(TypeReference): InterfaceType */
        typeParameters := /* TODO(PropertyAccessExpression): type.localTypeParameters */ TODO
        if typeParameters {
            numTypeArguments := length(/* TODO(PropertyAccessExpression): node.typeArguments */ TODO)
            minTypeArgumentCount := getMinTypeArgumentCount(typeParameters)
            isJs := isInJSFile(node)
            isJsImplicitAny := /* TODO(BinaryExpression): !noImplicitAny && isJs */ TODO
            if /* TODO(BinaryExpression): !isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) */ TODO {
                missingAugmentsTag := /* TODO(BinaryExpression): isJs && isExpressionWithTypeArguments(node) && !isJSDocAugmentsTag(node.parent) */ TODO
                diag := /* TODO(ConditionalExpression): minTypeArgumentCount === typeParameters.length ?                     missingAugmentsTag ?                         Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag :                         Diagnostics.Generic_type_0_requires_1_type_argument_s :                     missingAugmentsTag ?                     Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag :                     Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments */ TODO
                typeStr := typeToString(type_, undefined, /* TODO(PropertyAccessExpression): TypeFormatFlags.WriteArrayAsGenericType */ TODO)
                /* TODO(ExpressionStatement): error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length); */
                if /* TODO(PrefixUnaryExpression): !isJs */ TODO {
                     errorType
                }
            }
            if /* TODO(BinaryExpression): node.kind === SyntaxKind.TypeReference && isDeferredTypeReferenceNode(node as TypeReferenceNode, length(node.typeArguments) !== typeParameters.length) */ TODO {
                 createDeferredTypeReference(type_ /* as */ /* TODO(TypeReference): GenericType */, node /* as */ /* TODO(TypeReference): TypeReferenceNode */, undefined)
            }
            typeArguments := concatenate(/* TODO(PropertyAccessExpression): type.outerTypeParameters */ TODO, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs))
             createTypeReference(type_ /* as */ /* TODO(TypeReference): GenericType */, typeArguments)
        }
         /* TODO(ConditionalExpression): checkNoTypeArguments(node, symbol) ? type : errorType */ TODO
    }
    getTypeAliasInstantiation := func(symbol Symbol, typeArguments /* TODO(TypeOperator): readonly Type[] */ any, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
        type_ := getDeclaredTypeOfSymbol(symbol)
        if /* TODO(BinaryExpression): type === intrinsicMarkerType */ TODO {
            typeKind := /* TODO(PropertyAccessExpression): intrinsicTypeKinds.get */ TODO(/* TODO(PropertyAccessExpression): symbol.escapedName */ TODO /* as */ /* TODO(StringKeyword): string */)
            if /* TODO(BinaryExpression): typeKind !== undefined && typeArguments && typeArguments.length === 1 */ TODO {
                 /* TODO(ConditionalExpression): typeKind === IntrinsicTypeKind.NoInfer ? getNoInferType(typeArguments[0]) : getStringMappingType(symbol, typeArguments[0]) */ TODO
            }
        }
        links := getSymbolLinks(symbol)
        typeParameters := /* TODO(NonNullExpression): links.typeParameters! */ TODO
        id := /* TODO(BinaryExpression): getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
        instantiation := /* TODO(PropertyAccessExpression): links.instantiations!.get */ TODO(id)
        if /* TODO(PrefixUnaryExpression): !instantiation */ TODO {
            /* TODO(ExpressionStatement): links.instantiations!.set(id, instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments)); */
        }
         instantiation
    }
    getTypeFromTypeAliasReference := func(node NodeWithTypeArguments, symbol Symbol) Type {
        if /* TODO(BinaryExpression): getCheckFlags(symbol) & CheckFlags.Unresolved */ TODO {
            typeArguments := typeArgumentsFromTypeReferenceNode(node)
            id := getAliasId(symbol, typeArguments)
            errorType := /* TODO(PropertyAccessExpression): errorTypes.get */ TODO(id)
            if /* TODO(PrefixUnaryExpression): !errorType */ TODO {
                /* TODO(ExpressionStatement): errorType = createIntrinsicType(TypeFlags.Any, "error", /*objectFlags* / undefined, `alias ${id}`); */
                /* TODO(ExpressionStatement): errorType.aliasSymbol = symbol; */
                /* TODO(ExpressionStatement): errorType.aliasTypeArguments = typeArguments; */
                /* TODO(ExpressionStatement): errorTypes.set(id, errorType); */
            }
             errorType
        }
        type_ := getDeclaredTypeOfSymbol(symbol)
        typeParameters := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).typeParameters */ TODO
        if typeParameters {
            numTypeArguments := length(/* TODO(PropertyAccessExpression): node.typeArguments */ TODO)
            minTypeArgumentCount := getMinTypeArgumentCount(typeParameters)
            if /* TODO(BinaryExpression): numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length */ TODO {
                /* TODO(ExpressionStatement): error(                     node,                     minTypeArgumentCount === typeParameters.length ?                         Diagnostics.Generic_type_0_requires_1_type_argument_s :                         Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments,                     symbolToString(symbol),                     minTypeArgumentCount,                     typeParameters.length,                 ); */
                 errorType
            }
            aliasSymbol := getAliasSymbolForTypeNode(node)
            newAliasSymbol := /* TODO(ConditionalExpression): aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(aliasSymbol)) ? aliasSymbol : undefined */ TODO
            var aliasTypeArguments /* TODO(ArrayType): Type[] */ any
            if newAliasSymbol {
                /* TODO(ExpressionStatement): aliasTypeArguments = getTypeArgumentsForAliasSymbol(newAliasSymbol); */
            } else if isTypeReferenceType(node) {
                aliasSymbol := resolveTypeReferenceName(node, /* TODO(PropertyAccessExpression): SymbolFlags.Alias */ TODO, /* TODO(TrueKeyword): true */ TODO)
                if /* TODO(BinaryExpression): aliasSymbol && aliasSymbol !== unknownSymbol */ TODO {
                    resolved := resolveAlias(aliasSymbol)
                    if /* TODO(BinaryExpression): resolved && resolved.flags & SymbolFlags.TypeAlias */ TODO {
                        /* TODO(ExpressionStatement): newAliasSymbol = resolved; */
                        /* TODO(ExpressionStatement): aliasTypeArguments = typeArgumentsFromTypeReferenceNode(node) || (typeParameters ? [] : undefined); */
                    }
                }
            }
             getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, aliasTypeArguments)
        }
         /* TODO(ConditionalExpression): checkNoTypeArguments(node, symbol) ? type : errorType */ TODO
    }
    isLocalTypeAlias := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
        declaration := /* TODO(PropertyAccessExpression): symbol.declarations?.find */ TODO(isTypeAlias)
         /* TODO(PrefixUnaryExpression): !!(declaration && getContainingFunction(declaration)) */ TODO
    }
    getTypeReferenceName := func(node TypeReferenceType) *EntityNameOrEntityNameExpression {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.TypeReference:                 return node.typeName;             case SyntaxKind.ExpressionWithTypeArguments:                 // We only support expressions that are simple qualified names. For other                 // expressions this produces undefined.                 const expr = node.expression;                 if (isEntityNameExpression(expr)) {                     return expr;                 }                 // fall through;         } */
         undefined
    }
    getSymbolPath := func(symbol Symbol) string {
         /* TODO(ConditionalExpression): symbol.parent ? `${getSymbolPath(symbol.parent)}.${symbol.escapedName}` : symbol.escapedName as string */ TODO
    }
    getUnresolvedSymbolForEntityName := func(name EntityNameOrEntityNameExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
        identifier := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.right :             name.kind === SyntaxKind.PropertyAccessExpression ? name.name :             name */ TODO
        text := /* TODO(PropertyAccessExpression): identifier.escapedText */ TODO
        if text {
            parentSymbol := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? getUnresolvedSymbolForEntityName(name.left) :                 name.kind === SyntaxKind.PropertyAccessExpression ? getUnresolvedSymbolForEntityName(name.expression) :                 undefined */ TODO
            path := /* TODO(ConditionalExpression): parentSymbol ? `${getSymbolPath(parentSymbol)}.${text}` : text as string */ TODO
            result := /* TODO(PropertyAccessExpression): unresolvedSymbols.get */ TODO(path)
            if /* TODO(PrefixUnaryExpression): !result */ TODO {
                /* TODO(ExpressionStatement): unresolvedSymbols.set(path, result = createSymbol(SymbolFlags.TypeAlias, text, CheckFlags.Unresolved)); */
                /* TODO(ExpressionStatement): result.parent = parentSymbol; */
                /* TODO(ExpressionStatement): result.links.declaredType = unresolvedType; */
            }
             result
        }
         unknownSymbol
    }
    resolveTypeReferenceName := func(typeReference TypeReferenceType, meaning SymbolFlags, ignoreErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
        name := getTypeReferenceName(typeReference)
        if /* TODO(PrefixUnaryExpression): !name */ TODO {
             unknownSymbol
        }
        symbol := resolveEntityName(name, meaning, ignoreErrors)
         /* TODO(ConditionalExpression): symbol && symbol !== unknownSymbol ? symbol :             ignoreErrors ? unknownSymbol : getUnresolvedSymbolForEntityName(name) */ TODO
    }
    getTypeReferenceType := func(node NodeWithTypeArguments, symbol Symbol) Type {
        if /* TODO(BinaryExpression): symbol === unknownSymbol */ TODO {
             errorType
        }
        /* TODO(ExpressionStatement): symbol = getExpandoSymbol(symbol) || symbol; */
        if /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface) */ TODO {
             getTypeFromClassOrInterfaceReference(node, symbol)
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeAlias */ TODO {
             getTypeFromTypeAliasReference(node, symbol)
        }
        res := tryGetDeclaredTypeOfSymbol(symbol)
        if res {
             /* TODO(ConditionalExpression): checkNoTypeArguments(node, symbol) ? getRegularTypeOfLiteralType(res) : errorType */ TODO
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Value && isJSDocTypeReference(node) */ TODO {
            jsdocType := getTypeFromJSDocValueReference(node, symbol)
            if jsdocType {
                 jsdocType
            } else {
                /* TODO(ExpressionStatement): resolveTypeReferenceName(node, SymbolFlags.Type); */
                 getTypeOfSymbol(symbol)
            }
        }
         errorType
    }
    getTypeFromJSDocValueReference := func(node NodeWithTypeArguments, symbol Symbol) *Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedJSDocType */ TODO {
            valueType := getTypeOfSymbol(symbol)
            typeType := valueType
            if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
                isImportTypeWithQualifier := /* TODO(BinaryExpression): node.kind === SyntaxKind.ImportType && (node as ImportTypeNode).qualifier */ TODO
                if /* TODO(BinaryExpression): valueType.symbol && valueType.symbol !== symbol && isImportTypeWithQualifier */ TODO {
                    /* TODO(ExpressionStatement): typeType = getTypeReferenceType(node, valueType.symbol); */
                }
            }
            /* TODO(ExpressionStatement): links.resolvedJSDocType = typeType; */
        }
         /* TODO(PropertyAccessExpression): links.resolvedJSDocType */ TODO
    }
    getNoInferType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): isNoInferTargetType(type) ? getOrCreateSubstitutionType(type, unknownType) : type */ TODO
    }
    isNoInferTargetType := func(type_ Type) bool {
         /* TODO(PrefixUnaryExpression): !!(type.flags & TypeFlags.UnionOrIntersection && some((type as UnionOrIntersectionType).types, isNoInferTargetType) ||             type.flags & TypeFlags.Substitution && !isNoInferType(type) && isNoInferTargetType((type as SubstitutionType).baseType) ||             type.flags & TypeFlags.Object && !isEmptyAnonymousObjectType(type) ||             type.flags & (TypeFlags.Instantiable & ~TypeFlags.Substitution) && !isPatternLiteralType(type)) */ TODO
    }
    isNoInferType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(type.flags & TypeFlags.Substitution && (type as SubstitutionType).constraint.flags & TypeFlags.Unknown) */ TODO
    }
    getSubstitutionType := func(baseType Type, constraint Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): constraint.flags & TypeFlags.AnyOrUnknown || constraint === baseType || baseType.flags & TypeFlags.Any ?             baseType :             getOrCreateSubstitutionType(baseType, constraint) */ TODO
    }
    getOrCreateSubstitutionType := func(baseType Type, constraint Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SubstitutionType */ TODO {
        id := /* TODO(TemplateExpression): `${getTypeId(baseType)}>${getTypeId(constraint)}` */ TODO
        cached := /* TODO(PropertyAccessExpression): substitutionTypes.get */ TODO(id)
        if cached {
             cached
        }
        result := createType(/* TODO(PropertyAccessExpression): TypeFlags.Substitution */ TODO) /* as */ /* TODO(TypeReference): SubstitutionType */
        /* TODO(ExpressionStatement): result.baseType = baseType; */
        /* TODO(ExpressionStatement): result.constraint = constraint; */
        /* TODO(ExpressionStatement): substitutionTypes.set(id, result); */
         result
    }
    getSubstitutionIntersection := func(substitutionType SubstitutionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): isNoInferType(substitutionType) ? substitutionType.baseType : getIntersectionType([substitutionType.constraint, substitutionType.baseType]) */ TODO
    }
    isUnaryTupleTypeNode := func(node TypeNode) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): node.kind === SyntaxKind.TupleType && (node as TupleTypeNode).elements.length === 1 */ TODO
    }
    getImpliedConstraint := func(type_ Type, checkNode TypeNode, extendsNode TypeNode) *Type {
         /* TODO(ConditionalExpression): isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode) ? getImpliedConstraint(type, (checkNode as TupleTypeNode).elements[0], (extendsNode as TupleTypeNode).elements[0]) :             getActualTypeVariable(getTypeFromTypeNode(checkNode)) === getActualTypeVariable(type) ? getTypeFromTypeNode(extendsNode) :             undefined */ TODO
    }
    getConditionalFlowTypeOfType := func(type_ Type, node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        var constraints /* TODO(ArrayType): Type[] */ any
        covariant := /* TODO(TrueKeyword): true */ TODO
        /* TODO(WhileStatement): while (node && !isStatement(node) && node.kind !== SyntaxKind.JSDoc) {             const parent = node.parent;             // only consider variance flipped by parameter locations - `keyof` types would usually be considered variance inverting, but             // often get used in indexed accesses where they behave sortof invariantly, but our checking is lax             if (parent.kind === SyntaxKind.Parameter) {                 covariant = !covariant;             }             // Always substitute on type parameters, regardless of variance, since even             // in contravariant positions, they may rely on substituted constraints to be valid             if ((covariant || type.flags & TypeFlags.TypeVariable) && parent.kind === SyntaxKind.ConditionalType && node === (parent as ConditionalTypeNode).trueType) {                 const constraint = getImpliedConstraint(type, (parent as ConditionalTypeNode).checkType, (parent as ConditionalTypeNode).extendsType);                 if (constraint) {                     constraints = append(constraints, constraint);                 }             }             // Given a homomorphic mapped type { [K in keyof T]: XXX }, where T is constrained to an array or tuple type, in the             // template type XXX, K has an added constraint of number | `${number}`.             else if (type.flags & TypeFlags.TypeParameter && parent.kind === SyntaxKind.MappedType && !(parent as MappedTypeNode).nameType && node === (parent as MappedTypeNode).type) {                 const mappedType = getTypeFromTypeNode(parent as TypeNode) as MappedType;                 if (getTypeParameterFromMappedType(mappedType) === getActualTypeVariable(type)) {                     const typeParameter = getHomomorphicTypeVariable(mappedType);                     if (typeParameter) {                         const constraint = getConstraintOfTypeParameter(typeParameter);                         if (constraint && everyType(constraint, isArrayOrTupleType)) {                             constraints = append(constraints, getUnionType([numberType, numericStringType]));                         }                     }                 }             }             node = parent;         } */
         /* TODO(ConditionalExpression): constraints ? getSubstitutionType(type, getIntersectionType(constraints)) : type */ TODO
    }
    isJSDocTypeReference := func(node Node) /* TODO(TypePredicate): node is TypeReferenceNode */ TODO {
         /* TODO(BinaryExpression): !!(node.flags & NodeFlags.JSDoc) && (node.kind === SyntaxKind.TypeReference || node.kind === SyntaxKind.ImportType) */ TODO
    }
    checkNoTypeArguments := func(node NodeWithTypeArguments, symbol Symbol) /* TODO(undefined): boolean */ TODO {
        if /* TODO(PropertyAccessExpression): node.typeArguments */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.Type_0_is_not_generic, symbol ? symbolToString(symbol) : (node as TypeReferenceNode).typeName ? declarationNameToString((node as TypeReferenceNode).typeName) : anon); */
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(TrueKeyword): true */ TODO
    }
    getIntendedTypeFromJSDocTypeReference := func(node TypeReferenceNode) *Type {
        if isIdentifier(/* TODO(PropertyAccessExpression): node.typeName */ TODO) {
            typeArgs := /* TODO(PropertyAccessExpression): node.typeArguments */ TODO
            /* TODO(SwitchStatement): switch (node.typeName.escapedText) {                 case "String":                     checkNoTypeArguments(node);                     return stringType;                 case "Number":                     checkNoTypeArguments(node);                     return numberType;                 case "Boolean":                     checkNoTypeArguments(node);                     return booleanType;                 case "Void":                     checkNoTypeArguments(node);                     return voidType;                 case "Undefined":                     checkNoTypeArguments(node);                     return undefinedType;                 case "Null":                     checkNoTypeArguments(node);                     return nullType;                 case "Function":                 case "function":                     checkNoTypeArguments(node);                     return globalFunctionType;                 case "array":                     return (!typeArgs || !typeArgs.length) && !noImplicitAny ? anyArrayType : undefined;                 case "promise":                     return (!typeArgs || !typeArgs.length) && !noImplicitAny ? createPromiseType(anyType) : undefined;                 case "Object":                     if (typeArgs && typeArgs.length === 2) {                         if (isJSDocIndexSignature(node)) {                             const indexed = getTypeFromTypeNode(typeArgs[0]);                             const target = getTypeFromTypeNode(typeArgs[1]);                             const indexInfo = indexed === stringType || indexed === numberType ? [createIndexInfo(indexed, target, /*isReadonly* / false)] : emptyArray;                             return createAnonymousType(/*symbol* / undefined, emptySymbols, emptyArray, emptyArray, indexInfo);                         }                         return anyType;                     }                     checkNoTypeArguments(node);                     return !noImplicitAny ? anyType : undefined;             } */
        }
    }
    getTypeFromJSDocNullableTypeNode := func(node JSDocNullableType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        type_ := getTypeFromTypeNode(/* TODO(PropertyAccessExpression): node.type */ TODO)
         /* TODO(ConditionalExpression): strictNullChecks ? getNullableType(type, TypeFlags.Null) : type */ TODO
    }
    getTypeFromTypeReference := func(node TypeReferenceType) Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            if /* TODO(BinaryExpression): isConstTypeReference(node) && isAssertionExpression(node.parent) */ TODO {
                /* TODO(ExpressionStatement): links.resolvedSymbol = unknownSymbol; */
                 /* TODO(BinaryExpression): links.resolvedType = checkExpressionCached(node.parent.expression) */ TODO
            }
            var symbol *Symbol
            var type_ *Type
            meaning := /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO
            if isJSDocTypeReference(node) {
                /* TODO(ExpressionStatement): type = getIntendedTypeFromJSDocTypeReference(node); */
                if /* TODO(PrefixUnaryExpression): !type */ TODO {
                    /* TODO(ExpressionStatement): symbol = resolveTypeReferenceName(node, meaning, /*ignoreErrors* / true); */
                    if /* TODO(BinaryExpression): symbol === unknownSymbol */ TODO {
                        /* TODO(ExpressionStatement): symbol = resolveTypeReferenceName(node, meaning | SymbolFlags.Value); */
                    } else {
                        /* TODO(ExpressionStatement): resolveTypeReferenceName(node, meaning); */
                    }
                    /* TODO(ExpressionStatement): type = getTypeReferenceType(node, symbol); */
                }
            }
            if /* TODO(PrefixUnaryExpression): !type */ TODO {
                /* TODO(ExpressionStatement): symbol = resolveTypeReferenceName(node, meaning); */
                /* TODO(ExpressionStatement): type = getTypeReferenceType(node, symbol); */
            }
            /* TODO(ExpressionStatement): links.resolvedSymbol = symbol; */
            /* TODO(ExpressionStatement): links.resolvedType = type; */
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    typeArgumentsFromTypeReferenceNode := func(node NodeWithTypeArguments) /* TODO(ArrayType): Type[] */ any {
         map_(/* TODO(PropertyAccessExpression): node.typeArguments */ TODO, getTypeFromTypeNode)
    }
    getTypeFromTypeQueryNode := func(node TypeQueryNode) Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            type_ := checkExpressionWithTypeArguments(node)
            /* TODO(ExpressionStatement): links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(type)); */
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    getTypeOfGlobalSymbol := func(symbol *Symbol, arity number) ObjectType {
        getTypeDeclaration := func(symbol Symbol) Declaration {
            declarations := /* TODO(PropertyAccessExpression): symbol.declarations */ TODO
            if declarations {
                /* TODO(ForOfStatement): for (const declaration of declarations) {                     switch (declaration.kind) {                         case SyntaxKind.ClassDeclaration:                         case SyntaxKind.InterfaceDeclaration:                         case SyntaxKind.EnumDeclaration:                             return declaration;                     }                 } */
            }
        }
        if /* TODO(PrefixUnaryExpression): !symbol */ TODO {
             /* TODO(ConditionalExpression): arity ? emptyGenericType : emptyObjectType */ TODO
        }
        type_ := getDeclaredTypeOfSymbol(symbol)
        if /* TODO(PrefixUnaryExpression): !(type.flags & TypeFlags.Object) */ TODO {
            /* TODO(ExpressionStatement): error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_be_a_class_or_interface_type, symbolName(symbol)); */
             /* TODO(ConditionalExpression): arity ? emptyGenericType : emptyObjectType */ TODO
        }
        if /* TODO(BinaryExpression): length((type as InterfaceType).typeParameters) !== arity */ TODO {
            /* TODO(ExpressionStatement): error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity); */
             /* TODO(ConditionalExpression): arity ? emptyGenericType : emptyObjectType */ TODO
        }
         type_ /* as */ /* TODO(TypeReference): ObjectType */
    }
    getGlobalValueSymbol := func(name __String, reportErrors bool) *Symbol {
         getGlobalSymbol(name, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO, /* TODO(ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_value_0 : undefined */ TODO)
    }
    getGlobalTypeSymbol := func(name __String, reportErrors bool) *Symbol {
         getGlobalSymbol(name, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO, /* TODO(ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined */ TODO)
    }
    getGlobalTypeAliasSymbol := func(name __String, arity number, reportErrors bool) *Symbol {
        symbol := getGlobalSymbol(name, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO, /* TODO(ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined */ TODO)
        if symbol {
            /* TODO(ExpressionStatement): getDeclaredTypeOfSymbol(symbol); */
            if /* TODO(BinaryExpression): length(getSymbolLinks(symbol).typeParameters) !== arity */ TODO {
                decl := /* TODO(BinaryExpression): symbol.declarations && find(symbol.declarations, isTypeAliasDeclaration) */ TODO
                /* TODO(ExpressionStatement): error(decl, Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity); */
                 undefined
            }
        }
         symbol
    }
    getGlobalSymbol := func(name __String, meaning SymbolFlags, diagnostic *DiagnosticMessage) *Symbol {
         resolveName(undefined, name, meaning, diagnostic, /* TODO(FalseKeyword): false */ TODO, /* TODO(FalseKeyword): false */ TODO)
    }
    // OVERLOAD: getGlobalType := func(name __String, arity /* TODO(LiteralType): 0 */ TODO, reportErrors /* TODO(LiteralType): true */ TODO) ObjectType
    // OVERLOAD: getGlobalType := func(name __String, arity /* TODO(LiteralType): 0 */ TODO, reportErrors bool) *ObjectType
    // OVERLOAD: getGlobalType := func(name __String, arity number, reportErrors /* TODO(LiteralType): true */ TODO) GenericType
    // OVERLOAD: getGlobalType := func(name __String, arity number, reportErrors bool) *GenericType
    getGlobalType := func(name __String, arity number, reportErrors bool) *ObjectType {
        symbol := getGlobalTypeSymbol(name, reportErrors)
         /* TODO(ConditionalExpression): symbol || reportErrors ? getTypeOfGlobalSymbol(symbol, arity) : undefined */ TODO
    }
    // OVERLOAD: getGlobalBuiltinTypes := func(typeNames []string, arity /* TODO(LiteralType): 0 */ TODO) []ObjectType
    // OVERLOAD: getGlobalBuiltinTypes := func(typeNames []string, arity number) []GenericType
    getGlobalBuiltinTypes := func(typeNames []string, arity number) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
        var types /* TODO(ArrayType): Type[] */ any
        /* TODO(ForOfStatement): for (const typeName of typeNames) {             types = append(types, getGlobalType(typeName as __String, arity, /*reportErrors* / false));         } */
         /* TODO(BinaryExpression): types ?? emptyArray */ TODO
    }
    getGlobalTypedPropertyDescriptorType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): deferredGlobalTypedPropertyDescriptorType ||= getGlobalType("TypedPropertyDescriptor" as __String, /*arity* / 1, /*reportErrors* / true) || emptyGenericType */ TODO
    }
    getGlobalTemplateStringsArrayType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
         /* TODO(BinaryExpression): deferredGlobalTemplateStringsArrayType ||= getGlobalType("TemplateStringsArray" as __String, /*arity* / 0, /*reportErrors* / true) || emptyObjectType */ TODO
    }
    getGlobalImportMetaType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
         /* TODO(BinaryExpression): deferredGlobalImportMetaType ||= getGlobalType("ImportMeta" as __String, /*arity* / 0, /*reportErrors* / true) || emptyObjectType */ TODO
    }
    getGlobalImportMetaExpressionType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
        if /* TODO(PrefixUnaryExpression): !deferredGlobalImportMetaExpressionType */ TODO {
            symbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.None */ TODO, "ImportMetaExpression" /* as */ /* TODO(TypeReference): __String */)
            importMetaType := getGlobalImportMetaType()
            metaPropertySymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "meta" /* as */ /* TODO(TypeReference): __String */, /* TODO(PropertyAccessExpression): CheckFlags.Readonly */ TODO)
            /* TODO(ExpressionStatement): metaPropertySymbol.parent = symbol; */
            /* TODO(ExpressionStatement): metaPropertySymbol.links.type = importMetaType; */
            members := createSymbolTable(/* TODO(ArrayLiteralExpression): [metaPropertySymbol] */ TODO)
            /* TODO(ExpressionStatement): symbol.members = members; */
            /* TODO(ExpressionStatement): deferredGlobalImportMetaExpressionType = createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray); */
        }
         deferredGlobalImportMetaExpressionType
    }
    getGlobalImportCallOptionsType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalImportCallOptionsType ||= getGlobalType("ImportCallOptions" as __String, /*arity* / 0, reportErrors)) || emptyObjectType */ TODO
    }
    getGlobalImportAttributesType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalImportAttributesType ||= getGlobalType("ImportAttributes" as __String, /*arity* / 0, reportErrors)) || emptyObjectType */ TODO
    }
    getGlobalESSymbolConstructorSymbol := func(reportErrors bool) *Symbol {
         /* TODO(BinaryExpression): deferredGlobalESSymbolConstructorSymbol ||= getGlobalValueSymbol("Symbol" as __String, reportErrors) */ TODO
    }
    getGlobalESSymbolConstructorTypeSymbol := func(reportErrors bool) *Symbol {
         /* TODO(BinaryExpression): deferredGlobalESSymbolConstructorTypeSymbol ||= getGlobalTypeSymbol("SymbolConstructor" as __String, reportErrors) */ TODO
    }
    getGlobalESSymbolType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalESSymbolType ||= getGlobalType("Symbol" as __String, /*arity* / 0, /*reportErrors* / false)) || emptyObjectType */ TODO
    }
    getGlobalPromiseType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalPromiseType ||= getGlobalType("Promise" as __String, /*arity* / 1, reportErrors)) || emptyGenericType */ TODO
    }
    getGlobalPromiseLikeType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalPromiseLikeType ||= getGlobalType("PromiseLike" as __String, /*arity* / 1, reportErrors)) || emptyGenericType */ TODO
    }
    getGlobalPromiseConstructorSymbol := func(reportErrors bool) *Symbol {
         /* TODO(BinaryExpression): deferredGlobalPromiseConstructorSymbol ||= getGlobalValueSymbol("Promise" as __String, reportErrors) */ TODO
    }
    getGlobalPromiseConstructorLikeType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalPromiseConstructorLikeType ||= getGlobalType("PromiseConstructorLike" as __String, /*arity* / 0, reportErrors)) || emptyObjectType */ TODO
    }
    getGlobalAsyncIterableType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalAsyncIterableType ||= getGlobalType("AsyncIterable" as __String, /*arity* / 3, reportErrors)) || emptyGenericType */ TODO
    }
    getGlobalAsyncIteratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalAsyncIteratorType ||= getGlobalType("AsyncIterator" as __String, /*arity* / 3, reportErrors)) || emptyGenericType */ TODO
    }
    getGlobalAsyncIterableIteratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalAsyncIterableIteratorType ||= getGlobalType("AsyncIterableIterator" as __String, /*arity* / 3, reportErrors)) || emptyGenericType */ TODO
    }
    getGlobalBuiltinAsyncIteratorTypes := func() /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType[] */ TODO {
         /* TODO(BinaryExpression): deferredGlobalBuiltinAsyncIteratorTypes ??= getGlobalBuiltinTypes(["ReadableStreamAsyncIterator"], 1) */ TODO
    }
    getGlobalAsyncIteratorObjectType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalAsyncIteratorObjectType ||= getGlobalType("AsyncIteratorObject" as __String, /*arity* / 3, reportErrors)) || emptyGenericType */ TODO
    }
    getGlobalAsyncGeneratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalAsyncGeneratorType ||= getGlobalType("AsyncGenerator" as __String, /*arity* / 3, reportErrors)) || emptyGenericType */ TODO
    }
    getGlobalIterableType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalIterableType ||= getGlobalType("Iterable" as __String, /*arity* / 3, reportErrors)) || emptyGenericType */ TODO
    }
    getGlobalIteratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalIteratorType ||= getGlobalType("Iterator" as __String, /*arity* / 3, reportErrors)) || emptyGenericType */ TODO
    }
    getGlobalIterableIteratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalIterableIteratorType ||= getGlobalType("IterableIterator" as __String, /*arity* / 3, reportErrors)) || emptyGenericType */ TODO
    }
    getBuiltinIteratorReturnType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
         /* TODO(ConditionalExpression): strictBuiltinIteratorReturn ? undefinedType : anyType */ TODO
    }
    getGlobalBuiltinIteratorTypes := func() /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType[] */ TODO {
         /* TODO(BinaryExpression): deferredGlobalBuiltinIteratorTypes ??= getGlobalBuiltinTypes(["ArrayIterator", "MapIterator", "SetIterator", "StringIterator"], 1) */ TODO
    }
    getGlobalIteratorObjectType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalIteratorObjectType ||= getGlobalType("IteratorObject" as __String, /*arity* / 3, reportErrors)) || emptyGenericType */ TODO
    }
    getGlobalGeneratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalGeneratorType ||= getGlobalType("Generator" as __String, /*arity* / 3, reportErrors)) || emptyGenericType */ TODO
    }
    getGlobalIteratorYieldResultType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalIteratorYieldResultType ||= getGlobalType("IteratorYieldResult" as __String, /*arity* / 1, reportErrors)) || emptyGenericType */ TODO
    }
    getGlobalIteratorReturnResultType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalIteratorReturnResultType ||= getGlobalType("IteratorReturnResult" as __String, /*arity* / 1, reportErrors)) || emptyGenericType */ TODO
    }
    getGlobalDisposableType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalDisposableType ||= getGlobalType("Disposable" as __String, /*arity* / 0, reportErrors)) || emptyObjectType */ TODO
    }
    getGlobalAsyncDisposableType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalAsyncDisposableType ||= getGlobalType("AsyncDisposable" as __String, /*arity* / 0, reportErrors)) || emptyObjectType */ TODO
    }
    getGlobalTypeOrUndefined := func(name __String, arity /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) *ObjectType {
        symbol := getGlobalSymbol(name, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO, undefined)
         /* TODO(BinaryExpression): symbol && getTypeOfGlobalSymbol(symbol, arity) as GenericType */ TODO
    }
    getGlobalExtractSymbol := func() *Symbol {
        /* TODO(ExpressionStatement): deferredGlobalExtractSymbol ||= getGlobalTypeAliasSymbol("Extract" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol; */
         /* TODO(ConditionalExpression): deferredGlobalExtractSymbol === unknownSymbol ? undefined : deferredGlobalExtractSymbol */ TODO
    }
    getGlobalOmitSymbol := func() *Symbol {
        /* TODO(ExpressionStatement): deferredGlobalOmitSymbol ||= getGlobalTypeAliasSymbol("Omit" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol; */
         /* TODO(ConditionalExpression): deferredGlobalOmitSymbol === unknownSymbol ? undefined : deferredGlobalOmitSymbol */ TODO
    }
    getGlobalAwaitedSymbol := func(reportErrors bool) *Symbol {
        /* TODO(ExpressionStatement): deferredGlobalAwaitedSymbol ||= getGlobalTypeAliasSymbol("Awaited" as __String, /*arity* / 1, reportErrors) || (reportErrors ? unknownSymbol : undefined); */
         /* TODO(ConditionalExpression): deferredGlobalAwaitedSymbol === unknownSymbol ? undefined : deferredGlobalAwaitedSymbol */ TODO
    }
    getGlobalBigIntType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalBigIntType ||= getGlobalType("BigInt" as __String, /*arity* / 0, /*reportErrors* / false)) || emptyObjectType */ TODO
    }
    getGlobalClassDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalClassDecoratorContextType ??= getGlobalType("ClassDecoratorContext" as __String, /*arity* / 1, reportErrors)) ?? emptyGenericType */ TODO
    }
    getGlobalClassMethodDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalClassMethodDecoratorContextType ??= getGlobalType("ClassMethodDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
    }
    getGlobalClassGetterDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalClassGetterDecoratorContextType ??= getGlobalType("ClassGetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
    }
    getGlobalClassSetterDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalClassSetterDecoratorContextType ??= getGlobalType("ClassSetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
    }
    getGlobalClassAccessorDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalClassAccessorDecoratorContextType ??= getGlobalType("ClassAccessorDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
    }
    getGlobalClassAccessorDecoratorTargetType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalClassAccessorDecoratorTargetType ??= getGlobalType("ClassAccessorDecoratorTarget" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
    }
    getGlobalClassAccessorDecoratorResultType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalClassAccessorDecoratorResultType ??= getGlobalType("ClassAccessorDecoratorResult" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
    }
    getGlobalClassFieldDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
         /* TODO(BinaryExpression): (deferredGlobalClassFieldDecoratorContextType ??= getGlobalType("ClassFieldDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
    }
    getGlobalNaNSymbol := func() *Symbol {
         /* TODO(ParenthesizedExpression): (deferredGlobalNaNSymbol ||= getGlobalValueSymbol("NaN" as __String, /*reportErrors* / false)) */ TODO
    }
    getGlobalRecordSymbol := func() *Symbol {
        /* TODO(ExpressionStatement): deferredGlobalRecordSymbol ||= getGlobalTypeAliasSymbol("Record" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol; */
         /* TODO(ConditionalExpression): deferredGlobalRecordSymbol === unknownSymbol ? undefined : deferredGlobalRecordSymbol */ TODO
    }
    createTypeFromGenericGlobalType := func(genericGlobalType GenericType, typeArguments []Type) ObjectType {
         /* TODO(ConditionalExpression): genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, typeArguments) : emptyObjectType */ TODO
    }
    createTypedPropertyDescriptorType := func(propertyType Type) Type {
         createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType(), /* TODO(ArrayLiteralExpression): [propertyType] */ TODO)
    }
    createIterableType := func(iteratedType Type) Type {
         createTypeFromGenericGlobalType(getGlobalIterableType(/* TODO(TrueKeyword): true */ TODO), /* TODO(ArrayLiteralExpression): [iteratedType, voidType, undefinedType] */ TODO)
    }
    createArrayType := func(elementType Type, readonly bool) ObjectType {
         createTypeFromGenericGlobalType(/* TODO(ConditionalExpression): readonly ? globalReadonlyArrayType : globalArrayType */ TODO, /* TODO(ArrayLiteralExpression): [elementType] */ TODO)
    }
    getTupleElementFlags := func(node TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Required | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Optional | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Rest | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Variadic */ TODO {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.OptionalType:                 return ElementFlags.Optional;             case SyntaxKind.RestType:                 return getRestTypeElementFlags(node as RestTypeNode);             case SyntaxKind.NamedTupleMember:                 return (node as NamedTupleMember).questionToken ? ElementFlags.Optional :                     (node as NamedTupleMember).dotDotDotToken ? getRestTypeElementFlags(node as NamedTupleMember) :                     ElementFlags.Required;             default:                 return ElementFlags.Required;         } */
    }
    getRestTypeElementFlags := func(node /* TODO(UnionType): RestTypeNode | NamedTupleMember */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Rest | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Variadic */ TODO {
         /* TODO(ConditionalExpression): getArrayElementTypeNode(node.type) ? ElementFlags.Rest : ElementFlags.Variadic */ TODO
    }
    getArrayOrTupleTargetType := func(node /* TODO(UnionType): ArrayTypeNode | TupleTypeNode */ any) GenericType {
        readonly := isReadonlyTypeOperator(/* TODO(PropertyAccessExpression): node.parent */ TODO)
        elementType := getArrayElementTypeNode(node)
        if elementType {
             /* TODO(ConditionalExpression): readonly ? globalReadonlyArrayType : globalArrayType */ TODO
        }
        elementFlags := map_(/* TODO(PropertyAccessExpression): (node as TupleTypeNode).elements */ TODO, getTupleElementFlags)
         getTupleTargetType(elementFlags, readonly, map_(/* TODO(PropertyAccessExpression): (node as TupleTypeNode).elements */ TODO, memberIfLabeledElementDeclaration))
    }
    memberIfLabeledElementDeclaration := func(member Node) /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any {
         /* TODO(ConditionalExpression): isNamedTupleMember(member) || isParameter(member) ? member : undefined */ TODO
    }
    isDeferredTypeReferenceNode := func(node /* TODO(UnionType): TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, hasDefaultTypeArguments bool) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && (                     node.kind === SyntaxKind.ArrayType ? mayResolveTypeAlias(node.elementType) :                         node.kind === SyntaxKind.TupleType ? some(node.elements, mayResolveTypeAlias) :                         hasDefaultTypeArguments || some(node.typeArguments, mayResolveTypeAlias)                 ) */ TODO
    }
    isResolvedByTypeAlias := func(node Node) bool {
        parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
        /* TODO(SwitchStatement): switch (parent.kind) {             case SyntaxKind.ParenthesizedType:             case SyntaxKind.NamedTupleMember:             case SyntaxKind.TypeReference:             case SyntaxKind.UnionType:             case SyntaxKind.IntersectionType:             case SyntaxKind.IndexedAccessType:             case SyntaxKind.ConditionalType:             case SyntaxKind.TypeOperator:             case SyntaxKind.ArrayType:             case SyntaxKind.TupleType:                 return isResolvedByTypeAlias(parent);             case SyntaxKind.TypeAliasDeclaration:                 return true;         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    mayResolveTypeAlias := func(node Node) bool {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.TypeReference:                 return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(node as TypeReferenceNode, SymbolFlags.Type).flags & SymbolFlags.TypeAlias);             case SyntaxKind.TypeQuery:                 return true;             case SyntaxKind.TypeOperator:                 return (node as TypeOperatorNode).operator !== SyntaxKind.UniqueKeyword && mayResolveTypeAlias((node as TypeOperatorNode).type);             case SyntaxKind.ParenthesizedType:             case SyntaxKind.OptionalType:             case SyntaxKind.NamedTupleMember:             case SyntaxKind.JSDocOptionalType:             case SyntaxKind.JSDocNullableType:             case SyntaxKind.JSDocNonNullableType:             case SyntaxKind.JSDocTypeExpression:                 return mayResolveTypeAlias((node as ParenthesizedTypeNode | OptionalTypeNode | JSDocTypeReferencingNode | NamedTupleMember).type);             case SyntaxKind.RestType:                 return (node as RestTypeNode).type.kind !== SyntaxKind.ArrayType || mayResolveTypeAlias(((node as RestTypeNode).type as ArrayTypeNode).elementType);             case SyntaxKind.UnionType:             case SyntaxKind.IntersectionType:                 return some((node as UnionOrIntersectionTypeNode).types, mayResolveTypeAlias);             case SyntaxKind.IndexedAccessType:                 return mayResolveTypeAlias((node as IndexedAccessTypeNode).objectType) || mayResolveTypeAlias((node as IndexedAccessTypeNode).indexType);             case SyntaxKind.ConditionalType:                 return mayResolveTypeAlias((node as ConditionalTypeNode).checkType) || mayResolveTypeAlias((node as ConditionalTypeNode).extendsType) ||                     mayResolveTypeAlias((node as ConditionalTypeNode).trueType) || mayResolveTypeAlias((node as ConditionalTypeNode).falseType);         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    getTypeFromArrayOrTupleTypeNode := func(node /* TODO(UnionType): ArrayTypeNode | TupleTypeNode */ any) Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            target := getArrayOrTupleTargetType(node)
            if /* TODO(BinaryExpression): target === emptyGenericType */ TODO {
                /* TODO(ExpressionStatement): links.resolvedType = emptyObjectType; */
            } else if /* TODO(BinaryExpression): !(node.kind === SyntaxKind.TupleType && some(node.elements, e => !!(getTupleElementFlags(e) & ElementFlags.Variadic))) && isDeferredTypeReferenceNode(node) */ TODO {
                /* TODO(ExpressionStatement): links.resolvedType = node.kind === SyntaxKind.TupleType && node.elements.length === 0 ? target :                     createDeferredTypeReference(target, node, /*mapper* / undefined); */
            } else {
                elementTypes := /* TODO(ConditionalExpression): node.kind === SyntaxKind.ArrayType ? [getTypeFromTypeNode(node.elementType)] : map(node.elements, getTypeFromTypeNode) */ TODO
                /* TODO(ExpressionStatement): links.resolvedType = createNormalizedTypeReference(target, elementTypes); */
            }
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    isReadonlyTypeOperator := func(node Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isTypeOperatorNode(node) && node.operator === SyntaxKind.ReadonlyKeyword */ TODO
    }
    createTupleType := func(elementTypes []Type, elementFlags []ElementFlags, readonly /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, namedMemberDeclarations []/* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any /* = */ /* TODO(ArrayLiteralExpression): [] */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        tupleTarget := getTupleTargetType(/* TODO(BinaryExpression): elementFlags || map(elementTypes, _ => ElementFlags.Required) */ TODO, readonly, namedMemberDeclarations)
         /* TODO(ConditionalExpression): tupleTarget === emptyGenericType ? emptyObjectType :             elementTypes.length ? createNormalizedTypeReference(tupleTarget, elementTypes) :             tupleTarget */ TODO
    }
    getTupleTargetType := func(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations []/* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) GenericType {
        if /* TODO(BinaryExpression): elementFlags.length === 1 && elementFlags[0] & ElementFlags.Rest */ TODO {
             /* TODO(ConditionalExpression): readonly ? globalReadonlyArrayType : globalArrayType */ TODO
        }
        key := /* TODO(BinaryExpression): map(elementFlags, f => f & ElementFlags.Required ? "#" : f & ElementFlags.Optional ? "?" : f & ElementFlags.Rest ? "." : "*").join() +             (readonly ? "R" : "") +             (some(namedMemberDeclarations, node => !!node) ? "," + map(namedMemberDeclarations, node => node ? getNodeId(node) : "_").join(",") : "") */ TODO
        type_ := /* TODO(PropertyAccessExpression): tupleTypes.get */ TODO(key)
        if /* TODO(PrefixUnaryExpression): !type */ TODO {
            /* TODO(ExpressionStatement): tupleTypes.set(key, type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations)); */
        }
         type_
    }
    createTupleTargetType := func(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations []/* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) TupleType {
        arity := /* TODO(PropertyAccessExpression): elementFlags.length */ TODO
        minLength := countWhere(elementFlags, /* TODO(ArrowFunction): f => !!(f & (ElementFlags.Required | ElementFlags.Variadic)) */ TODO)
        var typeParameters /* TODO(ArrayType): TypeParameter[] */ any
        var properties []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
        combinedFlags := 0 /* as */ /* TODO(TypeReference): ElementFlags */
        if arity {
            /* TODO(ExpressionStatement): typeParameters = new Array(arity); */
            /* TODO(ForStatement): for (let i = 0; i < arity; i++) {                 const typeParameter = typeParameters[i] = createTypeParameter();                 const flags = elementFlags[i];                 combinedFlags |= flags;                 if (!(combinedFlags & ElementFlags.Variable)) {                     const property = createSymbol(SymbolFlags.Property | (flags & ElementFlags.Optional ? SymbolFlags.Optional : 0), "" + i as __String, readonly ? CheckFlags.Readonly : 0);                     property.links.tupleLabelDeclaration = namedMemberDeclarations?.[i];                     property.links.type = typeParameter;                     properties.push(property);                 }             } */
        }
        fixedLength := /* TODO(PropertyAccessExpression): properties.length */ TODO
        lengthSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "length" /* as */ /* TODO(TypeReference): __String */, /* TODO(ConditionalExpression): readonly ? CheckFlags.Readonly : 0 */ TODO)
        if /* TODO(BinaryExpression): combinedFlags & ElementFlags.Variable */ TODO {
            /* TODO(ExpressionStatement): lengthSymbol.links.type = numberType; */
        } else {
            literalTypes := /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(ForStatement): for (let i = minLength; i <= arity; i++) literalTypes.push(getNumberLiteralType(i)); */
            /* TODO(ExpressionStatement): lengthSymbol.links.type = getUnionType(literalTypes); */
        }
        /* TODO(ExpressionStatement): properties.push(lengthSymbol); */
        type_ := createObjectType(/* TODO(BinaryExpression): ObjectFlags.Tuple | ObjectFlags.Reference */ TODO) /* as */ /* TODO(IntersectionType): TupleType & InterfaceTypeWithDeclaredMembers */
        /* TODO(ExpressionStatement): type.typeParameters = typeParameters; */
        /* TODO(ExpressionStatement): type.outerTypeParameters = undefined; */
        /* TODO(ExpressionStatement): type.localTypeParameters = typeParameters; */
        /* TODO(ExpressionStatement): type.instantiations = new Map<string, TypeReference>(); */
        /* TODO(ExpressionStatement): type.instantiations.set(getTypeListId(type.typeParameters), type as GenericType); */
        /* TODO(ExpressionStatement): type.target = type as GenericType; */
        /* TODO(ExpressionStatement): type.resolvedTypeArguments = type.typeParameters; */
        /* TODO(ExpressionStatement): type.thisType = createTypeParameter(); */
        /* TODO(ExpressionStatement): type.thisType.isThisType = true; */
        /* TODO(ExpressionStatement): type.thisType.constraint = type; */
        /* TODO(ExpressionStatement): type.declaredProperties = properties; */
        /* TODO(ExpressionStatement): type.declaredCallSignatures = emptyArray; */
        /* TODO(ExpressionStatement): type.declaredConstructSignatures = emptyArray; */
        /* TODO(ExpressionStatement): type.declaredIndexInfos = emptyArray; */
        /* TODO(ExpressionStatement): type.elementFlags = elementFlags; */
        /* TODO(ExpressionStatement): type.minLength = minLength; */
        /* TODO(ExpressionStatement): type.fixedLength = fixedLength; */
        /* TODO(ExpressionStatement): type.hasRestElement = !!(combinedFlags & ElementFlags.Variable); */
        /* TODO(ExpressionStatement): type.combinedFlags = combinedFlags; */
        /* TODO(ExpressionStatement): type.readonly = readonly; */
        /* TODO(ExpressionStatement): type.labeledElementDeclarations = namedMemberDeclarations; */
         type_
    }
    createNormalizedTypeReference := func(target GenericType, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): target.objectFlags & ObjectFlags.Tuple ? createNormalizedTupleType(target as TupleType, typeArguments!) : createTypeReference(target, typeArguments) */ TODO
    }
    createNormalizedTupleType := func(target TupleType, elementTypes []Type) Type {
        if /* TODO(PrefixUnaryExpression): !(target.combinedFlags & ElementFlags.NonRequired) */ TODO {
             createTypeReference(target, elementTypes)
        }
        if /* TODO(BinaryExpression): target.combinedFlags & ElementFlags.Variadic */ TODO {
            unionIndex := findIndex(elementTypes, /* TODO(ArrowFunction): (t, i) => !!(target.elementFlags[i] & ElementFlags.Variadic && t.flags & (TypeFlags.Never | TypeFlags.Union)) */ TODO)
            if /* TODO(BinaryExpression): unionIndex >= 0 */ TODO {
                 /* TODO(ConditionalExpression): checkCrossProductUnion(map(elementTypes, (t, i) => target.elementFlags[i] & ElementFlags.Variadic ? t : unknownType)) ?                     mapType(elementTypes[unionIndex], t => createNormalizedTupleType(target, replaceElement(elementTypes, unionIndex, t))) :                     errorType */ TODO
            }
        }
        var expandedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        var expandedFlags []ElementFlags = /* TODO(ArrayLiteralExpression): [] */ TODO
        var expandedDeclarations []/* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
        lastRequiredIndex := /* TODO(PrefixUnaryExpression): -1 */ TODO
        firstRestIndex := /* TODO(PrefixUnaryExpression): -1 */ TODO
        lastOptionalOrRestIndex := /* TODO(PrefixUnaryExpression): -1 */ TODO
        /* TODO(ForStatement): for (let i = 0; i < elementTypes.length; i++) {             const type = elementTypes[i];             const flags = target.elementFlags[i];             if (flags & ElementFlags.Variadic) {                 if (type.flags & TypeFlags.Any) {                     addElement(type, ElementFlags.Rest, target.labeledElementDeclarations?.[i]);                 }                 else if (type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(type)) {                     // Generic variadic elements stay as they are.                     addElement(type, ElementFlags.Variadic, target.labeledElementDeclarations?.[i]);                 }                 else if (isTupleType(type)) {                     const elements = getElementTypes(type);                     if (elements.length + expandedTypes.length >= 10_000) {                         error(                             currentNode,                             isPartOfTypeNode(currentNode!)                                 ? Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent                                 : Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent,                         );                         return errorType;                     }                     // Spread variadic elements with tuple types into the resulting tuple.                     forEach(elements, (t, n) => addElement(t, type.target.elementFlags[n], type.target.labeledElementDeclarations?.[n]));                 }                 else {                     // Treat everything else as an array type and create a rest element.                     addElement(isArrayLikeType(type) && getIndexTypeOfType(type, numberType) || errorType, ElementFlags.Rest, target.labeledElementDeclarations?.[i]);                 }             }             else {                 // Copy other element kinds with no change.                 addElement(type, flags, target.labeledElementDeclarations?.[i]);             }         } */
        /* TODO(ForStatement): for (let i = 0; i < lastRequiredIndex; i++) {             if (expandedFlags[i] & ElementFlags.Optional) expandedFlags[i] = ElementFlags.Required;         } */
        if /* TODO(BinaryExpression): firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex */ TODO {
            /* TODO(ExpressionStatement): expandedTypes[firstRestIndex] = getUnionType(sameMap(expandedTypes.slice(firstRestIndex, lastOptionalOrRestIndex + 1), (t, i) => expandedFlags[firstRestIndex + i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t)); */
            /* TODO(ExpressionStatement): expandedTypes.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex); */
            /* TODO(ExpressionStatement): expandedFlags.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex); */
            /* TODO(ExpressionStatement): expandedDeclarations.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex); */
        }
        tupleTarget := getTupleTargetType(expandedFlags, /* TODO(PropertyAccessExpression): target.readonly */ TODO, expandedDeclarations)
         /* TODO(ConditionalExpression): tupleTarget === emptyGenericType ? emptyObjectType :             expandedFlags.length ? createTypeReference(tupleTarget, expandedTypes) :             tupleTarget */ TODO
        addElement := func(type_ Type, flags ElementFlags, declaration /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) {
            if /* TODO(BinaryExpression): flags & ElementFlags.Required */ TODO {
                /* TODO(ExpressionStatement): lastRequiredIndex = expandedFlags.length; */
            }
            if /* TODO(BinaryExpression): flags & ElementFlags.Rest && firstRestIndex < 0 */ TODO {
                /* TODO(ExpressionStatement): firstRestIndex = expandedFlags.length; */
            }
            if /* TODO(BinaryExpression): flags & (ElementFlags.Optional | ElementFlags.Rest) */ TODO {
                /* TODO(ExpressionStatement): lastOptionalOrRestIndex = expandedFlags.length; */
            }
            /* TODO(ExpressionStatement): expandedTypes.push(flags & ElementFlags.Optional ? addOptionality(type, /*isProperty* / true) : type); */
            /* TODO(ExpressionStatement): expandedFlags.push(flags); */
            /* TODO(ExpressionStatement): expandedDeclarations.push(declaration); */
        }
    }
    sliceTupleType := func(type_ TupleTypeReference, index number, endSkipCount /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        target := /* TODO(PropertyAccessExpression): type.target */ TODO
        endIndex := /* TODO(BinaryExpression): getTypeReferenceArity(type) - endSkipCount */ TODO
         /* TODO(ConditionalExpression): index > target.fixedLength ? getRestArrayTypeOfTupleType(type) || createTupleType(emptyArray) :             createTupleType(getTypeArguments(type).slice(index, endIndex), target.elementFlags.slice(index, endIndex), /*readonly* / false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex)) */ TODO
    }
    getKnownKeysOfTupleType := func(type_ TupleTypeReference) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         getUnionType(append(arrayOf(/* TODO(PropertyAccessExpression): type.target.fixedLength */ TODO, /* TODO(ArrowFunction): i => getStringLiteralType("" + i) */ TODO), getIndexType(/* TODO(ConditionalExpression): type.target.readonly ? globalReadonlyArrayType : globalArrayType */ TODO)))
    }
    getStartElementCount := func(type_ TupleType, flags ElementFlags) /* TODO(undefined): number */ TODO {
        index := findIndex(/* TODO(PropertyAccessExpression): type.elementFlags */ TODO, /* TODO(ArrowFunction): f => !(f & flags) */ TODO)
         /* TODO(ConditionalExpression): index >= 0 ? index : type.elementFlags.length */ TODO
    }
    getEndElementCount := func(type_ TupleType, flags ElementFlags) /* TODO(undefined): number */ TODO {
         /* TODO(BinaryExpression): type.elementFlags.length - findLastIndex(type.elementFlags, f => !(f & flags)) - 1 */ TODO
    }
    getTotalFixedElementCount := func(type_ TupleType) /* TODO(undefined): number */ TODO {
         /* TODO(BinaryExpression): type.fixedLength + getEndElementCount(type, ElementFlags.Fixed) */ TODO
    }
    getElementTypes := func(type_ TupleTypeReference) []Type {
        typeArguments := getTypeArguments(type_)
        arity := getTypeReferenceArity(type_)
         /* TODO(ConditionalExpression): typeArguments.length === arity ? typeArguments : typeArguments.slice(0, arity) */ TODO
    }
    getTypeFromOptionalTypeNode := func(node OptionalTypeNode) Type {
         addOptionality(getTypeFromTypeNode(/* TODO(PropertyAccessExpression): node.type */ TODO), /* TODO(TrueKeyword): true */ TODO)
    }
    getTypeId := func(type_ Type) TypeId {
         /* TODO(PropertyAccessExpression): type.id */ TODO
    }
    containsType := func(types []Type, type_ Type) bool {
         /* TODO(BinaryExpression): binarySearch(types, type, getTypeId, compareValues) >= 0 */ TODO
    }
    insertType := func(types []Type, type_ Type) bool {
        index := binarySearch(types, type_, getTypeId, compareValues)
        if /* TODO(BinaryExpression): index < 0 */ TODO {
            /* TODO(ExpressionStatement): types.splice(~index, 0, type); */
             /* TODO(TrueKeyword): true */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    addTypeToUnion := func(typeSet []Type, includes TypeFlags, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO {
        flags := /* TODO(PropertyAccessExpression): type.flags */ TODO
        if /* TODO(PrefixUnaryExpression): !(flags & TypeFlags.Never) */ TODO {
            /* TODO(ExpressionStatement): includes |= flags & TypeFlags.IncludesMask; */
            if /* TODO(BinaryExpression): flags & TypeFlags.Instantiable */ TODO {
                /* TODO(BinaryExpression): includes |= TypeFlags.IncludesInstantiable */
            }
            if /* TODO(BinaryExpression): flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable */ TODO {
                /* TODO(BinaryExpression): includes |= TypeFlags.IncludesConstrainedTypeVariable */
            }
            if /* TODO(BinaryExpression): type === wildcardType */ TODO {
                /* TODO(BinaryExpression): includes |= TypeFlags.IncludesWildcard */
            }
            if isErrorType(type_) {
                /* TODO(BinaryExpression): includes |= TypeFlags.IncludesError */
            }
            if /* TODO(BinaryExpression): !strictNullChecks && flags & TypeFlags.Nullable */ TODO {
                if /* TODO(PrefixUnaryExpression): !(getObjectFlags(type) & ObjectFlags.ContainsWideningType) */ TODO {
                    /* TODO(BinaryExpression): includes |= TypeFlags.IncludesNonWideningType */
                }
            } else {
                len := /* TODO(PropertyAccessExpression): typeSet.length */ TODO
                index := /* TODO(ConditionalExpression): len && type.id > typeSet[len - 1].id ? ~len : binarySearch(typeSet, type, getTypeId, compareValues) */ TODO
                if /* TODO(BinaryExpression): index < 0 */ TODO {
                    /* TODO(ExpressionStatement): typeSet.splice(~index, 0, type); */
                }
            }
        }
         includes
    }
    addTypesToUnion := func(typeSet []Type, includes TypeFlags, types []Type) TypeFlags {
        var lastType *Type
        /* TODO(ForOfStatement): for (const type of types) {             // We skip the type if it is the same as the last type we processed. This simple test particularly             // saves a lot of work for large lists of the same union type, such as when resolving `Record<A, B>[A]`,             // where A and B are large union types.             if (type !== lastType) {                 includes = type.flags & TypeFlags.Union ?                     addTypesToUnion(typeSet, includes | (isNamedUnionType(type) ? TypeFlags.Union : 0), (type as UnionType).types) :                     addTypeToUnion(typeSet, includes, type);                 lastType = type;             }         } */
         includes
    }
    removeSubtypes := func(types []Type, hasObjectTypes bool) /* TODO(ArrayType): Type[] */ any {
        if /* TODO(BinaryExpression): types.length < 2 */ TODO {
             types
        }
        id := getTypeListId(types)
        match := /* TODO(PropertyAccessExpression): subtypeReductionCache.get */ TODO(id)
        if match {
             match
        }
        hasEmptyObject := /* TODO(BinaryExpression): hasObjectTypes && some(types, t => !!(t.flags & TypeFlags.Object) && !isGenericMappedType(t) && isEmptyResolvedType(resolveStructuredTypeMembers(t as ObjectType))) */ TODO
        len := /* TODO(PropertyAccessExpression): types.length */ TODO
        i := len
        count := 0
        /* TODO(WhileStatement): while (i > 0) {             i--;             const source = types[i];             if (hasEmptyObject || source.flags & TypeFlags.StructuredOrInstantiable) {                 // A type parameter with a union constraint may be a subtype of some union, but not a subtype of the                 // individual constituents of that union. For example, `T extends A | B` is a subtype of `A | B`, but not                 // a subtype of just `A` or just `B`. When we encounter such a type parameter, we therefore check if the                 // type parameter is a subtype of a union of all the other types.                 if (source.flags & TypeFlags.TypeParameter && getBaseConstraintOrType(source).flags & TypeFlags.Union) {                     if (isTypeRelatedTo(source, getUnionType(map(types, t => t === source ? neverType : t)), strictSubtypeRelation)) {                         orderedRemoveItemAt(types, i);                     }                     continue;                 }                 // Find the first property with a unit type, if any. When constituents have a property by the same name                 // but of a different unit type, we can quickly disqualify them from subtype checks. This helps subtype                 // reduction of large discriminated union types.                 const keyProperty = source.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive) ?                     find(getPropertiesOfType(source), p => isUnitType(getTypeOfSymbol(p))) :                     undefined;                 const keyPropertyType = keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty));                 for (const target of types) {                     if (source !== target) {                         if (count === 100000) {                             // After 100000 subtype checks we estimate the remaining amount of work by assuming the                             // same ratio of checks per element. If the estimated number of remaining type checks is                             // greater than 1M we deem the union type too complex to represent. This for example                             // caps union types at 1000 unique object types.                             const estimatedCount = (count / (len - i)) * len;                             if (estimatedCount > 1000000) {                                 tracing?.instant(tracing.Phase.CheckTypes, "removeSubtypes_DepthLimit", { typeIds: types.map(t => t.id) });                                 error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);                                 return undefined;                             }                         }                         count++;                         if (keyProperty && target.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive)) {                             const t = getTypeOfPropertyOfType(target, keyProperty.escapedName);                             if (t && isUnitType(t) && getRegularTypeOfLiteralType(t) !== keyPropertyType) {                                 continue;                             }                         }                         if (                             isTypeRelatedTo(source, target, strictSubtypeRelation) && (                                 !(getObjectFlags(getTargetType(source)) & ObjectFlags.Class) ||                                 !(getObjectFlags(getTargetType(target)) & ObjectFlags.Class) ||                                 isTypeDerivedFrom(source, target)                             )                         ) {                             orderedRemoveItemAt(types, i);                             break;                         }                     }                 }             }         } */
        /* TODO(ExpressionStatement): subtypeReductionCache.set(id, types); */
         types
    }
    removeRedundantLiteralTypes := func(types []Type, includes TypeFlags, reduceVoidUndefined bool) {
        i := /* TODO(PropertyAccessExpression): types.length */ TODO
        /* TODO(WhileStatement): while (i > 0) {             i--;             const t = types[i];             const flags = t.flags;             const remove = flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && includes & TypeFlags.String ||                 flags & TypeFlags.NumberLiteral && includes & TypeFlags.Number ||                 flags & TypeFlags.BigIntLiteral && includes & TypeFlags.BigInt ||                 flags & TypeFlags.UniqueESSymbol && includes & TypeFlags.ESSymbol ||                 reduceVoidUndefined && flags & TypeFlags.Undefined && includes & TypeFlags.Void ||                 isFreshLiteralType(t) && containsType(types, (t as LiteralType).regularType);             if (remove) {                 orderedRemoveItemAt(types, i);             }         } */
    }
    removeStringLiteralsMatchedByTemplateLiterals := func(types []Type) {
        patterns := filter(types, isPatternLiteralType) /* as */ /* TODO(ArrayType): (TemplateLiteralType | StringMappingType)[] */
        templateLiterals := filter(patterns, /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.TemplateLiteral) */ TODO) /* as */ /* TODO(ArrayType): TemplateLiteralType[] */
        estimatedCount := /* TODO(BinaryExpression): templateLiterals.length * countWhere(types, t => !!(t.flags & TypeFlags.StringLiteral)) */ TODO
        if /* TODO(BinaryExpression): estimatedCount > 0 */ TODO {
            trie := createPrefixSuffixTrie()
            /* TODO(ExpressionStatement): forEach(templateLiterals, t => {                 const prefix = t.texts[0];                 const suffix = t.texts[t.texts.length - 1];                 trie.set(prefix, suffix, templates => append(templates, t));             }); */
            i := /* TODO(PropertyAccessExpression): types.length */ TODO
            /* TODO(LabeledStatement): outer: while (i > 0) {                 i--;                 const t = types[i];                 if (!(t.flags & TypeFlags.StringLiteral)) continue;                 const text = (t as StringLiteralType).value;                  for (const templates of trie.iterateAllMatches(text)) {                     if (some(templates, template => isTypeMatchedByTemplateLiteralOrStringMapping(t, template))) {                         orderedRemoveItemAt(types, i);                         continue outer;                     }                 }             } */
            /* TODO(ExpressionStatement): patterns = filter(patterns, t => !!(t.flags & TypeFlags.StringMapping)) as StringMappingType[]; */
        }
        if /* TODO(PropertyAccessExpression): patterns.length */ TODO {
            i := /* TODO(PropertyAccessExpression): types.length */ TODO
            /* TODO(WhileStatement): while (i > 0) {                 i--;                 const t = types[i];                 if (!(t.flags & TypeFlags.StringLiteral)) continue;                 if (some(patterns, template => isTypeMatchedByTemplateLiteralOrStringMapping(t, template))) {                     orderedRemoveItemAt(types, i);                 }             } */
        }
    }
    isTypeMatchedByTemplateLiteralOrStringMapping := func(type_ Type, template /* TODO(UnionType): TemplateLiteralType | StringMappingType */ any) /* TODO(undefined): boolean */ TODO {
         /* TODO(ConditionalExpression): template.flags & TypeFlags.TemplateLiteral ?             isTypeMatchedByTemplateLiteralType(type, template as TemplateLiteralType) :             isMemberOfStringMapping(type, template) */ TODO
    }
    removeConstrainedTypeVariables := func(types []Type) {
        var typeVariables []TypeVariable = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForOfStatement): for (const type of types) {             if (type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable) {                 const index = (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1;                 pushIfUnique(typeVariables, (type as IntersectionType).types[index]);             }         } */
        /* TODO(ForOfStatement): for (const typeVariable of typeVariables) {             const primitives: Type[] = [];             // First collect the primitive types from the constraining intersections.             for (const type of types) {                 if (type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable) {                     const index = (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1;                     if ((type as IntersectionType).types[index] === typeVariable) {                         insertType(primitives, (type as IntersectionType).types[1 - index]);                     }                 }             }             // If every constituent in the type variable's constraint is covered by an intersection of the type             // variable and that constituent, remove those intersections and substitute the type variable.             const constraint = getBaseConstraintOfType(typeVariable)!;             if (everyType(constraint, t => containsType(primitives, t))) {                 let i = types.length;                 while (i > 0) {                     i--;                     const type = types[i];                     if (type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable) {                         const index = (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1;                         if ((type as IntersectionType).types[index] === typeVariable && containsType(primitives, (type as IntersectionType).types[1 - index])) {                             orderedRemoveItemAt(types, i);                         }                     }                 }                 insertType(types, typeVariable);             }         } */
    }
    isNamedUnionType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(type.flags & TypeFlags.Union && (type.aliasSymbol || (type as UnionType).origin)) */ TODO
    }
    addNamedUnions := func(namedUnions []Type, types []Type) {
        /* TODO(ForOfStatement): for (const t of types) {             if (t.flags & TypeFlags.Union) {                 const origin = (t as UnionType).origin;                 if (t.aliasSymbol || origin && !(origin.flags & TypeFlags.Union)) {                     pushIfUnique(namedUnions, t);                 }                 else if (origin && origin.flags & TypeFlags.Union) {                     addNamedUnions(namedUnions, (origin as UnionType).types);                 }             }         } */
    }
    createOriginUnionOrIntersectionType := func(flags TypeFlags, types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").UnionOrIntersectionType */ TODO {
        result := createOriginType(flags) /* as */ /* TODO(TypeReference): UnionOrIntersectionType */
        /* TODO(ExpressionStatement): result.types = types; */
         result
    }
    getUnionType := func(types []Type, unionReduction UnionReduction /* = */ /* TODO(PropertyAccessExpression): UnionReduction.Literal */, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
        if /* TODO(BinaryExpression): types.length === 0 */ TODO {
             neverType
        }
        if /* TODO(BinaryExpression): types.length === 1 */ TODO {
             /* TODO(ElementAccessExpression): types[0] */ TODO
        }
        if /* TODO(BinaryExpression): types.length === 2 && !origin && (types[0].flags & TypeFlags.Union || types[1].flags & TypeFlags.Union) */ TODO {
            infix := /* TODO(ConditionalExpression): unionReduction === UnionReduction.None ? "N" : unionReduction === UnionReduction.Subtype ? "S" : "L" */ TODO
            index := /* TODO(ConditionalExpression): types[0].id < types[1].id ? 0 : 1 */ TODO
            id := /* TODO(BinaryExpression): types[index].id + infix + types[1 - index].id + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
            type_ := /* TODO(PropertyAccessExpression): unionOfUnionTypes.get */ TODO(id)
            if /* TODO(PrefixUnaryExpression): !type */ TODO {
                /* TODO(ExpressionStatement): type = getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, /*origin* / undefined); */
                /* TODO(ExpressionStatement): unionOfUnionTypes.set(id, type); */
            }
             type_
        }
         getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, origin)
    }
    getUnionTypeWorker := func(types []Type, unionReduction UnionReduction, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any, origin *Type) Type {
        var typeSet /* TODO(ArrayType): Type[] */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
        includes := addTypesToUnion(typeSet, 0 /* as */ /* TODO(TypeReference): TypeFlags */, types)
        if /* TODO(BinaryExpression): unionReduction !== UnionReduction.None */ TODO {
            if /* TODO(BinaryExpression): includes & TypeFlags.AnyOrUnknown */ TODO {
                 /* TODO(ConditionalExpression): includes & TypeFlags.Any ?                     includes & TypeFlags.IncludesWildcard ? wildcardType :                         includes & TypeFlags.IncludesError ? errorType : anyType :                     unknownType */ TODO
            }
            if /* TODO(BinaryExpression): includes & TypeFlags.Undefined */ TODO {
                if /* TODO(BinaryExpression): typeSet.length >= 2 && typeSet[0] === undefinedType && typeSet[1] === missingType */ TODO {
                    /* TODO(ExpressionStatement): orderedRemoveItemAt(typeSet, 1); */
                }
            }
            if /* TODO(BinaryExpression): includes & (TypeFlags.Enum | TypeFlags.Literal | TypeFlags.UniqueESSymbol | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) || includes & TypeFlags.Void && includes & TypeFlags.Undefined */ TODO {
                /* TODO(ExpressionStatement): removeRedundantLiteralTypes(typeSet, includes, !!(unionReduction & UnionReduction.Subtype)); */
            }
            if /* TODO(BinaryExpression): includes & TypeFlags.StringLiteral && includes & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping) */ TODO {
                /* TODO(ExpressionStatement): removeStringLiteralsMatchedByTemplateLiterals(typeSet); */
            }
            if /* TODO(BinaryExpression): includes & TypeFlags.IncludesConstrainedTypeVariable */ TODO {
                /* TODO(ExpressionStatement): removeConstrainedTypeVariables(typeSet); */
            }
            if /* TODO(BinaryExpression): unionReduction === UnionReduction.Subtype */ TODO {
                /* TODO(ExpressionStatement): typeSet = removeSubtypes(typeSet, !!(includes & TypeFlags.Object)); */
                if /* TODO(PrefixUnaryExpression): !typeSet */ TODO {
                     errorType
                }
            }
            if /* TODO(BinaryExpression): typeSet.length === 0 */ TODO {
                 /* TODO(ConditionalExpression): includes & TypeFlags.Null ? includes & TypeFlags.IncludesNonWideningType ? nullType : nullWideningType :                     includes & TypeFlags.Undefined ? includes & TypeFlags.IncludesNonWideningType ? undefinedType : undefinedWideningType :                     neverType */ TODO
            }
        }
        if /* TODO(BinaryExpression): !origin && includes & TypeFlags.Union */ TODO {
            var namedUnions []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(ExpressionStatement): addNamedUnions(namedUnions, types); */
            var reducedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(ForOfStatement): for (const t of typeSet) {                 if (!some(namedUnions, union => containsType((union as UnionType).types, t))) {                     reducedTypes.push(t);                 }             } */
            if /* TODO(BinaryExpression): !aliasSymbol && namedUnions.length === 1 && reducedTypes.length === 0 */ TODO {
                 /* TODO(ElementAccessExpression): namedUnions[0] */ TODO
            }
            namedTypesCount := reduceLeft(namedUnions, /* TODO(ArrowFunction): (sum, union) => sum + (union as UnionType).types.length */ TODO, 0)
            if /* TODO(BinaryExpression): namedTypesCount + reducedTypes.length === typeSet.length */ TODO {
                /* TODO(ForOfStatement): for (const t of namedUnions) {                     insertType(reducedTypes, t);                 } */
                /* TODO(ExpressionStatement): origin = createOriginUnionOrIntersectionType(TypeFlags.Union, reducedTypes); */
            }
        }
        objectFlags := /* TODO(BinaryExpression): (includes & TypeFlags.NotPrimitiveUnion ? 0 : ObjectFlags.PrimitiveUnion) |             (includes & TypeFlags.Intersection ? ObjectFlags.ContainsIntersections : 0) */ TODO
         getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin)
    }
    getUnionOrIntersectionTypePredicate := func(signatures []Signature, kind *TypeFlags) *TypePredicate {
        var last *TypePredicate
        var types []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForOfStatement): for (const sig of signatures) {             const pred = getTypePredicateOfSignature(sig);             if (pred) {                 // Constituent type predicates must all have matching kinds. We don't create composite type predicates for assertions.                 if (pred.kind !== TypePredicateKind.This && pred.kind !== TypePredicateKind.Identifier || last && !typePredicateKindsMatch(last, pred)) {                     return undefined;                 }                 last = pred;                 types.push(pred.type);             }             else {                 // In composite union signatures we permit and ignore signatures with a return type `false`.                 const returnType = kind !== TypeFlags.Intersection ? getReturnTypeOfSignature(sig) : undefined;                 if (returnType !== falseType && returnType !== regularFalseType) {                     return undefined;                 }             }         } */
        if /* TODO(PrefixUnaryExpression): !last */ TODO {
             undefined
        }
        compositeType := getUnionOrIntersectionType(types, kind)
         createTypePredicate(/* TODO(PropertyAccessExpression): last.kind */ TODO, /* TODO(PropertyAccessExpression): last.parameterName */ TODO, /* TODO(PropertyAccessExpression): last.parameterIndex */ TODO, compositeType)
    }
    typePredicateKindsMatch := func(a TypePredicate, b TypePredicate) bool {
         /* TODO(BinaryExpression): a.kind === b.kind && a.parameterIndex === b.parameterIndex */ TODO
    }
    getUnionTypeFromSortedList := func(types []Type, precomputedObjectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
        if /* TODO(BinaryExpression): types.length === 0 */ TODO {
             neverType
        }
        if /* TODO(BinaryExpression): types.length === 1 */ TODO {
             /* TODO(ElementAccessExpression): types[0] */ TODO
        }
        typeKey := /* TODO(ConditionalExpression): !origin ? getTypeListId(types) :             origin.flags & TypeFlags.Union ? `|${getTypeListId((origin as UnionType).types)}` :             origin.flags & TypeFlags.Intersection ? `&${getTypeListId((origin as IntersectionType).types)}` :             `#${(origin as IndexType).type.id}|${getTypeListId(types)}` */ TODO
        id := /* TODO(BinaryExpression): typeKey + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
        type_ := /* TODO(PropertyAccessExpression): unionTypes.get */ TODO(id)
        if /* TODO(PrefixUnaryExpression): !type */ TODO {
            /* TODO(ExpressionStatement): type = createType(TypeFlags.Union) as UnionType; */
            /* TODO(ExpressionStatement): type.objectFlags = precomputedObjectFlags | getPropagatingFlagsOfTypes(types, /*excludeKinds* / TypeFlags.Nullable); */
            /* TODO(ExpressionStatement): type.types = types; */
            /* TODO(ExpressionStatement): type.origin = origin; */
            /* TODO(ExpressionStatement): type.aliasSymbol = aliasSymbol; */
            /* TODO(ExpressionStatement): type.aliasTypeArguments = aliasTypeArguments; */
            if /* TODO(BinaryExpression): types.length === 2 && types[0].flags & TypeFlags.BooleanLiteral && types[1].flags & TypeFlags.BooleanLiteral */ TODO {
                /* TODO(ExpressionStatement): type.flags |= TypeFlags.Boolean; */
                /* TODO(ExpressionStatement): (type as UnionType & IntrinsicType).intrinsicName = "boolean"; */
            }
            /* TODO(ExpressionStatement): unionTypes.set(id, type); */
        }
         type_
    }
    getTypeFromUnionTypeNode := func(node UnionTypeNode) Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            aliasSymbol := getAliasSymbolForTypeNode(node)
            /* TODO(ExpressionStatement): links.resolvedType = getUnionType(map(node.types, getTypeFromTypeNode), UnionReduction.Literal, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol)); */
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    addTypeToIntersection := func(typeSet Map[string, Type], includes TypeFlags, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO {
        flags := /* TODO(PropertyAccessExpression): type.flags */ TODO
        if /* TODO(BinaryExpression): flags & TypeFlags.Intersection */ TODO {
             addTypesToIntersection(typeSet, includes, /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO)
        }
        if isEmptyAnonymousObjectType(type_) {
            if /* TODO(PrefixUnaryExpression): !(includes & TypeFlags.IncludesEmptyObject) */ TODO {
                /* TODO(ExpressionStatement): includes |= TypeFlags.IncludesEmptyObject; */
                /* TODO(ExpressionStatement): typeSet.set(type.id.toString(), type); */
            }
        } else {
            if /* TODO(BinaryExpression): flags & TypeFlags.AnyOrUnknown */ TODO {
                if /* TODO(BinaryExpression): type === wildcardType */ TODO {
                    /* TODO(BinaryExpression): includes |= TypeFlags.IncludesWildcard */
                }
                if isErrorType(type_) {
                    /* TODO(BinaryExpression): includes |= TypeFlags.IncludesError */
                }
            } else if /* TODO(BinaryExpression): strictNullChecks || !(flags & TypeFlags.Nullable) */ TODO {
                if /* TODO(BinaryExpression): type === missingType */ TODO {
                    /* TODO(ExpressionStatement): includes |= TypeFlags.IncludesMissingType; */
                    /* TODO(ExpressionStatement): type = undefinedType; */
                }
                if /* TODO(PrefixUnaryExpression): !typeSet.has(type.id.toString()) */ TODO {
                    if /* TODO(BinaryExpression): type.flags & TypeFlags.Unit && includes & TypeFlags.Unit */ TODO {
                        /* TODO(ExpressionStatement): includes |= TypeFlags.NonPrimitive; */
                    }
                    /* TODO(ExpressionStatement): typeSet.set(type.id.toString(), type); */
                }
            }
            /* TODO(ExpressionStatement): includes |= flags & TypeFlags.IncludesMask; */
        }
         includes
    }
    addTypesToIntersection := func(typeSet Map[string, Type], includes TypeFlags, types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO {
        /* TODO(ForOfStatement): for (const type of types) {             includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type));         } */
         includes
    }
    removeRedundantSupertypes := func(types []Type, includes TypeFlags) {
        i := /* TODO(PropertyAccessExpression): types.length */ TODO
        /* TODO(WhileStatement): while (i > 0) {             i--;             const t = types[i];             const remove = t.flags & TypeFlags.String && includes & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ||                 t.flags & TypeFlags.Number && includes & TypeFlags.NumberLiteral ||                 t.flags & TypeFlags.BigInt && includes & TypeFlags.BigIntLiteral ||                 t.flags & TypeFlags.ESSymbol && includes & TypeFlags.UniqueESSymbol ||                 t.flags & TypeFlags.Void && includes & TypeFlags.Undefined ||                 isEmptyAnonymousObjectType(t) && includes & TypeFlags.DefinitelyNonNullable;             if (remove) {                 orderedRemoveItemAt(types, i);             }         } */
    }
    eachUnionContains := func(unionTypes []UnionType, type_ Type) /* TODO(undefined): boolean */ TODO {
        /* TODO(ForOfStatement): for (const u of unionTypes) {             if (!containsType(u.types, type)) {                 if (type === missingType) {                     return containsType(u.types, undefinedType);                 }                 if (type === undefinedType) {                     return containsType(u.types, missingType);                 }                 const primitive = type.flags & TypeFlags.StringLiteral ? stringType :                     type.flags & (TypeFlags.Enum | TypeFlags.NumberLiteral) ? numberType :                     type.flags & TypeFlags.BigIntLiteral ? bigintType :                     type.flags & TypeFlags.UniqueESSymbol ? esSymbolType :                     undefined;                 if (!primitive || !containsType(u.types, primitive)) {                     return false;                 }             }         } */
         /* TODO(TrueKeyword): true */ TODO
    }
    extractRedundantTemplateLiterals := func(types []Type) bool {
        i := /* TODO(PropertyAccessExpression): types.length */ TODO
        literals := filter(types, /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.StringLiteral) */ TODO)
        /* TODO(WhileStatement): while (i > 0) {             i--;             const t = types[i];             if (!(t.flags & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping))) continue;             for (const t2 of literals) {                 if (isTypeSubtypeOf(t2, t)) {                     // For example, `get${T}` & "getX" is just "getX", and Lowercase<string> & "foo" is just "foo"                     orderedRemoveItemAt(types, i);                     break;                 }                 else if (isPatternLiteralType(t)) {                     return true;                 }             }         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    removeFromEach := func(types []Type, flag TypeFlags) {
        /* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             types[i] = filterType(types[i], t => !(t.flags & flag));         } */
    }
    intersectUnionsOfPrimitiveTypes := func(types []Type) /* TODO(undefined): boolean */ TODO {
        var unionTypes /* TODO(ArrayType): UnionType[] */ any
        index := findIndex(types, /* TODO(ArrowFunction): t => !!(getObjectFlags(t) & ObjectFlags.PrimitiveUnion) */ TODO)
        if /* TODO(BinaryExpression): index < 0 */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        i := /* TODO(BinaryExpression): index + 1 */ TODO
        /* TODO(WhileStatement): while (i < types.length) {             const t = types[i];             if (getObjectFlags(t) & ObjectFlags.PrimitiveUnion) {                 (unionTypes || (unionTypes = [types[index] as UnionType])).push(t as UnionType);                 orderedRemoveItemAt(types, i);             }             else {                 i++;             }         } */
        if /* TODO(PrefixUnaryExpression): !unionTypes */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        var checked []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        var result []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForOfStatement): for (const u of unionTypes) {             for (const t of u.types) {                 if (insertType(checked, t)) {                     if (eachUnionContains(unionTypes, t)) {                         // undefinedType/missingType should always come sorted first so we leverage that here                         if (t === undefinedType && result.length && result[0] === missingType) {                             continue;                         }                         if (t === missingType && result.length && result[0] === undefinedType) {                             result[0] = missingType;                             continue;                         }                         insertType(result, t);                     }                 }             }         } */
        /* TODO(ExpressionStatement): types[index] = getUnionTypeFromSortedList(result, ObjectFlags.PrimitiveUnion); */
         /* TODO(TrueKeyword): true */ TODO
    }
    createIntersectionType := func(types []Type, objectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntersectionType */ TODO {
        result := createType(/* TODO(PropertyAccessExpression): TypeFlags.Intersection */ TODO) /* as */ /* TODO(TypeReference): IntersectionType */
        /* TODO(ExpressionStatement): result.objectFlags = objectFlags | getPropagatingFlagsOfTypes(types, /*excludeKinds* / TypeFlags.Nullable); */
        /* TODO(ExpressionStatement): result.types = types; */
        /* TODO(ExpressionStatement): result.aliasSymbol = aliasSymbol; */
        /* TODO(ExpressionStatement): result.aliasTypeArguments = aliasTypeArguments; */
         result
    }
    getIntersectionType := func(types []Type, flags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntersectionFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): IntersectionFlags.None */, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
        typeMembershipMap := /* TODO(NewExpression): new Map<string, Type>() */ TODO
        includes := addTypesToIntersection(typeMembershipMap, 0 /* as */ /* TODO(TypeReference): TypeFlags */, types)
        var typeSet []Type = arrayFrom(/* TODO(PropertyAccessExpression): typeMembershipMap.values */ TODO())
        objectFlags := /* TODO(PropertyAccessExpression): ObjectFlags.None */ TODO
        if /* TODO(BinaryExpression): includes & TypeFlags.Never */ TODO {
             /* TODO(ConditionalExpression): contains(typeSet, silentNeverType) ? silentNeverType : neverType */ TODO
        }
        if /* TODO(BinaryExpression): strictNullChecks && includes & TypeFlags.Nullable && includes & (TypeFlags.Object | TypeFlags.NonPrimitive | TypeFlags.IncludesEmptyObject) ||             includes & TypeFlags.NonPrimitive && includes & (TypeFlags.DisjointDomains & ~TypeFlags.NonPrimitive) ||             includes & TypeFlags.StringLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.StringLike) ||             includes & TypeFlags.NumberLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.NumberLike) ||             includes & TypeFlags.BigIntLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.BigIntLike) ||             includes & TypeFlags.ESSymbolLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.ESSymbolLike) ||             includes & TypeFlags.VoidLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.VoidLike) */ TODO {
             neverType
        }
        if /* TODO(BinaryExpression): includes & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && includes & TypeFlags.StringLiteral && extractRedundantTemplateLiterals(typeSet) */ TODO {
             neverType
        }
        if /* TODO(BinaryExpression): includes & TypeFlags.Any */ TODO {
             /* TODO(ConditionalExpression): includes & TypeFlags.IncludesWildcard ? wildcardType : includes & TypeFlags.IncludesError ? errorType : anyType */ TODO
        }
        if /* TODO(BinaryExpression): !strictNullChecks && includes & TypeFlags.Nullable */ TODO {
             /* TODO(ConditionalExpression): includes & TypeFlags.IncludesEmptyObject ? neverType : includes & TypeFlags.Undefined ? undefinedType : nullType */ TODO
        }
        if /* TODO(BinaryExpression): includes & TypeFlags.String && includes & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ||             includes & TypeFlags.Number && includes & TypeFlags.NumberLiteral ||             includes & TypeFlags.BigInt && includes & TypeFlags.BigIntLiteral ||             includes & TypeFlags.ESSymbol && includes & TypeFlags.UniqueESSymbol ||             includes & TypeFlags.Void && includes & TypeFlags.Undefined ||             includes & TypeFlags.IncludesEmptyObject && includes & TypeFlags.DefinitelyNonNullable */ TODO {
            if /* TODO(PrefixUnaryExpression): !(flags & IntersectionFlags.NoSupertypeReduction) */ TODO {
                /* TODO(CallExpression): removeRedundantSupertypes(typeSet, includes) */
            }
        }
        if /* TODO(BinaryExpression): includes & TypeFlags.IncludesMissingType */ TODO {
            /* TODO(ExpressionStatement): typeSet[typeSet.indexOf(undefinedType)] = missingType; */
        }
        if /* TODO(BinaryExpression): typeSet.length === 0 */ TODO {
             unknownType
        }
        if /* TODO(BinaryExpression): typeSet.length === 1 */ TODO {
             /* TODO(ElementAccessExpression): typeSet[0] */ TODO
        }
        if /* TODO(BinaryExpression): typeSet.length === 2 && !(flags & IntersectionFlags.NoConstraintReduction) */ TODO {
            typeVarIndex := /* TODO(ConditionalExpression): typeSet[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
            typeVariable := /* TODO(ElementAccessExpression): typeSet[typeVarIndex] */ TODO
            primitiveType := /* TODO(ElementAccessExpression): typeSet[1 - typeVarIndex] */ TODO
            if /* TODO(BinaryExpression): typeVariable.flags & TypeFlags.TypeVariable &&                 (primitiveType.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive) && !isGenericStringLikeType(primitiveType) || includes & TypeFlags.IncludesEmptyObject) */ TODO {
                constraint := getBaseConstraintOfType(typeVariable)
                if /* TODO(BinaryExpression): constraint && everyType(constraint, t => !!(t.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) || isEmptyAnonymousObjectType(t)) */ TODO {
                    if isTypeStrictSubtypeOf(constraint, primitiveType) {
                         typeVariable
                    }
                    if /* TODO(PrefixUnaryExpression): !(constraint.flags & TypeFlags.Union && someType(constraint, c => isTypeStrictSubtypeOf(c, primitiveType))) */ TODO {
                        if /* TODO(PrefixUnaryExpression): !isTypeStrictSubtypeOf(primitiveType, constraint) */ TODO {
                             neverType
                        }
                    }
                    /* TODO(ExpressionStatement): objectFlags = ObjectFlags.IsConstrainedTypeVariable; */
                }
            }
        }
        id := /* TODO(BinaryExpression): getTypeListId(typeSet) + (flags & IntersectionFlags.NoConstraintReduction ? "*" : getAliasId(aliasSymbol, aliasTypeArguments)) */ TODO
        result := /* TODO(PropertyAccessExpression): intersectionTypes.get */ TODO(id)
        if /* TODO(PrefixUnaryExpression): !result */ TODO {
            if /* TODO(BinaryExpression): includes & TypeFlags.Union */ TODO {
                if intersectUnionsOfPrimitiveTypes(typeSet) {
                    /* TODO(ExpressionStatement): result = getIntersectionType(typeSet, flags, aliasSymbol, aliasTypeArguments); */
                } else if every(typeSet, /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.Union && (t as UnionType).types[0].flags & TypeFlags.Undefined) */ TODO) {
                    containedUndefinedType := /* TODO(ConditionalExpression): some(typeSet, containsMissingType) ? missingType : undefinedType */ TODO
                    /* TODO(ExpressionStatement): removeFromEach(typeSet, TypeFlags.Undefined); */
                    /* TODO(ExpressionStatement): result = getUnionType([getIntersectionType(typeSet, flags), containedUndefinedType], UnionReduction.Literal, aliasSymbol, aliasTypeArguments); */
                } else if every(typeSet, /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.Union && ((t as UnionType).types[0].flags & TypeFlags.Null || (t as UnionType).types[1].flags & TypeFlags.Null)) */ TODO) {
                    /* TODO(ExpressionStatement): removeFromEach(typeSet, TypeFlags.Null); */
                    /* TODO(ExpressionStatement): result = getUnionType([getIntersectionType(typeSet, flags), nullType], UnionReduction.Literal, aliasSymbol, aliasTypeArguments); */
                } else if /* TODO(BinaryExpression): typeSet.length >= 3 && types.length > 2 */ TODO {
                    middle := /* TODO(PropertyAccessExpression): Math.floor */ TODO(/* TODO(BinaryExpression): typeSet.length / 2 */ TODO)
                    /* TODO(ExpressionStatement): result = getIntersectionType([getIntersectionType(typeSet.slice(0, middle), flags), getIntersectionType(typeSet.slice(middle), flags)], flags, aliasSymbol, aliasTypeArguments); */
                } else {
                    if /* TODO(PrefixUnaryExpression): !checkCrossProductUnion(typeSet) */ TODO {
                         errorType
                    }
                    constituents := getCrossProductIntersections(typeSet, flags)
                    origin := /* TODO(ConditionalExpression): some(constituents, t => !!(t.flags & TypeFlags.Intersection)) && getConstituentCountOfTypes(constituents) > getConstituentCountOfTypes(typeSet) ? createOriginUnionOrIntersectionType(TypeFlags.Intersection, typeSet) : undefined */ TODO
                    /* TODO(ExpressionStatement): result = getUnionType(constituents, UnionReduction.Literal, aliasSymbol, aliasTypeArguments, origin); */
                }
            } else {
                /* TODO(ExpressionStatement): result = createIntersectionType(typeSet, objectFlags, aliasSymbol, aliasTypeArguments); */
            }
            /* TODO(ExpressionStatement): intersectionTypes.set(id, result); */
        }
         result
    }
    getCrossProductUnionSize := func(types []Type) /* TODO(undefined): number */ TODO {
         reduceLeft(types, /* TODO(ArrowFunction): (n, t) => t.flags & TypeFlags.Union ? n * (t as UnionType).types.length : t.flags & TypeFlags.Never ? 0 : n */ TODO, 1)
    }
    checkCrossProductUnion := func(types []Type) /* TODO(undefined): boolean */ TODO {
        size := getCrossProductUnionSize(types)
        if /* TODO(BinaryExpression): size >= 100000 */ TODO {
            /* TODO(ExpressionStatement): tracing?.instant(tracing.Phase.CheckTypes, "checkCrossProductUnion_DepthLimit", { typeIds: types.map(t => t.id), size }); */
            /* TODO(ExpressionStatement): error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent); */
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(TrueKeyword): true */ TODO
    }
    getCrossProductIntersections := func(types []Type, flags IntersectionFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
        count := getCrossProductUnionSize(types)
        var intersections []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForStatement): for (let i = 0; i < count; i++) {             const constituents = types.slice();             let n = i;             for (let j = types.length - 1; j >= 0; j--) {                 if (types[j].flags & TypeFlags.Union) {                     const sourceTypes = (types[j] as UnionType).types;                     const length = sourceTypes.length;                     constituents[j] = sourceTypes[n % length];                     n = Math.floor(n / length);                 }             }             const t = getIntersectionType(constituents, flags);             if (!(t.flags & TypeFlags.Never)) intersections.push(t);         } */
         intersections
    }
    getConstituentCount := func(type_ Type) number {
         /* TODO(ConditionalExpression): !(type.flags & TypeFlags.UnionOrIntersection) || type.aliasSymbol ? 1 :             type.flags & TypeFlags.Union && (type as UnionType).origin ? getConstituentCount((type as UnionType).origin!) :             getConstituentCountOfTypes((type as UnionOrIntersectionType).types) */ TODO
    }
    getConstituentCountOfTypes := func(types []Type) number {
         reduceLeft(types, /* TODO(ArrowFunction): (n, t) => n + getConstituentCount(t) */ TODO, 0)
    }
    getTypeFromIntersectionTypeNode := func(node IntersectionTypeNode) Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            aliasSymbol := getAliasSymbolForTypeNode(node)
            types := map_(/* TODO(PropertyAccessExpression): node.types */ TODO, getTypeFromTypeNode)
            emptyIndex := /* TODO(ConditionalExpression): types.length === 2 ? types.indexOf(emptyTypeLiteralType) : -1 */ TODO
            t := /* TODO(ConditionalExpression): emptyIndex >= 0 ? types[1 - emptyIndex] : unknownType */ TODO
            noSupertypeReduction := /* TODO(PrefixUnaryExpression): !!(t.flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.BigInt) || t.flags & TypeFlags.TemplateLiteral && isPatternLiteralType(t)) */ TODO
            /* TODO(ExpressionStatement): links.resolvedType = getIntersectionType(types, noSupertypeReduction ? IntersectionFlags.NoSupertypeReduction : 0, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol)); */
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    createIndexType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ TODO {
        result := createType(/* TODO(PropertyAccessExpression): TypeFlags.Index */ TODO) /* as */ /* TODO(TypeReference): IndexType */
        /* TODO(ExpressionStatement): result.type = type; */
        /* TODO(ExpressionStatement): result.indexFlags = indexFlags; */
         result
    }
    createOriginIndexType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ TODO {
        result := createOriginType(/* TODO(PropertyAccessExpression): TypeFlags.Index */ TODO) /* as */ /* TODO(TypeReference): IndexType */
        /* TODO(ExpressionStatement): result.type = type; */
         result
    }
    getIndexTypeForGenericType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ TODO {
         /* TODO(ConditionalExpression): indexFlags & IndexFlags.StringsOnly ?             type.resolvedStringIndexType || (type.resolvedStringIndexType = createIndexType(type, IndexFlags.StringsOnly)) :             type.resolvedIndexType || (type.resolvedIndexType = createIndexType(type, IndexFlags.None)) */ TODO
    }
    getIndexTypeForMappedType := func(type_ MappedType, indexFlags IndexFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        typeParameter := getTypeParameterFromMappedType(type_)
        constraintType := getConstraintTypeFromMappedType(type_)
        nameType := getNameTypeFromMappedType(/* TODO(BinaryExpression): type.target as MappedType || type */ TODO)
        if /* TODO(BinaryExpression): !nameType && !(indexFlags & IndexFlags.NoIndexSignatures) */ TODO {
             constraintType
        }
        var keyTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        if isGenericIndexType(constraintType) {
            if isMappedTypeWithKeyofConstraintDeclaration(type_) {
                 getIndexTypeForGenericType(type_, indexFlags)
            }
            /* TODO(ExpressionStatement): forEachType(constraintType, addMemberForKeyType); */
        } else if isMappedTypeWithKeyofConstraintDeclaration(type_) {
            modifiersType := getApparentType(getModifiersTypeFromMappedType(type_))
            /* TODO(ExpressionStatement): forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, TypeFlags.StringOrNumberLiteralOrUnique, !!(indexFlags & IndexFlags.StringsOnly), addMemberForKeyType); */
        } else {
            /* TODO(ExpressionStatement): forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType); */
        }
        result := /* TODO(ConditionalExpression): indexFlags & IndexFlags.NoIndexSignatures ? filterType(getUnionType(keyTypes), t => !(t.flags & (TypeFlags.Any | TypeFlags.String))) : getUnionType(keyTypes) */ TODO
        if /* TODO(BinaryExpression): result.flags & TypeFlags.Union && constraintType.flags & TypeFlags.Union && getTypeListId((result as UnionType).types) === getTypeListId((constraintType as UnionType).types) */ TODO {
             constraintType
        }
         result
        addMemberForKeyType := func(keyType Type) {
            propNameType := /* TODO(ConditionalExpression): nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType */ TODO
            /* TODO(ExpressionStatement): keyTypes.push(propNameType === stringType ? stringOrNumberType : propNameType); */
        }
    }
    hasDistributiveNameType := func(mappedType MappedType) /* TODO(undefined): boolean */ TODO {
        typeVariable := getTypeParameterFromMappedType(mappedType)
         isDistributive(/* TODO(BinaryExpression): getNameTypeFromMappedType(mappedType) || typeVariable */ TODO)
        isDistributive := func(type_ Type) bool {
             /* TODO(ConditionalExpression): type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Primitive | TypeFlags.Never | TypeFlags.TypeParameter | TypeFlags.Object | TypeFlags.NonPrimitive) ? true :                 type.flags & TypeFlags.Conditional ? (type as ConditionalType).root.isDistributive && (type as ConditionalType).checkType === typeVariable :                 type.flags & (TypeFlags.UnionOrIntersection | TypeFlags.TemplateLiteral) ? every((type as UnionOrIntersectionType | TemplateLiteralType).types, isDistributive) :                 type.flags & TypeFlags.IndexedAccess ? isDistributive((type as IndexedAccessType).objectType) && isDistributive((type as IndexedAccessType).indexType) :                 type.flags & TypeFlags.Substitution ? isDistributive((type as SubstitutionType).baseType) && isDistributive((type as SubstitutionType).constraint) :                 type.flags & TypeFlags.StringMapping ? isDistributive((type as StringMappingType).type) :                 false */ TODO
        }
    }
    getLiteralTypeFromPropertyName := func(name /* TODO(UnionType): PropertyName | JsxAttributeName */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if isPrivateIdentifier(name) {
             neverType
        }
        if isNumericLiteral(name) {
             getRegularTypeOfLiteralType(checkExpression(name))
        }
        if isComputedPropertyName(name) {
             getRegularTypeOfLiteralType(checkComputedPropertyName(name))
        }
        propertyName := getPropertyNameForPropertyNameNode(name)
        if /* TODO(BinaryExpression): propertyName !== undefined */ TODO {
             getStringLiteralType(unescapeLeadingUnderscores(propertyName))
        }
        if isExpression(name) {
             getRegularTypeOfLiteralType(checkExpression(name))
        }
         neverType
    }
    getLiteralTypeFromProperty := func(prop Symbol, include TypeFlags, includeNonPublic bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(BinaryExpression): includeNonPublic || !(getDeclarationModifierFlagsFromSymbol(prop) & ModifierFlags.NonPublicAccessibilityModifier) */ TODO {
            type_ := /* TODO(PropertyAccessExpression): getSymbolLinks(getLateBoundSymbol(prop)).nameType */ TODO
            if /* TODO(PrefixUnaryExpression): !type */ TODO {
                name := getNameOfDeclaration(/* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO) /* as */ /* TODO(UnionType): PropertyName | JsxAttributeName */
                /* TODO(ExpressionStatement): type = prop.escapedName === InternalSymbolName.Default ? getStringLiteralType("default") :                     name && getLiteralTypeFromPropertyName(name) || (!isKnownSymbol(prop) ? getStringLiteralType(symbolName(prop)) : undefined); */
            }
            if /* TODO(BinaryExpression): type && type.flags & include */ TODO {
                 type_
            }
        }
         neverType
    }
    isKeyTypeIncluded := func(keyType Type, include TypeFlags) bool {
         /* TODO(PrefixUnaryExpression): !!(keyType.flags & include || keyType.flags & TypeFlags.Intersection && some((keyType as IntersectionType).types, t => isKeyTypeIncluded(t, include))) */ TODO
    }
    getLiteralTypeFromProperties := func(type_ Type, include TypeFlags, includeOrigin bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        origin := /* TODO(ConditionalExpression): includeOrigin && (getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference) || type.aliasSymbol) ? createOriginIndexType(type) : undefined */ TODO
        propertyTypes := map_(getPropertiesOfType(type_), /* TODO(ArrowFunction): prop => getLiteralTypeFromProperty(prop, include) */ TODO)
        indexKeyTypes := map_(getIndexInfosOfType(type_), /* TODO(ArrowFunction): info =>             info !== enumNumberIndexInfo && isKeyTypeIncluded(info.keyType, include) ?                 info.keyType === stringType && include & TypeFlags.Number ? stringOrNumberType : info.keyType : neverType */ TODO)
         getUnionType(concatenate(propertyTypes, indexKeyTypes), /* TODO(PropertyAccessExpression): UnionReduction.Literal */ TODO, undefined, undefined, origin)
    }
    shouldDeferIndexType := func(type_ Type, indexFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): IndexFlags.None */) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(type.flags & TypeFlags.InstantiableNonPrimitive ||             isGenericTupleType(type) ||             isGenericMappedType(type) && (!hasDistributiveNameType(type) || getMappedTypeNameTypeKind(type) === MappedTypeNameTypeKind.Remapping) ||             type.flags & TypeFlags.Union && !(indexFlags & IndexFlags.NoReducibleCheck) && isGenericReducibleType(type) ||             type.flags & TypeFlags.Intersection && maybeTypeOfKind(type, TypeFlags.Instantiable) && some((type as IntersectionType).types, isEmptyAnonymousObjectType)) */ TODO
    }
    getIndexType := func(type_ Type, indexFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): IndexFlags.None */) Type {
        /* TODO(ExpressionStatement): type = getReducedType(type); */
         /* TODO(ConditionalExpression): isNoInferType(type) ? getNoInferType(getIndexType((type as SubstitutionType).baseType, indexFlags)) :             shouldDeferIndexType(type, indexFlags) ? getIndexTypeForGenericType(type as InstantiableType | UnionOrIntersectionType, indexFlags) :             type.flags & TypeFlags.Union ? getIntersectionType(map((type as UnionType).types, t => getIndexType(t, indexFlags))) :             type.flags & TypeFlags.Intersection ? getUnionType(map((type as IntersectionType).types, t => getIndexType(t, indexFlags))) :             getObjectFlags(type) & ObjectFlags.Mapped ? getIndexTypeForMappedType(type as MappedType, indexFlags) :             type === wildcardType ? wildcardType :             type.flags & TypeFlags.Unknown ? neverType :             type.flags & (TypeFlags.Any | TypeFlags.Never) ? stringNumberSymbolType :             getLiteralTypeFromProperties(type, (indexFlags & IndexFlags.NoIndexSignatures ? TypeFlags.StringLiteral : TypeFlags.StringLike) | (indexFlags & IndexFlags.StringsOnly ? 0 : TypeFlags.NumberLike | TypeFlags.ESSymbolLike), indexFlags === IndexFlags.None) */ TODO
    }
    getExtractStringType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        extractTypeAlias := getGlobalExtractSymbol()
         /* TODO(ConditionalExpression): extractTypeAlias ? getTypeAliasInstantiation(extractTypeAlias, [type, stringType]) : stringType */ TODO
    }
    getIndexTypeOrString := func(type_ Type) Type {
        indexType := getExtractStringType(getIndexType(type_))
         /* TODO(ConditionalExpression): indexType.flags & TypeFlags.Never ? stringType : indexType */ TODO
    }
    getTypeFromTypeOperatorNode := func(node TypeOperatorNode) Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            /* TODO(SwitchStatement): switch (node.operator) {                 case SyntaxKind.KeyOfKeyword:                     links.resolvedType = getIndexType(getTypeFromTypeNode(node.type));                     break;                 case SyntaxKind.UniqueKeyword:                     links.resolvedType = node.type.kind === SyntaxKind.SymbolKeyword                         ? getESSymbolLikeTypeForNode(walkUpParenthesizedTypes(node.parent))                         : errorType;                     break;                 case SyntaxKind.ReadonlyKeyword:                     links.resolvedType = getTypeFromTypeNode(node.type);                     break;                 default:                     Debug.assertNever(node.operator);             } */
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    getTypeFromTemplateTypeNode := func(node TemplateLiteralTypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            /* TODO(ExpressionStatement): links.resolvedType = getTemplateLiteralType(                 [node.head.text, ...map(node.templateSpans, span => span.literal.text)],                 map(node.templateSpans, span => getTypeFromTypeNode(span.type)),             ); */
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    getTemplateLiteralType := func(texts []string, types []Type) Type {
        unionIndex := findIndex(types, /* TODO(ArrowFunction): t => !!(t.flags & (TypeFlags.Never | TypeFlags.Union)) */ TODO)
        if /* TODO(BinaryExpression): unionIndex >= 0 */ TODO {
             /* TODO(ConditionalExpression): checkCrossProductUnion(types) ?                 mapType(types[unionIndex], t => getTemplateLiteralType(texts, replaceElement(types, unionIndex, t))) :                 errorType */ TODO
        }
        if contains(types, wildcardType) {
             wildcardType
        }
        var newTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        var newTexts []string = /* TODO(ArrayLiteralExpression): [] */ TODO
        text := /* TODO(ElementAccessExpression): texts[0] */ TODO
        if /* TODO(PrefixUnaryExpression): !addSpans(texts, types) */ TODO {
             stringType
        }
        if /* TODO(BinaryExpression): newTypes.length === 0 */ TODO {
             getStringLiteralType(text)
        }
        /* TODO(ExpressionStatement): newTexts.push(text); */
        if every(newTexts, /* TODO(ArrowFunction): t => t === "" */ TODO) {
            if every(newTypes, /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.String) */ TODO) {
                 stringType
            }
            if /* TODO(BinaryExpression): newTypes.length === 1 && isPatternLiteralType(newTypes[0]) */ TODO {
                 /* TODO(ElementAccessExpression): newTypes[0] */ TODO
            }
        }
        id := /* TODO(TemplateExpression): `${getTypeListId(newTypes)}|${map(newTexts, t => t.length).join(",")}|${newTexts.join("")}` */ TODO
        type_ := /* TODO(PropertyAccessExpression): templateLiteralTypes.get */ TODO(id)
        if /* TODO(PrefixUnaryExpression): !type */ TODO {
            /* TODO(ExpressionStatement): templateLiteralTypes.set(id, type = createTemplateLiteralType(newTexts, newTypes)); */
        }
         type_
        addSpans := func(texts []string, types []Type) bool {
            /* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                 const t = types[i];                 if (t.flags & (TypeFlags.Literal | TypeFlags.Null | TypeFlags.Undefined)) {                     text += getTemplateStringForType(t) || "";                     text += texts[i + 1];                 }                 else if (t.flags & TypeFlags.TemplateLiteral) {                     text += (t as TemplateLiteralType).texts[0];                     if (!addSpans((t as TemplateLiteralType).texts, (t as TemplateLiteralType).types)) return false;                     text += texts[i + 1];                 }                 else if (isGenericIndexType(t) || isPatternLiteralPlaceholderType(t)) {                     newTypes.push(t);                     newTexts.push(text);                     text = texts[i + 1];                 }                 else {                     return false;                 }             } */
             /* TODO(TrueKeyword): true */ TODO
        }
    }
    getTemplateStringForType := func(type_ Type) /* TODO(undefined): string | undefined */ TODO {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.StringLiteral ? (type as StringLiteralType).value :             type.flags & TypeFlags.NumberLiteral ? "" + (type as NumberLiteralType).value :             type.flags & TypeFlags.BigIntLiteral ? pseudoBigIntToString((type as BigIntLiteralType).value) :             type.flags & (TypeFlags.BooleanLiteral | TypeFlags.Nullable) ? (type as IntrinsicType).intrinsicName :             undefined */ TODO
    }
    createTemplateLiteralType := func(texts []string, types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType */ TODO {
        type_ := createType(/* TODO(PropertyAccessExpression): TypeFlags.TemplateLiteral */ TODO) /* as */ /* TODO(TypeReference): TemplateLiteralType */
        /* TODO(ExpressionStatement): type.texts = texts; */
        /* TODO(ExpressionStatement): type.types = types; */
         type_
    }
    getStringMappingType := func(symbol Symbol, type_ Type) Type {
         /* TODO(ConditionalExpression): type.flags & (TypeFlags.Union | TypeFlags.Never) ? mapType(type, t => getStringMappingType(symbol, t)) :             type.flags & TypeFlags.StringLiteral ? getStringLiteralType(applyStringMapping(symbol, (type as StringLiteralType).value)) :             type.flags & TypeFlags.TemplateLiteral ? getTemplateLiteralType(...applyTemplateStringMapping(symbol, (type as TemplateLiteralType).texts, (type as TemplateLiteralType).types)) :             // Mapping<Mapping<T>> === Mapping<T>             type.flags & TypeFlags.StringMapping && symbol === type.symbol ? type :             type.flags & (TypeFlags.Any | TypeFlags.String | TypeFlags.StringMapping) || isGenericIndexType(type) ? getStringMappingTypeForGenericType(symbol, type) :             // This handles Mapping<`${number}`> and Mapping<`${bigint}`>             isPatternLiteralPlaceholderType(type) ? getStringMappingTypeForGenericType(symbol, getTemplateLiteralType(["", ""], [type])) :             type */ TODO
    }
    applyStringMapping := func(symbol Symbol, str string) /* TODO(undefined): string */ TODO {
        /* TODO(SwitchStatement): switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {             case IntrinsicTypeKind.Uppercase:                 return str.toUpperCase();             case IntrinsicTypeKind.Lowercase:                 return str.toLowerCase();             case IntrinsicTypeKind.Capitalize:                 return str.charAt(0).toUpperCase() + str.slice(1);             case IntrinsicTypeKind.Uncapitalize:                 return str.charAt(0).toLowerCase() + str.slice(1);         } */
         str
    }
    applyTemplateStringMapping := func(symbol Symbol, texts []string, types []Type) /* TODO(TupleType): [texts: readonly string[], types: readonly Type[]] */ TODO {
        /* TODO(SwitchStatement): switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {             case IntrinsicTypeKind.Uppercase:                 return [texts.map(t => t.toUpperCase()), types.map(t => getStringMappingType(symbol, t))];             case IntrinsicTypeKind.Lowercase:                 return [texts.map(t => t.toLowerCase()), types.map(t => getStringMappingType(symbol, t))];             case IntrinsicTypeKind.Capitalize:                 return [texts[0] === "" ? texts : [texts[0].charAt(0).toUpperCase() + texts[0].slice(1), ...texts.slice(1)], texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types];             case IntrinsicTypeKind.Uncapitalize:                 return [texts[0] === "" ? texts : [texts[0].charAt(0).toLowerCase() + texts[0].slice(1), ...texts.slice(1)], texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types];         } */
         /* TODO(ArrayLiteralExpression): [texts, types] */ TODO
    }
    getStringMappingTypeForGenericType := func(symbol Symbol, type_ Type) Type {
        id := /* TODO(TemplateExpression): `${getSymbolId(symbol)},${getTypeId(type)}` */ TODO
        result := /* TODO(PropertyAccessExpression): stringMappingTypes.get */ TODO(id)
        if /* TODO(PrefixUnaryExpression): !result */ TODO {
            /* TODO(ExpressionStatement): stringMappingTypes.set(id, result = createStringMappingType(symbol, type)); */
        }
         result
    }
    createStringMappingType := func(symbol Symbol, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringMappingType */ TODO {
        result := createTypeWithSymbol(/* TODO(PropertyAccessExpression): TypeFlags.StringMapping */ TODO, symbol) /* as */ /* TODO(TypeReference): StringMappingType */
        /* TODO(ExpressionStatement): result.type = type; */
         result
    }
    createIndexedAccessType := func(objectType Type, indexType Type, accessFlags AccessFlags, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexedAccessType */ TODO {
        type_ := createType(/* TODO(PropertyAccessExpression): TypeFlags.IndexedAccess */ TODO) /* as */ /* TODO(TypeReference): IndexedAccessType */
        /* TODO(ExpressionStatement): type.objectType = objectType; */
        /* TODO(ExpressionStatement): type.indexType = indexType; */
        /* TODO(ExpressionStatement): type.accessFlags = accessFlags; */
        /* TODO(ExpressionStatement): type.aliasSymbol = aliasSymbol; */
        /* TODO(ExpressionStatement): type.aliasTypeArguments = aliasTypeArguments; */
         type_
    }
    isJSLiteralType := func(type_ Type) bool {
        if noImplicitAny {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.JSLiteral */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
             every(/* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, isJSLiteralType)
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
             some(/* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, isJSLiteralType)
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Instantiable */ TODO {
            constraint := getResolvedBaseConstraint(type_)
             /* TODO(BinaryExpression): constraint !== type && isJSLiteralType(constraint) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    getPropertyNameFromIndex := func(indexType Type, accessNode /* TODO(UnionType): PropertyName | ObjectBindingPattern | ArrayBindingPattern | IndexedAccessTypeNode | ElementAccessExpression | SyntheticExpression | undefined */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
         /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(indexType) ?             getPropertyNameFromType(indexType) :             accessNode && isPropertyName(accessNode) ?             // late bound names are handled in the first branch, so here we only need to handle normal names             getPropertyNameForPropertyNameNode(accessNode) :             undefined */ TODO
    }
    isUncalledFunctionReference := func(node Node, symbol Symbol) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Function | SymbolFlags.Method) */ TODO {
            parent := /* TODO(BinaryExpression): findAncestor(node.parent, n => !isAccessExpression(n)) || node.parent */ TODO
            if isCallLikeExpression(parent) {
                 /* TODO(BinaryExpression): isCallOrNewExpression(parent) && isIdentifier(node) && hasMatchingArgument(parent, node) */ TODO
            }
             every(/* TODO(PropertyAccessExpression): symbol.declarations */ TODO, /* TODO(ArrowFunction): d => !isFunctionLike(d) || isDeprecatedDeclaration(d) */ TODO)
        }
         /* TODO(TrueKeyword): true */ TODO
    }
    getPropertyTypeForIndexType := func(originalObjectType Type, objectType Type, indexType Type, fullIndexType Type, accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression | undefined */ any, accessFlags AccessFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        accessExpression := /* TODO(ConditionalExpression): accessNode && accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode : undefined */ TODO
        propName := /* TODO(ConditionalExpression): accessNode && isPrivateIdentifier(accessNode) ? undefined : getPropertyNameFromIndex(indexType, accessNode) */ TODO
        if /* TODO(BinaryExpression): propName !== undefined */ TODO {
            if /* TODO(BinaryExpression): accessFlags & AccessFlags.Contextual */ TODO {
                 /* TODO(BinaryExpression): getTypeOfPropertyOfContextualType(objectType, propName) || anyType */ TODO
            }
            prop := getPropertyOfType(objectType, propName)
            if prop {
                if /* TODO(BinaryExpression): accessFlags & AccessFlags.ReportDeprecated && accessNode && prop.declarations && isDeprecatedSymbol(prop) && isUncalledFunctionReference(accessNode, prop) */ TODO {
                    deprecatedNode := /* TODO(BinaryExpression): accessExpression?.argumentExpression ?? (isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode) */ TODO
                    /* TODO(ExpressionStatement): addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName as string); */
                }
                if accessExpression {
                    /* TODO(ExpressionStatement): markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess(accessExpression.expression, objectType.symbol)); */
                    if isAssignmentToReadonlyEntity(accessExpression, prop, getAssignmentTargetKind(accessExpression)) {
                        /* TODO(ExpressionStatement): error(accessExpression.argumentExpression, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop)); */
                         undefined
                    }
                    if /* TODO(BinaryExpression): accessFlags & AccessFlags.CacheSymbol */ TODO {
                        /* TODO(ExpressionStatement): getNodeLinks(accessNode!).resolvedSymbol = prop; */
                    }
                    if isThisPropertyAccessInConstructor(accessExpression, prop) {
                         autoType
                    }
                }
                propType := /* TODO(ConditionalExpression): accessFlags & AccessFlags.Writing ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop) */ TODO
                 /* TODO(ConditionalExpression): accessExpression && getAssignmentTargetKind(accessExpression) !== AssignmentKind.Definite ? getFlowTypeOfReference(accessExpression, propType) :                     accessNode && isIndexedAccessTypeNode(accessNode) && containsMissingType(propType) ? getUnionType([propType, undefinedType]) :                     propType */ TODO
            }
            if /* TODO(BinaryExpression): everyType(objectType, isTupleType) && isNumericLiteralName(propName) */ TODO {
                index := /* TODO(PrefixUnaryExpression): +propName */ TODO
                if /* TODO(BinaryExpression): accessNode && everyType(objectType, t => !((t as TupleTypeReference).target.combinedFlags & ElementFlags.Variable)) && !(accessFlags & AccessFlags.AllowMissing) */ TODO {
                    indexNode := getIndexNodeForAccessExpression(accessNode)
                    if isTupleType(objectType) {
                        if /* TODO(BinaryExpression): index < 0 */ TODO {
                            /* TODO(ExpressionStatement): error(indexNode, Diagnostics.A_tuple_type_cannot_be_indexed_with_a_negative_value); */
                             undefinedType
                        }
                        /* TODO(ExpressionStatement): error(indexNode, Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2, typeToString(objectType), getTypeReferenceArity(objectType), unescapeLeadingUnderscores(propName)); */
                    } else {
                        /* TODO(ExpressionStatement): error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType)); */
                    }
                }
                if /* TODO(BinaryExpression): index >= 0 */ TODO {
                    /* TODO(ExpressionStatement): errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType)); */
                     getTupleElementTypeOutOfStartCount(objectType, index, /* TODO(ConditionalExpression): accessFlags & AccessFlags.IncludeUndefined ? missingType : undefined */ TODO)
                }
            }
        }
        if /* TODO(BinaryExpression): !(indexType.flags & TypeFlags.Nullable) && isTypeAssignableToKind(indexType, TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.ESSymbolLike) */ TODO {
            if /* TODO(BinaryExpression): objectType.flags & (TypeFlags.Any | TypeFlags.Never) */ TODO {
                 objectType
            }
            indexInfo := /* TODO(BinaryExpression): getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(objectType, stringType) */ TODO
            if indexInfo {
                if /* TODO(BinaryExpression): accessFlags & AccessFlags.NoIndexSignatures && indexInfo.keyType !== numberType */ TODO {
                    if accessExpression {
                        if /* TODO(BinaryExpression): accessFlags & AccessFlags.Writing */ TODO {
                            /* TODO(ExpressionStatement): error(accessExpression, Diagnostics.Type_0_is_generic_and_can_only_be_indexed_for_reading, typeToString(originalObjectType)); */
                        } else {
                            /* TODO(ExpressionStatement): error(accessExpression, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType)); */
                        }
                    }
                     undefined
                }
                if /* TODO(BinaryExpression): accessNode && indexInfo.keyType === stringType && !isTypeAssignableToKind(indexType, TypeFlags.String | TypeFlags.Number) */ TODO {
                    indexNode := getIndexNodeForAccessExpression(accessNode)
                    /* TODO(ExpressionStatement): error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType)); */
                     /* TODO(ConditionalExpression): accessFlags & AccessFlags.IncludeUndefined ? getUnionType([indexInfo.type, missingType]) : indexInfo.type */ TODO
                }
                /* TODO(ExpressionStatement): errorIfWritingToReadonlyIndex(indexInfo); */
                if /* TODO(BinaryExpression): (accessFlags & AccessFlags.IncludeUndefined) &&                     !(objectType.symbol &&                         objectType.symbol.flags & (SymbolFlags.RegularEnum | SymbolFlags.ConstEnum) &&                         (indexType.symbol &&                             indexType.flags & TypeFlags.EnumLiteral &&                             getParentOfSymbol(indexType.symbol) === objectType.symbol)) */ TODO {
                     getUnionType(/* TODO(ArrayLiteralExpression): [indexInfo.type, missingType] */ TODO)
                }
                 /* TODO(PropertyAccessExpression): indexInfo.type */ TODO
            }
            if /* TODO(BinaryExpression): indexType.flags & TypeFlags.Never */ TODO {
                 neverType
            }
            if isJSLiteralType(objectType) {
                 anyType
            }
            if /* TODO(BinaryExpression): accessExpression && !isConstEnumObjectType(objectType) */ TODO {
                if isObjectLiteralType(objectType) {
                    if /* TODO(BinaryExpression): noImplicitAny && indexType.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral) */ TODO {
                        /* TODO(ExpressionStatement): diagnostics.add(createDiagnosticForNode(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as StringLiteralType).value, typeToString(objectType))); */
                         undefinedType
                    } else if /* TODO(BinaryExpression): indexType.flags & (TypeFlags.Number | TypeFlags.String) */ TODO {
                        types := map_(/* TODO(PropertyAccessExpression): (objectType as ResolvedType).properties */ TODO, /* TODO(ArrowFunction): property => {                             return getTypeOfSymbol(property);                         } */ TODO)
                         getUnionType(append(types, undefinedType))
                    }
                }
                if /* TODO(BinaryExpression): objectType.symbol === globalThisSymbol && propName !== undefined && globalThisSymbol.exports!.has(propName) && (globalThisSymbol.exports!.get(propName)!.flags & SymbolFlags.BlockScoped) */ TODO {
                    /* TODO(ExpressionStatement): error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType)); */
                } else if /* TODO(BinaryExpression): noImplicitAny && !(accessFlags & AccessFlags.SuppressNoImplicitAnyError) */ TODO {
                    if /* TODO(BinaryExpression): propName !== undefined && typeHasStaticProperty(propName, objectType) */ TODO {
                        typeName := typeToString(objectType)
                        /* TODO(ExpressionStatement): error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName as string, typeName, typeName + "[" + getTextOfNode(accessExpression.argumentExpression) + "]"); */
                    } else if getIndexTypeOfType(objectType, numberType) {
                        /* TODO(ExpressionStatement): error(accessExpression.argumentExpression, Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number); */
                    } else {
                        var suggestion /* TODO(StringKeyword): string */ any
                        if /* TODO(BinaryExpression): propName !== undefined && (suggestion = getSuggestionForNonexistentProperty(propName as string, objectType)) */ TODO {
                            if /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
                                /* TODO(ExpressionStatement): error(accessExpression.argumentExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName as string, typeToString(objectType), suggestion); */
                            }
                        } else {
                            suggestion := getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType)
                            if /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
                                /* TODO(ExpressionStatement): error(accessExpression, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion); */
                            } else {
                                var errorInfo *DiagnosticMessageChain
                                if /* TODO(BinaryExpression): indexType.flags & TypeFlags.EnumLiteral */ TODO {
                                    /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(/*details* / undefined, Diagnostics.Property_0_does_not_exist_on_type_1, "[" + typeToString(indexType) + "]", typeToString(objectType)); */
                                } else if /* TODO(BinaryExpression): indexType.flags & TypeFlags.UniqueESSymbol */ TODO {
                                    symbolName := getFullyQualifiedName(/* TODO(PropertyAccessExpression): (indexType as UniqueESSymbolType).symbol */ TODO, accessExpression)
                                    /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(/*details* / undefined, Diagnostics.Property_0_does_not_exist_on_type_1, "[" + symbolName + "]", typeToString(objectType)); */
                                } else if /* TODO(BinaryExpression): indexType.flags & TypeFlags.StringLiteral */ TODO {
                                    /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(/*details* / undefined, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as StringLiteralType).value, typeToString(objectType)); */
                                } else if /* TODO(BinaryExpression): indexType.flags & TypeFlags.NumberLiteral */ TODO {
                                    /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(/*details* / undefined, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as NumberLiteralType).value, typeToString(objectType)); */
                                } else if /* TODO(BinaryExpression): indexType.flags & (TypeFlags.Number | TypeFlags.String) */ TODO {
                                    /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(/*details* / undefined, Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType)); */
                                }
                                /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(                                     errorInfo,                                     Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1,                                     typeToString(fullIndexType),                                     typeToString(objectType),                                 ); */
                                /* TODO(ExpressionStatement): diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(accessExpression), accessExpression, errorInfo)); */
                            }
                        }
                    }
                }
                 undefined
            }
        }
        if /* TODO(BinaryExpression): accessFlags & AccessFlags.AllowMissing && isObjectLiteralType(objectType) */ TODO {
             undefinedType
        }
        if isJSLiteralType(objectType) {
             anyType
        }
        if accessNode {
            indexNode := getIndexNodeForAccessExpression(accessNode)
            if /* TODO(BinaryExpression): indexNode.kind !== SyntaxKind.BigIntLiteral && indexType.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral) */ TODO {
                /* TODO(ExpressionStatement): error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, "" + (indexType as StringLiteralType | NumberLiteralType).value, typeToString(objectType)); */
            } else if /* TODO(BinaryExpression): indexType.flags & (TypeFlags.String | TypeFlags.Number) */ TODO {
                /* TODO(ExpressionStatement): error(indexNode, Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType)); */
            } else {
                typeString := /* TODO(ConditionalExpression): indexNode.kind === SyntaxKind.BigIntLiteral ? "bigint" : typeToString(indexType) */ TODO
                /* TODO(ExpressionStatement): error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeString); */
            }
        }
        if isTypeAny(indexType) {
             indexType
        }
         undefined
        errorIfWritingToReadonlyIndex := func(indexInfo *IndexInfo) {
            if /* TODO(BinaryExpression): indexInfo && indexInfo.isReadonly && accessExpression && (isAssignmentTarget(accessExpression) || isDeleteTarget(accessExpression)) */ TODO {
                /* TODO(ExpressionStatement): error(accessExpression, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType)); */
            }
        }
    }
    getIndexNodeForAccessExpression := func(accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectBindingPattern | import("/home/jabaile/work/TypeScript/src/compiler/types").ArrayBindingPattern | import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
         /* TODO(ConditionalExpression): accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode.argumentExpression :             accessNode.kind === SyntaxKind.IndexedAccessType ? accessNode.indexType :             accessNode.kind === SyntaxKind.ComputedPropertyName ? accessNode.expression :             accessNode */ TODO
    }
    isPatternLiteralPlaceholderType := func(type_ Type) bool {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
            seenPlaceholder := /* TODO(FalseKeyword): false */ TODO
            /* TODO(ForOfStatement): for (const t of (type as IntersectionType).types) {                 if (t.flags & (TypeFlags.Literal | TypeFlags.Nullable) || isPatternLiteralPlaceholderType(t)) {                     seenPlaceholder = true;                 }                 else if (!(t.flags & TypeFlags.Object)) {                     return false;                 }             } */
             seenPlaceholder
        }
         /* TODO(BinaryExpression): !!(type.flags & (TypeFlags.Any | TypeFlags.String | TypeFlags.Number | TypeFlags.BigInt)) || isPatternLiteralType(type) */ TODO
    }
    isPatternLiteralType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !!(type.flags & TypeFlags.TemplateLiteral) && every((type as TemplateLiteralType).types, isPatternLiteralPlaceholderType) ||             !!(type.flags & TypeFlags.StringMapping) && isPatternLiteralPlaceholderType((type as StringMappingType).type) */ TODO
    }
    isGenericStringLikeType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !!(type.flags & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping)) && !isPatternLiteralType(type) */ TODO
    }
    isGenericType := func(type_ Type) bool {
         /* TODO(PrefixUnaryExpression): !!getGenericObjectFlags(type) */ TODO
    }
    isGenericObjectType := func(type_ Type) bool {
         /* TODO(PrefixUnaryExpression): !!(getGenericObjectFlags(type) & ObjectFlags.IsGenericObjectType) */ TODO
    }
    isGenericIndexType := func(type_ Type) bool {
         /* TODO(PrefixUnaryExpression): !!(getGenericObjectFlags(type) & ObjectFlags.IsGenericIndexType) */ TODO
    }
    getGenericObjectFlags := func(type_ Type) ObjectFlags {
        if /* TODO(BinaryExpression): type.flags & (TypeFlags.UnionOrIntersection) */ TODO {
            if /* TODO(PrefixUnaryExpression): !((type as UnionOrIntersectionType).objectFlags & ObjectFlags.IsGenericTypeComputed) */ TODO {
                /* TODO(ExpressionStatement): (type as UnionOrIntersectionType).objectFlags |= ObjectFlags.IsGenericTypeComputed |                     reduceLeft((type as UnionOrIntersectionType).types, (flags, t) => flags | getGenericObjectFlags(t), 0); */
            }
             /* TODO(BinaryExpression): (type as UnionOrIntersectionType).objectFlags & ObjectFlags.IsGenericType */ TODO
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Substitution */ TODO {
            if /* TODO(PrefixUnaryExpression): !((type as SubstitutionType).objectFlags & ObjectFlags.IsGenericTypeComputed) */ TODO {
                /* TODO(ExpressionStatement): (type as SubstitutionType).objectFlags |= ObjectFlags.IsGenericTypeComputed |                     getGenericObjectFlags((type as SubstitutionType).baseType) | getGenericObjectFlags((type as SubstitutionType).constraint); */
            }
             /* TODO(BinaryExpression): (type as SubstitutionType).objectFlags & ObjectFlags.IsGenericType */ TODO
        }
         /* TODO(BinaryExpression): (type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(type) || isGenericTupleType(type) ? ObjectFlags.IsGenericObjectType : 0) |             (type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.Index) || isGenericStringLikeType(type) ? ObjectFlags.IsGenericIndexType : 0) */ TODO
    }
    getSimplifiedType := func(type_ Type, writing bool) Type {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.IndexedAccess ? getSimplifiedIndexedAccessType(type as IndexedAccessType, writing) :             type.flags & TypeFlags.Conditional ? getSimplifiedConditionalType(type as ConditionalType, writing) :             type */ TODO
    }
    distributeIndexOverObjectType := func(objectType Type, indexType Type, writing bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(BinaryExpression): objectType.flags & TypeFlags.Union || objectType.flags & TypeFlags.Intersection && !shouldDeferIndexType(objectType) */ TODO {
            types := map_(/* TODO(PropertyAccessExpression): (objectType as UnionOrIntersectionType).types */ TODO, /* TODO(ArrowFunction): t => getSimplifiedType(getIndexedAccessType(t, indexType), writing) */ TODO)
             /* TODO(ConditionalExpression): objectType.flags & TypeFlags.Intersection || writing ? getIntersectionType(types) : getUnionType(types) */ TODO
        }
    }
    distributeObjectOverIndexType := func(objectType Type, indexType Type, writing bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(BinaryExpression): indexType.flags & TypeFlags.Union */ TODO {
            types := map_(/* TODO(PropertyAccessExpression): (indexType as UnionType).types */ TODO, /* TODO(ArrowFunction): t => getSimplifiedType(getIndexedAccessType(objectType, t), writing) */ TODO)
             /* TODO(ConditionalExpression): writing ? getIntersectionType(types) : getUnionType(types) */ TODO
        }
    }
    getSimplifiedIndexedAccessType := func(type_ IndexedAccessType, writing bool) Type {
        cache := /* TODO(ConditionalExpression): writing ? "simplifiedForWriting" : "simplifiedForReading" */ TODO
        if /* TODO(ElementAccessExpression): type[cache] */ TODO {
             /* TODO(ConditionalExpression): type[cache] === circularConstraintType ? type : type[cache] */ TODO
        }
        /* TODO(ExpressionStatement): type[cache] = circularConstraintType; */
        objectType := getSimplifiedType(/* TODO(PropertyAccessExpression): type.objectType */ TODO, writing)
        indexType := getSimplifiedType(/* TODO(PropertyAccessExpression): type.indexType */ TODO, writing)
        distributedOverIndex := distributeObjectOverIndexType(objectType, indexType, writing)
        if distributedOverIndex {
             /* TODO(BinaryExpression): type[cache] = distributedOverIndex */ TODO
        }
        if /* TODO(PrefixUnaryExpression): !(indexType.flags & TypeFlags.Instantiable) */ TODO {
            distributedOverObject := distributeIndexOverObjectType(objectType, indexType, writing)
            if distributedOverObject {
                 /* TODO(BinaryExpression): type[cache] = distributedOverObject */ TODO
            }
        }
        if /* TODO(BinaryExpression): isGenericTupleType(objectType) && indexType.flags & TypeFlags.NumberLike */ TODO {
            elementType := getElementTypeOfSliceOfTupleType(objectType, /* TODO(ConditionalExpression): indexType.flags & TypeFlags.Number ? 0 : objectType.target.fixedLength */ TODO, 0, writing)
            if elementType {
                 /* TODO(BinaryExpression): type[cache] = elementType */ TODO
            }
        }
        if isGenericMappedType(objectType) {
            if /* TODO(BinaryExpression): getMappedTypeNameTypeKind(objectType) !== MappedTypeNameTypeKind.Remapping */ TODO {
                 /* TODO(BinaryExpression): type[cache] = mapType(substituteIndexedMappedType(objectType, type.indexType), t => getSimplifiedType(t, writing)) */ TODO
            }
        }
         /* TODO(BinaryExpression): type[cache] = type */ TODO
    }
    getSimplifiedConditionalType := func(type_ ConditionalType, writing bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        checkType := /* TODO(PropertyAccessExpression): type.checkType */ TODO
        extendsType := /* TODO(PropertyAccessExpression): type.extendsType */ TODO
        trueType := getTrueTypeFromConditionalType(type_)
        falseType := getFalseTypeFromConditionalType(type_)
        if /* TODO(BinaryExpression): falseType.flags & TypeFlags.Never && getActualTypeVariable(trueType) === getActualTypeVariable(checkType) */ TODO {
            if /* TODO(BinaryExpression): checkType.flags & TypeFlags.Any || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType)) */ TODO {
                 getSimplifiedType(trueType, writing)
            } else if isIntersectionEmpty(checkType, extendsType) {
                 neverType
            }
        } else if /* TODO(BinaryExpression): trueType.flags & TypeFlags.Never && getActualTypeVariable(falseType) === getActualTypeVariable(checkType) */ TODO {
            if /* TODO(BinaryExpression): !(checkType.flags & TypeFlags.Any) && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType)) */ TODO {
                 neverType
            } else if /* TODO(BinaryExpression): checkType.flags & TypeFlags.Any || isIntersectionEmpty(checkType, extendsType) */ TODO {
                 getSimplifiedType(falseType, writing)
            }
        }
         type_
    }
    isIntersectionEmpty := func(type1 Type, type2 Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(getUnionType([intersectTypes(type1, type2), neverType]).flags & TypeFlags.Never) */ TODO
    }
    substituteIndexedMappedType := func(objectType MappedType, index Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        mapper := createTypeMapper(/* TODO(ArrayLiteralExpression): [getTypeParameterFromMappedType(objectType)] */ TODO, /* TODO(ArrayLiteralExpression): [index] */ TODO)
        templateMapper := combineTypeMappers(/* TODO(PropertyAccessExpression): objectType.mapper */ TODO, mapper)
        instantiatedTemplateType := instantiateType(getTemplateTypeFromMappedType(/* TODO(BinaryExpression): objectType.target as MappedType || objectType */ TODO), templateMapper)
        isOptional := /* TODO(BinaryExpression): getMappedTypeOptionality(objectType) > 0 || (isGenericType(objectType) ?             getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(objectType)) > 0 :             couldAccessOptionalProperty(objectType, index)) */ TODO
         addOptionality(instantiatedTemplateType, /* TODO(TrueKeyword): true */ TODO, isOptional)
    }
    couldAccessOptionalProperty := func(objectType Type, indexType Type) /* TODO(undefined): boolean */ TODO {
        indexConstraint := getBaseConstraintOfType(indexType)
         /* TODO(BinaryExpression): !!indexConstraint && some(getPropertiesOfType(objectType), p =>             !!(p.flags & SymbolFlags.Optional) &&             isTypeAssignableTo(getLiteralTypeFromProperty(p, TypeFlags.StringOrNumberLiteralOrUnique), indexConstraint)) */ TODO
    }
    getIndexedAccessType := func(objectType Type, indexType Type, accessFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").AccessFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): AccessFlags.None */, accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
         /* TODO(BinaryExpression): getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || (accessNode ? errorType : unknownType) */ TODO
    }
    indexTypeLessThan := func(indexType Type, limit number) /* TODO(undefined): boolean */ TODO {
         everyType(indexType, /* TODO(ArrowFunction): t => {             if (t.flags & TypeFlags.StringOrNumberLiteral) {                 const propName = getPropertyNameFromType(t as StringLiteralType | NumberLiteralType);                 if (isNumericLiteralName(propName)) {                     const index = +propName;                     return index >= 0 && index < limit;                 }             }             return false;         } */ TODO)
    }
    getIndexedAccessTypeOrUndefined := func(objectType Type, indexType Type, accessFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").AccessFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): AccessFlags.None */, accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) *Type {
        if /* TODO(BinaryExpression): objectType === wildcardType || indexType === wildcardType */ TODO {
             wildcardType
        }
        /* TODO(ExpressionStatement): objectType = getReducedType(objectType); */
        if /* TODO(BinaryExpression): isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & TypeFlags.Nullable) && isTypeAssignableToKind(indexType, TypeFlags.String | TypeFlags.Number) */ TODO {
            /* TODO(ExpressionStatement): indexType = stringType; */
        }
        if /* TODO(BinaryExpression): compilerOptions.noUncheckedIndexedAccess && accessFlags & AccessFlags.ExpressionPosition */ TODO {
            /* TODO(BinaryExpression): accessFlags |= AccessFlags.IncludeUndefined */
        }
        if /* TODO(BinaryExpression): isGenericIndexType(indexType) || (accessNode && accessNode.kind !== SyntaxKind.IndexedAccessType ?                 isGenericTupleType(objectType) && !indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target)) :                 isGenericObjectType(objectType) && !(isTupleType(objectType) && indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target))) || isGenericReducibleType(objectType)) */ TODO {
            if /* TODO(BinaryExpression): objectType.flags & TypeFlags.AnyOrUnknown */ TODO {
                 objectType
            }
            persistentAccessFlags := /* TODO(BinaryExpression): accessFlags & AccessFlags.Persistent */ TODO
            id := /* TODO(BinaryExpression): objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
            type_ := /* TODO(PropertyAccessExpression): indexedAccessTypes.get */ TODO(id)
            if /* TODO(PrefixUnaryExpression): !type */ TODO {
                /* TODO(ExpressionStatement): indexedAccessTypes.set(id, type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments)); */
            }
             type_
        }
        apparentObjectType := getReducedApparentType(objectType)
        if /* TODO(BinaryExpression): indexType.flags & TypeFlags.Union && !(indexType.flags & TypeFlags.Boolean) */ TODO {
            var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
            wasMissingProp := /* TODO(FalseKeyword): false */ TODO
            /* TODO(ForOfStatement): for (const t of (indexType as UnionType).types) {                 const propType = getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags | (wasMissingProp ? AccessFlags.SuppressNoImplicitAnyError : 0));                 if (propType) {                     propTypes.push(propType);                 }                 else if (!accessNode) {                     // If there's no error node, we can immeditely stop, since error reporting is off                     return undefined;                 }                 else {                     // Otherwise we set a flag and return at the end of the loop so we still mark all errors                     wasMissingProp = true;                 }             } */
            if wasMissingProp {
                 undefined
            }
             /* TODO(ConditionalExpression): accessFlags & AccessFlags.Writing                 ? getIntersectionType(propTypes, IntersectionFlags.None, aliasSymbol, aliasTypeArguments)                 : getUnionType(propTypes, UnionReduction.Literal, aliasSymbol, aliasTypeArguments) */ TODO
        }
         getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode, /* TODO(BinaryExpression): accessFlags | AccessFlags.CacheSymbol | AccessFlags.ReportDeprecated */ TODO)
    }
    getTypeFromIndexedAccessTypeNode := func(node IndexedAccessTypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            objectType := getTypeFromTypeNode(/* TODO(PropertyAccessExpression): node.objectType */ TODO)
            indexType := getTypeFromTypeNode(/* TODO(PropertyAccessExpression): node.indexType */ TODO)
            potentialAlias := getAliasSymbolForTypeNode(node)
            /* TODO(ExpressionStatement): links.resolvedType = getIndexedAccessType(objectType, indexType, AccessFlags.None, node, potentialAlias, getTypeArgumentsForAliasSymbol(potentialAlias)); */
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    getTypeFromMappedTypeNode := func(node MappedTypeNode) Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            type_ := createObjectType(/* TODO(PropertyAccessExpression): ObjectFlags.Mapped */ TODO, /* TODO(PropertyAccessExpression): node.symbol */ TODO) /* as */ /* TODO(TypeReference): MappedType */
            /* TODO(ExpressionStatement): type.declaration = node; */
            /* TODO(ExpressionStatement): type.aliasSymbol = getAliasSymbolForTypeNode(node); */
            /* TODO(ExpressionStatement): type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type.aliasSymbol); */
            /* TODO(ExpressionStatement): links.resolvedType = type; */
            /* TODO(ExpressionStatement): getConstraintTypeFromMappedType(type); */
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    getActualTypeVariable := func(type_ Type) Type {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Substitution */ TODO {
             getActualTypeVariable(/* TODO(PropertyAccessExpression): (type as SubstitutionType).baseType */ TODO)
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.IndexedAccess && (                 (type as IndexedAccessType).objectType.flags & TypeFlags.Substitution ||                 (type as IndexedAccessType).indexType.flags & TypeFlags.Substitution             ) */ TODO {
             getIndexedAccessType(getActualTypeVariable(/* TODO(PropertyAccessExpression): (type as IndexedAccessType).objectType */ TODO), getActualTypeVariable(/* TODO(PropertyAccessExpression): (type as IndexedAccessType).indexType */ TODO))
        }
         type_
    }
    isSimpleTupleType := func(node TypeNode) bool {
         /* TODO(BinaryExpression): isTupleTypeNode(node) && length(node.elements) > 0 &&             !some(node.elements, e => isOptionalTypeNode(e) || isRestTypeNode(e) || isNamedTupleMember(e) && !!(e.questionToken || e.dotDotDotToken)) */ TODO
    }
    isDeferredType := func(type_ Type, checkTuples bool) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isGenericType(type) || checkTuples && isTupleType(type) && some(getElementTypes(type), isGenericType) */ TODO
    }
    getConditionalType := func(root ConditionalRoot, mapper *TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
        result
        var extraTypes /* TODO(ArrayType): Type[] */ any
        tailCount := 0
        /* TODO(WhileStatement): while (true) {             if (tailCount === 1000) {                 error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);                 return errorType;             }             const checkType = instantiateType(getActualTypeVariable(root.checkType), mapper);             const extendsType = instantiateType(root.extendsType, mapper);             if (checkType === errorType || extendsType === errorType) {                 return errorType;             }             if (checkType === wildcardType || extendsType === wildcardType) {                 return wildcardType;             }             const checkTypeNode = skipTypeParentheses(root.node.checkType);             const extendsTypeNode = skipTypeParentheses(root.node.extendsType);             // When the check and extends types are simple tuple types of the same arity, we defer resolution of the             // conditional type when any tuple elements are generic. This is such that non-distributable conditional             // types can be written `[X] extends [Y] ? ...` and be deferred similarly to `X extends Y ? ...`.             const checkTuples = isSimpleTupleType(checkTypeNode) && isSimpleTupleType(extendsTypeNode) &&                 length((checkTypeNode as TupleTypeNode).elements) === length((extendsTypeNode as TupleTypeNode).elements);             const checkTypeDeferred = isDeferredType(checkType, checkTuples);             let combinedMapper: TypeMapper | undefined;             if (root.inferTypeParameters) {                 // When we're looking at making an inference for an infer type, when we get its constraint, it'll automagically be                 // instantiated with the context, so it doesn't need the mapper for the inference context - however the constraint                 // may refer to another _root_, _uncloned_ `infer` type parameter [1], or to something mapped by `mapper` [2].                 // [1] Eg, if we have `Foo<T, U extends T>` and `Foo<number, infer B>` - `B` is constrained to `T`, which, in turn, has been instantiated                 // as `number`                 // Conversely, if we have `Foo<infer A, infer B>`, `B` is still constrained to `T` and `T` is instantiated as `A`                 // [2] Eg, if we have `Foo<T, U extends T>` and `Foo<Q, infer B>` where `Q` is mapped by `mapper` into `number` - `B` is constrained to `T`                 // which is in turn instantiated as `Q`, which is in turn instantiated as `number`.                 // So we need to:                 //    * combine `context.nonFixingMapper` with `mapper` so their constraints can be instantiated in the context of `mapper` (otherwise they'd only get inference context information)                 //    * incorporate all of the component mappers into the combined mapper for the true and false members                 // This means we have two mappers that need applying:                 //    * The original `mapper` used to create this conditional                 //    * The mapper that maps the infer type parameter to its inference result (`context.mapper`)                 const context = createInferenceContext(root.inferTypeParameters, /*signature* / undefined, InferenceFlags.None);                 if (mapper) {                     context.nonFixingMapper = combineTypeMappers(context.nonFixingMapper, mapper);                 }                 if (!checkTypeDeferred) {                     // We don't want inferences from constraints as they may cause us to eagerly resolve the                     // conditional type instead of deferring resolution. Also, we always want strict function                     // types rules (i.e. proper contravariance) for inferences.                     inferTypes(context.inferences, checkType, extendsType, InferencePriority.NoConstraints | InferencePriority.AlwaysStrict);                 }                 // It's possible for 'infer T' type paramteters to be given uninstantiated constraints when the                 // those type parameters are used in type references (see getInferredTypeParameterConstraint). For                 // that reason we need context.mapper to be first in the combined mapper. See #42636 for examples.                 combinedMapper = mapper ? combineTypeMappers(context.mapper, mapper) : context.mapper;             }             // Instantiate the extends type including inferences for 'infer T' type parameters             const inferredExtendsType = combinedMapper ? instantiateType(root.extendsType, combinedMapper) : extendsType;             // We attempt to resolve the conditional type only when the check and extends types are non-generic             if (!checkTypeDeferred && !isDeferredType(inferredExtendsType, checkTuples)) {                 // Return falseType for a definitely false extends check. We check an instantiations of the two                 // types with type parameters mapped to the wildcard type, the most permissive instantiations                 // possible (the wildcard type is assignable to and from all types). If those are not related,                 // then no instantiations will be and we can just return the false branch type.                 if (!(inferredExtendsType.flags & TypeFlags.AnyOrUnknown) && (checkType.flags & TypeFlags.Any || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType)))) {                     // Return union of trueType and falseType for 'any' since it matches anything. Furthermore, for a                     // distributive conditional type applied to the constraint of a type variable, include trueType if                     // there are possible values of the check type that are also possible values of the extends type.                     // We use a reverse assignability check as it is less expensive than the comparable relationship                     // and avoids false positives of a non-empty intersection check.                     if (checkType.flags & TypeFlags.Any || forConstraint && !(inferredExtendsType.flags & TypeFlags.Never) && someType(getPermissiveInstantiation(inferredExtendsType), t => isTypeAssignableTo(t, getPermissiveInstantiation(checkType)))) {                         (extraTypes || (extraTypes = [])).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper));                     }                     // If falseType is an immediately nested conditional type that isn't distributive or has an                     // identical checkType, switch to that type and loop.                     const falseType = getTypeFromTypeNode(root.node.falseType);                     if (falseType.flags & TypeFlags.Conditional) {                         const newRoot = (falseType as ConditionalType).root;                         if (newRoot.node.parent === root.node && (!newRoot.isDistributive || newRoot.checkType === root.checkType)) {                             root = newRoot;                             continue;                         }                         if (canTailRecurse(falseType, mapper)) {                             continue;                         }                     }                     result = instantiateType(falseType, mapper);                     break;                 }                 // Return trueType for a definitely true extends check. We check instantiations of the two                 // types with type parameters mapped to their restrictive form, i.e. a form of the type parameter                 // that has no constraint. This ensures that, for example, the type                 //   type Foo<T extends { x: any }> = T extends { x: string } ? string : number                 // doesn't immediately resolve to 'string' instead of being deferred.                 if (inferredExtendsType.flags & TypeFlags.AnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType))) {                     const trueType = getTypeFromTypeNode(root.node.trueType);                     const trueMapper = combinedMapper || mapper;                     if (canTailRecurse(trueType, trueMapper)) {                         continue;                     }                     result = instantiateType(trueType, trueMapper);                     break;                 }             }             // Return a deferred type for a check that is neither definitely true nor definitely false             result = createType(TypeFlags.Conditional) as ConditionalType;             result.root = root;             result.checkType = instantiateType(root.checkType, mapper);             result.extendsType = instantiateType(root.extendsType, mapper);             result.mapper = mapper;             result.combinedMapper = combinedMapper;             result.aliasSymbol = aliasSymbol || root.aliasSymbol;             result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(root.aliasTypeArguments, mapper!); // TODO: GH#18217             break;         } */
         /* TODO(ConditionalExpression): extraTypes ? getUnionType(append(extraTypes, result)) : result */ TODO
        canTailRecurse := func(newType Type, newMapper *TypeMapper) /* TODO(undefined): boolean */ TODO {
            if /* TODO(BinaryExpression): newType.flags & TypeFlags.Conditional && newMapper */ TODO {
                newRoot := /* TODO(PropertyAccessExpression): (newType as ConditionalType).root */ TODO
                if /* TODO(PropertyAccessExpression): newRoot.outerTypeParameters */ TODO {
                    typeParamMapper := combineTypeMappers(/* TODO(PropertyAccessExpression): (newType as ConditionalType).mapper */ TODO, newMapper)
                    typeArguments := map_(/* TODO(PropertyAccessExpression): newRoot.outerTypeParameters */ TODO, /* TODO(ArrowFunction): t => getMappedType(t, typeParamMapper) */ TODO)
                    newRootMapper := createTypeMapper(/* TODO(PropertyAccessExpression): newRoot.outerTypeParameters */ TODO, typeArguments)
                    newCheckType := /* TODO(ConditionalExpression): newRoot.isDistributive ? getMappedType(newRoot.checkType, newRootMapper) : undefined */ TODO
                    if /* TODO(BinaryExpression): !newCheckType || newCheckType === newRoot.checkType || !(newCheckType.flags & (TypeFlags.Union | TypeFlags.Never)) */ TODO {
                        /* TODO(ExpressionStatement): root = newRoot; */
                        /* TODO(ExpressionStatement): mapper = newRootMapper; */
                        /* TODO(ExpressionStatement): aliasSymbol = undefined; */
                        /* TODO(ExpressionStatement): aliasTypeArguments = undefined; */
                        if /* TODO(PropertyAccessExpression): newRoot.aliasSymbol */ TODO {
                            /* TODO(ExpressionStatement): tailCount++; */
                        }
                         /* TODO(TrueKeyword): true */ TODO
                    }
                }
            }
             /* TODO(FalseKeyword): false */ TODO
        }
    }
    getTrueTypeFromConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(BinaryExpression): type.resolvedTrueType || (type.resolvedTrueType = instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.mapper)) */ TODO
    }
    getFalseTypeFromConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(BinaryExpression): type.resolvedFalseType || (type.resolvedFalseType = instantiateType(getTypeFromTypeNode(type.root.node.falseType), type.mapper)) */ TODO
    }
    getInferredTrueTypeFromConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(BinaryExpression): type.resolvedInferredTrueType || (type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.combinedMapper) : getTrueTypeFromConditionalType(type)) */ TODO
    }
    getInferTypeParameters := func(node ConditionalTypeNode) /* TODO(ArrayType): TypeParameter[] */ any {
        var result /* TODO(ArrayType): TypeParameter[] */ any
        if /* TODO(PropertyAccessExpression): node.locals */ TODO {
            /* TODO(ExpressionStatement): node.locals.forEach(symbol => {                 if (symbol.flags & SymbolFlags.TypeParameter) {                     result = append(result, getDeclaredTypeOfSymbol(symbol));                 }             }); */
        }
         result
    }
    isDistributionDependent := func(root ConditionalRoot) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): root.isDistributive && (             isTypeParameterPossiblyReferenced(root.checkType as TypeParameter, root.node.trueType) ||             isTypeParameterPossiblyReferenced(root.checkType as TypeParameter, root.node.falseType)         ) */ TODO
    }
    getTypeFromConditionalTypeNode := func(node ConditionalTypeNode) Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            checkType := getTypeFromTypeNode(/* TODO(PropertyAccessExpression): node.checkType */ TODO)
            aliasSymbol := getAliasSymbolForTypeNode(node)
            aliasTypeArguments := getTypeArgumentsForAliasSymbol(aliasSymbol)
            allOuterTypeParameters := getOuterTypeParameters(node, /* TODO(TrueKeyword): true */ TODO)
            outerTypeParameters := /* TODO(ConditionalExpression): aliasTypeArguments ? allOuterTypeParameters : filter(allOuterTypeParameters, tp => isTypeParameterPossiblyReferenced(tp, node)) */ TODO
            var root ConditionalRoot = /* TODO(ObjectLiteralExpression): {                 node,                 checkType,                 extendsType: getTypeFromTypeNode(node.extendsType),                 isDistributive: !!(checkType.flags & TypeFlags.TypeParameter),                 inferTypeParameters: getInferTypeParameters(node),                 outerTypeParameters,                 instantiations: undefined,                 aliasSymbol,                 aliasTypeArguments,             } */ TODO
            /* TODO(ExpressionStatement): links.resolvedType = getConditionalType(root, /*mapper* / undefined, /*forConstraint* / false); */
            if outerTypeParameters {
                /* TODO(ExpressionStatement): root.instantiations = new Map<string, Type>(); */
                /* TODO(ExpressionStatement): root.instantiations.set(getTypeListId(outerTypeParameters), links.resolvedType); */
            }
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    getTypeFromInferTypeNode := func(node InferTypeNode) Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            /* TODO(ExpressionStatement): links.resolvedType = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter)); */
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    getIdentifierChain := func(node EntityName) []Identifier {
        if isIdentifier(node) {
             /* TODO(ArrayLiteralExpression): [node] */ TODO
        } else {
             append(getIdentifierChain(/* TODO(PropertyAccessExpression): node.left */ TODO), /* TODO(PropertyAccessExpression): node.right */ TODO)
        }
    }
    getTypeFromImportTypeNode := func(node ImportTypeNode) Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            if /* TODO(PrefixUnaryExpression): !isLiteralImportTypeNode(node) */ TODO {
                /* TODO(ExpressionStatement): error(node.argument, Diagnostics.String_literal_expected); */
                /* TODO(ExpressionStatement): links.resolvedSymbol = unknownSymbol; */
                 /* TODO(BinaryExpression): links.resolvedType = errorType */ TODO
            }
            targetMeaning := /* TODO(ConditionalExpression): node.isTypeOf ? SymbolFlags.Value : node.flags & NodeFlags.JSDoc ? SymbolFlags.Value | SymbolFlags.Type : SymbolFlags.Type */ TODO
            innerModuleSymbol := resolveExternalModuleName(node, /* TODO(PropertyAccessExpression): node.argument.literal */ TODO)
            if /* TODO(PrefixUnaryExpression): !innerModuleSymbol */ TODO {
                /* TODO(ExpressionStatement): links.resolvedSymbol = unknownSymbol; */
                 /* TODO(BinaryExpression): links.resolvedType = errorType */ TODO
            }
            isExportEquals := /* TODO(PrefixUnaryExpression): !!innerModuleSymbol.exports?.get(InternalSymbolName.ExportEquals) */ TODO
            moduleSymbol := resolveExternalModuleSymbol(innerModuleSymbol, /* TODO(FalseKeyword): false */ TODO)
            if /* TODO(PrefixUnaryExpression): !nodeIsMissing(node.qualifier) */ TODO {
                var nameStack []Identifier = getIdentifierChain(/* TODO(NonNullExpression): node.qualifier! */ TODO)
                currentNamespace := moduleSymbol
                var current *Identifier
                /* TODO(WhileStatement): while (current = nameStack.shift()) {                     const meaning = nameStack.length ? SymbolFlags.Namespace : targetMeaning;                     // typeof a.b.c is normally resolved using `checkExpression` which in turn defers to `checkQualifiedName`                     // That, in turn, ultimately uses `getPropertyOfType` on the type of the symbol, which differs slightly from                     // the `exports` lookup process that only looks up namespace members which is used for most type references                     const mergedResolvedSymbol = getMergedSymbol(resolveSymbol(currentNamespace));                     const symbolFromVariable = node.isTypeOf || isInJSFile(node) && isExportEquals                         ? getPropertyOfType(getTypeOfSymbol(mergedResolvedSymbol), current.escapedText, /*skipObjectFunctionPropertyAugment* / false, /*includeTypeOnlyMembers* / true)                         : undefined;                     const symbolFromModule = node.isTypeOf ? undefined : getSymbol(getExportsOfSymbol(mergedResolvedSymbol), current.escapedText, meaning);                     const next = symbolFromModule ?? symbolFromVariable;                     if (!next) {                         error(current, Diagnostics.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(currentNamespace), declarationNameToString(current));                         return links.resolvedType = errorType;                     }                     getNodeLinks(current).resolvedSymbol = next;                     getNodeLinks(current.parent).resolvedSymbol = next;                     currentNamespace = next;                 } */
                /* TODO(ExpressionStatement): links.resolvedType = resolveImportSymbolType(node, links, currentNamespace, targetMeaning); */
            } else {
                if /* TODO(BinaryExpression): moduleSymbol.flags & targetMeaning */ TODO {
                    /* TODO(ExpressionStatement): links.resolvedType = resolveImportSymbolType(node, links, moduleSymbol, targetMeaning); */
                } else {
                    errorMessage := /* TODO(ConditionalExpression): targetMeaning === SymbolFlags.Value                         ? Diagnostics.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here                         : Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0 */ TODO
                    /* TODO(ExpressionStatement): error(node, errorMessage, node.argument.literal.text); */
                    /* TODO(ExpressionStatement): links.resolvedSymbol = unknownSymbol; */
                    /* TODO(ExpressionStatement): links.resolvedType = errorType; */
                }
            }
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    resolveImportSymbolType := func(node ImportTypeNode, links NodeLinks, symbol Symbol, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        resolvedSymbol := resolveSymbol(symbol)
        /* TODO(ExpressionStatement): links.resolvedSymbol = resolvedSymbol; */
        if /* TODO(BinaryExpression): meaning === SymbolFlags.Value */ TODO {
             getInstantiationExpressionType(getTypeOfSymbol(symbol), node)
        } else {
             getTypeReferenceType(node, resolvedSymbol)
        }
    }
    getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode := func(node /* TODO(UnionType): TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature */ any) Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            aliasSymbol := getAliasSymbolForTypeNode(node)
            if /* TODO(BinaryExpression): getMembersOfSymbol(node.symbol).size === 0 && !aliasSymbol */ TODO {
                /* TODO(ExpressionStatement): links.resolvedType = emptyTypeLiteralType; */
            } else {
                type_ := createObjectType(/* TODO(PropertyAccessExpression): ObjectFlags.Anonymous */ TODO, /* TODO(PropertyAccessExpression): node.symbol */ TODO)
                /* TODO(ExpressionStatement): type.aliasSymbol = aliasSymbol; */
                /* TODO(ExpressionStatement): type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol); */
                if /* TODO(BinaryExpression): isJSDocTypeLiteral(node) && node.isArrayType */ TODO {
                    /* TODO(ExpressionStatement): type = createArrayType(type); */
                }
                /* TODO(ExpressionStatement): links.resolvedType = type; */
            }
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    getAliasSymbolForTypeNode := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        host := /* TODO(PropertyAccessExpression): node.parent */ TODO
        /* TODO(WhileStatement): while (isParenthesizedTypeNode(host) || isJSDocTypeExpression(host) || isTypeOperatorNode(host) && host.operator === SyntaxKind.ReadonlyKeyword) {             host = host.parent;         } */
         /* TODO(ConditionalExpression): isTypeAlias(host) ? getSymbolOfDeclaration(host) : undefined */ TODO
    }
    getTypeArgumentsForAliasSymbol := func(symbol *Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
         /* TODO(ConditionalExpression): symbol ? getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) : undefined */ TODO
    }
    isNonGenericObjectType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !!(type.flags & TypeFlags.Object) && !isGenericMappedType(type) */ TODO
    }
    isEmptyObjectTypeOrSpreadsIntoEmptyObject := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isEmptyObjectType(type) || !!(type.flags & (TypeFlags.Null | TypeFlags.Undefined | TypeFlags.BooleanLike | TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.EnumLike | TypeFlags.NonPrimitive | TypeFlags.Index)) */ TODO
    }
    tryMergeUnionOfObjectTypeAndEmptyObject := func(type_ Type, readonly bool) Type {
        if /* TODO(PrefixUnaryExpression): !(type.flags & TypeFlags.Union) */ TODO {
             type_
        }
        if every(/* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, isEmptyObjectTypeOrSpreadsIntoEmptyObject) {
             /* TODO(BinaryExpression): find((type as UnionType).types, isEmptyObjectType) || emptyObjectType */ TODO
        }
        firstType := find(/* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, /* TODO(ArrowFunction): t => !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t) */ TODO)
        if /* TODO(PrefixUnaryExpression): !firstType */ TODO {
             type_
        }
        secondType := find(/* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, /* TODO(ArrowFunction): t => t !== firstType && !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t) */ TODO)
        if secondType {
             type_
        }
         getAnonymousPartialType(firstType)
        getAnonymousPartialType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
            members := createSymbolTable()
            /* TODO(ForOfStatement): for (const prop of getPropertiesOfType(type)) {                 if (getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlags.Private | ModifierFlags.Protected)) {                     // do nothing, skip privates                 }                 else if (isSpreadableProperty(prop)) {                     const isSetonlyAccessor = prop.flags & SymbolFlags.SetAccessor && !(prop.flags & SymbolFlags.GetAccessor);                     const flags = SymbolFlags.Property | SymbolFlags.Optional;                     const result = createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop) | (readonly ? CheckFlags.Readonly : 0));                     result.links.type = isSetonlyAccessor ? undefinedType : addOptionality(getTypeOfSymbol(prop), /*isProperty* / true);                     result.declarations = prop.declarations;                     result.links.nameType = getSymbolLinks(prop).nameType;                     result.links.syntheticOrigin = prop;                     members.set(prop.escapedName, result);                 }             } */
            spread := createAnonymousType(/* TODO(PropertyAccessExpression): type.symbol */ TODO, members, emptyArray, emptyArray, getIndexInfosOfType(type_))
            /* TODO(ExpressionStatement): spread.objectFlags |= ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral; */
             spread
        }
    }
    getSpreadType := func(left Type, right Type, symbol *Symbol, objectFlags ObjectFlags, readonly bool) Type {
        if /* TODO(BinaryExpression): left.flags & TypeFlags.Any || right.flags & TypeFlags.Any */ TODO {
             anyType
        }
        if /* TODO(BinaryExpression): left.flags & TypeFlags.Unknown || right.flags & TypeFlags.Unknown */ TODO {
             unknownType
        }
        if /* TODO(BinaryExpression): left.flags & TypeFlags.Never */ TODO {
             right
        }
        if /* TODO(BinaryExpression): right.flags & TypeFlags.Never */ TODO {
             left
        }
        /* TODO(ExpressionStatement): left = tryMergeUnionOfObjectTypeAndEmptyObject(left, readonly); */
        if /* TODO(BinaryExpression): left.flags & TypeFlags.Union */ TODO {
             /* TODO(ConditionalExpression): checkCrossProductUnion([left, right])                 ? mapType(left, t => getSpreadType(t, right, symbol, objectFlags, readonly))                 : errorType */ TODO
        }
        /* TODO(ExpressionStatement): right = tryMergeUnionOfObjectTypeAndEmptyObject(right, readonly); */
        if /* TODO(BinaryExpression): right.flags & TypeFlags.Union */ TODO {
             /* TODO(ConditionalExpression): checkCrossProductUnion([left, right])                 ? mapType(right, t => getSpreadType(left, t, symbol, objectFlags, readonly))                 : errorType */ TODO
        }
        if /* TODO(BinaryExpression): right.flags & (TypeFlags.BooleanLike | TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.EnumLike | TypeFlags.NonPrimitive | TypeFlags.Index) */ TODO {
             left
        }
        if /* TODO(BinaryExpression): isGenericObjectType(left) || isGenericObjectType(right) */ TODO {
            if isEmptyObjectType(left) {
                 right
            }
            if /* TODO(BinaryExpression): left.flags & TypeFlags.Intersection */ TODO {
                types := /* TODO(PropertyAccessExpression): (left as IntersectionType).types */ TODO
                lastLeft := /* TODO(ElementAccessExpression): types[types.length - 1] */ TODO
                if /* TODO(BinaryExpression): isNonGenericObjectType(lastLeft) && isNonGenericObjectType(right) */ TODO {
                     getIntersectionType(concatenate(/* TODO(PropertyAccessExpression): types.slice */ TODO(0, /* TODO(BinaryExpression): types.length - 1 */ TODO), /* TODO(ArrayLiteralExpression): [getSpreadType(lastLeft, right, symbol, objectFlags, readonly)] */ TODO))
                }
            }
             getIntersectionType(/* TODO(ArrayLiteralExpression): [left, right] */ TODO)
        }
        members := createSymbolTable()
        skippedPrivateMembers := /* TODO(NewExpression): new Set<__String>() */ TODO
        indexInfos := /* TODO(ConditionalExpression): left === emptyObjectType ? getIndexInfosOfType(right) : getUnionIndexInfos([left, right]) */ TODO
        /* TODO(ForOfStatement): for (const rightProp of getPropertiesOfType(right)) {             if (getDeclarationModifierFlagsFromSymbol(rightProp) & (ModifierFlags.Private | ModifierFlags.Protected)) {                 skippedPrivateMembers.add(rightProp.escapedName);             }             else if (isSpreadableProperty(rightProp)) {                 members.set(rightProp.escapedName, getSpreadSymbol(rightProp, readonly));             }         } */
        /* TODO(ForOfStatement): for (const leftProp of getPropertiesOfType(left)) {             if (skippedPrivateMembers.has(leftProp.escapedName) || !isSpreadableProperty(leftProp)) {                 continue;             }             if (members.has(leftProp.escapedName)) {                 const rightProp = members.get(leftProp.escapedName)!;                 const rightType = getTypeOfSymbol(rightProp);                 if (rightProp.flags & SymbolFlags.Optional) {                     const declarations = concatenate(leftProp.declarations, rightProp.declarations);                     const flags = SymbolFlags.Property | (leftProp.flags & SymbolFlags.Optional);                     const result = createSymbol(flags, leftProp.escapedName);                     // Optimization: avoid calculating the union type if spreading into the exact same type.                     // This is common, e.g. spreading one options bag into another where the bags have the                     // same type, or have properties which overlap. If the unions are large, it may turn out                     // to be expensive to perform subtype reduction.                     const leftType = getTypeOfSymbol(leftProp);                     const leftTypeWithoutUndefined = removeMissingOrUndefinedType(leftType);                     const rightTypeWithoutUndefined = removeMissingOrUndefinedType(rightType);                     result.links.type = leftTypeWithoutUndefined === rightTypeWithoutUndefined ? leftType : getUnionType([leftType, rightTypeWithoutUndefined], UnionReduction.Subtype);                     result.links.leftSpread = leftProp;                     result.links.rightSpread = rightProp;                     result.declarations = declarations;                     result.links.nameType = getSymbolLinks(leftProp).nameType;                     members.set(leftProp.escapedName, result);                 }             }             else {                 members.set(leftProp.escapedName, getSpreadSymbol(leftProp, readonly));             }         } */
        spread := createAnonymousType(symbol, members, emptyArray, emptyArray, sameMap(indexInfos, /* TODO(ArrowFunction): info => getIndexInfoWithReadonly(info, readonly) */ TODO))
        /* TODO(ExpressionStatement): spread.objectFlags |= ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral | ObjectFlags.ContainsSpread | objectFlags; */
         spread
    }
    isSpreadableProperty := func(prop Symbol) bool {
         /* TODO(BinaryExpression): !some(prop.declarations, isPrivateIdentifierClassElementDeclaration) &&             (!(prop.flags & (SymbolFlags.Method | SymbolFlags.GetAccessor | SymbolFlags.SetAccessor)) ||                 !prop.declarations?.some(decl => isClassLike(decl.parent))) */ TODO
    }
    getSpreadSymbol := func(prop Symbol, readonly bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
        isSetonlyAccessor := /* TODO(BinaryExpression): prop.flags & SymbolFlags.SetAccessor && !(prop.flags & SymbolFlags.GetAccessor) */ TODO
        if /* TODO(BinaryExpression): !isSetonlyAccessor && readonly === isReadonlySymbol(prop) */ TODO {
             prop
        }
        flags := /* TODO(BinaryExpression): SymbolFlags.Property | (prop.flags & SymbolFlags.Optional) */ TODO
        result := createSymbol(flags, /* TODO(PropertyAccessExpression): prop.escapedName */ TODO, /* TODO(BinaryExpression): getIsLateCheckFlag(prop) | (readonly ? CheckFlags.Readonly : 0) */ TODO)
        /* TODO(ExpressionStatement): result.links.type = isSetonlyAccessor ? undefinedType : getTypeOfSymbol(prop); */
        /* TODO(ExpressionStatement): result.declarations = prop.declarations; */
        /* TODO(ExpressionStatement): result.links.nameType = getSymbolLinks(prop).nameType; */
        /* TODO(ExpressionStatement): result.links.syntheticOrigin = prop; */
         result
    }
    getIndexInfoWithReadonly := func(info IndexInfo, readonly bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO {
         /* TODO(ConditionalExpression): info.isReadonly !== readonly ? createIndexInfo(info.keyType, info.type, readonly, info.declaration) : info */ TODO
    }
    createLiteralType := func(flags TypeFlags, value /* TODO(UnionType): string | number | PseudoBigInt */ any, symbol Symbol, regularType LiteralType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType */ TODO {
        type_ := createTypeWithSymbol(flags, /* TODO(NonNullExpression): symbol! */ TODO) /* as */ /* TODO(TypeReference): LiteralType */
        /* TODO(ExpressionStatement): type.value = value; */
        /* TODO(ExpressionStatement): type.regularType = regularType || type; */
         type_
    }
    getFreshTypeOfLiteralType := func(type_ Type) Type {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Freshable */ TODO {
            if /* TODO(PrefixUnaryExpression): !(type as FreshableType).freshType */ TODO {
                freshType := createLiteralType(/* TODO(PropertyAccessExpression): type.flags */ TODO, /* TODO(PropertyAccessExpression): (type as LiteralType).value */ TODO, /* TODO(PropertyAccessExpression): (type as LiteralType).symbol */ TODO, type_ /* as */ /* TODO(TypeReference): LiteralType */)
                /* TODO(ExpressionStatement): freshType.freshType = freshType; */
                /* TODO(ExpressionStatement): (type as FreshableType).freshType = freshType; */
            }
             /* TODO(PropertyAccessExpression): (type as FreshableType).freshType */ TODO
        }
         type_
    }
    getRegularTypeOfLiteralType := func(type_ Type) Type {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Freshable ? (type as FreshableType).regularType :             type.flags & TypeFlags.Union ? ((type as UnionType).regularType || ((type as UnionType).regularType = mapType(type, getRegularTypeOfLiteralType) as UnionType)) :             type */ TODO
    }
    isFreshLiteralType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !!(type.flags & TypeFlags.Freshable) && (type as LiteralType).freshType === type */ TODO
    }
    getStringLiteralType := func(value string) StringLiteralType {
        type_
         /* TODO(BinaryExpression): stringLiteralTypes.get(value) ||             (stringLiteralTypes.set(value, type = createLiteralType(TypeFlags.StringLiteral, value) as StringLiteralType), type) */ TODO
    }
    getNumberLiteralType := func(value number) NumberLiteralType {
        type_
         /* TODO(BinaryExpression): numberLiteralTypes.get(value) ||             (numberLiteralTypes.set(value, type = createLiteralType(TypeFlags.NumberLiteral, value) as NumberLiteralType), type) */ TODO
    }
    getBigIntLiteralType := func(value PseudoBigInt) BigIntLiteralType {
        type_
        key := pseudoBigIntToString(value)
         /* TODO(BinaryExpression): bigIntLiteralTypes.get(key) ||             (bigIntLiteralTypes.set(key, type = createLiteralType(TypeFlags.BigIntLiteral, value) as BigIntLiteralType), type) */ TODO
    }
    getEnumLiteralType := func(value /* TODO(UnionType): string | number */ any, enumId number, symbol Symbol) LiteralType {
        type_
        key := /* TODO(TemplateExpression): `${enumId}${typeof value === "string" ? "@" : "#"}${value}` */ TODO
        flags := /* TODO(BinaryExpression): TypeFlags.EnumLiteral | (typeof value === "string" ? TypeFlags.StringLiteral : TypeFlags.NumberLiteral) */ TODO
         /* TODO(BinaryExpression): enumLiteralTypes.get(key) ||             (enumLiteralTypes.set(key, type = createLiteralType(flags, value, symbol)), type) */ TODO
    }
    getTypeFromLiteralTypeNode := func(node LiteralTypeNode) Type {
        if /* TODO(BinaryExpression): node.literal.kind === SyntaxKind.NullKeyword */ TODO {
             nullType
        }
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            /* TODO(ExpressionStatement): links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal)); */
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    createUniqueESSymbolType := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").UniqueESSymbolType */ TODO {
        type_ := createTypeWithSymbol(/* TODO(PropertyAccessExpression): TypeFlags.UniqueESSymbol */ TODO, symbol) /* as */ /* TODO(TypeReference): UniqueESSymbolType */
        /* TODO(ExpressionStatement): type.escapedName = `__@${type.symbol.escapedName}@${getSymbolId(type.symbol)}` as __String; */
         type_
    }
    getESSymbolLikeTypeForNode := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(BinaryExpression): isInJSFile(node) && isJSDocTypeExpression(node) */ TODO {
            host := getJSDocHost(node)
            if host {
                /* TODO(ExpressionStatement): node = getSingleVariableOfVariableStatement(host) || host; */
            }
        }
        if isValidESSymbolDeclaration(node) {
            symbol := /* TODO(ConditionalExpression): isCommonJsExportPropertyAssignment(node) ? getSymbolOfNode((node as BinaryExpression).left) : getSymbolOfNode(node) */ TODO
            if symbol {
                links := getSymbolLinks(symbol)
                 /* TODO(BinaryExpression): links.uniqueESSymbolType || (links.uniqueESSymbolType = createUniqueESSymbolType(symbol)) */ TODO
            }
        }
         esSymbolType
    }
    getThisType := func(node Node) Type {
        container := getThisContainer(node, /* TODO(FalseKeyword): false */ TODO, /* TODO(FalseKeyword): false */ TODO)
        parent := /* TODO(BinaryExpression): container && container.parent */ TODO
        if /* TODO(BinaryExpression): parent && (isClassLike(parent) || parent.kind === SyntaxKind.InterfaceDeclaration) */ TODO {
            if /* TODO(BinaryExpression): !isStatic(container) &&                 (!isConstructorDeclaration(container) || isNodeDescendantOf(node, container.body)) */ TODO {
                 /* TODO(NonNullExpression): getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(parent as ClassLikeDeclaration | InterfaceDeclaration)).thisType! */ TODO
            }
        }
        if /* TODO(BinaryExpression): parent && isObjectLiteralExpression(parent) && isBinaryExpression(parent.parent) && getAssignmentDeclarationKind(parent.parent) === AssignmentDeclarationKind.Prototype */ TODO {
             /* TODO(NonNullExpression): getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent.parent.left)!.parent!).thisType! */ TODO
        }
        host := /* TODO(ConditionalExpression): node.flags & NodeFlags.JSDoc ? getHostSignatureFromJSDoc(node) : undefined */ TODO
        if /* TODO(BinaryExpression): host && isFunctionExpression(host) && isBinaryExpression(host.parent) && getAssignmentDeclarationKind(host.parent) === AssignmentDeclarationKind.PrototypeProperty */ TODO {
             /* TODO(NonNullExpression): getDeclaredTypeOfClassOrInterface(getSymbolOfNode(host.parent.left)!.parent!).thisType! */ TODO
        }
        if /* TODO(BinaryExpression): isJSConstructor(container) && isNodeDescendantOf(node, container.body) */ TODO {
             /* TODO(NonNullExpression): getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(container)).thisType! */ TODO
        }
        /* TODO(ExpressionStatement): error(node, Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface); */
         errorType
    }
    getTypeFromThisTypeNode := func(node /* TODO(UnionType): ThisExpression | ThisTypeNode */ any) Type {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            /* TODO(ExpressionStatement): links.resolvedType = getThisType(node); */
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    getTypeFromRestTypeNode := func(node /* TODO(UnionType): RestTypeNode | NamedTupleMember */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         getTypeFromTypeNode(/* TODO(BinaryExpression): getArrayElementTypeNode(node.type) || node.type */ TODO)
    }
    getArrayElementTypeNode := func(node TypeNode) *TypeNode {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ParenthesizedType:                 return getArrayElementTypeNode((node as ParenthesizedTypeNode).type);             case SyntaxKind.TupleType:                 if ((node as TupleTypeNode).elements.length === 1) {                     node = (node as TupleTypeNode).elements[0];                     if (node.kind === SyntaxKind.RestType || node.kind === SyntaxKind.NamedTupleMember && (node as NamedTupleMember).dotDotDotToken) {                         return getArrayElementTypeNode((node as RestTypeNode | NamedTupleMember).type);                     }                 }                 break;             case SyntaxKind.ArrayType:                 return (node as ArrayTypeNode).elementType;         } */
         undefined
    }
    getTypeFromNamedTupleTypeNode := func(node NamedTupleMember) Type {
        links := getNodeLinks(node)
         /* TODO(BinaryExpression): links.resolvedType || (links.resolvedType = node.dotDotDotToken ? getTypeFromRestTypeNode(node) :             addOptionality(getTypeFromTypeNode(node.type), /*isProperty* / true, !!node.questionToken)) */ TODO
    }
    getTypeFromTypeNode := func(node TypeNode) Type {
         getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node)
    }
    getTypeFromTypeNodeWorker := func(node TypeNode) Type {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AnyKeyword:             case SyntaxKind.JSDocAllType:             case SyntaxKind.JSDocUnknownType:                 return anyType;             case SyntaxKind.UnknownKeyword:                 return unknownType;             case SyntaxKind.StringKeyword:                 return stringType;             case SyntaxKind.NumberKeyword:                 return numberType;             case SyntaxKind.BigIntKeyword:                 return bigintType;             case SyntaxKind.BooleanKeyword:                 return booleanType;             case SyntaxKind.SymbolKeyword:                 return esSymbolType;             case SyntaxKind.VoidKeyword:                 return voidType;             case SyntaxKind.UndefinedKeyword:                 return undefinedType;             case SyntaxKind.NullKeyword as TypeNodeSyntaxKind:                 // TODO(rbuckton): `NullKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service.                 return nullType;             case SyntaxKind.NeverKeyword:                 return neverType;             case SyntaxKind.ObjectKeyword:                 return node.flags & NodeFlags.JavaScriptFile && !noImplicitAny ? anyType : nonPrimitiveType;             case SyntaxKind.IntrinsicKeyword:                 return intrinsicMarkerType;             case SyntaxKind.ThisType:             case SyntaxKind.ThisKeyword as TypeNodeSyntaxKind:                 // TODO(rbuckton): `ThisKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service and because of `isPartOfTypeNode`.                 return getTypeFromThisTypeNode(node as ThisExpression | ThisTypeNode);             case SyntaxKind.LiteralType:                 return getTypeFromLiteralTypeNode(node as LiteralTypeNode);             case SyntaxKind.TypeReference:                 return getTypeFromTypeReference(node as TypeReferenceNode);             case SyntaxKind.TypePredicate:                 return (node as TypePredicateNode).assertsModifier ? voidType : booleanType;             case SyntaxKind.ExpressionWithTypeArguments:                 return getTypeFromTypeReference(node as ExpressionWithTypeArguments);             case SyntaxKind.TypeQuery:                 return getTypeFromTypeQueryNode(node as TypeQueryNode);             case SyntaxKind.ArrayType:             case SyntaxKind.TupleType:                 return getTypeFromArrayOrTupleTypeNode(node as ArrayTypeNode | TupleTypeNode);             case SyntaxKind.OptionalType:                 return getTypeFromOptionalTypeNode(node as OptionalTypeNode);             case SyntaxKind.UnionType:                 return getTypeFromUnionTypeNode(node as UnionTypeNode);             case SyntaxKind.IntersectionType:                 return getTypeFromIntersectionTypeNode(node as IntersectionTypeNode);             case SyntaxKind.JSDocNullableType:                 return getTypeFromJSDocNullableTypeNode(node as JSDocNullableType);             case SyntaxKind.JSDocOptionalType:                 return addOptionality(getTypeFromTypeNode((node as JSDocOptionalType).type));             case SyntaxKind.NamedTupleMember:                 return getTypeFromNamedTupleTypeNode(node as NamedTupleMember);             case SyntaxKind.ParenthesizedType:             case SyntaxKind.JSDocNonNullableType:             case SyntaxKind.JSDocTypeExpression:                 return getTypeFromTypeNode((node as ParenthesizedTypeNode | JSDocTypeReferencingNode | JSDocTypeExpression | NamedTupleMember).type);             case SyntaxKind.RestType:                 return getTypeFromRestTypeNode(node as RestTypeNode);             case SyntaxKind.JSDocVariadicType:                 return getTypeFromJSDocVariadicType(node as JSDocVariadicType);             case SyntaxKind.FunctionType:             case SyntaxKind.ConstructorType:             case SyntaxKind.TypeLiteral:             case SyntaxKind.JSDocTypeLiteral:             case SyntaxKind.JSDocFunctionType:             case SyntaxKind.JSDocSignature:                 return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node as TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature);             case SyntaxKind.TypeOperator:                 return getTypeFromTypeOperatorNode(node as TypeOperatorNode);             case SyntaxKind.IndexedAccessType:                 return getTypeFromIndexedAccessTypeNode(node as IndexedAccessTypeNode);             case SyntaxKind.MappedType:                 return getTypeFromMappedTypeNode(node as MappedTypeNode);             case SyntaxKind.ConditionalType:                 return getTypeFromConditionalTypeNode(node as ConditionalTypeNode);             case SyntaxKind.InferType:                 return getTypeFromInferTypeNode(node as InferTypeNode);             case SyntaxKind.TemplateLiteralType:                 return getTypeFromTemplateTypeNode(node as TemplateLiteralTypeNode);             case SyntaxKind.ImportType:                 return getTypeFromImportTypeNode(node as ImportTypeNode);             // This function assumes that an identifier, qualified name, or property access expression is a type expression             // Callers should first ensure this by calling `isPartOfTypeNode`             // TODO(rbuckton): These aren't valid TypeNodes, but we treat them as such because of `isPartOfTypeNode`, which returns `true` for things that aren't `TypeNode`s.             case SyntaxKind.Identifier as TypeNodeSyntaxKind:             case SyntaxKind.QualifiedName as TypeNodeSyntaxKind:             case SyntaxKind.PropertyAccessExpression as TypeNodeSyntaxKind:                 const symbol = getSymbolAtLocation(node);                 return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;             default:                 return errorType;         } */
    }
    // OVERLOAD: instantiateList := func(items []T, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) []T
    // OVERLOAD: instantiateList := func(items /* TODO(TypeOperator): readonly T[] */ any, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) /* TODO(TypeOperator): readonly T[] */ any
    instantiateList := func(items /* TODO(TypeOperator): readonly T[] */ any, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) /* TODO(TypeOperator): readonly T[] */ any {
        if /* TODO(BinaryExpression): items && items.length */ TODO {
            /* TODO(ForStatement): for (let i = 0; i < items.length; i++) {                 const item = items[i];                 const mapped = instantiator(item, mapper);                 if (item !== mapped) {                     const result = i === 0 ? [] : items.slice(0, i);                     result.push(mapped);                     for (i++; i < items.length; i++) {                         result.push(instantiator(items[i], mapper));                     }                     return result;                 }             } */
        }
         items
    }
    // OVERLOAD: instantiateTypes := func(types []Type, mapper TypeMapper) []Type
    // OVERLOAD: instantiateTypes := func(types /* TODO(TypeOperator): readonly Type[] */ any, mapper TypeMapper) /* TODO(TypeOperator): readonly Type[] */ any
    instantiateTypes := func(types /* TODO(TypeOperator): readonly Type[] */ any, mapper TypeMapper) /* TODO(TypeOperator): readonly Type[] */ any {
         instantiateList(types, mapper, instantiateType)
    }
    instantiateSignatures := func(signatures []Signature, mapper TypeMapper) []Signature {
         instantiateList(signatures, mapper, instantiateSignature)
    }
    instantiateIndexInfos := func(indexInfos []IndexInfo, mapper TypeMapper) []IndexInfo {
         instantiateList(indexInfos, mapper, instantiateIndexInfo)
    }
    createTypeMapper := func(sources []TypeParameter, targets /* TODO(TypeOperator): readonly Type[] */ any) TypeMapper {
         /* TODO(ConditionalExpression): sources.length === 1 ? makeUnaryTypeMapper(sources[0], targets ? targets[0] : anyType) : makeArrayTypeMapper(sources, targets) */ TODO
    }
    getMappedType := func(type_ Type, mapper TypeMapper) Type {
        /* TODO(SwitchStatement): switch (mapper.kind) {             case TypeMapKind.Simple:                 return type === mapper.source ? mapper.target : type;             case TypeMapKind.Array: {                 const sources = mapper.sources;                 const targets = mapper.targets;                 for (let i = 0; i < sources.length; i++) {                     if (type === sources[i]) {                         return targets ? targets[i] : anyType;                     }                 }                 return type;             }             case TypeMapKind.Deferred: {                 const sources = mapper.sources;                 const targets = mapper.targets;                 for (let i = 0; i < sources.length; i++) {                     if (type === sources[i]) {                         return targets[i]();                     }                 }                 return type;             }             case TypeMapKind.Function:                 return mapper.func(type);             case TypeMapKind.Composite:             case TypeMapKind.Merged:                 const t1 = getMappedType(type, mapper.mapper1);                 return t1 !== type && mapper.kind === TypeMapKind.Composite ? instantiateType(t1, mapper.mapper2) : getMappedType(t1, mapper.mapper2);         } */
    }
    makeUnaryTypeMapper := func(source Type, target Type) TypeMapper {
         /* TODO(PropertyAccessExpression): Debug.attachDebugPrototypeIfDebug */ TODO(/* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Simple, source, target } */ TODO)
    }
    makeArrayTypeMapper := func(sources []TypeParameter, targets /* TODO(TypeOperator): readonly Type[] */ any) TypeMapper {
         /* TODO(PropertyAccessExpression): Debug.attachDebugPrototypeIfDebug */ TODO(/* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Array, sources, targets } */ TODO)
    }
    makeFunctionTypeMapper := func(func_ func(t Type) Type, debugInfo func() string) TypeMapper {
         /* TODO(PropertyAccessExpression): Debug.attachDebugPrototypeIfDebug */ TODO(/* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Function, func, debugInfo: Debug.isDebugging ? debugInfo : undefined } */ TODO)
    }
    makeDeferredTypeMapper := func(sources []TypeParameter, targets []func() Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
         /* TODO(PropertyAccessExpression): Debug.attachDebugPrototypeIfDebug */ TODO(/* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Deferred, sources, targets } */ TODO)
    }
    makeCompositeTypeMapper := func(kind /* TODO(UnionType): TypeMapKind.Composite | TypeMapKind.Merged */ any, mapper1 TypeMapper, mapper2 TypeMapper) TypeMapper {
         /* TODO(PropertyAccessExpression): Debug.attachDebugPrototypeIfDebug */ TODO(/* TODO(ObjectLiteralExpression): { kind, mapper1, mapper2 } */ TODO)
    }
    createTypeEraser := func(sources []TypeParameter) TypeMapper {
         createTypeMapper(sources, undefined)
    }
    createBackreferenceMapper := func(context InferenceContext, index number) TypeMapper {
        forwardInferences := /* TODO(PropertyAccessExpression): context.inferences.slice */ TODO(index)
         createTypeMapper(map_(forwardInferences, /* TODO(ArrowFunction): i => i.typeParameter */ TODO), map_(forwardInferences, /* TODO(ArrowFunction): () => unknownType */ TODO))
    }
    combineTypeMappers := func(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
         /* TODO(ConditionalExpression): mapper1 ? makeCompositeTypeMapper(TypeMapKind.Composite, mapper1, mapper2) : mapper2 */ TODO
    }
    mergeTypeMappers := func(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
         /* TODO(ConditionalExpression): mapper1 ? makeCompositeTypeMapper(TypeMapKind.Merged, mapper1, mapper2) : mapper2 */ TODO
    }
    prependTypeMapping := func(source Type, target Type, mapper *TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
         /* TODO(ConditionalExpression): !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, makeUnaryTypeMapper(source, target), mapper) */ TODO
    }
    appendTypeMapping := func(mapper *TypeMapper, source Type, target Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
         /* TODO(ConditionalExpression): !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, mapper, makeUnaryTypeMapper(source, target)) */ TODO
    }
    getRestrictiveTypeParameter := func(tp TypeParameter) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): !tp.constraint && !getConstraintDeclaration(tp) || tp.constraint === noConstraintType ? tp : tp.restrictiveInstantiation || (             tp.restrictiveInstantiation = createTypeParameter(tp.symbol), (tp.restrictiveInstantiation as TypeParameter).constraint = noConstraintType, tp.restrictiveInstantiation         ) */ TODO
    }
    cloneTypeParameter := func(typeParameter TypeParameter) TypeParameter {
        result := createTypeParameter(/* TODO(PropertyAccessExpression): typeParameter.symbol */ TODO)
        /* TODO(ExpressionStatement): result.target = typeParameter; */
         result
    }
    instantiateTypePredicate := func(predicate TypePredicate, mapper TypeMapper) TypePredicate {
         createTypePredicate(/* TODO(PropertyAccessExpression): predicate.kind */ TODO, /* TODO(PropertyAccessExpression): predicate.parameterName */ TODO, /* TODO(PropertyAccessExpression): predicate.parameterIndex */ TODO, instantiateType(/* TODO(PropertyAccessExpression): predicate.type */ TODO, mapper))
    }
    instantiateSignature := func(signature Signature, mapper TypeMapper, eraseTypeParameters bool) Signature {
        var freshTypeParameters /* TODO(ArrayType): TypeParameter[] */ any
        if /* TODO(BinaryExpression): signature.typeParameters && !eraseTypeParameters */ TODO {
            /* TODO(ExpressionStatement): freshTypeParameters = map(signature.typeParameters, cloneTypeParameter); */
            /* TODO(ExpressionStatement): mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper); */
            /* TODO(ForOfStatement): for (const tp of freshTypeParameters) {                 tp.mapper = mapper;             } */
        }
        result := createSignature(/* TODO(PropertyAccessExpression): signature.declaration */ TODO, freshTypeParameters, /* TODO(BinaryExpression): signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper) */ TODO, instantiateList(/* TODO(PropertyAccessExpression): signature.parameters */ TODO, mapper, instantiateSymbol), undefined, undefined, /* TODO(PropertyAccessExpression): signature.minArgumentCount */ TODO, /* TODO(BinaryExpression): signature.flags & SignatureFlags.PropagatingFlags */ TODO)
        /* TODO(ExpressionStatement): result.target = signature; */
        /* TODO(ExpressionStatement): result.mapper = mapper; */
         result
    }
    instantiateSymbol := func(symbol Symbol, mapper TypeMapper) Symbol {
        links := getSymbolLinks(symbol)
        if /* TODO(BinaryExpression): links.type && !couldContainTypeVariables(links.type) */ TODO {
            if /* TODO(PrefixUnaryExpression): !(symbol.flags & SymbolFlags.SetAccessor) */ TODO {
                 symbol
            }
            if /* TODO(BinaryExpression): links.writeType && !couldContainTypeVariables(links.writeType) */ TODO {
                 symbol
            }
        }
        if /* TODO(BinaryExpression): getCheckFlags(symbol) & CheckFlags.Instantiated */ TODO {
            /* TODO(ExpressionStatement): symbol = links.target!; */
            /* TODO(ExpressionStatement): mapper = combineTypeMappers(links.mapper, mapper); */
        }
        result := createSymbol(/* TODO(PropertyAccessExpression): symbol.flags */ TODO, /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO, /* TODO(BinaryExpression): CheckFlags.Instantiated | getCheckFlags(symbol) & (CheckFlags.Readonly | CheckFlags.Late | CheckFlags.OptionalParameter | CheckFlags.RestParameter) */ TODO)
        /* TODO(ExpressionStatement): result.declarations = symbol.declarations; */
        /* TODO(ExpressionStatement): result.parent = symbol.parent; */
        /* TODO(ExpressionStatement): result.links.target = symbol; */
        /* TODO(ExpressionStatement): result.links.mapper = mapper; */
        if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
            /* TODO(ExpressionStatement): result.valueDeclaration = symbol.valueDeclaration; */
        }
        if /* TODO(PropertyAccessExpression): links.nameType */ TODO {
            /* TODO(ExpressionStatement): result.links.nameType = links.nameType; */
        }
         result
    }
    getObjectTypeInstantiation := func(type_ /* TODO(UnionType): AnonymousType | DeferredTypeReference */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        declaration := /* TODO(ConditionalExpression): type.objectFlags & ObjectFlags.Reference ? (type as TypeReference).node! :             type.objectFlags & ObjectFlags.InstantiationExpressionType ? (type as InstantiationExpressionType).node :             type.symbol.declarations![0] */ TODO
        links := getNodeLinks(declaration)
        target := /* TODO(ConditionalExpression): type.objectFlags & ObjectFlags.Reference ? links.resolvedType! as DeferredTypeReference :             type.objectFlags & ObjectFlags.Instantiated ? type.target! : type */ TODO
        typeParameters := /* TODO(ConditionalExpression): type.objectFlags & ObjectFlags.SingleSignatureType ? (type as SingleSignatureType).outerTypeParameters : links.outerTypeParameters */ TODO
        if /* TODO(PrefixUnaryExpression): !typeParameters */ TODO {
            outerTypeParameters := getOuterTypeParameters(declaration, /* TODO(TrueKeyword): true */ TODO)
            if isJSConstructor(declaration) {
                templateTagParameters := getTypeParametersFromDeclaration(declaration /* as */ /* TODO(TypeReference): DeclarationWithTypeParameters */)
                /* TODO(ExpressionStatement): outerTypeParameters = addRange(outerTypeParameters, templateTagParameters); */
            }
            /* TODO(ExpressionStatement): typeParameters = outerTypeParameters || emptyArray; */
            allDeclarations := /* TODO(ConditionalExpression): type.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) ? [declaration] : type.symbol.declarations! */ TODO
            /* TODO(ExpressionStatement): typeParameters = (target.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) || target.symbol.flags & SymbolFlags.Method || target.symbol.flags & SymbolFlags.TypeLiteral) && !target.aliasTypeArguments ?                 filter(typeParameters, tp => some(allDeclarations, d => isTypeParameterPossiblyReferenced(tp, d))) :                 typeParameters; */
            /* TODO(ExpressionStatement): links.outerTypeParameters = typeParameters; */
        }
        if /* TODO(PropertyAccessExpression): typeParameters.length */ TODO {
            combinedMapper := combineTypeMappers(/* TODO(PropertyAccessExpression): type.mapper */ TODO, mapper)
            typeArguments := map_(typeParameters, /* TODO(ArrowFunction): t => getMappedType(t, combinedMapper) */ TODO)
            newAliasSymbol := /* TODO(BinaryExpression): aliasSymbol || type.aliasSymbol */ TODO
            newAliasTypeArguments := /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
            id := /* TODO(BinaryExpression): (type.objectFlags & ObjectFlags.SingleSignatureType ? "S" : "") + getTypeListId(typeArguments) + getAliasId(newAliasSymbol, newAliasTypeArguments) */ TODO
            if /* TODO(PrefixUnaryExpression): !target.instantiations */ TODO {
                /* TODO(ExpressionStatement): target.instantiations = new Map<string, Type>(); */
                /* TODO(ExpressionStatement): target.instantiations.set(getTypeListId(typeParameters) + getAliasId(target.aliasSymbol, target.aliasTypeArguments), target); */
            }
            result := /* TODO(PropertyAccessExpression): target.instantiations.get */ TODO(id)
            if /* TODO(PrefixUnaryExpression): !result */ TODO {
                if /* TODO(BinaryExpression): type.objectFlags & ObjectFlags.SingleSignatureType */ TODO {
                    /* TODO(ExpressionStatement): result = instantiateAnonymousType(type, mapper); */
                    /* TODO(ExpressionStatement): target.instantiations.set(id, result); */
                     result
                }
                newMapper := createTypeMapper(typeParameters, typeArguments)
                /* TODO(ExpressionStatement): result = target.objectFlags & ObjectFlags.Reference ? createDeferredTypeReference((type as DeferredTypeReference).target, (type as DeferredTypeReference).node, newMapper, newAliasSymbol, newAliasTypeArguments) :                     target.objectFlags & ObjectFlags.Mapped ? instantiateMappedType(target as MappedType, newMapper, newAliasSymbol, newAliasTypeArguments) :                     instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments); */
                /* TODO(ExpressionStatement): target.instantiations.set(id, result); */
                resultObjectFlags := getObjectFlags(result)
                if /* TODO(BinaryExpression): result.flags & TypeFlags.ObjectFlagsType && !(resultObjectFlags & ObjectFlags.CouldContainTypeVariablesComputed) */ TODO {
                    resultCouldContainTypeVariables := some(typeArguments, couldContainTypeVariables)
                    if /* TODO(PrefixUnaryExpression): !(getObjectFlags(result) & ObjectFlags.CouldContainTypeVariablesComputed) */ TODO {
                        if /* TODO(BinaryExpression): resultObjectFlags & (ObjectFlags.Mapped | ObjectFlags.Anonymous | ObjectFlags.Reference) */ TODO {
                            /* TODO(ExpressionStatement): (result as ObjectFlagsType).objectFlags |= ObjectFlags.CouldContainTypeVariablesComputed | (resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariables : 0); */
                        } else {
                            /* TODO(ExpressionStatement): (result as ObjectFlagsType).objectFlags |= !resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariablesComputed : 0; */
                        }
                    }
                }
            }
             result
        }
         type_
    }
    maybeTypeParameterReference := func(node Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !(node.parent.kind === SyntaxKind.TypeReference && (node.parent as TypeReferenceNode).typeArguments && node === (node.parent as TypeReferenceNode).typeName ||             node.parent.kind === SyntaxKind.ImportType && (node.parent as ImportTypeNode).typeArguments && node === (node.parent as ImportTypeNode).qualifier) */ TODO
    }
    isTypeParameterPossiblyReferenced := func(tp TypeParameter, node Node) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length === 1 */ TODO {
            container := /* TODO(PropertyAccessExpression): tp.symbol.declarations[0].parent */ TODO
            /* TODO(ForStatement): for (let n = node; n !== container; n = n.parent) {                 if (!n || n.kind === SyntaxKind.Block || n.kind === SyntaxKind.ConditionalType && forEachChild((n as ConditionalTypeNode).extendsType, containsReference)) {                     return true;                 }             } */
             containsReference(node)
        }
         /* TODO(TrueKeyword): true */ TODO
        containsReference := func(node Node) bool {
            /* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.ThisType:                     return !!tp.isThisType;                 case SyntaxKind.Identifier:                     return !tp.isThisType && isPartOfTypeNode(node) && maybeTypeParameterReference(node) &&                         getTypeFromTypeNodeWorker(node as TypeNode) === tp; // use worker because we're looking for === equality                 case SyntaxKind.TypeQuery:                     const entityName = (node as TypeQueryNode).exprName;                     const firstIdentifier = getFirstIdentifier(entityName);                     if (!isThisIdentifier(firstIdentifier)) { // Don't attempt to analyze typeof this.xxx                         const firstIdentifierSymbol = getResolvedSymbol(firstIdentifier);                         const tpDeclaration = tp.symbol.declarations![0]; // There is exactly one declaration, otherwise `containsReference` is not called                         const tpScope = tpDeclaration.kind === SyntaxKind.TypeParameter ? tpDeclaration.parent : // Type parameter is a regular type parameter, e.g. foo<T>                             tp.isThisType ? tpDeclaration : // Type parameter is the this type, and its declaration is the class declaration.                             undefined; // Type parameter's declaration was unrecognized, e.g. comes from JSDoc annotation.                         if (firstIdentifierSymbol.declarations && tpScope) {                             return some(firstIdentifierSymbol.declarations, idDecl => isNodeDescendantOf(idDecl, tpScope)) ||                                 some((node as TypeQueryNode).typeArguments, containsReference);                         }                     }                     return true;                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.MethodSignature:                     return !(node as FunctionLikeDeclaration).type && !!(node as FunctionLikeDeclaration).body ||                         some((node as FunctionLikeDeclaration).typeParameters, containsReference) ||                         some((node as FunctionLikeDeclaration).parameters, containsReference) ||                         !!(node as FunctionLikeDeclaration).type && containsReference((node as FunctionLikeDeclaration).type!);             } */
             /* TODO(PrefixUnaryExpression): !!forEachChild(node, containsReference) */ TODO
        }
    }
    getHomomorphicTypeVariable := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter | undefined */ TODO {
        constraintType := getConstraintTypeFromMappedType(type_)
        if /* TODO(BinaryExpression): constraintType.flags & TypeFlags.Index */ TODO {
            typeVariable := getActualTypeVariable(/* TODO(PropertyAccessExpression): (constraintType as IndexType).type */ TODO)
            if /* TODO(BinaryExpression): typeVariable.flags & TypeFlags.TypeParameter */ TODO {
                 typeVariable /* as */ /* TODO(TypeReference): TypeParameter */
            }
        }
         undefined
    }
    instantiateMappedType := func(type_ MappedType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
        typeVariable := getHomomorphicTypeVariable(type_)
        if typeVariable {
            mappedTypeVariable := instantiateType(typeVariable, mapper)
            if /* TODO(BinaryExpression): typeVariable !== mappedTypeVariable */ TODO {
                 mapTypeWithAlias(getReducedType(mappedTypeVariable), instantiateConstituent, aliasSymbol, aliasTypeArguments)
            }
        }
         /* TODO(ConditionalExpression): instantiateType(getConstraintTypeFromMappedType(type), mapper) === wildcardType ? wildcardType : instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments) */ TODO
        instantiateConstituent := func(t Type) Type {
            if /* TODO(BinaryExpression): t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.InstantiableNonPrimitive | TypeFlags.Object | TypeFlags.Intersection) && t !== wildcardType && !isErrorType(t) */ TODO {
                if /* TODO(PrefixUnaryExpression): !type.declaration.nameType */ TODO {
                    constraint
                    if /* TODO(BinaryExpression): isArrayType(t) || t.flags & TypeFlags.Any && findResolutionCycleStartIndex(typeVariable!, TypeSystemPropertyName.ImmediateBaseConstraint) < 0 &&                             (constraint = getConstraintOfTypeParameter(typeVariable!)) && everyType(constraint, isArrayOrTupleType) */ TODO {
                         instantiateMappedArrayType(t, type_, prependTypeMapping(/* TODO(NonNullExpression): typeVariable! */ TODO, t, mapper))
                    }
                    if isTupleType(t) {
                         instantiateMappedTupleType(t, type_, /* TODO(NonNullExpression): typeVariable! */ TODO, mapper)
                    }
                    if isArrayOrTupleOrIntersection(t) {
                         getIntersectionType(map_(/* TODO(PropertyAccessExpression): (t as IntersectionType).types */ TODO, instantiateConstituent))
                    }
                }
                 instantiateAnonymousType(type_, prependTypeMapping(/* TODO(NonNullExpression): typeVariable! */ TODO, t, mapper))
            }
             t
        }
    }
    getModifiedReadonlyState := func(state bool, modifiers MappedTypeModifiers) /* TODO(undefined): boolean */ TODO {
         /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeReadonly ? true : modifiers & MappedTypeModifiers.ExcludeReadonly ? false : state */ TODO
    }
    instantiateMappedTupleType := func(tupleType TupleTypeReference, mappedType MappedType, typeVariable TypeVariable, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        elementFlags := /* TODO(PropertyAccessExpression): tupleType.target.elementFlags */ TODO
        fixedLength := /* TODO(PropertyAccessExpression): tupleType.target.fixedLength */ TODO
        fixedMapper := /* TODO(ConditionalExpression): fixedLength ? prependTypeMapping(typeVariable, tupleType, mapper) : mapper */ TODO
        newElementTypes := map_(getElementTypes(tupleType), /* TODO(ArrowFunction): (type, i) => {             const flags = elementFlags[i];             return i < fixedLength ? instantiateMappedTypeTemplate(mappedType, getStringLiteralType("" + i), !!(flags & ElementFlags.Optional), fixedMapper) :                 flags & ElementFlags.Variadic ? instantiateType(mappedType, prependTypeMapping(typeVariable, type, mapper)) :                 getElementTypeOfArrayType(instantiateType(mappedType, prependTypeMapping(typeVariable, createArrayType(type), mapper))) ?? unknownType;         } */ TODO)
        modifiers := getMappedTypeModifiers(mappedType)
        newElementFlags := /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeOptional ? map(elementFlags, f => f & ElementFlags.Required ? ElementFlags.Optional : f) :             modifiers & MappedTypeModifiers.ExcludeOptional ? map(elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) :             elementFlags */ TODO
        newReadonly := getModifiedReadonlyState(/* TODO(PropertyAccessExpression): tupleType.target.readonly */ TODO, getMappedTypeModifiers(mappedType))
         /* TODO(ConditionalExpression): contains(newElementTypes, errorType) ? errorType :             createTupleType(newElementTypes, newElementFlags, newReadonly, tupleType.target.labeledElementDeclarations) */ TODO
    }
    instantiateMappedArrayType := func(arrayType Type, mappedType MappedType, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType | import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
        elementType := instantiateMappedTypeTemplate(mappedType, numberType, /* TODO(TrueKeyword): true */ TODO, mapper)
         /* TODO(ConditionalExpression): isErrorType(elementType) ? errorType :             createArrayType(elementType, getModifiedReadonlyState(isReadonlyArrayType(arrayType), getMappedTypeModifiers(mappedType))) */ TODO
    }
    instantiateMappedTypeTemplate := func(type_ MappedType, key Type, isOptional bool, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        templateMapper := appendTypeMapping(mapper, getTypeParameterFromMappedType(type_), key)
        propType := instantiateType(getTemplateTypeFromMappedType(/* TODO(BinaryExpression): type.target as MappedType || type */ TODO), templateMapper)
        modifiers := getMappedTypeModifiers(type_)
         /* TODO(ConditionalExpression): strictNullChecks && modifiers & MappedTypeModifiers.IncludeOptional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void) ? getOptionalType(propType, /*isProperty* / true) :             strictNullChecks && modifiers & MappedTypeModifiers.ExcludeOptional && isOptional ? getTypeWithFacts(propType, TypeFacts.NEUndefined) :             propType */ TODO
    }
    instantiateAnonymousType := func(type_ AnonymousType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) AnonymousType {
        /* TODO(ExpressionStatement): Debug.assert(type.symbol, "anonymous type must have symbol to be instantiated"); */
        result := createObjectType(/* TODO(BinaryExpression): type.objectFlags & ~(ObjectFlags.CouldContainTypeVariablesComputed | ObjectFlags.CouldContainTypeVariables) | ObjectFlags.Instantiated */ TODO, /* TODO(PropertyAccessExpression): type.symbol */ TODO) /* as */ /* TODO(TypeReference): AnonymousType */
        if /* TODO(BinaryExpression): type.objectFlags & ObjectFlags.Mapped */ TODO {
            /* TODO(ExpressionStatement): (result as MappedType).declaration = (type as MappedType).declaration; */
            origTypeParameter := getTypeParameterFromMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */)
            freshTypeParameter := cloneTypeParameter(origTypeParameter)
            /* TODO(ExpressionStatement): (result as MappedType).typeParameter = freshTypeParameter; */
            /* TODO(ExpressionStatement): mapper = combineTypeMappers(makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper); */
            /* TODO(ExpressionStatement): freshTypeParameter.mapper = mapper; */
        }
        if /* TODO(BinaryExpression): type.objectFlags & ObjectFlags.InstantiationExpressionType */ TODO {
            /* TODO(ExpressionStatement): (result as InstantiationExpressionType).node = (type as InstantiationExpressionType).node; */
        }
        if /* TODO(BinaryExpression): type.objectFlags & ObjectFlags.SingleSignatureType */ TODO {
            /* TODO(ExpressionStatement): (result as SingleSignatureType).outerTypeParameters = (type as SingleSignatureType).outerTypeParameters; */
        }
        /* TODO(ExpressionStatement): result.target = type; */
        /* TODO(ExpressionStatement): result.mapper = mapper; */
        /* TODO(ExpressionStatement): result.aliasSymbol = aliasSymbol || type.aliasSymbol; */
        /* TODO(ExpressionStatement): result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper); */
        /* TODO(ExpressionStatement): result.objectFlags |= result.aliasTypeArguments ? getPropagatingFlagsOfTypes(result.aliasTypeArguments) : 0; */
         result
    }
    getConditionalTypeInstantiation := func(type_ ConditionalType, mapper TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
        root := /* TODO(PropertyAccessExpression): type.root */ TODO
        if /* TODO(PropertyAccessExpression): root.outerTypeParameters */ TODO {
            typeArguments := map_(/* TODO(PropertyAccessExpression): root.outerTypeParameters */ TODO, /* TODO(ArrowFunction): t => getMappedType(t, mapper) */ TODO)
            id := /* TODO(BinaryExpression): (forConstraint ? "C" : "") + getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
            result := /* TODO(PropertyAccessExpression): root.instantiations!.get */ TODO(id)
            if /* TODO(PrefixUnaryExpression): !result */ TODO {
                newMapper := createTypeMapper(/* TODO(PropertyAccessExpression): root.outerTypeParameters */ TODO, typeArguments)
                checkType := /* TODO(PropertyAccessExpression): root.checkType */ TODO
                distributionType := /* TODO(ConditionalExpression): root.isDistributive ? getReducedType(getMappedType(checkType, newMapper)) : undefined */ TODO
                /* TODO(ExpressionStatement): result = distributionType && checkType !== distributionType && distributionType.flags & (TypeFlags.Union | TypeFlags.Never) ?                     mapTypeWithAlias(distributionType, t => getConditionalType(root, prependTypeMapping(checkType, t, newMapper), forConstraint), aliasSymbol, aliasTypeArguments) :                     getConditionalType(root, newMapper, forConstraint, aliasSymbol, aliasTypeArguments); */
                /* TODO(ExpressionStatement): root.instantiations!.set(id, result); */
            }
             result
        }
         type_
    }
    // OVERLOAD: instantiateType := func(type_ Type, mapper *TypeMapper) Type
    // OVERLOAD: instantiateType := func(type_ *Type, mapper *TypeMapper) *Type
    instantiateType := func(type_ *Type, mapper *TypeMapper) *Type {
         /* TODO(ConditionalExpression): type && mapper ? instantiateTypeWithAlias(type, mapper, /*aliasSymbol* / undefined, /*aliasTypeArguments* / undefined) : type */ TODO
    }
    instantiateTypeWithAlias := func(type_ Type, mapper TypeMapper, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) Type {
        if /* TODO(PrefixUnaryExpression): !couldContainTypeVariables(type) */ TODO {
             type_
        }
        if /* TODO(BinaryExpression): instantiationDepth === 100 || instantiationCount >= 5000000 */ TODO {
            /* TODO(ExpressionStatement): tracing?.instant(tracing.Phase.CheckTypes, "instantiateType_DepthLimit", { typeId: type.id, instantiationDepth, instantiationCount }); */
            /* TODO(ExpressionStatement): error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite); */
             errorType
        }
        /* TODO(ExpressionStatement): totalInstantiationCount++; */
        /* TODO(ExpressionStatement): instantiationCount++; */
        /* TODO(ExpressionStatement): instantiationDepth++; */
        result := instantiateTypeWorker(type_, mapper, aliasSymbol, aliasTypeArguments)
        /* TODO(ExpressionStatement): instantiationDepth--; */
         result
    }
    instantiateTypeWorker := func(type_ Type, mapper TypeMapper, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) Type {
        flags := /* TODO(PropertyAccessExpression): type.flags */ TODO
        if /* TODO(BinaryExpression): flags & TypeFlags.TypeParameter */ TODO {
             getMappedType(type_, mapper)
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.Object */ TODO {
            objectFlags := /* TODO(PropertyAccessExpression): (type as ObjectType).objectFlags */ TODO
            if /* TODO(BinaryExpression): objectFlags & (ObjectFlags.Reference | ObjectFlags.Anonymous | ObjectFlags.Mapped) */ TODO {
                if /* TODO(BinaryExpression): objectFlags & ObjectFlags.Reference && !(type as TypeReference).node */ TODO {
                    resolvedTypeArguments := /* TODO(PropertyAccessExpression): (type as TypeReference).resolvedTypeArguments */ TODO
                    newTypeArguments := instantiateTypes(resolvedTypeArguments, mapper)
                     /* TODO(ConditionalExpression): newTypeArguments !== resolvedTypeArguments ? createNormalizedTypeReference((type as TypeReference).target, newTypeArguments) : type */ TODO
                }
                if /* TODO(BinaryExpression): objectFlags & ObjectFlags.ReverseMapped */ TODO {
                     instantiateReverseMappedType(type_ /* as */ /* TODO(TypeReference): ReverseMappedType */, mapper)
                }
                 getObjectTypeInstantiation(type_ /* as */ /* TODO(UnionType): TypeReference | AnonymousType | MappedType */, mapper, aliasSymbol, aliasTypeArguments)
            }
             type_
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.UnionOrIntersection */ TODO {
            origin := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).origin : undefined */ TODO
            types := /* TODO(ConditionalExpression): origin && origin.flags & TypeFlags.UnionOrIntersection ? (origin as UnionOrIntersectionType).types : (type as UnionOrIntersectionType).types */ TODO
            newTypes := instantiateTypes(types, mapper)
            if /* TODO(BinaryExpression): newTypes === types && aliasSymbol === type.aliasSymbol */ TODO {
                 type_
            }
            newAliasSymbol := /* TODO(BinaryExpression): aliasSymbol || type.aliasSymbol */ TODO
            newAliasTypeArguments := /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
             /* TODO(ConditionalExpression): flags & TypeFlags.Intersection || origin && origin.flags & TypeFlags.Intersection ?                 getIntersectionType(newTypes, IntersectionFlags.None, newAliasSymbol, newAliasTypeArguments) :                 getUnionType(newTypes, UnionReduction.Literal, newAliasSymbol, newAliasTypeArguments) */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.Index */ TODO {
             getIndexType(instantiateType(/* TODO(PropertyAccessExpression): (type as IndexType).type */ TODO, mapper))
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.TemplateLiteral */ TODO {
             getTemplateLiteralType(/* TODO(PropertyAccessExpression): (type as TemplateLiteralType).texts */ TODO, instantiateTypes(/* TODO(PropertyAccessExpression): (type as TemplateLiteralType).types */ TODO, mapper))
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.StringMapping */ TODO {
             getStringMappingType(/* TODO(PropertyAccessExpression): (type as StringMappingType).symbol */ TODO, instantiateType(/* TODO(PropertyAccessExpression): (type as StringMappingType).type */ TODO, mapper))
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.IndexedAccess */ TODO {
            newAliasSymbol := /* TODO(BinaryExpression): aliasSymbol || type.aliasSymbol */ TODO
            newAliasTypeArguments := /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
             getIndexedAccessType(instantiateType(/* TODO(PropertyAccessExpression): (type as IndexedAccessType).objectType */ TODO, mapper), instantiateType(/* TODO(PropertyAccessExpression): (type as IndexedAccessType).indexType */ TODO, mapper), /* TODO(PropertyAccessExpression): (type as IndexedAccessType).accessFlags */ TODO, undefined, newAliasSymbol, newAliasTypeArguments)
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.Conditional */ TODO {
             getConditionalTypeInstantiation(type_ /* as */ /* TODO(TypeReference): ConditionalType */, combineTypeMappers(/* TODO(PropertyAccessExpression): (type as ConditionalType).mapper */ TODO, mapper), /* TODO(FalseKeyword): false */ TODO, aliasSymbol, aliasTypeArguments)
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.Substitution */ TODO {
            newBaseType := instantiateType(/* TODO(PropertyAccessExpression): (type as SubstitutionType).baseType */ TODO, mapper)
            if isNoInferType(type_) {
                 getNoInferType(newBaseType)
            }
            newConstraint := instantiateType(/* TODO(PropertyAccessExpression): (type as SubstitutionType).constraint */ TODO, mapper)
            if /* TODO(BinaryExpression): newBaseType.flags & TypeFlags.TypeVariable && isGenericType(newConstraint) */ TODO {
                 getSubstitutionType(newBaseType, newConstraint)
            }
            if /* TODO(BinaryExpression): newConstraint.flags & TypeFlags.AnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(newBaseType), getRestrictiveInstantiation(newConstraint)) */ TODO {
                 newBaseType
            }
             /* TODO(ConditionalExpression): newBaseType.flags & TypeFlags.TypeVariable ? getSubstitutionType(newBaseType, newConstraint) : getIntersectionType([newConstraint, newBaseType]) */ TODO
        }
         type_
    }
    instantiateReverseMappedType := func(type_ ReverseMappedType, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        innerMappedType := instantiateType(/* TODO(PropertyAccessExpression): type.mappedType */ TODO, mapper)
        if /* TODO(PrefixUnaryExpression): !(getObjectFlags(innerMappedType) & ObjectFlags.Mapped) */ TODO {
             type_
        }
        innerIndexType := instantiateType(/* TODO(PropertyAccessExpression): type.constraintType */ TODO, mapper)
        if /* TODO(PrefixUnaryExpression): !(innerIndexType.flags & TypeFlags.Index) */ TODO {
             type_
        }
        instantiated := inferTypeForHomomorphicMappedType(instantiateType(/* TODO(PropertyAccessExpression): type.source */ TODO, mapper), innerMappedType /* as */ /* TODO(TypeReference): MappedType */, innerIndexType /* as */ /* TODO(TypeReference): IndexType */)
        if instantiated {
             instantiated
        }
         type_
    }
    getPermissiveInstantiation := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never) ? type :             type.permissiveInstantiation || (type.permissiveInstantiation = instantiateType(type, permissiveMapper)) */ TODO
    }
    getRestrictiveInstantiation := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(BinaryExpression): type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never) */ TODO {
             type_
        }
        if /* TODO(PropertyAccessExpression): type.restrictiveInstantiation */ TODO {
             /* TODO(PropertyAccessExpression): type.restrictiveInstantiation */ TODO
        }
        /* TODO(ExpressionStatement): type.restrictiveInstantiation = instantiateType(type, restrictiveMapper); */
        /* TODO(ExpressionStatement): type.restrictiveInstantiation.restrictiveInstantiation = type.restrictiveInstantiation; */
         /* TODO(PropertyAccessExpression): type.restrictiveInstantiation */ TODO
    }
    instantiateIndexInfo := func(info IndexInfo, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO {
         createIndexInfo(/* TODO(PropertyAccessExpression): info.keyType */ TODO, instantiateType(/* TODO(PropertyAccessExpression): info.type */ TODO, mapper), /* TODO(PropertyAccessExpression): info.isReadonly */ TODO, /* TODO(PropertyAccessExpression): info.declaration */ TODO)
    }
    isContextSensitive := func(node /* TODO(UnionType): Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike | JsxChild */ any) bool {
        /* TODO(ExpressionStatement): Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(node)); */
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.FunctionDeclaration: // Function declarations can have context when annotated with a jsdoc @type                 return isContextSensitiveFunctionLikeDeclaration(node as FunctionExpression | ArrowFunction | MethodDeclaration);             case SyntaxKind.ObjectLiteralExpression:                 return some((node as ObjectLiteralExpression).properties, isContextSensitive);             case SyntaxKind.ArrayLiteralExpression:                 return some((node as ArrayLiteralExpression).elements, isContextSensitive);             case SyntaxKind.ConditionalExpression:                 return isContextSensitive((node as ConditionalExpression).whenTrue) ||                     isContextSensitive((node as ConditionalExpression).whenFalse);             case SyntaxKind.BinaryExpression:                 return ((node as BinaryExpression).operatorToken.kind === SyntaxKind.BarBarToken || (node as BinaryExpression).operatorToken.kind === SyntaxKind.QuestionQuestionToken) &&                     (isContextSensitive((node as BinaryExpression).left) || isContextSensitive((node as BinaryExpression).right));             case SyntaxKind.PropertyAssignment:                 return isContextSensitive((node as PropertyAssignment).initializer);             case SyntaxKind.ParenthesizedExpression:                 return isContextSensitive((node as ParenthesizedExpression).expression);             case SyntaxKind.JsxAttributes:                 return some((node as JsxAttributes).properties, isContextSensitive) || isJsxOpeningElement(node.parent) && some(node.parent.parent.children, isContextSensitive);             case SyntaxKind.JsxAttribute: {                 // If there is no initializer, JSX attribute has a boolean value of true which is not context sensitive.                 const { initializer } = node as JsxAttribute;                 return !!initializer && isContextSensitive(initializer);             }             case SyntaxKind.JsxExpression: {                 // It is possible to that node.expression is undefined (e.g <div x={} />)                 const { expression } = node as JsxExpression;                 return !!expression && isContextSensitive(expression);             }         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    isContextSensitiveFunctionLikeDeclaration := func(node FunctionLikeDeclaration) bool {
         /* TODO(BinaryExpression): hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node) */ TODO
    }
    hasContextSensitiveReturnExpression := func(node FunctionLikeDeclaration) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): node.typeParameters || getEffectiveReturnTypeNode(node) || !node.body */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): node.body.kind !== SyntaxKind.Block */ TODO {
             isContextSensitive(/* TODO(PropertyAccessExpression): node.body */ TODO)
        }
         /* TODO(PrefixUnaryExpression): !!forEachReturnStatement(node.body as Block, statement => !!statement.expression && isContextSensitive(statement.expression)) */ TODO
    }
    isContextSensitiveFunctionOrObjectLiteralMethod := func(func_ Node) /* TODO(TypePredicate): func is FunctionExpression | ArrowFunction | MethodDeclaration */ TODO {
         /* TODO(BinaryExpression): (isFunctionExpressionOrArrowFunction(func) || isObjectLiteralMethod(func)) &&             isContextSensitiveFunctionLikeDeclaration(func) */ TODO
    }
    getTypeWithoutSignatures := func(type_ Type) Type {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
            resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
            if /* TODO(BinaryExpression): resolved.constructSignatures.length || resolved.callSignatures.length */ TODO {
                result := createObjectType(/* TODO(PropertyAccessExpression): ObjectFlags.Anonymous */ TODO, /* TODO(PropertyAccessExpression): type.symbol */ TODO)
                /* TODO(ExpressionStatement): result.members = resolved.members; */
                /* TODO(ExpressionStatement): result.properties = resolved.properties; */
                /* TODO(ExpressionStatement): result.callSignatures = emptyArray; */
                /* TODO(ExpressionStatement): result.constructSignatures = emptyArray; */
                /* TODO(ExpressionStatement): result.indexInfos = emptyArray; */
                 result
            }
        } else if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
             getIntersectionType(map_(/* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, getTypeWithoutSignatures))
        }
         type_
    }
    isTypeIdenticalTo := func(source Type, target Type) bool {
         isTypeRelatedTo(source, target, identityRelation)
    }
    compareTypesIdentical := func(source Type, target Type) Ternary {
         /* TODO(ConditionalExpression): isTypeRelatedTo(source, target, identityRelation) ? Ternary.True : Ternary.False */ TODO
    }
    compareTypesAssignable := func(source Type, target Type) Ternary {
         /* TODO(ConditionalExpression): isTypeRelatedTo(source, target, assignableRelation) ? Ternary.True : Ternary.False */ TODO
    }
    compareTypesSubtypeOf := func(source Type, target Type) Ternary {
         /* TODO(ConditionalExpression): isTypeRelatedTo(source, target, subtypeRelation) ? Ternary.True : Ternary.False */ TODO
    }
    isTypeSubtypeOf := func(source Type, target Type) bool {
         isTypeRelatedTo(source, target, subtypeRelation)
    }
    isTypeStrictSubtypeOf := func(source Type, target Type) bool {
         isTypeRelatedTo(source, target, strictSubtypeRelation)
    }
    isTypeAssignableTo := func(source Type, target Type) bool {
         isTypeRelatedTo(source, target, assignableRelation)
    }
    isTypeDerivedFrom := func(source Type, target Type) bool {
         /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? every((source as UnionType).types, t => isTypeDerivedFrom(t, target)) :             target.flags & TypeFlags.Union ? some((target as UnionType).types, t => isTypeDerivedFrom(source, t)) :             source.flags & TypeFlags.Intersection ? some((source as IntersectionType).types, t => isTypeDerivedFrom(t, target)) :             source.flags & TypeFlags.InstantiableNonPrimitive ? isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target) :             isEmptyAnonymousObjectType(target) ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive)) :             target === globalObjectType ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive)) && !isEmptyAnonymousObjectType(source) :             target === globalFunctionType ? !!(source.flags & TypeFlags.Object) && isFunctionObjectType(source as ObjectType) :             hasBaseType(source, getTargetType(target)) || (isArrayType(target) && !isReadonlyArrayType(target) && isTypeDerivedFrom(source, globalReadonlyArrayType)) */ TODO
    }
    isTypeComparableTo := func(source Type, target Type) bool {
         isTypeRelatedTo(source, target, comparableRelation)
    }
    areTypesComparable := func(type1 Type, type2 Type) bool {
         /* TODO(BinaryExpression): isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1) */ TODO
    }
    checkTypeAssignableTo := func(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputObject /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ TODO) bool {
         checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject)
    }
    checkTypeAssignableToAndOptionallyElaborate := func(source Type, target Type, errorNode Node, expr *Expression, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
         checkTypeRelatedToAndOptionallyElaborate(source, target, assignableRelation, errorNode, expr, headMessage, containingMessageChain, undefined)
    }
    checkTypeRelatedToAndOptionallyElaborate := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, expr *Expression, headMessage *DiagnosticMessage, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
        if isTypeRelatedTo(source, target, relation) {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): !errorNode || !elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) */ TODO {
             checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isOrHasGenericConditional := func(type_ Type) bool {
         /* TODO(PrefixUnaryExpression): !!(type.flags & TypeFlags.Conditional || (type.flags & TypeFlags.Intersection && some((type as IntersectionType).types, isOrHasGenericConditional))) */ TODO
    }
    elaborateError := func(node *Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
        if /* TODO(BinaryExpression): !node || isOrHasGenericConditional(target) */ TODO {
            /* TODO(FalseKeyword): false */
        }
        if /* TODO(BinaryExpression): !checkTypeRelatedTo(source, target, relation, /*errorNode* / undefined)             && elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AsExpression:                 if (!isConstAssertion(node)) {                     break;                 }                 // fallthrough             case SyntaxKind.JsxExpression:             case SyntaxKind.ParenthesizedExpression:                 return elaborateError((node as AsExpression | ParenthesizedExpression | JsxExpression).expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);             case SyntaxKind.BinaryExpression:                 switch ((node as BinaryExpression).operatorToken.kind) {                     case SyntaxKind.EqualsToken:                     case SyntaxKind.CommaToken:                         return elaborateError((node as BinaryExpression).right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);                 }                 break;             case SyntaxKind.ObjectLiteralExpression:                 return elaborateObjectLiteral(node as ObjectLiteralExpression, source, target, relation, containingMessageChain, errorOutputContainer);             case SyntaxKind.ArrayLiteralExpression:                 return elaborateArrayLiteral(node as ArrayLiteralExpression, source, target, relation, containingMessageChain, errorOutputContainer);             case SyntaxKind.JsxAttributes:                 return elaborateJsxComponents(node as JsxAttributes, source, target, relation, containingMessageChain, errorOutputContainer);             case SyntaxKind.ArrowFunction:                 return elaborateArrowFunction(node as ArrowFunction, source, target, relation, containingMessageChain, errorOutputContainer);         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    elaborateDidYouMeanToCallOrConstruct := func(node Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
        callSignatures := getSignaturesOfType(source, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
        constructSignatures := getSignaturesOfType(source, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO)
        /* TODO(ForOfStatement): for (const signatures of [constructSignatures, callSignatures]) {             if (                 some(signatures, s => {                     const returnType = getReturnTypeOfSignature(s);                     return !(returnType.flags & (TypeFlags.Any | TypeFlags.Never)) && checkTypeRelatedTo(returnType, target, relation, /*errorNode* / undefined);                 })             ) {                 const resultObj: { errors?: Diagnostic[]; } = errorOutputContainer || {};                 checkTypeAssignableTo(source, target, node, headMessage, containingMessageChain, resultObj);                 const diagnostic = resultObj.errors![resultObj.errors!.length - 1];                 addRelatedInfo(                     diagnostic,                     createDiagnosticForNode(                         node,                         signatures === constructSignatures ? Diagnostics.Did_you_mean_to_use_new_with_this_expression : Diagnostics.Did_you_mean_to_call_this_expression,                     ),                 );                 return true;             }         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    elaborateArrowFunction := func(node ArrowFunction, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
        if isBlock(/* TODO(PropertyAccessExpression): node.body */ TODO) {
             /* TODO(FalseKeyword): false */ TODO
        }
        if some(/* TODO(PropertyAccessExpression): node.parameters */ TODO, hasType) {
             /* TODO(FalseKeyword): false */ TODO
        }
        sourceSig := getSingleCallSignature(source)
        if /* TODO(PrefixUnaryExpression): !sourceSig */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        targetSignatures := getSignaturesOfType(target, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
        if /* TODO(PrefixUnaryExpression): !length(targetSignatures) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        returnExpression := /* TODO(PropertyAccessExpression): node.body */ TODO
        sourceReturn := getReturnTypeOfSignature(sourceSig)
        targetReturn := getUnionType(map_(targetSignatures, getReturnTypeOfSignature))
        if /* TODO(PrefixUnaryExpression): !checkTypeRelatedTo(sourceReturn, targetReturn, relation, /*errorNode* / undefined) */ TODO {
            elaborated := /* TODO(BinaryExpression): returnExpression && elaborateError(returnExpression, sourceReturn, targetReturn, relation, /*headMessage* / undefined, containingMessageChain, errorOutputContainer) */ TODO
            if elaborated {
                 elaborated
            }
            var resultObj /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ TODO = /* TODO(BinaryExpression): errorOutputContainer || {} */ TODO
            /* TODO(ExpressionStatement): checkTypeRelatedTo(sourceReturn, targetReturn, relation, returnExpression, /*headMessage* / undefined, containingMessageChain, resultObj); */
            if /* TODO(PropertyAccessExpression): resultObj.errors */ TODO {
                if /* TODO(BinaryExpression): target.symbol && length(target.symbol.declarations) */ TODO {
                    /* TODO(ExpressionStatement): addRelatedInfo(                         resultObj.errors[resultObj.errors.length - 1],                         createDiagnosticForNode(                             target.symbol.declarations![0],                             Diagnostics.The_expected_type_comes_from_the_return_type_of_this_signature,                         ),                     ); */
                }
                if /* TODO(BinaryExpression): (getFunctionFlags(node) & FunctionFlags.Async) === 0                     // exclude cases where source itself is promisy - this way we don't make a suggestion when relating                     // an IPromise and a Promise that are slightly different                     && !getTypeOfPropertyOfType(sourceReturn, "then" as __String)                     && checkTypeRelatedTo(createPromiseType(sourceReturn), targetReturn, relation, /*errorNode* / undefined) */ TODO {
                    /* TODO(ExpressionStatement): addRelatedInfo(                         resultObj.errors[resultObj.errors.length - 1],                         createDiagnosticForNode(                             node,                             Diagnostics.Did_you_mean_to_mark_this_function_as_async,                         ),                     ); */
                }
                 /* TODO(TrueKeyword): true */ TODO
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    getBestMatchIndexedAccessTypeOrUndefined := func(source Type, target Type, nameType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        idx := getIndexedAccessTypeOrUndefined(target, nameType)
        if idx {
             idx
        }
        if /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
            best := getBestMatchingType(source, target /* as */ /* TODO(TypeReference): UnionType */)
            if best {
                 getIndexedAccessTypeOrUndefined(best, nameType)
            }
        }
    }
    checkExpressionForMutableLocationWithContextualType := func(next Expression, sourcePropType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        /* TODO(ExpressionStatement): pushContextualType(next, sourcePropType, /*isCache* / false); */
        result := checkExpressionForMutableLocation(next, /* TODO(PropertyAccessExpression): CheckMode.Contextual */ TODO)
        /* TODO(ExpressionStatement): popContextualType(); */
         result
    }
    type ElaborationIterator IterableIterator[/* TODO(TypeLiteral): { errorNode: Node; innerExpression: Expression | undefined; nameType: Type; errorMessage?: DiagnosticMessage | undefined; } */ TODO]
    elaborateElementwise := func(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
        reportedError := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForOfStatement): for (const value of iterator) {             const { errorNode: prop, innerExpression: next, nameType, errorMessage } = value;             let targetPropType = getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType);             if (!targetPropType || targetPropType.flags & TypeFlags.IndexedAccess) continue; // Don't elaborate on indexes on generic variables             let sourcePropType = getIndexedAccessTypeOrUndefined(source, nameType);             if (!sourcePropType) continue;             const propName = getPropertyNameFromIndex(nameType, /*accessNode* / undefined);             if (!checkTypeRelatedTo(sourcePropType, targetPropType, relation, /*errorNode* / undefined)) {                 const elaborated = next && elaborateError(next, sourcePropType, targetPropType, relation, /*headMessage* / undefined, containingMessageChain, errorOutputContainer);                 reportedError = true;                 if (!elaborated) {                     // Issue error on the prop itself, since the prop couldn't elaborate the error                     const resultObj: { errors?: Diagnostic[]; } = errorOutputContainer || {};                     // Use the expression type, if available                     const specificSource = next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType;                     if (exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType)) {                         const diag = createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType));                         diagnostics.add(diag);                         resultObj.errors = [diag];                     }                     else {                         const targetIsOptional = !!(propName && (getPropertyOfType(target, propName) || unknownSymbol).flags & SymbolFlags.Optional);                         const sourceIsOptional = !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags & SymbolFlags.Optional);                         targetPropType = removeMissingType(targetPropType, targetIsOptional);                         sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional);                         const result = checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);                         if (result && specificSource !== sourcePropType) {                             // If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType                             checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);                         }                     }                     if (resultObj.errors) {                         const reportedDiag = resultObj.errors[resultObj.errors.length - 1];                         const propertyName = isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;                         const targetProp = propertyName !== undefined ? getPropertyOfType(target, propertyName) : undefined;                          let issuedElaboration = false;                         if (!targetProp) {                             const indexInfo = getApplicableIndexInfo(target, nameType);                             if (indexInfo && indexInfo.declaration && !getSourceFileOfNode(indexInfo.declaration).hasNoDefaultLib) {                                 issuedElaboration = true;                                 addRelatedInfo(reportedDiag, createDiagnosticForNode(indexInfo.declaration, Diagnostics.The_expected_type_comes_from_this_index_signature));                             }                         }                          if (!issuedElaboration && (targetProp && length(targetProp.declarations) || target.symbol && length(target.symbol.declarations))) {                             const targetNode = targetProp && length(targetProp.declarations) ? targetProp.declarations![0] : target.symbol.declarations![0];                             if (!getSourceFileOfNode(targetNode).hasNoDefaultLib) {                                 addRelatedInfo(                                     reportedDiag,                                     createDiagnosticForNode(                                         targetNode,                                         Diagnostics.The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1,                                         propertyName && !(nameType.flags & TypeFlags.UniqueESSymbol) ? unescapeLeadingUnderscores(propertyName) : typeToString(nameType),                                         typeToString(target),                                     ),                                 );                             }                         }                     }                 }             }         } */
         reportedError
    }
    elaborateIterableOrArrayLikeTargetElementwise := func(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
        tupleOrArrayLikeTargetParts := filterType(target, isArrayOrTupleLikeType)
        nonTupleOrArrayLikeTargetParts := filterType(target, /* TODO(ArrowFunction): t => !isArrayOrTupleLikeType(t) */ TODO)
        iterationType := /* TODO(ConditionalExpression): nonTupleOrArrayLikeTargetParts !== neverType             ? getIterationTypeOfIterable(IterationUse.ForOf, IterationTypeKind.Yield, nonTupleOrArrayLikeTargetParts, /*errorNode* / undefined)             : undefined */ TODO
        reportedError := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForStatement): for (let status = iterator.next(); !status.done; status = iterator.next()) {             const { errorNode: prop, innerExpression: next, nameType, errorMessage } = status.value;             let targetPropType = iterationType;             const targetIndexedPropType = tupleOrArrayLikeTargetParts !== neverType ? getBestMatchIndexedAccessTypeOrUndefined(source, tupleOrArrayLikeTargetParts, nameType) : undefined;             if (targetIndexedPropType && !(targetIndexedPropType.flags & TypeFlags.IndexedAccess)) { // Don't elaborate on indexes on generic variables                 targetPropType = iterationType ? getUnionType([iterationType, targetIndexedPropType]) : targetIndexedPropType;             }             if (!targetPropType) continue;             let sourcePropType = getIndexedAccessTypeOrUndefined(source, nameType);             if (!sourcePropType) continue;             const propName = getPropertyNameFromIndex(nameType, /*accessNode* / undefined);             if (!checkTypeRelatedTo(sourcePropType, targetPropType, relation, /*errorNode* / undefined)) {                 const elaborated = next && elaborateError(next, sourcePropType, targetPropType, relation, /*headMessage* / undefined, containingMessageChain, errorOutputContainer);                 reportedError = true;                 if (!elaborated) {                     // Issue error on the prop itself, since the prop couldn't elaborate the error                     const resultObj: { errors?: Diagnostic[]; } = errorOutputContainer || {};                     // Use the expression type, if available                     const specificSource = next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType;                     if (exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType)) {                         const diag = createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType));                         diagnostics.add(diag);                         resultObj.errors = [diag];                     }                     else {                         const targetIsOptional = !!(propName && (getPropertyOfType(tupleOrArrayLikeTargetParts, propName) || unknownSymbol).flags & SymbolFlags.Optional);                         const sourceIsOptional = !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags & SymbolFlags.Optional);                         targetPropType = removeMissingType(targetPropType, targetIsOptional);                         sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional);                         const result = checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);                         if (result && specificSource !== sourcePropType) {                             // If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType                             checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);                         }                     }                 }             }         } */
         reportedError
    }
    generateJsxAttributes := func(node JsxAttributes) ElaborationIterator {
        if /* TODO(PrefixUnaryExpression): !length(node.properties) */ TODO {
        }
        /* TODO(ForOfStatement): for (const prop of node.properties) {             if (isJsxSpreadAttribute(prop) || isHyphenatedJsxName(getTextOfJsxAttributeName(prop.name))) continue;             yield { errorNode: prop.name, innerExpression: prop.initializer, nameType: getStringLiteralType(getTextOfJsxAttributeName(prop.name)) };         } */
    }
    generateJsxChildren := func(node JsxElement, getInvalidTextDiagnostic func() DiagnosticMessage) ElaborationIterator {
        if /* TODO(PrefixUnaryExpression): !length(node.children) */ TODO {
        }
        memberOffset := 0
        /* TODO(ForStatement): for (let i = 0; i < node.children.length; i++) {             const child = node.children[i];             const nameType = getNumberLiteralType(i - memberOffset);             const elem = getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic);             if (elem) {                 yield elem;             }             else {                 memberOffset++;             }         } */
    }
    getElaborationElementForJsxChild := func(child JsxChild, nameType LiteralType, getInvalidTextDiagnostic func() DiagnosticMessage) /* TODO(undefined): { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxExpression; innerExpression: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage?: undefined; } | { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxText; innerExpression: undefined; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage; } | { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSelfClosingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxFragment; innerExpression: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSelfClosingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxFragment; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage?: undefined; } | undefined */ TODO {
        /* TODO(SwitchStatement): switch (child.kind) {             case SyntaxKind.JsxExpression:                 // child is of the type of the expression                 return { errorNode: child, innerExpression: child.expression, nameType };             case SyntaxKind.JsxText:                 if (child.containsOnlyTriviaWhiteSpaces) {                     break; // Whitespace only jsx text isn't real jsx text                 }                 // child is a string                 return { errorNode: child, innerExpression: undefined, nameType, errorMessage: getInvalidTextDiagnostic() };             case SyntaxKind.JsxElement:             case SyntaxKind.JsxSelfClosingElement:             case SyntaxKind.JsxFragment:                 // child is of type JSX.Element                 return { errorNode: child, innerExpression: child, nameType };             default:                 return Debug.assertNever(child, "Found invalid jsx child");         } */
    }
    elaborateJsxComponents := func(node JsxAttributes, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
        result := elaborateElementwise(generateJsxAttributes(node), source, target, relation, containingMessageChain, errorOutputContainer)
        var invalidTextDiagnostic *DiagnosticMessage
        if /* TODO(BinaryExpression): isJsxOpeningElement(node.parent) && isJsxElement(node.parent.parent) */ TODO {
            containingElement := /* TODO(PropertyAccessExpression): node.parent.parent */ TODO
            childPropName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
            childrenPropName := /* TODO(ConditionalExpression): childPropName === undefined ? "children" : unescapeLeadingUnderscores(childPropName) */ TODO
            childrenNameType := getStringLiteralType(childrenPropName)
            childrenTargetType := getIndexedAccessType(target, childrenNameType)
            validChildren := getSemanticJsxChildren(/* TODO(PropertyAccessExpression): containingElement.children */ TODO)
            if /* TODO(PrefixUnaryExpression): !length(validChildren) */ TODO {
                 result
            }
            moreThanOneRealChildren := /* TODO(BinaryExpression): length(validChildren) > 1 */ TODO
            var arrayLikeTargetParts Type
            var nonArrayLikeTargetParts Type
            iterableType := getGlobalIterableType(/* TODO(FalseKeyword): false */ TODO)
            if /* TODO(BinaryExpression): iterableType !== emptyGenericType */ TODO {
                anyIterable := createIterableType(anyType)
                /* TODO(ExpressionStatement): arrayLikeTargetParts = filterType(childrenTargetType, t => isTypeAssignableTo(t, anyIterable)); */
                /* TODO(ExpressionStatement): nonArrayLikeTargetParts = filterType(childrenTargetType, t => !isTypeAssignableTo(t, anyIterable)); */
            } else {
                /* TODO(ExpressionStatement): arrayLikeTargetParts = filterType(childrenTargetType, isArrayOrTupleLikeType); */
                /* TODO(ExpressionStatement): nonArrayLikeTargetParts = filterType(childrenTargetType, t => !isArrayOrTupleLikeType(t)); */
            }
            if moreThanOneRealChildren {
                if /* TODO(BinaryExpression): arrayLikeTargetParts !== neverType */ TODO {
                    realSource := createTupleType(checkJsxChildren(containingElement, /* TODO(PropertyAccessExpression): CheckMode.Normal */ TODO))
                    children := generateJsxChildren(containingElement, getInvalidTextualChildDiagnostic)
                    /* TODO(ExpressionStatement): result = elaborateIterableOrArrayLikeTargetElementwise(children, realSource, arrayLikeTargetParts, relation, containingMessageChain, errorOutputContainer) || result; */
                } else if /* TODO(PrefixUnaryExpression): !isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) */ TODO {
                    /* TODO(ExpressionStatement): result = true; */
                    diag := error(/* TODO(PropertyAccessExpression): containingElement.openingElement.tagName */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided */ TODO, childrenPropName, typeToString(childrenTargetType))
                    if /* TODO(BinaryExpression): errorOutputContainer && errorOutputContainer.skipLogging */ TODO {
                        /* TODO(ExpressionStatement): (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag); */
                    }
                }
            } else {
                if /* TODO(BinaryExpression): nonArrayLikeTargetParts !== neverType */ TODO {
                    child := /* TODO(ElementAccessExpression): validChildren[0] */ TODO
                    elem := getElaborationElementForJsxChild(child, childrenNameType, getInvalidTextualChildDiagnostic)
                    if elem {
                        /* TODO(ExpressionStatement): result = elaborateElementwise(                             (function* () {                                 yield elem;                             })(),                             source,                             target,                             relation,                             containingMessageChain,                             errorOutputContainer,                         ) || result; */
                    }
                } else if /* TODO(PrefixUnaryExpression): !isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) */ TODO {
                    /* TODO(ExpressionStatement): result = true; */
                    diag := error(/* TODO(PropertyAccessExpression): containingElement.openingElement.tagName */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided */ TODO, childrenPropName, typeToString(childrenTargetType))
                    if /* TODO(BinaryExpression): errorOutputContainer && errorOutputContainer.skipLogging */ TODO {
                        /* TODO(ExpressionStatement): (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag); */
                    }
                }
            }
        }
         result
        getInvalidTextualChildDiagnostic := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO {
            if /* TODO(PrefixUnaryExpression): !invalidTextDiagnostic */ TODO {
                tagNameText := getTextOfNode(/* TODO(PropertyAccessExpression): node.parent.tagName */ TODO)
                childPropName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
                childrenPropName := /* TODO(ConditionalExpression): childPropName === undefined ? "children" : unescapeLeadingUnderscores(childPropName) */ TODO
                childrenTargetType := getIndexedAccessType(target, getStringLiteralType(childrenPropName))
                diagnostic := /* TODO(PropertyAccessExpression): Diagnostics._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2 */ TODO
                /* TODO(ExpressionStatement): invalidTextDiagnostic = { ...diagnostic, key: "!!ALREADY FORMATTED!!", message: formatMessage(diagnostic, tagNameText, childrenPropName, typeToString(childrenTargetType)) }; */
            }
             invalidTextDiagnostic
        }
    }
    generateLimitedTupleElements := func(node ArrayLiteralExpression, target Type) ElaborationIterator {
        len := length(/* TODO(PropertyAccessExpression): node.elements */ TODO)
        if /* TODO(PrefixUnaryExpression): !len */ TODO {
        }
        /* TODO(ForStatement): for (let i = 0; i < len; i++) {             // Skip elements which do not exist in the target - a length error on the tuple overall is likely better than an error on a mismatched index signature             if (isTupleLikeType(target) && !getPropertyOfType(target, ("" + i) as __String)) continue;             const elem = node.elements[i];             if (isOmittedExpression(elem)) continue;             const nameType = getNumberLiteralType(i);             const checkNode = getEffectiveCheckNode(elem);             yield { errorNode: checkNode, innerExpression: checkNode, nameType };         } */
    }
    elaborateArrayLiteral := func(node ArrayLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): target.flags & (TypeFlags.Primitive | TypeFlags.Never) */ TODO {
            /* TODO(FalseKeyword): false */
        }
        if isTupleLikeType(source) {
             elaborateElementwise(generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer)
        }
        /* TODO(ExpressionStatement): pushContextualType(node, target, /*isCache* / false); */
        tupleizedType := checkArrayLiteral(node, /* TODO(PropertyAccessExpression): CheckMode.Contextual */ TODO, /* TODO(TrueKeyword): true */ TODO)
        /* TODO(ExpressionStatement): popContextualType(); */
        if isTupleLikeType(tupleizedType) {
             elaborateElementwise(generateLimitedTupleElements(node, target), tupleizedType, target, relation, containingMessageChain, errorOutputContainer)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    generateObjectLiteralElements := func(node ObjectLiteralExpression) ElaborationIterator {
        if /* TODO(PrefixUnaryExpression): !length(node.properties) */ TODO {
        }
        /* TODO(ForOfStatement): for (const prop of node.properties) {             if (isSpreadAssignment(prop)) continue;             const type = getLiteralTypeFromProperty(getSymbolOfDeclaration(prop), TypeFlags.StringOrNumberLiteralOrUnique);             if (!type || (type.flags & TypeFlags.Never)) {                 continue;             }             switch (prop.kind) {                 case SyntaxKind.SetAccessor:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.ShorthandPropertyAssignment:                     yield { errorNode: prop.name, innerExpression: undefined, nameType: type };                     break;                 case SyntaxKind.PropertyAssignment:                     yield { errorNode: prop.name, innerExpression: prop.initializer, nameType: type, errorMessage: isComputedNonLiteralName(prop.name) ? Diagnostics.Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1 : undefined };                     break;                 default:                     Debug.assertNever(prop);             }         } */
    }
    elaborateObjectLiteral := func(node ObjectLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): target.flags & (TypeFlags.Primitive | TypeFlags.Never) */ TODO {
            /* TODO(FalseKeyword): false */
        }
         elaborateElementwise(generateObjectLiteralElements(node), source, target, relation, containingMessageChain, errorOutputContainer)
    }
    checkTypeComparableTo := func(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
         checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain)
    }
    isSignatureAssignableTo := func(source Signature, target Signature, ignoreReturnTypes bool) bool {
         /* TODO(BinaryExpression): compareSignaturesRelated(source, target, ignoreReturnTypes ? SignatureCheckMode.IgnoreReturnTypes : SignatureCheckMode.None, /*reportErrors* / false, /*errorReporter* / undefined, /*incompatibleErrorReporter* / undefined, compareTypesAssignable, /*reportUnreliableMarkers* / undefined) !== Ternary.False */ TODO
    }
    type ErrorReporter func(message DiagnosticMessage, args DiagnosticArguments) 
    isTopSignature := func(s Signature) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): !s.typeParameters && (!s.thisParameter || isTypeAny(getTypeOfParameter(s.thisParameter))) && s.parameters.length === 1 && signatureHasRestParameter(s) */ TODO {
            paramType := getTypeOfParameter(/* TODO(ElementAccessExpression): s.parameters[0] */ TODO)
            restType := /* TODO(ConditionalExpression): isArrayType(paramType) ? getTypeArguments(paramType)[0] : paramType */ TODO
             /* TODO(PrefixUnaryExpression): !!(restType.flags & (TypeFlags.Any | TypeFlags.Never) && getReturnTypeOfSignature(s).flags & TypeFlags.AnyOrUnknown) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    compareSignaturesRelated := func(source Signature, target Signature, checkMode SignatureCheckMode, reportErrors bool, errorReporter *ErrorReporter, incompatibleErrorReporter /* TODO(ParenthesizedType): ((source: Type, target: Type) => void) */ any, compareTypes TypeComparer, reportUnreliableMarkers *TypeMapper) Ternary {
        if /* TODO(BinaryExpression): source === target */ TODO {
             /* TODO(PropertyAccessExpression): Ternary.True */ TODO
        }
        if /* TODO(BinaryExpression): !(checkMode & SignatureCheckMode.StrictTopSignature && isTopSignature(source)) && isTopSignature(target) */ TODO {
             /* TODO(PropertyAccessExpression): Ternary.True */ TODO
        }
        if /* TODO(BinaryExpression): checkMode & SignatureCheckMode.StrictTopSignature && isTopSignature(source) && !isTopSignature(target) */ TODO {
             /* TODO(PropertyAccessExpression): Ternary.False */ TODO
        }
        targetCount := getParameterCount(target)
        sourceHasMoreParameters := /* TODO(BinaryExpression): !hasEffectiveRestParameter(target) &&             (checkMode & SignatureCheckMode.StrictArity ? hasEffectiveRestParameter(source) || getParameterCount(source) > targetCount : getMinArgumentCount(source) > targetCount) */ TODO
        if sourceHasMoreParameters {
            if /* TODO(BinaryExpression): reportErrors && !(checkMode & SignatureCheckMode.StrictArity) */ TODO {
                /* TODO(ExpressionStatement): errorReporter!(Diagnostics.Target_signature_provides_too_few_arguments_Expected_0_or_more_but_got_1, getMinArgumentCount(source), targetCount); */
            }
             /* TODO(PropertyAccessExpression): Ternary.False */ TODO
        }
        if /* TODO(BinaryExpression): source.typeParameters && source.typeParameters !== target.typeParameters */ TODO {
            /* TODO(ExpressionStatement): target = getCanonicalSignature(target); */
            /* TODO(ExpressionStatement): source = instantiateSignatureInContextOf(source, target, /*inferenceContext* / undefined, compareTypes); */
        }
        sourceCount := getParameterCount(source)
        sourceRestType := getNonArrayRestType(source)
        targetRestType := getNonArrayRestType(target)
        if /* TODO(BinaryExpression): sourceRestType || targetRestType */ TODO {
            /* TODO(ExpressionStatement): void instantiateType(sourceRestType || targetRestType, reportUnreliableMarkers); */
        }
        kind := /* TODO(ConditionalExpression): target.declaration ? target.declaration.kind : SyntaxKind.Unknown */ TODO
        strictVariance := /* TODO(BinaryExpression): !(checkMode & SignatureCheckMode.Callback) && strictFunctionTypes && kind !== SyntaxKind.MethodDeclaration &&             kind !== SyntaxKind.MethodSignature && kind !== SyntaxKind.Constructor */ TODO
        result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
        sourceThisType := getThisTypeOfSignature(source)
        if /* TODO(BinaryExpression): sourceThisType && sourceThisType !== voidType */ TODO {
            targetThisType := getThisTypeOfSignature(target)
            if targetThisType {
                related := /* TODO(BinaryExpression): !strictVariance && compareTypes(sourceThisType, targetThisType, /*reportErrors* / false)                     || compareTypes(targetThisType, sourceThisType, reportErrors) */ TODO
                if /* TODO(PrefixUnaryExpression): !related */ TODO {
                    if reportErrors {
                        /* TODO(ExpressionStatement): errorReporter!(Diagnostics.The_this_types_of_each_signature_are_incompatible); */
                    }
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
                /* TODO(ExpressionStatement): result &= related; */
            }
        }
        paramCount := /* TODO(ConditionalExpression): sourceRestType || targetRestType ? Math.min(sourceCount, targetCount) : Math.max(sourceCount, targetCount) */ TODO
        restIndex := /* TODO(ConditionalExpression): sourceRestType || targetRestType ? paramCount - 1 : -1 */ TODO
        /* TODO(ForStatement): for (let i = 0; i < paramCount; i++) {             const sourceType = i === restIndex ? getRestOrAnyTypeAtPosition(source, i) : tryGetTypeAtPosition(source, i);             const targetType = i === restIndex ? getRestOrAnyTypeAtPosition(target, i) : tryGetTypeAtPosition(target, i);             if (sourceType && targetType && (sourceType !== targetType || checkMode & SignatureCheckMode.StrictArity)) {                 // In order to ensure that any generic type Foo<T> is at least co-variant with respect to T no matter                 // how Foo uses T, we need to relate parameters bi-variantly (given that parameters are input positions,                 // they naturally relate only contra-variantly). However, if the source and target parameters both have                 // function types with a single call signature, we know we are relating two callback parameters. In                 // that case it is sufficient to only relate the parameters of the signatures co-variantly because,                 // similar to return values, callback parameters are output positions. This means that a Promise<T>,                 // where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant)                 // with respect to T.                 const sourceSig = checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(source, i) ? undefined : getSingleCallSignature(getNonNullableType(sourceType));                 const targetSig = checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(target, i) ? undefined : getSingleCallSignature(getNonNullableType(targetType));                 const callbacks = sourceSig && targetSig && !getTypePredicateOfSignature(sourceSig) && !getTypePredicateOfSignature(targetSig) &&                     getTypeFacts(sourceType, TypeFacts.IsUndefinedOrNull) === getTypeFacts(targetType, TypeFacts.IsUndefinedOrNull);                 let related = callbacks ?                     compareSignaturesRelated(targetSig, sourceSig, (checkMode & SignatureCheckMode.StrictArity) | (strictVariance ? SignatureCheckMode.StrictCallback : SignatureCheckMode.BivariantCallback), reportErrors, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers) :                     !(checkMode & SignatureCheckMode.Callback) && !strictVariance && compareTypes(sourceType, targetType, /*reportErrors* / false) || compareTypes(targetType, sourceType, reportErrors);                 // With strict arity, (x: number | undefined) => void is a subtype of (x?: number | undefined) => void                 if (related && checkMode & SignatureCheckMode.StrictArity && i >= getMinArgumentCount(source) && i < getMinArgumentCount(target) && compareTypes(sourceType, targetType, /*reportErrors* / false)) {                     related = Ternary.False;                 }                 if (!related) {                     if (reportErrors) {                         errorReporter!(Diagnostics.Types_of_parameters_0_and_1_are_incompatible, unescapeLeadingUnderscores(getParameterNameAtPosition(source, i)), unescapeLeadingUnderscores(getParameterNameAtPosition(target, i)));                     }                     return Ternary.False;                 }                 result &= related;             }         } */
        if /* TODO(PrefixUnaryExpression): !(checkMode & SignatureCheckMode.IgnoreReturnTypes) */ TODO {
            targetReturnType := /* TODO(ConditionalExpression): isResolvingReturnTypeOfSignature(target) ? anyType                 : target.declaration && isJSConstructor(target.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(target.declaration.symbol))                 : getReturnTypeOfSignature(target) */ TODO
            if /* TODO(BinaryExpression): targetReturnType === voidType || targetReturnType === anyType */ TODO {
                 result
            }
            sourceReturnType := /* TODO(ConditionalExpression): isResolvingReturnTypeOfSignature(source) ? anyType                 : source.declaration && isJSConstructor(source.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(source.declaration.symbol))                 : getReturnTypeOfSignature(source) */ TODO
            targetTypePredicate := getTypePredicateOfSignature(target)
            if targetTypePredicate {
                sourceTypePredicate := getTypePredicateOfSignature(source)
                if sourceTypePredicate {
                    /* TODO(ExpressionStatement): result &= compareTypePredicateRelatedTo(sourceTypePredicate, targetTypePredicate, reportErrors, errorReporter, compareTypes); */
                } else if /* TODO(BinaryExpression): isIdentifierTypePredicate(targetTypePredicate) || isThisTypePredicate(targetTypePredicate) */ TODO {
                    if reportErrors {
                        /* TODO(ExpressionStatement): errorReporter!(Diagnostics.Signature_0_must_be_a_type_predicate, signatureToString(source)); */
                    }
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
            } else {
                /* TODO(ExpressionStatement): result &= checkMode & SignatureCheckMode.BivariantCallback && compareTypes(targetReturnType, sourceReturnType, /*reportErrors* / false) ||                     compareTypes(sourceReturnType, targetReturnType, reportErrors); */
                if /* TODO(BinaryExpression): !result && reportErrors && incompatibleErrorReporter */ TODO {
                    /* TODO(ExpressionStatement): incompatibleErrorReporter(sourceReturnType, targetReturnType); */
                }
            }
        }
         result
    }
    compareTypePredicateRelatedTo := func(source TypePredicate, target TypePredicate, reportErrors bool, errorReporter *ErrorReporter, compareTypes func(s Type, t Type, reportErrors bool) Ternary) Ternary {
        if /* TODO(BinaryExpression): source.kind !== target.kind */ TODO {
            if reportErrors {
                /* TODO(ExpressionStatement): errorReporter!(Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard); */
                /* TODO(ExpressionStatement): errorReporter!(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target)); */
            }
             /* TODO(PropertyAccessExpression): Ternary.False */ TODO
        }
        if /* TODO(BinaryExpression): source.kind === TypePredicateKind.Identifier || source.kind === TypePredicateKind.AssertsIdentifier */ TODO {
            if /* TODO(BinaryExpression): source.parameterIndex !== (target as IdentifierTypePredicate).parameterIndex */ TODO {
                if reportErrors {
                    /* TODO(ExpressionStatement): errorReporter!(Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1, source.parameterName, (target as IdentifierTypePredicate).parameterName); */
                    /* TODO(ExpressionStatement): errorReporter!(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target)); */
                }
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
        }
        related := /* TODO(ConditionalExpression): source.type === target.type ? Ternary.True :             source.type && target.type ? compareTypes(source.type, target.type, reportErrors) :             Ternary.False */ TODO
        if /* TODO(BinaryExpression): related === Ternary.False && reportErrors */ TODO {
            /* TODO(ExpressionStatement): errorReporter!(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target)); */
        }
         related
    }
    isImplementationCompatibleWithOverload := func(implementation Signature, overload Signature) bool {
        erasedSource := getErasedSignature(implementation)
        erasedTarget := getErasedSignature(overload)
        sourceReturnType := getReturnTypeOfSignature(erasedSource)
        targetReturnType := getReturnTypeOfSignature(erasedTarget)
        if /* TODO(BinaryExpression): targetReturnType === voidType             || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation)             || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation) */ TODO {
             isSignatureAssignableTo(erasedSource, erasedTarget, /* TODO(TrueKeyword): true */ TODO)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isEmptyResolvedType := func(t ResolvedType) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): t !== anyFunctionType &&             t.properties.length === 0 &&             t.callSignatures.length === 0 &&             t.constructSignatures.length === 0 &&             t.indexInfos.length === 0 */ TODO
    }
    isEmptyObjectType := func(type_ Type) bool {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Object ? !isGenericMappedType(type) && isEmptyResolvedType(resolveStructuredTypeMembers(type as ObjectType)) :             type.flags & TypeFlags.NonPrimitive ? true :             type.flags & TypeFlags.Union ? some((type as UnionType).types, isEmptyObjectType) :             type.flags & TypeFlags.Intersection ? every((type as UnionType).types, isEmptyObjectType) :             false */ TODO
    }
    isEmptyAnonymousObjectType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(getObjectFlags(type) & ObjectFlags.Anonymous && (             (type as ResolvedType).members && isEmptyResolvedType(type as ResolvedType) ||             type.symbol && type.symbol.flags & SymbolFlags.TypeLiteral && getMembersOfSymbol(type.symbol).size === 0         )) */ TODO
    }
    isUnknownLikeUnionType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): strictNullChecks && type.flags & TypeFlags.Union */ TODO {
            if /* TODO(PrefixUnaryExpression): !((type as UnionType).objectFlags & ObjectFlags.IsUnknownLikeUnionComputed) */ TODO {
                types := /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO
                /* TODO(ExpressionStatement): (type as UnionType).objectFlags |= ObjectFlags.IsUnknownLikeUnionComputed | (types.length >= 3 && types[0].flags & TypeFlags.Undefined &&                         types[1].flags & TypeFlags.Null && some(types, isEmptyAnonymousObjectType) ? ObjectFlags.IsUnknownLikeUnion : 0); */
            }
             /* TODO(PrefixUnaryExpression): !!((type as UnionType).objectFlags & ObjectFlags.IsUnknownLikeUnion) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    containsUndefinedType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!((type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type).flags & TypeFlags.Undefined) */ TODO
    }
    containsNonMissingUndefinedType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
        candidate := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type */ TODO
         /* TODO(BinaryExpression): !!(candidate.flags & TypeFlags.Undefined) && candidate !== missingType */ TODO
    }
    isStringIndexSignatureOnlyType := func(type_ Type) bool {
         /* TODO(BinaryExpression): type.flags & TypeFlags.Object && !isGenericMappedType(type) && getPropertiesOfType(type).length === 0 && getIndexInfosOfType(type).length === 1 && !!getIndexInfoOfType(type, stringType) ||             type.flags & TypeFlags.UnionOrIntersection && every((type as UnionOrIntersectionType).types, isStringIndexSignatureOnlyType) ||             false */ TODO
    }
    isEnumTypeRelatedTo := func(source Symbol, target Symbol, errorReporter ErrorReporter) /* TODO(undefined): boolean */ TODO {
        sourceSymbol := /* TODO(ConditionalExpression): source.flags & SymbolFlags.EnumMember ? getParentOfSymbol(source)! : source */ TODO
        targetSymbol := /* TODO(ConditionalExpression): target.flags & SymbolFlags.EnumMember ? getParentOfSymbol(target)! : target */ TODO
        if /* TODO(BinaryExpression): sourceSymbol === targetSymbol */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): sourceSymbol.escapedName !== targetSymbol.escapedName || !(sourceSymbol.flags & SymbolFlags.RegularEnum) || !(targetSymbol.flags & SymbolFlags.RegularEnum) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        id := /* TODO(BinaryExpression): getSymbolId(sourceSymbol) + "," + getSymbolId(targetSymbol) */ TODO
        entry := /* TODO(PropertyAccessExpression): enumRelation.get */ TODO(id)
        if /* TODO(BinaryExpression): entry !== undefined && !(entry & RelationComparisonResult.Failed && errorReporter) */ TODO {
             /* TODO(PrefixUnaryExpression): !!(entry & RelationComparisonResult.Succeeded) */ TODO
        }
        targetEnumType := getTypeOfSymbol(targetSymbol)
        /* TODO(ForOfStatement): for (const sourceProperty of getPropertiesOfType(getTypeOfSymbol(sourceSymbol))) {             if (sourceProperty.flags & SymbolFlags.EnumMember) {                 const targetProperty = getPropertyOfType(targetEnumType, sourceProperty.escapedName);                 if (!targetProperty || !(targetProperty.flags & SymbolFlags.EnumMember)) {                     if (errorReporter) {                         errorReporter(Diagnostics.Property_0_is_missing_in_type_1, symbolName(sourceProperty), typeToString(getDeclaredTypeOfSymbol(targetSymbol), /*enclosingDeclaration* / undefined, TypeFormatFlags.UseFullyQualifiedType));                     }                     enumRelation.set(id, RelationComparisonResult.Failed);                     return false;                 }                 const sourceValue = getEnumMemberValue(getDeclarationOfKind(sourceProperty, SyntaxKind.EnumMember)!).value;                 const targetValue = getEnumMemberValue(getDeclarationOfKind(targetProperty, SyntaxKind.EnumMember)!).value;                 if (sourceValue !== targetValue) {                     const sourceIsString = typeof sourceValue === "string";                     const targetIsString = typeof targetValue === "string";                      // If we have 2 enums with *known* values that differ, they are incompatible.                     if (sourceValue !== undefined && targetValue !== undefined) {                         if (errorReporter) {                             const escapedSource = sourceIsString ? `"${escapeString(sourceValue)}"` : sourceValue;                             const escapedTarget = targetIsString ? `"${escapeString(targetValue)}"` : targetValue;                             errorReporter(Diagnostics.Each_declaration_of_0_1_differs_in_its_value_where_2_was_expected_but_3_was_given, symbolName(targetSymbol), symbolName(targetProperty), escapedTarget, escapedSource);                         }                         enumRelation.set(id, RelationComparisonResult.Failed);                         return false;                     }                      // At this point we know that at least one of the values is 'undefined'.                     // This may mean that we have an opaque member from an ambient enum declaration,                     // or that we were not able to calculate it (which is basically an error).                     //                     // Either way, we can assume that it's numeric.                     // If the other is a string, we have a mismatch in types.                     if (sourceIsString || targetIsString) {                         if (errorReporter) {                             const knownStringValue = sourceValue ?? targetValue;                             Debug.assert(typeof knownStringValue === "string");                             const escapedValue = `"${escapeString(knownStringValue)}"`;                             errorReporter(Diagnostics.One_value_of_0_1_is_the_string_2_and_the_other_is_assumed_to_be_an_unknown_numeric_value, symbolName(targetSymbol), symbolName(targetProperty), escapedValue);                         }                         enumRelation.set(id, RelationComparisonResult.Failed);                         return false;                     }                 }             }         } */
        /* TODO(ExpressionStatement): enumRelation.set(id, RelationComparisonResult.Succeeded); */
         /* TODO(TrueKeyword): true */ TODO
    }
    isSimpleTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorReporter ErrorReporter) /* TODO(undefined): boolean */ TODO {
        s := /* TODO(PropertyAccessExpression): source.flags */ TODO
        t := /* TODO(PropertyAccessExpression): target.flags */ TODO
        if /* TODO(BinaryExpression): t & TypeFlags.Any || s & TypeFlags.Never || source === wildcardType */ TODO {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): t & TypeFlags.Unknown && !(relation === strictSubtypeRelation && s & TypeFlags.Any) */ TODO {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): t & TypeFlags.Never */ TODO {
            /* TODO(FalseKeyword): false */
        }
        if /* TODO(BinaryExpression): s & TypeFlags.StringLike && t & TypeFlags.String */ TODO {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): s & TypeFlags.StringLiteral && s & TypeFlags.EnumLiteral &&             t & TypeFlags.StringLiteral && !(t & TypeFlags.EnumLiteral) &&             (source as StringLiteralType).value === (target as StringLiteralType).value */ TODO {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): s & TypeFlags.NumberLike && t & TypeFlags.Number */ TODO {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): s & TypeFlags.NumberLiteral && s & TypeFlags.EnumLiteral &&             t & TypeFlags.NumberLiteral && !(t & TypeFlags.EnumLiteral) &&             (source as NumberLiteralType).value === (target as NumberLiteralType).value */ TODO {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): s & TypeFlags.BigIntLike && t & TypeFlags.BigInt */ TODO {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): s & TypeFlags.BooleanLike && t & TypeFlags.Boolean */ TODO {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): s & TypeFlags.ESSymbolLike && t & TypeFlags.ESSymbol */ TODO {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): s & TypeFlags.Enum && t & TypeFlags.Enum && source.symbol.escapedName === target.symbol.escapedName &&             isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) */ TODO {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): s & TypeFlags.EnumLiteral && t & TypeFlags.EnumLiteral */ TODO {
            if /* TODO(BinaryExpression): s & TypeFlags.Union && t & TypeFlags.Union && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) */ TODO {
                /* TODO(TrueKeyword): true */
            }
            if /* TODO(BinaryExpression): s & TypeFlags.Literal && t & TypeFlags.Literal && (source as LiteralType).value === (target as LiteralType).value &&                 isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) */ TODO {
                /* TODO(TrueKeyword): true */
            }
        }
        if /* TODO(BinaryExpression): s & TypeFlags.Undefined && (!strictNullChecks && !(t & TypeFlags.UnionOrIntersection) || t & (TypeFlags.Undefined | TypeFlags.Void)) */ TODO {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): s & TypeFlags.Null && (!strictNullChecks && !(t & TypeFlags.UnionOrIntersection) || t & TypeFlags.Null) */ TODO {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): s & TypeFlags.Object && t & TypeFlags.NonPrimitive && !(relation === strictSubtypeRelation && isEmptyAnonymousObjectType(source) && !(getObjectFlags(source) & ObjectFlags.FreshLiteral)) */ TODO {
            /* TODO(TrueKeyword): true */
        }
        if /* TODO(BinaryExpression): relation === assignableRelation || relation === comparableRelation */ TODO {
            if /* TODO(BinaryExpression): s & TypeFlags.Any */ TODO {
                /* TODO(TrueKeyword): true */
            }
            if /* TODO(BinaryExpression): s & TypeFlags.Number && (t & TypeFlags.Enum || t & TypeFlags.NumberLiteral && t & TypeFlags.EnumLiteral) */ TODO {
                /* TODO(TrueKeyword): true */
            }
            if /* TODO(BinaryExpression): s & TypeFlags.NumberLiteral && !(s & TypeFlags.EnumLiteral) && (t & TypeFlags.Enum ||                     t & TypeFlags.NumberLiteral && t & TypeFlags.EnumLiteral &&                         (source as NumberLiteralType).value === (target as NumberLiteralType).value) */ TODO {
                /* TODO(TrueKeyword): true */
            }
            if isUnknownLikeUnionType(target) {
                /* TODO(TrueKeyword): true */
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult]) /* TODO(undefined): boolean */ TODO {
        if isFreshLiteralType(source) {
            /* TODO(ExpressionStatement): source = (source as FreshableType).regularType; */
        }
        if isFreshLiteralType(target) {
            /* TODO(ExpressionStatement): target = (target as FreshableType).regularType; */
        }
        if /* TODO(BinaryExpression): source === target */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
            if /* TODO(BinaryExpression): relation === comparableRelation && !(target.flags & TypeFlags.Never) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation) */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
        } else if /* TODO(PrefixUnaryExpression): !((source.flags | target.flags) & (TypeFlags.UnionOrIntersection | TypeFlags.IndexedAccess | TypeFlags.Conditional | TypeFlags.Substitution)) */ TODO {
            if /* TODO(BinaryExpression): source.flags !== target.flags */ TODO {
                /* TODO(FalseKeyword): false */
            }
            if /* TODO(BinaryExpression): source.flags & TypeFlags.Singleton */ TODO {
                /* TODO(TrueKeyword): true */
            }
        }
        if /* TODO(BinaryExpression): source.flags & TypeFlags.Object && target.flags & TypeFlags.Object */ TODO {
            related := /* TODO(PropertyAccessExpression): relation.get */ TODO(getRelationKey(source, target, /* TODO(PropertyAccessExpression): IntersectionState.None */ TODO, relation, /* TODO(FalseKeyword): false */ TODO))
            if /* TODO(BinaryExpression): related !== undefined */ TODO {
                 /* TODO(PrefixUnaryExpression): !!(related & RelationComparisonResult.Succeeded) */ TODO
            }
        }
        if /* TODO(BinaryExpression): source.flags & TypeFlags.StructuredOrInstantiable || target.flags & TypeFlags.StructuredOrInstantiable */ TODO {
             checkTypeRelatedTo(source, target, relation, undefined)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isIgnoredJsxProperty := func(source Type, sourceProp Symbol) /* TODO(undefined): boolean | 0 */ TODO {
         /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.JsxAttributes && isHyphenatedJsxName(sourceProp.escapedName) */ TODO
    }
    getNormalizedType := func(type_ Type, writing bool) Type {
        /* TODO(WhileStatement): while (true) {             const t = isFreshLiteralType(type) ? (type as FreshableType).regularType :                 isGenericTupleType(type) ? getNormalizedTupleType(type, writing) :                 getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).node ? createTypeReference((type as TypeReference).target, getTypeArguments(type as TypeReference)) : getSingleBaseForNonAugmentingSubtype(type) || type :                 type.flags & TypeFlags.UnionOrIntersection ? getNormalizedUnionOrIntersectionType(type as UnionOrIntersectionType, writing) :                 type.flags & TypeFlags.Substitution ? writing ? (type as SubstitutionType).baseType : getSubstitutionIntersection(type as SubstitutionType) :                 type.flags & TypeFlags.Simplifiable ? getSimplifiedType(type, writing) :                 type;             if (t === type) return t;             type = t;         } */
    }
    getNormalizedUnionOrIntersectionType := func(type_ UnionOrIntersectionType, writing bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        reduced := getReducedType(type_)
        if /* TODO(BinaryExpression): reduced !== type */ TODO {
             reduced
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection && shouldNormalizeIntersection(type as IntersectionType) */ TODO {
            normalizedTypes := sameMap(/* TODO(PropertyAccessExpression): type.types */ TODO, /* TODO(ArrowFunction): t => getNormalizedType(t, writing) */ TODO)
            if /* TODO(BinaryExpression): normalizedTypes !== type.types */ TODO {
                 getIntersectionType(normalizedTypes)
            }
        }
         type_
    }
    shouldNormalizeIntersection := func(type_ IntersectionType) /* TODO(undefined): boolean */ TODO {
        hasInstantiable := /* TODO(FalseKeyword): false */ TODO
        hasNullableOrEmpty := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForOfStatement): for (const t of type.types) {             hasInstantiable ||= !!(t.flags & TypeFlags.Instantiable);             hasNullableOrEmpty ||= !!(t.flags & TypeFlags.Nullable) || isEmptyAnonymousObjectType(t);             if (hasInstantiable && hasNullableOrEmpty) return true;         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    getNormalizedTupleType := func(type_ TupleTypeReference, writing bool) Type {
        elements := getElementTypes(type_)
        normalizedElements := sameMap(elements, /* TODO(ArrowFunction): t => t.flags & TypeFlags.Simplifiable ? getSimplifiedType(t, writing) : t */ TODO)
         /* TODO(ConditionalExpression): elements !== normalizedElements ? createNormalizedTupleType(type.target, normalizedElements) : type */ TODO
    }
    checkTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ TODO) bool {
        var errorInfo *DiagnosticMessageChain
        var relatedInfo /* TODO(TupleType): [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] */ any
        var maybeKeys []string
        var maybeKeysSet Set[string]
        var sourceStack []Type
        var targetStack []Type
        maybeCount := 0
        sourceDepth := 0
        targetDepth := 0
        expandingFlags := /* TODO(PropertyAccessExpression): ExpandingFlags.None */ TODO
        overflow := /* TODO(FalseKeyword): false */ TODO
        overrideNextErrorInfo := 0
        skipParentCounter := 0
        var lastSkippedInfo /* TODO(TupleType): [Type, Type] */ any
        var incompatibleStack /* TODO(ArrayType): DiagnosticAndArguments[] */ any
        relationCount := /* TODO(BinaryExpression): (16_000_000 - relation.size) >> 3 */ TODO
        /* TODO(ExpressionStatement): Debug.assert(relation !== identityRelation || !errorNode, "no error reporting in identity checking"); */
        result := isRelatedTo(source, target, /* TODO(PropertyAccessExpression): RecursionFlags.Both */ TODO, /* TODO(PrefixUnaryExpression): !!errorNode */ TODO, headMessage)
        if incompatibleStack {
            /* TODO(ExpressionStatement): reportIncompatibleStack(); */
        }
        if overflow {
            id := getRelationKey(source, target, /* TODO(PropertyAccessExpression): IntersectionState.None */ TODO, relation, /* TODO(FalseKeyword): false */ TODO)
            /* TODO(ExpressionStatement): relation.set(id, RelationComparisonResult.Failed | (relationCount <= 0 ? RelationComparisonResult.ComplexityOverflow : RelationComparisonResult.StackDepthOverflow)); */
            /* TODO(ExpressionStatement): tracing?.instant(tracing.Phase.CheckTypes, "checkTypeRelatedTo_DepthLimit", { sourceId: source.id, targetId: target.id, depth: sourceDepth, targetDepth }); */
            message := /* TODO(ConditionalExpression): relationCount <= 0 ?                 Diagnostics.Excessive_complexity_comparing_types_0_and_1 :                 Diagnostics.Excessive_stack_depth_comparing_types_0_and_1 */ TODO
            diag := error(/* TODO(BinaryExpression): errorNode || currentNode */ TODO, message, typeToString(source), typeToString(target))
            if errorOutputContainer {
                /* TODO(ExpressionStatement): (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag); */
            }
        } else if errorInfo {
            if containingMessageChain {
                chain := containingMessageChain()
                if chain {
                    /* TODO(ExpressionStatement): concatenateDiagnosticMessageChains(chain, errorInfo); */
                    /* TODO(ExpressionStatement): errorInfo = chain; */
                }
            }
            var relatedInformation /* TODO(ArrayType): DiagnosticRelatedInformation[] */ any
            if /* TODO(BinaryExpression): headMessage && errorNode && !result && source.symbol */ TODO {
                links := getSymbolLinks(/* TODO(PropertyAccessExpression): source.symbol */ TODO)
                if /* TODO(BinaryExpression): links.originatingImport && !isImportCall(links.originatingImport) */ TODO {
                    helpfulRetry := checkTypeRelatedTo(getTypeOfSymbol(/* TODO(NonNullExpression): links.target! */ TODO), target, relation, undefined)
                    if helpfulRetry {
                        diag := createDiagnosticForNode(/* TODO(PropertyAccessExpression): links.originatingImport */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead */ TODO)
                        /* TODO(ExpressionStatement): relatedInformation = append(relatedInformation, diag); */
                    }
                }
            }
            diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(/* TODO(NonNullExpression): errorNode! */ TODO), /* TODO(NonNullExpression): errorNode! */ TODO, errorInfo, relatedInformation)
            if relatedInfo {
                /* TODO(ExpressionStatement): addRelatedInfo(diag, ...relatedInfo); */
            }
            if errorOutputContainer {
                /* TODO(ExpressionStatement): (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag); */
            }
            if /* TODO(BinaryExpression): !errorOutputContainer || !errorOutputContainer.skipLogging */ TODO {
                /* TODO(ExpressionStatement): diagnostics.add(diag); */
            }
        }
        if /* TODO(BinaryExpression): errorNode && errorOutputContainer && errorOutputContainer.skipLogging && result === Ternary.False */ TODO {
            /* TODO(ExpressionStatement): Debug.assert(!!errorOutputContainer.errors, "missed opportunity to interact with error."); */
        }
         /* TODO(BinaryExpression): result !== Ternary.False */ TODO
        resetErrorInfo := func(saved ReturnType[/* TODO(TypeQuery): typeof captureErrorCalculationState */ TODO]) {
            /* TODO(ExpressionStatement): errorInfo = saved.errorInfo; */
            /* TODO(ExpressionStatement): lastSkippedInfo = saved.lastSkippedInfo; */
            /* TODO(ExpressionStatement): incompatibleStack = saved.incompatibleStack; */
            /* TODO(ExpressionStatement): overrideNextErrorInfo = saved.overrideNextErrorInfo; */
            /* TODO(ExpressionStatement): skipParentCounter = saved.skipParentCounter; */
            /* TODO(ExpressionStatement): relatedInfo = saved.relatedInfo; */
        }
        captureErrorCalculationState := func() /* TODO(undefined): { errorInfo: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined; lastSkippedInfo: [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, import("/home/jabaile/work/TypeScript/src/compiler/types").Type] | undefined; incompatibleStack: [message: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage, ...args: (string | number)[]][] | undefined; overrideNextErrorInfo: number; skipParentCounter: number; relatedInfo: [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined; } */ TODO {
             /* TODO(ObjectLiteralExpression): {                 errorInfo,                 lastSkippedInfo,                 incompatibleStack: incompatibleStack?.slice(),                 overrideNextErrorInfo,                 skipParentCounter,                 relatedInfo: relatedInfo?.slice() as [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined,             } */ TODO
        }
        reportIncompatibleError := func(message DiagnosticMessage, args DiagnosticArguments) {
            /* TODO(ExpressionStatement): overrideNextErrorInfo++; */
            /* TODO(ExpressionStatement): lastSkippedInfo = undefined; */
            /* TODO(ExpressionStatement): (incompatibleStack ||= []).push([message, ...args]); */
        }
        reportIncompatibleStack := func() /* TODO(undefined): undefined */ TODO {
            stack := /* TODO(BinaryExpression): incompatibleStack || [] */ TODO
            /* TODO(ExpressionStatement): incompatibleStack = undefined; */
            info := lastSkippedInfo
            /* TODO(ExpressionStatement): lastSkippedInfo = undefined; */
            if /* TODO(BinaryExpression): stack.length === 1 */ TODO {
                /* TODO(ExpressionStatement): reportError(...stack[0]); */
                if info {
                    /* TODO(ExpressionStatement): reportRelationError(/*message* / undefined, ...info); */
                }

            }
            path := ""
            var secondaryRootErrors []DiagnosticAndArguments = /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(WhileStatement): while (stack.length) {                 const [msg, ...args] = stack.pop()!;                 switch (msg.code) {                     case Diagnostics.Types_of_property_0_are_incompatible.code: {                         // Parenthesize a `new` if there is one                         if (path.indexOf("new ") === 0) {                             path = `(${path})`;                         }                         const str = "" + args[0];                         // If leading, just print back the arg (irrespective of if it's a valid identifier)                         if (path.length === 0) {                             path = `${str}`;                         }                         // Otherwise write a dotted name if possible                         else if (isIdentifierText(str, getEmitScriptTarget(compilerOptions))) {                             path = `${path}.${str}`;                         }                         // Failing that, check if the name is already a computed name                         else if (str[0] === "[" && str[str.length - 1] === "]") {                             path = `${path}${str}`;                         }                         // And finally write out a computed name as a last resort                         else {                             path = `${path}[${str}]`;                         }                         break;                     }                     case Diagnostics.Call_signature_return_types_0_and_1_are_incompatible.code:                     case Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code:                     case Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:                     case Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code: {                         if (path.length === 0) {                             // Don't flatten signature compatability errors at the start of a chain - instead prefer                             // to unify (the with no arguments bit is excessive for printback) and print them back                             let mappedMsg = msg;                             if (msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {                                 mappedMsg = Diagnostics.Call_signature_return_types_0_and_1_are_incompatible;                             }                             else if (msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {                                 mappedMsg = Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible;                             }                             secondaryRootErrors.unshift([mappedMsg, args[0], args[1]]);                         }                         else {                             const prefix = (msg.code === Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code ||                                     msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)                                 ? "new "                                 : "";                             const params = (msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code ||                                     msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)                                 ? ""                                 : "...";                             path = `${prefix}${path}(${params})`;                         }                         break;                     }                     case Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target.code: {                         secondaryRootErrors.unshift([Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, args[0], args[1]]);                         break;                     }                     case Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target.code: {                         secondaryRootErrors.unshift([Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, args[0], args[1], args[2]]);                         break;                     }                     default:                         return Debug.fail(`Unhandled Diagnostic: ${msg.code}`);                 }             } */
            if path {
                /* TODO(ExpressionStatement): reportError(                     path[path.length - 1] === ")"                         ? Diagnostics.The_types_returned_by_0_are_incompatible_between_these_types                         : Diagnostics.The_types_of_0_are_incompatible_between_these_types,                     path,                 ); */
            } else {
                /* TODO(ExpressionStatement): secondaryRootErrors.shift(); */
            }
            /* TODO(ForOfStatement): for (const [msg, ...args] of secondaryRootErrors) {                 const originalValue = msg.elidedInCompatabilityPyramid;                 msg.elidedInCompatabilityPyramid = false; // Temporarily override elision to ensure error is reported                 reportError(msg, ...args);                 msg.elidedInCompatabilityPyramid = originalValue;             } */
            if info {
                /* TODO(ExpressionStatement): reportRelationError(/*message* / undefined, ...info); */
            }
        }
        reportError := func(message DiagnosticMessage, args DiagnosticArguments) {
            /* TODO(ExpressionStatement): Debug.assert(!!errorNode); */
            if incompatibleStack {
                /* TODO(CallExpression): reportIncompatibleStack() */
            }
            if /* TODO(PropertyAccessExpression): message.elidedInCompatabilityPyramid */ TODO {
            }
            if /* TODO(BinaryExpression): skipParentCounter === 0 */ TODO {
                /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(errorInfo, message, ...args); */
            } else {
                /* TODO(ExpressionStatement): skipParentCounter--; */
            }
        }
        reportParentSkippedError := func(message DiagnosticMessage, args DiagnosticArguments) {
            /* TODO(ExpressionStatement): reportError(message, ...args); */
            /* TODO(ExpressionStatement): skipParentCounter++; */
        }
        associateRelatedInfo := func(info DiagnosticRelatedInformation) {
            /* TODO(ExpressionStatement): Debug.assert(!!errorInfo); */
            if /* TODO(PrefixUnaryExpression): !relatedInfo */ TODO {
                /* TODO(ExpressionStatement): relatedInfo = [info]; */
            } else {
                /* TODO(ExpressionStatement): relatedInfo.push(info); */
            }
        }
        reportRelationError := func(message *DiagnosticMessage, source Type, target Type) {
            if incompatibleStack {
                /* TODO(CallExpression): reportIncompatibleStack() */
            }
            TODO_IDENTIFIER := getTypeNamesForErrorDisplay(source, target)
            generalizedSource := source
            generalizedSourceType := sourceType
            if /* TODO(BinaryExpression): isLiteralType(source) && !typeCouldHaveTopLevelSingletonTypes(target) */ TODO {
                /* TODO(ExpressionStatement): generalizedSource = getBaseTypeOfLiteralType(source); */
                /* TODO(ExpressionStatement): Debug.assert(!isTypeAssignableTo(generalizedSource, target), "generalized source shouldn't be assignable"); */
                /* TODO(ExpressionStatement): generalizedSourceType = getTypeNameForErrorDisplay(generalizedSource); */
            }
            targetFlags := /* TODO(ConditionalExpression): target.flags & TypeFlags.IndexedAccess && !(source.flags & TypeFlags.IndexedAccess) ?                 (target as IndexedAccessType).objectType.flags :                 target.flags */ TODO
            if /* TODO(BinaryExpression): targetFlags & TypeFlags.TypeParameter && target !== markerSuperTypeForCheck && target !== markerSubTypeForCheck */ TODO {
                constraint := getBaseConstraintOfType(target)
                needsOriginalSource
                if /* TODO(BinaryExpression): constraint && (isTypeAssignableTo(generalizedSource, constraint) || (needsOriginalSource = isTypeAssignableTo(source, constraint))) */ TODO {
                    /* TODO(ExpressionStatement): reportError(                         Diagnostics._0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2,                         needsOriginalSource ? sourceType : generalizedSourceType,                         targetType,                         typeToString(constraint),                     ); */
                } else {
                    /* TODO(ExpressionStatement): errorInfo = undefined; */
                    /* TODO(ExpressionStatement): reportError(                         Diagnostics._0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1,                         targetType,                         generalizedSourceType,                     ); */
                }
            }
            if /* TODO(PrefixUnaryExpression): !message */ TODO {
                if /* TODO(BinaryExpression): relation === comparableRelation */ TODO {
                    /* TODO(ExpressionStatement): message = Diagnostics.Type_0_is_not_comparable_to_type_1; */
                } else if /* TODO(BinaryExpression): sourceType === targetType */ TODO {
                    /* TODO(ExpressionStatement): message = Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated; */
                } else if /* TODO(BinaryExpression): exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(source, target).length */ TODO {
                    /* TODO(ExpressionStatement): message = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties; */
                } else {
                    if /* TODO(BinaryExpression): source.flags & TypeFlags.StringLiteral && target.flags & TypeFlags.Union */ TODO {
                        suggestedType := getSuggestedTypeForNonexistentStringLiteralType(source /* as */ /* TODO(TypeReference): StringLiteralType */, target /* as */ /* TODO(TypeReference): UnionType */)
                        if suggestedType {
                            /* TODO(ExpressionStatement): reportError(Diagnostics.Type_0_is_not_assignable_to_type_1_Did_you_mean_2, generalizedSourceType, targetType, typeToString(suggestedType)); */

                        }
                    }
                    /* TODO(ExpressionStatement): message = Diagnostics.Type_0_is_not_assignable_to_type_1; */
                }
            } else if /* TODO(BinaryExpression): message === Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1                 && exactOptionalPropertyTypes                 && getExactOptionalUnassignableProperties(source, target).length */ TODO {
                /* TODO(ExpressionStatement): message = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties; */
            }
            /* TODO(ExpressionStatement): reportError(message, generalizedSourceType, targetType); */
        }
        tryElaborateErrorsForPrimitivesAndObjects := func(source Type, target Type) {
            sourceType := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(source.symbol) ? typeToString(source, source.symbol.valueDeclaration) : typeToString(source) */ TODO
            targetType := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(target.symbol) ? typeToString(target, target.symbol.valueDeclaration) : typeToString(target) */ TODO
            if /* TODO(BinaryExpression): (globalStringType === source && stringType === target) ||                 (globalNumberType === source && numberType === target) ||                 (globalBooleanType === source && booleanType === target) ||                 (getGlobalESSymbolType() === source && esSymbolType === target) */ TODO {
                /* TODO(ExpressionStatement): reportError(Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType); */
            }
        }
        tryElaborateArrayLikeErrors := func(source Type, target Type, reportErrors bool) bool {
            if isTupleType(source) {
                if /* TODO(BinaryExpression): source.target.readonly && isMutableArrayOrTuple(target) */ TODO {
                    if reportErrors {
                        /* TODO(ExpressionStatement): reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target)); */
                    }
                     /* TODO(FalseKeyword): false */ TODO
                }
                 isArrayOrTupleType(target)
            }
            if /* TODO(BinaryExpression): isReadonlyArrayType(source) && isMutableArrayOrTuple(target) */ TODO {
                if reportErrors {
                    /* TODO(ExpressionStatement): reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target)); */
                }
                 /* TODO(FalseKeyword): false */ TODO
            }
            if isTupleType(target) {
                 isArrayType(source)
            }
             /* TODO(TrueKeyword): true */ TODO
        }
        isRelatedToWorker := func(source Type, target Type, reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
             isRelatedTo(source, target, /* TODO(PropertyAccessExpression): RecursionFlags.Both */ TODO, reportErrors)
        }
        isRelatedTo := func(originalSource Type, originalTarget Type, recursionFlags RecursionFlags /* = */ /* TODO(PropertyAccessExpression): RecursionFlags.Both */, reportErrors /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, headMessage DiagnosticMessage, intersectionState /* TODO(undefined): IntersectionState */ TODO /* = */ /* TODO(PropertyAccessExpression): IntersectionState.None */) Ternary {
            if /* TODO(BinaryExpression): originalSource === originalTarget */ TODO {
                /* TODO(PropertyAccessExpression): Ternary.True */
            }
            if /* TODO(BinaryExpression): originalSource.flags & TypeFlags.Object && originalTarget.flags & TypeFlags.Primitive */ TODO {
                if /* TODO(BinaryExpression): relation === comparableRelation && !(originalTarget.flags & TypeFlags.Never) && isSimpleTypeRelatedTo(originalTarget, originalSource, relation) ||                     isSimpleTypeRelatedTo(originalSource, originalTarget, relation, reportErrors ? reportError : undefined) */ TODO {
                     /* TODO(PropertyAccessExpression): Ternary.True */ TODO
                }
                if reportErrors {
                    /* TODO(ExpressionStatement): reportErrorResults(originalSource, originalTarget, originalSource, originalTarget, headMessage); */
                }
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
            source := getNormalizedType(originalSource, /* TODO(FalseKeyword): false */ TODO)
            target := getNormalizedType(originalTarget, /* TODO(TrueKeyword): true */ TODO)
            if /* TODO(BinaryExpression): source === target */ TODO {
                /* TODO(PropertyAccessExpression): Ternary.True */
            }
            if /* TODO(BinaryExpression): relation === identityRelation */ TODO {
                if /* TODO(BinaryExpression): source.flags !== target.flags */ TODO {
                    /* TODO(PropertyAccessExpression): Ternary.False */
                }
                if /* TODO(BinaryExpression): source.flags & TypeFlags.Singleton */ TODO {
                    /* TODO(PropertyAccessExpression): Ternary.True */
                }
                /* TODO(ExpressionStatement): traceUnionsOrIntersectionsTooLarge(source, target); */
                 recursiveTypeRelatedTo(source, target, /* TODO(FalseKeyword): false */ TODO, /* TODO(PropertyAccessExpression): IntersectionState.None */ TODO, recursionFlags)
            }
            if /* TODO(BinaryExpression): source.flags & TypeFlags.TypeParameter && getConstraintOfType(source) === target */ TODO {
                 /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            }
            if /* TODO(BinaryExpression): source.flags & TypeFlags.DefinitelyNonNullable && target.flags & TypeFlags.Union */ TODO {
                types := /* TODO(PropertyAccessExpression): (target as UnionType).types */ TODO
                candidate := /* TODO(ConditionalExpression): types.length === 2 && types[0].flags & TypeFlags.Nullable ? types[1] :                     types.length === 3 && types[0].flags & TypeFlags.Nullable && types[1].flags & TypeFlags.Nullable ? types[2] :                     undefined */ TODO
                if /* TODO(BinaryExpression): candidate && !(candidate.flags & TypeFlags.Nullable) */ TODO {
                    /* TODO(ExpressionStatement): target = getNormalizedType(candidate, /*writing* / true); */
                    if /* TODO(BinaryExpression): source === target */ TODO {
                        /* TODO(PropertyAccessExpression): Ternary.True */
                    }
                }
            }
            if /* TODO(BinaryExpression): relation === comparableRelation && !(target.flags & TypeFlags.Never) && isSimpleTypeRelatedTo(target, source, relation) ||                 isSimpleTypeRelatedTo(source, target, relation, reportErrors ? reportError : undefined) */ TODO {
                /* TODO(PropertyAccessExpression): Ternary.True */
            }
            if /* TODO(BinaryExpression): source.flags & TypeFlags.StructuredOrInstantiable || target.flags & TypeFlags.StructuredOrInstantiable */ TODO {
                isPerformingExcessPropertyChecks := /* TODO(BinaryExpression): !(intersectionState & IntersectionState.Target) && (isObjectLiteralType(source) && getObjectFlags(source) & ObjectFlags.FreshLiteral) */ TODO
                if isPerformingExcessPropertyChecks {
                    if hasExcessProperties(source /* as */ /* TODO(TypeReference): FreshObjectLiteralType */, target, reportErrors) {
                        if reportErrors {
                            /* TODO(ExpressionStatement): reportRelationError(headMessage, source, originalTarget.aliasSymbol ? originalTarget : target); */
                        }
                         /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                    }
                }
                isPerformingCommonPropertyChecks := /* TODO(BinaryExpression): (relation !== comparableRelation || isUnitType(source)) &&                     !(intersectionState & IntersectionState.Target) &&                     source.flags & (TypeFlags.Primitive | TypeFlags.Object | TypeFlags.Intersection) && source !== globalObjectType &&                     target.flags & (TypeFlags.Object | TypeFlags.Intersection) && isWeakType(target) &&                     (getPropertiesOfType(source).length > 0 || typeHasCallOrConstructSignatures(source)) */ TODO
                isComparingJsxAttributes := /* TODO(PrefixUnaryExpression): !!(getObjectFlags(source) & ObjectFlags.JsxAttributes) */ TODO
                if /* TODO(BinaryExpression): isPerformingCommonPropertyChecks && !hasCommonProperties(source, target, isComparingJsxAttributes) */ TODO {
                    if reportErrors {
                        sourceString := typeToString(/* TODO(ConditionalExpression): originalSource.aliasSymbol ? originalSource : source */ TODO)
                        targetString := typeToString(/* TODO(ConditionalExpression): originalTarget.aliasSymbol ? originalTarget : target */ TODO)
                        calls := getSignaturesOfType(source, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
                        constructs := getSignaturesOfType(source, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO)
                        if /* TODO(BinaryExpression): calls.length > 0 && isRelatedTo(getReturnTypeOfSignature(calls[0]), target, RecursionFlags.Source, /*reportErrors* / false) ||                             constructs.length > 0 && isRelatedTo(getReturnTypeOfSignature(constructs[0]), target, RecursionFlags.Source, /*reportErrors* / false) */ TODO {
                            /* TODO(ExpressionStatement): reportError(Diagnostics.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it, sourceString, targetString); */
                        } else {
                            /* TODO(ExpressionStatement): reportError(Diagnostics.Type_0_has_no_properties_in_common_with_type_1, sourceString, targetString); */
                        }
                    }
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
                /* TODO(ExpressionStatement): traceUnionsOrIntersectionsTooLarge(source, target); */
                skipCaching := /* TODO(BinaryExpression): source.flags & TypeFlags.Union && (source as UnionType).types.length < 4 && !(target.flags & TypeFlags.Union) ||                     target.flags & TypeFlags.Union && (target as UnionType).types.length < 4 && !(source.flags & TypeFlags.StructuredOrInstantiable) */ TODO
                result := /* TODO(ConditionalExpression): skipCaching ?                     unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) :                     recursiveTypeRelatedTo(source, target, reportErrors, intersectionState, recursionFlags) */ TODO
                if result {
                     result
                }
            }
            if reportErrors {
                /* TODO(ExpressionStatement): reportErrorResults(originalSource, originalTarget, source, target, headMessage); */
            }
             /* TODO(PropertyAccessExpression): Ternary.False */ TODO
        }
        reportErrorResults := func(originalSource Type, originalTarget Type, source Type, target Type, headMessage *DiagnosticMessage) {
            sourceHasBase := /* TODO(PrefixUnaryExpression): !!getSingleBaseForNonAugmentingSubtype(originalSource) */ TODO
            targetHasBase := /* TODO(PrefixUnaryExpression): !!getSingleBaseForNonAugmentingSubtype(originalTarget) */ TODO
            /* TODO(ExpressionStatement): source = (originalSource.aliasSymbol || sourceHasBase) ? originalSource : source; */
            /* TODO(ExpressionStatement): target = (originalTarget.aliasSymbol || targetHasBase) ? originalTarget : target; */
            maybeSuppress := /* TODO(BinaryExpression): overrideNextErrorInfo > 0 */ TODO
            if maybeSuppress {
                /* TODO(ExpressionStatement): overrideNextErrorInfo--; */
            }
            if /* TODO(BinaryExpression): source.flags & TypeFlags.Object && target.flags & TypeFlags.Object */ TODO {
                currentError := errorInfo
                /* TODO(ExpressionStatement): tryElaborateArrayLikeErrors(source, target, /*reportErrors* / true); */
                if /* TODO(BinaryExpression): errorInfo !== currentError */ TODO {
                    /* TODO(ExpressionStatement): maybeSuppress = !!errorInfo; */
                }
            }
            if /* TODO(BinaryExpression): source.flags & TypeFlags.Object && target.flags & TypeFlags.Primitive */ TODO {
                /* TODO(ExpressionStatement): tryElaborateErrorsForPrimitivesAndObjects(source, target); */
            } else if /* TODO(BinaryExpression): source.symbol && source.flags & TypeFlags.Object && globalObjectType === source */ TODO {
                /* TODO(ExpressionStatement): reportError(Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead); */
            } else if /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.JsxAttributes && target.flags & TypeFlags.Intersection */ TODO {
                targetTypes := /* TODO(PropertyAccessExpression): (target as IntersectionType).types */ TODO
                intrinsicAttributes := getJsxType(/* TODO(PropertyAccessExpression): JsxNames.IntrinsicAttributes */ TODO, errorNode)
                intrinsicClassAttributes := getJsxType(/* TODO(PropertyAccessExpression): JsxNames.IntrinsicClassAttributes */ TODO, errorNode)
                if /* TODO(BinaryExpression): !isErrorType(intrinsicAttributes) && !isErrorType(intrinsicClassAttributes) &&                     (contains(targetTypes, intrinsicAttributes) || contains(targetTypes, intrinsicClassAttributes)) */ TODO {

                }
            } else {
                /* TODO(ExpressionStatement): errorInfo = elaborateNeverIntersection(errorInfo, originalTarget); */
            }
            if /* TODO(BinaryExpression): !headMessage && maybeSuppress */ TODO {
                savedErrorState := captureErrorCalculationState()
                /* TODO(ExpressionStatement): reportRelationError(headMessage, source, target); */
                canonical
                if /* TODO(BinaryExpression): errorInfo && errorInfo !== savedErrorState.errorInfo */ TODO {
                    /* TODO(ExpressionStatement): canonical = { code: errorInfo.code, messageText: errorInfo.messageText }; */
                }
                /* TODO(ExpressionStatement): resetErrorInfo(savedErrorState); */
                if /* TODO(BinaryExpression): canonical && errorInfo */ TODO {
                    /* TODO(ExpressionStatement): errorInfo.canonicalHead = canonical; */
                }
                /* TODO(ExpressionStatement): lastSkippedInfo = [source, target]; */

            }
            /* TODO(ExpressionStatement): reportRelationError(headMessage, source, target); */
            if /* TODO(BinaryExpression): source.flags & TypeFlags.TypeParameter && source.symbol?.declarations?.[0] && !getConstraintOfType(source as TypeVariable) */ TODO {
                syntheticParam := cloneTypeParameter(source /* as */ /* TODO(TypeReference): TypeParameter */)
                /* TODO(ExpressionStatement): syntheticParam.constraint = instantiateType(target, makeUnaryTypeMapper(source, syntheticParam)); */
                if hasNonCircularBaseConstraint(syntheticParam) {
                    targetConstraintString := typeToString(target, /* TODO(ElementAccessExpression): source.symbol.declarations[0] */ TODO)
                    /* TODO(ExpressionStatement): associateRelatedInfo(createDiagnosticForNode(source.symbol.declarations[0], Diagnostics.This_type_parameter_might_need_an_extends_0_constraint, targetConstraintString)); */
                }
            }
        }
        traceUnionsOrIntersectionsTooLarge := func(source Type, target Type) {
            if /* TODO(PrefixUnaryExpression): !tracing */ TODO {

            }
            if /* TODO(BinaryExpression): (source.flags & TypeFlags.UnionOrIntersection) && (target.flags & TypeFlags.UnionOrIntersection) */ TODO {
                sourceUnionOrIntersection := source /* as */ /* TODO(TypeReference): UnionOrIntersectionType */
                targetUnionOrIntersection := target /* as */ /* TODO(TypeReference): UnionOrIntersectionType */
                if /* TODO(BinaryExpression): sourceUnionOrIntersection.objectFlags & targetUnionOrIntersection.objectFlags & ObjectFlags.PrimitiveUnion */ TODO {

                }
                sourceSize := /* TODO(PropertyAccessExpression): sourceUnionOrIntersection.types.length */ TODO
                targetSize := /* TODO(PropertyAccessExpression): targetUnionOrIntersection.types.length */ TODO
                if /* TODO(BinaryExpression): sourceSize * targetSize > 1E6 */ TODO {
                    /* TODO(ExpressionStatement): tracing.instant(tracing.Phase.CheckTypes, "traceUnionsOrIntersectionsTooLarge_DepthLimit", {                         sourceId: source.id,                         sourceSize,                         targetId: target.id,                         targetSize,                         pos: errorNode?.pos,                         end: errorNode?.end,                     }); */
                }
            }
        }
        getTypeOfPropertyInTypes := func(types []Type, name __String) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
            appendPropType := /* TODO(ArrowFunction): (propTypes: Type[] | undefined, type: Type) => {                 type = getApparentType(type);                 const prop = type.flags & TypeFlags.UnionOrIntersection ? getPropertyOfUnionOrIntersectionType(type as UnionOrIntersectionType, name) : getPropertyOfObjectType(type, name);                 const propType = prop && getTypeOfSymbol(prop) || getApplicableIndexInfoForName(type, name)?.type || undefinedType;                 return append(propTypes, propType);             } */ TODO
             getUnionType(/* TODO(BinaryExpression): reduceLeft(types, appendPropType, /*initial* / undefined) || emptyArray */ TODO)
        }
        hasExcessProperties := func(source FreshObjectLiteralType, target Type, reportErrors bool) bool {
            if /* TODO(BinaryExpression): !isExcessPropertyCheckTarget(target) || !noImplicitAny && getObjectFlags(target) & ObjectFlags.JSLiteral */ TODO {
                 /* TODO(FalseKeyword): false */ TODO
            }
            isComparingJsxAttributes := /* TODO(PrefixUnaryExpression): !!(getObjectFlags(source) & ObjectFlags.JsxAttributes) */ TODO
            if /* TODO(BinaryExpression): (relation === assignableRelation || relation === comparableRelation) &&                 (isTypeSubsetOf(globalObjectType, target) || (!isComparingJsxAttributes && isEmptyObjectType(target))) */ TODO {
                 /* TODO(FalseKeyword): false */ TODO
            }
            reducedTarget := target
            var checkTypes /* TODO(ArrayType): Type[] */ any
            if /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
                /* TODO(ExpressionStatement): reducedTarget = findMatchingDiscriminantType(source, target as UnionType, isRelatedTo) || filterPrimitivesIfContainsNonPrimitive(target as UnionType); */
                /* TODO(ExpressionStatement): checkTypes = reducedTarget.flags & TypeFlags.Union ? (reducedTarget as UnionType).types : [reducedTarget]; */
            }
            /* TODO(ForOfStatement): for (const prop of getPropertiesOfType(source)) {                 if (shouldCheckAsExcessProperty(prop, source.symbol) && !isIgnoredJsxProperty(source, prop)) {                     if (!isKnownProperty(reducedTarget, prop.escapedName, isComparingJsxAttributes)) {                         if (reportErrors) {                             // Report error in terms of object types in the target as those are the only ones                             // we check in isKnownProperty.                             const errorTarget = filterType(reducedTarget, isExcessPropertyCheckTarget);                             // We know *exactly* where things went wrong when comparing the types.                             // Use this property as the error node as this will be more helpful in                             // reasoning about what went wrong.                             if (!errorNode) return Debug.fail();                             if (isJsxAttributes(errorNode) || isJsxOpeningLikeElement(errorNode) || isJsxOpeningLikeElement(errorNode.parent)) {                                 // JsxAttributes has an object-literal flag and undergo same type-assignablity check as normal object-literal.                                 // However, using an object-literal error message will be very confusing to the users so we give different a message.                                 if (prop.valueDeclaration && isJsxAttribute(prop.valueDeclaration) && getSourceFileOfNode(errorNode) === getSourceFileOfNode(prop.valueDeclaration.name)) {                                     // Note that extraneous children (as in `<NoChild>extra</NoChild>`) don't pass this check,                                     // since `children` is a SyntaxKind.PropertySignature instead of a SyntaxKind.JsxAttribute.                                     errorNode = prop.valueDeclaration.name;                                 }                                 const propName = symbolToString(prop);                                 const suggestionSymbol = getSuggestedSymbolForNonexistentJSXAttribute(propName, errorTarget);                                 const suggestion = suggestionSymbol ? symbolToString(suggestionSymbol) : undefined;                                 if (suggestion) {                                     reportError(Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(errorTarget), suggestion);                                 }                                 else {                                     reportError(Diagnostics.Property_0_does_not_exist_on_type_1, propName, typeToString(errorTarget));                                 }                             }                             else {                                 // use the property's value declaration if the property is assigned inside the literal itself                                 const objectLiteralDeclaration = source.symbol?.declarations && firstOrUndefined(source.symbol.declarations);                                 let suggestion: string | undefined;                                 if (prop.valueDeclaration && findAncestor(prop.valueDeclaration, d => d === objectLiteralDeclaration) && getSourceFileOfNode(objectLiteralDeclaration) === getSourceFileOfNode(errorNode)) {                                     const propDeclaration = prop.valueDeclaration as ObjectLiteralElementLike;                                     Debug.assertNode(propDeclaration, isObjectLiteralElementLike);                                      const name = propDeclaration.name!;                                     errorNode = name;                                      if (isIdentifier(name)) {                                         suggestion = getSuggestionForNonexistentProperty(name, errorTarget);                                     }                                 }                                 if (suggestion !== undefined) {                                     reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2, symbolToString(prop), typeToString(errorTarget), suggestion);                                 }                                 else {                                     reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(prop), typeToString(errorTarget));                                 }                             }                         }                         return true;                     }                     if (checkTypes && !isRelatedTo(getTypeOfSymbol(prop), getTypeOfPropertyInTypes(checkTypes, prop.escapedName), RecursionFlags.Both, reportErrors)) {                         if (reportErrors) {                             reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(prop));                         }                         return true;                     }                 }             } */
             /* TODO(FalseKeyword): false */ TODO
        }
        shouldCheckAsExcessProperty := func(prop Symbol, container Symbol) /* TODO(undefined): boolean | undefined */ TODO {
             /* TODO(BinaryExpression): prop.valueDeclaration && container.valueDeclaration && prop.valueDeclaration.parent === container.valueDeclaration */ TODO
        }
        unionOrIntersectionRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
            if /* TODO(BinaryExpression): source.flags & TypeFlags.Union */ TODO {
                if /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
                    sourceOrigin := /* TODO(PropertyAccessExpression): (source as UnionType).origin */ TODO
                    if /* TODO(BinaryExpression): sourceOrigin && sourceOrigin.flags & TypeFlags.Intersection && target.aliasSymbol && contains((sourceOrigin as IntersectionType).types, target) */ TODO {
                         /* TODO(PropertyAccessExpression): Ternary.True */ TODO
                    }
                    targetOrigin := /* TODO(PropertyAccessExpression): (target as UnionType).origin */ TODO
                    if /* TODO(BinaryExpression): targetOrigin && targetOrigin.flags & TypeFlags.Union && source.aliasSymbol && contains((targetOrigin as UnionType).types, source) */ TODO {
                         /* TODO(PropertyAccessExpression): Ternary.True */ TODO
                    }
                }
                 /* TODO(ConditionalExpression): relation === comparableRelation ?                     someTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState) :                     eachTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState) */ TODO
            }
            if /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
                 typeRelatedToSomeType(getRegularTypeOfObjectLiteral(source), target /* as */ /* TODO(TypeReference): UnionType */, /* TODO(BinaryExpression): reportErrors && !(source.flags & TypeFlags.Primitive) && !(target.flags & TypeFlags.Primitive) */ TODO, intersectionState)
            }
            if /* TODO(BinaryExpression): target.flags & TypeFlags.Intersection */ TODO {
                 typeRelatedToEachType(source, target /* as */ /* TODO(TypeReference): IntersectionType */, reportErrors, /* TODO(PropertyAccessExpression): IntersectionState.Target */ TODO)
            }
            if /* TODO(BinaryExpression): relation === comparableRelation && target.flags & TypeFlags.Primitive */ TODO {
                constraints := sameMap(/* TODO(PropertyAccessExpression): (source as IntersectionType).types */ TODO, /* TODO(ArrowFunction): t => t.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(t) || unknownType : t */ TODO)
                if /* TODO(BinaryExpression): constraints !== (source as IntersectionType).types */ TODO {
                    /* TODO(ExpressionStatement): source = getIntersectionType(constraints); */
                    if /* TODO(BinaryExpression): source.flags & TypeFlags.Never */ TODO {
                         /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                    }
                    if /* TODO(PrefixUnaryExpression): !(source.flags & TypeFlags.Intersection) */ TODO {
                         /* TODO(BinaryExpression): isRelatedTo(source, target, RecursionFlags.Source, /*reportErrors* / false) ||                             isRelatedTo(target, source, RecursionFlags.Source, /*reportErrors* / false) */ TODO
                    }
                }
            }
             someTypeRelatedToType(source /* as */ /* TODO(TypeReference): IntersectionType */, target, /* TODO(FalseKeyword): false */ TODO, /* TODO(PropertyAccessExpression): IntersectionState.Source */ TODO)
        }
        eachTypeRelatedToSomeType := func(source UnionOrIntersectionType, target UnionOrIntersectionType) Ternary {
            result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            sourceTypes := /* TODO(PropertyAccessExpression): source.types */ TODO
            /* TODO(ForOfStatement): for (const sourceType of sourceTypes) {                 const related = typeRelatedToSomeType(sourceType, target, /*reportErrors* / false, IntersectionState.None);                 if (!related) {                     return Ternary.False;                 }                 result &= related;             } */
             result
        }
        typeRelatedToSomeType := func(source Type, target UnionOrIntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
            targetTypes := /* TODO(PropertyAccessExpression): target.types */ TODO
            if /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
                if containsType(targetTypes, source) {
                     /* TODO(PropertyAccessExpression): Ternary.True */ TODO
                }
                if /* TODO(BinaryExpression): relation !== comparableRelation && getObjectFlags(target) & ObjectFlags.PrimitiveUnion && !(source.flags & TypeFlags.EnumLiteral) && (                         source.flags & (TypeFlags.StringLiteral | TypeFlags.BooleanLiteral | TypeFlags.BigIntLiteral) ||                         (relation === subtypeRelation || relation === strictSubtypeRelation) && source.flags & TypeFlags.NumberLiteral                     ) */ TODO {
                    alternateForm := /* TODO(ConditionalExpression): source === (source as StringLiteralType).regularType ? (source as StringLiteralType).freshType : (source as StringLiteralType).regularType */ TODO
                    primitive := /* TODO(ConditionalExpression): source.flags & TypeFlags.StringLiteral ? stringType :                         source.flags & TypeFlags.NumberLiteral ? numberType :                         source.flags & TypeFlags.BigIntLiteral ? bigintType :                         undefined */ TODO
                     /* TODO(ConditionalExpression): primitive && containsType(targetTypes, primitive) || alternateForm && containsType(targetTypes, alternateForm) ? Ternary.True : Ternary.False */ TODO
                }
                match := getMatchingUnionConstituentForType(target /* as */ /* TODO(TypeReference): UnionType */, source)
                if match {
                    related := isRelatedTo(source, match, /* TODO(PropertyAccessExpression): RecursionFlags.Target */ TODO, /* TODO(FalseKeyword): false */ TODO, undefined, intersectionState)
                    if related {
                         related
                    }
                }
            }
            /* TODO(ForOfStatement): for (const type of targetTypes) {                 const related = isRelatedTo(source, type, RecursionFlags.Target, /*reportErrors* / false, /*headMessage* / undefined, intersectionState);                 if (related) {                     return related;                 }             } */
            if reportErrors {
                bestMatchingType := getBestMatchingType(source, target, isRelatedTo)
                if bestMatchingType {
                    /* TODO(ExpressionStatement): isRelatedTo(source, bestMatchingType, RecursionFlags.Target, /*reportErrors* / true, /*headMessage* / undefined, intersectionState); */
                }
            }
             /* TODO(PropertyAccessExpression): Ternary.False */ TODO
        }
        typeRelatedToEachType := func(source Type, target IntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
            result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            targetTypes := /* TODO(PropertyAccessExpression): target.types */ TODO
            /* TODO(ForOfStatement): for (const targetType of targetTypes) {                 const related = isRelatedTo(source, targetType, RecursionFlags.Target, reportErrors, /*headMessage* / undefined, intersectionState);                 if (!related) {                     return Ternary.False;                 }                 result &= related;             } */
             result
        }
        someTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
            sourceTypes := /* TODO(PropertyAccessExpression): source.types */ TODO
            if /* TODO(BinaryExpression): source.flags & TypeFlags.Union && containsType(sourceTypes, target) */ TODO {
                 /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            }
            len := /* TODO(PropertyAccessExpression): sourceTypes.length */ TODO
            /* TODO(ForStatement): for (let i = 0; i < len; i++) {                 const related = isRelatedTo(sourceTypes[i], target, RecursionFlags.Source, reportErrors && i === len - 1, /*headMessage* / undefined, intersectionState);                 if (related) {                     return related;                 }             } */
             /* TODO(PropertyAccessExpression): Ternary.False */ TODO
        }
        getUndefinedStrippedTargetIfNeeded := func(source Type, target Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
            if /* TODO(BinaryExpression): source.flags & TypeFlags.Union && target.flags & TypeFlags.Union &&                 !((source as UnionType).types[0].flags & TypeFlags.Undefined) && (target as UnionType).types[0].flags & TypeFlags.Undefined */ TODO {
                 extractTypesOfKind(target, /* TODO(PrefixUnaryExpression): ~TypeFlags.Undefined */ TODO)
            }
             target
        }
        eachTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
            result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            sourceTypes := /* TODO(PropertyAccessExpression): source.types */ TODO
            undefinedStrippedTarget := getUndefinedStrippedTargetIfNeeded(source, target /* as */ /* TODO(TypeReference): UnionType */)
            /* TODO(ForStatement): for (let i = 0; i < sourceTypes.length; i++) {                 const sourceType = sourceTypes[i];                 if (undefinedStrippedTarget.flags & TypeFlags.Union && sourceTypes.length >= (undefinedStrippedTarget as UnionType).types.length && sourceTypes.length % (undefinedStrippedTarget as UnionType).types.length === 0) {                     // many unions are mappings of one another; in such cases, simply comparing members at the same index can shortcut the comparison                     // such unions will have identical lengths, and their corresponding elements will match up. Another common scenario is where a large                     // union has a union of objects intersected with it. In such cases, if the input was, eg `("a" | "b" | "c") & (string | boolean | {} | {whatever})`,                     // the result will have the structure `"a" | "b" | "c" | "a" & {} | "b" & {} | "c" & {} | "a" & {whatever} | "b" & {whatever} | "c" & {whatever}`                     // - the resulting union has a length which is a multiple of the original union, and the elements correspond modulo the length of the original union                     const related = isRelatedTo(sourceType, (undefinedStrippedTarget as UnionType).types[i % (undefinedStrippedTarget as UnionType).types.length], RecursionFlags.Both, /*reportErrors* / false, /*headMessage* / undefined, intersectionState);                     if (related) {                         result &= related;                         continue;                     }                 }                 const related = isRelatedTo(sourceType, target, RecursionFlags.Source, reportErrors, /*headMessage* / undefined, intersectionState);                 if (!related) {                     return Ternary.False;                 }                 result &= related;             } */
             result
        }
        typeArgumentsRelatedTo := func(sources []Type /* = */ /* TODO(Identifier): emptyArray */, targets []Type /* = */ /* TODO(Identifier): emptyArray */, variances []VarianceFlags /* = */ /* TODO(Identifier): emptyArray */, reportErrors bool, intersectionState IntersectionState) Ternary {
            if /* TODO(BinaryExpression): sources.length !== targets.length && relation === identityRelation */ TODO {
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
            length := /* TODO(ConditionalExpression): sources.length <= targets.length ? sources.length : targets.length */ TODO
            result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            /* TODO(ForStatement): for (let i = 0; i < length; i++) {                 // When variance information isn't available we default to covariance. This happens                 // in the process of computing variance information for recursive types and when                 // comparing 'this' type arguments.                 const varianceFlags = i < variances.length ? variances[i] : VarianceFlags.Covariant;                 const variance = varianceFlags & VarianceFlags.VarianceMask;                 // We ignore arguments for independent type parameters (because they're never witnessed).                 if (variance !== VarianceFlags.Independent) {                     const s = sources[i];                     const t = targets[i];                     let related = Ternary.True;                     if (varianceFlags & VarianceFlags.Unmeasurable) {                         // Even an `Unmeasurable` variance works out without a structural check if the source and target are _identical_.                         // We can't simply assume invariance, because `Unmeasurable` marks nonlinear relations, for example, a relation tained by                         // the `-?` modifier in a mapped type (where, no matter how the inputs are related, the outputs still might not be)                         related = relation === identityRelation ? isRelatedTo(s, t, RecursionFlags.Both, /*reportErrors* / false) : compareTypesIdentical(s, t);                     }                     else if (variance === VarianceFlags.Covariant) {                         related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                     }                     else if (variance === VarianceFlags.Contravariant) {                         related = isRelatedTo(t, s, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                     }                     else if (variance === VarianceFlags.Bivariant) {                         // In the bivariant case we first compare contravariantly without reporting                         // errors. Then, if that doesn't succeed, we compare covariantly with error                         // reporting. Thus, error elaboration will be based on the the covariant check,                         // which is generally easier to reason about.                         related = isRelatedTo(t, s, RecursionFlags.Both, /*reportErrors* / false);                         if (!related) {                             related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         }                     }                     else {                         // In the invariant case we first compare covariantly, and only when that                         // succeeds do we proceed to compare contravariantly. Thus, error elaboration                         // will typically be based on the covariant check.                         related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         if (related) {                             related &= isRelatedTo(t, s, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         }                     }                     if (!related) {                         return Ternary.False;                     }                     result &= related;                 }             } */
             result
        }
        recursiveTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, recursionFlags RecursionFlags) Ternary {
            if overflow {
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
            id := getRelationKey(source, target, intersectionState, relation, /* TODO(FalseKeyword): false */ TODO)
            entry := /* TODO(PropertyAccessExpression): relation.get */ TODO(id)
            if /* TODO(BinaryExpression): entry !== undefined */ TODO {
                if /* TODO(BinaryExpression): reportErrors && entry & RelationComparisonResult.Failed && !(entry & RelationComparisonResult.Overflow) */ TODO {
                } else {
                    if outofbandVarianceMarkerHandler {
                        saved := /* TODO(BinaryExpression): entry & RelationComparisonResult.ReportsMask */ TODO
                        if /* TODO(BinaryExpression): saved & RelationComparisonResult.ReportsUnmeasurable */ TODO {
                            /* TODO(ExpressionStatement): instantiateType(source, reportUnmeasurableMapper); */
                        }
                        if /* TODO(BinaryExpression): saved & RelationComparisonResult.ReportsUnreliable */ TODO {
                            /* TODO(ExpressionStatement): instantiateType(source, reportUnreliableMapper); */
                        }
                    }
                    if /* TODO(BinaryExpression): reportErrors && entry & RelationComparisonResult.Overflow */ TODO {
                        message := /* TODO(ConditionalExpression): entry & RelationComparisonResult.ComplexityOverflow ?                             Diagnostics.Excessive_complexity_comparing_types_0_and_1 :                             Diagnostics.Excessive_stack_depth_comparing_types_0_and_1 */ TODO
                        /* TODO(ExpressionStatement): reportError(message, typeToString(source), typeToString(target)); */
                        /* TODO(ExpressionStatement): overrideNextErrorInfo++; */
                    }
                     /* TODO(ConditionalExpression): entry & RelationComparisonResult.Succeeded ? Ternary.True : Ternary.False */ TODO
                }
            }
            if /* TODO(BinaryExpression): relationCount <= 0 */ TODO {
                /* TODO(ExpressionStatement): overflow = true; */
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
            if /* TODO(PrefixUnaryExpression): !maybeKeys */ TODO {
                /* TODO(ExpressionStatement): maybeKeys = []; */
                /* TODO(ExpressionStatement): maybeKeysSet = new Set(); */
                /* TODO(ExpressionStatement): sourceStack = []; */
                /* TODO(ExpressionStatement): targetStack = []; */
            } else {
                if /* TODO(PropertyAccessExpression): maybeKeysSet.has */ TODO(id) {
                     /* TODO(PropertyAccessExpression): Ternary.Maybe */ TODO
                }
                broadestEquivalentId := /* TODO(ConditionalExpression): id.startsWith("*") ? getRelationKey(source, target, intersectionState, relation, /*ignoreConstraints* / true) : undefined */ TODO
                if /* TODO(BinaryExpression): broadestEquivalentId && maybeKeysSet.has(broadestEquivalentId) */ TODO {
                     /* TODO(PropertyAccessExpression): Ternary.Maybe */ TODO
                }
                if /* TODO(BinaryExpression): sourceDepth === 100 || targetDepth === 100 */ TODO {
                    /* TODO(ExpressionStatement): overflow = true; */
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
            }
            maybeStart := maybeCount
            /* TODO(ExpressionStatement): maybeKeys[maybeCount] = id; */
            /* TODO(ExpressionStatement): maybeKeysSet.add(id); */
            /* TODO(ExpressionStatement): maybeCount++; */
            saveExpandingFlags := expandingFlags
            if /* TODO(BinaryExpression): recursionFlags & RecursionFlags.Source */ TODO {
                /* TODO(ExpressionStatement): sourceStack[sourceDepth] = source; */
                /* TODO(ExpressionStatement): sourceDepth++; */
                if /* TODO(BinaryExpression): !(expandingFlags & ExpandingFlags.Source) && isDeeplyNestedType(source, sourceStack, sourceDepth) */ TODO {
                    /* TODO(BinaryExpression): expandingFlags |= ExpandingFlags.Source */
                }
            }
            if /* TODO(BinaryExpression): recursionFlags & RecursionFlags.Target */ TODO {
                /* TODO(ExpressionStatement): targetStack[targetDepth] = target; */
                /* TODO(ExpressionStatement): targetDepth++; */
                if /* TODO(BinaryExpression): !(expandingFlags & ExpandingFlags.Target) && isDeeplyNestedType(target, targetStack, targetDepth) */ TODO {
                    /* TODO(BinaryExpression): expandingFlags |= ExpandingFlags.Target */
                }
            }
            var originalHandler /* TODO(TypeQuery): typeof outofbandVarianceMarkerHandler */ TODO
            propagatingVarianceFlags := 0 /* as */ /* TODO(TypeReference): RelationComparisonResult */
            if outofbandVarianceMarkerHandler {
                /* TODO(ExpressionStatement): originalHandler = outofbandVarianceMarkerHandler; */
                /* TODO(ExpressionStatement): outofbandVarianceMarkerHandler = onlyUnreliable => {                     propagatingVarianceFlags |= onlyUnreliable ? RelationComparisonResult.ReportsUnreliable : RelationComparisonResult.ReportsUnmeasurable;                     return originalHandler!(onlyUnreliable);                 }; */
            }
            var result Ternary
            if /* TODO(BinaryExpression): expandingFlags === ExpandingFlags.Both */ TODO {
                /* TODO(ExpressionStatement): tracing?.instant(tracing.Phase.CheckTypes, "recursiveTypeRelatedTo_DepthLimit", {                     sourceId: source.id,                     sourceIdStack: sourceStack.map(t => t.id),                     targetId: target.id,                     targetIdStack: targetStack.map(t => t.id),                     depth: sourceDepth,                     targetDepth,                 }); */
                /* TODO(ExpressionStatement): result = Ternary.Maybe; */
            } else {
                /* TODO(ExpressionStatement): tracing?.push(tracing.Phase.CheckTypes, "structuredTypeRelatedTo", { sourceId: source.id, targetId: target.id }); */
                /* TODO(ExpressionStatement): result = structuredTypeRelatedTo(source, target, reportErrors, intersectionState); */
                /* TODO(ExpressionStatement): tracing?.pop(); */
            }
            if outofbandVarianceMarkerHandler {
                /* TODO(ExpressionStatement): outofbandVarianceMarkerHandler = originalHandler; */
            }
            if /* TODO(BinaryExpression): recursionFlags & RecursionFlags.Source */ TODO {
                /* TODO(ExpressionStatement): sourceDepth--; */
            }
            if /* TODO(BinaryExpression): recursionFlags & RecursionFlags.Target */ TODO {
                /* TODO(ExpressionStatement): targetDepth--; */
            }
            /* TODO(ExpressionStatement): expandingFlags = saveExpandingFlags; */
            if result {
                if /* TODO(BinaryExpression): result === Ternary.True || (sourceDepth === 0 && targetDepth === 0) */ TODO {
                    if /* TODO(BinaryExpression): result === Ternary.True || result === Ternary.Maybe */ TODO {
                        /* TODO(ExpressionStatement): resetMaybeStack(/*markAllAsSucceeded* / true); */
                    } else {
                        /* TODO(ExpressionStatement): resetMaybeStack(/*markAllAsSucceeded* / false); */
                    }
                }
            } else {
                /* TODO(ExpressionStatement): relation.set(id, RelationComparisonResult.Failed | propagatingVarianceFlags); */
                /* TODO(ExpressionStatement): relationCount--; */
                /* TODO(ExpressionStatement): resetMaybeStack(/*markAllAsSucceeded* / false); */
            }
             result
            resetMaybeStack := func(markAllAsSucceeded bool) {
                /* TODO(ForStatement): for (let i = maybeStart; i < maybeCount; i++) {                     maybeKeysSet.delete(maybeKeys[i]);                     if (markAllAsSucceeded) {                         relation.set(maybeKeys[i], RelationComparisonResult.Succeeded | propagatingVarianceFlags);                         relationCount--;                     }                 } */
                /* TODO(ExpressionStatement): maybeCount = maybeStart; */
            }
        }
        structuredTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
            saveErrorInfo := captureErrorCalculationState()
            result := structuredTypeRelatedToWorker(source, target, reportErrors, intersectionState, saveErrorInfo)
            if /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
                if /* TODO(BinaryExpression): !result && (source.flags & TypeFlags.Intersection || source.flags & TypeFlags.TypeParameter && target.flags & TypeFlags.Union) */ TODO {
                    constraint := getEffectiveConstraintOfIntersection(/* TODO(ConditionalExpression): source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source] */ TODO, /* TODO(PrefixUnaryExpression): !!(target.flags & TypeFlags.Union) */ TODO)
                    if /* TODO(BinaryExpression): constraint && everyType(constraint, c => c !== source) */ TODO {
                        /* TODO(ExpressionStatement): result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false, /*headMessage* / undefined, intersectionState); */
                    }
                }
                if /* TODO(BinaryExpression): result && !(intersectionState & IntersectionState.Target) && target.flags & TypeFlags.Intersection &&                     !isGenericObjectType(target) && source.flags & (TypeFlags.Object | TypeFlags.Intersection) */ TODO {
                    /* TODO(ExpressionStatement): result &= propertiesRelatedTo(source, target, reportErrors, /*excludedProperties* / undefined, /*optionalsOnly* / false, IntersectionState.None); */
                    if /* TODO(BinaryExpression): result && isObjectLiteralType(source) && getObjectFlags(source) & ObjectFlags.FreshLiteral */ TODO {
                        /* TODO(ExpressionStatement): result &= indexSignaturesRelatedTo(source, target, /*sourceIsPrimitive* / false, reportErrors, IntersectionState.None); */
                    }
                } else if /* TODO(BinaryExpression): result && isNonGenericObjectType(target) && !isArrayOrTupleType(target) &&                     source.flags & TypeFlags.Intersection && getApparentType(source).flags & TypeFlags.StructuredType &&                     !some((source as IntersectionType).types, t => t === target || !!(getObjectFlags(t) & ObjectFlags.NonInferrableType)) */ TODO {
                    /* TODO(ExpressionStatement): result &= propertiesRelatedTo(source, target, reportErrors, /*excludedProperties* / undefined, /*optionalsOnly* / true, intersectionState); */
                }
            }
            if result {
                /* TODO(ExpressionStatement): resetErrorInfo(saveErrorInfo); */
            }
             result
        }
        getApparentMappedTypeKeys := func(nameType Type, targetType MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
            modifiersType := getApparentType(getModifiersTypeFromMappedType(targetType))
            var mappedKeys []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(ExpressionStatement): forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(                 modifiersType,                 TypeFlags.StringOrNumberLiteralOrUnique,                 /*stringsOnly* / false,                 t => void mappedKeys.push(instantiateType(nameType, appendTypeMapping(targetType.mapper, getTypeParameterFromMappedType(targetType), t))),             ); */
             getUnionType(mappedKeys)
        }
        structuredTypeRelatedToWorker := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, saveErrorInfo ReturnType[/* TODO(TypeQuery): typeof captureErrorCalculationState */ TODO]) Ternary {
            var result Ternary
            var originalErrorInfo *DiagnosticMessageChain
            varianceCheckFailed := /* TODO(FalseKeyword): false */ TODO
            sourceFlags := /* TODO(PropertyAccessExpression): source.flags */ TODO
            targetFlags := /* TODO(PropertyAccessExpression): target.flags */ TODO
            if /* TODO(BinaryExpression): relation === identityRelation */ TODO {
                if /* TODO(BinaryExpression): sourceFlags & TypeFlags.UnionOrIntersection */ TODO {
                    result := eachTypeRelatedToSomeType(source /* as */ /* TODO(TypeReference): UnionOrIntersectionType */, target /* as */ /* TODO(TypeReference): UnionOrIntersectionType */)
                    if result {
                        /* TODO(ExpressionStatement): result &= eachTypeRelatedToSomeType(target as UnionOrIntersectionType, source as UnionOrIntersectionType); */
                    }
                     result
                }
                if /* TODO(BinaryExpression): sourceFlags & TypeFlags.Index */ TODO {
                     isRelatedTo(/* TODO(PropertyAccessExpression): (source as IndexType).type */ TODO, /* TODO(PropertyAccessExpression): (target as IndexType).type */ TODO, /* TODO(PropertyAccessExpression): RecursionFlags.Both */ TODO, /* TODO(FalseKeyword): false */ TODO)
                }
                if /* TODO(BinaryExpression): sourceFlags & TypeFlags.IndexedAccess */ TODO {
                    if /* TODO(BinaryExpression): result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
                        if /* TODO(BinaryExpression): result &= isRelatedTo((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
                             result
                        }
                    }
                }
                if /* TODO(BinaryExpression): sourceFlags & TypeFlags.Conditional */ TODO {
                    if /* TODO(BinaryExpression): (source as ConditionalType).root.isDistributive === (target as ConditionalType).root.isDistributive */ TODO {
                        if /* TODO(BinaryExpression): result = isRelatedTo((source as ConditionalType).checkType, (target as ConditionalType).checkType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
                            if /* TODO(BinaryExpression): result &= isRelatedTo((source as ConditionalType).extendsType, (target as ConditionalType).extendsType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
                                if /* TODO(BinaryExpression): result &= isRelatedTo(getTrueTypeFromConditionalType(source as ConditionalType), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
                                    if /* TODO(BinaryExpression): result &= isRelatedTo(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
                                         result
                                    }
                                }
                            }
                        }
                    }
                }
                if /* TODO(BinaryExpression): sourceFlags & TypeFlags.Substitution */ TODO {
                    if /* TODO(BinaryExpression): result = isRelatedTo((source as SubstitutionType).baseType, (target as SubstitutionType).baseType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
                        if /* TODO(BinaryExpression): result &= isRelatedTo((source as SubstitutionType).constraint, (target as SubstitutionType).constraint, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
                             result
                        }
                    }
                }
                if /* TODO(PrefixUnaryExpression): !(sourceFlags & TypeFlags.Object) */ TODO {
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
            } else if /* TODO(BinaryExpression): sourceFlags & TypeFlags.UnionOrIntersection || targetFlags & TypeFlags.UnionOrIntersection */ TODO {
                if /* TODO(BinaryExpression): result = unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) */ TODO {
                     result
                }
                if /* TODO(PrefixUnaryExpression): !(sourceFlags & TypeFlags.Instantiable ||                         sourceFlags & TypeFlags.Object && targetFlags & TypeFlags.Union ||                         sourceFlags & TypeFlags.Intersection && targetFlags & (TypeFlags.Object | TypeFlags.Union | TypeFlags.Instantiable)) */ TODO {
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
            }
            if /* TODO(BinaryExpression): sourceFlags & (TypeFlags.Object | TypeFlags.Conditional) && source.aliasSymbol && source.aliasTypeArguments &&                 source.aliasSymbol === target.aliasSymbol && !(isMarkerType(source) || isMarkerType(target)) */ TODO {
                variances := getAliasVariances(/* TODO(PropertyAccessExpression): source.aliasSymbol */ TODO)
                if /* TODO(BinaryExpression): variances === emptyArray */ TODO {
                     /* TODO(PropertyAccessExpression): Ternary.Unknown */ TODO
                }
                params := /* TODO(NonNullExpression): getSymbolLinks(source.aliasSymbol).typeParameters! */ TODO
                minParams := getMinTypeArgumentCount(params)
                sourceTypes := fillMissingTypeArguments(/* TODO(PropertyAccessExpression): source.aliasTypeArguments */ TODO, params, minParams, isInJSFile(/* TODO(PropertyAccessExpression): source.aliasSymbol.valueDeclaration */ TODO))
                targetTypes := fillMissingTypeArguments(/* TODO(PropertyAccessExpression): target.aliasTypeArguments */ TODO, params, minParams, isInJSFile(/* TODO(PropertyAccessExpression): source.aliasSymbol.valueDeclaration */ TODO))
                varianceResult := relateVariances(sourceTypes, targetTypes, variances, intersectionState)
                if /* TODO(BinaryExpression): varianceResult !== undefined */ TODO {
                     varianceResult
                }
            }
            if /* TODO(BinaryExpression): isSingleElementGenericTupleType(source) && !source.target.readonly && (result = isRelatedTo(getTypeArguments(source)[0], target, RecursionFlags.Source)) ||                 isSingleElementGenericTupleType(target) && (target.target.readonly || isMutableArrayOrTuple(getBaseConstraintOfType(source) || source)) && (result = isRelatedTo(source, getTypeArguments(target)[0], RecursionFlags.Target)) */ TODO {
                 result
            }
            if /* TODO(BinaryExpression): targetFlags & TypeFlags.TypeParameter */ TODO {
                if /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.Mapped && !(source as MappedType).declaration.nameType && isRelatedTo(getIndexType(target), getConstraintTypeFromMappedType(source as MappedType), RecursionFlags.Both) */ TODO {
                    if /* TODO(PrefixUnaryExpression): !(getMappedTypeModifiers(source as MappedType) & MappedTypeModifiers.IncludeOptional) */ TODO {
                        templateType := getTemplateTypeFromMappedType(source /* as */ /* TODO(TypeReference): MappedType */)
                        indexedAccessType := getIndexedAccessType(target, getTypeParameterFromMappedType(source /* as */ /* TODO(TypeReference): MappedType */))
                        if /* TODO(BinaryExpression): result = isRelatedTo(templateType, indexedAccessType, RecursionFlags.Both, reportErrors) */ TODO {
                             result
                        }
                    }
                }
                if /* TODO(BinaryExpression): relation === comparableRelation && sourceFlags & TypeFlags.TypeParameter */ TODO {
                    constraint := getConstraintOfTypeParameter(source)
                    if constraint {
                        /* TODO(WhileStatement): while (constraint && someType(constraint, c => !!(c.flags & TypeFlags.TypeParameter))) {                             if (result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false)) {                                 return result;                             }                             constraint = getConstraintOfTypeParameter(constraint);                         } */
                    }
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
            } else if /* TODO(BinaryExpression): targetFlags & TypeFlags.Index */ TODO {
                targetType := /* TODO(PropertyAccessExpression): (target as IndexType).type */ TODO
                if /* TODO(BinaryExpression): sourceFlags & TypeFlags.Index */ TODO {
                    if /* TODO(BinaryExpression): result = isRelatedTo(targetType, (source as IndexType).type, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
                         result
                    }
                }
                if isTupleType(targetType) {
                    if /* TODO(BinaryExpression): result = isRelatedTo(source, getKnownKeysOfTupleType(targetType), RecursionFlags.Target, reportErrors) */ TODO {
                         result
                    }
                } else {
                    constraint := getSimplifiedTypeOrConstraint(targetType)
                    if constraint {
                        if /* TODO(BinaryExpression): isRelatedTo(source, getIndexType(constraint, (target as IndexType).indexFlags | IndexFlags.NoReducibleCheck), RecursionFlags.Target, reportErrors) === Ternary.True */ TODO {
                             /* TODO(PropertyAccessExpression): Ternary.True */ TODO
                        }
                    } else if isGenericMappedType(targetType) {
                        nameType := getNameTypeFromMappedType(targetType)
                        constraintType := getConstraintTypeFromMappedType(targetType)
                        targetKeys
                        if /* TODO(BinaryExpression): nameType && isMappedTypeWithKeyofConstraintDeclaration(targetType) */ TODO {
                            mappedKeys := getApparentMappedTypeKeys(nameType, targetType)
                            /* TODO(ExpressionStatement): targetKeys = getUnionType([mappedKeys, nameType]); */
                        } else {
                            /* TODO(ExpressionStatement): targetKeys = nameType || constraintType; */
                        }
                        if /* TODO(BinaryExpression): isRelatedTo(source, targetKeys, RecursionFlags.Target, reportErrors) === Ternary.True */ TODO {
                             /* TODO(PropertyAccessExpression): Ternary.True */ TODO
                        }
                    }
                }
            } else if /* TODO(BinaryExpression): targetFlags & TypeFlags.IndexedAccess */ TODO {
                if /* TODO(BinaryExpression): sourceFlags & TypeFlags.IndexedAccess */ TODO {
                    if /* TODO(BinaryExpression): result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, reportErrors) */ TODO {
                        /* TODO(ExpressionStatement): result &= isRelatedTo((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType, RecursionFlags.Both, reportErrors); */
                    }
                    if result {
                         result
                    }
                    if reportErrors {
                        /* TODO(ExpressionStatement): originalErrorInfo = errorInfo; */
                    }
                }
                if /* TODO(BinaryExpression): relation === assignableRelation || relation === comparableRelation */ TODO {
                    objectType := /* TODO(PropertyAccessExpression): (target as IndexedAccessType).objectType */ TODO
                    indexType := /* TODO(PropertyAccessExpression): (target as IndexedAccessType).indexType */ TODO
                    baseObjectType := /* TODO(BinaryExpression): getBaseConstraintOfType(objectType) || objectType */ TODO
                    baseIndexType := /* TODO(BinaryExpression): getBaseConstraintOfType(indexType) || indexType */ TODO
                    if /* TODO(BinaryExpression): !isGenericObjectType(baseObjectType) && !isGenericIndexType(baseIndexType) */ TODO {
                        accessFlags := /* TODO(BinaryExpression): AccessFlags.Writing | (baseObjectType !== objectType ? AccessFlags.NoIndexSignatures : 0) */ TODO
                        constraint := getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, accessFlags)
                        if constraint {
                            if /* TODO(BinaryExpression): reportErrors && originalErrorInfo */ TODO {
                                /* TODO(ExpressionStatement): resetErrorInfo(saveErrorInfo); */
                            }
                            if /* TODO(BinaryExpression): result = isRelatedTo(source, constraint, RecursionFlags.Target, reportErrors, /*headMessage* / undefined, intersectionState) */ TODO {
                                 result
                            }
                            if /* TODO(BinaryExpression): reportErrors && originalErrorInfo && errorInfo */ TODO {
                                /* TODO(ExpressionStatement): errorInfo = countMessageChainBreadth([originalErrorInfo]) <= countMessageChainBreadth([errorInfo]) ? originalErrorInfo : errorInfo; */
                            }
                        }
                    }
                }
                if reportErrors {
                    /* TODO(ExpressionStatement): originalErrorInfo = undefined; */
                }
            } else if /* TODO(BinaryExpression): isGenericMappedType(target) && relation !== identityRelation */ TODO {
                keysRemapped := /* TODO(PrefixUnaryExpression): !!target.declaration.nameType */ TODO
                templateType := getTemplateTypeFromMappedType(target)
                modifiers := getMappedTypeModifiers(target)
                if /* TODO(PrefixUnaryExpression): !(modifiers & MappedTypeModifiers.ExcludeOptional) */ TODO {
                    if /* TODO(BinaryExpression): !keysRemapped && templateType.flags & TypeFlags.IndexedAccess && (templateType as IndexedAccessType).objectType === source &&                         (templateType as IndexedAccessType).indexType === getTypeParameterFromMappedType(target) */ TODO {
                         /* TODO(PropertyAccessExpression): Ternary.True */ TODO
                    }
                    if /* TODO(PrefixUnaryExpression): !isGenericMappedType(source) */ TODO {
                        targetKeys := /* TODO(ConditionalExpression): keysRemapped ? getNameTypeFromMappedType(target)! : getConstraintTypeFromMappedType(target) */ TODO
                        sourceKeys := getIndexType(source, /* TODO(PropertyAccessExpression): IndexFlags.NoIndexSignatures */ TODO)
                        includeOptional := /* TODO(BinaryExpression): modifiers & MappedTypeModifiers.IncludeOptional */ TODO
                        filteredByApplicability := /* TODO(ConditionalExpression): includeOptional ? intersectTypes(targetKeys, sourceKeys) : undefined */ TODO
                        if /* TODO(ConditionalExpression): includeOptional                                 ? !(filteredByApplicability!.flags & TypeFlags.Never)                                 : isRelatedTo(targetKeys, sourceKeys, RecursionFlags.Both) */ TODO {
                            templateType := getTemplateTypeFromMappedType(target)
                            typeParameter := getTypeParameterFromMappedType(target)
                            nonNullComponent := extractTypesOfKind(templateType, /* TODO(PrefixUnaryExpression): ~TypeFlags.Nullable */ TODO)
                            if /* TODO(BinaryExpression): !keysRemapped && nonNullComponent.flags & TypeFlags.IndexedAccess && (nonNullComponent as IndexedAccessType).indexType === typeParameter */ TODO {
                                if /* TODO(BinaryExpression): result = isRelatedTo(source, (nonNullComponent as IndexedAccessType).objectType, RecursionFlags.Target, reportErrors) */ TODO {
                                     result
                                }
                            } else {
                                indexingType := /* TODO(ConditionalExpression): keysRemapped                                     ? (filteredByApplicability || targetKeys)                                     : filteredByApplicability                                     ? getIntersectionType([filteredByApplicability, typeParameter])                                     : typeParameter */ TODO
                                indexedAccessType := getIndexedAccessType(source, indexingType)
                                if /* TODO(BinaryExpression): result = isRelatedTo(indexedAccessType, templateType, RecursionFlags.Both, reportErrors) */ TODO {
                                     result
                                }
                            }
                        }
                        /* TODO(ExpressionStatement): originalErrorInfo = errorInfo; */
                        /* TODO(ExpressionStatement): resetErrorInfo(saveErrorInfo); */
                    }
                }
            } else if /* TODO(BinaryExpression): targetFlags & TypeFlags.Conditional */ TODO {
                if isDeeplyNestedType(target, targetStack, targetDepth, 10) {
                     /* TODO(PropertyAccessExpression): Ternary.Maybe */ TODO
                }
                c := target /* as */ /* TODO(TypeReference): ConditionalType */
                if /* TODO(BinaryExpression): !c.root.inferTypeParameters && !isDistributionDependent(c.root) && !(source.flags & TypeFlags.Conditional && (source as ConditionalType).root === c.root) */ TODO {
                    skipTrue := /* TODO(PrefixUnaryExpression): !isTypeAssignableTo(getPermissiveInstantiation(c.checkType), getPermissiveInstantiation(c.extendsType)) */ TODO
                    skipFalse := /* TODO(BinaryExpression): !skipTrue && isTypeAssignableTo(getRestrictiveInstantiation(c.checkType), getRestrictiveInstantiation(c.extendsType)) */ TODO
                    if /* TODO(BinaryExpression): result = skipTrue ? Ternary.True : isRelatedTo(source, getTrueTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
                        /* TODO(ExpressionStatement): result &= skipFalse ? Ternary.True : isRelatedTo(source, getFalseTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors* / false, /*headMessage* / undefined, intersectionState); */
                        if result {
                             result
                        }
                    }
                }
            } else if /* TODO(BinaryExpression): targetFlags & TypeFlags.TemplateLiteral */ TODO {
                if /* TODO(BinaryExpression): sourceFlags & TypeFlags.TemplateLiteral */ TODO {
                    if /* TODO(BinaryExpression): relation === comparableRelation */ TODO {
                         /* TODO(ConditionalExpression): templateLiteralTypesDefinitelyUnrelated(source as TemplateLiteralType, target as TemplateLiteralType) ? Ternary.False : Ternary.True */ TODO
                    }
                    /* TODO(ExpressionStatement): instantiateType(source, reportUnreliableMapper); */
                }
                if isTypeMatchedByTemplateLiteralType(source, target /* as */ /* TODO(TypeReference): TemplateLiteralType */) {
                     /* TODO(PropertyAccessExpression): Ternary.True */ TODO
                }
            } else if /* TODO(BinaryExpression): target.flags & TypeFlags.StringMapping */ TODO {
                if /* TODO(PrefixUnaryExpression): !(source.flags & TypeFlags.StringMapping) */ TODO {
                    if isMemberOfStringMapping(source, target) {
                         /* TODO(PropertyAccessExpression): Ternary.True */ TODO
                    }
                }
            }
            if /* TODO(BinaryExpression): sourceFlags & TypeFlags.TypeVariable */ TODO {
                if /* TODO(PrefixUnaryExpression): !(sourceFlags & TypeFlags.IndexedAccess && targetFlags & TypeFlags.IndexedAccess) */ TODO {
                    constraint := /* TODO(BinaryExpression): getConstraintOfType(source as TypeVariable) || unknownType */ TODO
                    if /* TODO(BinaryExpression): result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
                         result
                    } else if /* TODO(BinaryExpression): result = isRelatedTo(getTypeWithThisArgument(constraint, source), target, RecursionFlags.Source, reportErrors && constraint !== unknownType && !(targetFlags & sourceFlags & TypeFlags.TypeParameter), /*headMessage* / undefined, intersectionState) */ TODO {
                         result
                    }
                    if isMappedTypeGenericIndexedAccess(source) {
                        indexConstraint := getConstraintOfType(/* TODO(PropertyAccessExpression): (source as IndexedAccessType).indexType */ TODO)
                        if indexConstraint {
                            if /* TODO(BinaryExpression): result = isRelatedTo(getIndexedAccessType((source as IndexedAccessType).objectType, indexConstraint), target, RecursionFlags.Source, reportErrors) */ TODO {
                                 result
                            }
                        }
                    }
                }
            } else if /* TODO(BinaryExpression): sourceFlags & TypeFlags.Index */ TODO {
                isDeferredMappedIndex := /* TODO(BinaryExpression): shouldDeferIndexType((source as IndexType).type, (source as IndexType).indexFlags) && getObjectFlags((source as IndexType).type) & ObjectFlags.Mapped */ TODO
                if /* TODO(BinaryExpression): result = isRelatedTo(stringNumberSymbolType, target, RecursionFlags.Source, reportErrors && !isDeferredMappedIndex) */ TODO {
                     result
                }
                if isDeferredMappedIndex {
                    mappedType := /* TODO(PropertyAccessExpression): (source as IndexType).type */ TODO /* as */ /* TODO(TypeReference): MappedType */
                    nameType := getNameTypeFromMappedType(mappedType)
                    sourceMappedKeys := /* TODO(ConditionalExpression): nameType && isMappedTypeWithKeyofConstraintDeclaration(mappedType) ? getApparentMappedTypeKeys(nameType, mappedType) : (nameType || getConstraintTypeFromMappedType(mappedType)) */ TODO
                    if /* TODO(BinaryExpression): result = isRelatedTo(sourceMappedKeys, target, RecursionFlags.Source, reportErrors) */ TODO {
                         result
                    }
                }
            } else if /* TODO(BinaryExpression): sourceFlags & TypeFlags.TemplateLiteral && !(targetFlags & TypeFlags.Object) */ TODO {
                if /* TODO(PrefixUnaryExpression): !(targetFlags & TypeFlags.TemplateLiteral) */ TODO {
                    constraint := getBaseConstraintOfType(source)
                    if /* TODO(BinaryExpression): constraint && constraint !== source && (result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors)) */ TODO {
                         result
                    }
                }
            } else if /* TODO(BinaryExpression): sourceFlags & TypeFlags.StringMapping */ TODO {
                if /* TODO(BinaryExpression): targetFlags & TypeFlags.StringMapping */ TODO {
                    if /* TODO(BinaryExpression): (source as StringMappingType).symbol !== (target as StringMappingType).symbol */ TODO {
                         /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                    }
                    if /* TODO(BinaryExpression): result = isRelatedTo((source as StringMappingType).type, (target as StringMappingType).type, RecursionFlags.Both, reportErrors) */ TODO {
                         result
                    }
                } else {
                    constraint := getBaseConstraintOfType(source)
                    if /* TODO(BinaryExpression): constraint && (result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors)) */ TODO {
                         result
                    }
                }
            } else if /* TODO(BinaryExpression): sourceFlags & TypeFlags.Conditional */ TODO {
                if isDeeplyNestedType(source, sourceStack, sourceDepth, 10) {
                     /* TODO(PropertyAccessExpression): Ternary.Maybe */ TODO
                }
                if /* TODO(BinaryExpression): targetFlags & TypeFlags.Conditional */ TODO {
                    sourceParams := /* TODO(PropertyAccessExpression): (source as ConditionalType).root.inferTypeParameters */ TODO
                    sourceExtends := /* TODO(PropertyAccessExpression): (source as ConditionalType).extendsType */ TODO
                    var mapper *TypeMapper
                    if sourceParams {
                        ctx := createInferenceContext(sourceParams, undefined, /* TODO(PropertyAccessExpression): InferenceFlags.None */ TODO, isRelatedToWorker)
                        /* TODO(ExpressionStatement): inferTypes(ctx.inferences, (target as ConditionalType).extendsType, sourceExtends, InferencePriority.NoConstraints | InferencePriority.AlwaysStrict); */
                        /* TODO(ExpressionStatement): sourceExtends = instantiateType(sourceExtends, ctx.mapper); */
                        /* TODO(ExpressionStatement): mapper = ctx.mapper; */
                    }
                    if /* TODO(BinaryExpression): isTypeIdenticalTo(sourceExtends, (target as ConditionalType).extendsType) &&                         (isRelatedTo((source as ConditionalType).checkType, (target as ConditionalType).checkType, RecursionFlags.Both) || isRelatedTo((target as ConditionalType).checkType, (source as ConditionalType).checkType, RecursionFlags.Both)) */ TODO {
                        if /* TODO(BinaryExpression): result = isRelatedTo(instantiateType(getTrueTypeFromConditionalType(source as ConditionalType), mapper), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, reportErrors) */ TODO {
                            /* TODO(ExpressionStatement): result &= isRelatedTo(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, reportErrors); */
                        }
                        if result {
                             result
                        }
                    }
                }
                defaultConstraint := getDefaultConstraintOfConditionalType(source /* as */ /* TODO(TypeReference): ConditionalType */)
                if defaultConstraint {
                    if /* TODO(BinaryExpression): result = isRelatedTo(defaultConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
                         result
                    }
                }
                distributiveConstraint := /* TODO(ConditionalExpression): !(targetFlags & TypeFlags.Conditional) && hasNonCircularBaseConstraint(source) ? getConstraintOfDistributiveConditionalType(source as ConditionalType) : undefined */ TODO
                if distributiveConstraint {
                    /* TODO(ExpressionStatement): resetErrorInfo(saveErrorInfo); */
                    if /* TODO(BinaryExpression): result = isRelatedTo(distributiveConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
                         result
                    }
                }
            } else {
                if /* TODO(BinaryExpression): relation !== subtypeRelation && relation !== strictSubtypeRelation && isPartialMappedType(target) && isEmptyObjectType(source) */ TODO {
                     /* TODO(PropertyAccessExpression): Ternary.True */ TODO
                }
                if isGenericMappedType(target) {
                    if isGenericMappedType(source) {
                        if /* TODO(BinaryExpression): result = mappedTypeRelatedTo(source, target, reportErrors) */ TODO {
                             result
                        }
                    }
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
                sourceIsPrimitive := /* TODO(PrefixUnaryExpression): !!(sourceFlags & TypeFlags.Primitive) */ TODO
                if /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
                    /* TODO(ExpressionStatement): source = getApparentType(source); */
                    /* TODO(ExpressionStatement): sourceFlags = source.flags; */
                } else if isGenericMappedType(source) {
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
                if /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.Reference && getObjectFlags(target) & ObjectFlags.Reference && (source as TypeReference).target === (target as TypeReference).target &&                     !isTupleType(source) && !(isMarkerType(source) || isMarkerType(target)) */ TODO {
                    if isEmptyArrayLiteralType(source) {
                         /* TODO(PropertyAccessExpression): Ternary.True */ TODO
                    }
                    variances := getVariances(/* TODO(PropertyAccessExpression): (source as TypeReference).target */ TODO)
                    if /* TODO(BinaryExpression): variances === emptyArray */ TODO {
                         /* TODO(PropertyAccessExpression): Ternary.Unknown */ TODO
                    }
                    varianceResult := relateVariances(getTypeArguments(source /* as */ /* TODO(TypeReference): TypeReference */), getTypeArguments(target /* as */ /* TODO(TypeReference): TypeReference */), variances, intersectionState)
                    if /* TODO(BinaryExpression): varianceResult !== undefined */ TODO {
                         varianceResult
                    }
                } else if /* TODO(ConditionalExpression): isReadonlyArrayType(target) ? everyType(source, isArrayOrTupleType) : isArrayType(target) && everyType(source, t => isTupleType(t) && !t.target.readonly) */ TODO {
                    if /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
                         isRelatedTo(/* TODO(BinaryExpression): getIndexTypeOfType(source, numberType) || anyType */ TODO, /* TODO(BinaryExpression): getIndexTypeOfType(target, numberType) || anyType */ TODO, /* TODO(PropertyAccessExpression): RecursionFlags.Both */ TODO, reportErrors)
                    } else {
                         /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                    }
                } else if /* TODO(BinaryExpression): isGenericTupleType(source) && isTupleType(target) && !isGenericTupleType(target) */ TODO {
                    constraint := getBaseConstraintOrType(source)
                    if /* TODO(BinaryExpression): constraint !== source */ TODO {
                         isRelatedTo(constraint, target, /* TODO(PropertyAccessExpression): RecursionFlags.Source */ TODO, reportErrors)
                    }
                } else if /* TODO(BinaryExpression): (relation === subtypeRelation || relation === strictSubtypeRelation) && isEmptyObjectType(target) && getObjectFlags(target) & ObjectFlags.FreshLiteral && !isEmptyObjectType(source) */ TODO {
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
                if /* TODO(BinaryExpression): sourceFlags & (TypeFlags.Object | TypeFlags.Intersection) && targetFlags & TypeFlags.Object */ TODO {
                    reportStructuralErrors := /* TODO(BinaryExpression): reportErrors && errorInfo === saveErrorInfo.errorInfo && !sourceIsPrimitive */ TODO
                    /* TODO(ExpressionStatement): result = propertiesRelatedTo(source, target, reportStructuralErrors, /*excludedProperties* / undefined, /*optionalsOnly* / false, intersectionState); */
                    if result {
                        /* TODO(ExpressionStatement): result &= signaturesRelatedTo(source, target, SignatureKind.Call, reportStructuralErrors, intersectionState); */
                        if result {
                            /* TODO(ExpressionStatement): result &= signaturesRelatedTo(source, target, SignatureKind.Construct, reportStructuralErrors, intersectionState); */
                            if result {
                                /* TODO(ExpressionStatement): result &= indexSignaturesRelatedTo(source, target, sourceIsPrimitive, reportStructuralErrors, intersectionState); */
                            }
                        }
                    }
                    if /* TODO(BinaryExpression): varianceCheckFailed && result */ TODO {
                        /* TODO(ExpressionStatement): errorInfo = originalErrorInfo || errorInfo || saveErrorInfo.errorInfo; */
                    } else if result {
                         result
                    }
                }
                if /* TODO(BinaryExpression): sourceFlags & (TypeFlags.Object | TypeFlags.Intersection) && targetFlags & TypeFlags.Union */ TODO {
                    objectOnlyTarget := extractTypesOfKind(target, /* TODO(BinaryExpression): TypeFlags.Object | TypeFlags.Intersection | TypeFlags.Substitution */ TODO)
                    if /* TODO(BinaryExpression): objectOnlyTarget.flags & TypeFlags.Union */ TODO {
                        result := typeRelatedToDiscriminatedType(source, objectOnlyTarget /* as */ /* TODO(TypeReference): UnionType */)
                        if result {
                             result
                        }
                    }
                }
            }
             /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            countMessageChainBreadth := func(info /* TODO(ArrayType): DiagnosticMessageChain[] */ any) number {
                if /* TODO(PrefixUnaryExpression): !info */ TODO {
                    /* TODO(NumericLiteral): 0 */
                }
                 reduceLeft(info, /* TODO(ArrowFunction): (value, chain) => value + 1 + countMessageChainBreadth(chain.next) */ TODO, 0)
            }
            relateVariances := func(sourceTypeArguments /* TODO(TypeOperator): readonly Type[] */ any, targetTypeArguments /* TODO(TypeOperator): readonly Type[] */ any, variances []VarianceFlags, intersectionState IntersectionState) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary | undefined */ TODO {
                if /* TODO(BinaryExpression): result = typeArgumentsRelatedTo(sourceTypeArguments, targetTypeArguments, variances, reportErrors, intersectionState) */ TODO {
                     result
                }
                if some(variances, /* TODO(ArrowFunction): v => !!(v & VarianceFlags.AllowsStructuralFallback) */ TODO) {
                    /* TODO(ExpressionStatement): originalErrorInfo = undefined; */
                    /* TODO(ExpressionStatement): resetErrorInfo(saveErrorInfo); */
                     undefined
                }
                allowStructuralFallback := /* TODO(BinaryExpression): targetTypeArguments && hasCovariantVoidArgument(targetTypeArguments, variances) */ TODO
                /* TODO(ExpressionStatement): varianceCheckFailed = !allowStructuralFallback; */
                if /* TODO(BinaryExpression): variances !== emptyArray && !allowStructuralFallback */ TODO {
                    if /* TODO(BinaryExpression): varianceCheckFailed && !(reportErrors && some(variances, v => (v & VarianceFlags.VarianceMask) === VarianceFlags.Invariant)) */ TODO {
                         /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                    }
                    /* TODO(ExpressionStatement): originalErrorInfo = errorInfo; */
                    /* TODO(ExpressionStatement): resetErrorInfo(saveErrorInfo); */
                }
            }
        }
        mappedTypeRelatedTo := func(source MappedType, target MappedType, reportErrors bool) Ternary {
            modifiersRelated := /* TODO(BinaryExpression): relation === comparableRelation || (relation === identityRelation ? getMappedTypeModifiers(source) === getMappedTypeModifiers(target) :                 getCombinedMappedTypeOptionality(source) <= getCombinedMappedTypeOptionality(target)) */ TODO
            if modifiersRelated {
                var result Ternary
                targetConstraint := getConstraintTypeFromMappedType(target)
                sourceConstraint := instantiateType(getConstraintTypeFromMappedType(source), /* TODO(ConditionalExpression): getCombinedMappedTypeOptionality(source) < 0 ? reportUnmeasurableMapper : reportUnreliableMapper */ TODO)
                if /* TODO(BinaryExpression): result = isRelatedTo(targetConstraint, sourceConstraint, RecursionFlags.Both, reportErrors) */ TODO {
                    mapper := createTypeMapper(/* TODO(ArrayLiteralExpression): [getTypeParameterFromMappedType(source)] */ TODO, /* TODO(ArrayLiteralExpression): [getTypeParameterFromMappedType(target)] */ TODO)
                    if /* TODO(BinaryExpression): instantiateType(getNameTypeFromMappedType(source), mapper) === instantiateType(getNameTypeFromMappedType(target), mapper) */ TODO {
                         /* TODO(BinaryExpression): result & isRelatedTo(instantiateType(getTemplateTypeFromMappedType(source), mapper), getTemplateTypeFromMappedType(target), RecursionFlags.Both, reportErrors) */ TODO
                    }
                }
            }
             /* TODO(PropertyAccessExpression): Ternary.False */ TODO
        }
        typeRelatedToDiscriminatedType := func(source Type, target UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
            sourceProperties := getPropertiesOfType(source)
            sourcePropertiesFiltered := findDiscriminantProperties(sourceProperties, target)
            if /* TODO(PrefixUnaryExpression): !sourcePropertiesFiltered */ TODO {
                /* TODO(PropertyAccessExpression): Ternary.False */
            }
            numCombinations := 1
            /* TODO(ForOfStatement): for (const sourceProperty of sourcePropertiesFiltered) {                 numCombinations *= countTypes(getNonMissingTypeOfSymbol(sourceProperty));                 if (numCombinations > 25) {                     // We've reached the complexity limit.                     tracing?.instant(tracing.Phase.CheckTypes, "typeRelatedToDiscriminatedType_DepthLimit", { sourceId: source.id, targetId: target.id, numCombinations });                     return Ternary.False;                 }             } */
            var sourceDiscriminantTypes [][]Type = /* TODO(NewExpression): new Array<Type[]>(sourcePropertiesFiltered.length) */ TODO
            excludedProperties := /* TODO(NewExpression): new Set<__String>() */ TODO
            /* TODO(ForStatement): for (let i = 0; i < sourcePropertiesFiltered.length; i++) {                 const sourceProperty = sourcePropertiesFiltered[i];                 const sourcePropertyType = getNonMissingTypeOfSymbol(sourceProperty);                 sourceDiscriminantTypes[i] = sourcePropertyType.flags & TypeFlags.Union                     ? (sourcePropertyType as UnionType).types                     : [sourcePropertyType];                 excludedProperties.add(sourceProperty.escapedName);             } */
            discriminantCombinations := cartesianProduct(sourceDiscriminantTypes)
            var matchingTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(ForOfStatement): for (const combination of discriminantCombinations) {                 let hasMatch = false;                 outer:                 for (const type of target.types) {                     for (let i = 0; i < sourcePropertiesFiltered.length; i++) {                         const sourceProperty = sourcePropertiesFiltered[i];                         const targetProperty = getPropertyOfType(type, sourceProperty.escapedName);                         if (!targetProperty) continue outer;                         if (sourceProperty === targetProperty) continue;                         // We compare the source property to the target in the context of a single discriminant type.                         const related = propertyRelatedTo(source, target, sourceProperty, targetProperty, _ => combination[i], /*reportErrors* / false, IntersectionState.None, /*skipOptional* / strictNullChecks || relation === comparableRelation);                         // If the target property could not be found, or if the properties were not related,                         // then this constituent is not a match.                         if (!related) {                             continue outer;                         }                     }                     pushIfUnique(matchingTypes, type, equateValues);                     hasMatch = true;                 }                 if (!hasMatch) {                     // We failed to match any type for this combination.                     return Ternary.False;                 }             } */
            result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            /* TODO(ForOfStatement): for (const type of matchingTypes) {                 result &= propertiesRelatedTo(source, type, /*reportErrors* / false, excludedProperties, /*optionalsOnly* / false, IntersectionState.None);                 if (result) {                     result &= signaturesRelatedTo(source, type, SignatureKind.Call, /*reportErrors* / false, IntersectionState.None);                     if (result) {                         result &= signaturesRelatedTo(source, type, SignatureKind.Construct, /*reportErrors* / false, IntersectionState.None);                         if (result && !(isTupleType(source) && isTupleType(type))) {                             // Comparing numeric index types when both `source` and `type` are tuples is unnecessary as the                             // element types should be sufficiently covered by `propertiesRelatedTo`. It also causes problems                             // with index type assignability as the types for the excluded discriminants are still included                             // in the index type.                             result &= indexSignaturesRelatedTo(source, type, /*sourceIsPrimitive* / false, /*reportErrors* / false, IntersectionState.None);                         }                     }                 }                 if (!result) {                     return result;                 }             } */
             result
        }
        excludeProperties := func(properties []Symbol, excludedProperties *Set[__String]) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
            if /* TODO(BinaryExpression): !excludedProperties || properties.length === 0 */ TODO {
                /* TODO(Identifier): properties */
            }
            var result /* TODO(ArrayType): Symbol[] */ any
            /* TODO(ForStatement): for (let i = 0; i < properties.length; i++) {                 if (!excludedProperties.has(properties[i].escapedName)) {                     if (result) {                         result.push(properties[i]);                     }                 }                 else if (!result) {                     result = properties.slice(0, i);                 }             } */
             /* TODO(BinaryExpression): result || properties */ TODO
        }
        isPropertySymbolTypeRelated := func(sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState) Ternary {
            targetIsOptional := /* TODO(BinaryExpression): strictNullChecks && !!(getCheckFlags(targetProp) & CheckFlags.Partial) */ TODO
            effectiveTarget := addOptionality(getNonMissingTypeOfSymbol(targetProp), /* TODO(FalseKeyword): false */ TODO, targetIsOptional)
            effectiveSource := getTypeOfSourceProperty(sourceProp)
             isRelatedTo(effectiveSource, effectiveTarget, /* TODO(PropertyAccessExpression): RecursionFlags.Both */ TODO, reportErrors, undefined, intersectionState)
        }
        propertyRelatedTo := func(source Type, target Type, sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState, skipOptional bool) Ternary {
            sourcePropFlags := getDeclarationModifierFlagsFromSymbol(sourceProp)
            targetPropFlags := getDeclarationModifierFlagsFromSymbol(targetProp)
            if /* TODO(BinaryExpression): sourcePropFlags & ModifierFlags.Private || targetPropFlags & ModifierFlags.Private */ TODO {
                if /* TODO(BinaryExpression): sourceProp.valueDeclaration !== targetProp.valueDeclaration */ TODO {
                    if reportErrors {
                        if /* TODO(BinaryExpression): sourcePropFlags & ModifierFlags.Private && targetPropFlags & ModifierFlags.Private */ TODO {
                            /* TODO(ExpressionStatement): reportError(Diagnostics.Types_have_separate_declarations_of_a_private_property_0, symbolToString(targetProp)); */
                        } else {
                            /* TODO(ExpressionStatement): reportError(Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, symbolToString(targetProp), typeToString(sourcePropFlags & ModifierFlags.Private ? source : target), typeToString(sourcePropFlags & ModifierFlags.Private ? target : source)); */
                        }
                    }
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
            } else if /* TODO(BinaryExpression): targetPropFlags & ModifierFlags.Protected */ TODO {
                if /* TODO(PrefixUnaryExpression): !isValidOverrideOf(sourceProp, targetProp) */ TODO {
                    if reportErrors {
                        /* TODO(ExpressionStatement): reportError(Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, symbolToString(targetProp), typeToString(getDeclaringClass(sourceProp) || source), typeToString(getDeclaringClass(targetProp) || target)); */
                    }
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
            } else if /* TODO(BinaryExpression): sourcePropFlags & ModifierFlags.Protected */ TODO {
                if reportErrors {
                    /* TODO(ExpressionStatement): reportError(Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target)); */
                }
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
            if /* TODO(BinaryExpression): relation === strictSubtypeRelation &&                 isReadonlySymbol(sourceProp) && !isReadonlySymbol(targetProp) */ TODO {
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
            related := isPropertySymbolTypeRelated(sourceProp, targetProp, getTypeOfSourceProperty, reportErrors, intersectionState)
            if /* TODO(PrefixUnaryExpression): !related */ TODO {
                if reportErrors {
                    /* TODO(ExpressionStatement): reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(targetProp)); */
                }
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
            if /* TODO(BinaryExpression): !skipOptional && sourceProp.flags & SymbolFlags.Optional && targetProp.flags & SymbolFlags.ClassMember && !(targetProp.flags & SymbolFlags.Optional) */ TODO {
                if reportErrors {
                    /* TODO(ExpressionStatement): reportError(Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target)); */
                }
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
             related
        }
        reportUnmatchedProperty := func(source Type, target Type, unmatchedProperty Symbol, requireOptionalProperties bool) {
            shouldSkipElaboration := /* TODO(FalseKeyword): false */ TODO
            if /* TODO(BinaryExpression): unmatchedProperty.valueDeclaration                 && isNamedDeclaration(unmatchedProperty.valueDeclaration)                 && isPrivateIdentifier(unmatchedProperty.valueDeclaration.name)                 && source.symbol                 && source.symbol.flags & SymbolFlags.Class */ TODO {
                privateIdentifierDescription := /* TODO(PropertyAccessExpression): unmatchedProperty.valueDeclaration.name.escapedText */ TODO
                symbolTableKey := getSymbolNameForPrivateIdentifier(/* TODO(PropertyAccessExpression): source.symbol */ TODO, privateIdentifierDescription)
                if /* TODO(BinaryExpression): symbolTableKey && getPropertyOfType(source, symbolTableKey) */ TODO {
                    sourceName := /* TODO(PropertyAccessExpression): factory.getDeclarationName */ TODO(/* TODO(PropertyAccessExpression): source.symbol.valueDeclaration */ TODO)
                    targetName := /* TODO(PropertyAccessExpression): factory.getDeclarationName */ TODO(/* TODO(PropertyAccessExpression): target.symbol.valueDeclaration */ TODO)
                    /* TODO(ExpressionStatement): reportError(                         Diagnostics.Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2,                         diagnosticName(privateIdentifierDescription),                         diagnosticName(sourceName.escapedText === "" ? anon : sourceName),                         diagnosticName(targetName.escapedText === "" ? anon : targetName),                     ); */

                }
            }
            props := arrayFrom(getUnmatchedProperties(source, target, requireOptionalProperties, /* TODO(FalseKeyword): false */ TODO))
            if /* TODO(BinaryExpression): !headMessage || (headMessage.code !== Diagnostics.Class_0_incorrectly_implements_interface_1.code &&                     headMessage.code !== Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass.code) */ TODO {
                /* TODO(ExpressionStatement): shouldSkipElaboration = true; */
            }
            if /* TODO(BinaryExpression): props.length === 1 */ TODO {
                propName := symbolToString(unmatchedProperty, undefined, /* TODO(PropertyAccessExpression): SymbolFlags.None */ TODO, /* TODO(BinaryExpression): SymbolFormatFlags.AllowAnyNodeKind | SymbolFormatFlags.WriteComputedProps */ TODO)
                /* TODO(ExpressionStatement): reportError(Diagnostics.Property_0_is_missing_in_type_1_but_required_in_type_2, propName, ...getTypeNamesForErrorDisplay(source, target)); */
                if length(/* TODO(PropertyAccessExpression): unmatchedProperty.declarations */ TODO) {
                    /* TODO(ExpressionStatement): associateRelatedInfo(createDiagnosticForNode(unmatchedProperty.declarations![0], Diagnostics._0_is_declared_here, propName)); */
                }
                if /* TODO(BinaryExpression): shouldSkipElaboration && errorInfo */ TODO {
                    /* TODO(ExpressionStatement): overrideNextErrorInfo++; */
                }
            } else if tryElaborateArrayLikeErrors(source, target, /* TODO(FalseKeyword): false */ TODO) {
                if /* TODO(BinaryExpression): props.length > 5 */ TODO {
                    /* TODO(ExpressionStatement): reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more, typeToString(source), typeToString(target), map(props.slice(0, 4), p => symbolToString(p)).join(", "), props.length - 4); */
                } else {
                    /* TODO(ExpressionStatement): reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2, typeToString(source), typeToString(target), map(props, p => symbolToString(p)).join(", ")); */
                }
                if /* TODO(BinaryExpression): shouldSkipElaboration && errorInfo */ TODO {
                    /* TODO(ExpressionStatement): overrideNextErrorInfo++; */
                }
            }
        }
        propertiesRelatedTo := func(source Type, target Type, reportErrors bool, excludedProperties *Set[__String], optionalsOnly bool, intersectionState IntersectionState) Ternary {
            if /* TODO(BinaryExpression): relation === identityRelation */ TODO {
                 propertiesIdenticalTo(source, target, excludedProperties)
            }
            result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            if isTupleType(target) {
                if isArrayOrTupleType(source) {
                    if /* TODO(BinaryExpression): !target.target.readonly && (isReadonlyArrayType(source) || isTupleType(source) && source.target.readonly) */ TODO {
                         /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                    }
                    sourceArity := getTypeReferenceArity(source)
                    targetArity := getTypeReferenceArity(target)
                    sourceRestFlag := /* TODO(ConditionalExpression): isTupleType(source) ? source.target.combinedFlags & ElementFlags.Rest : ElementFlags.Rest */ TODO
                    targetHasRestElement := /* TODO(PrefixUnaryExpression): !!(target.target.combinedFlags & ElementFlags.Variable) */ TODO
                    sourceMinLength := /* TODO(ConditionalExpression): isTupleType(source) ? source.target.minLength : 0 */ TODO
                    targetMinLength := /* TODO(PropertyAccessExpression): target.target.minLength */ TODO
                    if /* TODO(BinaryExpression): !sourceRestFlag && sourceArity < targetMinLength */ TODO {
                        if reportErrors {
                            /* TODO(ExpressionStatement): reportError(Diagnostics.Source_has_0_element_s_but_target_requires_1, sourceArity, targetMinLength); */
                        }
                         /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                    }
                    if /* TODO(BinaryExpression): !targetHasRestElement && targetArity < sourceMinLength */ TODO {
                        if reportErrors {
                            /* TODO(ExpressionStatement): reportError(Diagnostics.Source_has_0_element_s_but_target_allows_only_1, sourceMinLength, targetArity); */
                        }
                         /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                    }
                    if /* TODO(BinaryExpression): !targetHasRestElement && (sourceRestFlag || targetArity < sourceArity) */ TODO {
                        if reportErrors {
                            if /* TODO(BinaryExpression): sourceMinLength < targetMinLength */ TODO {
                                /* TODO(ExpressionStatement): reportError(Diagnostics.Target_requires_0_element_s_but_source_may_have_fewer, targetMinLength); */
                            } else {
                                /* TODO(ExpressionStatement): reportError(Diagnostics.Target_allows_only_0_element_s_but_source_may_have_more, targetArity); */
                            }
                        }
                         /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                    }
                    sourceTypeArguments := getTypeArguments(source)
                    targetTypeArguments := getTypeArguments(target)
                    targetStartCount := getStartElementCount(/* TODO(PropertyAccessExpression): target.target */ TODO, /* TODO(PropertyAccessExpression): ElementFlags.NonRest */ TODO)
                    targetEndCount := getEndElementCount(/* TODO(PropertyAccessExpression): target.target */ TODO, /* TODO(PropertyAccessExpression): ElementFlags.NonRest */ TODO)
                    canExcludeDiscriminants := /* TODO(PrefixUnaryExpression): !!excludedProperties */ TODO
                    /* TODO(ForStatement): for (let sourcePosition = 0; sourcePosition < sourceArity; sourcePosition++) {                         const sourceFlags = isTupleType(source) ? source.target.elementFlags[sourcePosition] : ElementFlags.Rest;                         const sourcePositionFromEnd = sourceArity - 1 - sourcePosition;                          const targetPosition = targetHasRestElement && sourcePosition >= targetStartCount                             ? targetArity - 1 - Math.min(sourcePositionFromEnd, targetEndCount)                             : sourcePosition;                          const targetFlags = target.target.elementFlags[targetPosition];                          if (targetFlags & ElementFlags.Variadic && !(sourceFlags & ElementFlags.Variadic)) {                             if (reportErrors) {                                 reportError(Diagnostics.Source_provides_no_match_for_variadic_element_at_position_0_in_target, targetPosition);                             }                             return Ternary.False;                         }                         if (sourceFlags & ElementFlags.Variadic && !(targetFlags & ElementFlags.Variable)) {                             if (reportErrors) {                                 reportError(Diagnostics.Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target, sourcePosition, targetPosition);                             }                             return Ternary.False;                         }                         if (targetFlags & ElementFlags.Required && !(sourceFlags & ElementFlags.Required)) {                             if (reportErrors) {                                 reportError(Diagnostics.Source_provides_no_match_for_required_element_at_position_0_in_target, targetPosition);                             }                             return Ternary.False;                         }                         // We can only exclude discriminant properties if we have not yet encountered a variable-length element.                         if (canExcludeDiscriminants) {                             if (sourceFlags & ElementFlags.Variable || targetFlags & ElementFlags.Variable) {                                 canExcludeDiscriminants = false;                             }                             if (canExcludeDiscriminants && excludedProperties?.has(("" + sourcePosition) as __String)) {                                 continue;                             }                         }                          const sourceType = removeMissingType(sourceTypeArguments[sourcePosition], !!(sourceFlags & targetFlags & ElementFlags.Optional));                         const targetType = targetTypeArguments[targetPosition];                          const targetCheckType = sourceFlags & ElementFlags.Variadic && targetFlags & ElementFlags.Rest ? createArrayType(targetType) :                             removeMissingType(targetType, !!(targetFlags & ElementFlags.Optional));                         const related = isRelatedTo(sourceType, targetCheckType, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         if (!related) {                             if (reportErrors && (targetArity > 1 || sourceArity > 1)) {                                 if (targetHasRestElement && sourcePosition >= targetStartCount && sourcePositionFromEnd >= targetEndCount && targetStartCount !== sourceArity - targetEndCount - 1) {                                     reportIncompatibleError(Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, targetStartCount, sourceArity - targetEndCount - 1, targetPosition);                                 }                                 else {                                     reportIncompatibleError(Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, sourcePosition, targetPosition);                                 }                             }                             return Ternary.False;                         }                         result &= related;                     } */
                     result
                }
                if /* TODO(BinaryExpression): target.target.combinedFlags & ElementFlags.Variable */ TODO {
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
            }
            requireOptionalProperties := /* TODO(BinaryExpression): (relation === subtypeRelation || relation === strictSubtypeRelation) && !isObjectLiteralType(source) && !isEmptyArrayLiteralType(source) && !isTupleType(source) */ TODO
            unmatchedProperty := getUnmatchedProperty(source, target, requireOptionalProperties, /* TODO(FalseKeyword): false */ TODO)
            if unmatchedProperty {
                if /* TODO(BinaryExpression): reportErrors && shouldReportUnmatchedPropertyError(source, target) */ TODO {
                    /* TODO(ExpressionStatement): reportUnmatchedProperty(source, target, unmatchedProperty, requireOptionalProperties); */
                }
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
            if isObjectLiteralType(target) {
                /* TODO(ForOfStatement): for (const sourceProp of excludeProperties(getPropertiesOfType(source), excludedProperties)) {                     if (!getPropertyOfObjectType(target, sourceProp.escapedName)) {                         const sourceType = getTypeOfSymbol(sourceProp);                         if (!(sourceType.flags & TypeFlags.Undefined)) {                             if (reportErrors) {                                 reportError(Diagnostics.Property_0_does_not_exist_on_type_1, symbolToString(sourceProp), typeToString(target));                             }                             return Ternary.False;                         }                     }                 } */
            }
            properties := getPropertiesOfType(target)
            numericNamesOnly := /* TODO(BinaryExpression): isTupleType(source) && isTupleType(target) */ TODO
            /* TODO(ForOfStatement): for (const targetProp of excludeProperties(properties, excludedProperties)) {                 const name = targetProp.escapedName;                 if (!(targetProp.flags & SymbolFlags.Prototype) && (!numericNamesOnly || isNumericLiteralName(name) || name === "length") && (!optionalsOnly || targetProp.flags & SymbolFlags.Optional)) {                     const sourceProp = getPropertyOfType(source, name);                     if (sourceProp && sourceProp !== targetProp) {                         const related = propertyRelatedTo(source, target, sourceProp, targetProp, getNonMissingTypeOfSymbol, reportErrors, intersectionState, relation === comparableRelation);                         if (!related) {                             return Ternary.False;                         }                         result &= related;                     }                 }             } */
             result
        }
        propertiesIdenticalTo := func(source Type, target Type, excludedProperties *Set[__String]) Ternary {
            if /* TODO(PrefixUnaryExpression): !(source.flags & TypeFlags.Object && target.flags & TypeFlags.Object) */ TODO {
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
            sourceProperties := excludeProperties(getPropertiesOfObjectType(source), excludedProperties)
            targetProperties := excludeProperties(getPropertiesOfObjectType(target), excludedProperties)
            if /* TODO(BinaryExpression): sourceProperties.length !== targetProperties.length */ TODO {
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
            result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            /* TODO(ForOfStatement): for (const sourceProp of sourceProperties) {                 const targetProp = getPropertyOfObjectType(target, sourceProp.escapedName);                 if (!targetProp) {                     return Ternary.False;                 }                 const related = compareProperties(sourceProp, targetProp, isRelatedTo);                 if (!related) {                     return Ternary.False;                 }                 result &= related;             } */
             result
        }
        signaturesRelatedTo := func(source Type, target Type, kind SignatureKind, reportErrors bool, intersectionState IntersectionState) Ternary {
            if /* TODO(BinaryExpression): relation === identityRelation */ TODO {
                 signaturesIdenticalTo(source, target, kind)
            }
            if /* TODO(BinaryExpression): target === anyFunctionType || source === anyFunctionType */ TODO {
                 /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            }
            sourceIsJSConstructor := /* TODO(BinaryExpression): source.symbol && isJSConstructor(source.symbol.valueDeclaration) */ TODO
            targetIsJSConstructor := /* TODO(BinaryExpression): target.symbol && isJSConstructor(target.symbol.valueDeclaration) */ TODO
            sourceSignatures := getSignaturesOfType(source, /* TODO(ConditionalExpression): (sourceIsJSConstructor && kind === SignatureKind.Construct) ?                     SignatureKind.Call : kind */ TODO)
            targetSignatures := getSignaturesOfType(target, /* TODO(ConditionalExpression): (targetIsJSConstructor && kind === SignatureKind.Construct) ?                     SignatureKind.Call : kind */ TODO)
            if /* TODO(BinaryExpression): kind === SignatureKind.Construct && sourceSignatures.length && targetSignatures.length */ TODO {
                sourceIsAbstract := /* TODO(PrefixUnaryExpression): !!(sourceSignatures[0].flags & SignatureFlags.Abstract) */ TODO
                targetIsAbstract := /* TODO(PrefixUnaryExpression): !!(targetSignatures[0].flags & SignatureFlags.Abstract) */ TODO
                if /* TODO(BinaryExpression): sourceIsAbstract && !targetIsAbstract */ TODO {
                    if reportErrors {
                        /* TODO(ExpressionStatement): reportError(Diagnostics.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type); */
                    }
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
                if /* TODO(PrefixUnaryExpression): !constructorVisibilitiesAreCompatible(sourceSignatures[0], targetSignatures[0], reportErrors) */ TODO {
                     /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                }
            }
            result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            incompatibleReporter := /* TODO(ConditionalExpression): kind === SignatureKind.Construct ? reportIncompatibleConstructSignatureReturn : reportIncompatibleCallSignatureReturn */ TODO
            sourceObjectFlags := getObjectFlags(source)
            targetObjectFlags := getObjectFlags(target)
            if /* TODO(BinaryExpression): sourceObjectFlags & ObjectFlags.Instantiated && targetObjectFlags & ObjectFlags.Instantiated && source.symbol === target.symbol ||                 sourceObjectFlags & ObjectFlags.Reference && targetObjectFlags & ObjectFlags.Reference && (source as TypeReference).target === (target as TypeReference).target */ TODO {
                /* TODO(ExpressionStatement): Debug.assertEqual(sourceSignatures.length, targetSignatures.length); */
                /* TODO(ForStatement): for (let i = 0; i < targetSignatures.length; i++) {                     const related = signatureRelatedTo(sourceSignatures[i], targetSignatures[i], /*erase* / true, reportErrors, intersectionState, incompatibleReporter(sourceSignatures[i], targetSignatures[i]));                     if (!related) {                         return Ternary.False;                     }                     result &= related;                 } */
            } else if /* TODO(BinaryExpression): sourceSignatures.length === 1 && targetSignatures.length === 1 */ TODO {
                eraseGenerics := /* TODO(BinaryExpression): relation === comparableRelation */ TODO
                sourceSignature := first(sourceSignatures)
                targetSignature := first(targetSignatures)
                /* TODO(ExpressionStatement): result = signatureRelatedTo(sourceSignature, targetSignature, eraseGenerics, reportErrors, intersectionState, incompatibleReporter(sourceSignature, targetSignature)); */
                if /* TODO(BinaryExpression): !result && reportErrors && kind === SignatureKind.Construct && (sourceObjectFlags & targetObjectFlags) &&                     (targetSignature.declaration?.kind === SyntaxKind.Constructor || sourceSignature.declaration?.kind === SyntaxKind.Constructor) */ TODO {
                    constructSignatureToString := /* TODO(ArrowFunction): (signature: Signature) => signatureToString(signature, /*enclosingDeclaration* / undefined, TypeFormatFlags.WriteArrowStyleSignature, kind) */ TODO
                    /* TODO(ExpressionStatement): reportError(Diagnostics.Type_0_is_not_assignable_to_type_1, constructSignatureToString(sourceSignature), constructSignatureToString(targetSignature)); */
                    /* TODO(ExpressionStatement): reportError(Diagnostics.Types_of_construct_signatures_are_incompatible); */
                     result
                }
            } else {
                /* TODO(LabeledStatement): outer:                 for (const t of targetSignatures) {                     const saveErrorInfo = captureErrorCalculationState();                     // Only elaborate errors from the first failure                     let shouldElaborateErrors = reportErrors;                     for (const s of sourceSignatures) {                         const related = signatureRelatedTo(s, t, /*erase* / true, shouldElaborateErrors, intersectionState, incompatibleReporter(s, t));                         if (related) {                             result &= related;                             resetErrorInfo(saveErrorInfo);                             continue outer;                         }                         shouldElaborateErrors = false;                     }                     if (shouldElaborateErrors) {                         reportError(Diagnostics.Type_0_provides_no_match_for_the_signature_1, typeToString(source), signatureToString(t, /*enclosingDeclaration* / undefined, /*flags* / undefined, kind));                     }                     return Ternary.False;                 } */
            }
             result
        }
        shouldReportUnmatchedPropertyError := func(source Type, target Type) bool {
            typeCallSignatures := getSignaturesOfStructuredType(source, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
            typeConstructSignatures := getSignaturesOfStructuredType(source, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO)
            typeProperties := getPropertiesOfObjectType(source)
            if /* TODO(BinaryExpression): (typeCallSignatures.length || typeConstructSignatures.length) && !typeProperties.length */ TODO {
                if /* TODO(BinaryExpression): (getSignaturesOfType(target, SignatureKind.Call).length && typeCallSignatures.length) ||                     (getSignaturesOfType(target, SignatureKind.Construct).length && typeConstructSignatures.length) */ TODO {
                     /* TODO(TrueKeyword): true */ TODO
                }
                 /* TODO(FalseKeyword): false */ TODO
            }
             /* TODO(TrueKeyword): true */ TODO
        }
        reportIncompatibleCallSignatureReturn := func(siga Signature, sigb Signature) /* TODO(undefined): (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => void */ TODO {
            if /* TODO(BinaryExpression): siga.parameters.length === 0 && sigb.parameters.length === 0 */ TODO {
                 /* TODO(ArrowFunction): (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target)) */ TODO
            }
             /* TODO(ArrowFunction): (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Call_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target)) */ TODO
        }
        reportIncompatibleConstructSignatureReturn := func(siga Signature, sigb Signature) /* TODO(undefined): (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => void */ TODO {
            if /* TODO(BinaryExpression): siga.parameters.length === 0 && sigb.parameters.length === 0 */ TODO {
                 /* TODO(ArrowFunction): (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target)) */ TODO
            }
             /* TODO(ArrowFunction): (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target)) */ TODO
        }
        signatureRelatedTo := func(source Signature, target Signature, erase bool, reportErrors bool, intersectionState IntersectionState, incompatibleReporter func(source Type, target Type) ) Ternary {
            checkMode := /* TODO(ConditionalExpression): relation === subtypeRelation ? SignatureCheckMode.StrictTopSignature :                 relation === strictSubtypeRelation ? SignatureCheckMode.StrictTopSignature | SignatureCheckMode.StrictArity :                 SignatureCheckMode.None */ TODO
             compareSignaturesRelated(/* TODO(ConditionalExpression): erase ? getErasedSignature(source) : source */ TODO, /* TODO(ConditionalExpression): erase ? getErasedSignature(target) : target */ TODO, checkMode, reportErrors, reportError, incompatibleReporter, isRelatedToWorker, reportUnreliableMapper)
            isRelatedToWorker := func(source Type, target Type, reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
                 isRelatedTo(source, target, /* TODO(PropertyAccessExpression): RecursionFlags.Both */ TODO, reportErrors, undefined, intersectionState)
            }
        }
        signaturesIdenticalTo := func(source Type, target Type, kind SignatureKind) Ternary {
            sourceSignatures := getSignaturesOfType(source, kind)
            targetSignatures := getSignaturesOfType(target, kind)
            if /* TODO(BinaryExpression): sourceSignatures.length !== targetSignatures.length */ TODO {
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
            result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            /* TODO(ForStatement): for (let i = 0; i < sourceSignatures.length; i++) {                 const related = compareSignaturesIdentical(sourceSignatures[i], targetSignatures[i], /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / false, isRelatedTo);                 if (!related) {                     return Ternary.False;                 }                 result &= related;             } */
             result
        }
        membersRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
            result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            keyType := /* TODO(PropertyAccessExpression): targetInfo.keyType */ TODO
            props := /* TODO(ConditionalExpression): source.flags & TypeFlags.Intersection ? getPropertiesOfUnionOrIntersectionType(source as IntersectionType) : getPropertiesOfObjectType(source) */ TODO
            /* TODO(ForOfStatement): for (const prop of props) {                 // Skip over ignored JSX and symbol-named members                 if (isIgnoredJsxProperty(source, prop)) {                     continue;                 }                 if (isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique), keyType)) {                     const propType = getNonMissingTypeOfSymbol(prop);                     const type = exactOptionalPropertyTypes || propType.flags & TypeFlags.Undefined || keyType === numberType || !(prop.flags & SymbolFlags.Optional)                         ? propType                         : getTypeWithFacts(propType, TypeFacts.NEUndefined);                     const related = isRelatedTo(type, targetInfo.type, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                     if (!related) {                         if (reportErrors) {                             reportError(Diagnostics.Property_0_is_incompatible_with_index_signature, symbolToString(prop));                         }                         return Ternary.False;                     }                     result &= related;                 }             } */
            /* TODO(ForOfStatement): for (const info of getIndexInfosOfType(source)) {                 if (isApplicableIndexType(info.keyType, keyType)) {                     const related = indexInfoRelatedTo(info, targetInfo, reportErrors, intersectionState);                     if (!related) {                         return Ternary.False;                     }                     result &= related;                 }             } */
             result
        }
        indexInfoRelatedTo := func(sourceInfo IndexInfo, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
            related := isRelatedTo(/* TODO(PropertyAccessExpression): sourceInfo.type */ TODO, /* TODO(PropertyAccessExpression): targetInfo.type */ TODO, /* TODO(PropertyAccessExpression): RecursionFlags.Both */ TODO, reportErrors, undefined, intersectionState)
            if /* TODO(BinaryExpression): !related && reportErrors */ TODO {
                if /* TODO(BinaryExpression): sourceInfo.keyType === targetInfo.keyType */ TODO {
                    /* TODO(ExpressionStatement): reportError(Diagnostics._0_index_signatures_are_incompatible, typeToString(sourceInfo.keyType)); */
                } else {
                    /* TODO(ExpressionStatement): reportError(Diagnostics._0_and_1_index_signatures_are_incompatible, typeToString(sourceInfo.keyType), typeToString(targetInfo.keyType)); */
                }
            }
             related
        }
        indexSignaturesRelatedTo := func(source Type, target Type, sourceIsPrimitive bool, reportErrors bool, intersectionState IntersectionState) Ternary {
            if /* TODO(BinaryExpression): relation === identityRelation */ TODO {
                 indexSignaturesIdenticalTo(source, target)
            }
            indexInfos := getIndexInfosOfType(target)
            targetHasStringIndex := some(indexInfos, /* TODO(ArrowFunction): info => info.keyType === stringType */ TODO)
            result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
            /* TODO(ForOfStatement): for (const targetInfo of indexInfos) {                 const related = relation !== strictSubtypeRelation && !sourceIsPrimitive && targetHasStringIndex && targetInfo.type.flags & TypeFlags.Any ? Ternary.True :                     isGenericMappedType(source) && targetHasStringIndex ? isRelatedTo(getTemplateTypeFromMappedType(source), targetInfo.type, RecursionFlags.Both, reportErrors) :                     typeRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState);                 if (!related) {                     return Ternary.False;                 }                 result &= related;             } */
             result
        }
        typeRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
            sourceInfo := getApplicableIndexInfo(source, /* TODO(PropertyAccessExpression): targetInfo.keyType */ TODO)
            if sourceInfo {
                 indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors, intersectionState)
            }
            if /* TODO(BinaryExpression): !(intersectionState & IntersectionState.Source) && (relation !== strictSubtypeRelation || getObjectFlags(source) & ObjectFlags.FreshLiteral) && isObjectTypeWithInferableIndex(source) */ TODO {
                 membersRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState)
            }
            if reportErrors {
                /* TODO(ExpressionStatement): reportError(Diagnostics.Index_signature_for_type_0_is_missing_in_type_1, typeToString(targetInfo.keyType), typeToString(source)); */
            }
             /* TODO(PropertyAccessExpression): Ternary.False */ TODO
        }
        indexSignaturesIdenticalTo := func(source Type, target Type) Ternary {
            sourceInfos := getIndexInfosOfType(source)
            targetInfos := getIndexInfosOfType(target)
            if /* TODO(BinaryExpression): sourceInfos.length !== targetInfos.length */ TODO {
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
            /* TODO(ForOfStatement): for (const targetInfo of targetInfos) {                 const sourceInfo = getIndexInfoOfType(source, targetInfo.keyType);                 if (!(sourceInfo && isRelatedTo(sourceInfo.type, targetInfo.type, RecursionFlags.Both) && sourceInfo.isReadonly === targetInfo.isReadonly)) {                     return Ternary.False;                 }             } */
             /* TODO(PropertyAccessExpression): Ternary.True */ TODO
        }
        constructorVisibilitiesAreCompatible := func(sourceSignature Signature, targetSignature Signature, reportErrors bool) /* TODO(undefined): boolean */ TODO {
            if /* TODO(BinaryExpression): !sourceSignature.declaration || !targetSignature.declaration */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            sourceAccessibility := getSelectedEffectiveModifierFlags(/* TODO(PropertyAccessExpression): sourceSignature.declaration */ TODO, /* TODO(PropertyAccessExpression): ModifierFlags.NonPublicAccessibilityModifier */ TODO)
            targetAccessibility := getSelectedEffectiveModifierFlags(/* TODO(PropertyAccessExpression): targetSignature.declaration */ TODO, /* TODO(PropertyAccessExpression): ModifierFlags.NonPublicAccessibilityModifier */ TODO)
            if /* TODO(BinaryExpression): targetAccessibility === ModifierFlags.Private */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            if /* TODO(BinaryExpression): targetAccessibility === ModifierFlags.Protected && sourceAccessibility !== ModifierFlags.Private */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            if /* TODO(BinaryExpression): targetAccessibility !== ModifierFlags.Protected && !sourceAccessibility */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            if reportErrors {
                /* TODO(ExpressionStatement): reportError(Diagnostics.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type, visibilityToString(sourceAccessibility), visibilityToString(targetAccessibility)); */
            }
             /* TODO(FalseKeyword): false */ TODO
        }
    }
    typeCouldHaveTopLevelSingletonTypes := func(type_ Type) bool {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Boolean */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.UnionOrIntersection */ TODO {
             /* TODO(PrefixUnaryExpression): !!forEach((type as IntersectionType).types, typeCouldHaveTopLevelSingletonTypes) */ TODO
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Instantiable */ TODO {
            constraint := getConstraintOfType(type_)
            if /* TODO(BinaryExpression): constraint && constraint !== type */ TODO {
                 typeCouldHaveTopLevelSingletonTypes(constraint)
            }
        }
         /* TODO(BinaryExpression): isUnitType(type) || !!(type.flags & TypeFlags.TemplateLiteral) || !!(type.flags & TypeFlags.StringMapping) */ TODO
    }
    getExactOptionalUnassignableProperties := func(source Type, target Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
        if /* TODO(BinaryExpression): isTupleType(source) && isTupleType(target) */ TODO {
            /* TODO(Identifier): emptyArray */
        }
         /* TODO(PropertyAccessExpression): getPropertiesOfType(target)             .filter */ TODO(/* TODO(ArrowFunction): targetProp => isExactOptionalPropertyMismatch(getTypeOfPropertyOfType(source, targetProp.escapedName), getTypeOfSymbol(targetProp)) */ TODO)
    }
    isExactOptionalPropertyMismatch := func(source *Type, target *Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !!source && !!target && maybeTypeOfKind(source, TypeFlags.Undefined) && !!containsMissingType(target) */ TODO
    }
    getExactOptionalProperties := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
         /* TODO(PropertyAccessExpression): getPropertiesOfType(type).filter */ TODO(/* TODO(ArrowFunction): targetProp => containsMissingType(getTypeOfSymbol(targetProp)) */ TODO)
    }
    getBestMatchingType := func(source Type, target UnionOrIntersectionType, isRelatedTo /* TODO(undefined): (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO /* = */ /* TODO(Identifier): compareTypesAssignable */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
         /* TODO(BinaryExpression): findMatchingDiscriminantType(source, target, isRelatedTo) ||             findMatchingTypeReferenceOrTypeAliasReference(source, target) ||             findBestTypeForObjectLiteral(source, target) ||             findBestTypeForInvokable(source, target) ||             findMostOverlappyType(source, target) */ TODO
    }
    discriminateTypeByDiscriminableItems := func(target UnionType, discriminators []/* TODO(TupleType): [() => Type, __String] */ TODO, related func(source Type, target Type) /* TODO(UnionType): boolean | Ternary */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        types := /* TODO(PropertyAccessExpression): target.types */ TODO
        var include []Ternary = /* TODO(PropertyAccessExpression): types.map */ TODO(/* TODO(ArrowFunction): t => t.flags & TypeFlags.Primitive ? Ternary.False : Ternary.True */ TODO)
        /* TODO(ForOfStatement): for (const [getDiscriminatingType, propertyName] of discriminators) {             // If the remaining target types include at least one with a matching discriminant, eliminate those that             // have non-matching discriminants. This ensures that we ignore erroneous discriminators and gradually             // refine the target set without eliminating every constituent (which would lead to `never`).             let matched = false;             for (let i = 0; i < types.length; i++) {                 if (include[i]) {                     const targetType = getTypeOfPropertyOrIndexSignatureOfType(types[i], propertyName);                     if (targetType && someType(getDiscriminatingType(), t => !!related(t, targetType))) {                         matched = true;                     }                     else {                         include[i] = Ternary.Maybe;                     }                 }             }             // Turn each Ternary.Maybe into Ternary.False if there was a match. Otherwise, revert to Ternary.True.             for (let i = 0; i < types.length; i++) {                 if (include[i] === Ternary.Maybe) {                     include[i] = matched ? Ternary.False : Ternary.True;                 }             }         } */
        filtered := /* TODO(ConditionalExpression): contains(include, Ternary.False) ? getUnionType(types.filter((_, i) => include[i]), UnionReduction.None) : target */ TODO
         /* TODO(ConditionalExpression): filtered.flags & TypeFlags.Never ? target : filtered */ TODO
    }
    isWeakType := func(type_ Type) bool {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
            resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
             /* TODO(BinaryExpression): resolved.callSignatures.length === 0 && resolved.constructSignatures.length === 0 && resolved.indexInfos.length === 0 &&                 resolved.properties.length > 0 && every(resolved.properties, p => !!(p.flags & SymbolFlags.Optional)) */ TODO
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Substitution */ TODO {
             isWeakType(/* TODO(PropertyAccessExpression): (type as SubstitutionType).baseType */ TODO)
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
             every(/* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, isWeakType)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    hasCommonProperties := func(source Type, target Type, isComparingJsxAttributes bool) /* TODO(undefined): boolean */ TODO {
        /* TODO(ForOfStatement): for (const prop of getPropertiesOfType(source)) {             if (isKnownProperty(target, prop.escapedName, isComparingJsxAttributes)) {                 return true;             }         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    getVariances := func(type_ GenericType) []VarianceFlags {
         /* TODO(ConditionalExpression): type === globalArrayType || type === globalReadonlyArrayType || type.objectFlags & ObjectFlags.Tuple ?             arrayVariances :             getVariancesWorker(type.symbol, type.typeParameters) */ TODO
    }
    getAliasVariances := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").VarianceFlags[] */ TODO {
         getVariancesWorker(symbol, /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).typeParameters */ TODO)
    }
    getVariancesWorker := func(symbol Symbol, typeParameters []TypeParameter /* = */ /* TODO(Identifier): emptyArray */) []VarianceFlags {
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.variances */ TODO {
            /* TODO(ExpressionStatement): tracing?.push(tracing.Phase.CheckTypes, "getVariancesWorker", { arity: typeParameters.length, id: getTypeId(getDeclaredTypeOfSymbol(symbol)) }); */
            oldVarianceComputation := inVarianceComputation
            saveResolutionStart := resolutionStart
            if /* TODO(PrefixUnaryExpression): !inVarianceComputation */ TODO {
                /* TODO(ExpressionStatement): inVarianceComputation = true; */
                /* TODO(ExpressionStatement): resolutionStart = resolutionTargets.length; */
            }
            /* TODO(ExpressionStatement): links.variances = emptyArray; */
            variances := /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(ForOfStatement): for (const tp of typeParameters) {                 const modifiers = getTypeParameterModifiers(tp);                 let variance = modifiers & ModifierFlags.Out ?                     modifiers & ModifierFlags.In ? VarianceFlags.Invariant : VarianceFlags.Covariant :                     modifiers & ModifierFlags.In ? VarianceFlags.Contravariant : undefined;                 if (variance === undefined) {                     let unmeasurable = false;                     let unreliable = false;                     const oldHandler = outofbandVarianceMarkerHandler;                     outofbandVarianceMarkerHandler = onlyUnreliable => onlyUnreliable ? unreliable = true : unmeasurable = true;                     // We first compare instantiations where the type parameter is replaced with                     // marker types that have a known subtype relationship. From this we can infer                     // invariance, covariance, contravariance or bivariance.                     const typeWithSuper = createMarkerType(symbol, tp, markerSuperType);                     const typeWithSub = createMarkerType(symbol, tp, markerSubType);                     variance = (isTypeAssignableTo(typeWithSub, typeWithSuper) ? VarianceFlags.Covariant : 0) |                         (isTypeAssignableTo(typeWithSuper, typeWithSub) ? VarianceFlags.Contravariant : 0);                     // If the instantiations appear to be related bivariantly it may be because the                     // type parameter is independent (i.e. it isn't witnessed anywhere in the generic                     // type). To determine this we compare instantiations where the type parameter is                     // replaced with marker types that are known to be unrelated.                     if (variance === VarianceFlags.Bivariant && isTypeAssignableTo(createMarkerType(symbol, tp, markerOtherType), typeWithSuper)) {                         variance = VarianceFlags.Independent;                     }                     outofbandVarianceMarkerHandler = oldHandler;                     if (unmeasurable || unreliable) {                         if (unmeasurable) {                             variance |= VarianceFlags.Unmeasurable;                         }                         if (unreliable) {                             variance |= VarianceFlags.Unreliable;                         }                     }                 }                 variances.push(variance);             } */
            if /* TODO(PrefixUnaryExpression): !oldVarianceComputation */ TODO {
                /* TODO(ExpressionStatement): inVarianceComputation = false; */
                /* TODO(ExpressionStatement): resolutionStart = saveResolutionStart; */
            }
            /* TODO(ExpressionStatement): links.variances = variances; */
            /* TODO(ExpressionStatement): tracing?.pop({ variances: variances.map(Debug.formatVariance) }); */
        }
         /* TODO(PropertyAccessExpression): links.variances */ TODO
    }
    createMarkerType := func(symbol Symbol, source TypeParameter, target Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        mapper := makeUnaryTypeMapper(source, target)
        type_ := getDeclaredTypeOfSymbol(symbol)
        if isErrorType(type_) {
             type_
        }
        result := /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.TypeAlias ?             getTypeAliasInstantiation(symbol, instantiateTypes(getSymbolLinks(symbol).typeParameters!, mapper)) :             createTypeReference(type as GenericType, instantiateTypes((type as GenericType).typeParameters, mapper)) */ TODO
        /* TODO(ExpressionStatement): markerTypes.add(getTypeId(result)); */
         result
    }
    isMarkerType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(PropertyAccessExpression): markerTypes.has */ TODO(getTypeId(type_))
    }
    getTypeParameterModifiers := func(tp TypeParameter) ModifierFlags {
         /* TODO(BinaryExpression): reduceLeft(tp.symbol?.declarations, (modifiers, d) => modifiers | getEffectiveModifierFlags(d), ModifierFlags.None) & (ModifierFlags.In | ModifierFlags.Out | ModifierFlags.Const) */ TODO
    }
    hasCovariantVoidArgument := func(typeArguments []Type, variances []VarianceFlags) bool {
        /* TODO(ForStatement): for (let i = 0; i < variances.length; i++) {             if ((variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Covariant && typeArguments[i].flags & TypeFlags.Void) {                 return true;             }         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    isUnconstrainedTypeParameter := func(type_ Type) /* TODO(undefined): boolean | 0 */ TODO {
         /* TODO(BinaryExpression): type.flags & TypeFlags.TypeParameter && !getConstraintOfTypeParameter(type as TypeParameter) */ TODO
    }
    isNonDeferredTypeReference := func(type_ Type) /* TODO(TypePredicate): type is TypeReference */ TODO {
         /* TODO(BinaryExpression): !!(getObjectFlags(type) & ObjectFlags.Reference) && !(type as TypeReference).node */ TODO
    }
    isTypeReferenceWithGenericArguments := func(type_ Type) bool {
         /* TODO(BinaryExpression): isNonDeferredTypeReference(type) && some(getTypeArguments(type), t => !!(t.flags & TypeFlags.TypeParameter) || isTypeReferenceWithGenericArguments(t)) */ TODO
    }
    getGenericTypeReferenceRelationKey := func(source TypeReference, target TypeReference, postFix string, ignoreConstraints bool) /* TODO(undefined): string */ TODO {
        var typeParameters []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        constraintMarker := ""
        sourceId := getTypeReferenceId(source, 0)
        targetId := getTypeReferenceId(target, 0)
         /* TODO(TemplateExpression): `${constraintMarker}${sourceId},${targetId}${postFix}` */ TODO
        getTypeReferenceId := func(type_ TypeReference, depth /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) /* TODO(undefined): string */ TODO {
            result := /* TODO(BinaryExpression): "" + type.target.id */ TODO
            /* TODO(ForOfStatement): for (const t of getTypeArguments(type)) {                 if (t.flags & TypeFlags.TypeParameter) {                     if (ignoreConstraints || isUnconstrainedTypeParameter(t)) {                         let index = typeParameters.indexOf(t);                         if (index < 0) {                             index = typeParameters.length;                             typeParameters.push(t);                         }                         result += "=" + index;                         continue;                     }                     // We mark type references that reference constrained type parameters such that we know to obtain                     // and look for a "broadest equivalent key" in the cache.                     constraintMarker = "*";                 }                 else if (depth < 4 && isTypeReferenceWithGenericArguments(t)) {                     result += "<" + getTypeReferenceId(t as TypeReference, depth + 1) + ">";                     continue;                 }                 result += "-" + t.id;             } */
             result
        }
    }
    getRelationKey := func(source Type, target Type, intersectionState IntersectionState, relation Map[string, RelationComparisonResult], ignoreConstraints bool) /* TODO(undefined): string */ TODO {
        if /* TODO(BinaryExpression): relation === identityRelation && source.id > target.id */ TODO {
            temp := source
            /* TODO(ExpressionStatement): source = target; */
            /* TODO(ExpressionStatement): target = temp; */
        }
        postFix := /* TODO(ConditionalExpression): intersectionState ? ":" + intersectionState : "" */ TODO
         /* TODO(ConditionalExpression): isTypeReferenceWithGenericArguments(source) && isTypeReferenceWithGenericArguments(target) ?             getGenericTypeReferenceRelationKey(source as TypeReference, target as TypeReference, postFix, ignoreConstraints) :             `${source.id},${target.id}${postFix}` */ TODO
    }
    forEachProperty := func(prop Symbol, callback func(p Symbol) T) *T {
        if /* TODO(BinaryExpression): getCheckFlags(prop) & CheckFlags.Synthetic */ TODO {
            /* TODO(ForOfStatement): for (const t of (prop as TransientSymbol).links.containingType!.types) {                 const p = getPropertyOfType(t, prop.escapedName);                 const result = p && forEachProperty(p, callback);                 if (result) {                     return result;                 }             } */
             undefined
        }
         callback(prop)
    }
    getDeclaringClass := func(prop Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceType | undefined */ TODO {
         /* TODO(ConditionalExpression): prop.parent && prop.parent.flags & SymbolFlags.Class ? getDeclaredTypeOfSymbol(getParentOfSymbol(prop)!) as InterfaceType : undefined */ TODO
    }
    getTypeOfPropertyInBaseClass := func(property Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        classType := getDeclaringClass(property)
        baseClassType := /* TODO(BinaryExpression): classType && getBaseTypes(classType)[0] */ TODO
         /* TODO(BinaryExpression): baseClassType && getTypeOfPropertyOfType(baseClassType, property.escapedName) */ TODO
    }
    isPropertyInClassDerivedFrom := func(prop Symbol, baseClass *Type) /* TODO(undefined): boolean | undefined */ TODO {
         forEachProperty(prop, /* TODO(ArrowFunction): sp => {             const sourceClass = getDeclaringClass(sp);             return sourceClass ? hasBaseType(sourceClass, baseClass) : false;         } */ TODO)
    }
    isValidOverrideOf := func(sourceProp Symbol, targetProp Symbol) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !forEachProperty(targetProp, tp =>             getDeclarationModifierFlagsFromSymbol(tp) & ModifierFlags.Protected ?                 !isPropertyInClassDerivedFrom(sourceProp, getDeclaringClass(tp)) : false) */ TODO
    }
    isClassDerivedFromDeclaringClasses := func(checkClass T, prop Symbol, writing bool) /* TODO(undefined): T | undefined */ TODO {
         /* TODO(ConditionalExpression): forEachProperty(prop, p =>                 getDeclarationModifierFlagsFromSymbol(p, writing) & ModifierFlags.Protected ?                     !hasBaseType(checkClass, getDeclaringClass(p)) : false) ? undefined : checkClass */ TODO
    }
    isDeeplyNestedType := func(type_ Type, stack []Type, depth number, maxDepth /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 3 */) bool {
        if /* TODO(BinaryExpression): depth >= maxDepth */ TODO {
            if /* TODO(BinaryExpression): (getObjectFlags(type) & ObjectFlags.InstantiatedMapped) === ObjectFlags.InstantiatedMapped */ TODO {
                /* TODO(ExpressionStatement): type = getMappedTargetWithSymbol(type); */
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
                 some(/* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, /* TODO(ArrowFunction): t => isDeeplyNestedType(t, stack, depth, maxDepth) */ TODO)
            }
            identity := getRecursionIdentity(type_)
            count := 0
            lastTypeId := 0
            /* TODO(ForStatement): for (let i = 0; i < depth; i++) {                 const t = stack[i];                 if (hasMatchingRecursionIdentity(t, identity)) {                     // We only count occurrences with a higher type id than the previous occurrence, since higher                     // type ids are an indicator of newer instantiations caused by recursion.                     if (t.id >= lastTypeId) {                         count++;                         if (count >= maxDepth) {                             return true;                         }                     }                     lastTypeId = t.id;                 }             } */
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    getMappedTargetWithSymbol := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        target
        /* TODO(WhileStatement): while (             (getObjectFlags(type) & ObjectFlags.InstantiatedMapped) === ObjectFlags.InstantiatedMapped &&             (target = getModifiersTypeFromMappedType(type as MappedType)) &&             (target.symbol || target.flags & TypeFlags.Intersection && some((target as IntersectionType).types, t => !!t.symbol))         ) {             type = target;         } */
         type_
    }
    hasMatchingRecursionIdentity := func(type_ Type, identity /* TODO(ObjectKeyword): object */ TODO) bool {
        if /* TODO(BinaryExpression): (getObjectFlags(type) & ObjectFlags.InstantiatedMapped) === ObjectFlags.InstantiatedMapped */ TODO {
            /* TODO(ExpressionStatement): type = getMappedTargetWithSymbol(type); */
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
             some(/* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, /* TODO(ArrowFunction): t => hasMatchingRecursionIdentity(t, identity) */ TODO)
        }
         /* TODO(BinaryExpression): getRecursionIdentity(type) === identity */ TODO
    }
    getRecursionIdentity := func(type_ Type) /* TODO(ObjectKeyword): object */ TODO {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Object && !isObjectOrArrayLiteralType(type) */ TODO {
            if /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference).node */ TODO {
                 /* TODO(NonNullExpression): (type as TypeReference).node! */ TODO
            }
            if /* TODO(BinaryExpression): type.symbol && !(getObjectFlags(type) & ObjectFlags.Anonymous && type.symbol.flags & SymbolFlags.Class) */ TODO {
                 /* TODO(PropertyAccessExpression): type.symbol */ TODO
            }
            if isTupleType(type_) {
                 /* TODO(PropertyAccessExpression): type.target */ TODO
            }
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.TypeParameter */ TODO {
             /* TODO(PropertyAccessExpression): type.symbol */ TODO
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.IndexedAccess */ TODO {
            /* TODO(DoStatement): do {                 type = (type as IndexedAccessType).objectType;             }             while (type.flags & TypeFlags.IndexedAccess); */
             type_
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Conditional */ TODO {
             /* TODO(PropertyAccessExpression): (type as ConditionalType).root */ TODO
        }
         type_
    }
    isPropertyIdenticalTo := func(sourceProp Symbol, targetProp Symbol) bool {
         /* TODO(BinaryExpression): compareProperties(sourceProp, targetProp, compareTypesIdentical) !== Ternary.False */ TODO
    }
    compareProperties := func(sourceProp Symbol, targetProp Symbol, compareTypes func(source Type, target Type) Ternary) Ternary {
        if /* TODO(BinaryExpression): sourceProp === targetProp */ TODO {
             /* TODO(PropertyAccessExpression): Ternary.True */ TODO
        }
        sourcePropAccessibility := /* TODO(BinaryExpression): getDeclarationModifierFlagsFromSymbol(sourceProp) & ModifierFlags.NonPublicAccessibilityModifier */ TODO
        targetPropAccessibility := /* TODO(BinaryExpression): getDeclarationModifierFlagsFromSymbol(targetProp) & ModifierFlags.NonPublicAccessibilityModifier */ TODO
        if /* TODO(BinaryExpression): sourcePropAccessibility !== targetPropAccessibility */ TODO {
             /* TODO(PropertyAccessExpression): Ternary.False */ TODO
        }
        if sourcePropAccessibility {
            if /* TODO(BinaryExpression): getTargetSymbol(sourceProp) !== getTargetSymbol(targetProp) */ TODO {
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
        } else {
            if /* TODO(BinaryExpression): (sourceProp.flags & SymbolFlags.Optional) !== (targetProp.flags & SymbolFlags.Optional) */ TODO {
                 /* TODO(PropertyAccessExpression): Ternary.False */ TODO
            }
        }
        if /* TODO(BinaryExpression): isReadonlySymbol(sourceProp) !== isReadonlySymbol(targetProp) */ TODO {
             /* TODO(PropertyAccessExpression): Ternary.False */ TODO
        }
         compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp))
    }
    isMatchingSignature := func(source Signature, target Signature, partialMatch bool) /* TODO(undefined): boolean */ TODO {
        sourceParameterCount := getParameterCount(source)
        targetParameterCount := getParameterCount(target)
        sourceMinArgumentCount := getMinArgumentCount(source)
        targetMinArgumentCount := getMinArgumentCount(target)
        sourceHasRestParameter := hasEffectiveRestParameter(source)
        targetHasRestParameter := hasEffectiveRestParameter(target)
        if /* TODO(BinaryExpression): sourceParameterCount === targetParameterCount &&             sourceMinArgumentCount === targetMinArgumentCount &&             sourceHasRestParameter === targetHasRestParameter */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): partialMatch && sourceMinArgumentCount <= targetMinArgumentCount */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    compareSignaturesIdentical := func(source Signature, target Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool, compareTypes func(s Type, t Type) Ternary) Ternary {
        if /* TODO(BinaryExpression): source === target */ TODO {
             /* TODO(PropertyAccessExpression): Ternary.True */ TODO
        }
        if /* TODO(PrefixUnaryExpression): !(isMatchingSignature(source, target, partialMatch)) */ TODO {
             /* TODO(PropertyAccessExpression): Ternary.False */ TODO
        }
        if /* TODO(BinaryExpression): length(source.typeParameters) !== length(target.typeParameters) */ TODO {
             /* TODO(PropertyAccessExpression): Ternary.False */ TODO
        }
        if /* TODO(PropertyAccessExpression): target.typeParameters */ TODO {
            mapper := createTypeMapper(/* TODO(NonNullExpression): source.typeParameters! */ TODO, /* TODO(PropertyAccessExpression): target.typeParameters */ TODO)
            /* TODO(ForStatement): for (let i = 0; i < target.typeParameters.length; i++) {                 const s = source.typeParameters![i];                 const t = target.typeParameters[i];                 if (                     !(s === t || compareTypes(instantiateType(getConstraintFromTypeParameter(s), mapper) || unknownType, getConstraintFromTypeParameter(t) || unknownType) &&                             compareTypes(instantiateType(getDefaultFromTypeParameter(s), mapper) || unknownType, getDefaultFromTypeParameter(t) || unknownType))                 ) {                     return Ternary.False;                 }             } */
            /* TODO(ExpressionStatement): source = instantiateSignature(source, mapper, /*eraseTypeParameters* / true); */
        }
        result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
        if /* TODO(PrefixUnaryExpression): !ignoreThisTypes */ TODO {
            sourceThisType := getThisTypeOfSignature(source)
            if sourceThisType {
                targetThisType := getThisTypeOfSignature(target)
                if targetThisType {
                    related := compareTypes(sourceThisType, targetThisType)
                    if /* TODO(PrefixUnaryExpression): !related */ TODO {
                         /* TODO(PropertyAccessExpression): Ternary.False */ TODO
                    }
                    /* TODO(ExpressionStatement): result &= related; */
                }
            }
        }
        targetLen := getParameterCount(target)
        /* TODO(ForStatement): for (let i = 0; i < targetLen; i++) {             const s = getTypeAtPosition(source, i);             const t = getTypeAtPosition(target, i);             const related = compareTypes(t, s);             if (!related) {                 return Ternary.False;             }             result &= related;         } */
        if /* TODO(PrefixUnaryExpression): !ignoreReturnTypes */ TODO {
            sourceTypePredicate := getTypePredicateOfSignature(source)
            targetTypePredicate := getTypePredicateOfSignature(target)
            /* TODO(ExpressionStatement): result &= sourceTypePredicate || targetTypePredicate ?                 compareTypePredicatesIdentical(sourceTypePredicate, targetTypePredicate, compareTypes) :                 compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target)); */
        }
         result
    }
    compareTypePredicatesIdentical := func(source *TypePredicate, target *TypePredicate, compareTypes func(s Type, t Type) Ternary) Ternary {
         /* TODO(ConditionalExpression): !(source && target && typePredicateKindsMatch(source, target)) ? Ternary.False :             source.type === target.type ? Ternary.True :             source.type && target.type ? compareTypes(source.type, target.type) :             Ternary.False */ TODO
    }
    literalTypesWithSameBaseType := func(types []Type) bool {
        var commonBaseType *Type
        /* TODO(ForOfStatement): for (const t of types) {             if (!(t.flags & TypeFlags.Never)) {                 const baseType = getBaseTypeOfLiteralType(t);                 commonBaseType ??= baseType;                 if (baseType === t || baseType !== commonBaseType) {                     return false;                 }             }         } */
         /* TODO(TrueKeyword): true */ TODO
    }
    getCombinedTypeFlags := func(types []Type) TypeFlags {
         reduceLeft(types, /* TODO(ArrowFunction): (flags, t) => flags | (t.flags & TypeFlags.Union ? getCombinedTypeFlags((t as UnionType).types) : t.flags) */ TODO, 0 /* as */ /* TODO(TypeReference): TypeFlags */)
    }
    getCommonSupertype := func(types []Type) Type {
        if /* TODO(BinaryExpression): types.length === 1 */ TODO {
             /* TODO(ElementAccessExpression): types[0] */ TODO
        }
        primaryTypes := /* TODO(ConditionalExpression): strictNullChecks ? sameMap(types, t => filterType(t, u => !(u.flags & TypeFlags.Nullable))) : types */ TODO
        superTypeOrUnion := /* TODO(ConditionalExpression): literalTypesWithSameBaseType(primaryTypes) ?             getUnionType(primaryTypes) :             reduceLeft(primaryTypes, (s, t) => isTypeSubtypeOf(s, t) ? t : s)! */ TODO
         /* TODO(ConditionalExpression): primaryTypes === types ? superTypeOrUnion : getNullableType(superTypeOrUnion, getCombinedTypeFlags(types) & TypeFlags.Nullable) */ TODO
    }
    getCommonSubtype := func(types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(NonNullExpression): reduceLeft(types, (s, t) => isTypeSubtypeOf(t, s) ? t : s)! */ TODO
    }
    isArrayType := func(type_ Type) /* TODO(TypePredicate): type is TypeReference */ TODO {
         /* TODO(BinaryExpression): !!(getObjectFlags(type) & ObjectFlags.Reference) && ((type as TypeReference).target === globalArrayType || (type as TypeReference).target === globalReadonlyArrayType) */ TODO
    }
    isReadonlyArrayType := func(type_ Type) bool {
         /* TODO(BinaryExpression): !!(getObjectFlags(type) & ObjectFlags.Reference) && (type as TypeReference).target === globalReadonlyArrayType */ TODO
    }
    isArrayOrTupleType := func(type_ Type) /* TODO(TypePredicate): type is TypeReference */ TODO {
         /* TODO(BinaryExpression): isArrayType(type) || isTupleType(type) */ TODO
    }
    isMutableArrayOrTuple := func(type_ Type) bool {
         /* TODO(BinaryExpression): isArrayType(type) && !isReadonlyArrayType(type) || isTupleType(type) && !type.target.readonly */ TODO
    }
    getElementTypeOfArrayType := func(type_ Type) *Type {
         /* TODO(ConditionalExpression): isArrayType(type) ? getTypeArguments(type)[0] : undefined */ TODO
    }
    isArrayLikeType := func(type_ Type) bool {
         /* TODO(BinaryExpression): isArrayType(type) || !(type.flags & TypeFlags.Nullable) && isTypeAssignableTo(type, anyReadonlyArrayType) */ TODO
    }
    isMutableArrayLikeType := func(type_ Type) bool {
         /* TODO(BinaryExpression): isMutableArrayOrTuple(type) || !(type.flags & (TypeFlags.Any | TypeFlags.Nullable)) && isTypeAssignableTo(type, anyArrayType) */ TODO
    }
    getSingleBaseForNonAugmentingSubtype := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(BinaryExpression): !(getObjectFlags(type) & ObjectFlags.Reference) || !(getObjectFlags((type as TypeReference).target) & ObjectFlags.ClassOrInterface) */ TODO {
             undefined
        }
        if /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.IdenticalBaseTypeCalculated */ TODO {
             /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.IdenticalBaseTypeExists ? (type as TypeReference).cachedEquivalentBaseType : undefined */ TODO
        }
        /* TODO(ExpressionStatement): (type as TypeReference).objectFlags |= ObjectFlags.IdenticalBaseTypeCalculated; */
        target := /* TODO(PropertyAccessExpression): (type as TypeReference).target */ TODO /* as */ /* TODO(TypeReference): InterfaceType */
        if /* TODO(BinaryExpression): getObjectFlags(target) & ObjectFlags.Class */ TODO {
            baseTypeNode := getBaseTypeNodeOfClass(target)
            if /* TODO(BinaryExpression): baseTypeNode && baseTypeNode.expression.kind !== SyntaxKind.Identifier && baseTypeNode.expression.kind !== SyntaxKind.PropertyAccessExpression */ TODO {
                 undefined
            }
        }
        bases := getBaseTypes(target)
        if /* TODO(BinaryExpression): bases.length !== 1 */ TODO {
             undefined
        }
        if /* TODO(PropertyAccessExpression): getMembersOfSymbol(type.symbol).size */ TODO {
             undefined
        }
        instantiatedBase := /* TODO(ConditionalExpression): !length(target.typeParameters) ? bases[0] : instantiateType(bases[0], createTypeMapper(target.typeParameters!, getTypeArguments(type as TypeReference).slice(0, target.typeParameters!.length))) */ TODO
        if /* TODO(BinaryExpression): length(getTypeArguments(type as TypeReference)) > length(target.typeParameters) */ TODO {
            /* TODO(ExpressionStatement): instantiatedBase = getTypeWithThisArgument(instantiatedBase, last(getTypeArguments(type as TypeReference))); */
        }
        /* TODO(ExpressionStatement): (type as TypeReference).objectFlags |= ObjectFlags.IdenticalBaseTypeExists; */
         /* TODO(BinaryExpression): (type as TypeReference).cachedEquivalentBaseType = instantiatedBase */ TODO
    }
    isEmptyLiteralType := func(type_ Type) bool {
         /* TODO(ConditionalExpression): strictNullChecks ? type === implicitNeverType : type === undefinedWideningType */ TODO
    }
    isEmptyArrayLiteralType := func(type_ Type) bool {
        elementType := getElementTypeOfArrayType(type_)
         /* TODO(BinaryExpression): !!elementType && isEmptyLiteralType(elementType) */ TODO
    }
    isTupleLikeType := func(type_ Type) bool {
        lengthType
         /* TODO(BinaryExpression): isTupleType(type) ||             !!getPropertyOfType(type, "0" as __String) ||             isArrayLikeType(type) && !!(lengthType = getTypeOfPropertyOfType(type, "length" as __String)) && everyType(lengthType, t => !!(t.flags & TypeFlags.NumberLiteral)) */ TODO
    }
    isArrayOrTupleLikeType := func(type_ Type) bool {
         /* TODO(BinaryExpression): isArrayLikeType(type) || isTupleLikeType(type) */ TODO
    }
    getTupleElementType := func(type_ Type, index number) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        propType := getTypeOfPropertyOfType(type_, /* TODO(BinaryExpression): "" + index */ TODO /* as */ /* TODO(TypeReference): __String */)
        if propType {
             propType
        }
        if everyType(type_, isTupleType) {
             getTupleElementTypeOutOfStartCount(type_, index, /* TODO(ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ? undefinedType : undefined */ TODO)
        }
         undefined
    }
    isNeitherUnitTypeNorNever := func(type_ Type) bool {
         /* TODO(PrefixUnaryExpression): !(type.flags & (TypeFlags.Unit | TypeFlags.Never)) */ TODO
    }
    isUnitType := func(type_ Type) bool {
         /* TODO(PrefixUnaryExpression): !!(type.flags & TypeFlags.Unit) */ TODO
    }
    isUnitLikeType := func(type_ Type) bool {
        t := getBaseConstraintOrType(type_)
         /* TODO(ConditionalExpression): t.flags & TypeFlags.Intersection ? some((t as IntersectionType).types, isUnitType) : isUnitType(t) */ TODO
    }
    extractUnitType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection ? find((type as IntersectionType).types, isUnitType) || type : type */ TODO
    }
    isLiteralType := func(type_ Type) bool {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Boolean ? true :             type.flags & TypeFlags.Union ? type.flags & TypeFlags.EnumLiteral ? true : every((type as UnionType).types, isUnitType) :             isUnitType(type) */ TODO
    }
    getBaseTypeOfLiteralType := func(type_ Type) Type {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike ? getBaseTypeOfEnumLikeType(type as LiteralType) :             type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? stringType :             type.flags & TypeFlags.NumberLiteral ? numberType :             type.flags & TypeFlags.BigIntLiteral ? bigintType :             type.flags & TypeFlags.BooleanLiteral ? booleanType :             type.flags & TypeFlags.Union ? getBaseTypeOfLiteralTypeUnion(type as UnionType) :             type */ TODO
    }
    getBaseTypeOfLiteralTypeUnion := func(type_ UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        key := /* TODO(TemplateExpression): `B${getTypeId(type)}` */ TODO
         /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, mapType(type, getBaseTypeOfLiteralType)) */ TODO
    }
    getBaseTypeOfLiteralTypeForComparison := func(type_ Type) Type {
         /* TODO(ConditionalExpression): type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? stringType :             type.flags & (TypeFlags.NumberLiteral | TypeFlags.Enum) ? numberType :             type.flags & TypeFlags.BigIntLiteral ? bigintType :             type.flags & TypeFlags.BooleanLiteral ? booleanType :             type.flags & TypeFlags.Union ? mapType(type, getBaseTypeOfLiteralTypeForComparison) :             type */ TODO
    }
    getWidenedLiteralType := func(type_ Type) Type {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike && isFreshLiteralType(type) ? getBaseTypeOfEnumLikeType(type as LiteralType) :             type.flags & TypeFlags.StringLiteral && isFreshLiteralType(type) ? stringType :             type.flags & TypeFlags.NumberLiteral && isFreshLiteralType(type) ? numberType :             type.flags & TypeFlags.BigIntLiteral && isFreshLiteralType(type) ? bigintType :             type.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(type) ? booleanType :             type.flags & TypeFlags.Union ? mapType(type as UnionType, getWidenedLiteralType) :             type */ TODO
    }
    getWidenedUniqueESSymbolType := func(type_ Type) Type {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.UniqueESSymbol ? esSymbolType :             type.flags & TypeFlags.Union ? mapType(type as UnionType, getWidenedUniqueESSymbolType) :             type */ TODO
    }
    getWidenedLiteralLikeTypeForContextualType := func(type_ Type, contextualType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(PrefixUnaryExpression): !isLiteralOfContextualType(type, contextualType) */ TODO {
            /* TODO(ExpressionStatement): type = getWidenedUniqueESSymbolType(getWidenedLiteralType(type)); */
        }
         getRegularTypeOfLiteralType(type_)
    }
    getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded := func(type_ *Type, contextualSignatureReturnType *Type, isAsync bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(BinaryExpression): type && isUnitType(type) */ TODO {
            contextualType := /* TODO(ConditionalExpression): !contextualSignatureReturnType ? undefined :                 isAsync ? getPromisedTypeOfPromise(contextualSignatureReturnType) :                 contextualSignatureReturnType */ TODO
            /* TODO(ExpressionStatement): type = getWidenedLiteralLikeTypeForContextualType(type, contextualType); */
        }
         type_
    }
    getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded := func(type_ *Type, contextualSignatureReturnType *Type, kind IterationTypeKind, isAsyncGenerator bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(BinaryExpression): type && isUnitType(type) */ TODO {
            contextualType := /* TODO(ConditionalExpression): !contextualSignatureReturnType ? undefined :                 getIterationTypeOfGeneratorFunctionReturnType(kind, contextualSignatureReturnType, isAsyncGenerator) */ TODO
            /* TODO(ExpressionStatement): type = getWidenedLiteralLikeTypeForContextualType(type, contextualType); */
        }
         type_
    }
    isTupleType := func(type_ Type) /* TODO(TypePredicate): type is TupleTypeReference */ TODO {
         /* TODO(PrefixUnaryExpression): !!(getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference).target.objectFlags & ObjectFlags.Tuple) */ TODO
    }
    isGenericTupleType := func(type_ Type) /* TODO(TypePredicate): type is TupleTypeReference */ TODO {
         /* TODO(BinaryExpression): isTupleType(type) && !!(type.target.combinedFlags & ElementFlags.Variadic) */ TODO
    }
    isSingleElementGenericTupleType := func(type_ Type) /* TODO(TypePredicate): type is TupleTypeReference */ TODO {
         /* TODO(BinaryExpression): isGenericTupleType(type) && type.target.elementFlags.length === 1 */ TODO
    }
    getRestTypeOfTupleType := func(type_ TupleTypeReference) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
         getElementTypeOfSliceOfTupleType(type_, /* TODO(PropertyAccessExpression): type.target.fixedLength */ TODO)
    }
    getTupleElementTypeOutOfStartCount := func(type_ Type, index number, undefinedOrMissingType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         mapType(type_, /* TODO(ArrowFunction): t => {             const tupleType = t as TupleTypeReference;             const restType = getRestTypeOfTupleType(tupleType);             if (!restType) {                 return undefinedType;             }             if (undefinedOrMissingType && index >= getTotalFixedElementCount(tupleType.target)) {                 return getUnionType([restType, undefinedOrMissingType]);             }             return restType;         } */ TODO)
    }
    getRestArrayTypeOfTupleType := func(type_ TupleTypeReference) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType | undefined */ TODO {
        restType := getRestTypeOfTupleType(type_)
         /* TODO(BinaryExpression): restType && createArrayType(restType) */ TODO
    }
    getElementTypeOfSliceOfTupleType := func(type_ TupleTypeReference, index number, endSkipCount /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */, writing /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, noReductions /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        length := /* TODO(BinaryExpression): getTypeReferenceArity(type) - endSkipCount */ TODO
        if /* TODO(BinaryExpression): index < length */ TODO {
            typeArguments := getTypeArguments(type_)
            var elementTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(ForStatement): for (let i = index; i < length; i++) {                 const t = typeArguments[i];                 elementTypes.push(type.target.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t);             } */
             /* TODO(ConditionalExpression): writing ? getIntersectionType(elementTypes) : getUnionType(elementTypes, noReductions ? UnionReduction.None : UnionReduction.Literal) */ TODO
        }
         undefined
    }
    isTupleTypeStructureMatching := func(t1 TupleTypeReference, t2 TupleTypeReference) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): getTypeReferenceArity(t1) === getTypeReferenceArity(t2) &&             every(t1.target.elementFlags, (f, i) => (f & ElementFlags.Variable) === (t2.target.elementFlags[i] & ElementFlags.Variable)) */ TODO
    }
    isZeroBigInt := func(TODO_IDENTIFIER BigIntLiteralType) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): value.base10Value === "0" */ TODO
    }
    removeDefinitelyFalsyTypes := func(type_ Type) Type {
         filterType(type_, /* TODO(ArrowFunction): t => hasTypeFacts(t, TypeFacts.Truthy) */ TODO)
    }
    extractDefinitelyFalsyTypes := func(type_ Type) Type {
         mapType(type_, getDefinitelyFalsyPartOfType)
    }
    getDefinitelyFalsyPartOfType := func(type_ Type) Type {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.String ? emptyStringType :             type.flags & TypeFlags.Number ? zeroType :             type.flags & TypeFlags.BigInt ? zeroBigIntType :             type === regularFalseType ||                 type === falseType ||                 type.flags & (TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null | TypeFlags.AnyOrUnknown) ||                 type.flags & TypeFlags.StringLiteral && (type as StringLiteralType).value === "" ||                 type.flags & TypeFlags.NumberLiteral && (type as NumberLiteralType).value === 0 ||                 type.flags & TypeFlags.BigIntLiteral && isZeroBigInt(type as BigIntLiteralType) ? type :             neverType */ TODO
    }
    getNullableType := func(type_ Type, flags TypeFlags) Type {
        missing := /* TODO(BinaryExpression): (flags & ~type.flags) & (TypeFlags.Undefined | TypeFlags.Null) */ TODO
         /* TODO(ConditionalExpression): missing === 0 ? type :             missing === TypeFlags.Undefined ? getUnionType([type, undefinedType]) :             missing === TypeFlags.Null ? getUnionType([type, nullType]) :             getUnionType([type, undefinedType, nullType]) */ TODO
    }
    getOptionalType := func(type_ Type, isProperty /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) Type {
        /* TODO(ExpressionStatement): Debug.assert(strictNullChecks); */
        missingOrUndefined := /* TODO(ConditionalExpression): isProperty ? undefinedOrMissingType : undefinedType */ TODO
         /* TODO(ConditionalExpression): type === missingOrUndefined || type.flags & TypeFlags.Union && (type as UnionType).types[0] === missingOrUndefined ? type : getUnionType([type, missingOrUndefined]) */ TODO
    }
    getGlobalNonNullableTypeInstantiation := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(PrefixUnaryExpression): !deferredGlobalNonNullableTypeAlias */ TODO {
            /* TODO(ExpressionStatement): deferredGlobalNonNullableTypeAlias = getGlobalSymbol("NonNullable" as __String, SymbolFlags.TypeAlias, /*diagnostic* / undefined) || unknownSymbol; */
        }
         /* TODO(ConditionalExpression): deferredGlobalNonNullableTypeAlias !== unknownSymbol ?             getTypeAliasInstantiation(deferredGlobalNonNullableTypeAlias, [type]) :             getIntersectionType([type, emptyObjectType]) */ TODO
    }
    getNonNullableType := func(type_ Type) Type {
         /* TODO(ConditionalExpression): strictNullChecks ? getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO
    }
    addOptionalTypeMarker := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): strictNullChecks ? getUnionType([type, optionalType]) : type */ TODO
    }
    removeOptionalTypeMarker := func(type_ Type) Type {
         /* TODO(ConditionalExpression): strictNullChecks ? removeType(type, optionalType) : type */ TODO
    }
    propagateOptionalTypeMarker := func(type_ Type, node OptionalChain, wasOptional bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): wasOptional ? isOutermostOptionalChain(node) ? getOptionalType(type) : addOptionalTypeMarker(type) : type */ TODO
    }
    getOptionalExpressionType := func(exprType Type, expression Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): isExpressionOfOptionalChainRoot(expression) ? getNonNullableType(exprType) :             isOptionalChain(expression) ? removeOptionalTypeMarker(exprType) :             exprType */ TODO
    }
    removeMissingType := func(type_ Type, isOptional bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): exactOptionalPropertyTypes && isOptional ? removeType(type, missingType) : type */ TODO
    }
    containsMissingType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): type === missingType || !!(type.flags & TypeFlags.Union) && (type as UnionType).types[0] === missingType */ TODO
    }
    removeMissingOrUndefinedType := func(type_ Type) Type {
         /* TODO(ConditionalExpression): exactOptionalPropertyTypes ? removeType(type, missingType) : getTypeWithFacts(type, TypeFacts.NEUndefined) */ TODO
    }
    isCoercibleUnderDoubleEquals := func(source Type, target Type) bool {
         /* TODO(BinaryExpression): ((source.flags & (TypeFlags.Number | TypeFlags.String | TypeFlags.BooleanLiteral)) !== 0)             && ((target.flags & (TypeFlags.Number | TypeFlags.String | TypeFlags.Boolean)) !== 0) */ TODO
    }
    isObjectTypeWithInferableIndex := func(type_ Type) bool {
        objectFlags := getObjectFlags(type_)
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection             ? every((type as IntersectionType).types, isObjectTypeWithInferableIndex)             : !!(                 type.symbol                 && (type.symbol.flags & (SymbolFlags.ObjectLiteral | SymbolFlags.TypeLiteral | SymbolFlags.Enum | SymbolFlags.ValueModule)) !== 0                 && !(type.symbol.flags & SymbolFlags.Class)                 && !typeHasCallOrConstructSignatures(type)             ) || !!(                 objectFlags & ObjectFlags.ObjectRestType             ) || !!(objectFlags & ObjectFlags.ReverseMapped && isObjectTypeWithInferableIndex((type as ReverseMappedType).source)) */ TODO
    }
    createSymbolWithType := func(source Symbol, type_ *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
        symbol := createSymbol(/* TODO(PropertyAccessExpression): source.flags */ TODO, /* TODO(PropertyAccessExpression): source.escapedName */ TODO, /* TODO(BinaryExpression): getCheckFlags(source) & CheckFlags.Readonly */ TODO)
        /* TODO(ExpressionStatement): symbol.declarations = source.declarations; */
        /* TODO(ExpressionStatement): symbol.parent = source.parent; */
        /* TODO(ExpressionStatement): symbol.links.type = type; */
        /* TODO(ExpressionStatement): symbol.links.target = source; */
        if /* TODO(PropertyAccessExpression): source.valueDeclaration */ TODO {
            /* TODO(ExpressionStatement): symbol.valueDeclaration = source.valueDeclaration; */
        }
        nameType := /* TODO(PropertyAccessExpression): getSymbolLinks(source).nameType */ TODO
        if nameType {
            /* TODO(ExpressionStatement): symbol.links.nameType = nameType; */
        }
         symbol
    }
    transformTypeOfMembers := func(type_ Type, f func(propertyType Type) Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ TODO {
        members := createSymbolTable()
        /* TODO(ForOfStatement): for (const property of getPropertiesOfObjectType(type)) {             const original = getTypeOfSymbol(property);             const updated = f(original);             members.set(property.escapedName, updated === original ? property : createSymbolWithType(property, updated));         } */
         members
    }
    getRegularTypeOfObjectLiteral := func(type_ Type) Type {
        if /* TODO(PrefixUnaryExpression): !(isObjectLiteralType(type) && getObjectFlags(type) & ObjectFlags.FreshLiteral) */ TODO {
             type_
        }
        regularType := /* TODO(PropertyAccessExpression): (type as FreshObjectLiteralType).regularType */ TODO
        if regularType {
             regularType
        }
        resolved := type_ /* as */ /* TODO(TypeReference): ResolvedType */
        members := transformTypeOfMembers(type_, getRegularTypeOfObjectLiteral)
        regularNew := createAnonymousType(/* TODO(PropertyAccessExpression): resolved.symbol */ TODO, members, /* TODO(PropertyAccessExpression): resolved.callSignatures */ TODO, /* TODO(PropertyAccessExpression): resolved.constructSignatures */ TODO, /* TODO(PropertyAccessExpression): resolved.indexInfos */ TODO)
        /* TODO(ExpressionStatement): regularNew.flags = resolved.flags; */
        /* TODO(ExpressionStatement): regularNew.objectFlags |= resolved.objectFlags & ~ObjectFlags.FreshLiteral; */
        /* TODO(ExpressionStatement): (type as FreshObjectLiteralType).regularType = regularNew; */
         regularNew
    }
    createWideningContext := func(parent *WideningContext, propertyName *__String, siblings /* TODO(ArrayType): Type[] */ any) WideningContext {
         /* TODO(ObjectLiteralExpression): { parent, propertyName, siblings, resolvedProperties: undefined } */ TODO
    }
    getSiblingsOfContext := func(context WideningContext) []Type {
        if /* TODO(PrefixUnaryExpression): !context.siblings */ TODO {
            var siblings []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(ForOfStatement): for (const type of getSiblingsOfContext(context.parent!)) {                 if (isObjectLiteralType(type)) {                     const prop = getPropertyOfObjectType(type, context.propertyName!);                     if (prop) {                         forEachType(getTypeOfSymbol(prop), t => {                             siblings.push(t);                         });                     }                 }             } */
            /* TODO(ExpressionStatement): context.siblings = siblings; */
        }
         /* TODO(PropertyAccessExpression): context.siblings */ TODO
    }
    getPropertiesOfContext := func(context WideningContext) []Symbol {
        if /* TODO(PrefixUnaryExpression): !context.resolvedProperties */ TODO {
            names := /* TODO(NewExpression): new Map<__String, Symbol>() */ TODO
            /* TODO(ForOfStatement): for (const t of getSiblingsOfContext(context)) {                 if (isObjectLiteralType(t) && !(getObjectFlags(t) & ObjectFlags.ContainsSpread)) {                     for (const prop of getPropertiesOfType(t)) {                         names.set(prop.escapedName, prop);                     }                 }             } */
            /* TODO(ExpressionStatement): context.resolvedProperties = arrayFrom(names.values()); */
        }
         /* TODO(PropertyAccessExpression): context.resolvedProperties */ TODO
    }
    getWidenedProperty := func(prop Symbol, context *WideningContext) Symbol {
        if /* TODO(PrefixUnaryExpression): !(prop.flags & SymbolFlags.Property) */ TODO {
             prop
        }
        original := getTypeOfSymbol(prop)
        propContext := /* TODO(BinaryExpression): context && createWideningContext(context, prop.escapedName, /*siblings* / undefined) */ TODO
        widened := getWidenedTypeWithContext(original, propContext)
         /* TODO(ConditionalExpression): widened === original ? prop : createSymbolWithType(prop, widened) */ TODO
    }
    getUndefinedProperty := func(prop Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
        cached := /* TODO(PropertyAccessExpression): undefinedProperties.get */ TODO(/* TODO(PropertyAccessExpression): prop.escapedName */ TODO)
        if cached {
             cached
        }
        result := createSymbolWithType(prop, undefinedOrMissingType)
        /* TODO(ExpressionStatement): result.flags |= SymbolFlags.Optional; */
        /* TODO(ExpressionStatement): undefinedProperties.set(prop.escapedName, result); */
         result
    }
    getWidenedTypeOfObjectLiteral := func(type_ Type, context *WideningContext) Type {
        members := createSymbolTable()
        /* TODO(ForOfStatement): for (const prop of getPropertiesOfObjectType(type)) {             members.set(prop.escapedName, getWidenedProperty(prop, context));         } */
        if context {
            /* TODO(ForOfStatement): for (const prop of getPropertiesOfContext(context)) {                 if (!members.has(prop.escapedName)) {                     members.set(prop.escapedName, getUndefinedProperty(prop));                 }             } */
        }
        result := createAnonymousType(/* TODO(PropertyAccessExpression): type.symbol */ TODO, members, emptyArray, emptyArray, sameMap(getIndexInfosOfType(type_), /* TODO(ArrowFunction): info => createIndexInfo(info.keyType, getWidenedType(info.type), info.isReadonly) */ TODO))
        /* TODO(ExpressionStatement): result.objectFlags |= getObjectFlags(type) & (ObjectFlags.JSLiteral | ObjectFlags.NonInferrableType); */
         result
    }
    getWidenedType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         getWidenedTypeWithContext(type_, undefined)
    }
    getWidenedTypeWithContext := func(type_ Type, context *WideningContext) Type {
        if /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.RequiresWidening */ TODO {
            if /* TODO(BinaryExpression): context === undefined && type.widened */ TODO {
                 /* TODO(PropertyAccessExpression): type.widened */ TODO
            }
            var result *Type
            if /* TODO(BinaryExpression): type.flags & (TypeFlags.Any | TypeFlags.Nullable) */ TODO {
                /* TODO(ExpressionStatement): result = anyType; */
            } else if isObjectLiteralType(type_) {
                /* TODO(ExpressionStatement): result = getWidenedTypeOfObjectLiteral(type, context); */
            } else if /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
                unionContext := /* TODO(BinaryExpression): context || createWideningContext(/*parent* / undefined, /*propertyName* / undefined, (type as UnionType).types) */ TODO
                widenedTypes := sameMap(/* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, /* TODO(ArrowFunction): t => t.flags & TypeFlags.Nullable ? t : getWidenedTypeWithContext(t, unionContext) */ TODO)
                /* TODO(ExpressionStatement): result = getUnionType(widenedTypes, some(widenedTypes, isEmptyObjectType) ? UnionReduction.Subtype : UnionReduction.Literal); */
            } else if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
                /* TODO(ExpressionStatement): result = getIntersectionType(sameMap((type as IntersectionType).types, getWidenedType)); */
            } else if isArrayOrTupleType(type_) {
                /* TODO(ExpressionStatement): result = createTypeReference(type.target, sameMap(getTypeArguments(type), getWidenedType)); */
            }
            if /* TODO(BinaryExpression): result && context === undefined */ TODO {
                /* TODO(ExpressionStatement): type.widened = result; */
            }
             /* TODO(BinaryExpression): result || type */ TODO
        }
         type_
    }
    reportWideningErrorsInType := func(type_ Type) bool {
        errorReported := /* TODO(FalseKeyword): false */ TODO
        if /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.ContainsWideningType */ TODO {
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
                if some(/* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, isEmptyObjectType) {
                    /* TODO(ExpressionStatement): errorReported = true; */
                } else {
                    /* TODO(ForOfStatement): for (const t of (type as UnionType).types) {                         errorReported ||= reportWideningErrorsInType(t);                     } */
                }
            } else if isArrayOrTupleType(type_) {
                /* TODO(ForOfStatement): for (const t of getTypeArguments(type)) {                     errorReported ||= reportWideningErrorsInType(t);                 } */
            } else if isObjectLiteralType(type_) {
                /* TODO(ForOfStatement): for (const p of getPropertiesOfObjectType(type)) {                     const t = getTypeOfSymbol(p);                     if (getObjectFlags(t) & ObjectFlags.ContainsWideningType) {                         errorReported = reportWideningErrorsInType(t);                         if (!errorReported) {                             // we need to account for property types coming from object literal type normalization in unions                             const valueDeclaration = p.declarations?.find(d => d.symbol.valueDeclaration?.parent === type.symbol.valueDeclaration);                             if (valueDeclaration) {                                 error(valueDeclaration, Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, symbolToString(p), typeToString(getWidenedType(t)));                                 errorReported = true;                             }                         }                     }                 } */
            }
        }
         errorReported
    }
    reportImplicitAny := func(declaration Declaration, type_ Type, wideningKind WideningKind) {
        typeAsString := typeToString(getWidenedType(type_))
        if /* TODO(BinaryExpression): isInJSFile(declaration) && !isCheckJsEnabledForFile(getSourceFileOfNode(declaration), compilerOptions) */ TODO {

        }
        var diagnostic DiagnosticMessage
        /* TODO(SwitchStatement): switch (declaration.kind) {             case SyntaxKind.BinaryExpression:             case SyntaxKind.PropertyDeclaration:             case SyntaxKind.PropertySignature:                 diagnostic = noImplicitAny ? Diagnostics.Member_0_implicitly_has_an_1_type : Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;                 break;             case SyntaxKind.Parameter:                 const param = declaration as ParameterDeclaration;                 if (isIdentifier(param.name)) {                     const originalKeywordKind = identifierToKeywordKind(param.name);                     if (                         (isCallSignatureDeclaration(param.parent) || isMethodSignature(param.parent) || isFunctionTypeNode(param.parent)) &&                         param.parent.parameters.includes(param) &&                         (resolveName(param, param.name.escapedText, SymbolFlags.Type, /*nameNotFoundMessage* / undefined, /*isUse* / true) ||                             originalKeywordKind && isTypeNodeKind(originalKeywordKind))                     ) {                         const newName = "arg" + param.parent.parameters.indexOf(param);                         const typeName = declarationNameToString(param.name) + (param.dotDotDotToken ? "[]" : "");                         errorOrSuggestion(noImplicitAny, declaration, Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1, newName, typeName);                         return;                     }                 }                 diagnostic = (declaration as ParameterDeclaration).dotDotDotToken ?                     noImplicitAny ? Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage :                     noImplicitAny ? Diagnostics.Parameter_0_implicitly_has_an_1_type : Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;                 break;             case SyntaxKind.BindingElement:                 diagnostic = Diagnostics.Binding_element_0_implicitly_has_an_1_type;                 if (!noImplicitAny) {                     // Don't issue a suggestion for binding elements since the codefix doesn't yet support them.                     return;                 }                 break;             case SyntaxKind.JSDocFunctionType:                 error(declaration, Diagnostics.Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);                 return;             case SyntaxKind.JSDocSignature:                 if (noImplicitAny && isJSDocOverloadTag(declaration.parent)) {                     error(declaration.parent.tagName, Diagnostics.This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation, typeAsString);                 }                 return;             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:                 if (noImplicitAny && !(declaration as NamedDeclaration).name) {                     if (wideningKind === WideningKind.GeneratorYield) {                         error(declaration, Diagnostics.Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation, typeAsString);                     }                     else {                         error(declaration, Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);                     }                     return;                 }                 diagnostic = !noImplicitAny ? Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage :                     wideningKind === WideningKind.GeneratorYield ? Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type :                     Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type;                 break;             case SyntaxKind.MappedType:                 if (noImplicitAny) {                     error(declaration, Diagnostics.Mapped_object_type_implicitly_has_an_any_template_type);                 }                 return;             default:                 diagnostic = noImplicitAny ? Diagnostics.Variable_0_implicitly_has_an_1_type : Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;         } */
        /* TODO(ExpressionStatement): errorOrSuggestion(noImplicitAny, declaration, diagnostic, declarationNameToString(getNameOfDeclaration(declaration)), typeAsString); */
    }
    reportErrorsFromWidening := func(declaration Declaration, type_ Type, wideningKind WideningKind) {
        /* TODO(ExpressionStatement): addLazyDiagnostic(() => {             if (noImplicitAny && getObjectFlags(type) & ObjectFlags.ContainsWideningType && (!wideningKind || !getContextualSignatureForFunctionLikeDeclaration(declaration as FunctionLikeDeclaration))) {                 // Report implicit any error within type if possible, otherwise report error on declaration                 if (!reportWideningErrorsInType(type)) {                     reportImplicitAny(declaration, type, wideningKind);                 }             }         }); */
    }
    applyToParameterTypes := func(source Signature, target Signature, callback func(s Type, t Type) ) {
        sourceCount := getParameterCount(source)
        targetCount := getParameterCount(target)
        sourceRestType := getEffectiveRestType(source)
        targetRestType := getEffectiveRestType(target)
        targetNonRestCount := /* TODO(ConditionalExpression): targetRestType ? targetCount - 1 : targetCount */ TODO
        paramCount := /* TODO(ConditionalExpression): sourceRestType ? targetNonRestCount : Math.min(sourceCount, targetNonRestCount) */ TODO
        sourceThisType := getThisTypeOfSignature(source)
        if sourceThisType {
            targetThisType := getThisTypeOfSignature(target)
            if targetThisType {
                /* TODO(ExpressionStatement): callback(sourceThisType, targetThisType); */
            }
        }
        /* TODO(ForStatement): for (let i = 0; i < paramCount; i++) {             callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i));         } */
        if targetRestType {
            /* TODO(ExpressionStatement): callback(getRestTypeAtPosition(source, paramCount, /*readonly* / isConstTypeVariable(targetRestType) && !someType(targetRestType, isMutableArrayLikeType)), targetRestType); */
        }
    }
    applyToReturnTypes := func(source Signature, target Signature, callback func(s Type, t Type) ) {
        targetTypePredicate := getTypePredicateOfSignature(target)
        if targetTypePredicate {
            sourceTypePredicate := getTypePredicateOfSignature(source)
            if /* TODO(BinaryExpression): sourceTypePredicate && typePredicateKindsMatch(sourceTypePredicate, targetTypePredicate) && sourceTypePredicate.type && targetTypePredicate.type */ TODO {
                /* TODO(ExpressionStatement): callback(sourceTypePredicate.type, targetTypePredicate.type); */

            }
        }
        targetReturnType := getReturnTypeOfSignature(target)
        if couldContainTypeVariables(targetReturnType) {
            /* TODO(ExpressionStatement): callback(getReturnTypeOfSignature(source), targetReturnType); */
        }
    }
    createInferenceContext := func(typeParameters []TypeParameter, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
         createInferenceContextWorker(/* TODO(PropertyAccessExpression): typeParameters.map */ TODO(createInferenceInfo), signature, flags, /* TODO(BinaryExpression): compareTypes || compareTypesAssignable */ TODO)
    }
    cloneInferenceContext := func(context T, extraFlags InferenceFlags /* = */ /* TODO(NumericLiteral): 0 */) /* TODO(UnionType): InferenceContext | T & undefined */ any {
         /* TODO(BinaryExpression): context && createInferenceContextWorker(map(context.inferences, cloneInferenceInfo), context.signature, context.flags | extraFlags, context.compareTypes) */ TODO
    }
    createInferenceContextWorker := func(inferences []InferenceInfo, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
        var context InferenceContext = /* TODO(ObjectLiteralExpression): {             inferences,             signature,             flags,             compareTypes,             mapper: reportUnmeasurableMapper, // initialize to a noop mapper so the context object is available, but the underlying object shape is right upon construction             nonFixingMapper: reportUnmeasurableMapper,         } */ TODO
        /* TODO(ExpressionStatement): context.mapper = makeFixingMapperForContext(context); */
        /* TODO(ExpressionStatement): context.nonFixingMapper = makeNonFixingMapperForContext(context); */
         context
    }
    makeFixingMapperForContext := func(context InferenceContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
         makeDeferredTypeMapper(map_(/* TODO(PropertyAccessExpression): context.inferences */ TODO, /* TODO(ArrowFunction): i => i.typeParameter */ TODO), map_(/* TODO(PropertyAccessExpression): context.inferences */ TODO, /* TODO(ArrowFunction): (inference, i) => () => {                 if (!inference.isFixed) {                     // Before we commit to a particular inference (and thus lock out any further inferences),                     // we infer from any intra-expression inference sites we have collected.                     inferFromIntraExpressionSites(context);                     clearCachedInferences(context.inferences);                     inference.isFixed = true;                 }                 return getInferredType(context, i);             } */ TODO))
    }
    makeNonFixingMapperForContext := func(context InferenceContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
         makeDeferredTypeMapper(map_(/* TODO(PropertyAccessExpression): context.inferences */ TODO, /* TODO(ArrowFunction): i => i.typeParameter */ TODO), map_(/* TODO(PropertyAccessExpression): context.inferences */ TODO, /* TODO(ArrowFunction): (_, i) => () => {                 return getInferredType(context, i);             } */ TODO))
    }
    clearCachedInferences := func(inferences []InferenceInfo) {
        /* TODO(ForOfStatement): for (const inference of inferences) {             if (!inference.isFixed) {                 inference.inferredType = undefined;             }         } */
    }
    addIntraExpressionInferenceSite := func(context InferenceContext, node /* TODO(UnionType): Expression | MethodDeclaration */ any, type_ Type) {
        /* TODO(ExpressionStatement): (context.intraExpressionInferenceSites ??= []).push({ node, type }); */
    }
    inferFromIntraExpressionSites := func(context InferenceContext) {
        if /* TODO(PropertyAccessExpression): context.intraExpressionInferenceSites */ TODO {
            /* TODO(ForOfStatement): for (const { node, type } of context.intraExpressionInferenceSites) {                 const contextualType = node.kind === SyntaxKind.MethodDeclaration ?                     getContextualTypeForObjectLiteralMethod(node as MethodDeclaration, ContextFlags.NoConstraints) :                     getContextualType(node, ContextFlags.NoConstraints);                 if (contextualType) {                     inferTypes(context.inferences, type, contextualType);                 }             } */
            /* TODO(ExpressionStatement): context.intraExpressionInferenceSites = undefined; */
        }
    }
    createInferenceInfo := func(typeParameter TypeParameter) InferenceInfo {
         /* TODO(ObjectLiteralExpression): {             typeParameter,             candidates: undefined,             contraCandidates: undefined,             inferredType: undefined,             priority: undefined,             topLevel: true,             isFixed: false,             impliedArity: undefined,         } */ TODO
    }
    cloneInferenceInfo := func(inference InferenceInfo) InferenceInfo {
         /* TODO(ObjectLiteralExpression): {             typeParameter: inference.typeParameter,             candidates: inference.candidates && inference.candidates.slice(),             contraCandidates: inference.contraCandidates && inference.contraCandidates.slice(),             inferredType: inference.inferredType,             priority: inference.priority,             topLevel: inference.topLevel,             isFixed: inference.isFixed,             impliedArity: inference.impliedArity,         } */ TODO
    }
    cloneInferredPartOfContext := func(context InferenceContext) *InferenceContext {
        inferences := filter(/* TODO(PropertyAccessExpression): context.inferences */ TODO, hasInferenceCandidates)
         /* TODO(ConditionalExpression): inferences.length ?             createInferenceContextWorker(map(inferences, cloneInferenceInfo), context.signature, context.flags, context.compareTypes) :             undefined */ TODO
    }
    getMapperFromContext := func(context T) /* TODO(UnionType): TypeMapper | T & undefined */ any {
         /* TODO(BinaryExpression): context && context.mapper */ TODO
    }
    couldContainTypeVariables := func(type_ Type) bool {
        objectFlags := getObjectFlags(type_)
        if /* TODO(BinaryExpression): objectFlags & ObjectFlags.CouldContainTypeVariablesComputed */ TODO {
             /* TODO(PrefixUnaryExpression): !!(objectFlags & ObjectFlags.CouldContainTypeVariables) */ TODO
        }
        result := /* TODO(PrefixUnaryExpression): !!(type.flags & TypeFlags.Instantiable ||             type.flags & TypeFlags.Object && !isNonGenericTopLevelType(type) && (                     objectFlags & ObjectFlags.Reference && ((type as TypeReference).node || some(getTypeArguments(type as TypeReference), couldContainTypeVariables)) ||                     objectFlags & ObjectFlags.SingleSignatureType && !!length((type as SingleSignatureType).outerTypeParameters) ||                     objectFlags & ObjectFlags.Anonymous && type.symbol && type.symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral) && type.symbol.declarations ||                     objectFlags & (ObjectFlags.Mapped | ObjectFlags.ReverseMapped | ObjectFlags.ObjectRestType | ObjectFlags.InstantiationExpressionType)                 ) ||             type.flags & TypeFlags.UnionOrIntersection && !(type.flags & TypeFlags.EnumLiteral) && !isNonGenericTopLevelType(type) && some((type as UnionOrIntersectionType).types, couldContainTypeVariables)) */ TODO
        if /* TODO(BinaryExpression): type.flags & TypeFlags.ObjectFlagsType */ TODO {
            /* TODO(ExpressionStatement): (type as ObjectFlagsType).objectFlags |= ObjectFlags.CouldContainTypeVariablesComputed | (result ? ObjectFlags.CouldContainTypeVariables : 0); */
        }
         result
    }
    isNonGenericTopLevelType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): type.aliasSymbol && !type.aliasTypeArguments */ TODO {
            declaration := getDeclarationOfKind(/* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO, /* TODO(PropertyAccessExpression): SyntaxKind.TypeAliasDeclaration */ TODO)
             /* TODO(PrefixUnaryExpression): !!(declaration && findAncestor(declaration.parent, n => n.kind === SyntaxKind.SourceFile ? true : n.kind === SyntaxKind.ModuleDeclaration ? false : "quit")) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isTypeParameterAtTopLevel := func(type_ Type, tp TypeParameter, depth /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) bool {
         /* TODO(PrefixUnaryExpression): !!(type === tp ||             type.flags & TypeFlags.UnionOrIntersection && some((type as UnionOrIntersectionType).types, t => isTypeParameterAtTopLevel(t, tp, depth)) ||             depth < 3 && type.flags & TypeFlags.Conditional && (                     isTypeParameterAtTopLevel(getTrueTypeFromConditionalType(type as ConditionalType), tp, depth + 1) ||                     isTypeParameterAtTopLevel(getFalseTypeFromConditionalType(type as ConditionalType), tp, depth + 1)                 )) */ TODO
    }
    isTypeParameterAtTopLevelInReturnType := func(signature Signature, typeParameter TypeParameter) /* TODO(undefined): boolean */ TODO {
        typePredicate := getTypePredicateOfSignature(signature)
         /* TODO(ConditionalExpression): typePredicate ? !!typePredicate.type && isTypeParameterAtTopLevel(typePredicate.type, typeParameter) :             isTypeParameterAtTopLevel(getReturnTypeOfSignature(signature), typeParameter) */ TODO
    }
    createEmptyObjectTypeFromStringLiteral := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
        members := createSymbolTable()
        /* TODO(ExpressionStatement): forEachType(type, t => {             if (!(t.flags & TypeFlags.StringLiteral)) {                 return;             }             const name = escapeLeadingUnderscores((t as StringLiteralType).value);             const literalProp = createSymbol(SymbolFlags.Property, name);             literalProp.links.type = anyType;             if (t.symbol) {                 literalProp.declarations = t.symbol.declarations;                 literalProp.valueDeclaration = t.symbol.valueDeclaration;             }             members.set(name, literalProp);         }); */
        indexInfos := /* TODO(ConditionalExpression): type.flags & TypeFlags.String ? [createIndexInfo(stringType, emptyObjectType, /*isReadonly* / false)] : emptyArray */ TODO
         createAnonymousType(undefined, members, emptyArray, emptyArray, indexInfos)
    }
    inferTypeForHomomorphicMappedType := func(source Type, target MappedType, constraint IndexType) *Type {
        cacheKey := /* TODO(BinaryExpression): source.id + "," + target.id + "," + constraint.id */ TODO
        if /* TODO(PropertyAccessExpression): reverseHomomorphicMappedCache.has */ TODO(cacheKey) {
             /* TODO(PropertyAccessExpression): reverseHomomorphicMappedCache.get */ TODO(cacheKey)
        }
        type_ := createReverseMappedType(source, target, constraint)
        /* TODO(ExpressionStatement): reverseHomomorphicMappedCache.set(cacheKey, type); */
         type_
    }
    isPartiallyInferableType := func(type_ Type) bool {
         /* TODO(BinaryExpression): !(getObjectFlags(type) & ObjectFlags.NonInferrableType) ||             isObjectLiteralType(type) && some(getPropertiesOfType(type), prop => isPartiallyInferableType(getTypeOfSymbol(prop))) ||             isTupleType(type) && some(getElementTypes(type), isPartiallyInferableType) */ TODO
    }
    createReverseMappedType := func(source Type, target MappedType, constraint IndexType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(PrefixUnaryExpression): !(getIndexInfoOfType(source, stringType) || getPropertiesOfType(source).length !== 0 && isPartiallyInferableType(source)) */ TODO {
             undefined
        }
        if isArrayType(source) {
            elementType := inferReverseMappedType(/* TODO(ElementAccessExpression): getTypeArguments(source)[0] */ TODO, target, constraint)
            if /* TODO(PrefixUnaryExpression): !elementType */ TODO {
                 undefined
            }
             createArrayType(elementType, isReadonlyArrayType(source))
        }
        if isTupleType(source) {
            elementTypes := map_(getElementTypes(source), /* TODO(ArrowFunction): t => inferReverseMappedType(t, target, constraint) */ TODO)
            if /* TODO(PrefixUnaryExpression): !every(elementTypes, (t): t is Type => !!t) */ TODO {
                 undefined
            }
            elementFlags := /* TODO(ConditionalExpression): getMappedTypeModifiers(target) & MappedTypeModifiers.IncludeOptional ?                 sameMap(source.target.elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) :                 source.target.elementFlags */ TODO
             createTupleType(elementTypes, elementFlags, /* TODO(PropertyAccessExpression): source.target.readonly */ TODO, /* TODO(PropertyAccessExpression): source.target.labeledElementDeclarations */ TODO)
        }
        reversed := createObjectType(/* TODO(BinaryExpression): ObjectFlags.ReverseMapped | ObjectFlags.Anonymous */ TODO, undefined) /* as */ /* TODO(TypeReference): ReverseMappedType */
        /* TODO(ExpressionStatement): reversed.source = source; */
        /* TODO(ExpressionStatement): reversed.mappedType = target; */
        /* TODO(ExpressionStatement): reversed.constraintType = constraint; */
         reversed
    }
    getTypeOfReverseMappedSymbol := func(symbol ReverseMappedSymbol) Type {
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.type */ TODO {
            /* TODO(ExpressionStatement): links.type = inferReverseMappedType(symbol.links.propertyType, symbol.links.mappedType, symbol.links.constraintType) || unknownType; */
        }
         /* TODO(PropertyAccessExpression): links.type */ TODO
    }
    inferReverseMappedTypeWorker := func(sourceType Type, target MappedType, constraint IndexType) Type {
        typeParameter := getIndexedAccessType(/* TODO(PropertyAccessExpression): constraint.type */ TODO, getTypeParameterFromMappedType(target)) /* as */ /* TODO(TypeReference): TypeParameter */
        templateType := getTemplateTypeFromMappedType(target)
        inference := createInferenceInfo(typeParameter)
        /* TODO(ExpressionStatement): inferTypes([inference], sourceType, templateType); */
         /* TODO(BinaryExpression): getTypeFromInference(inference) || unknownType */ TODO
    }
    inferReverseMappedType := func(source Type, target MappedType, constraint IndexType) *Type {
        cacheKey := /* TODO(BinaryExpression): source.id + "," + target.id + "," + constraint.id */ TODO
        if /* TODO(PropertyAccessExpression): reverseMappedCache.has */ TODO(cacheKey) {
             /* TODO(BinaryExpression): reverseMappedCache.get(cacheKey) || unknownType */ TODO
        }
        /* TODO(ExpressionStatement): reverseMappedSourceStack.push(source); */
        /* TODO(ExpressionStatement): reverseMappedTargetStack.push(target); */
        saveExpandingFlags := reverseExpandingFlags
        if isDeeplyNestedType(source, reverseMappedSourceStack, /* TODO(PropertyAccessExpression): reverseMappedSourceStack.length */ TODO, 2) {
            /* TODO(BinaryExpression): reverseExpandingFlags |= ExpandingFlags.Source */
        }
        if isDeeplyNestedType(target, reverseMappedTargetStack, /* TODO(PropertyAccessExpression): reverseMappedTargetStack.length */ TODO, 2) {
            /* TODO(BinaryExpression): reverseExpandingFlags |= ExpandingFlags.Target */
        }
        type_
        if /* TODO(BinaryExpression): reverseExpandingFlags !== ExpandingFlags.Both */ TODO {
            /* TODO(ExpressionStatement): type = inferReverseMappedTypeWorker(source, target, constraint); */
        }
        /* TODO(ExpressionStatement): reverseMappedSourceStack.pop(); */
        /* TODO(ExpressionStatement): reverseMappedTargetStack.pop(); */
        /* TODO(ExpressionStatement): reverseExpandingFlags = saveExpandingFlags; */
        /* TODO(ExpressionStatement): reverseMappedCache.set(cacheKey, type); */
         type_
    }
    getUnmatchedProperties := func(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) IterableIterator[Symbol] {
        properties := getPropertiesOfType(target)
        /* TODO(ForOfStatement): for (const targetProp of properties) {             // TODO: remove this when we support static private identifier fields and find other solutions to get privateNamesAndStaticFields test to pass             if (isStaticPrivateIdentifierProperty(targetProp)) {                 continue;             }             if (requireOptionalProperties || !(targetProp.flags & SymbolFlags.Optional || getCheckFlags(targetProp) & CheckFlags.Partial)) {                 const sourceProp = getPropertyOfType(source, targetProp.escapedName);                 if (!sourceProp) {                     yield targetProp;                 }                 else if (matchDiscriminantProperties) {                     const targetType = getTypeOfSymbol(targetProp);                     if (targetType.flags & TypeFlags.Unit) {                         const sourceType = getTypeOfSymbol(sourceProp);                         if (!(sourceType.flags & TypeFlags.Any || getRegularTypeOfLiteralType(sourceType) === getRegularTypeOfLiteralType(targetType))) {                             yield targetProp;                         }                     }                 }             }         } */
    }
    getUnmatchedProperty := func(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) *Symbol {
         firstOrUndefinedIterator(getUnmatchedProperties(source, target, requireOptionalProperties, matchDiscriminantProperties))
    }
    tupleTypesDefinitelyUnrelated := func(source TupleTypeReference, target TupleTypeReference) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !(target.target.combinedFlags & ElementFlags.Variadic) && target.target.minLength > source.target.minLength ||             !(target.target.combinedFlags & ElementFlags.Variable) && (!!(source.target.combinedFlags & ElementFlags.Variable) || target.target.fixedLength < source.target.fixedLength) */ TODO
    }
    typesDefinitelyUnrelated := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(ConditionalExpression): isTupleType(source) && isTupleType(target) ? tupleTypesDefinitelyUnrelated(source, target) :             !!getUnmatchedProperty(source, target, /*requireOptionalProperties* / false, /*matchDiscriminantProperties* / true) &&             !!getUnmatchedProperty(target, source, /*requireOptionalProperties* / false, /*matchDiscriminantProperties* / false) */ TODO
    }
    getTypeFromInference := func(inference InferenceInfo) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
         /* TODO(ConditionalExpression): inference.candidates ? getUnionType(inference.candidates, UnionReduction.Subtype) :             inference.contraCandidates ? getIntersectionType(inference.contraCandidates) :             undefined */ TODO
    }
    hasSkipDirectInferenceFlag := func(node Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!getNodeLinks(node).skipDirectInference */ TODO
    }
    isFromInferenceBlockedSource := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(type.symbol && some(type.symbol.declarations, hasSkipDirectInferenceFlag)) */ TODO
    }
    templateLiteralTypesDefinitelyUnrelated := func(source TemplateLiteralType, target TemplateLiteralType) /* TODO(undefined): boolean */ TODO {
        sourceStart := /* TODO(ElementAccessExpression): source.texts[0] */ TODO
        targetStart := /* TODO(ElementAccessExpression): target.texts[0] */ TODO
        sourceEnd := /* TODO(ElementAccessExpression): source.texts[source.texts.length - 1] */ TODO
        targetEnd := /* TODO(ElementAccessExpression): target.texts[target.texts.length - 1] */ TODO
        startLen := /* TODO(PropertyAccessExpression): Math.min */ TODO(/* TODO(PropertyAccessExpression): sourceStart.length */ TODO, /* TODO(PropertyAccessExpression): targetStart.length */ TODO)
        endLen := /* TODO(PropertyAccessExpression): Math.min */ TODO(/* TODO(PropertyAccessExpression): sourceEnd.length */ TODO, /* TODO(PropertyAccessExpression): targetEnd.length */ TODO)
         /* TODO(BinaryExpression): sourceStart.slice(0, startLen) !== targetStart.slice(0, startLen) ||             sourceEnd.slice(sourceEnd.length - endLen) !== targetEnd.slice(targetEnd.length - endLen) */ TODO
    }
    isValidNumberString := func(s string, roundTripOnly bool) bool {
        if /* TODO(BinaryExpression): s === "" */ TODO {
            /* TODO(FalseKeyword): false */
        }
        n := /* TODO(PrefixUnaryExpression): +s */ TODO
         /* TODO(BinaryExpression): isFinite(n) && (!roundTripOnly || "" + n === s) */ TODO
    }
    parseBigIntLiteralType := func(text string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BigIntLiteralType */ TODO {
         getBigIntLiteralType(parseValidBigInt(text))
    }
    isMemberOfStringMapping := func(source Type, target Type) bool {
        if /* TODO(BinaryExpression): target.flags & TypeFlags.Any */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): target.flags & (TypeFlags.String | TypeFlags.TemplateLiteral) */ TODO {
             isTypeAssignableTo(source, target)
        }
        if /* TODO(BinaryExpression): target.flags & TypeFlags.StringMapping */ TODO {
            mappingStack := /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(WhileStatement): while (target.flags & TypeFlags.StringMapping) {                 mappingStack.unshift(target.symbol);                 target = (target as StringMappingType).type;             } */
            mappedSource := reduceLeft(mappingStack, /* TODO(ArrowFunction): (memo, value) => getStringMappingType(value, memo) */ TODO, source)
             /* TODO(BinaryExpression): mappedSource === source && isMemberOfStringMapping(source, target) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isValidTypeForTemplateLiteralPlaceholder := func(source Type, target Type) bool {
        if /* TODO(BinaryExpression): target.flags & TypeFlags.Intersection */ TODO {
             every(/* TODO(PropertyAccessExpression): (target as IntersectionType).types */ TODO, /* TODO(ArrowFunction): t => t === emptyTypeLiteralType || isValidTypeForTemplateLiteralPlaceholder(source, t) */ TODO)
        }
        if /* TODO(BinaryExpression): target.flags & TypeFlags.String || isTypeAssignableTo(source, target) */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): source.flags & TypeFlags.StringLiteral */ TODO {
            value := /* TODO(PropertyAccessExpression): (source as StringLiteralType).value */ TODO
             /* TODO(PrefixUnaryExpression): !!(target.flags & TypeFlags.Number && isValidNumberString(value, /*roundTripOnly* / false) ||                 target.flags & TypeFlags.BigInt && isValidBigIntString(value, /*roundTripOnly* / false) ||                 target.flags & (TypeFlags.BooleanLiteral | TypeFlags.Nullable) && value === (target as IntrinsicType).intrinsicName ||                 target.flags & TypeFlags.StringMapping && isMemberOfStringMapping(getStringLiteralType(value), target) ||                 target.flags & TypeFlags.TemplateLiteral && isTypeMatchedByTemplateLiteralType(source, target as TemplateLiteralType)) */ TODO
        }
        if /* TODO(BinaryExpression): source.flags & TypeFlags.TemplateLiteral */ TODO {
            texts := /* TODO(PropertyAccessExpression): (source as TemplateLiteralType).texts */ TODO
             /* TODO(BinaryExpression): texts.length === 2 && texts[0] === "" && texts[1] === "" && isTypeAssignableTo((source as TemplateLiteralType).types[0], target) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    inferTypesFromTemplateLiteralType := func(source Type, target TemplateLiteralType) /* TODO(ArrayType): Type[] */ any {
         /* TODO(ConditionalExpression): source.flags & TypeFlags.StringLiteral ? inferFromLiteralPartsToTemplateLiteral([(source as StringLiteralType).value], emptyArray, target) :             source.flags & TypeFlags.TemplateLiteral ?             arrayIsEqualTo((source as TemplateLiteralType).texts, target.texts) ? map((source as TemplateLiteralType).types, (s, i) => {                 return isTypeAssignableTo(getBaseConstraintOrType(s), getBaseConstraintOrType(target.types[i])) ? s : getStringLikeTypeForType(s);             }) :                 inferFromLiteralPartsToTemplateLiteral((source as TemplateLiteralType).texts, (source as TemplateLiteralType).types, target) :             undefined */ TODO
    }
    isTypeMatchedByTemplateLiteralType := func(source Type, target TemplateLiteralType) bool {
        inferences := inferTypesFromTemplateLiteralType(source, target)
         /* TODO(BinaryExpression): !!inferences && every(inferences, (r, i) => isValidTypeForTemplateLiteralPlaceholder(r, target.types[i])) */ TODO
    }
    getStringLikeTypeForType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): type.flags & (TypeFlags.Any | TypeFlags.StringLike) ? type : getTemplateLiteralType(["", ""], [type]) */ TODO
    }
    inferFromLiteralPartsToTemplateLiteral := func(sourceTexts []string, sourceTypes []Type, target TemplateLiteralType) /* TODO(ArrayType): Type[] */ any {
        lastSourceIndex := /* TODO(BinaryExpression): sourceTexts.length - 1 */ TODO
        sourceStartText := /* TODO(ElementAccessExpression): sourceTexts[0] */ TODO
        sourceEndText := /* TODO(ElementAccessExpression): sourceTexts[lastSourceIndex] */ TODO
        targetTexts := /* TODO(PropertyAccessExpression): target.texts */ TODO
        lastTargetIndex := /* TODO(BinaryExpression): targetTexts.length - 1 */ TODO
        targetStartText := /* TODO(ElementAccessExpression): targetTexts[0] */ TODO
        targetEndText := /* TODO(ElementAccessExpression): targetTexts[lastTargetIndex] */ TODO
        if /* TODO(BinaryExpression): lastSourceIndex === 0 && sourceStartText.length < targetStartText.length + targetEndText.length ||             !sourceStartText.startsWith(targetStartText) || !sourceEndText.endsWith(targetEndText) */ TODO {
            /* TODO(Identifier): undefined */
        }
        remainingEndText := /* TODO(PropertyAccessExpression): sourceEndText.slice */ TODO(0, /* TODO(BinaryExpression): sourceEndText.length - targetEndText.length */ TODO)
        var matches []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        seg := 0
        pos := /* TODO(PropertyAccessExpression): targetStartText.length */ TODO
        /* TODO(ForStatement): for (let i = 1; i < lastTargetIndex; i++) {             const delim = targetTexts[i];             if (delim.length > 0) {                 let s = seg;                 let p = pos;                 while (true) {                     p = getSourceText(s).indexOf(delim, p);                     if (p >= 0) break;                     s++;                     if (s === sourceTexts.length) return undefined;                     p = 0;                 }                 addMatch(s, p);                 pos += delim.length;             }             else if (pos < getSourceText(seg).length) {                 addMatch(seg, pos + 1);             }             else if (seg < lastSourceIndex) {                 addMatch(seg + 1, 0);             }             else {                 return undefined;             }         } */
        /* TODO(ExpressionStatement): addMatch(lastSourceIndex, getSourceText(lastSourceIndex).length); */
         matches
        getSourceText := func(index number) /* TODO(undefined): string */ TODO {
             /* TODO(ConditionalExpression): index < lastSourceIndex ? sourceTexts[index] : remainingEndText */ TODO
        }
        addMatch := func(s number, p number) {
            matchType := /* TODO(ConditionalExpression): s === seg ?                 getStringLiteralType(getSourceText(s).slice(pos, p)) :                 getTemplateLiteralType(                     [sourceTexts[seg].slice(pos), ...sourceTexts.slice(seg + 1, s), getSourceText(s).slice(0, p)],                     sourceTypes.slice(seg, s),                 ) */ TODO
            /* TODO(ExpressionStatement): matches.push(matchType); */
            /* TODO(ExpressionStatement): seg = s; */
            /* TODO(ExpressionStatement): pos = p; */
        }
    }
    isTupleOfSelf := func(typeParameter TypeParameter, type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isTupleType(type) && getTupleElementType(type, 0) === getIndexedAccessType(typeParameter, getNumberLiteralType(0)) && !getTypeOfPropertyOfType(type, "1" as __String) */ TODO
    }
    inferTypes := func(inferences []InferenceInfo, originalSource Type, originalTarget Type, priority /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferencePriority */ TODO /* = */ /* TODO(PropertyAccessExpression): InferencePriority.None */, contravariant /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) {
        bivariant := /* TODO(FalseKeyword): false */ TODO
        var propagationType Type
        var inferencePriority number = /* TODO(PropertyAccessExpression): InferencePriority.MaxValue */ TODO
        var visited Map[string, number]
        var sourceStack []Type
        var targetStack []Type
        expandingFlags := /* TODO(PropertyAccessExpression): ExpandingFlags.None */ TODO
        /* TODO(ExpressionStatement): inferFromTypes(originalSource, originalTarget); */
        inferFromTypes := func(source Type, target Type) {
            if /* TODO(BinaryExpression): !couldContainTypeVariables(target) || isNoInferType(target) */ TODO {

            }
            if /* TODO(BinaryExpression): source === wildcardType || source === blockedStringType */ TODO {
                savePropagationType := propagationType
                /* TODO(ExpressionStatement): propagationType = source; */
                /* TODO(ExpressionStatement): inferFromTypes(target, target); */
                /* TODO(ExpressionStatement): propagationType = savePropagationType; */

            }
            if /* TODO(BinaryExpression): source.aliasSymbol && source.aliasSymbol === target.aliasSymbol */ TODO {
                if /* TODO(PropertyAccessExpression): source.aliasTypeArguments */ TODO {
                    params := /* TODO(NonNullExpression): getSymbolLinks(source.aliasSymbol).typeParameters! */ TODO
                    minParams := getMinTypeArgumentCount(params)
                    sourceTypes := fillMissingTypeArguments(/* TODO(PropertyAccessExpression): source.aliasTypeArguments */ TODO, params, minParams, isInJSFile(/* TODO(PropertyAccessExpression): source.aliasSymbol.valueDeclaration */ TODO))
                    targetTypes := fillMissingTypeArguments(/* TODO(PropertyAccessExpression): target.aliasTypeArguments */ TODO, params, minParams, isInJSFile(/* TODO(PropertyAccessExpression): source.aliasSymbol.valueDeclaration */ TODO))
                    /* TODO(ExpressionStatement): inferFromTypeArguments(sourceTypes, targetTypes!, getAliasVariances(source.aliasSymbol)); */
                }

            }
            if /* TODO(BinaryExpression): source === target && source.flags & TypeFlags.UnionOrIntersection */ TODO {
                /* TODO(ForOfStatement): for (const t of (source as UnionOrIntersectionType).types) {                     inferFromTypes(t, t);                 } */

            }
            if /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
                TODO_IDENTIFIER := inferFromMatchingTypes(/* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? (source as UnionType).types : [source] */ TODO, /* TODO(PropertyAccessExpression): (target as UnionType).types */ TODO, isTypeOrBaseIdenticalTo)
                TODO_IDENTIFIER := inferFromMatchingTypes(tempSources, tempTargets, isTypeCloselyMatchedBy)
                if /* TODO(BinaryExpression): targets.length === 0 */ TODO {

                }
                /* TODO(ExpressionStatement): target = getUnionType(targets); */
                if /* TODO(BinaryExpression): sources.length === 0 */ TODO {
                    /* TODO(ExpressionStatement): inferWithPriority(source, target, InferencePriority.NakedTypeVariable); */

                }
                /* TODO(ExpressionStatement): source = getUnionType(sources); */
            } else if /* TODO(BinaryExpression): target.flags & TypeFlags.Intersection && !every((target as IntersectionType).types, isNonGenericObjectType) */ TODO {
                if /* TODO(PrefixUnaryExpression): !(source.flags & TypeFlags.Union) */ TODO {
                    TODO_IDENTIFIER := inferFromMatchingTypes(/* TODO(ConditionalExpression): source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source] */ TODO, /* TODO(PropertyAccessExpression): (target as IntersectionType).types */ TODO, isTypeIdenticalTo)
                    if /* TODO(BinaryExpression): sources.length === 0 || targets.length === 0 */ TODO {

                    }
                    /* TODO(ExpressionStatement): source = getIntersectionType(sources); */
                    /* TODO(ExpressionStatement): target = getIntersectionType(targets); */
                }
            }
            if /* TODO(BinaryExpression): target.flags & (TypeFlags.IndexedAccess | TypeFlags.Substitution) */ TODO {
                if isNoInferType(target) {

                }
                /* TODO(ExpressionStatement): target = getActualTypeVariable(target); */
            }
            if /* TODO(BinaryExpression): target.flags & TypeFlags.TypeVariable */ TODO {
                if isFromInferenceBlockedSource(source) {

                }
                inference := getInferenceInfoForType(target)
                if inference {
                    if /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.NonInferrableType || source === nonInferrableAnyType */ TODO {

                    }
                    if /* TODO(PrefixUnaryExpression): !inference.isFixed */ TODO {
                        candidate := /* TODO(BinaryExpression): propagationType || source */ TODO
                        if /* TODO(BinaryExpression): candidate === blockedStringType */ TODO {

                        }
                        if /* TODO(BinaryExpression): inference.priority === undefined || priority < inference.priority */ TODO {
                            /* TODO(ExpressionStatement): inference.candidates = undefined; */
                            /* TODO(ExpressionStatement): inference.contraCandidates = undefined; */
                            /* TODO(ExpressionStatement): inference.topLevel = true; */
                            /* TODO(ExpressionStatement): inference.priority = priority; */
                        }
                        if /* TODO(BinaryExpression): priority === inference.priority */ TODO {
                            if isTupleOfSelf(/* TODO(PropertyAccessExpression): inference.typeParameter */ TODO, candidate) {

                            }
                            if /* TODO(BinaryExpression): contravariant && !bivariant */ TODO {
                                if /* TODO(PrefixUnaryExpression): !contains(inference.contraCandidates, candidate) */ TODO {
                                    /* TODO(ExpressionStatement): inference.contraCandidates = append(inference.contraCandidates, candidate); */
                                    /* TODO(ExpressionStatement): clearCachedInferences(inferences); */
                                }
                            } else if /* TODO(PrefixUnaryExpression): !contains(inference.candidates, candidate) */ TODO {
                                /* TODO(ExpressionStatement): inference.candidates = append(inference.candidates, candidate); */
                                /* TODO(ExpressionStatement): clearCachedInferences(inferences); */
                            }
                        }
                        if /* TODO(BinaryExpression): !(priority & InferencePriority.ReturnType) && target.flags & TypeFlags.TypeParameter && inference.topLevel && !isTypeParameterAtTopLevel(originalTarget, target as TypeParameter) */ TODO {
                            /* TODO(ExpressionStatement): inference.topLevel = false; */
                            /* TODO(ExpressionStatement): clearCachedInferences(inferences); */
                        }
                    }
                    /* TODO(ExpressionStatement): inferencePriority = Math.min(inferencePriority, priority); */

                }
                simplified := getSimplifiedType(target, /* TODO(FalseKeyword): false */ TODO)
                if /* TODO(BinaryExpression): simplified !== target */ TODO {
                    /* TODO(ExpressionStatement): inferFromTypes(source, simplified); */
                } else if /* TODO(BinaryExpression): target.flags & TypeFlags.IndexedAccess */ TODO {
                    indexType := getSimplifiedType(/* TODO(PropertyAccessExpression): (target as IndexedAccessType).indexType */ TODO, /* TODO(FalseKeyword): false */ TODO)
                    if /* TODO(BinaryExpression): indexType.flags & TypeFlags.Instantiable */ TODO {
                        simplified := distributeIndexOverObjectType(getSimplifiedType(/* TODO(PropertyAccessExpression): (target as IndexedAccessType).objectType */ TODO, /* TODO(FalseKeyword): false */ TODO), indexType, /* TODO(FalseKeyword): false */ TODO)
                        if /* TODO(BinaryExpression): simplified && simplified !== target */ TODO {
                            /* TODO(ExpressionStatement): inferFromTypes(source, simplified); */
                        }
                    }
                }
            }
            if /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.Reference && getObjectFlags(target) & ObjectFlags.Reference && (                     (source as TypeReference).target === (target as TypeReference).target || isArrayType(source) && isArrayType(target)                 ) &&                 !((source as TypeReference).node && (target as TypeReference).node) */ TODO {
                /* TODO(ExpressionStatement): inferFromTypeArguments(getTypeArguments(source as TypeReference), getTypeArguments(target as TypeReference), getVariances((source as TypeReference).target)); */
            } else if /* TODO(BinaryExpression): source.flags & TypeFlags.Index && target.flags & TypeFlags.Index */ TODO {
                /* TODO(ExpressionStatement): inferFromContravariantTypes((source as IndexType).type, (target as IndexType).type); */
            } else if /* TODO(BinaryExpression): (isLiteralType(source) || source.flags & TypeFlags.String) && target.flags & TypeFlags.Index */ TODO {
                empty := createEmptyObjectTypeFromStringLiteral(source)
                /* TODO(ExpressionStatement): inferFromContravariantTypesWithPriority(empty, (target as IndexType).type, InferencePriority.LiteralKeyof); */
            } else if /* TODO(BinaryExpression): source.flags & TypeFlags.IndexedAccess && target.flags & TypeFlags.IndexedAccess */ TODO {
                /* TODO(ExpressionStatement): inferFromTypes((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType); */
                /* TODO(ExpressionStatement): inferFromTypes((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType); */
            } else if /* TODO(BinaryExpression): source.flags & TypeFlags.StringMapping && target.flags & TypeFlags.StringMapping */ TODO {
                if /* TODO(BinaryExpression): (source as StringMappingType).symbol === (target as StringMappingType).symbol */ TODO {
                    /* TODO(ExpressionStatement): inferFromTypes((source as StringMappingType).type, (target as StringMappingType).type); */
                }
            } else if /* TODO(BinaryExpression): source.flags & TypeFlags.Substitution */ TODO {
                /* TODO(ExpressionStatement): inferFromTypes((source as SubstitutionType).baseType, target); */
                /* TODO(ExpressionStatement): inferWithPriority(getSubstitutionIntersection(source as SubstitutionType), target, InferencePriority.SubstituteSource); */
            } else if /* TODO(BinaryExpression): target.flags & TypeFlags.Conditional */ TODO {
                /* TODO(ExpressionStatement): invokeOnce(source, target as ConditionalType, inferToConditionalType); */
            } else if /* TODO(BinaryExpression): target.flags & TypeFlags.UnionOrIntersection */ TODO {
                /* TODO(ExpressionStatement): inferToMultipleTypes(source, (target as UnionOrIntersectionType).types, target.flags); */
            } else if /* TODO(BinaryExpression): source.flags & TypeFlags.Union */ TODO {
                sourceTypes := /* TODO(PropertyAccessExpression): (source as UnionOrIntersectionType).types */ TODO
                /* TODO(ForOfStatement): for (const sourceType of sourceTypes) {                     inferFromTypes(sourceType, target);                 } */
            } else if /* TODO(BinaryExpression): target.flags & TypeFlags.TemplateLiteral */ TODO {
                /* TODO(ExpressionStatement): inferToTemplateLiteralType(source, target as TemplateLiteralType); */
            } else {
                /* TODO(ExpressionStatement): source = getReducedType(source); */
                if /* TODO(BinaryExpression): isGenericMappedType(source) && isGenericMappedType(target) */ TODO {
                    /* TODO(ExpressionStatement): invokeOnce(source, target, inferFromGenericMappedTypes); */
                }
                if /* TODO(PrefixUnaryExpression): !(priority & InferencePriority.NoConstraints && source.flags & (TypeFlags.Intersection | TypeFlags.Instantiable)) */ TODO {
                    apparentSource := getApparentType(source)
                    if /* TODO(BinaryExpression): apparentSource !== source && !(apparentSource.flags & (TypeFlags.Object | TypeFlags.Intersection)) */ TODO {
                         inferFromTypes(apparentSource, target)
                    }
                    /* TODO(ExpressionStatement): source = apparentSource; */
                }
                if /* TODO(BinaryExpression): source.flags & (TypeFlags.Object | TypeFlags.Intersection) */ TODO {
                    /* TODO(ExpressionStatement): invokeOnce(source, target, inferFromObjectTypes); */
                }
            }
        }
        inferWithPriority := func(source Type, target Type, newPriority InferencePriority) {
            savePriority := priority
            /* TODO(ExpressionStatement): priority |= newPriority; */
            /* TODO(ExpressionStatement): inferFromTypes(source, target); */
            /* TODO(ExpressionStatement): priority = savePriority; */
        }
        inferFromContravariantTypesWithPriority := func(source Type, target Type, newPriority InferencePriority) {
            savePriority := priority
            /* TODO(ExpressionStatement): priority |= newPriority; */
            /* TODO(ExpressionStatement): inferFromContravariantTypes(source, target); */
            /* TODO(ExpressionStatement): priority = savePriority; */
        }
        inferToMultipleTypesWithPriority := func(source Type, targets []Type, targetFlags TypeFlags, newPriority InferencePriority) {
            savePriority := priority
            /* TODO(ExpressionStatement): priority |= newPriority; */
            /* TODO(ExpressionStatement): inferToMultipleTypes(source, targets, targetFlags); */
            /* TODO(ExpressionStatement): priority = savePriority; */
        }
        invokeOnce := func(source Source, target Target, action func(source Source, target Target) ) {
            key := /* TODO(BinaryExpression): source.id + "," + target.id */ TODO
            status := /* TODO(BinaryExpression): visited && visited.get(key) */ TODO
            if /* TODO(BinaryExpression): status !== undefined */ TODO {
                /* TODO(ExpressionStatement): inferencePriority = Math.min(inferencePriority, status); */

            }
            /* TODO(ExpressionStatement): (visited || (visited = new Map<string, number>())).set(key, InferencePriority.Circularity); */
            saveInferencePriority := inferencePriority
            /* TODO(ExpressionStatement): inferencePriority = InferencePriority.MaxValue; */
            saveExpandingFlags := expandingFlags
            /* TODO(ExpressionStatement): (sourceStack ??= []).push(source); */
            /* TODO(ExpressionStatement): (targetStack ??= []).push(target); */
            if isDeeplyNestedType(source, sourceStack, /* TODO(PropertyAccessExpression): sourceStack.length */ TODO, 2) {
                /* TODO(BinaryExpression): expandingFlags |= ExpandingFlags.Source */
            }
            if isDeeplyNestedType(target, targetStack, /* TODO(PropertyAccessExpression): targetStack.length */ TODO, 2) {
                /* TODO(BinaryExpression): expandingFlags |= ExpandingFlags.Target */
            }
            if /* TODO(BinaryExpression): expandingFlags !== ExpandingFlags.Both */ TODO {
                /* TODO(ExpressionStatement): action(source, target); */
            } else {
                /* TODO(ExpressionStatement): inferencePriority = InferencePriority.Circularity; */
            }
            /* TODO(ExpressionStatement): targetStack.pop(); */
            /* TODO(ExpressionStatement): sourceStack.pop(); */
            /* TODO(ExpressionStatement): expandingFlags = saveExpandingFlags; */
            /* TODO(ExpressionStatement): visited.set(key, inferencePriority); */
            /* TODO(ExpressionStatement): inferencePriority = Math.min(inferencePriority, saveInferencePriority); */
        }
        inferFromMatchingTypes := func(sources []Type, targets []Type, matches func(s Type, t Type) bool) /* TODO(TupleType): [Type[], Type[]] */ TODO {
            var matchedSources /* TODO(ArrayType): Type[] */ any
            var matchedTargets /* TODO(ArrayType): Type[] */ any
            /* TODO(ForOfStatement): for (const t of targets) {                 for (const s of sources) {                     if (matches(s, t)) {                         inferFromTypes(s, t);                         matchedSources = appendIfUnique(matchedSources, s);                         matchedTargets = appendIfUnique(matchedTargets, t);                     }                 }             } */
             /* TODO(ArrayLiteralExpression): [                 matchedSources ? filter(sources, t => !contains(matchedSources, t)) : sources,                 matchedTargets ? filter(targets, t => !contains(matchedTargets, t)) : targets,             ] */ TODO
        }
        inferFromTypeArguments := func(sourceTypes []Type, targetTypes []Type, variances []VarianceFlags) {
            count := /* TODO(ConditionalExpression): sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length */ TODO
            /* TODO(ForStatement): for (let i = 0; i < count; i++) {                 if (i < variances.length && (variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Contravariant) {                     inferFromContravariantTypes(sourceTypes[i], targetTypes[i]);                 }                 else {                     inferFromTypes(sourceTypes[i], targetTypes[i]);                 }             } */
        }
        inferFromContravariantTypes := func(source Type, target Type) {
            /* TODO(ExpressionStatement): contravariant = !contravariant; */
            /* TODO(ExpressionStatement): inferFromTypes(source, target); */
            /* TODO(ExpressionStatement): contravariant = !contravariant; */
        }
        inferFromContravariantTypesIfStrictFunctionTypes := func(source Type, target Type) {
            if /* TODO(BinaryExpression): strictFunctionTypes || priority & InferencePriority.AlwaysStrict */ TODO {
                /* TODO(ExpressionStatement): inferFromContravariantTypes(source, target); */
            } else {
                /* TODO(ExpressionStatement): inferFromTypes(source, target); */
            }
        }
        getInferenceInfoForType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo | undefined */ TODO {
            if /* TODO(BinaryExpression): type.flags & TypeFlags.TypeVariable */ TODO {
                /* TODO(ForOfStatement): for (const inference of inferences) {                     if (type === inference.typeParameter) {                         return inference;                     }                 } */
            }
             undefined
        }
        getSingleTypeVariableFromIntersectionTypes := func(types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
            var typeVariable *Type
            /* TODO(ForOfStatement): for (const type of types) {                 const t = type.flags & TypeFlags.Intersection && find((type as IntersectionType).types, t => !!getInferenceInfoForType(t));                 if (!t || typeVariable && t !== typeVariable) {                     return undefined;                 }                 typeVariable = t;             } */
             typeVariable
        }
        inferToMultipleTypes := func(source Type, targets []Type, targetFlags TypeFlags) {
            typeVariableCount := 0
            if /* TODO(BinaryExpression): targetFlags & TypeFlags.Union */ TODO {
                var nakedTypeVariable *Type
                sources := /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? (source as UnionType).types : [source] */ TODO
                matched := /* TODO(NewExpression): new Array<boolean>(sources.length) */ TODO
                inferenceCircularity := /* TODO(FalseKeyword): false */ TODO
                /* TODO(ForOfStatement): for (const t of targets) {                     if (getInferenceInfoForType(t)) {                         nakedTypeVariable = t;                         typeVariableCount++;                     }                     else {                         for (let i = 0; i < sources.length; i++) {                             const saveInferencePriority = inferencePriority;                             inferencePriority = InferencePriority.MaxValue;                             inferFromTypes(sources[i], t);                             if (inferencePriority === priority) matched[i] = true;                             inferenceCircularity = inferenceCircularity || inferencePriority === InferencePriority.Circularity;                             inferencePriority = Math.min(inferencePriority, saveInferencePriority);                         }                     }                 } */
                if /* TODO(BinaryExpression): typeVariableCount === 0 */ TODO {
                    intersectionTypeVariable := getSingleTypeVariableFromIntersectionTypes(targets)
                    if intersectionTypeVariable {
                        /* TODO(ExpressionStatement): inferWithPriority(source, intersectionTypeVariable, InferencePriority.NakedTypeVariable); */
                    }

                }
                if /* TODO(BinaryExpression): typeVariableCount === 1 && !inferenceCircularity */ TODO {
                    unmatched := flatMap(sources, /* TODO(ArrowFunction): (s, i) => matched[i] ? undefined : s */ TODO)
                    if /* TODO(PropertyAccessExpression): unmatched.length */ TODO {
                        /* TODO(ExpressionStatement): inferFromTypes(getUnionType(unmatched), nakedTypeVariable!); */

                    }
                }
            } else {
                /* TODO(ForOfStatement): for (const t of targets) {                     if (getInferenceInfoForType(t)) {                         typeVariableCount++;                     }                     else {                         inferFromTypes(source, t);                     }                 } */
            }
            if /* TODO(ConditionalExpression): targetFlags & TypeFlags.Intersection ? typeVariableCount === 1 : typeVariableCount > 0 */ TODO {
                /* TODO(ForOfStatement): for (const t of targets) {                     if (getInferenceInfoForType(t)) {                         inferWithPriority(source, t, InferencePriority.NakedTypeVariable);                     }                 } */
            }
        }
        inferToMappedType := func(source Type, target MappedType, constraintType Type) bool {
            if /* TODO(BinaryExpression): (constraintType.flags & TypeFlags.Union) || (constraintType.flags & TypeFlags.Intersection) */ TODO {
                result := /* TODO(FalseKeyword): false */ TODO
                /* TODO(ForOfStatement): for (const type of (constraintType as (UnionType | IntersectionType)).types) {                     result = inferToMappedType(source, target, type) || result;                 } */
                 result
            }
            if /* TODO(BinaryExpression): constraintType.flags & TypeFlags.Index */ TODO {
                inference := getInferenceInfoForType(/* TODO(PropertyAccessExpression): (constraintType as IndexType).type */ TODO)
                if /* TODO(BinaryExpression): inference && !inference.isFixed && !isFromInferenceBlockedSource(source) */ TODO {
                    inferredType := inferTypeForHomomorphicMappedType(source, target, constraintType /* as */ /* TODO(TypeReference): IndexType */)
                    if inferredType {
                        /* TODO(ExpressionStatement): inferWithPriority(                             inferredType,                             inference.typeParameter,                             getObjectFlags(source) & ObjectFlags.NonInferrableType ?                                 InferencePriority.PartialHomomorphicMappedType :                                 InferencePriority.HomomorphicMappedType,                         ); */
                    }
                }
                 /* TODO(TrueKeyword): true */ TODO
            }
            if /* TODO(BinaryExpression): constraintType.flags & TypeFlags.TypeParameter */ TODO {
                /* TODO(ExpressionStatement): inferWithPriority(getIndexType(source, /*indexFlags* / !!source.pattern ? IndexFlags.NoIndexSignatures : IndexFlags.None), constraintType, InferencePriority.MappedTypeConstraint); */
                extendedConstraint := getConstraintOfType(constraintType)
                if /* TODO(BinaryExpression): extendedConstraint && inferToMappedType(source, target, extendedConstraint) */ TODO {
                     /* TODO(TrueKeyword): true */ TODO
                }
                propTypes := map_(getPropertiesOfType(source), getTypeOfSymbol)
                indexTypes := map_(getIndexInfosOfType(source), /* TODO(ArrowFunction): info => info !== enumNumberIndexInfo ? info.type : neverType */ TODO)
                /* TODO(ExpressionStatement): inferFromTypes(getUnionType(concatenate(propTypes, indexTypes)), getTemplateTypeFromMappedType(target)); */
                 /* TODO(TrueKeyword): true */ TODO
            }
             /* TODO(FalseKeyword): false */ TODO
        }
        inferToConditionalType := func(source Type, target ConditionalType) {
            if /* TODO(BinaryExpression): source.flags & TypeFlags.Conditional */ TODO {
                /* TODO(ExpressionStatement): inferFromTypes((source as ConditionalType).checkType, target.checkType); */
                /* TODO(ExpressionStatement): inferFromTypes((source as ConditionalType).extendsType, target.extendsType); */
                /* TODO(ExpressionStatement): inferFromTypes(getTrueTypeFromConditionalType(source as ConditionalType), getTrueTypeFromConditionalType(target)); */
                /* TODO(ExpressionStatement): inferFromTypes(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target)); */
            } else {
                targetTypes := /* TODO(ArrayLiteralExpression): [getTrueTypeFromConditionalType(target), getFalseTypeFromConditionalType(target)] */ TODO
                /* TODO(ExpressionStatement): inferToMultipleTypesWithPriority(source, targetTypes, target.flags, contravariant ? InferencePriority.ContravariantConditional : 0); */
            }
        }
        inferToTemplateLiteralType := func(source Type, target TemplateLiteralType) {
            matches := inferTypesFromTemplateLiteralType(source, target)
            types := /* TODO(PropertyAccessExpression): target.types */ TODO
            if /* TODO(BinaryExpression): matches || every(target.texts, s => s.length === 0) */ TODO {
                /* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                     const source = matches ? matches[i] : neverType;                     const target = types[i];                      // If we are inferring from a string literal type to a type variable whose constraint includes one of the                     // allowed template literal placeholder types, infer from a literal type corresponding to the constraint.                     if (source.flags & TypeFlags.StringLiteral && target.flags & TypeFlags.TypeVariable) {                         const inferenceContext = getInferenceInfoForType(target);                         const constraint = inferenceContext ? getBaseConstraintOfType(inferenceContext.typeParameter) : undefined;                         if (constraint && !isTypeAny(constraint)) {                             const constraintTypes = constraint.flags & TypeFlags.Union ? (constraint as UnionType).types : [constraint];                             let allTypeFlags: TypeFlags = reduceLeft(constraintTypes, (flags, t) => flags | t.flags, 0 as TypeFlags);                              // If the constraint contains `string`, we don't need to look for a more preferred type                             if (!(allTypeFlags & TypeFlags.String)) {                                 const str = (source as StringLiteralType).value;                                  // If the type contains `number` or a number literal and the string isn't a valid number, exclude numbers                                 if (allTypeFlags & TypeFlags.NumberLike && !isValidNumberString(str, /*roundTripOnly* / true)) {                                     allTypeFlags &= ~TypeFlags.NumberLike;                                 }                                  // If the type contains `bigint` or a bigint literal and the string isn't a valid bigint, exclude bigints                                 if (allTypeFlags & TypeFlags.BigIntLike && !isValidBigIntString(str, /*roundTripOnly* / true)) {                                     allTypeFlags &= ~TypeFlags.BigIntLike;                                 }                                  // for each type in the constraint, find the highest priority matching type                                 const matchingType = reduceLeft(constraintTypes, (left, right) =>                                     !(right.flags & allTypeFlags) ? left :                                         left.flags & TypeFlags.String ? left : right.flags & TypeFlags.String ? source :                                         left.flags & TypeFlags.TemplateLiteral ? left : right.flags & TypeFlags.TemplateLiteral && isTypeMatchedByTemplateLiteralType(source, right as TemplateLiteralType) ? source :                                         left.flags & TypeFlags.StringMapping ? left : right.flags & TypeFlags.StringMapping && str === applyStringMapping(right.symbol, str) ? source :                                         left.flags & TypeFlags.StringLiteral ? left : right.flags & TypeFlags.StringLiteral && (right as StringLiteralType).value === str ? right :                                         left.flags & TypeFlags.Number ? left : right.flags & TypeFlags.Number ? getNumberLiteralType(+str) :                                         left.flags & TypeFlags.Enum ? left : right.flags & TypeFlags.Enum ? getNumberLiteralType(+str) :                                         left.flags & TypeFlags.NumberLiteral ? left : right.flags & TypeFlags.NumberLiteral && (right as NumberLiteralType).value === +str ? right :                                         left.flags & TypeFlags.BigInt ? left : right.flags & TypeFlags.BigInt ? parseBigIntLiteralType(str) :                                         left.flags & TypeFlags.BigIntLiteral ? left : right.flags & TypeFlags.BigIntLiteral && pseudoBigIntToString((right as BigIntLiteralType).value) === str ? right :                                         left.flags & TypeFlags.Boolean ? left : right.flags & TypeFlags.Boolean ? str === "true" ? trueType : str === "false" ? falseType : booleanType :                                         left.flags & TypeFlags.BooleanLiteral ? left : right.flags & TypeFlags.BooleanLiteral && (right as IntrinsicType).intrinsicName === str ? right :                                         left.flags & TypeFlags.Undefined ? left : right.flags & TypeFlags.Undefined && (right as IntrinsicType).intrinsicName === str ? right :                                         left.flags & TypeFlags.Null ? left : right.flags & TypeFlags.Null && (right as IntrinsicType).intrinsicName === str ? right :                                         left, neverType as Type);                                  if (!(matchingType.flags & TypeFlags.Never)) {                                     inferFromTypes(matchingType, target);                                     continue;                                 }                             }                         }                     }                      inferFromTypes(source, target);                 } */
            }
        }
        inferFromGenericMappedTypes := func(source MappedType, target MappedType) {
            /* TODO(ExpressionStatement): inferFromTypes(getConstraintTypeFromMappedType(source), getConstraintTypeFromMappedType(target)); */
            /* TODO(ExpressionStatement): inferFromTypes(getTemplateTypeFromMappedType(source), getTemplateTypeFromMappedType(target)); */
            sourceNameType := getNameTypeFromMappedType(source)
            targetNameType := getNameTypeFromMappedType(target)
            if /* TODO(BinaryExpression): sourceNameType && targetNameType */ TODO {
                /* TODO(CallExpression): inferFromTypes(sourceNameType, targetNameType) */
            }
        }
        inferFromObjectTypes := func(source Type, target Type) {
            if /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.Reference && getObjectFlags(target) & ObjectFlags.Reference && (                     (source as TypeReference).target === (target as TypeReference).target || isArrayType(source) && isArrayType(target)                 ) */ TODO {
                /* TODO(ExpressionStatement): inferFromTypeArguments(getTypeArguments(source as TypeReference), getTypeArguments(target as TypeReference), getVariances((source as TypeReference).target)); */

            }
            if /* TODO(BinaryExpression): isGenericMappedType(source) && isGenericMappedType(target) */ TODO {
                /* TODO(ExpressionStatement): inferFromGenericMappedTypes(source, target); */
            }
            if /* TODO(BinaryExpression): getObjectFlags(target) & ObjectFlags.Mapped && !(target as MappedType).declaration.nameType */ TODO {
                constraintType := getConstraintTypeFromMappedType(target /* as */ /* TODO(TypeReference): MappedType */)
                if inferToMappedType(source, target /* as */ /* TODO(TypeReference): MappedType */, constraintType) {

                }
            }
            if /* TODO(PrefixUnaryExpression): !typesDefinitelyUnrelated(source, target) */ TODO {
                if isArrayOrTupleType(source) {
                    if isTupleType(target) {
                        sourceArity := getTypeReferenceArity(source)
                        targetArity := getTypeReferenceArity(target)
                        elementTypes := getTypeArguments(target)
                        elementFlags := /* TODO(PropertyAccessExpression): target.target.elementFlags */ TODO
                        if /* TODO(BinaryExpression): isTupleType(source) && isTupleTypeStructureMatching(source, target) */ TODO {
                            /* TODO(ForStatement): for (let i = 0; i < targetArity; i++) {                                 inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);                             } */

                        }
                        startLength := /* TODO(ConditionalExpression): isTupleType(source) ? Math.min(source.target.fixedLength, target.target.fixedLength) : 0 */ TODO
                        endLength := /* TODO(PropertyAccessExpression): Math.min */ TODO(/* TODO(ConditionalExpression): isTupleType(source) ? getEndElementCount(source.target, ElementFlags.Fixed) : 0 */ TODO, /* TODO(ConditionalExpression): target.target.combinedFlags & ElementFlags.Variable ? getEndElementCount(target.target, ElementFlags.Fixed) : 0 */ TODO)
                        /* TODO(ForStatement): for (let i = 0; i < startLength; i++) {                             inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);                         } */
                        if /* TODO(BinaryExpression): !isTupleType(source) || sourceArity - startLength - endLength === 1 && source.target.elementFlags[startLength] & ElementFlags.Rest */ TODO {
                            restType := /* TODO(ElementAccessExpression): getTypeArguments(source)[startLength] */ TODO
                            /* TODO(ForStatement): for (let i = startLength; i < targetArity - endLength; i++) {                                 inferFromTypes(elementFlags[i] & ElementFlags.Variadic ? createArrayType(restType) : restType, elementTypes[i]);                             } */
                        } else {
                            middleLength := /* TODO(BinaryExpression): targetArity - startLength - endLength */ TODO
                            if /* TODO(BinaryExpression): middleLength === 2 */ TODO {
                                if /* TODO(BinaryExpression): elementFlags[startLength] & elementFlags[startLength + 1] & ElementFlags.Variadic */ TODO {
                                    targetInfo := getInferenceInfoForType(/* TODO(ElementAccessExpression): elementTypes[startLength] */ TODO)
                                    if /* TODO(BinaryExpression): targetInfo && targetInfo.impliedArity !== undefined */ TODO {
                                        /* TODO(ExpressionStatement): inferFromTypes(sliceTupleType(source, startLength, endLength + sourceArity - targetInfo.impliedArity), elementTypes[startLength]); */
                                        /* TODO(ExpressionStatement): inferFromTypes(sliceTupleType(source, startLength + targetInfo.impliedArity, endLength), elementTypes[startLength + 1]); */
                                    }
                                } else if /* TODO(BinaryExpression): elementFlags[startLength] & ElementFlags.Variadic && elementFlags[startLength + 1] & ElementFlags.Rest */ TODO {
                                    param := /* TODO(PropertyAccessExpression): getInferenceInfoForType(elementTypes[startLength])?.typeParameter */ TODO
                                    constraint := /* TODO(BinaryExpression): param && getBaseConstraintOfType(param) */ TODO
                                    if /* TODO(BinaryExpression): constraint && isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlags.Variable) */ TODO {
                                        impliedArity := /* TODO(PropertyAccessExpression): constraint.target.fixedLength */ TODO
                                        /* TODO(ExpressionStatement): inferFromTypes(sliceTupleType(source, startLength, sourceArity - (startLength + impliedArity)), elementTypes[startLength]); */
                                        /* TODO(ExpressionStatement): inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength + impliedArity, endLength)!, elementTypes[startLength + 1]); */
                                    }
                                } else if /* TODO(BinaryExpression): elementFlags[startLength] & ElementFlags.Rest && elementFlags[startLength + 1] & ElementFlags.Variadic */ TODO {
                                    param := /* TODO(PropertyAccessExpression): getInferenceInfoForType(elementTypes[startLength + 1])?.typeParameter */ TODO
                                    constraint := /* TODO(BinaryExpression): param && getBaseConstraintOfType(param) */ TODO
                                    if /* TODO(BinaryExpression): constraint && isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlags.Variable) */ TODO {
                                        impliedArity := /* TODO(PropertyAccessExpression): constraint.target.fixedLength */ TODO
                                        endIndex := /* TODO(BinaryExpression): sourceArity - getEndElementCount(target.target, ElementFlags.Fixed) */ TODO
                                        startIndex := /* TODO(BinaryExpression): endIndex - impliedArity */ TODO
                                        trailingSlice := createTupleType(/* TODO(PropertyAccessExpression): getTypeArguments(source).slice */ TODO(startIndex, endIndex), /* TODO(PropertyAccessExpression): source.target.elementFlags.slice */ TODO(startIndex, endIndex), /* TODO(FalseKeyword): false */ TODO, /* TODO(BinaryExpression): source.target.labeledElementDeclarations && source.target.labeledElementDeclarations.slice(startIndex, endIndex) */ TODO)
                                        /* TODO(ExpressionStatement): inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength, endLength + impliedArity)!, elementTypes[startLength]); */
                                        /* TODO(ExpressionStatement): inferFromTypes(trailingSlice, elementTypes[startLength + 1]); */
                                    }
                                }
                            } else if /* TODO(BinaryExpression): middleLength === 1 && elementFlags[startLength] & ElementFlags.Variadic */ TODO {
                                endsInOptional := /* TODO(BinaryExpression): target.target.elementFlags[targetArity - 1] & ElementFlags.Optional */ TODO
                                sourceSlice := sliceTupleType(source, startLength, endLength)
                                /* TODO(ExpressionStatement): inferWithPriority(sourceSlice, elementTypes[startLength], endsInOptional ? InferencePriority.SpeculativeTuple : 0); */
                            } else if /* TODO(BinaryExpression): middleLength === 1 && elementFlags[startLength] & ElementFlags.Rest */ TODO {
                                restType := getElementTypeOfSliceOfTupleType(source, startLength, endLength)
                                if restType {
                                    /* TODO(ExpressionStatement): inferFromTypes(restType, elementTypes[startLength]); */
                                }
                            }
                        }
                        /* TODO(ForStatement): for (let i = 0; i < endLength; i++) {                             inferFromTypes(getTypeArguments(source)[sourceArity - i - 1], elementTypes[targetArity - i - 1]);                         } */

                    }
                    if isArrayType(target) {
                        /* TODO(ExpressionStatement): inferFromIndexTypes(source, target); */

                    }
                }
                /* TODO(ExpressionStatement): inferFromProperties(source, target); */
                /* TODO(ExpressionStatement): inferFromSignatures(source, target, SignatureKind.Call); */
                /* TODO(ExpressionStatement): inferFromSignatures(source, target, SignatureKind.Construct); */
                /* TODO(ExpressionStatement): inferFromIndexTypes(source, target); */
            }
        }
        inferFromProperties := func(source Type, target Type) {
            properties := getPropertiesOfObjectType(target)
            /* TODO(ForOfStatement): for (const targetProp of properties) {                 const sourceProp = getPropertyOfType(source, targetProp.escapedName);                 if (sourceProp && !some(sourceProp.declarations, hasSkipDirectInferenceFlag)) {                     inferFromTypes(                         removeMissingType(getTypeOfSymbol(sourceProp), !!(sourceProp.flags & SymbolFlags.Optional)),                         removeMissingType(getTypeOfSymbol(targetProp), !!(targetProp.flags & SymbolFlags.Optional)),                     );                 }             } */
        }
        inferFromSignatures := func(source Type, target Type, kind SignatureKind) {
            sourceSignatures := getSignaturesOfType(source, kind)
            sourceLen := /* TODO(PropertyAccessExpression): sourceSignatures.length */ TODO
            if /* TODO(BinaryExpression): sourceLen > 0 */ TODO {
                targetSignatures := getSignaturesOfType(target, kind)
                targetLen := /* TODO(PropertyAccessExpression): targetSignatures.length */ TODO
                /* TODO(ForStatement): for (let i = 0; i < targetLen; i++) {                     const sourceIndex = Math.max(sourceLen - targetLen + i, 0);                     inferFromSignature(getBaseSignature(sourceSignatures[sourceIndex]), getErasedSignature(targetSignatures[i]));                 } */
            }
        }
        inferFromSignature := func(source Signature, target Signature) {
            if /* TODO(PrefixUnaryExpression): !(source.flags & SignatureFlags.IsNonInferrable) */ TODO {
                saveBivariant := bivariant
                kind := /* TODO(ConditionalExpression): target.declaration ? target.declaration.kind : SyntaxKind.Unknown */ TODO
                /* TODO(ExpressionStatement): bivariant = bivariant || kind === SyntaxKind.MethodDeclaration || kind === SyntaxKind.MethodSignature || kind === SyntaxKind.Constructor; */
                /* TODO(ExpressionStatement): applyToParameterTypes(source, target, inferFromContravariantTypesIfStrictFunctionTypes); */
                /* TODO(ExpressionStatement): bivariant = saveBivariant; */
            }
            /* TODO(ExpressionStatement): applyToReturnTypes(source, target, inferFromTypes); */
        }
        inferFromIndexTypes := func(source Type, target Type) {
            priority := /* TODO(ConditionalExpression): (getObjectFlags(source) & getObjectFlags(target) & ObjectFlags.Mapped) ? InferencePriority.HomomorphicMappedType : 0 */ TODO
            indexInfos := getIndexInfosOfType(target)
            if isObjectTypeWithInferableIndex(source) {
                /* TODO(ForOfStatement): for (const targetInfo of indexInfos) {                     const propTypes: Type[] = [];                     for (const prop of getPropertiesOfType(source)) {                         if (isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique), targetInfo.keyType)) {                             const propType = getTypeOfSymbol(prop);                             propTypes.push(prop.flags & SymbolFlags.Optional ? removeMissingOrUndefinedType(propType) : propType);                         }                     }                     for (const info of getIndexInfosOfType(source)) {                         if (isApplicableIndexType(info.keyType, targetInfo.keyType)) {                             propTypes.push(info.type);                         }                     }                     if (propTypes.length) {                         inferWithPriority(getUnionType(propTypes), targetInfo.type, priority);                     }                 } */
            }
            /* TODO(ForOfStatement): for (const targetInfo of indexInfos) {                 const sourceInfo = getApplicableIndexInfo(source, targetInfo.keyType);                 if (sourceInfo) {                     inferWithPriority(sourceInfo.type, targetInfo.type, priority);                 }             } */
        }
    }
    isTypeOrBaseIdenticalTo := func(s Type, t Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(ConditionalExpression): t === missingType ? s === t :             (isTypeIdenticalTo(s, t) || !!(t.flags & TypeFlags.String && s.flags & TypeFlags.StringLiteral || t.flags & TypeFlags.Number && s.flags & TypeFlags.NumberLiteral)) */ TODO
    }
    isTypeCloselyMatchedBy := func(s Type, t Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(s.flags & TypeFlags.Object && t.flags & TypeFlags.Object && s.symbol && s.symbol === t.symbol ||             s.aliasSymbol && s.aliasTypeArguments && s.aliasSymbol === t.aliasSymbol) */ TODO
    }
    hasPrimitiveConstraint := func(type_ TypeParameter) bool {
        constraint := getConstraintOfTypeParameter(type_)
         /* TODO(BinaryExpression): !!constraint && maybeTypeOfKind(constraint.flags & TypeFlags.Conditional ? getDefaultConstraintOfConditionalType(constraint as ConditionalType) : constraint, TypeFlags.Primitive | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) */ TODO
    }
    isObjectLiteralType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(getObjectFlags(type) & ObjectFlags.ObjectLiteral) */ TODO
    }
    isObjectOrArrayLiteralType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(getObjectFlags(type) & (ObjectFlags.ObjectLiteral | ObjectFlags.ArrayLiteral)) */ TODO
    }
    unionObjectAndArrayLiteralCandidates := func(candidates []Type) []Type {
        if /* TODO(BinaryExpression): candidates.length > 1 */ TODO {
            objectLiterals := filter(candidates, isObjectOrArrayLiteralType)
            if /* TODO(PropertyAccessExpression): objectLiterals.length */ TODO {
                literalsType := getUnionType(objectLiterals, /* TODO(PropertyAccessExpression): UnionReduction.Subtype */ TODO)
                 concatenate(filter(candidates, /* TODO(ArrowFunction): t => !isObjectOrArrayLiteralType(t) */ TODO), /* TODO(ArrayLiteralExpression): [literalsType] */ TODO)
            }
        }
         candidates
    }
    getContravariantInference := func(inference InferenceInfo) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): inference.priority! & InferencePriority.PriorityImpliesCombination ? getIntersectionType(inference.contraCandidates!) : getCommonSubtype(inference.contraCandidates!) */ TODO
    }
    getCovariantInference := func(inference InferenceInfo, signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        candidates := unionObjectAndArrayLiteralCandidates(/* TODO(NonNullExpression): inference.candidates! */ TODO)
        primitiveConstraint := /* TODO(BinaryExpression): hasPrimitiveConstraint(inference.typeParameter) || isConstTypeVariable(inference.typeParameter) */ TODO
        widenLiteralTypes := /* TODO(BinaryExpression): !primitiveConstraint && inference.topLevel &&             (inference.isFixed || !isTypeParameterAtTopLevelInReturnType(signature, inference.typeParameter)) */ TODO
        baseCandidates := /* TODO(ConditionalExpression): primitiveConstraint ? sameMap(candidates, getRegularTypeOfLiteralType) :             widenLiteralTypes ? sameMap(candidates, getWidenedLiteralType) :             candidates */ TODO
        unwidenedType := /* TODO(ConditionalExpression): inference.priority! & InferencePriority.PriorityImpliesCombination ?             getUnionType(baseCandidates, UnionReduction.Subtype) :             getCommonSupertype(baseCandidates) */ TODO
         getWidenedType(unwidenedType)
    }
    getInferredType := func(context InferenceContext, index number) Type {
        inference := /* TODO(ElementAccessExpression): context.inferences[index] */ TODO
        if /* TODO(PrefixUnaryExpression): !inference.inferredType */ TODO {
            var inferredType *Type
            var fallbackType *Type
            if /* TODO(PropertyAccessExpression): context.signature */ TODO {
                inferredCovariantType := /* TODO(ConditionalExpression): inference.candidates ? getCovariantInference(inference, context.signature) : undefined */ TODO
                inferredContravariantType := /* TODO(ConditionalExpression): inference.contraCandidates ? getContravariantInference(inference) : undefined */ TODO
                if /* TODO(BinaryExpression): inferredCovariantType || inferredContravariantType */ TODO {
                    preferCovariantType := /* TODO(BinaryExpression): inferredCovariantType && (!inferredContravariantType ||                         !(inferredCovariantType.flags & (TypeFlags.Never | TypeFlags.Any)) &&                             some(inference.contraCandidates, t => isTypeAssignableTo(inferredCovariantType, t)) &&                             every(context.inferences, other =>                                 other !== inference && getConstraintOfTypeParameter(other.typeParameter) !== inference.typeParameter ||                                 every(other.candidates, t => isTypeAssignableTo(t, inferredCovariantType)))) */ TODO
                    /* TODO(ExpressionStatement): inferredType = preferCovariantType ? inferredCovariantType : inferredContravariantType; */
                    /* TODO(ExpressionStatement): fallbackType = preferCovariantType ? inferredContravariantType : inferredCovariantType; */
                } else if /* TODO(BinaryExpression): context.flags & InferenceFlags.NoDefault */ TODO {
                    /* TODO(ExpressionStatement): inferredType = silentNeverType; */
                } else {
                    defaultType := getDefaultFromTypeParameter(/* TODO(PropertyAccessExpression): inference.typeParameter */ TODO)
                    if defaultType {
                        /* TODO(ExpressionStatement): inferredType = instantiateType(defaultType, mergeTypeMappers(createBackreferenceMapper(context, index), context.nonFixingMapper)); */
                    }
                }
            } else {
                /* TODO(ExpressionStatement): inferredType = getTypeFromInference(inference); */
            }
            /* TODO(ExpressionStatement): inference.inferredType = inferredType || getDefaultTypeArgumentType(!!(context.flags & InferenceFlags.AnyDefault)); */
            constraint := getConstraintOfTypeParameter(/* TODO(PropertyAccessExpression): inference.typeParameter */ TODO)
            if constraint {
                instantiatedConstraint := instantiateType(constraint, /* TODO(PropertyAccessExpression): context.nonFixingMapper */ TODO)
                if /* TODO(BinaryExpression): !inferredType || !context.compareTypes(inferredType, getTypeWithThisArgument(instantiatedConstraint, inferredType)) */ TODO {
                    /* TODO(ExpressionStatement): inference.inferredType = fallbackType && context.compareTypes(fallbackType, getTypeWithThisArgument(instantiatedConstraint, fallbackType)) ? fallbackType : instantiatedConstraint; */
                }
            }
        }
         /* TODO(PropertyAccessExpression): inference.inferredType */ TODO
    }
    getDefaultTypeArgumentType := func(isInJavaScriptFile bool) Type {
         /* TODO(ConditionalExpression): isInJavaScriptFile ? anyType : unknownType */ TODO
    }
    getInferredTypes := func(context InferenceContext) []Type {
        var result []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForStatement): for (let i = 0; i < context.inferences.length; i++) {             result.push(getInferredType(context, i));         } */
         result
    }
    getCannotFindNameDiagnosticForName := func(node Identifier) DiagnosticMessage {
        /* TODO(SwitchStatement): switch (node.escapedText) {             case "document":             case "console":                 return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom;             case "$":                 return compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery;             case "describe":             case "suite":             case "it":             case "test":                 return compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha;             case "process":             case "require":             case "Buffer":             case "module":                 return compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode;             case "Bun":                 return compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun_and_then_add_bun_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun;             case "Map":             case "Set":             case "Promise":             case "Symbol":             case "WeakMap":             case "WeakSet":             case "Iterator":             case "AsyncIterator":             case "SharedArrayBuffer":             case "Atomics":             case "AsyncIterable":             case "AsyncIterableIterator":             case "AsyncGenerator":             case "AsyncGeneratorFunction":             case "BigInt":             case "Reflect":             case "BigInt64Array":             case "BigUint64Array":                 return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later;             case "await":                 if (isCallExpression(node.parent)) {                     return Diagnostics.Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function;                 }                 // falls through             default:                 if (node.parent.kind === SyntaxKind.ShorthandPropertyAssignment) {                     return Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer;                 }                 else {                     return Diagnostics.Cannot_find_name_0;                 }         } */
    }
    getResolvedSymbol := func(node Identifier) Symbol {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedSymbol */ TODO {
            /* TODO(ExpressionStatement): links.resolvedSymbol = !nodeIsMissing(node) &&                     resolveName(                         node,                         node,                         SymbolFlags.Value | SymbolFlags.ExportValue,                         getCannotFindNameDiagnosticForName(node),                         !isWriteOnlyAccess(node),                         /*excludeGlobals* / false,                     ) || unknownSymbol; */
        }
         /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO
    }
    isInAmbientOrTypeNode := func(node Node) bool {
         /* TODO(PrefixUnaryExpression): !!(node.flags & NodeFlags.Ambient || findAncestor(node, n => isInterfaceDeclaration(n) || isTypeAliasDeclaration(n) || isTypeLiteralNode(n))) */ TODO
    }
    getFlowCacheKey := func(node Node, declaredType Type, initialType Type, flowContainer Node) /* TODO(StringKeyword): string */ any {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:                 if (!isThisInTypeQuery(node)) {                     const symbol = getResolvedSymbol(node as Identifier);                     return symbol !== unknownSymbol ? `${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}|${getSymbolId(symbol)}` : undefined;                 }                 // falls through             case SyntaxKind.ThisKeyword:                 return `0|${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}`;             case SyntaxKind.NonNullExpression:             case SyntaxKind.ParenthesizedExpression:                 return getFlowCacheKey((node as NonNullExpression | ParenthesizedExpression).expression, declaredType, initialType, flowContainer);             case SyntaxKind.QualifiedName:                 const left = getFlowCacheKey((node as QualifiedName).left, declaredType, initialType, flowContainer);                 return left && `${left}.${(node as QualifiedName).right.escapedText}`;             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 const propName = getAccessedPropertyName(node as AccessExpression);                 if (propName !== undefined) {                     const key = getFlowCacheKey((node as AccessExpression).expression, declaredType, initialType, flowContainer);                     return key && `${key}.${propName}`;                 }                 if (isElementAccessExpression(node) && isIdentifier(node.argumentExpression)) {                     const symbol = getResolvedSymbol(node.argumentExpression);                     if (isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol)) {                         const key = getFlowCacheKey((node as AccessExpression).expression, declaredType, initialType, flowContainer);                         return key && `${key}.@${getSymbolId(symbol)}`;                     }                 }                 break;             case SyntaxKind.ObjectBindingPattern:             case SyntaxKind.ArrayBindingPattern:             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.MethodDeclaration:                 // Handle pseudo-references originating in getNarrowedTypeOfSymbol.                 return `${getNodeId(node)}#${getTypeId(declaredType)}`;         } */
         undefined
    }
    isMatchingReference := func(source Node, target Node) bool {
        /* TODO(SwitchStatement): switch (target.kind) {             case SyntaxKind.ParenthesizedExpression:             case SyntaxKind.NonNullExpression:                 return isMatchingReference(source, (target as NonNullExpression | ParenthesizedExpression).expression);             case SyntaxKind.BinaryExpression:                 return (isAssignmentExpression(target) && isMatchingReference(source, target.left)) ||                     (isBinaryExpression(target) && target.operatorToken.kind === SyntaxKind.CommaToken && isMatchingReference(source, target.right));         } */
        /* TODO(SwitchStatement): switch (source.kind) {             case SyntaxKind.MetaProperty:                 return target.kind === SyntaxKind.MetaProperty                     && (source as MetaProperty).keywordToken === (target as MetaProperty).keywordToken                     && (source as MetaProperty).name.escapedText === (target as MetaProperty).name.escapedText;             case SyntaxKind.Identifier:             case SyntaxKind.PrivateIdentifier:                 return isThisInTypeQuery(source) ?                     target.kind === SyntaxKind.ThisKeyword :                     target.kind === SyntaxKind.Identifier && getResolvedSymbol(source as Identifier) === getResolvedSymbol(target as Identifier) ||                     (isVariableDeclaration(target) || isBindingElement(target)) &&                         getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(source as Identifier)) === getSymbolOfDeclaration(target);             case SyntaxKind.ThisKeyword:                 return target.kind === SyntaxKind.ThisKeyword;             case SyntaxKind.SuperKeyword:                 return target.kind === SyntaxKind.SuperKeyword;             case SyntaxKind.NonNullExpression:             case SyntaxKind.ParenthesizedExpression:                 return isMatchingReference((source as NonNullExpression | ParenthesizedExpression).expression, target);             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 const sourcePropertyName = getAccessedPropertyName(source as AccessExpression);                 if (sourcePropertyName !== undefined) {                     const targetPropertyName = isAccessExpression(target) ? getAccessedPropertyName(target) : undefined;                     if (targetPropertyName !== undefined) {                         return targetPropertyName === sourcePropertyName && isMatchingReference((source as AccessExpression).expression, (target as AccessExpression).expression);                     }                 }                 if (isElementAccessExpression(source) && isElementAccessExpression(target) && isIdentifier(source.argumentExpression) && isIdentifier(target.argumentExpression)) {                     const symbol = getResolvedSymbol(source.argumentExpression);                     if (symbol === getResolvedSymbol(target.argumentExpression) && (isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol))) {                         return isMatchingReference(source.expression, target.expression);                     }                 }                 break;             case SyntaxKind.QualifiedName:                 return isAccessExpression(target) &&                     (source as QualifiedName).right.escapedText === getAccessedPropertyName(target) &&                     isMatchingReference((source as QualifiedName).left, target.expression);             case SyntaxKind.BinaryExpression:                 return (isBinaryExpression(source) && source.operatorToken.kind === SyntaxKind.CommaToken && isMatchingReference(source.right, target));         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    getAccessedPropertyName := func(access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any) *__String {
        if isPropertyAccessExpression(access) {
             /* TODO(PropertyAccessExpression): access.name.escapedText */ TODO
        }
        if isElementAccessExpression(access) {
             tryGetElementAccessExpressionName(access)
        }
        if isBindingElement(access) {
            name := getDestructuringPropertyName(access)
             /* TODO(ConditionalExpression): name ? escapeLeadingUnderscores(name) : undefined */ TODO
        }
        if isParameter(access) {
             /* TODO(ParenthesizedExpression): ("" + access.parent.parameters.indexOf(access)) */ TODO /* as */ /* TODO(TypeReference): __String */
        }
         undefined
    }
    tryGetNameFromType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.UniqueESSymbol ? (type as UniqueESSymbolType).escapedName :             type.flags & TypeFlags.StringOrNumberLiteral ? escapeLeadingUnderscores("" + (type as StringLiteralType | NumberLiteralType).value) : undefined */ TODO
    }
    tryGetElementAccessExpressionName := func(node ElementAccessExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
         /* TODO(ConditionalExpression): isStringOrNumericLiteralLike(node.argumentExpression) ? escapeLeadingUnderscores(node.argumentExpression.text) :             isEntityNameExpression(node.argumentExpression) ? tryGetNameFromEntityNameExpression(node.argumentExpression) : undefined */ TODO
    }
    tryGetNameFromEntityNameExpression := func(node EntityNameOrEntityNameExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
        symbol := resolveEntityName(node, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO, /* TODO(TrueKeyword): true */ TODO)
        if /* TODO(BinaryExpression): !symbol || !(isConstantVariable(symbol) || (symbol.flags & SymbolFlags.EnumMember)) */ TODO {
            /* TODO(Identifier): undefined */
        }
        declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
        if /* TODO(BinaryExpression): declaration === undefined */ TODO {
            /* TODO(Identifier): undefined */
        }
        type_ := tryGetTypeFromEffectiveTypeNode(declaration)
        if type_ {
            name := tryGetNameFromType(type_)
            if /* TODO(BinaryExpression): name !== undefined */ TODO {
                 name
            }
        }
        if /* TODO(BinaryExpression): hasOnlyExpressionInitializer(declaration) && isBlockScopedNameDeclaredBeforeUse(declaration, node) */ TODO {
            initializer := getEffectiveInitializer(declaration)
            if initializer {
                initializerType := /* TODO(ConditionalExpression): isBindingPattern(declaration.parent) ? getTypeForBindingElement(declaration as BindingElement) : getTypeOfExpression(initializer) */ TODO
                 /* TODO(BinaryExpression): initializerType && tryGetNameFromType(initializerType) */ TODO
            }
            if isEnumMember(declaration) {
                 getTextOfPropertyName(/* TODO(PropertyAccessExpression): declaration.name */ TODO)
            }
        }
         undefined
    }
    containsMatchingReference := func(source Node, target Node) /* TODO(undefined): boolean */ TODO {
        /* TODO(WhileStatement): while (isAccessExpression(source)) {             source = source.expression;             if (isMatchingReference(source, target)) {                 return true;             }         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    optionalChainContainsReference := func(source Node, target Node) /* TODO(undefined): boolean */ TODO {
        /* TODO(WhileStatement): while (isOptionalChain(source)) {             source = source.expression;             if (isMatchingReference(source, target)) {                 return true;             }         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    isDiscriminantProperty := func(type_ *Type, name __String) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): type && type.flags & TypeFlags.Union */ TODO {
            prop := getUnionOrIntersectionProperty(type_ /* as */ /* TODO(TypeReference): UnionType */, name)
            if /* TODO(BinaryExpression): prop && getCheckFlags(prop) & CheckFlags.SyntheticProperty */ TODO {
                if /* TODO(BinaryExpression): (prop as TransientSymbol).links.isDiscriminantProperty === undefined */ TODO {
                    /* TODO(ExpressionStatement): (prop as TransientSymbol).links.isDiscriminantProperty = ((prop as TransientSymbol).links.checkFlags & CheckFlags.Discriminant) === CheckFlags.Discriminant &&                         !isGenericType(getTypeOfSymbol(prop)); */
                }
                 /* TODO(PrefixUnaryExpression): !!(prop as TransientSymbol).links.isDiscriminantProperty */ TODO
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    findDiscriminantProperties := func(sourceProperties []Symbol, target Type) /* TODO(ArrayType): Symbol[] */ any {
        var result /* TODO(ArrayType): Symbol[] */ any
        /* TODO(ForOfStatement): for (const sourceProperty of sourceProperties) {             if (isDiscriminantProperty(target, sourceProperty.escapedName)) {                 if (result) {                     result.push(sourceProperty);                     continue;                 }                 result = [sourceProperty];             }         } */
         result
    }
    mapTypesByKeyProperty := func(types []Type, name __String) /* TODO(undefined): Map<number, import("/home/jabaile/work/TypeScript/src/compiler/types").Type> | undefined */ TODO {
        map_ := /* TODO(NewExpression): new Map<TypeId, Type>() */ TODO
        count := 0
        /* TODO(ForOfStatement): for (const type of types) {             if (type.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive)) {                 const discriminant = getTypeOfPropertyOfType(type, name);                 if (discriminant) {                     if (!isLiteralType(discriminant)) {                         return undefined;                     }                     let duplicate = false;                     forEachType(discriminant, t => {                         const id = getTypeId(getRegularTypeOfLiteralType(t));                         const existing = map.get(id);                         if (!existing) {                             map.set(id, type);                         }                         else if (existing !== unknownType) {                             map.set(id, unknownType);                             duplicate = true;                         }                     });                     if (!duplicate) count++;                 }             }         } */
         /* TODO(ConditionalExpression): count >= 10 && count * 2 >= types.length ? map : undefined */ TODO
    }
    getKeyPropertyName := func(unionType UnionType) *__String {
        types := /* TODO(PropertyAccessExpression): unionType.types */ TODO
        if /* TODO(BinaryExpression): types.length < 10 || getObjectFlags(unionType) & ObjectFlags.PrimitiveUnion ||             countWhere(types, t => !!(t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive))) < 10 */ TODO {
             undefined
        }
        if /* TODO(BinaryExpression): unionType.keyPropertyName === undefined */ TODO {
            keyPropertyName := forEach(types, /* TODO(ArrowFunction): t =>                 t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive) ?                     forEach(getPropertiesOfType(t), p => isUnitType(getTypeOfSymbol(p)) ? p.escapedName : undefined) :                     undefined */ TODO)
            mapByKeyProperty := /* TODO(BinaryExpression): keyPropertyName && mapTypesByKeyProperty(types, keyPropertyName) */ TODO
            /* TODO(ExpressionStatement): unionType.keyPropertyName = mapByKeyProperty ? keyPropertyName : "" as __String; */
            /* TODO(ExpressionStatement): unionType.constituentMap = mapByKeyProperty; */
        }
         /* TODO(ConditionalExpression): (unionType.keyPropertyName as string).length ? unionType.keyPropertyName : undefined */ TODO
    }
    getConstituentTypeForKeyType := func(unionType UnionType, keyType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        result := /* TODO(PropertyAccessExpression): unionType.constituentMap?.get */ TODO(getTypeId(getRegularTypeOfLiteralType(keyType)))
         /* TODO(ConditionalExpression): result !== unknownType ? result : undefined */ TODO
    }
    getMatchingUnionConstituentForType := func(unionType UnionType, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        keyPropertyName := getKeyPropertyName(unionType)
        propType := /* TODO(BinaryExpression): keyPropertyName && getTypeOfPropertyOfType(type, keyPropertyName) */ TODO
         /* TODO(BinaryExpression): propType && getConstituentTypeForKeyType(unionType, propType) */ TODO
    }
    getMatchingUnionConstituentForObjectLiteral := func(unionType UnionType, node ObjectLiteralExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        keyPropertyName := getKeyPropertyName(unionType)
        propNode := /* TODO(BinaryExpression): keyPropertyName && find(node.properties, p =>             p.symbol && p.kind === SyntaxKind.PropertyAssignment &&             p.symbol.escapedName === keyPropertyName && isPossiblyDiscriminantValue(p.initializer)) */ TODO
        propType := /* TODO(BinaryExpression): propNode && getContextFreeTypeOfExpression((propNode as PropertyAssignment).initializer) */ TODO
         /* TODO(BinaryExpression): propType && getConstituentTypeForKeyType(unionType, propType) */ TODO
    }
    isOrContainsMatchingReference := func(source Node, target Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isMatchingReference(source, target) || containsMatchingReference(source, target) */ TODO
    }
    hasMatchingArgument := func(expression /* TODO(UnionType): CallExpression | NewExpression */ any, reference Node) /* TODO(undefined): boolean */ TODO {
        if /* TODO(PropertyAccessExpression): expression.arguments */ TODO {
            /* TODO(ForOfStatement): for (const argument of expression.arguments) {                 if (isOrContainsMatchingReference(reference, argument) || optionalChainContainsReference(argument, reference)) {                     return true;                 }             } */
        }
        if /* TODO(BinaryExpression): expression.expression.kind === SyntaxKind.PropertyAccessExpression &&             isOrContainsMatchingReference(reference, (expression.expression as PropertyAccessExpression).expression) */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    getFlowNodeId := func(flow FlowNode) number {
        if /* TODO(BinaryExpression): flow.id <= 0 */ TODO {
            /* TODO(ExpressionStatement): flow.id = nextFlowId; */
            /* TODO(ExpressionStatement): nextFlowId++; */
        }
         /* TODO(PropertyAccessExpression): flow.id */ TODO
    }
    typeMaybeAssignableTo := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
        if /* TODO(PrefixUnaryExpression): !(source.flags & TypeFlags.Union) */ TODO {
             isTypeAssignableTo(source, target)
        }
        /* TODO(ForOfStatement): for (const t of (source as UnionType).types) {             if (isTypeAssignableTo(t, target)) {                 return true;             }         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    getAssignmentReducedType := func(declaredType UnionType, assignedType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(BinaryExpression): declaredType === assignedType */ TODO {
             declaredType
        }
        if /* TODO(BinaryExpression): assignedType.flags & TypeFlags.Never */ TODO {
             assignedType
        }
        key := /* TODO(TemplateExpression): `A${getTypeId(declaredType)},${getTypeId(assignedType)}` */ TODO
         /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, getAssignmentReducedTypeWorker(declaredType, assignedType)) */ TODO
    }
    getAssignmentReducedTypeWorker := func(declaredType UnionType, assignedType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        filteredType := filterType(declaredType, /* TODO(ArrowFunction): t => typeMaybeAssignableTo(assignedType, t) */ TODO)
        reducedType := /* TODO(ConditionalExpression): assignedType.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(assignedType) ? mapType(filteredType, getFreshTypeOfLiteralType) : filteredType */ TODO
         /* TODO(ConditionalExpression): isTypeAssignableTo(assignedType, reducedType) ? reducedType : declaredType */ TODO
    }
    isFunctionObjectType := func(type_ ObjectType) bool {
        if /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.EvolvingArray */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        resolved := resolveStructuredTypeMembers(type_)
         /* TODO(PrefixUnaryExpression): !!(resolved.callSignatures.length || resolved.constructSignatures.length ||             resolved.members.get("bind" as __String) && isTypeSubtypeOf(type, globalFunctionType)) */ TODO
    }
    getTypeFacts := func(type_ Type, mask TypeFacts) TypeFacts {
         /* TODO(BinaryExpression): getTypeFactsWorker(type, mask) & mask */ TODO
    }
    hasTypeFacts := func(type_ Type, mask TypeFacts) bool {
         /* TODO(BinaryExpression): getTypeFacts(type, mask) !== 0 */ TODO
    }
    getTypeFactsWorker := func(type_ Type, callerOnlyNeeds TypeFacts) TypeFacts {
        if /* TODO(BinaryExpression): type.flags & (TypeFlags.Intersection | TypeFlags.Instantiable) */ TODO {
            /* TODO(ExpressionStatement): type = getBaseConstraintOfType(type) || unknownType; */
        }
        flags := /* TODO(PropertyAccessExpression): type.flags */ TODO
        if /* TODO(BinaryExpression): flags & (TypeFlags.String | TypeFlags.StringMapping) */ TODO {
             /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.StringStrictFacts : TypeFacts.StringFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral) */ TODO {
            isEmpty := /* TODO(BinaryExpression): flags & TypeFlags.StringLiteral && (type as StringLiteralType).value === "" */ TODO
             /* TODO(ConditionalExpression): strictNullChecks ?                 isEmpty ? TypeFacts.EmptyStringStrictFacts : TypeFacts.NonEmptyStringStrictFacts :                 isEmpty ? TypeFacts.EmptyStringFacts : TypeFacts.NonEmptyStringFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & (TypeFlags.Number | TypeFlags.Enum) */ TODO {
             /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.NumberStrictFacts : TypeFacts.NumberFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.NumberLiteral */ TODO {
            isZero := /* TODO(BinaryExpression): (type as NumberLiteralType).value === 0 */ TODO
             /* TODO(ConditionalExpression): strictNullChecks ?                 isZero ? TypeFacts.ZeroNumberStrictFacts : TypeFacts.NonZeroNumberStrictFacts :                 isZero ? TypeFacts.ZeroNumberFacts : TypeFacts.NonZeroNumberFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.BigInt */ TODO {
             /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.BigIntStrictFacts : TypeFacts.BigIntFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.BigIntLiteral */ TODO {
            isZero := isZeroBigInt(type_ /* as */ /* TODO(TypeReference): BigIntLiteralType */)
             /* TODO(ConditionalExpression): strictNullChecks ?                 isZero ? TypeFacts.ZeroBigIntStrictFacts : TypeFacts.NonZeroBigIntStrictFacts :                 isZero ? TypeFacts.ZeroBigIntFacts : TypeFacts.NonZeroBigIntFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.Boolean */ TODO {
             /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.BooleanStrictFacts : TypeFacts.BooleanFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.BooleanLike */ TODO {
             /* TODO(ConditionalExpression): strictNullChecks ?                 (type === falseType || type === regularFalseType) ? TypeFacts.FalseStrictFacts : TypeFacts.TrueStrictFacts :                 (type === falseType || type === regularFalseType) ? TypeFacts.FalseFacts : TypeFacts.TrueFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.Object */ TODO {
            possibleFacts := /* TODO(ConditionalExpression): strictNullChecks                 ? TypeFacts.EmptyObjectStrictFacts | TypeFacts.FunctionStrictFacts | TypeFacts.ObjectStrictFacts                 : TypeFacts.EmptyObjectFacts | TypeFacts.FunctionFacts | TypeFacts.ObjectFacts */ TODO
            if /* TODO(BinaryExpression): (callerOnlyNeeds & possibleFacts) === 0 */ TODO {
                 0
            }
             /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Anonymous && isEmptyObjectType(type as ObjectType) ?                 strictNullChecks ? TypeFacts.EmptyObjectStrictFacts : TypeFacts.EmptyObjectFacts :                 isFunctionObjectType(type as ObjectType) ?                 strictNullChecks ? TypeFacts.FunctionStrictFacts : TypeFacts.FunctionFacts :                 strictNullChecks ? TypeFacts.ObjectStrictFacts : TypeFacts.ObjectFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.Void */ TODO {
             /* TODO(PropertyAccessExpression): TypeFacts.VoidFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.Undefined */ TODO {
             /* TODO(PropertyAccessExpression): TypeFacts.UndefinedFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.Null */ TODO {
             /* TODO(PropertyAccessExpression): TypeFacts.NullFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.ESSymbolLike */ TODO {
             /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.SymbolStrictFacts : TypeFacts.SymbolFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.NonPrimitive */ TODO {
             /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.ObjectStrictFacts : TypeFacts.ObjectFacts */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.Never */ TODO {
             /* TODO(PropertyAccessExpression): TypeFacts.None */ TODO
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.Union */ TODO {
             reduceLeft(/* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, /* TODO(ArrowFunction): (facts, t) => facts | getTypeFactsWorker(t, callerOnlyNeeds) */ TODO, /* TODO(PropertyAccessExpression): TypeFacts.None */ TODO)
        }
        if /* TODO(BinaryExpression): flags & TypeFlags.Intersection */ TODO {
             getIntersectionTypeFacts(type_ /* as */ /* TODO(TypeReference): IntersectionType */, callerOnlyNeeds)
        }
         /* TODO(PropertyAccessExpression): TypeFacts.UnknownFacts */ TODO
    }
    getIntersectionTypeFacts := func(type_ IntersectionType, callerOnlyNeeds TypeFacts) TypeFacts {
        ignoreObjects := maybeTypeOfKind(type_, /* TODO(PropertyAccessExpression): TypeFlags.Primitive */ TODO)
        oredFacts := /* TODO(PropertyAccessExpression): TypeFacts.None */ TODO
        andedFacts := /* TODO(PropertyAccessExpression): TypeFacts.All */ TODO
        /* TODO(ForOfStatement): for (const t of type.types) {             if (!(ignoreObjects && t.flags & TypeFlags.Object)) {                 const f = getTypeFactsWorker(t, callerOnlyNeeds);                 oredFacts |= f;                 andedFacts &= f;             }         } */
         /* TODO(BinaryExpression): oredFacts & TypeFacts.OrFactsMask | andedFacts & TypeFacts.AndFactsMask */ TODO
    }
    getTypeWithFacts := func(type_ Type, include TypeFacts) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         filterType(type_, /* TODO(ArrowFunction): t => hasTypeFacts(t, include) */ TODO)
    }
    getAdjustedTypeWithFacts := func(type_ Type, facts TypeFacts) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        reduced := recombineUnknownType(getTypeWithFacts(/* TODO(ConditionalExpression): strictNullChecks && type.flags & TypeFlags.Unknown ? unknownUnionType : type */ TODO, facts))
        if strictNullChecks {
            /* TODO(SwitchStatement): switch (facts) {                 case TypeFacts.NEUndefined:                     return removeNullableByIntersection(reduced, TypeFacts.EQUndefined, TypeFacts.EQNull, TypeFacts.IsNull, nullType);                 case TypeFacts.NENull:                     return removeNullableByIntersection(reduced, TypeFacts.EQNull, TypeFacts.EQUndefined, TypeFacts.IsUndefined, undefinedType);                 case TypeFacts.NEUndefinedOrNull:                 case TypeFacts.Truthy:                     return mapType(reduced, t => hasTypeFacts(t, TypeFacts.EQUndefinedOrNull) ? getGlobalNonNullableTypeInstantiation(t) : t);             } */
        }
         reduced
    }
    removeNullableByIntersection := func(type_ Type, targetFacts TypeFacts, otherFacts TypeFacts, otherIncludesFacts TypeFacts, otherType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        facts := getTypeFacts(type_, /* TODO(BinaryExpression): TypeFacts.EQUndefined | TypeFacts.EQNull | TypeFacts.IsUndefined | TypeFacts.IsNull */ TODO)
        if /* TODO(PrefixUnaryExpression): !(facts & targetFacts) */ TODO {
             type_
        }
        emptyAndOtherUnion := getUnionType(/* TODO(ArrayLiteralExpression): [emptyObjectType, otherType] */ TODO)
         mapType(type_, /* TODO(ArrowFunction): t => hasTypeFacts(t, targetFacts) ? getIntersectionType([t, !(facts & otherIncludesFacts) && hasTypeFacts(t, otherFacts) ? emptyAndOtherUnion : emptyObjectType]) : t */ TODO)
    }
    recombineUnknownType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): type === unknownUnionType ? unknownType : type */ TODO
    }
    getTypeWithDefault := func(type_ Type, defaultExpression Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): defaultExpression ?             getUnionType([getNonUndefinedType(type), getTypeOfExpression(defaultExpression)]) :             type */ TODO
    }
    getTypeOfDestructuredProperty := func(type_ Type, name PropertyName) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        nameType := getLiteralTypeFromPropertyName(name)
        if /* TODO(PrefixUnaryExpression): !isTypeUsableAsPropertyName(nameType) */ TODO {
            /* TODO(Identifier): errorType */
        }
        text := getPropertyNameFromType(nameType)
         /* TODO(BinaryExpression): getTypeOfPropertyOfType(type, text) || includeUndefinedInIndexSignature(getApplicableIndexInfoForName(type, text)?.type) || errorType */ TODO
    }
    getTypeOfDestructuredArrayElement := func(type_ Type, index number) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(BinaryExpression): everyType(type, isTupleLikeType) && getTupleElementType(type, index) ||             includeUndefinedInIndexSignature(checkIteratedTypeOrElementType(IterationUse.Destructuring, type, undefinedType, /*errorNode* / undefined)) ||             errorType */ TODO
    }
    includeUndefinedInIndexSignature := func(type_ *Type) *Type {
        if /* TODO(PrefixUnaryExpression): !type */ TODO {
            /* TODO(Identifier): type */
        }
         /* TODO(ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ?             getUnionType([type, missingType]) :             type */ TODO
    }
    getTypeOfDestructuredSpreadExpression := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
         createArrayType(/* TODO(BinaryExpression): checkIteratedTypeOrElementType(IterationUse.Destructuring, type, undefinedType, /*errorNode* / undefined) || errorType */ TODO)
    }
    getAssignedTypeOfBinaryExpression := func(node BinaryExpression) Type {
        isDestructuringDefaultAssignment := /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.ArrayLiteralExpression && isDestructuringAssignmentTarget(node.parent) ||             node.parent.kind === SyntaxKind.PropertyAssignment && isDestructuringAssignmentTarget(node.parent.parent) */ TODO
         /* TODO(ConditionalExpression): isDestructuringDefaultAssignment ?             getTypeWithDefault(getAssignedType(node), node.right) :             getTypeOfExpression(node.right) */ TODO
    }
    isDestructuringAssignmentTarget := func(parent Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): parent.parent.kind === SyntaxKind.BinaryExpression && (parent.parent as BinaryExpression).left === parent ||             parent.parent.kind === SyntaxKind.ForOfStatement && (parent.parent as ForOfStatement).initializer === parent */ TODO
    }
    getAssignedTypeOfArrayLiteralElement := func(node ArrayLiteralExpression, element Expression) Type {
         getTypeOfDestructuredArrayElement(getAssignedType(node), /* TODO(PropertyAccessExpression): node.elements.indexOf */ TODO(element))
    }
    getAssignedTypeOfSpreadExpression := func(node SpreadElement) Type {
         getTypeOfDestructuredSpreadExpression(getAssignedType(/* TODO(PropertyAccessExpression): node.parent */ TODO /* as */ /* TODO(TypeReference): ArrayLiteralExpression */))
    }
    getAssignedTypeOfPropertyAssignment := func(node /* TODO(UnionType): PropertyAssignment | ShorthandPropertyAssignment */ any) Type {
         getTypeOfDestructuredProperty(getAssignedType(/* TODO(PropertyAccessExpression): node.parent */ TODO), /* TODO(PropertyAccessExpression): node.name */ TODO)
    }
    getAssignedTypeOfShorthandPropertyAssignment := func(node ShorthandPropertyAssignment) Type {
         getTypeWithDefault(getAssignedTypeOfPropertyAssignment(node), /* TODO(NonNullExpression): node.objectAssignmentInitializer! */ TODO)
    }
    getAssignedType := func(node Expression) Type {
        TODO_IDENTIFIER := node
        /* TODO(SwitchStatement): switch (parent.kind) {             case SyntaxKind.ForInStatement:                 return stringType;             case SyntaxKind.ForOfStatement:                 return checkRightHandSideOfForOf(parent as ForOfStatement) || errorType;             case SyntaxKind.BinaryExpression:                 return getAssignedTypeOfBinaryExpression(parent as BinaryExpression);             case SyntaxKind.DeleteExpression:                 return undefinedType;             case SyntaxKind.ArrayLiteralExpression:                 return getAssignedTypeOfArrayLiteralElement(parent as ArrayLiteralExpression, node);             case SyntaxKind.SpreadElement:                 return getAssignedTypeOfSpreadExpression(parent as SpreadElement);             case SyntaxKind.PropertyAssignment:                 return getAssignedTypeOfPropertyAssignment(parent as PropertyAssignment);             case SyntaxKind.ShorthandPropertyAssignment:                 return getAssignedTypeOfShorthandPropertyAssignment(parent as ShorthandPropertyAssignment);         } */
         errorType
    }
    getInitialTypeOfBindingElement := func(node BindingElement) Type {
        pattern := /* TODO(PropertyAccessExpression): node.parent */ TODO
        parentType := getInitialType(/* TODO(PropertyAccessExpression): pattern.parent */ TODO /* as */ /* TODO(UnionType): VariableDeclaration | BindingElement */)
        type_ := /* TODO(ConditionalExpression): pattern.kind === SyntaxKind.ObjectBindingPattern ?             getTypeOfDestructuredProperty(parentType, node.propertyName || node.name as Identifier) :             !node.dotDotDotToken ?             getTypeOfDestructuredArrayElement(parentType, pattern.elements.indexOf(node)) :             getTypeOfDestructuredSpreadExpression(parentType) */ TODO
         getTypeWithDefault(type_, /* TODO(NonNullExpression): node.initializer! */ TODO)
    }
    getTypeOfInitializer := func(node Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        links := getNodeLinks(node)
         /* TODO(BinaryExpression): links.resolvedType || getTypeOfExpression(node) */ TODO
    }
    getInitialTypeOfVariableDeclaration := func(node VariableDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(PropertyAccessExpression): node.initializer */ TODO {
             getTypeOfInitializer(/* TODO(PropertyAccessExpression): node.initializer */ TODO)
        }
        if /* TODO(BinaryExpression): node.parent.parent.kind === SyntaxKind.ForInStatement */ TODO {
             stringType
        }
        if /* TODO(BinaryExpression): node.parent.parent.kind === SyntaxKind.ForOfStatement */ TODO {
             /* TODO(BinaryExpression): checkRightHandSideOfForOf(node.parent.parent) || errorType */ TODO
        }
         errorType
    }
    getInitialType := func(node /* TODO(UnionType): VariableDeclaration | BindingElement */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): node.kind === SyntaxKind.VariableDeclaration ?             getInitialTypeOfVariableDeclaration(node) :             getInitialTypeOfBindingElement(node) */ TODO
    }
    isEmptyArrayAssignment := func(node /* TODO(UnionType): VariableDeclaration | BindingElement | Expression */ any) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): node.kind === SyntaxKind.VariableDeclaration && (node as VariableDeclaration).initializer &&                 isEmptyArrayLiteral((node as VariableDeclaration).initializer!) ||             node.kind !== SyntaxKind.BindingElement && node.parent.kind === SyntaxKind.BinaryExpression &&                 isEmptyArrayLiteral((node.parent as BinaryExpression).right) */ TODO
    }
    getReferenceCandidate := func(node Expression) Expression {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ParenthesizedExpression:                 return getReferenceCandidate((node as ParenthesizedExpression).expression);             case SyntaxKind.BinaryExpression:                 switch ((node as BinaryExpression).operatorToken.kind) {                     case SyntaxKind.EqualsToken:                     case SyntaxKind.BarBarEqualsToken:                     case SyntaxKind.AmpersandAmpersandEqualsToken:                     case SyntaxKind.QuestionQuestionEqualsToken:                         return getReferenceCandidate((node as BinaryExpression).left);                     case SyntaxKind.CommaToken:                         return getReferenceCandidate((node as BinaryExpression).right);                 }         } */
         node
    }
    getReferenceRoot := func(node Node) Node {
        TODO_IDENTIFIER := node
         /* TODO(ConditionalExpression): parent.kind === SyntaxKind.ParenthesizedExpression ||                 parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken && (parent as BinaryExpression).left === node ||                 parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.CommaToken && (parent as BinaryExpression).right === node ?             getReferenceRoot(parent) : node */ TODO
    }
    getTypeOfSwitchClause := func(clause /* TODO(UnionType): CaseClause | DefaultClause */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(BinaryExpression): clause.kind === SyntaxKind.CaseClause */ TODO {
             getRegularTypeOfLiteralType(getTypeOfExpression(/* TODO(PropertyAccessExpression): clause.expression */ TODO))
        }
         neverType
    }
    getSwitchClauseTypes := func(switchStatement SwitchStatement) []Type {
        links := getNodeLinks(switchStatement)
        if /* TODO(PrefixUnaryExpression): !links.switchTypes */ TODO {
            /* TODO(ExpressionStatement): links.switchTypes = []; */
            /* TODO(ForOfStatement): for (const clause of switchStatement.caseBlock.clauses) {                 links.switchTypes.push(getTypeOfSwitchClause(clause));             } */
        }
         /* TODO(PropertyAccessExpression): links.switchTypes */ TODO
    }
    getSwitchClauseTypeOfWitnesses := func(switchStatement SwitchStatement) /* TODO(ArrayType): (string | undefined)[] */ any {
        if some(/* TODO(PropertyAccessExpression): switchStatement.caseBlock.clauses */ TODO, /* TODO(ArrowFunction): clause => clause.kind === SyntaxKind.CaseClause && !isStringLiteralLike(clause.expression) */ TODO) {
             undefined
        }
        var witnesses []/* TODO(StringKeyword): string */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForOfStatement): for (const clause of switchStatement.caseBlock.clauses) {             const text = clause.kind === SyntaxKind.CaseClause ? (clause.expression as StringLiteralLike).text : undefined;             witnesses.push(text && !contains(witnesses, text) ? text : undefined);         } */
         witnesses
    }
    eachTypeContainedIn := func(source Type, types []Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? !forEach((source as UnionType).types, t => !contains(types, t)) : contains(types, source) */ TODO
    }
    isTypeSubsetOf := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(source === target || source.flags & TypeFlags.Never || target.flags & TypeFlags.Union && isTypeSubsetOfUnion(source, target as UnionType)) */ TODO
    }
    isTypeSubsetOfUnion := func(source Type, target UnionType) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): source.flags & TypeFlags.Union */ TODO {
            /* TODO(ForOfStatement): for (const t of (source as UnionType).types) {                 if (!containsType(target.types, t)) {                     return false;                 }             } */
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): source.flags & TypeFlags.EnumLike && getBaseTypeOfEnumLikeType(source as LiteralType) === target */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
         containsType(/* TODO(PropertyAccessExpression): target.types */ TODO, source)
    }
    forEachType := func(type_ Type, f func(t Type) *T) *T {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? forEach((type as UnionType).types, f) : f(type) */ TODO
    }
    someType := func(type_ Type, f func(t Type) bool) bool {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? some((type as UnionType).types, f) : f(type) */ TODO
    }
    everyType := func(type_ Type, f func(t Type) bool) bool {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? every((type as UnionType).types, f) : f(type) */ TODO
    }
    everyContainedType := func(type_ Type, f func(t Type) bool) bool {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.UnionOrIntersection ? every((type as UnionOrIntersectionType).types, f) : f(type) */ TODO
    }
    filterType := func(type_ Type, f func(t Type) bool) Type {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
            types := /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO
            filtered := filter(types, f)
            if /* TODO(BinaryExpression): filtered === types */ TODO {
                 type_
            }
            origin := /* TODO(PropertyAccessExpression): (type as UnionType).origin */ TODO
            var newOrigin *Type
            if /* TODO(BinaryExpression): origin && origin.flags & TypeFlags.Union */ TODO {
                originTypes := /* TODO(PropertyAccessExpression): (origin as UnionType).types */ TODO
                originFiltered := filter(originTypes, /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.Union) || f(t) */ TODO)
                if /* TODO(BinaryExpression): originTypes.length - originFiltered.length === types.length - filtered.length */ TODO {
                    if /* TODO(BinaryExpression): originFiltered.length === 1 */ TODO {
                         /* TODO(ElementAccessExpression): originFiltered[0] */ TODO
                    }
                    /* TODO(ExpressionStatement): newOrigin = createOriginUnionOrIntersectionType(TypeFlags.Union, originFiltered); */
                }
            }
             getUnionTypeFromSortedList(filtered, /* TODO(BinaryExpression): (type as UnionType).objectFlags & (ObjectFlags.PrimitiveUnion | ObjectFlags.ContainsIntersections) */ TODO, undefined, undefined, newOrigin)
        }
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Never || f(type) ? type : neverType */ TODO
    }
    removeType := func(type_ Type, targetType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         filterType(type_, /* TODO(ArrowFunction): t => t !== targetType */ TODO)
    }
    countTypes := func(type_ Type) /* TODO(undefined): number */ TODO {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).types.length : 1 */ TODO
    }
    // OVERLOAD: mapType := func(type_ Type, mapper func(t Type) Type, noReductions bool) Type
    // OVERLOAD: mapType := func(type_ Type, mapper func(t Type) *Type, noReductions bool) *Type
    mapType := func(type_ Type, mapper func(t Type) *Type, noReductions bool) *Type {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Never */ TODO {
             type_
        }
        if /* TODO(PrefixUnaryExpression): !(type.flags & TypeFlags.Union) */ TODO {
             mapper(type_)
        }
        origin := /* TODO(PropertyAccessExpression): (type as UnionType).origin */ TODO
        types := /* TODO(ConditionalExpression): origin && origin.flags & TypeFlags.Union ? (origin as UnionType).types : (type as UnionType).types */ TODO
        var mappedTypes /* TODO(ArrayType): Type[] */ any
        changed := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForOfStatement): for (const t of types) {             const mapped = t.flags & TypeFlags.Union ? mapType(t, mapper, noReductions) : mapper(t);             changed ||= t !== mapped;             if (mapped) {                 if (!mappedTypes) {                     mappedTypes = [mapped];                 }                 else {                     mappedTypes.push(mapped);                 }             }         } */
         /* TODO(ConditionalExpression): changed ? mappedTypes && getUnionType(mappedTypes, noReductions ? UnionReduction.None : UnionReduction.Literal) : type */ TODO
    }
    mapTypeWithAlias := func(type_ Type, mapper func(t Type) Type, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Union && aliasSymbol ?             getUnionType(map((type as UnionType).types, mapper), UnionReduction.Literal, aliasSymbol, aliasTypeArguments) :             mapType(type, mapper) */ TODO
    }
    extractTypesOfKind := func(type_ Type, kind TypeFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         filterType(type_, /* TODO(ArrowFunction): t => (t.flags & kind) !== 0 */ TODO)
    }
    replacePrimitivesWithLiterals := func(typeWithPrimitives Type, typeWithLiterals Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(BinaryExpression): maybeTypeOfKind(typeWithPrimitives, TypeFlags.String | TypeFlags.TemplateLiteral | TypeFlags.Number | TypeFlags.BigInt) &&             maybeTypeOfKind(typeWithLiterals, TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping | TypeFlags.NumberLiteral | TypeFlags.BigIntLiteral) */ TODO {
             mapType(typeWithPrimitives, /* TODO(ArrowFunction): t =>                 t.flags & TypeFlags.String ? extractTypesOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) :                     isPatternLiteralType(t) && !maybeTypeOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? extractTypesOfKind(typeWithLiterals, TypeFlags.StringLiteral) :                     t.flags & TypeFlags.Number ? extractTypesOfKind(typeWithLiterals, TypeFlags.Number | TypeFlags.NumberLiteral) :                     t.flags & TypeFlags.BigInt ? extractTypesOfKind(typeWithLiterals, TypeFlags.BigInt | TypeFlags.BigIntLiteral) : t */ TODO)
        }
         typeWithPrimitives
    }
    isIncomplete := func(flowType FlowType) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): flowType.flags === 0 */ TODO
    }
    getTypeFromFlowType := func(flowType FlowType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): flowType.flags === 0 ? flowType.type : flowType as Type */ TODO
    }
    createFlowType := func(type_ Type, incomplete bool) FlowType {
         /* TODO(ConditionalExpression): incomplete ? { flags: 0, type: type.flags & TypeFlags.Never ? silentNeverType : type } : type */ TODO
    }
    createEvolvingArrayType := func(elementType Type) EvolvingArrayType {
        result := createObjectType(/* TODO(PropertyAccessExpression): ObjectFlags.EvolvingArray */ TODO) /* as */ /* TODO(TypeReference): EvolvingArrayType */
        /* TODO(ExpressionStatement): result.elementType = elementType; */
         result
    }
    getEvolvingArrayType := func(elementType Type) EvolvingArrayType {
         /* TODO(BinaryExpression): evolvingArrayTypes[elementType.id] || (evolvingArrayTypes[elementType.id] = createEvolvingArrayType(elementType)) */ TODO
    }
    addEvolvingArrayElementType := func(evolvingArrayType EvolvingArrayType, node Expression) EvolvingArrayType {
        elementType := getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(getContextFreeTypeOfExpression(node)))
         /* TODO(ConditionalExpression): isTypeSubsetOf(elementType, evolvingArrayType.elementType) ? evolvingArrayType : getEvolvingArrayType(getUnionType([evolvingArrayType.elementType, elementType])) */ TODO
    }
    createFinalArrayType := func(elementType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): elementType.flags & TypeFlags.Never ?             autoArrayType :             createArrayType(                 elementType.flags & TypeFlags.Union ?                     getUnionType((elementType as UnionType).types, UnionReduction.Subtype) :                     elementType,             ) */ TODO
    }
    getFinalArrayType := func(evolvingArrayType EvolvingArrayType) Type {
         /* TODO(BinaryExpression): evolvingArrayType.finalArrayType || (evolvingArrayType.finalArrayType = createFinalArrayType(evolvingArrayType.elementType)) */ TODO
    }
    finalizeEvolvingArrayType := func(type_ Type) Type {
         /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.EvolvingArray ? getFinalArrayType(type as EvolvingArrayType) : type */ TODO
    }
    getElementTypeOfEvolvingArrayType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.EvolvingArray ? (type as EvolvingArrayType).elementType : neverType */ TODO
    }
    isEvolvingArrayTypeList := func(types []Type) /* TODO(undefined): boolean */ TODO {
        hasEvolvingArrayType := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForOfStatement): for (const t of types) {             if (!(t.flags & TypeFlags.Never)) {                 if (!(getObjectFlags(t) & ObjectFlags.EvolvingArray)) {                     return false;                 }                 hasEvolvingArrayType = true;             }         } */
         hasEvolvingArrayType
    }
    isEvolvingArrayOperationTarget := func(node Node) /* TODO(undefined): boolean */ TODO {
        root := getReferenceRoot(node)
        parent := /* TODO(PropertyAccessExpression): root.parent */ TODO
        isLengthPushOrUnshift := /* TODO(BinaryExpression): isPropertyAccessExpression(parent) && (             parent.name.escapedText === "length" ||             parent.parent.kind === SyntaxKind.CallExpression                 && isIdentifier(parent.name)                 && isPushOrUnshiftIdentifier(parent.name)         ) */ TODO
        isElementAssignment := /* TODO(BinaryExpression): parent.kind === SyntaxKind.ElementAccessExpression &&             (parent as ElementAccessExpression).expression === root &&             parent.parent.kind === SyntaxKind.BinaryExpression &&             (parent.parent as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken &&             (parent.parent as BinaryExpression).left === parent &&             !isAssignmentTarget(parent.parent) &&             isTypeAssignableToKind(getTypeOfExpression((parent as ElementAccessExpression).argumentExpression), TypeFlags.NumberLike) */ TODO
         /* TODO(BinaryExpression): isLengthPushOrUnshift || isElementAssignment */ TODO
    }
    isDeclarationWithExplicitTypeAnnotation := func(node Declaration) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): (isVariableDeclaration(node) || isPropertyDeclaration(node) || isPropertySignature(node) || isParameter(node)) &&             !!(getEffectiveTypeAnnotationNode(node) ||                 isInJSFile(node) && hasInitializer(node) && node.initializer && isFunctionExpressionOrArrowFunction(node.initializer) && getEffectiveReturnTypeNode(node.initializer)) */ TODO
    }
    getExplicitTypeOfSymbol := func(symbol Symbol, diagnostic Diagnostic) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        /* TODO(ExpressionStatement): symbol = resolveSymbol(symbol); */
        if /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.ValueModule) */ TODO {
             getTypeOfSymbol(symbol)
        }
        if /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Variable | SymbolFlags.Property) */ TODO {
            if /* TODO(BinaryExpression): getCheckFlags(symbol) & CheckFlags.Mapped */ TODO {
                origin := /* TODO(PropertyAccessExpression): (symbol as MappedSymbol).links.syntheticOrigin */ TODO
                if /* TODO(BinaryExpression): origin && getExplicitTypeOfSymbol(origin) */ TODO {
                     getTypeOfSymbol(symbol)
                }
            }
            declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
            if declaration {
                if isDeclarationWithExplicitTypeAnnotation(declaration) {
                     getTypeOfSymbol(symbol)
                }
                if /* TODO(BinaryExpression): isVariableDeclaration(declaration) && declaration.parent.parent.kind === SyntaxKind.ForOfStatement */ TODO {
                    statement := /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO
                    expressionType := getTypeOfDottedName(/* TODO(PropertyAccessExpression): statement.expression */ TODO, undefined)
                    if expressionType {
                        use := /* TODO(ConditionalExpression): statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf */ TODO
                         checkIteratedTypeOrElementType(use, expressionType, undefinedType, undefined)
                    }
                }
                if diagnostic {
                    /* TODO(ExpressionStatement): addRelatedInfo(diagnostic, createDiagnosticForNode(declaration, Diagnostics._0_needs_an_explicit_type_annotation, symbolToString(symbol))); */
                }
            }
        }
    }
    getTypeOfDottedName := func(node Expression, diagnostic *Diagnostic) *Type {
        if /* TODO(PrefixUnaryExpression): !(node.flags & NodeFlags.InWithStatement) */ TODO {
            /* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.Identifier:                     const symbol = getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(node as Identifier));                     return getExplicitTypeOfSymbol(symbol, diagnostic);                 case SyntaxKind.ThisKeyword:                     return getExplicitThisType(node);                 case SyntaxKind.SuperKeyword:                     return checkSuperExpression(node);                 case SyntaxKind.PropertyAccessExpression: {                     const type = getTypeOfDottedName((node as PropertyAccessExpression).expression, diagnostic);                     if (type) {                         const name = (node as PropertyAccessExpression).name;                         let prop: Symbol | undefined;                         if (isPrivateIdentifier(name)) {                             if (!type.symbol) {                                 return undefined;                             }                             prop = getPropertyOfType(type, getSymbolNameForPrivateIdentifier(type.symbol, name.escapedText));                         }                         else {                             prop = getPropertyOfType(type, name.escapedText);                         }                         return prop && getExplicitTypeOfSymbol(prop, diagnostic);                     }                     return undefined;                 }                 case SyntaxKind.ParenthesizedExpression:                     return getTypeOfDottedName((node as ParenthesizedExpression).expression, diagnostic);             } */
        }
    }
    getEffectsSignature := func(node /* TODO(UnionType): CallExpression | InstanceofExpression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
        links := getNodeLinks(node)
        signature := /* TODO(PropertyAccessExpression): links.effectsSignature */ TODO
        if /* TODO(BinaryExpression): signature === undefined */ TODO {
            var funcType *Type
            if isBinaryExpression(node) {
                rightType := checkNonNullExpression(/* TODO(PropertyAccessExpression): node.right */ TODO)
                /* TODO(ExpressionStatement): funcType = getSymbolHasInstanceMethodOfObjectType(rightType); */
            } else if /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.ExpressionStatement */ TODO {
                /* TODO(ExpressionStatement): funcType = getTypeOfDottedName(node.expression, /*diagnostic* / undefined); */
            } else if /* TODO(BinaryExpression): node.expression.kind !== SyntaxKind.SuperKeyword */ TODO {
                if isOptionalChain(node) {
                    /* TODO(ExpressionStatement): funcType = checkNonNullType(                         getOptionalExpressionType(checkExpression(node.expression), node.expression),                         node.expression,                     ); */
                } else {
                    /* TODO(ExpressionStatement): funcType = checkNonNullExpression(node.expression); */
                }
            }
            signatures := getSignaturesOfType(/* TODO(BinaryExpression): funcType && getApparentType(funcType) || unknownType */ TODO, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
            candidate := /* TODO(ConditionalExpression): signatures.length === 1 && !signatures[0].typeParameters ? signatures[0] :                 some(signatures, hasTypePredicateOrNeverReturnType) ? getResolvedSignature(node) :                 undefined */ TODO
            /* TODO(ExpressionStatement): signature = links.effectsSignature = candidate && hasTypePredicateOrNeverReturnType(candidate) ? candidate : unknownSignature; */
        }
         /* TODO(ConditionalExpression): signature === unknownSignature ? undefined : signature */ TODO
    }
    hasTypePredicateOrNeverReturnType := func(signature Signature) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(getTypePredicateOfSignature(signature) ||             signature.declaration && (getReturnTypeFromAnnotation(signature.declaration) || unknownType).flags & TypeFlags.Never) */ TODO
    }
    getTypePredicateArgument := func(predicate TypePredicate, callExpression CallExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ TODO {
        if /* TODO(BinaryExpression): predicate.kind === TypePredicateKind.Identifier || predicate.kind === TypePredicateKind.AssertsIdentifier */ TODO {
             /* TODO(ElementAccessExpression): callExpression.arguments[predicate.parameterIndex] */ TODO
        }
        invokedExpression := skipParentheses(/* TODO(PropertyAccessExpression): callExpression.expression */ TODO)
         /* TODO(ConditionalExpression): isAccessExpression(invokedExpression) ? skipParentheses(invokedExpression.expression) : undefined */ TODO
    }
    reportFlowControlError := func(node Node) {
        block := findAncestor(node, isFunctionOrModuleBlock) /* as */ /* TODO(UnionType): Block | ModuleBlock | SourceFile */
        sourceFile := getSourceFileOfNode(node)
        span := getSpanOfTokenAtPosition(sourceFile, /* TODO(PropertyAccessExpression): block.statements.pos */ TODO)
        /* TODO(ExpressionStatement): diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_containing_function_or_module_body_is_too_large_for_control_flow_analysis)); */
    }
    isReachableFlowNode := func(flow FlowNode) /* TODO(undefined): boolean */ TODO {
        result := isReachableFlowNodeWorker(flow, /* TODO(FalseKeyword): false */ TODO)
        /* TODO(ExpressionStatement): lastFlowNode = flow; */
        /* TODO(ExpressionStatement): lastFlowNodeReachable = result; */
         result
    }
    isFalseExpression := func(expr Expression) bool {
        node := skipParentheses(expr, /* TODO(TrueKeyword): true */ TODO)
         /* TODO(BinaryExpression): node.kind === SyntaxKind.FalseKeyword || node.kind === SyntaxKind.BinaryExpression && (                     (node as BinaryExpression).operatorToken.kind === SyntaxKind.AmpersandAmpersandToken && (isFalseExpression((node as BinaryExpression).left) || isFalseExpression((node as BinaryExpression).right)) ||                     (node as BinaryExpression).operatorToken.kind === SyntaxKind.BarBarToken && isFalseExpression((node as BinaryExpression).left) && isFalseExpression((node as BinaryExpression).right)                 ) */ TODO
    }
    isReachableFlowNodeWorker := func(flow FlowNode, noCacheCheck bool) bool {
        /* TODO(WhileStatement): while (true) {             if (flow === lastFlowNode) {                 return lastFlowNodeReachable;             }             const flags = flow.flags;             if (flags & FlowFlags.Shared) {                 if (!noCacheCheck) {                     const id = getFlowNodeId(flow);                     const reachable = flowNodeReachable[id];                     return reachable !== undefined ? reachable : (flowNodeReachable[id] = isReachableFlowNodeWorker(flow, /*noCacheCheck* / true));                 }                 noCacheCheck = false;             }             if (flags & (FlowFlags.Assignment | FlowFlags.Condition | FlowFlags.ArrayMutation)) {                 flow = (flow as FlowAssignment | FlowCondition | FlowArrayMutation).antecedent;             }             else if (flags & FlowFlags.Call) {                 const signature = getEffectsSignature((flow as FlowCall).node);                 if (signature) {                     const predicate = getTypePredicateOfSignature(signature);                     if (predicate && predicate.kind === TypePredicateKind.AssertsIdentifier && !predicate.type) {                         const predicateArgument = (flow as FlowCall).node.arguments[predicate.parameterIndex];                         if (predicateArgument && isFalseExpression(predicateArgument)) {                             return false;                         }                     }                     if (getReturnTypeOfSignature(signature).flags & TypeFlags.Never) {                         return false;                     }                 }                 flow = (flow as FlowCall).antecedent;             }             else if (flags & FlowFlags.BranchLabel) {                 // A branching point is reachable if any branch is reachable.                 return some((flow as FlowLabel).antecedent, f => isReachableFlowNodeWorker(f, /*noCacheCheck* / false));             }             else if (flags & FlowFlags.LoopLabel) {                 const antecedents = (flow as FlowLabel).antecedent;                 if (antecedents === undefined || antecedents.length === 0) {                     return false;                 }                 // A loop is reachable if the control flow path that leads to the top is reachable.                 flow = antecedents[0];             }             else if (flags & FlowFlags.SwitchClause) {                 // The control flow path representing an unmatched value in a switch statement with                 // no default clause is unreachable if the switch statement is exhaustive.                 const data = (flow as FlowSwitchClause).node;                 if (data.clauseStart === data.clauseEnd && isExhaustiveSwitchStatement(data.switchStatement)) {                     return false;                 }                 flow = (flow as FlowSwitchClause).antecedent;             }             else if (flags & FlowFlags.ReduceLabel) {                 // Cache is unreliable once we start adjusting labels                 lastFlowNode = undefined;                 const target = (flow as FlowReduceLabel).node.target;                 const saveAntecedents = target.antecedent;                 target.antecedent = (flow as FlowReduceLabel).node.antecedents;                 const result = isReachableFlowNodeWorker((flow as FlowReduceLabel).antecedent, /*noCacheCheck* / false);                 target.antecedent = saveAntecedents;                 return result;             }             else {                 return !(flags & FlowFlags.Unreachable);             }         } */
    }
    isPostSuperFlowNode := func(flow FlowNode, noCacheCheck bool) bool {
        /* TODO(WhileStatement): while (true) {             const flags = flow.flags;             if (flags & FlowFlags.Shared) {                 if (!noCacheCheck) {                     const id = getFlowNodeId(flow);                     const postSuper = flowNodePostSuper[id];                     return postSuper !== undefined ? postSuper : (flowNodePostSuper[id] = isPostSuperFlowNode(flow, /*noCacheCheck* / true));                 }                 noCacheCheck = false;             }             if (flags & (FlowFlags.Assignment | FlowFlags.Condition | FlowFlags.ArrayMutation | FlowFlags.SwitchClause)) {                 flow = (flow as FlowAssignment | FlowCondition | FlowArrayMutation | FlowSwitchClause).antecedent;             }             else if (flags & FlowFlags.Call) {                 if ((flow as FlowCall).node.expression.kind === SyntaxKind.SuperKeyword) {                     return true;                 }                 flow = (flow as FlowCall).antecedent;             }             else if (flags & FlowFlags.BranchLabel) {                 // A branching point is post-super if every branch is post-super.                 return every((flow as FlowLabel).antecedent, f => isPostSuperFlowNode(f, /*noCacheCheck* / false));             }             else if (flags & FlowFlags.LoopLabel) {                 // A loop is post-super if the control flow path that leads to the top is post-super.                 flow = (flow as FlowLabel).antecedent![0];             }             else if (flags & FlowFlags.ReduceLabel) {                 const target = (flow as FlowReduceLabel).node.target;                 const saveAntecedents = target.antecedent;                 target.antecedent = (flow as FlowReduceLabel).node.antecedents;                 const result = isPostSuperFlowNode((flow as FlowReduceLabel).antecedent, /*noCacheCheck* / false);                 target.antecedent = saveAntecedents;                 return result;             }             else {                 // Unreachable nodes are considered post-super to silence errors                 return !!(flags & FlowFlags.Unreachable);             }         } */
    }
    isConstantReference := func(node Node) bool {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ThisKeyword:                 return true;             case SyntaxKind.Identifier:                 if (!isThisInTypeQuery(node)) {                     const symbol = getResolvedSymbol(node as Identifier);                     return isConstantVariable(symbol)                         || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol)                         || !!symbol.valueDeclaration && isFunctionExpression(symbol.valueDeclaration);                 }                 break;             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 // The resolvedSymbol property is initialized by checkPropertyAccess or checkElementAccess before we get here.                 return isConstantReference((node as AccessExpression).expression) && isReadonlySymbol(getNodeLinks(node).resolvedSymbol || unknownSymbol);             case SyntaxKind.ObjectBindingPattern:             case SyntaxKind.ArrayBindingPattern:                 const rootDeclaration = getRootDeclaration(node.parent);                 return isParameter(rootDeclaration) || isCatchClauseVariableDeclaration(rootDeclaration)                     ? !isSomeSymbolAssigned(rootDeclaration)                     : isVariableDeclaration(rootDeclaration) && isVarConstLike(rootDeclaration);         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    getFlowTypeOfReference := func(reference Node, declaredType Type, initialType /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO /* = */ /* TODO(Identifier): declaredType */, flowContainer Node, flowNode /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").FlowNode | undefined */ TODO /* = */ /* TODO(PropertyAccessExpression): tryCast(reference, canHaveFlowNode)?.flowNode */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        var key /* TODO(StringKeyword): string */ any
        isKeySet := /* TODO(FalseKeyword): false */ TODO
        flowDepth := 0
        if flowAnalysisDisabled {
             errorType
        }
        if /* TODO(PrefixUnaryExpression): !flowNode */ TODO {
             declaredType
        }
        /* TODO(ExpressionStatement): flowInvocationCount++; */
        sharedFlowStart := sharedFlowCount
        evolvedType := getTypeFromFlowType(getTypeAtFlowNode(flowNode))
        /* TODO(ExpressionStatement): sharedFlowCount = sharedFlowStart; */
        resultType := /* TODO(ConditionalExpression): getObjectFlags(evolvedType) & ObjectFlags.EvolvingArray && isEvolvingArrayOperationTarget(reference) ? autoArrayType : finalizeEvolvingArrayType(evolvedType) */ TODO
        if /* TODO(BinaryExpression): resultType === unreachableNeverType || reference.parent && reference.parent.kind === SyntaxKind.NonNullExpression && !(resultType.flags & TypeFlags.Never) && getTypeWithFacts(resultType, TypeFacts.NEUndefinedOrNull).flags & TypeFlags.Never */ TODO {
             declaredType
        }
         resultType
        getOrSetCacheKey := func() /* TODO(undefined): string | undefined */ TODO {
            if isKeySet {
                 key
            }
            /* TODO(ExpressionStatement): isKeySet = true; */
             /* TODO(BinaryExpression): key = getFlowCacheKey(reference, declaredType, initialType, flowContainer) */ TODO
        }
        getTypeAtFlowNode := func(flow FlowNode) FlowType {
            if /* TODO(BinaryExpression): flowDepth === 2000 */ TODO {
                /* TODO(ExpressionStatement): tracing?.instant(tracing.Phase.CheckTypes, "getTypeAtFlowNode_DepthLimit", { flowId: flow.id }); */
                /* TODO(ExpressionStatement): flowAnalysisDisabled = true; */
                /* TODO(ExpressionStatement): reportFlowControlError(reference); */
                 errorType
            }
            /* TODO(ExpressionStatement): flowDepth++; */
            var sharedFlow *FlowNode
            /* TODO(WhileStatement): while (true) {                 const flags = flow.flags;                 if (flags & FlowFlags.Shared) {                     // We cache results of flow type resolution for shared nodes that were previously visited in                     // the same getFlowTypeOfReference invocation. A node is considered shared when it is the                     // antecedent of more than one node.                     for (let i = sharedFlowStart; i < sharedFlowCount; i++) {                         if (sharedFlowNodes[i] === flow) {                             flowDepth--;                             return sharedFlowTypes[i];                         }                     }                     sharedFlow = flow;                 }                 let type: FlowType | undefined;                 if (flags & FlowFlags.Assignment) {                     type = getTypeAtFlowAssignment(flow as FlowAssignment);                     if (!type) {                         flow = (flow as FlowAssignment).antecedent;                         continue;                     }                 }                 else if (flags & FlowFlags.Call) {                     type = getTypeAtFlowCall(flow as FlowCall);                     if (!type) {                         flow = (flow as FlowCall).antecedent;                         continue;                     }                 }                 else if (flags & FlowFlags.Condition) {                     type = getTypeAtFlowCondition(flow as FlowCondition);                 }                 else if (flags & FlowFlags.SwitchClause) {                     type = getTypeAtSwitchClause(flow as FlowSwitchClause);                 }                 else if (flags & FlowFlags.Label) {                     if ((flow as FlowLabel).antecedent!.length === 1) {                         flow = (flow as FlowLabel).antecedent![0];                         continue;                     }                     type = flags & FlowFlags.BranchLabel ?                         getTypeAtFlowBranchLabel(flow as FlowLabel) :                         getTypeAtFlowLoopLabel(flow as FlowLabel);                 }                 else if (flags & FlowFlags.ArrayMutation) {                     type = getTypeAtFlowArrayMutation(flow as FlowArrayMutation);                     if (!type) {                         flow = (flow as FlowArrayMutation).antecedent;                         continue;                     }                 }                 else if (flags & FlowFlags.ReduceLabel) {                     const target = (flow as FlowReduceLabel).node.target;                     const saveAntecedents = target.antecedent;                     target.antecedent = (flow as FlowReduceLabel).node.antecedents;                     type = getTypeAtFlowNode((flow as FlowReduceLabel).antecedent);                     target.antecedent = saveAntecedents;                 }                 else if (flags & FlowFlags.Start) {                     // Check if we should continue with the control flow of the containing function.                     const container = (flow as FlowStart).node;                     if (                         container && container !== flowContainer &&                         reference.kind !== SyntaxKind.PropertyAccessExpression &&                         reference.kind !== SyntaxKind.ElementAccessExpression &&                         !(reference.kind === SyntaxKind.ThisKeyword && container.kind !== SyntaxKind.ArrowFunction)                     ) {                         flow = container.flowNode!;                         continue;                     }                     // At the top of the flow we have the initial type.                     type = initialType;                 }                 else {                     // Unreachable code errors are reported in the binding phase. Here we                     // simply return the non-auto declared type to reduce follow-on errors.                     type = convertAutoToAny(declaredType);                 }                 if (sharedFlow) {                     // Record visited node and the associated type in the cache.                     sharedFlowNodes[sharedFlowCount] = sharedFlow;                     sharedFlowTypes[sharedFlowCount] = type;                     sharedFlowCount++;                 }                 flowDepth--;                 return type;             } */
        }
        getInitialOrAssignedType := func(flow FlowAssignment) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
            node := /* TODO(PropertyAccessExpression): flow.node */ TODO
             getNarrowableTypeForReference(/* TODO(ConditionalExpression): node.kind === SyntaxKind.VariableDeclaration || node.kind === SyntaxKind.BindingElement ?                     getInitialType(node as VariableDeclaration | BindingElement) :                     getAssignedType(node) */ TODO, reference)
        }
        getTypeAtFlowAssignment := func(flow FlowAssignment) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").FlowType | undefined */ TODO {
            node := /* TODO(PropertyAccessExpression): flow.node */ TODO
            if isMatchingReference(reference, node) {
                if /* TODO(PrefixUnaryExpression): !isReachableFlowNode(flow) */ TODO {
                     unreachableNeverType
                }
                if /* TODO(BinaryExpression): getAssignmentTargetKind(node) === AssignmentKind.Compound */ TODO {
                    flowType := getTypeAtFlowNode(/* TODO(PropertyAccessExpression): flow.antecedent */ TODO)
                     createFlowType(getBaseTypeOfLiteralType(getTypeFromFlowType(flowType)), isIncomplete(flowType))
                }
                if /* TODO(BinaryExpression): declaredType === autoType || declaredType === autoArrayType */ TODO {
                    if isEmptyArrayAssignment(node) {
                         getEvolvingArrayType(neverType)
                    }
                    assignedType := getWidenedLiteralType(getInitialOrAssignedType(flow))
                     /* TODO(ConditionalExpression): isTypeAssignableTo(assignedType, declaredType) ? assignedType : anyArrayType */ TODO
                }
                t := /* TODO(ConditionalExpression): isInCompoundLikeAssignment(node) ? getBaseTypeOfLiteralType(declaredType) : declaredType */ TODO
                if /* TODO(BinaryExpression): t.flags & TypeFlags.Union */ TODO {
                     getAssignmentReducedType(t /* as */ /* TODO(TypeReference): UnionType */, getInitialOrAssignedType(flow))
                }
                 t
            }
            if containsMatchingReference(reference, node) {
                if /* TODO(PrefixUnaryExpression): !isReachableFlowNode(flow) */ TODO {
                     unreachableNeverType
                }
                if /* TODO(BinaryExpression): isVariableDeclaration(node) && (isInJSFile(node) || isVarConstLike(node)) */ TODO {
                    init := getDeclaredExpandoInitializer(node)
                    if /* TODO(BinaryExpression): init && (init.kind === SyntaxKind.FunctionExpression || init.kind === SyntaxKind.ArrowFunction) */ TODO {
                         getTypeAtFlowNode(/* TODO(PropertyAccessExpression): flow.antecedent */ TODO)
                    }
                }
                 declaredType
            }
            if /* TODO(BinaryExpression): isVariableDeclaration(node) &&                 node.parent.parent.kind === SyntaxKind.ForInStatement &&                 (isMatchingReference(reference, node.parent.parent.expression) || optionalChainContainsReference(node.parent.parent.expression, reference)) */ TODO {
                 getNonNullableTypeIfNeeded(finalizeEvolvingArrayType(getTypeFromFlowType(getTypeAtFlowNode(/* TODO(PropertyAccessExpression): flow.antecedent */ TODO))))
            }
             undefined
        }
        narrowTypeByAssertion := func(type_ Type, expr Expression) Type {
            node := skipParentheses(expr, /* TODO(TrueKeyword): true */ TODO)
            if /* TODO(BinaryExpression): node.kind === SyntaxKind.FalseKeyword */ TODO {
                 unreachableNeverType
            }
            if /* TODO(BinaryExpression): node.kind === SyntaxKind.BinaryExpression */ TODO {
                if /* TODO(BinaryExpression): (node as BinaryExpression).operatorToken.kind === SyntaxKind.AmpersandAmpersandToken */ TODO {
                     narrowTypeByAssertion(narrowTypeByAssertion(type_, /* TODO(PropertyAccessExpression): (node as BinaryExpression).left */ TODO), /* TODO(PropertyAccessExpression): (node as BinaryExpression).right */ TODO)
                }
                if /* TODO(BinaryExpression): (node as BinaryExpression).operatorToken.kind === SyntaxKind.BarBarToken */ TODO {
                     getUnionType(/* TODO(ArrayLiteralExpression): [narrowTypeByAssertion(type, (node as BinaryExpression).left), narrowTypeByAssertion(type, (node as BinaryExpression).right)] */ TODO)
                }
            }
             narrowType(type_, node, /* TODO(TrueKeyword): true */ TODO)
        }
        getTypeAtFlowCall := func(flow FlowCall) *FlowType {
            signature := getEffectsSignature(/* TODO(PropertyAccessExpression): flow.node */ TODO)
            if signature {
                predicate := getTypePredicateOfSignature(signature)
                if /* TODO(BinaryExpression): predicate && (predicate.kind === TypePredicateKind.AssertsThis || predicate.kind === TypePredicateKind.AssertsIdentifier) */ TODO {
                    flowType := getTypeAtFlowNode(/* TODO(PropertyAccessExpression): flow.antecedent */ TODO)
                    type_ := finalizeEvolvingArrayType(getTypeFromFlowType(flowType))
                    narrowedType := /* TODO(ConditionalExpression): predicate.type ? narrowTypeByTypePredicate(type, predicate, flow.node, /*assumeTrue* / true) :                         predicate.kind === TypePredicateKind.AssertsIdentifier && predicate.parameterIndex >= 0 && predicate.parameterIndex < flow.node.arguments.length ? narrowTypeByAssertion(type, flow.node.arguments[predicate.parameterIndex]) :                         type */ TODO
                     /* TODO(ConditionalExpression): narrowedType === type ? flowType : createFlowType(narrowedType, isIncomplete(flowType)) */ TODO
                }
                if /* TODO(BinaryExpression): getReturnTypeOfSignature(signature).flags & TypeFlags.Never */ TODO {
                     unreachableNeverType
                }
            }
             undefined
        }
        getTypeAtFlowArrayMutation := func(flow FlowArrayMutation) *FlowType {
            if /* TODO(BinaryExpression): declaredType === autoType || declaredType === autoArrayType */ TODO {
                node := /* TODO(PropertyAccessExpression): flow.node */ TODO
                expr := /* TODO(ConditionalExpression): node.kind === SyntaxKind.CallExpression ?                     (node.expression as PropertyAccessExpression).expression :                     (node.left as ElementAccessExpression).expression */ TODO
                if isMatchingReference(reference, getReferenceCandidate(expr)) {
                    flowType := getTypeAtFlowNode(/* TODO(PropertyAccessExpression): flow.antecedent */ TODO)
                    type_ := getTypeFromFlowType(flowType)
                    if /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.EvolvingArray */ TODO {
                        evolvedType := type_ /* as */ /* TODO(TypeReference): EvolvingArrayType */
                        if /* TODO(BinaryExpression): node.kind === SyntaxKind.CallExpression */ TODO {
                            /* TODO(ForOfStatement): for (const arg of node.arguments) {                                 evolvedType = addEvolvingArrayElementType(evolvedType, arg);                             } */
                        } else {
                            indexType := getContextFreeTypeOfExpression(/* TODO(PropertyAccessExpression): (node.left as ElementAccessExpression).argumentExpression */ TODO)
                            if isTypeAssignableToKind(indexType, /* TODO(PropertyAccessExpression): TypeFlags.NumberLike */ TODO) {
                                /* TODO(ExpressionStatement): evolvedType = addEvolvingArrayElementType(evolvedType, node.right); */
                            }
                        }
                         /* TODO(ConditionalExpression): evolvedType === type ? flowType : createFlowType(evolvedType, isIncomplete(flowType)) */ TODO
                    }
                     flowType
                }
            }
             undefined
        }
        getTypeAtFlowCondition := func(flow FlowCondition) FlowType {
            flowType := getTypeAtFlowNode(/* TODO(PropertyAccessExpression): flow.antecedent */ TODO)
            type_ := getTypeFromFlowType(flowType)
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Never */ TODO {
                 flowType
            }
            assumeTrue := /* TODO(BinaryExpression): (flow.flags & FlowFlags.TrueCondition) !== 0 */ TODO
            nonEvolvingType := finalizeEvolvingArrayType(type_)
            narrowedType := narrowType(nonEvolvingType, /* TODO(PropertyAccessExpression): flow.node */ TODO, assumeTrue)
            if /* TODO(BinaryExpression): narrowedType === nonEvolvingType */ TODO {
                 flowType
            }
             createFlowType(narrowedType, isIncomplete(flowType))
        }
        getTypeAtSwitchClause := func(flow FlowSwitchClause) FlowType {
            expr := skipParentheses(/* TODO(PropertyAccessExpression): flow.node.switchStatement.expression */ TODO)
            flowType := getTypeAtFlowNode(/* TODO(PropertyAccessExpression): flow.antecedent */ TODO)
            type_ := getTypeFromFlowType(flowType)
            if isMatchingReference(reference, expr) {
                /* TODO(ExpressionStatement): type = narrowTypeBySwitchOnDiscriminant(type, flow.node); */
            } else if /* TODO(BinaryExpression): expr.kind === SyntaxKind.TypeOfExpression && isMatchingReference(reference, (expr as TypeOfExpression).expression) */ TODO {
                /* TODO(ExpressionStatement): type = narrowTypeBySwitchOnTypeOf(type, flow.node); */
            } else if /* TODO(BinaryExpression): expr.kind === SyntaxKind.TrueKeyword */ TODO {
                /* TODO(ExpressionStatement): type = narrowTypeBySwitchOnTrue(type, flow.node); */
            } else {
                if strictNullChecks {
                    if optionalChainContainsReference(expr, reference) {
                        /* TODO(ExpressionStatement): type = narrowTypeBySwitchOptionalChainContainment(type, flow.node, t => !(t.flags & (TypeFlags.Undefined | TypeFlags.Never))); */
                    } else if /* TODO(BinaryExpression): expr.kind === SyntaxKind.TypeOfExpression && optionalChainContainsReference((expr as TypeOfExpression).expression, reference) */ TODO {
                        /* TODO(ExpressionStatement): type = narrowTypeBySwitchOptionalChainContainment(type, flow.node, t => !(t.flags & TypeFlags.Never || t.flags & TypeFlags.StringLiteral && (t as StringLiteralType).value === "undefined")); */
                    }
                }
                access := getDiscriminantPropertyAccess(expr, type_)
                if access {
                    /* TODO(ExpressionStatement): type = narrowTypeBySwitchOnDiscriminantProperty(type, access, flow.node); */
                }
            }
             createFlowType(type_, isIncomplete(flowType))
        }
        getTypeAtFlowBranchLabel := func(flow FlowLabel) FlowType {
            var antecedentTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
            subtypeReduction := /* TODO(FalseKeyword): false */ TODO
            seenIncomplete := /* TODO(FalseKeyword): false */ TODO
            var bypassFlow *FlowSwitchClause
            /* TODO(ForOfStatement): for (const antecedent of flow.antecedent!) {                 if (!bypassFlow && antecedent.flags & FlowFlags.SwitchClause && (antecedent as FlowSwitchClause).node.clauseStart === (antecedent as FlowSwitchClause).node.clauseEnd) {                     // The antecedent is the bypass branch of a potentially exhaustive switch statement.                     bypassFlow = antecedent as FlowSwitchClause;                     continue;                 }                 const flowType = getTypeAtFlowNode(antecedent);                 const type = getTypeFromFlowType(flowType);                 // If the type at a particular antecedent path is the declared type and the                 // reference is known to always be assigned (i.e. when declared and initial types                 // are the same), there is no reason to process more antecedents since the only                 // possible outcome is subtypes that will be removed in the final union type anyway.                 if (type === declaredType && declaredType === initialType) {                     return type;                 }                 pushIfUnique(antecedentTypes, type);                 // If an antecedent type is not a subset of the declared type, we need to perform                 // subtype reduction. This happens when a "foreign" type is injected into the control                 // flow using the instanceof operator or a user defined type predicate.                 if (!isTypeSubsetOf(type, initialType)) {                     subtypeReduction = true;                 }                 if (isIncomplete(flowType)) {                     seenIncomplete = true;                 }             } */
            if bypassFlow {
                flowType := getTypeAtFlowNode(bypassFlow)
                type_ := getTypeFromFlowType(flowType)
                if /* TODO(BinaryExpression): !(type.flags & TypeFlags.Never) && !contains(antecedentTypes, type) && !isExhaustiveSwitchStatement(bypassFlow.node.switchStatement) */ TODO {
                    if /* TODO(BinaryExpression): type === declaredType && declaredType === initialType */ TODO {
                         type_
                    }
                    /* TODO(ExpressionStatement): antecedentTypes.push(type); */
                    if /* TODO(PrefixUnaryExpression): !isTypeSubsetOf(type, initialType) */ TODO {
                        /* TODO(ExpressionStatement): subtypeReduction = true; */
                    }
                    if isIncomplete(flowType) {
                        /* TODO(ExpressionStatement): seenIncomplete = true; */
                    }
                }
            }
             createFlowType(getUnionOrEvolvingArrayType(antecedentTypes, /* TODO(ConditionalExpression): subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal */ TODO), seenIncomplete)
        }
        getTypeAtFlowLoopLabel := func(flow FlowLabel) FlowType {
            id := getFlowNodeId(flow)
            cache := /* TODO(BinaryExpression): flowLoopCaches[id] || (flowLoopCaches[id] = new Map<string, Type>()) */ TODO
            key := getOrSetCacheKey()
            if /* TODO(PrefixUnaryExpression): !key */ TODO {
                 declaredType
            }
            cached := /* TODO(PropertyAccessExpression): cache.get */ TODO(key)
            if cached {
                 cached
            }
            /* TODO(ForStatement): for (let i = flowLoopStart; i < flowLoopCount; i++) {                 if (flowLoopNodes[i] === flow && flowLoopKeys[i] === key && flowLoopTypes[i].length) {                     return createFlowType(getUnionOrEvolvingArrayType(flowLoopTypes[i], UnionReduction.Literal), /*incomplete* / true);                 }             } */
            var antecedentTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
            subtypeReduction := /* TODO(FalseKeyword): false */ TODO
            var firstAntecedentType *FlowType
            /* TODO(ForOfStatement): for (const antecedent of flow.antecedent!) {                 let flowType;                 if (!firstAntecedentType) {                     // The first antecedent of a loop junction is always the non-looping control                     // flow path that leads to the top.                     flowType = firstAntecedentType = getTypeAtFlowNode(antecedent);                 }                 else {                     // All but the first antecedent are the looping control flow paths that lead                     // back to the loop junction. We track these on the flow loop stack.                     flowLoopNodes[flowLoopCount] = flow;                     flowLoopKeys[flowLoopCount] = key;                     flowLoopTypes[flowLoopCount] = antecedentTypes;                     flowLoopCount++;                     const saveFlowTypeCache = flowTypeCache;                     flowTypeCache = undefined;                     flowType = getTypeAtFlowNode(antecedent);                     flowTypeCache = saveFlowTypeCache;                     flowLoopCount--;                     // If we see a value appear in the cache it is a sign that control flow analysis                     // was restarted and completed by checkExpressionCached. We can simply pick up                     // the resulting type and bail out.                     const cached = cache.get(key);                     if (cached) {                         return cached;                     }                 }                 const type = getTypeFromFlowType(flowType);                 pushIfUnique(antecedentTypes, type);                 // If an antecedent type is not a subset of the declared type, we need to perform                 // subtype reduction. This happens when a "foreign" type is injected into the control                 // flow using the instanceof operator or a user defined type predicate.                 if (!isTypeSubsetOf(type, initialType)) {                     subtypeReduction = true;                 }                 // If the type at a particular antecedent path is the declared type there is no                 // reason to process more antecedents since the only possible outcome is subtypes                 // that will be removed in the final union type anyway.                 if (type === declaredType) {                     break;                 }             } */
            result := getUnionOrEvolvingArrayType(antecedentTypes, /* TODO(ConditionalExpression): subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal */ TODO)
            if isIncomplete(/* TODO(NonNullExpression): firstAntecedentType! */ TODO) {
                 createFlowType(result, /* TODO(TrueKeyword): true */ TODO)
            }
            /* TODO(ExpressionStatement): cache.set(key, result); */
             result
        }
        getUnionOrEvolvingArrayType := func(types []Type, subtypeReduction UnionReduction) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
            if isEvolvingArrayTypeList(types) {
                 getEvolvingArrayType(getUnionType(map_(types, getElementTypeOfEvolvingArrayType)))
            }
            result := recombineUnknownType(getUnionType(sameMap(types, finalizeEvolvingArrayType), subtypeReduction))
            if /* TODO(BinaryExpression): result !== declaredType && result.flags & declaredType.flags & TypeFlags.Union && arrayIsEqualTo((result as UnionType).types, (declaredType as UnionType).types) */ TODO {
                 declaredType
            }
             result
        }
        getCandidateDiscriminantPropertyAccess := func(expr Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessExpression | undefined */ TODO {
            if /* TODO(BinaryExpression): isBindingPattern(reference) || isFunctionExpressionOrArrowFunction(reference) || isObjectLiteralMethod(reference) */ TODO {
                if isIdentifier(expr) {
                    symbol := getResolvedSymbol(expr)
                    declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
                    if /* TODO(BinaryExpression): declaration && (isBindingElement(declaration) || isParameter(declaration)) && reference === declaration.parent && !declaration.initializer && !declaration.dotDotDotToken */ TODO {
                         declaration
                    }
                }
            } else if isAccessExpression(expr) {
                if isMatchingReference(reference, /* TODO(PropertyAccessExpression): expr.expression */ TODO) {
                     expr
                }
            } else if isIdentifier(expr) {
                symbol := getResolvedSymbol(expr)
                if isConstantVariable(symbol) {
                    declaration := /* TODO(NonNullExpression): symbol.valueDeclaration! */ TODO
                    if /* TODO(BinaryExpression): isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isAccessExpression(declaration.initializer) &&                         isMatchingReference(reference, declaration.initializer.expression) */ TODO {
                         /* TODO(PropertyAccessExpression): declaration.initializer */ TODO
                    }
                    if /* TODO(BinaryExpression): isBindingElement(declaration) && !declaration.initializer */ TODO {
                        parent := /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO
                        if /* TODO(BinaryExpression): isVariableDeclaration(parent) && !parent.type && parent.initializer && (isIdentifier(parent.initializer) || isAccessExpression(parent.initializer)) &&                             isMatchingReference(reference, parent.initializer) */ TODO {
                             declaration
                        }
                    }
                }
            }
             undefined
        }
        getDiscriminantPropertyAccess := func(expr Expression, computedType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessExpression | undefined */ TODO {
            if /* TODO(BinaryExpression): declaredType.flags & TypeFlags.Union || computedType.flags & TypeFlags.Union */ TODO {
                access := getCandidateDiscriminantPropertyAccess(expr)
                if access {
                    name := getAccessedPropertyName(access)
                    if name {
                        type_ := /* TODO(ConditionalExpression): declaredType.flags & TypeFlags.Union && isTypeSubsetOf(computedType, declaredType) ? declaredType : computedType */ TODO
                        if isDiscriminantProperty(type_, name) {
                             access
                        }
                    }
                }
            }
             undefined
        }
        narrowTypeByDiscriminant := func(type_ Type, access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, narrowType func(t Type) Type) Type {
            propName := getAccessedPropertyName(access)
            if /* TODO(BinaryExpression): propName === undefined */ TODO {
                 type_
            }
            optionalChain := isOptionalChain(access)
            removeNullable := /* TODO(BinaryExpression): strictNullChecks && (optionalChain || isNonNullAccess(access)) && maybeTypeOfKind(type, TypeFlags.Nullable) */ TODO
            propType := getTypeOfPropertyOfType(/* TODO(ConditionalExpression): removeNullable ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO, propName)
            if /* TODO(PrefixUnaryExpression): !propType */ TODO {
                 type_
            }
            /* TODO(ExpressionStatement): propType = removeNullable && optionalChain ? getOptionalType(propType) : propType; */
            narrowedPropType := narrowType(propType)
             filterType(type_, /* TODO(ArrowFunction): t => {                 const discriminantType = getTypeOfPropertyOrIndexSignatureOfType(t, propName) || unknownType;                 return !(discriminantType.flags & TypeFlags.Never) && !(narrowedPropType.flags & TypeFlags.Never) && areTypesComparable(narrowedPropType, discriminantType);             } */ TODO)
        }
        narrowTypeByDiscriminantProperty := func(type_ Type, access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, operator SyntaxKind, value Expression, assumeTrue bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
            if /* TODO(BinaryExpression): (operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken) && type.flags & TypeFlags.Union */ TODO {
                keyPropertyName := getKeyPropertyName(type_ /* as */ /* TODO(TypeReference): UnionType */)
                if /* TODO(BinaryExpression): keyPropertyName && keyPropertyName === getAccessedPropertyName(access) */ TODO {
                    candidate := getConstituentTypeForKeyType(type_ /* as */ /* TODO(TypeReference): UnionType */, getTypeOfExpression(value))
                    if candidate {
                         /* TODO(ConditionalExpression): operator === (assumeTrue ? SyntaxKind.EqualsEqualsEqualsToken : SyntaxKind.ExclamationEqualsEqualsToken) ? candidate :                             isUnitType(getTypeOfPropertyOfType(candidate, keyPropertyName) || unknownType) ? removeType(type, candidate) :                             type */ TODO
                    }
                }
            }
             narrowTypeByDiscriminant(type_, access, /* TODO(ArrowFunction): t => narrowTypeByEquality(t, operator, value, assumeTrue) */ TODO)
        }
        narrowTypeBySwitchOnDiscriminantProperty := func(type_ Type, access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, data FlowSwitchClauseData) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
            if /* TODO(BinaryExpression): data.clauseStart < data.clauseEnd && type.flags & TypeFlags.Union && getKeyPropertyName(type as UnionType) === getAccessedPropertyName(access) */ TODO {
                clauseTypes := /* TODO(PropertyAccessExpression): getSwitchClauseTypes(data.switchStatement).slice */ TODO(/* TODO(PropertyAccessExpression): data.clauseStart */ TODO, /* TODO(PropertyAccessExpression): data.clauseEnd */ TODO)
                candidate := getUnionType(map_(clauseTypes, /* TODO(ArrowFunction): t => getConstituentTypeForKeyType(type as UnionType, t) || unknownType */ TODO))
                if /* TODO(BinaryExpression): candidate !== unknownType */ TODO {
                     candidate
                }
            }
             narrowTypeByDiscriminant(type_, access, /* TODO(ArrowFunction): t => narrowTypeBySwitchOnDiscriminant(t, data) */ TODO)
        }
        narrowTypeByTruthiness := func(type_ Type, expr Expression, assumeTrue bool) Type {
            if isMatchingReference(reference, expr) {
                 getAdjustedTypeWithFacts(type_, /* TODO(ConditionalExpression): assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy */ TODO)
            }
            if /* TODO(BinaryExpression): strictNullChecks && assumeTrue && optionalChainContainsReference(expr, reference) */ TODO {
                /* TODO(ExpressionStatement): type = getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull); */
            }
            access := getDiscriminantPropertyAccess(expr, type_)
            if access {
                 narrowTypeByDiscriminant(type_, access, /* TODO(ArrowFunction): t => getTypeWithFacts(t, assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy) */ TODO)
            }
             type_
        }
        isTypePresencePossible := func(type_ Type, propName __String, assumeTrue bool) /* TODO(undefined): boolean */ TODO {
            prop := getPropertyOfType(type_, propName)
             /* TODO(ConditionalExpression): prop ?                 !!(prop.flags & SymbolFlags.Optional || getCheckFlags(prop) & CheckFlags.Partial) || assumeTrue :                 !!getApplicableIndexInfoForName(type, propName) || !assumeTrue */ TODO
        }
        narrowTypeByInKeyword := func(type_ Type, nameType /* TODO(UnionType): StringLiteralType | NumberLiteralType | UniqueESSymbolType */ any, assumeTrue bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
            name := getPropertyNameFromType(nameType)
            isKnownProperty := someType(type_, /* TODO(ArrowFunction): t => isTypePresencePossible(t, name, /*assumeTrue* / true) */ TODO)
            if isKnownProperty {
                 filterType(type_, /* TODO(ArrowFunction): t => isTypePresencePossible(t, name, assumeTrue) */ TODO)
            }
            if assumeTrue {
                recordSymbol := getGlobalRecordSymbol()
                if recordSymbol {
                     getIntersectionType(/* TODO(ArrayLiteralExpression): [type, getTypeAliasInstantiation(recordSymbol, [nameType, unknownType])] */ TODO)
                }
            }
             type_
        }
        narrowTypeByBooleanComparison := func(type_ Type, expr Expression, bool BooleanLiteral, operator BinaryOperator, assumeTrue bool) Type {
            /* TODO(ExpressionStatement): assumeTrue = (assumeTrue !== (bool.kind === SyntaxKind.TrueKeyword)) !== (operator !== SyntaxKind.ExclamationEqualsEqualsToken && operator !== SyntaxKind.ExclamationEqualsToken); */
             narrowType(type_, expr, assumeTrue)
        }
        narrowTypeByBinaryExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
            /* TODO(SwitchStatement): switch (expr.operatorToken.kind) {                 case SyntaxKind.EqualsToken:                 case SyntaxKind.BarBarEqualsToken:                 case SyntaxKind.AmpersandAmpersandEqualsToken:                 case SyntaxKind.QuestionQuestionEqualsToken:                     return narrowTypeByTruthiness(narrowType(type, expr.right, assumeTrue), expr.left, assumeTrue);                 case SyntaxKind.EqualsEqualsToken:                 case SyntaxKind.ExclamationEqualsToken:                 case SyntaxKind.EqualsEqualsEqualsToken:                 case SyntaxKind.ExclamationEqualsEqualsToken:                     const operator = expr.operatorToken.kind;                     const left = getReferenceCandidate(expr.left);                     const right = getReferenceCandidate(expr.right);                     if (left.kind === SyntaxKind.TypeOfExpression && isStringLiteralLike(right)) {                         return narrowTypeByTypeof(type, left as TypeOfExpression, operator, right, assumeTrue);                     }                     if (right.kind === SyntaxKind.TypeOfExpression && isStringLiteralLike(left)) {                         return narrowTypeByTypeof(type, right as TypeOfExpression, operator, left, assumeTrue);                     }                     if (isMatchingReference(reference, left)) {                         return narrowTypeByEquality(type, operator, right, assumeTrue);                     }                     if (isMatchingReference(reference, right)) {                         return narrowTypeByEquality(type, operator, left, assumeTrue);                     }                     if (strictNullChecks) {                         if (optionalChainContainsReference(left, reference)) {                             type = narrowTypeByOptionalChainContainment(type, operator, right, assumeTrue);                         }                         else if (optionalChainContainsReference(right, reference)) {                             type = narrowTypeByOptionalChainContainment(type, operator, left, assumeTrue);                         }                     }                     const leftAccess = getDiscriminantPropertyAccess(left, type);                     if (leftAccess) {                         return narrowTypeByDiscriminantProperty(type, leftAccess, operator, right, assumeTrue);                     }                     const rightAccess = getDiscriminantPropertyAccess(right, type);                     if (rightAccess) {                         return narrowTypeByDiscriminantProperty(type, rightAccess, operator, left, assumeTrue);                     }                     if (isMatchingConstructorReference(left)) {                         return narrowTypeByConstructor(type, operator, right, assumeTrue);                     }                     if (isMatchingConstructorReference(right)) {                         return narrowTypeByConstructor(type, operator, left, assumeTrue);                     }                     if (isBooleanLiteral(right) && !isAccessExpression(left)) {                         return narrowTypeByBooleanComparison(type, left, right, operator, assumeTrue);                     }                     if (isBooleanLiteral(left) && !isAccessExpression(right)) {                         return narrowTypeByBooleanComparison(type, right, left, operator, assumeTrue);                     }                     break;                 case SyntaxKind.InstanceOfKeyword:                     return narrowTypeByInstanceof(type, expr as InstanceofExpression, assumeTrue);                 case SyntaxKind.InKeyword:                     if (isPrivateIdentifier(expr.left)) {                         return narrowTypeByPrivateIdentifierInInExpression(type, expr, assumeTrue);                     }                     const target = getReferenceCandidate(expr.right);                     if (containsMissingType(type) && isAccessExpression(reference) && isMatchingReference(reference.expression, target)) {                         const leftType = getTypeOfExpression(expr.left);                         if (isTypeUsableAsPropertyName(leftType) && getAccessedPropertyName(reference) === getPropertyNameFromType(leftType)) {                             return getTypeWithFacts(type, assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined);                         }                     }                     if (isMatchingReference(reference, target)) {                         const leftType = getTypeOfExpression(expr.left);                         if (isTypeUsableAsPropertyName(leftType)) {                             return narrowTypeByInKeyword(type, leftType, assumeTrue);                         }                     }                     break;                 case SyntaxKind.CommaToken:                     return narrowType(type, expr.right, assumeTrue);                 // Ordinarily we won't see && and || expressions in control flow analysis because the Binder breaks those                 // expressions down to individual conditional control flows. However, we may encounter them when analyzing                 // aliased conditional expressions.                 case SyntaxKind.AmpersandAmpersandToken:                     return assumeTrue ?                         narrowType(narrowType(type, expr.left, /*assumeTrue* / true), expr.right, /*assumeTrue* / true) :                         getUnionType([narrowType(type, expr.left, /*assumeTrue* / false), narrowType(type, expr.right, /*assumeTrue* / false)]);                 case SyntaxKind.BarBarToken:                     return assumeTrue ?                         getUnionType([narrowType(type, expr.left, /*assumeTrue* / true), narrowType(type, expr.right, /*assumeTrue* / true)]) :                         narrowType(narrowType(type, expr.left, /*assumeTrue* / false), expr.right, /*assumeTrue* / false);             } */
             type_
        }
        narrowTypeByPrivateIdentifierInInExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
            target := getReferenceCandidate(/* TODO(PropertyAccessExpression): expr.right */ TODO)
            if /* TODO(PrefixUnaryExpression): !isMatchingReference(reference, target) */ TODO {
                 type_
            }
            /* TODO(ExpressionStatement): Debug.assertNode(expr.left, isPrivateIdentifier); */
            symbol := getSymbolForPrivateIdentifierExpression(/* TODO(PropertyAccessExpression): expr.left */ TODO)
            if /* TODO(BinaryExpression): symbol === undefined */ TODO {
                 type_
            }
            classSymbol := /* TODO(NonNullExpression): symbol.parent! */ TODO
            targetType := /* TODO(ConditionalExpression): hasStaticModifier(Debug.checkDefined(symbol.valueDeclaration, "should always have a declaration"))                 ? getTypeOfSymbol(classSymbol) as InterfaceType                 : getDeclaredTypeOfSymbol(classSymbol) */ TODO
             getNarrowedType(type_, targetType, assumeTrue, /* TODO(TrueKeyword): true */ TODO)
        }
        narrowTypeByOptionalChainContainment := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
            equalsOperator := /* TODO(BinaryExpression): operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.EqualsEqualsEqualsToken */ TODO
            nullableFlags := /* TODO(ConditionalExpression): operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? TypeFlags.Nullable : TypeFlags.Undefined */ TODO
            valueType := getTypeOfExpression(value)
            removeNullable := /* TODO(BinaryExpression): equalsOperator !== assumeTrue && everyType(valueType, t => !!(t.flags & nullableFlags)) ||                 equalsOperator === assumeTrue && everyType(valueType, t => !(t.flags & (TypeFlags.AnyOrUnknown | nullableFlags))) */ TODO
             /* TODO(ConditionalExpression): removeNullable ? getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO
        }
        narrowTypeByEquality := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
            if /* TODO(BinaryExpression): type.flags & TypeFlags.Any */ TODO {
                 type_
            }
            if /* TODO(BinaryExpression): operator === SyntaxKind.ExclamationEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken */ TODO {
                /* TODO(ExpressionStatement): assumeTrue = !assumeTrue; */
            }
            valueType := getTypeOfExpression(value)
            doubleEquals := /* TODO(BinaryExpression): operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken */ TODO
            if /* TODO(BinaryExpression): valueType.flags & TypeFlags.Nullable */ TODO {
                if /* TODO(PrefixUnaryExpression): !strictNullChecks */ TODO {
                     type_
                }
                facts := /* TODO(ConditionalExpression): doubleEquals ?                     assumeTrue ? TypeFacts.EQUndefinedOrNull : TypeFacts.NEUndefinedOrNull :                     valueType.flags & TypeFlags.Null ?                     assumeTrue ? TypeFacts.EQNull : TypeFacts.NENull :                     assumeTrue ? TypeFacts.EQUndefined : TypeFacts.NEUndefined */ TODO
                 getAdjustedTypeWithFacts(type_, facts)
            }
            if assumeTrue {
                if /* TODO(BinaryExpression): !doubleEquals && (type.flags & TypeFlags.Unknown || someType(type, isEmptyAnonymousObjectType)) */ TODO {
                    if /* TODO(BinaryExpression): valueType.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive) || isEmptyAnonymousObjectType(valueType) */ TODO {
                         valueType
                    }
                    if /* TODO(BinaryExpression): valueType.flags & TypeFlags.Object */ TODO {
                         nonPrimitiveType
                    }
                }
                filteredType := filterType(type_, /* TODO(ArrowFunction): t => areTypesComparable(t, valueType) || doubleEquals && isCoercibleUnderDoubleEquals(t, valueType) */ TODO)
                 replacePrimitivesWithLiterals(filteredType, valueType)
            }
            if isUnitType(valueType) {
                 filterType(type_, /* TODO(ArrowFunction): t => !(isUnitLikeType(t) && areTypesComparable(t, valueType)) */ TODO)
            }
             type_
        }
        narrowTypeByTypeof := func(type_ Type, typeOfExpr TypeOfExpression, operator SyntaxKind, literal LiteralExpression, assumeTrue bool) Type {
            if /* TODO(BinaryExpression): operator === SyntaxKind.ExclamationEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken */ TODO {
                /* TODO(ExpressionStatement): assumeTrue = !assumeTrue; */
            }
            target := getReferenceCandidate(/* TODO(PropertyAccessExpression): typeOfExpr.expression */ TODO)
            if /* TODO(PrefixUnaryExpression): !isMatchingReference(reference, target) */ TODO {
                if /* TODO(BinaryExpression): strictNullChecks && optionalChainContainsReference(target, reference) && assumeTrue === (literal.text !== "undefined") */ TODO {
                    /* TODO(ExpressionStatement): type = getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull); */
                }
                propertyAccess := getDiscriminantPropertyAccess(target, type_)
                if propertyAccess {
                     narrowTypeByDiscriminant(type_, propertyAccess, /* TODO(ArrowFunction): t => narrowTypeByLiteralExpression(t, literal, assumeTrue) */ TODO)
                }
                 type_
            }
             narrowTypeByLiteralExpression(type_, literal, assumeTrue)
        }
        narrowTypeByLiteralExpression := func(type_ Type, literal LiteralExpression, assumeTrue bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
             /* TODO(ConditionalExpression): assumeTrue ?                 narrowTypeByTypeName(type, literal.text) :                 getAdjustedTypeWithFacts(type, typeofNEFacts.get(literal.text) || TypeFacts.TypeofNEHostObject) */ TODO
        }
        narrowTypeBySwitchOptionalChainContainment := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData, clauseCheck func(type_ Type) bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
            everyClauseChecks := /* TODO(BinaryExpression): clauseStart !== clauseEnd && every(getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd), clauseCheck) */ TODO
             /* TODO(ConditionalExpression): everyClauseChecks ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO
        }
        narrowTypeBySwitchOnDiscriminant := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
            switchTypes := getSwitchClauseTypes(switchStatement)
            if /* TODO(PrefixUnaryExpression): !switchTypes.length */ TODO {
                 type_
            }
            clauseTypes := /* TODO(PropertyAccessExpression): switchTypes.slice */ TODO(clauseStart, clauseEnd)
            hasDefaultClause := /* TODO(BinaryExpression): clauseStart === clauseEnd || contains(clauseTypes, neverType) */ TODO
            if /* TODO(BinaryExpression): (type.flags & TypeFlags.Unknown) && !hasDefaultClause */ TODO {
                var groundClauseTypes /* TODO(ArrayType): Type[] */ any
                /* TODO(ForStatement): for (let i = 0; i < clauseTypes.length; i += 1) {                     const t = clauseTypes[i];                     if (t.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) {                         if (groundClauseTypes !== undefined) {                             groundClauseTypes.push(t);                         }                     }                     else if (t.flags & TypeFlags.Object) {                         if (groundClauseTypes === undefined) {                             groundClauseTypes = clauseTypes.slice(0, i);                         }                         groundClauseTypes.push(nonPrimitiveType);                     }                     else {                         return type;                     }                 } */
                 getUnionType(/* TODO(ConditionalExpression): groundClauseTypes === undefined ? clauseTypes : groundClauseTypes */ TODO)
            }
            discriminantType := getUnionType(clauseTypes)
            caseType := /* TODO(ConditionalExpression): discriminantType.flags & TypeFlags.Never ? neverType :                 replacePrimitivesWithLiterals(filterType(type, t => areTypesComparable(discriminantType, t)), discriminantType) */ TODO
            if /* TODO(PrefixUnaryExpression): !hasDefaultClause */ TODO {
                 caseType
            }
            defaultType := filterType(type_, /* TODO(ArrowFunction): t => !(isUnitLikeType(t) && contains(switchTypes, t.flags & TypeFlags.Undefined ? undefinedType : getRegularTypeOfLiteralType(extractUnitType(t)))) */ TODO)
             /* TODO(ConditionalExpression): caseType.flags & TypeFlags.Never ? defaultType : getUnionType([caseType, defaultType]) */ TODO
        }
        narrowTypeByTypeName := func(type_ Type, typeName string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
            /* TODO(SwitchStatement): switch (typeName) {                 case "string":                     return narrowTypeByTypeFacts(type, stringType, TypeFacts.TypeofEQString);                 case "number":                     return narrowTypeByTypeFacts(type, numberType, TypeFacts.TypeofEQNumber);                 case "bigint":                     return narrowTypeByTypeFacts(type, bigintType, TypeFacts.TypeofEQBigInt);                 case "boolean":                     return narrowTypeByTypeFacts(type, booleanType, TypeFacts.TypeofEQBoolean);                 case "symbol":                     return narrowTypeByTypeFacts(type, esSymbolType, TypeFacts.TypeofEQSymbol);                 case "object":                     return type.flags & TypeFlags.Any ? type : getUnionType([narrowTypeByTypeFacts(type, nonPrimitiveType, TypeFacts.TypeofEQObject), narrowTypeByTypeFacts(type, nullType, TypeFacts.EQNull)]);                 case "function":                     return type.flags & TypeFlags.Any ? type : narrowTypeByTypeFacts(type, globalFunctionType, TypeFacts.TypeofEQFunction);                 case "undefined":                     return narrowTypeByTypeFacts(type, undefinedType, TypeFacts.EQUndefined);             } */
             narrowTypeByTypeFacts(type_, nonPrimitiveType, /* TODO(PropertyAccessExpression): TypeFacts.TypeofEQHostObject */ TODO)
        }
        narrowTypeByTypeFacts := func(type_ Type, impliedType Type, facts TypeFacts) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
             mapType(type_, /* TODO(ArrowFunction): t =>                 // We first check if a constituent is a subtype of the implied type. If so, we either keep or eliminate                 // the constituent based on its type facts. We use the strict subtype relation because it treats `object`                 // as a subtype of `{}`, and we need the type facts check because function types are subtypes of `object`,                 // but are classified as "function" according to `typeof`.                 isTypeRelatedTo(t, impliedType, strictSubtypeRelation) ? hasTypeFacts(t, facts) ? t : neverType :                     // We next check if the consituent is a supertype of the implied type. If so, we substitute the implied                     // type. This handles top types like `unknown` and `{}`, and supertypes like `{ toString(): string }`.                     isTypeSubtypeOf(impliedType, t) ? impliedType :                     // Neither the constituent nor the implied type is a subtype of the other, however their domains may still                     // overlap. For example, an unconstrained type parameter and type `string`. If the type facts indicate                     // possible overlap, we form an intersection. Otherwise, we eliminate the constituent.                     hasTypeFacts(t, facts) ? getIntersectionType([t, impliedType]) :                     neverType */ TODO)
        }
        narrowTypeBySwitchOnTypeOf := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
            witnesses := getSwitchClauseTypeOfWitnesses(switchStatement)
            if /* TODO(PrefixUnaryExpression): !witnesses */ TODO {
                 type_
            }
            defaultIndex := findIndex(/* TODO(PropertyAccessExpression): switchStatement.caseBlock.clauses */ TODO, /* TODO(ArrowFunction): clause => clause.kind === SyntaxKind.DefaultClause */ TODO)
            hasDefaultClause := /* TODO(BinaryExpression): clauseStart === clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd) */ TODO
            if hasDefaultClause {
                notEqualFacts := getNotEqualFactsFromTypeofSwitch(clauseStart, clauseEnd, witnesses)
                 filterType(type_, /* TODO(ArrowFunction): t => getTypeFacts(t, notEqualFacts) === notEqualFacts */ TODO)
            }
            clauseWitnesses := /* TODO(PropertyAccessExpression): witnesses.slice */ TODO(clauseStart, clauseEnd)
             getUnionType(map_(clauseWitnesses, /* TODO(ArrowFunction): text => text ? narrowTypeByTypeName(type, text) : neverType */ TODO))
        }
        narrowTypeBySwitchOnTrue := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
            defaultIndex := findIndex(/* TODO(PropertyAccessExpression): switchStatement.caseBlock.clauses */ TODO, /* TODO(ArrowFunction): clause => clause.kind === SyntaxKind.DefaultClause */ TODO)
            hasDefaultClause := /* TODO(BinaryExpression): clauseStart === clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd) */ TODO
            /* TODO(ForStatement): for (let i = 0; i < clauseStart; i++) {                 const clause = switchStatement.caseBlock.clauses[i];                 if (clause.kind === SyntaxKind.CaseClause) {                     type = narrowType(type, clause.expression, /*assumeTrue* / false);                 }             } */
            if hasDefaultClause {
                /* TODO(ForStatement): for (let i = clauseEnd; i < switchStatement.caseBlock.clauses.length; i++) {                     const clause = switchStatement.caseBlock.clauses[i];                     if (clause.kind === SyntaxKind.CaseClause) {                         type = narrowType(type, clause.expression, /*assumeTrue* / false);                     }                 } */
                 type_
            }
            clauses := /* TODO(PropertyAccessExpression): switchStatement.caseBlock.clauses.slice */ TODO(clauseStart, clauseEnd)
             getUnionType(map_(clauses, /* TODO(ArrowFunction): clause => clause.kind === SyntaxKind.CaseClause ? narrowType(type, clause.expression, /*assumeTrue* / true) : neverType */ TODO))
        }
        isMatchingConstructorReference := func(expr Expression) /* TODO(undefined): boolean */ TODO {
             /* TODO(BinaryExpression): (isPropertyAccessExpression(expr) && idText(expr.name) === "constructor" ||                 isElementAccessExpression(expr) && isStringLiteralLike(expr.argumentExpression) && expr.argumentExpression.text === "constructor") &&                 isMatchingReference(reference, expr.expression) */ TODO
        }
        narrowTypeByConstructor := func(type_ Type, operator SyntaxKind, identifier Expression, assumeTrue bool) Type {
            if /* TODO(ConditionalExpression): assumeTrue ? (operator !== SyntaxKind.EqualsEqualsToken && operator !== SyntaxKind.EqualsEqualsEqualsToken) : (operator !== SyntaxKind.ExclamationEqualsToken && operator !== SyntaxKind.ExclamationEqualsEqualsToken) */ TODO {
                 type_
            }
            identifierType := getTypeOfExpression(identifier)
            if /* TODO(BinaryExpression): !isFunctionType(identifierType) && !isConstructorType(identifierType) */ TODO {
                 type_
            }
            prototypeProperty := getPropertyOfType(identifierType, "prototype" /* as */ /* TODO(TypeReference): __String */)
            if /* TODO(PrefixUnaryExpression): !prototypeProperty */ TODO {
                 type_
            }
            prototypeType := getTypeOfSymbol(prototypeProperty)
            candidate := /* TODO(ConditionalExpression): !isTypeAny(prototypeType) ? prototypeType : undefined */ TODO
            if /* TODO(BinaryExpression): !candidate || candidate === globalObjectType || candidate === globalFunctionType */ TODO {
                 type_
            }
            if isTypeAny(type_) {
                 candidate
            }
             filterType(type_, /* TODO(ArrowFunction): t => isConstructedBy(t, candidate) */ TODO)
            isConstructedBy := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
                if /* TODO(BinaryExpression): source.flags & TypeFlags.Object && getObjectFlags(source) & ObjectFlags.Class ||                     target.flags & TypeFlags.Object && getObjectFlags(target) & ObjectFlags.Class */ TODO {
                     /* TODO(BinaryExpression): source.symbol === target.symbol */ TODO
                }
                 isTypeSubtypeOf(source, target)
            }
        }
        narrowTypeByInstanceof := func(type_ Type, expr InstanceofExpression, assumeTrue bool) Type {
            left := getReferenceCandidate(/* TODO(PropertyAccessExpression): expr.left */ TODO)
            if /* TODO(PrefixUnaryExpression): !isMatchingReference(reference, left) */ TODO {
                if /* TODO(BinaryExpression): assumeTrue && strictNullChecks && optionalChainContainsReference(left, reference) */ TODO {
                     getAdjustedTypeWithFacts(type_, /* TODO(PropertyAccessExpression): TypeFacts.NEUndefinedOrNull */ TODO)
                }
                 type_
            }
            right := /* TODO(PropertyAccessExpression): expr.right */ TODO
            rightType := getTypeOfExpression(right)
            if /* TODO(PrefixUnaryExpression): !isTypeDerivedFrom(rightType, globalObjectType) */ TODO {
                 type_
            }
            signature := getEffectsSignature(expr)
            predicate := /* TODO(BinaryExpression): signature && getTypePredicateOfSignature(signature) */ TODO
            if /* TODO(BinaryExpression): predicate && predicate.kind === TypePredicateKind.Identifier && predicate.parameterIndex === 0 */ TODO {
                 getNarrowedType(type_, /* TODO(PropertyAccessExpression): predicate.type */ TODO, assumeTrue, /* TODO(TrueKeyword): true */ TODO)
            }
            if /* TODO(PrefixUnaryExpression): !isTypeDerivedFrom(rightType, globalFunctionType) */ TODO {
                 type_
            }
            instanceType := mapType(rightType, getInstanceType)
            if /* TODO(BinaryExpression): isTypeAny(type) && (instanceType === globalObjectType || instanceType === globalFunctionType) ||                 !assumeTrue && !(instanceType.flags & TypeFlags.Object && !isEmptyAnonymousObjectType(instanceType)) */ TODO {
                 type_
            }
             getNarrowedType(type_, instanceType, assumeTrue, /* TODO(TrueKeyword): true */ TODO)
        }
        getInstanceType := func(constructorType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
            prototypePropertyType := getTypeOfPropertyOfType(constructorType, "prototype" /* as */ /* TODO(TypeReference): __String */)
            if /* TODO(BinaryExpression): prototypePropertyType && !isTypeAny(prototypePropertyType) */ TODO {
                 prototypePropertyType
            }
            constructSignatures := getSignaturesOfType(constructorType, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO)
            if /* TODO(PropertyAccessExpression): constructSignatures.length */ TODO {
                 getUnionType(map_(constructSignatures, /* TODO(ArrowFunction): signature => getReturnTypeOfSignature(getErasedSignature(signature)) */ TODO))
            }
             emptyObjectType
        }
        getNarrowedType := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) Type {
            key := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? `N${getTypeId(type)},${getTypeId(candidate)},${(assumeTrue ? 1 : 0) | (checkDerived ? 2 : 0)}` : undefined */ TODO
             /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, getNarrowedTypeWorker(type, candidate, assumeTrue, checkDerived)) */ TODO
        }
        getNarrowedTypeWorker := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
            if /* TODO(PrefixUnaryExpression): !assumeTrue */ TODO {
                if /* TODO(BinaryExpression): type === candidate */ TODO {
                     neverType
                }
                if checkDerived {
                     filterType(type_, /* TODO(ArrowFunction): t => !isTypeDerivedFrom(t, candidate) */ TODO)
                }
                trueType := getNarrowedType(type_, candidate, /* TODO(TrueKeyword): true */ TODO, /* TODO(FalseKeyword): false */ TODO)
                 filterType(type_, /* TODO(ArrowFunction): t => !isTypeSubsetOf(t, trueType) */ TODO)
            }
            if /* TODO(BinaryExpression): type.flags & TypeFlags.AnyOrUnknown */ TODO {
                 candidate
            }
            if /* TODO(BinaryExpression): type === candidate */ TODO {
                 candidate
            }
            isRelated := /* TODO(ConditionalExpression): checkDerived ? isTypeDerivedFrom : isTypeSubtypeOf */ TODO
            keyPropertyName := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? getKeyPropertyName(type as UnionType) : undefined */ TODO
            narrowedType := mapType(candidate, /* TODO(ArrowFunction): c => {                 // If a discriminant property is available, use that to reduce the type.                 const discriminant = keyPropertyName && getTypeOfPropertyOfType(c, keyPropertyName);                 const matching = discriminant && getConstituentTypeForKeyType(type as UnionType, discriminant);                 // For each constituent t in the current type, if t and and c are directly related, pick the most                 // specific of the two. When t and c are related in both directions, we prefer c for type predicates                 // because that is the asserted type, but t for `instanceof` because generics aren't reflected in                 // prototype object types.                 const directlyRelated = mapType(                     matching || type,                     checkDerived ?                         t => isTypeDerivedFrom(t, c) ? t : isTypeDerivedFrom(c, t) ? c : neverType :                         t => isTypeStrictSubtypeOf(t, c) ? t : isTypeStrictSubtypeOf(c, t) ? c : isTypeSubtypeOf(t, c) ? t : isTypeSubtypeOf(c, t) ? c : neverType,                 );                 // If no constituents are directly related, create intersections for any generic constituents that                 // are related by constraint.                 return directlyRelated.flags & TypeFlags.Never ?                     mapType(type, t => maybeTypeOfKind(t, TypeFlags.Instantiable) && isRelated(c, getBaseConstraintOfType(t) || unknownType) ? getIntersectionType([t, c]) : neverType) :                     directlyRelated;             } */ TODO)
             /* TODO(ConditionalExpression): !(narrowedType.flags & TypeFlags.Never) ? narrowedType :                 isTypeSubtypeOf(candidate, type) ? candidate :                 isTypeAssignableTo(type, candidate) ? type :                 isTypeAssignableTo(candidate, type) ? candidate :                 getIntersectionType([type, candidate]) */ TODO
        }
        narrowTypeByCallExpression := func(type_ Type, callExpression CallExpression, assumeTrue bool) Type {
            if hasMatchingArgument(callExpression, reference) {
                signature := /* TODO(ConditionalExpression): assumeTrue || !isCallChain(callExpression) ? getEffectsSignature(callExpression) : undefined */ TODO
                predicate := /* TODO(BinaryExpression): signature && getTypePredicateOfSignature(signature) */ TODO
                if /* TODO(BinaryExpression): predicate && (predicate.kind === TypePredicateKind.This || predicate.kind === TypePredicateKind.Identifier) */ TODO {
                     narrowTypeByTypePredicate(type_, predicate, callExpression, assumeTrue)
                }
            }
            if /* TODO(BinaryExpression): containsMissingType(type) && isAccessExpression(reference) && isPropertyAccessExpression(callExpression.expression) */ TODO {
                callAccess := /* TODO(PropertyAccessExpression): callExpression.expression */ TODO
                if /* TODO(BinaryExpression): isMatchingReference(reference.expression, getReferenceCandidate(callAccess.expression)) &&                     isIdentifier(callAccess.name) && callAccess.name.escapedText === "hasOwnProperty" && callExpression.arguments.length === 1 */ TODO {
                    argument := /* TODO(ElementAccessExpression): callExpression.arguments[0] */ TODO
                    if /* TODO(BinaryExpression): isStringLiteralLike(argument) && getAccessedPropertyName(reference) === escapeLeadingUnderscores(argument.text) */ TODO {
                         getTypeWithFacts(type_, /* TODO(ConditionalExpression): assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined */ TODO)
                    }
                }
            }
             type_
        }
        narrowTypeByTypePredicate := func(type_ Type, predicate TypePredicate, callExpression CallExpression, assumeTrue bool) Type {
            if /* TODO(BinaryExpression): predicate.type && !(isTypeAny(type) && (predicate.type === globalObjectType || predicate.type === globalFunctionType)) */ TODO {
                predicateArgument := getTypePredicateArgument(predicate, callExpression)
                if predicateArgument {
                    if isMatchingReference(reference, predicateArgument) {
                         getNarrowedType(type_, /* TODO(PropertyAccessExpression): predicate.type */ TODO, assumeTrue, /* TODO(FalseKeyword): false */ TODO)
                    }
                    if /* TODO(BinaryExpression): strictNullChecks && optionalChainContainsReference(predicateArgument, reference) &&                         (                             assumeTrue && !(hasTypeFacts(predicate.type, TypeFacts.EQUndefined)) ||                             !assumeTrue && everyType(predicate.type, isNullableType)                         ) */ TODO {
                        /* TODO(ExpressionStatement): type = getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull); */
                    }
                    access := getDiscriminantPropertyAccess(predicateArgument, type_)
                    if access {
                         narrowTypeByDiscriminant(type_, access, /* TODO(ArrowFunction): t => getNarrowedType(t, predicate.type!, assumeTrue, /*checkDerived* / false) */ TODO)
                    }
                }
            }
             type_
        }
        narrowType := func(type_ Type, expr Expression, assumeTrue bool) Type {
            if /* TODO(BinaryExpression): isExpressionOfOptionalChainRoot(expr) ||                 isBinaryExpression(expr.parent) && (expr.parent.operatorToken.kind === SyntaxKind.QuestionQuestionToken || expr.parent.operatorToken.kind === SyntaxKind.QuestionQuestionEqualsToken) && expr.parent.left === expr */ TODO {
                 narrowTypeByOptionality(type_, expr, assumeTrue)
            }
            /* TODO(SwitchStatement): switch (expr.kind) {                 case SyntaxKind.Identifier:                     // When narrowing a reference to a const variable, non-assigned parameter, or readonly property, we inline                     // up to five levels of aliased conditional expressions that are themselves declared as const variables.                     if (!isMatchingReference(reference, expr) && inlineLevel < 5) {                         const symbol = getResolvedSymbol(expr as Identifier);                         if (isConstantVariable(symbol)) {                             const declaration = symbol.valueDeclaration;                             if (declaration && isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isConstantReference(reference)) {                                 inlineLevel++;                                 const result = narrowType(type, declaration.initializer, assumeTrue);                                 inlineLevel--;                                 return result;                             }                         }                     }                     // falls through                 case SyntaxKind.ThisKeyword:                 case SyntaxKind.SuperKeyword:                 case SyntaxKind.PropertyAccessExpression:                 case SyntaxKind.ElementAccessExpression:                     return narrowTypeByTruthiness(type, expr, assumeTrue);                 case SyntaxKind.CallExpression:                     return narrowTypeByCallExpression(type, expr as CallExpression, assumeTrue);                 case SyntaxKind.ParenthesizedExpression:                 case SyntaxKind.NonNullExpression:                     return narrowType(type, (expr as ParenthesizedExpression | NonNullExpression).expression, assumeTrue);                 case SyntaxKind.BinaryExpression:                     return narrowTypeByBinaryExpression(type, expr as BinaryExpression, assumeTrue);                 case SyntaxKind.PrefixUnaryExpression:                     if ((expr as PrefixUnaryExpression).operator === SyntaxKind.ExclamationToken) {                         return narrowType(type, (expr as PrefixUnaryExpression).operand, !assumeTrue);                     }                     break;             } */
             type_
        }
        narrowTypeByOptionality := func(type_ Type, expr Expression, assumePresent bool) Type {
            if isMatchingReference(reference, expr) {
                 getAdjustedTypeWithFacts(type_, /* TODO(ConditionalExpression): assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull */ TODO)
            }
            access := getDiscriminantPropertyAccess(expr, type_)
            if access {
                 narrowTypeByDiscriminant(type_, access, /* TODO(ArrowFunction): t => getTypeWithFacts(t, assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull) */ TODO)
            }
             type_
        }
    }
    getTypeOfSymbolAtLocation := func(symbol Symbol, location Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        /* TODO(ExpressionStatement): symbol = getExportSymbolOfValueSymbolIfExported(symbol); */
        if /* TODO(BinaryExpression): location.kind === SyntaxKind.Identifier || location.kind === SyntaxKind.PrivateIdentifier */ TODO {
            if isRightSideOfQualifiedNameOrPropertyAccess(location) {
                /* TODO(ExpressionStatement): location = location.parent; */
            }
            if /* TODO(BinaryExpression): isExpressionNode(location) && (!isAssignmentTarget(location) || isWriteAccess(location)) */ TODO {
                type_ := removeOptionalTypeMarker(/* TODO(ConditionalExpression): isWriteAccess(location) && location.kind === SyntaxKind.PropertyAccessExpression ?                         checkPropertyAccessExpression(location as PropertyAccessExpression, /*checkMode* / undefined, /*writeOnly* / true) :                         getTypeOfExpression(location as Expression) */ TODO)
                if /* TODO(BinaryExpression): getExportSymbolOfValueSymbolIfExported(getNodeLinks(location).resolvedSymbol) === symbol */ TODO {
                     type_
                }
            }
        }
        if /* TODO(BinaryExpression): isDeclarationName(location) && isSetAccessor(location.parent) && getAnnotatedAccessorTypeNode(location.parent) */ TODO {
             getWriteTypeOfAccessors(/* TODO(PropertyAccessExpression): location.parent.symbol */ TODO)
        }
         /* TODO(ConditionalExpression): isRightSideOfAccessExpression(location) && isWriteAccess(location.parent) ? getWriteTypeOfSymbol(symbol) : getNonMissingTypeOfSymbol(symbol) */ TODO
    }
    getControlFlowContainer := func(node Node) Node {
         /* TODO(NonNullExpression): findAncestor(node.parent, node =>             isFunctionLike(node) && !getImmediatelyInvokedFunctionExpression(node) ||             node.kind === SyntaxKind.ModuleBlock ||             node.kind === SyntaxKind.SourceFile ||             node.kind === SyntaxKind.PropertyDeclaration)! */ TODO
    }
    isSymbolAssignedDefinitely := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): symbol.lastAssignmentPos !== undefined */ TODO {
             /* TODO(BinaryExpression): symbol.lastAssignmentPos < 0 */ TODO
        }
         /* TODO(BinaryExpression): isSymbolAssigned(symbol) && symbol.lastAssignmentPos !== undefined && symbol.lastAssignmentPos < 0 */ TODO
    }
    isSymbolAssigned := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !isPastLastAssignment(symbol, /*location* / undefined) */ TODO
    }
    isPastLastAssignment := func(symbol Symbol, location Node) /* TODO(undefined): boolean | undefined */ TODO {
        parent := findAncestor(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO, isFunctionOrSourceFile)
        if /* TODO(PrefixUnaryExpression): !parent */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        links := getNodeLinks(parent)
        if /* TODO(PrefixUnaryExpression): !(links.flags & NodeCheckFlags.AssignmentsMarked) */ TODO {
            /* TODO(ExpressionStatement): links.flags |= NodeCheckFlags.AssignmentsMarked; */
            if /* TODO(PrefixUnaryExpression): !hasParentWithAssignmentsMarked(parent) */ TODO {
                /* TODO(ExpressionStatement): markNodeAssignments(parent); */
            }
        }
         /* TODO(BinaryExpression): !symbol.lastAssignmentPos || location && Math.abs(symbol.lastAssignmentPos) < location.pos */ TODO
    }
    isSomeSymbolAssigned := func(rootDeclaration Node) /* TODO(undefined): boolean */ TODO {
        /* TODO(ExpressionStatement): Debug.assert(isVariableDeclaration(rootDeclaration) || isParameter(rootDeclaration)); */
         isSomeSymbolAssignedWorker(/* TODO(PropertyAccessExpression): rootDeclaration.name */ TODO)
    }
    isSomeSymbolAssignedWorker := func(node BindingName) bool {
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.Identifier */ TODO {
             isSymbolAssigned(getSymbolOfDeclaration(/* TODO(PropertyAccessExpression): node.parent */ TODO /* as */ /* TODO(TypeReference): Declaration */))
        }
         some(/* TODO(PropertyAccessExpression): node.elements */ TODO, /* TODO(ArrowFunction): e => e.kind !== SyntaxKind.OmittedExpression && isSomeSymbolAssignedWorker(e.name) */ TODO)
    }
    hasParentWithAssignmentsMarked := func(node Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!findAncestor(node.parent, node => isFunctionOrSourceFile(node) && !!(getNodeLinks(node).flags & NodeCheckFlags.AssignmentsMarked)) */ TODO
    }
    isFunctionOrSourceFile := func(node Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isFunctionLikeDeclaration(node) || isSourceFile(node) */ TODO
    }
    markNodeAssignments := func(node Node) {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:                 const assigmentTarget = getAssignmentTargetKind(node);                 if (assigmentTarget !== AssignmentKind.None) {                     const symbol = getResolvedSymbol(node as Identifier);                     const hasDefiniteAssignment = assigmentTarget === AssignmentKind.Definite || (symbol.lastAssignmentPos !== undefined && symbol.lastAssignmentPos < 0);                     if (isParameterOrMutableLocalVariable(symbol)) {                         if (symbol.lastAssignmentPos === undefined || Math.abs(symbol.lastAssignmentPos) !== Number.MAX_VALUE) {                             const referencingFunction = findAncestor(node, isFunctionOrSourceFile);                             const declaringFunction = findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile);                             symbol.lastAssignmentPos = referencingFunction === declaringFunction ? extendAssignmentPosition(node, symbol.valueDeclaration!) : Number.MAX_VALUE;                         }                         if (hasDefiniteAssignment && symbol.lastAssignmentPos > 0) {                             symbol.lastAssignmentPos *= -1;                         }                     }                 }                 return;             case SyntaxKind.ExportSpecifier:                 const exportDeclaration = (node as ExportSpecifier).parent.parent;                 const name = (node as ExportSpecifier).propertyName || (node as ExportSpecifier).name;                 if (!(node as ExportSpecifier).isTypeOnly && !exportDeclaration.isTypeOnly && !exportDeclaration.moduleSpecifier && name.kind !== SyntaxKind.StringLiteral) {                     const symbol = resolveEntityName(name, SymbolFlags.Value, /*ignoreErrors* / true, /*dontResolveAlias* / true);                     if (symbol && isParameterOrMutableLocalVariable(symbol)) {                         const sign = symbol.lastAssignmentPos !== undefined && symbol.lastAssignmentPos < 0 ? -1 : 1;                         symbol.lastAssignmentPos = sign * Number.MAX_VALUE;                     }                 }                 return;             case SyntaxKind.InterfaceDeclaration:             case SyntaxKind.TypeAliasDeclaration:             case SyntaxKind.EnumDeclaration:                 return;         } */
        if isTypeNode(node) {

        }
        /* TODO(ExpressionStatement): forEachChild(node, markNodeAssignments); */
    }
    extendAssignmentPosition := func(node Node, declaration Declaration) /* TODO(undefined): number */ TODO {
        pos := /* TODO(PropertyAccessExpression): node.pos */ TODO
        /* TODO(WhileStatement): while (node && node.pos > declaration.pos) {             switch (node.kind) {                 case SyntaxKind.VariableStatement:                 case SyntaxKind.ExpressionStatement:                 case SyntaxKind.IfStatement:                 case SyntaxKind.DoStatement:                 case SyntaxKind.WhileStatement:                 case SyntaxKind.ForStatement:                 case SyntaxKind.ForInStatement:                 case SyntaxKind.ForOfStatement:                 case SyntaxKind.WithStatement:                 case SyntaxKind.SwitchStatement:                 case SyntaxKind.TryStatement:                 case SyntaxKind.ClassDeclaration:                     pos = node.end;             }             node = node.parent;         } */
         pos
    }
    isConstantVariable := func(symbol Symbol) /* TODO(undefined): boolean | 0 */ TODO {
         /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Variable && (getDeclarationNodeFlagsFromSymbol(symbol) & NodeFlags.Constant) !== 0 */ TODO
    }
    isParameterOrMutableLocalVariable := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
        declaration := /* TODO(BinaryExpression): symbol.valueDeclaration && getRootDeclaration(symbol.valueDeclaration) */ TODO
         /* TODO(BinaryExpression): !!declaration && (             isParameter(declaration) ||             isVariableDeclaration(declaration) && (isCatchClause(declaration.parent) || isMutableLocalVariableDeclaration(declaration))         ) */ TODO
    }
    isMutableLocalVariableDeclaration := func(declaration VariableDeclaration) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): !!(declaration.parent.flags & NodeFlags.Let) && !(             getCombinedModifierFlags(declaration) & ModifierFlags.Export ||             declaration.parent.parent.kind === SyntaxKind.VariableStatement && isGlobalSourceFile(declaration.parent.parent.parent)         ) */ TODO
    }
    parameterInitializerContainsUndefined := func(declaration ParameterDeclaration) bool {
        links := getNodeLinks(declaration)
        if /* TODO(BinaryExpression): links.parameterInitializerContainsUndefined === undefined */ TODO {
            if /* TODO(PrefixUnaryExpression): !pushTypeResolution(declaration, TypeSystemPropertyName.ParameterInitializerContainsUndefined) */ TODO {
                /* TODO(ExpressionStatement): reportCircularityError(declaration.symbol); */
                 /* TODO(TrueKeyword): true */ TODO
            }
            containsUndefined := /* TODO(PrefixUnaryExpression): !!(hasTypeFacts(checkDeclarationInitializer(declaration, CheckMode.Normal), TypeFacts.IsUndefined)) */ TODO
            if /* TODO(PrefixUnaryExpression): !popTypeResolution() */ TODO {
                /* TODO(ExpressionStatement): reportCircularityError(declaration.symbol); */
                 /* TODO(TrueKeyword): true */ TODO
            }
            /* TODO(ExpressionStatement): links.parameterInitializerContainsUndefined ??= containsUndefined; */
        }
         /* TODO(PropertyAccessExpression): links.parameterInitializerContainsUndefined */ TODO
    }
    removeOptionalityFromDeclaredType := func(declaredType Type, declaration VariableLikeDeclaration) Type {
        removeUndefined := /* TODO(BinaryExpression): strictNullChecks &&             declaration.kind === SyntaxKind.Parameter &&             declaration.initializer &&             hasTypeFacts(declaredType, TypeFacts.IsUndefined) &&             !parameterInitializerContainsUndefined(declaration) */ TODO
         /* TODO(ConditionalExpression): removeUndefined ? getTypeWithFacts(declaredType, TypeFacts.NEUndefined) : declaredType */ TODO
    }
    isConstraintPosition := func(type_ Type, node Node) /* TODO(undefined): boolean */ TODO {
        parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
         /* TODO(BinaryExpression): parent.kind === SyntaxKind.PropertyAccessExpression ||             parent.kind === SyntaxKind.QualifiedName ||             parent.kind === SyntaxKind.CallExpression && (parent as CallExpression).expression === node ||             parent.kind === SyntaxKind.NewExpression && (parent as NewExpression).expression === node ||             parent.kind === SyntaxKind.ElementAccessExpression && (parent as ElementAccessExpression).expression === node &&                 !(someType(type, isGenericTypeWithoutNullableConstraint) && isGenericIndexType(getTypeOfExpression((parent as ElementAccessExpression).argumentExpression))) */ TODO
    }
    isGenericTypeWithUnionConstraint := func(type_ Type) bool {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection ?             some((type as IntersectionType).types, isGenericTypeWithUnionConstraint) :             !!(type.flags & TypeFlags.Instantiable && getBaseConstraintOrType(type).flags & (TypeFlags.Nullable | TypeFlags.Union)) */ TODO
    }
    isGenericTypeWithoutNullableConstraint := func(type_ Type) bool {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection ?             some((type as IntersectionType).types, isGenericTypeWithoutNullableConstraint) :             !!(type.flags & TypeFlags.Instantiable && !maybeTypeOfKind(getBaseConstraintOrType(type), TypeFlags.Nullable)) */ TODO
    }
    hasContextualTypeWithNoGenericTypes := func(node Node, checkMode *CheckMode) /* TODO(undefined): boolean | undefined */ TODO {
        contextualType := /* TODO(BinaryExpression): (isIdentifier(node) || isPropertyAccessExpression(node) || isElementAccessExpression(node)) &&             !((isJsxOpeningElement(node.parent) || isJsxSelfClosingElement(node.parent)) && node.parent.tagName === node) &&             (checkMode && checkMode & CheckMode.RestBindingElement ?                 getContextualType(node, ContextFlags.SkipBindingPatterns)                 : getContextualType(node, /*contextFlags* / undefined)) */ TODO
         /* TODO(BinaryExpression): contextualType && !isGenericType(contextualType) */ TODO
    }
    getNarrowableTypeForReference := func(type_ Type, reference Node, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if isNoInferType(type_) {
            /* TODO(ExpressionStatement): type = (type as SubstitutionType).baseType; */
        }
        substituteConstraints := /* TODO(BinaryExpression): !(checkMode && checkMode & CheckMode.Inferential) &&             someType(type, isGenericTypeWithUnionConstraint) &&             (isConstraintPosition(type, reference) || hasContextualTypeWithNoGenericTypes(reference, checkMode)) */ TODO
         /* TODO(ConditionalExpression): substituteConstraints ? mapType(type, getBaseConstraintOrType) : type */ TODO
    }
    isExportOrExportExpression := func(location Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!findAncestor(location, n => {             const parent = n.parent;             if (parent === undefined) {                 return "quit";             }             if (isExportAssignment(parent)) {                 return parent.expression === n && isEntityNameExpression(n);             }             if (isExportSpecifier(parent)) {                 return parent.name === n || parent.propertyName === n;             }             return false;         }) */ TODO
    }
    // OVERLOAD: markLinkedReferences := func(location /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, hint /* TODO(QualifiedName): ReferenceHint.Property */ TODO, propSymbol *Symbol, parentType Type)
    // OVERLOAD: markLinkedReferences := func(location Identifier, hint /* TODO(QualifiedName): ReferenceHint.Identifier */ TODO)
    // OVERLOAD: markLinkedReferences := func(location ExportAssignment, hint /* TODO(QualifiedName): ReferenceHint.ExportAssignment */ TODO)
    // OVERLOAD: markLinkedReferences := func(location /* TODO(UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any, hint /* TODO(QualifiedName): ReferenceHint.Jsx */ TODO)
    // OVERLOAD: markLinkedReferences := func(location /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any, hint /* TODO(QualifiedName): ReferenceHint.AsyncFunction */ TODO)
    // OVERLOAD: markLinkedReferences := func(location ImportEqualsDeclaration, hint /* TODO(QualifiedName): ReferenceHint.ExportImportEquals */ TODO)
    // OVERLOAD: markLinkedReferences := func(location ExportSpecifier, hint /* TODO(QualifiedName): ReferenceHint.ExportSpecifier */ TODO)
    // OVERLOAD: markLinkedReferences := func(location HasDecorators, hint /* TODO(QualifiedName): ReferenceHint.Decorator */ TODO)
    // OVERLOAD: markLinkedReferences := func(location Node, hint /* TODO(QualifiedName): ReferenceHint.Unspecified */ TODO, propSymbol Symbol, parentType Type)
    markLinkedReferences := func(location Node, hint ReferenceHint, propSymbol Symbol, parentType Type) {
        if /* TODO(PrefixUnaryExpression): !canCollectSymbolAliasAccessabilityData */ TODO {

        }
        if /* TODO(BinaryExpression): location.flags & NodeFlags.Ambient && !isPropertySignature(location) && !isPropertyDeclaration(location) */ TODO {

        }
        /* TODO(SwitchStatement): switch (hint) {             case ReferenceHint.Identifier:                 return markIdentifierAliasReferenced(location as Identifier);             case ReferenceHint.Property:                 return markPropertyAliasReferenced(location as PropertyAccessExpression | QualifiedName, propSymbol, parentType);             case ReferenceHint.ExportAssignment:                 return markExportAssignmentAliasReferenced(location as ExportAssignment);             case ReferenceHint.Jsx:                 return markJsxAliasReferenced(location as JsxOpeningLikeElement | JsxOpeningFragment);             case ReferenceHint.AsyncFunction:                 return markAsyncFunctionAliasReferenced(location as FunctionLikeDeclaration | MethodSignature);             case ReferenceHint.ExportImportEquals:                 return markImportEqualsAliasReferenced(location as ImportEqualsDeclaration);             case ReferenceHint.ExportSpecifier:                 return markExportSpecifierAliasReferenced(location as ExportSpecifier);             case ReferenceHint.Decorator:                 return markDecoratorAliasReferenced(location as HasDecorators);             case ReferenceHint.Unspecified: {                 // Identifiers in expression contexts are emitted, so we need to follow their referenced aliases and mark them as used                 // Some non-expression identifiers are also treated as expression identifiers for this purpose, eg, `a` in `b = {a}` or `q` in `import r = q`                 // This is the exception, rather than the rule - most non-expression identifiers are declaration names.                 if (isIdentifier(location) && (isExpressionNode(location) || isShorthandPropertyAssignment(location.parent) || (isImportEqualsDeclaration(location.parent) && location.parent.moduleReference === location)) && shouldMarkIdentifierAliasReferenced(location)) {                     if (isPropertyAccessOrQualifiedName(location.parent)) {                         const left = isPropertyAccessExpression(location.parent) ? location.parent.expression : location.parent.left;                         if (left !== location) return; // Only mark the LHS (the RHS is a property lookup)                     }                     markIdentifierAliasReferenced(location);                     return;                 }                 if (isPropertyAccessOrQualifiedName(location)) {                     let topProp: Node | undefined = location;                     while (isPropertyAccessOrQualifiedName(topProp)) {                         if (isPartOfTypeNode(topProp)) return;                         topProp = topProp.parent;                     }                     return markPropertyAliasReferenced(location);                 }                 if (isExportAssignment(location)) {                     return markExportAssignmentAliasReferenced(location);                 }                 if (isJsxOpeningLikeElement(location) || isJsxOpeningFragment(location)) {                     return markJsxAliasReferenced(location);                 }                 if (isImportEqualsDeclaration(location)) {                     if (isInternalModuleImportEqualsDeclaration(location) || checkExternalImportOrExportDeclaration(location)) {                         return markImportEqualsAliasReferenced(location);                     }                     return;                 }                 if (isExportSpecifier(location)) {                     return markExportSpecifierAliasReferenced(location);                 }                 if (isFunctionLikeDeclaration(location) || isMethodSignature(location)) {                     markAsyncFunctionAliasReferenced(location);                     // Might be decorated, fall through to decorator final case                 }                 if (!compilerOptions.emitDecoratorMetadata) {                     return;                 }                 if (!canHaveDecorators(location) || !hasDecorators(location) || !location.modifiers || !nodeCanBeDecorated(legacyDecorators, location, location.parent, location.parent.parent)) {                     return;                 }                  return markDecoratorAliasReferenced(location);             }             default:                 Debug.assertNever(hint, `Unhandled reference hint: ${hint}`);         } */
    }
    markIdentifierAliasReferenced := func(location Identifier) {
        symbol := getResolvedSymbol(location)
        if /* TODO(BinaryExpression): symbol && symbol !== argumentsSymbol && symbol !== unknownSymbol && !isThisInTypeQuery(location) */ TODO {
            /* TODO(ExpressionStatement): markAliasReferenced(symbol, location); */
        }
    }
    markPropertyAliasReferenced := func(location /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, propSymbol Symbol, parentType Type) {
        left := /* TODO(ConditionalExpression): isPropertyAccessExpression(location) ? location.expression : location.left */ TODO
        if /* TODO(BinaryExpression): isThisIdentifier(left) || !isIdentifier(left) */ TODO {

        }
        parentSymbol := getResolvedSymbol(left)
        if /* TODO(BinaryExpression): !parentSymbol || parentSymbol === unknownSymbol */ TODO {

        }
        if /* TODO(BinaryExpression): getIsolatedModules(compilerOptions) || (shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location)) */ TODO {
            /* TODO(ExpressionStatement): markAliasReferenced(parentSymbol, location); */

        }
        leftType := /* TODO(BinaryExpression): parentType || checkExpressionCached(left) */ TODO
        if /* TODO(BinaryExpression): isTypeAny(leftType) || leftType === silentNeverType */ TODO {
            /* TODO(ExpressionStatement): markAliasReferenced(parentSymbol, location); */

        }
        prop := propSymbol
        if /* TODO(BinaryExpression): !prop && !parentType */ TODO {
            right := /* TODO(ConditionalExpression): isPropertyAccessExpression(location) ? location.name : location.right */ TODO
            lexicallyScopedSymbol := /* TODO(BinaryExpression): isPrivateIdentifier(right) && lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right) */ TODO
            assignmentKind := getAssignmentTargetKind(location)
            apparentType := getApparentType(/* TODO(ConditionalExpression): assignmentKind !== AssignmentKind.None || isMethodAccessForCall(location) ? getWidenedType(leftType) : leftType */ TODO)
            /* TODO(ExpressionStatement): prop = isPrivateIdentifier(right) ? lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(apparentType, lexicallyScopedSymbol) || undefined : getPropertyOfType(apparentType, right.escapedText); */
        }
        if /* TODO(PrefixUnaryExpression): !(prop && (isConstEnumOrConstEnumOnlyModule(prop) || prop.flags & SymbolFlags.EnumMember && location.parent.kind === SyntaxKind.EnumMember)) */ TODO {
            /* TODO(ExpressionStatement): markAliasReferenced(parentSymbol, location); */
        }

    }
    markExportAssignmentAliasReferenced := func(location ExportAssignment) {
        if isIdentifier(/* TODO(PropertyAccessExpression): location.expression */ TODO) {
            id := /* TODO(PropertyAccessExpression): location.expression */ TODO
            sym := getExportSymbolOfValueSymbolIfExported(resolveEntityName(id, /* TODO(PropertyAccessExpression): SymbolFlags.All */ TODO, /* TODO(TrueKeyword): true */ TODO, /* TODO(TrueKeyword): true */ TODO, location))
            if sym {
                /* TODO(ExpressionStatement): markAliasReferenced(sym, id); */
            }
        }
    }
    markJsxAliasReferenced := func(node /* TODO(UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any) {
        if /* TODO(PrefixUnaryExpression): !getJsxNamespaceContainerForImplicitImport(node) */ TODO {
            jsxFactoryRefErr := /* TODO(ConditionalExpression): diagnostics && compilerOptions.jsx === JsxEmit.React ? Diagnostics.Cannot_find_name_0 : undefined */ TODO
            jsxFactoryNamespace := getJsxNamespace(node)
            jsxFactoryLocation := /* TODO(ConditionalExpression): isJsxOpeningLikeElement(node) ? node.tagName : node */ TODO
            var jsxFactorySym *Symbol
            if /* TODO(PrefixUnaryExpression): !(isJsxOpeningFragment(node) && jsxFactoryNamespace === "null") */ TODO {
                /* TODO(ExpressionStatement): jsxFactorySym = resolveName(jsxFactoryLocation, jsxFactoryNamespace, SymbolFlags.Value, jsxFactoryRefErr, /*isUse* / true); */
            }
            if jsxFactorySym {
                /* TODO(ExpressionStatement): jsxFactorySym.isReferenced = SymbolFlags.All; */
                if /* TODO(BinaryExpression): canCollectSymbolAliasAccessabilityData && jsxFactorySym.flags & SymbolFlags.Alias && !getTypeOnlyAliasDeclaration(jsxFactorySym) */ TODO {
                    /* TODO(ExpressionStatement): markAliasSymbolAsReferenced(jsxFactorySym); */
                }
            }
            if isJsxOpeningFragment(node) {
                file := getSourceFileOfNode(node)
                localJsxNamespace := getLocalJsxNamespace(file)
                if localJsxNamespace {
                    /* TODO(ExpressionStatement): resolveName(jsxFactoryLocation, localJsxNamespace, SymbolFlags.Value, jsxFactoryRefErr, /*isUse* / true); */
                }
            }
        }

    }
    markAsyncFunctionAliasReferenced := func(location /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any) {
        if /* TODO(BinaryExpression): languageVersion < ScriptTarget.ES2015 */ TODO {
            if /* TODO(BinaryExpression): getFunctionFlags(location) & FunctionFlags.Async */ TODO {
                returnTypeNode := getEffectiveReturnTypeNode(location)
                /* TODO(ExpressionStatement): markTypeNodeAsReferenced(returnTypeNode); */
            }
        }
    }
    markImportEqualsAliasReferenced := func(location ImportEqualsDeclaration) {
        if hasSyntacticModifier(location, /* TODO(PropertyAccessExpression): ModifierFlags.Export */ TODO) {
            /* TODO(ExpressionStatement): markExportAsReferenced(location); */
        }
    }
    markExportSpecifierAliasReferenced := func(location ExportSpecifier) {
        if /* TODO(BinaryExpression): !location.parent.parent.moduleSpecifier && !location.isTypeOnly && !location.parent.parent.isTypeOnly */ TODO {
            exportedName := /* TODO(BinaryExpression): location.propertyName || location.name */ TODO
            if /* TODO(BinaryExpression): exportedName.kind === SyntaxKind.StringLiteral */ TODO {

            }
            symbol := resolveName(exportedName, /* TODO(PropertyAccessExpression): exportedName.escapedText */ TODO, /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias */ TODO, undefined, /* TODO(TrueKeyword): true */ TODO)
            if /* TODO(BinaryExpression): symbol && (symbol === undefinedSymbol || symbol === globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0]))) */ TODO {
            } else {
                target := /* TODO(BinaryExpression): symbol && (symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol) */ TODO
                if /* TODO(BinaryExpression): !target || getSymbolFlags(target) & SymbolFlags.Value */ TODO {
                    /* TODO(ExpressionStatement): markExportAsReferenced(location); */
                    /* TODO(ExpressionStatement): markIdentifierAliasReferenced(exportedName); */
                }
            }

        }
    }
    markDecoratorAliasReferenced := func(node HasDecorators) {
        if /* TODO(PropertyAccessExpression): compilerOptions.emitDecoratorMetadata */ TODO {
            firstDecorator := find(/* TODO(PropertyAccessExpression): node.modifiers */ TODO, isDecorator)
            if /* TODO(PrefixUnaryExpression): !firstDecorator */ TODO {

            }
            /* TODO(ExpressionStatement): checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.Metadata); */
            /* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.ClassDeclaration:                     const constructor = getFirstConstructorWithBody(node);                     if (constructor) {                         for (const parameter of constructor.parameters) {                             markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));                         }                     }                     break;                  case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                     const otherKind = node.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor;                     const otherAccessor = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfDeclaration(node), otherKind);                     markDecoratorMedataDataTypeNodeAsReferenced(getAnnotatedAccessorTypeNode(node) || otherAccessor && getAnnotatedAccessorTypeNode(otherAccessor));                     break;                 case SyntaxKind.MethodDeclaration:                     for (const parameter of node.parameters) {                         markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));                     }                      markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(node));                     break;                  case SyntaxKind.PropertyDeclaration:                     markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveTypeAnnotationNode(node));                     break;                  case SyntaxKind.Parameter:                     markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(node));                     const containingSignature = node.parent;                     for (const parameter of containingSignature.parameters) {                         markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));                     }                     markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(containingSignature));                     break;             } */
        }
    }
    markAliasReferenced := func(symbol Symbol, location Node) {
        if /* TODO(PrefixUnaryExpression): !canCollectSymbolAliasAccessabilityData */ TODO {

        }
        if /* TODO(BinaryExpression): isNonLocalAlias(symbol, /*excludes* / SymbolFlags.Value) && !isInTypeQuery(location) */ TODO {
            target := resolveAlias(symbol)
            if /* TODO(BinaryExpression): getSymbolFlags(symbol, /*excludeTypeOnlyMeanings* / true) & (SymbolFlags.Value | SymbolFlags.ExportValue) */ TODO {
                if /* TODO(BinaryExpression): getIsolatedModules(compilerOptions) ||                     shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location) ||                     !isConstEnumOrConstEnumOnlyModule(getExportSymbolOfValueSymbolIfExported(target)) */ TODO {
                    /* TODO(ExpressionStatement): markAliasSymbolAsReferenced(symbol); */
                }
            }
        }
    }
    markAliasSymbolAsReferenced := func(symbol Symbol) /* TODO(undefined): undefined */ TODO {
        /* TODO(ExpressionStatement): Debug.assert(canCollectSymbolAliasAccessabilityData); */
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.referenced */ TODO {
            /* TODO(ExpressionStatement): links.referenced = true; */
            node := getDeclarationOfAliasSymbol(symbol)
            if /* TODO(PrefixUnaryExpression): !node */ TODO {
                /* TODO(CallExpression): Debug.fail() */
            }
            if isInternalModuleImportEqualsDeclaration(node) {
                if /* TODO(BinaryExpression): getSymbolFlags(resolveSymbol(symbol)) & SymbolFlags.Value */ TODO {
                    left := getFirstIdentifier(/* TODO(PropertyAccessExpression): node.moduleReference */ TODO /* as */ /* TODO(TypeReference): EntityNameExpression */)
                    /* TODO(ExpressionStatement): markIdentifierAliasReferenced(left); */
                }
            }
        }
    }
    markExportAsReferenced := func(node /* TODO(UnionType): ImportEqualsDeclaration | ExportSpecifier */ any) {
        symbol := getSymbolOfDeclaration(node)
        target := resolveAlias(symbol)
        if target {
            markAlias := /* TODO(BinaryExpression): target === unknownSymbol ||                 ((getSymbolFlags(symbol, /*excludeTypeOnlyMeanings* / true) & SymbolFlags.Value) && !isConstEnumOrConstEnumOnlyModule(target)) */ TODO
            if markAlias {
                /* TODO(ExpressionStatement): markAliasSymbolAsReferenced(symbol); */
            }
        }
    }
    markEntityNameOrEntityExpressionAsReference := func(typeName *EntityNameOrEntityNameExpression, forDecoratorMetadata bool) {
        if /* TODO(PrefixUnaryExpression): !typeName */ TODO {
        }
        rootName := getFirstIdentifier(typeName)
        meaning := /* TODO(BinaryExpression): (typeName.kind === SyntaxKind.Identifier ? SymbolFlags.Type : SymbolFlags.Namespace) | SymbolFlags.Alias */ TODO
        rootSymbol := resolveName(rootName, /* TODO(PropertyAccessExpression): rootName.escapedText */ TODO, meaning, undefined, /* TODO(TrueKeyword): true */ TODO)
        if /* TODO(BinaryExpression): rootSymbol && rootSymbol.flags & SymbolFlags.Alias */ TODO {
            if /* TODO(BinaryExpression): canCollectSymbolAliasAccessabilityData                 && symbolIsValue(rootSymbol)                 && !isConstEnumOrConstEnumOnlyModule(resolveAlias(rootSymbol))                 && !getTypeOnlyAliasDeclaration(rootSymbol) */ TODO {
                /* TODO(ExpressionStatement): markAliasSymbolAsReferenced(rootSymbol); */
            } else if /* TODO(BinaryExpression): forDecoratorMetadata                 && getIsolatedModules(compilerOptions)                 && getEmitModuleKind(compilerOptions) >= ModuleKind.ES2015                 && !symbolIsValue(rootSymbol)                 && !some(rootSymbol.declarations, isTypeOnlyImportOrExportDeclaration) */ TODO {
                diag := error(typeName, /* TODO(PropertyAccessExpression): Diagnostics.A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled */ TODO)
                aliasDeclaration := find(/* TODO(BinaryExpression): rootSymbol.declarations || emptyArray */ TODO, isAliasSymbolDeclaration)
                if aliasDeclaration {
                    /* TODO(ExpressionStatement): addRelatedInfo(diag, createDiagnosticForNode(aliasDeclaration, Diagnostics._0_was_imported_here, idText(rootName))); */
                }
            }
        }
    }
    markTypeNodeAsReferenced := func(node *TypeNode) {
        /* TODO(ExpressionStatement): markEntityNameOrEntityExpressionAsReference(node && getEntityNameFromTypeNode(node), /*forDecoratorMetadata* / false); */
    }
    markDecoratorMedataDataTypeNodeAsReferenced := func(node *TypeNode) {
        entityName := getEntityNameForDecoratorMetadata(node)
        if /* TODO(BinaryExpression): entityName && isEntityName(entityName) */ TODO {
            /* TODO(ExpressionStatement): markEntityNameOrEntityExpressionAsReference(entityName, /*forDecoratorMetadata* / true); */
        }
    }
    getNarrowedTypeOfSymbol := func(symbol Symbol, location Identifier) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        type_ := getTypeOfSymbol(symbol)
        declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
        if declaration {
            if /* TODO(BinaryExpression): isBindingElement(declaration) && !declaration.initializer && !declaration.dotDotDotToken && declaration.parent.elements.length >= 2 */ TODO {
                parent := /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO
                rootDeclaration := getRootDeclaration(parent)
                if /* TODO(BinaryExpression): rootDeclaration.kind === SyntaxKind.VariableDeclaration && getCombinedNodeFlagsCached(rootDeclaration) & NodeFlags.Constant || rootDeclaration.kind === SyntaxKind.Parameter */ TODO {
                    links := getNodeLinks(parent)
                    if /* TODO(PrefixUnaryExpression): !(links.flags & NodeCheckFlags.InCheckIdentifier) */ TODO {
                        /* TODO(ExpressionStatement): links.flags |= NodeCheckFlags.InCheckIdentifier; */
                        parentType := getTypeForBindingElementParent(parent, /* TODO(PropertyAccessExpression): CheckMode.Normal */ TODO)
                        parentTypeConstraint := /* TODO(BinaryExpression): parentType && mapType(parentType, getBaseConstraintOrType) */ TODO
                        /* TODO(ExpressionStatement): links.flags &= ~NodeCheckFlags.InCheckIdentifier; */
                        if /* TODO(BinaryExpression): parentTypeConstraint && parentTypeConstraint.flags & TypeFlags.Union && !(rootDeclaration.kind === SyntaxKind.Parameter && isSomeSymbolAssigned(rootDeclaration)) */ TODO {
                            pattern := /* TODO(PropertyAccessExpression): declaration.parent */ TODO
                            narrowedType := getFlowTypeOfReference(pattern, parentTypeConstraint, parentTypeConstraint, undefined, /* TODO(PropertyAccessExpression): location.flowNode */ TODO)
                            if /* TODO(BinaryExpression): narrowedType.flags & TypeFlags.Never */ TODO {
                                 neverType
                            }
                             getBindingElementTypeFromParentType(declaration, narrowedType, /* TODO(TrueKeyword): true */ TODO)
                        }
                    }
                }
            }
            if /* TODO(BinaryExpression): isParameter(declaration) && !declaration.type && !declaration.initializer && !declaration.dotDotDotToken */ TODO {
                func_ := /* TODO(PropertyAccessExpression): declaration.parent */ TODO
                if /* TODO(BinaryExpression): func.parameters.length >= 2 && isContextSensitiveFunctionOrObjectLiteralMethod(func) */ TODO {
                    contextualSignature := getContextualSignature(func_)
                    if /* TODO(BinaryExpression): contextualSignature && contextualSignature.parameters.length === 1 && signatureHasRestParameter(contextualSignature) */ TODO {
                        restType := getReducedApparentType(instantiateType(getTypeOfSymbol(/* TODO(ElementAccessExpression): contextualSignature.parameters[0] */ TODO), /* TODO(PropertyAccessExpression): getInferenceContext(func)?.nonFixingMapper */ TODO))
                        if /* TODO(BinaryExpression): restType.flags & TypeFlags.Union && everyType(restType, isTupleType) && !some(func.parameters, isSomeSymbolAssigned) */ TODO {
                            narrowedType := getFlowTypeOfReference(func_, restType, restType, undefined, /* TODO(PropertyAccessExpression): location.flowNode */ TODO)
                            index := /* TODO(BinaryExpression): func.parameters.indexOf(declaration) - (getThisParameter(func) ? 1 : 0) */ TODO
                             getIndexedAccessType(narrowedType, getNumberLiteralType(index))
                        }
                    }
                }
            }
        }
         type_
    }
    checkIdentifierCalculateNodeCheckFlags := func(node Identifier, symbol Symbol) {
        if isThisInTypeQuery(node) {
        }
        if /* TODO(BinaryExpression): symbol === argumentsSymbol */ TODO {
            if isInPropertyInitializerOrClassStaticBlock(node) {
                /* TODO(ExpressionStatement): error(node, Diagnostics.arguments_cannot_be_referenced_in_property_initializers); */

            }
            container := getContainingFunction(node)
            if container {
                if /* TODO(BinaryExpression): languageVersion < ScriptTarget.ES2015 */ TODO {
                    if /* TODO(BinaryExpression): container.kind === SyntaxKind.ArrowFunction */ TODO {
                        /* TODO(ExpressionStatement): error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES5_Consider_using_a_standard_function_expression); */
                    } else if hasSyntacticModifier(container, /* TODO(PropertyAccessExpression): ModifierFlags.Async */ TODO) {
                        /* TODO(ExpressionStatement): error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES5_Consider_using_a_standard_function_or_method); */
                    }
                }
                /* TODO(ExpressionStatement): getNodeLinks(container).flags |= NodeCheckFlags.CaptureArguments; */
                /* TODO(WhileStatement): while (container && isArrowFunction(container)) {                     container = getContainingFunction(container);                     if (container) {                         getNodeLinks(container).flags |= NodeCheckFlags.CaptureArguments;                     }                 } */
            }

        }
        localOrExportSymbol := getExportSymbolOfValueSymbolIfExported(symbol)
        targetSymbol := resolveAliasWithDeprecationCheck(localOrExportSymbol, node)
        if /* TODO(BinaryExpression): isDeprecatedSymbol(targetSymbol) && isUncalledFunctionReference(node, targetSymbol) && targetSymbol.declarations */ TODO {
            /* TODO(ExpressionStatement): addDeprecatedSuggestion(node, targetSymbol.declarations, node.escapedText as string); */
        }
        declaration := /* TODO(PropertyAccessExpression): localOrExportSymbol.valueDeclaration */ TODO
        if /* TODO(BinaryExpression): declaration && localOrExportSymbol.flags & SymbolFlags.Class */ TODO {
            if /* TODO(BinaryExpression): isClassLike(declaration) && declaration.name !== node */ TODO {
                container := getThisContainer(node, /* TODO(FalseKeyword): false */ TODO, /* TODO(FalseKeyword): false */ TODO)
                /* TODO(WhileStatement): while (container.kind !== SyntaxKind.SourceFile && container.parent !== declaration) {                     container = getThisContainer(container, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false);                 } */
                if /* TODO(BinaryExpression): container.kind !== SyntaxKind.SourceFile */ TODO {
                    /* TODO(ExpressionStatement): getNodeLinks(declaration).flags |= NodeCheckFlags.ContainsConstructorReference; */
                    /* TODO(ExpressionStatement): getNodeLinks(container).flags |= NodeCheckFlags.ContainsConstructorReference; */
                    /* TODO(ExpressionStatement): getNodeLinks(node).flags |= NodeCheckFlags.ConstructorReference; */
                }
            }
        }
        /* TODO(ExpressionStatement): checkNestedBlockScopedBinding(node, symbol); */
    }
    checkIdentifier := func(node Identifier, checkMode *CheckMode) Type {
        if isThisInTypeQuery(node) {
             checkThisExpression(node)
        }
        symbol := getResolvedSymbol(node)
        if /* TODO(BinaryExpression): symbol === unknownSymbol */ TODO {
             errorType
        }
        /* TODO(ExpressionStatement): checkIdentifierCalculateNodeCheckFlags(node, symbol); */
        if /* TODO(BinaryExpression): symbol === argumentsSymbol */ TODO {
            if isInPropertyInitializerOrClassStaticBlock(node) {
                 errorType
            }
             getTypeOfSymbol(symbol)
        }
        if shouldMarkIdentifierAliasReferenced(node) {
            /* TODO(ExpressionStatement): markLinkedReferences(node, ReferenceHint.Identifier); */
        }
        localOrExportSymbol := getExportSymbolOfValueSymbolIfExported(symbol)
        declaration := /* TODO(PropertyAccessExpression): localOrExportSymbol.valueDeclaration */ TODO
        immediateDeclaration := declaration
        if /* TODO(BinaryExpression): declaration && declaration.kind === SyntaxKind.BindingElement && contains(contextualBindingPatterns, declaration.parent) && findAncestor(node, parent => parent === declaration!.parent) */ TODO {
             nonInferrableAnyType
        }
        type_ := getNarrowedTypeOfSymbol(localOrExportSymbol, node)
        assignmentKind := getAssignmentTargetKind(node)
        if assignmentKind {
            if /* TODO(BinaryExpression): !(localOrExportSymbol.flags & SymbolFlags.Variable) &&                 !(isInJSFile(node) && localOrExportSymbol.flags & SymbolFlags.ValueModule) */ TODO {
                assignmentError := /* TODO(ConditionalExpression): localOrExportSymbol.flags & SymbolFlags.Enum ? Diagnostics.Cannot_assign_to_0_because_it_is_an_enum                     : localOrExportSymbol.flags & SymbolFlags.Class ? Diagnostics.Cannot_assign_to_0_because_it_is_a_class                     : localOrExportSymbol.flags & SymbolFlags.Module ? Diagnostics.Cannot_assign_to_0_because_it_is_a_namespace                     : localOrExportSymbol.flags & SymbolFlags.Function ? Diagnostics.Cannot_assign_to_0_because_it_is_a_function                     : localOrExportSymbol.flags & SymbolFlags.Alias ? Diagnostics.Cannot_assign_to_0_because_it_is_an_import                     : Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable */ TODO
                /* TODO(ExpressionStatement): error(node, assignmentError, symbolToString(symbol)); */
                 errorType
            }
            if isReadonlySymbol(localOrExportSymbol) {
                if /* TODO(BinaryExpression): localOrExportSymbol.flags & SymbolFlags.Variable */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_constant, symbolToString(symbol)); */
                } else {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(symbol)); */
                }
                 errorType
            }
        }
        isAlias := /* TODO(BinaryExpression): localOrExportSymbol.flags & SymbolFlags.Alias */ TODO
        if /* TODO(BinaryExpression): localOrExportSymbol.flags & SymbolFlags.Variable */ TODO {
            if /* TODO(BinaryExpression): assignmentKind === AssignmentKind.Definite */ TODO {
                 /* TODO(ConditionalExpression): isInCompoundLikeAssignment(node) ? getBaseTypeOfLiteralType(type) : type */ TODO
            }
        } else if isAlias {
            /* TODO(ExpressionStatement): declaration = getDeclarationOfAliasSymbol(symbol); */
        } else {
             type_
        }
        if /* TODO(PrefixUnaryExpression): !declaration */ TODO {
             type_
        }
        /* TODO(ExpressionStatement): type = getNarrowableTypeForReference(type, node, checkMode); */
        isParameter := /* TODO(BinaryExpression): getRootDeclaration(declaration).kind === SyntaxKind.Parameter */ TODO
        declarationContainer := getControlFlowContainer(declaration)
        flowContainer := getControlFlowContainer(node)
        isOuterVariable := /* TODO(BinaryExpression): flowContainer !== declarationContainer */ TODO
        isSpreadDestructuringAssignmentTarget := /* TODO(BinaryExpression): node.parent && node.parent.parent && isSpreadAssignment(node.parent) && isDestructuringAssignmentTarget(node.parent.parent) */ TODO
        isModuleExports := /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ModuleExports */ TODO
        typeIsAutomatic := /* TODO(BinaryExpression): type === autoType || type === autoArrayType */ TODO
        isAutomaticTypeInNonNull := /* TODO(BinaryExpression): typeIsAutomatic && node.parent.kind === SyntaxKind.NonNullExpression */ TODO
        /* TODO(WhileStatement): while (             flowContainer !== declarationContainer && (                 flowContainer.kind === SyntaxKind.FunctionExpression ||                 flowContainer.kind === SyntaxKind.ArrowFunction ||                 isObjectLiteralOrClassExpressionMethodOrAccessor(flowContainer)             ) && (                 isConstantVariable(localOrExportSymbol) && type !== autoArrayType ||                 isParameterOrMutableLocalVariable(localOrExportSymbol) && isPastLastAssignment(localOrExportSymbol, node)             )         ) {             flowContainer = getControlFlowContainer(flowContainer);         } */
        isNeverInitialized := /* TODO(BinaryExpression): immediateDeclaration && isVariableDeclaration(immediateDeclaration) && !immediateDeclaration.initializer && !immediateDeclaration.exclamationToken && isMutableLocalVariableDeclaration(immediateDeclaration) && !isSymbolAssignedDefinitely(symbol) */ TODO
        assumeInitialized := /* TODO(BinaryExpression): isParameter || isAlias ||             (isOuterVariable && !isNeverInitialized) ||             isSpreadDestructuringAssignmentTarget || isModuleExports || isSameScopedBindingElement(node, declaration) ||             type !== autoType && type !== autoArrayType && (!strictNullChecks || (type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void)) !== 0 ||                     isInTypeQuery(node) || isInAmbientOrTypeNode(node) || node.parent.kind === SyntaxKind.ExportSpecifier) ||             node.parent.kind === SyntaxKind.NonNullExpression ||             declaration.kind === SyntaxKind.VariableDeclaration && (declaration as VariableDeclaration).exclamationToken ||             declaration.flags & NodeFlags.Ambient */ TODO
        initialType := /* TODO(ConditionalExpression): isAutomaticTypeInNonNull ? undefinedType :             assumeInitialized ? (isParameter ? removeOptionalityFromDeclaredType(type, declaration as VariableLikeDeclaration) : type) :             typeIsAutomatic ? undefinedType : getOptionalType(type) */ TODO
        flowType := /* TODO(ConditionalExpression): isAutomaticTypeInNonNull ? getNonNullableType(getFlowTypeOfReference(node, type, initialType, flowContainer)) :             getFlowTypeOfReference(node, type, initialType, flowContainer) */ TODO
        if /* TODO(BinaryExpression): !isEvolvingArrayOperationTarget(node) && (type === autoType || type === autoArrayType) */ TODO {
            if /* TODO(BinaryExpression): flowType === autoType || flowType === autoArrayType */ TODO {
                if noImplicitAny {
                    /* TODO(ExpressionStatement): error(getNameOfDeclaration(declaration), Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined, symbolToString(symbol), typeToString(flowType)); */
                    /* TODO(ExpressionStatement): error(node, Diagnostics.Variable_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType)); */
                }
                 convertAutoToAny(flowType)
            }
        } else if /* TODO(BinaryExpression): !assumeInitialized && !containsUndefinedType(type) && containsUndefinedType(flowType) */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.Variable_0_is_used_before_being_assigned, symbolToString(symbol)); */
             type_
        }
         /* TODO(ConditionalExpression): assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType */ TODO
    }
    isSameScopedBindingElement := func(node Identifier, declaration Declaration) /* TODO(undefined): boolean | undefined */ TODO {
        if isBindingElement(declaration) {
            bindingElement := findAncestor(node, isBindingElement)
             /* TODO(BinaryExpression): bindingElement && getRootDeclaration(bindingElement) === getRootDeclaration(declaration) */ TODO
        }
    }
    shouldMarkIdentifierAliasReferenced := func(node Identifier) bool {
        parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
        if parent {
            if /* TODO(BinaryExpression): isPropertyAccessExpression(parent) && parent.expression === node */ TODO {
                 /* TODO(FalseKeyword): false */ TODO
            }
            if /* TODO(BinaryExpression): isExportSpecifier(parent) && parent.isTypeOnly */ TODO {
                 /* TODO(FalseKeyword): false */ TODO
            }
            greatGrandparent := /* TODO(PropertyAccessExpression): parent.parent?.parent */ TODO
            if /* TODO(BinaryExpression): greatGrandparent && isExportDeclaration(greatGrandparent) && greatGrandparent.isTypeOnly */ TODO {
                 /* TODO(FalseKeyword): false */ TODO
            }
        }
         /* TODO(TrueKeyword): true */ TODO
    }
    isInsideFunctionOrInstancePropertyInitializer := func(node Node, threshold Node) bool {
         /* TODO(PrefixUnaryExpression): !!findAncestor(node, n =>             n === threshold ? "quit" : isFunctionLike(n) || (                 n.parent && isPropertyDeclaration(n.parent) && !hasStaticModifier(n.parent) && n.parent.initializer === n             )) */ TODO
    }
    getPartOfForStatementContainingNode := func(node Node, container ForStatement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO {
         findAncestor(node, /* TODO(ArrowFunction): n => n === container ? "quit" : n === container.initializer || n === container.condition || n === container.incrementor || n === container.statement */ TODO)
    }
    getEnclosingIterationStatement := func(node Node) Node {
         findAncestor(node, /* TODO(ArrowFunction): n => (!n || nodeStartsNewLexicalEnvironment(n)) ? "quit" : isIterationStatement(n, /*lookInLabeledStatements* / false) */ TODO)
    }
    checkNestedBlockScopedBinding := func(node Identifier, symbol Symbol) {
        if /* TODO(BinaryExpression): languageVersion >= ScriptTarget.ES2015 ||             (symbol.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.Class)) === 0 ||             !symbol.valueDeclaration ||             isSourceFile(symbol.valueDeclaration) ||             symbol.valueDeclaration.parent.kind === SyntaxKind.CatchClause */ TODO {

        }
        container := getEnclosingBlockScopeContainer(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
        isCaptured := isInsideFunctionOrInstancePropertyInitializer(node, container)
        enclosingIterationStatement := getEnclosingIterationStatement(container)
        if enclosingIterationStatement {
            if isCaptured {
                capturesBlockScopeBindingInLoopBody := /* TODO(TrueKeyword): true */ TODO
                if isForStatement(container) {
                    varDeclList := getAncestor(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO, /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclarationList */ TODO)
                    if /* TODO(BinaryExpression): varDeclList && varDeclList.parent === container */ TODO {
                        part := getPartOfForStatementContainingNode(/* TODO(PropertyAccessExpression): node.parent */ TODO, container)
                        if part {
                            links := getNodeLinks(part)
                            /* TODO(ExpressionStatement): links.flags |= NodeCheckFlags.ContainsCapturedBlockScopeBinding; */
                            capturedBindings := /* TODO(BinaryExpression): links.capturedBlockScopeBindings || (links.capturedBlockScopeBindings = []) */ TODO
                            /* TODO(ExpressionStatement): pushIfUnique(capturedBindings, symbol); */
                            if /* TODO(BinaryExpression): part === container.initializer */ TODO {
                                /* TODO(ExpressionStatement): capturesBlockScopeBindingInLoopBody = false; */
                            }
                        }
                    }
                }
                if capturesBlockScopeBindingInLoopBody {
                    /* TODO(ExpressionStatement): getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding; */
                }
            }
            if isForStatement(container) {
                varDeclList := getAncestor(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO, /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclarationList */ TODO)
                if /* TODO(BinaryExpression): varDeclList && varDeclList.parent === container && isAssignedInBodyOfForStatement(node, container) */ TODO {
                    /* TODO(ExpressionStatement): getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.NeedsLoopOutParameter; */
                }
            }
            /* TODO(ExpressionStatement): getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.BlockScopedBindingInLoop; */
        }
        if isCaptured {
            /* TODO(ExpressionStatement): getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.CapturedBlockScopedBinding; */
        }
    }
    isBindingCapturedByNode := func(node Node, decl /* TODO(UnionType): VariableDeclaration | BindingElement */ any) /* TODO(undefined): boolean */ TODO {
        links := getNodeLinks(node)
         /* TODO(BinaryExpression): !!links && contains(links.capturedBlockScopeBindings, getSymbolOfDeclaration(decl)) */ TODO
    }
    isAssignedInBodyOfForStatement := func(node Identifier, container ForStatement) bool {
        var current Node = node
        /* TODO(WhileStatement): while (current.parent.kind === SyntaxKind.ParenthesizedExpression) {             current = current.parent;         } */
        isAssigned := /* TODO(FalseKeyword): false */ TODO
        if isAssignmentTarget(current) {
            /* TODO(ExpressionStatement): isAssigned = true; */
        } else if /* TODO(ParenthesizedExpression): (current.parent.kind === SyntaxKind.PrefixUnaryExpression || current.parent.kind === SyntaxKind.PostfixUnaryExpression) */ TODO {
            expr := /* TODO(PropertyAccessExpression): current.parent */ TODO /* as */ /* TODO(UnionType): PrefixUnaryExpression | PostfixUnaryExpression */
            /* TODO(ExpressionStatement): isAssigned = expr.operator === SyntaxKind.PlusPlusToken || expr.operator === SyntaxKind.MinusMinusToken; */
        }
        if /* TODO(PrefixUnaryExpression): !isAssigned */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(PrefixUnaryExpression): !!findAncestor(current, n => n === container ? "quit" : n === container.statement) */ TODO
    }
    captureLexicalThis := func(node Node, container Node) {
        /* TODO(ExpressionStatement): getNodeLinks(node).flags |= NodeCheckFlags.LexicalThis; */
        if /* TODO(BinaryExpression): container.kind === SyntaxKind.PropertyDeclaration || container.kind === SyntaxKind.Constructor */ TODO {
            classNode := /* TODO(PropertyAccessExpression): container.parent */ TODO
            /* TODO(ExpressionStatement): getNodeLinks(classNode).flags |= NodeCheckFlags.CaptureThis; */
        } else {
            /* TODO(ExpressionStatement): getNodeLinks(container).flags |= NodeCheckFlags.CaptureThis; */
        }
    }
    findFirstSuperCall := func(node Node) *SuperCall {
         /* TODO(ConditionalExpression): isSuperCall(node) ? node :             isFunctionLike(node) ? undefined :             forEachChild(node, findFirstSuperCall) */ TODO
    }
    classDeclarationExtendsNull := func(classDecl ClassLikeDeclaration) bool {
        classSymbol := getSymbolOfDeclaration(classDecl)
        classInstanceType := getDeclaredTypeOfSymbol(classSymbol) /* as */ /* TODO(TypeReference): InterfaceType */
        baseConstructorType := getBaseConstructorTypeOfClass(classInstanceType)
         /* TODO(BinaryExpression): baseConstructorType === nullWideningType */ TODO
    }
    checkThisBeforeSuper := func(node Node, container Node, diagnosticMessage DiagnosticMessage) {
        containingClassDecl := /* TODO(PropertyAccessExpression): container.parent */ TODO /* as */ /* TODO(TypeReference): ClassDeclaration */
        baseTypeNode := getClassExtendsHeritageElement(containingClassDecl)
        if /* TODO(BinaryExpression): baseTypeNode && !classDeclarationExtendsNull(containingClassDecl) */ TODO {
            if /* TODO(BinaryExpression): canHaveFlowNode(node) && node.flowNode && !isPostSuperFlowNode(node.flowNode, /*noCacheCheck* / false) */ TODO {
                /* TODO(ExpressionStatement): error(node, diagnosticMessage); */
            }
        }
    }
    checkThisInStaticClassFieldInitializerInDecoratedClass := func(thisExpression Node, container Node) {
        if /* TODO(BinaryExpression): isPropertyDeclaration(container) && hasStaticModifier(container) && legacyDecorators &&             container.initializer && textRangeContainsPositionInclusive(container.initializer, thisExpression.pos) && hasDecorators(container.parent) */ TODO {
            /* TODO(ExpressionStatement): error(thisExpression, Diagnostics.Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class); */
        }
    }
    checkThisExpression := func(node Node) Type {
        isNodeInTypeQuery := isInTypeQuery(node)
        container := getThisContainer(node, /* TODO(TrueKeyword): true */ TODO, /* TODO(TrueKeyword): true */ TODO)
        capturedByArrowFunction := /* TODO(FalseKeyword): false */ TODO
        thisInComputedPropertyName := /* TODO(FalseKeyword): false */ TODO
        if /* TODO(BinaryExpression): container.kind === SyntaxKind.Constructor */ TODO {
            /* TODO(ExpressionStatement): checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class); */
        }
        /* TODO(WhileStatement): while (true) {             // Now skip arrow functions to get the "real" owner of 'this'.             if (container.kind === SyntaxKind.ArrowFunction) {                 container = getThisContainer(container, /*includeArrowFunctions* / false, !thisInComputedPropertyName);                 capturedByArrowFunction = true;             }              if (container.kind === SyntaxKind.ComputedPropertyName) {                 container = getThisContainer(container, !capturedByArrowFunction, /*includeClassComputedPropertyName* / false);                 thisInComputedPropertyName = true;                 continue;             }              break;         } */
        /* TODO(ExpressionStatement): checkThisInStaticClassFieldInitializerInDecoratedClass(node, container); */
        if thisInComputedPropertyName {
            /* TODO(ExpressionStatement): error(node, Diagnostics.this_cannot_be_referenced_in_a_computed_property_name); */
        } else {
            /* TODO(SwitchStatement): switch (container.kind) {                 case SyntaxKind.ModuleDeclaration:                     error(node, Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body);                     // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks                     break;                 case SyntaxKind.EnumDeclaration:                     error(node, Diagnostics.this_cannot_be_referenced_in_current_location);                     // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks                     break;             } */
        }
        if /* TODO(BinaryExpression): !isNodeInTypeQuery && capturedByArrowFunction && languageVersion < ScriptTarget.ES2015 */ TODO {
            /* TODO(ExpressionStatement): captureLexicalThis(node, container); */
        }
        type_ := tryGetThisTypeAt(node, /* TODO(TrueKeyword): true */ TODO, container)
        if noImplicitThis {
            globalThisType := getTypeOfSymbol(globalThisSymbol)
            if /* TODO(BinaryExpression): type === globalThisType && capturedByArrowFunction */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.The_containing_arrow_function_captures_the_global_value_of_this); */
            } else if /* TODO(PrefixUnaryExpression): !type */ TODO {
                diag := error(node, /* TODO(PropertyAccessExpression): Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation */ TODO)
                if /* TODO(PrefixUnaryExpression): !isSourceFile(container) */ TODO {
                    outsideThis := tryGetThisTypeAt(container)
                    if /* TODO(BinaryExpression): outsideThis && outsideThis !== globalThisType */ TODO {
                        /* TODO(ExpressionStatement): addRelatedInfo(diag, createDiagnosticForNode(container, Diagnostics.An_outer_value_of_this_is_shadowed_by_this_container)); */
                    }
                }
            }
        }
         /* TODO(BinaryExpression): type || anyType */ TODO
    }
    tryGetThisTypeAt := func(node Node, includeGlobalThis /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */, container /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/utilities").ThisContainer */ TODO /* = */ /* TODO(CallExpression): getThisContainer(node, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false) */) *Type {
        isInJS := isInJSFile(node)
        if /* TODO(BinaryExpression): isFunctionLike(container) &&             (!isInParameterInitializerBeforeContainingFunction(node) || getThisParameter(container)) */ TODO {
            thisType := /* TODO(BinaryExpression): getThisTypeOfDeclaration(container) || isInJS && getTypeForThisExpressionFromJSDoc(container) */ TODO
            if /* TODO(PrefixUnaryExpression): !thisType */ TODO {
                className := getClassNameFromPrototypeMethod(container)
                if /* TODO(BinaryExpression): isInJS && className */ TODO {
                    classSymbol := /* TODO(PropertyAccessExpression): checkExpression(className).symbol */ TODO
                    if /* TODO(BinaryExpression): classSymbol && classSymbol.members && (classSymbol.flags & SymbolFlags.Function) */ TODO {
                        /* TODO(ExpressionStatement): thisType = (getDeclaredTypeOfSymbol(classSymbol) as InterfaceType).thisType; */
                    }
                } else if isJSConstructor(container) {
                    /* TODO(ExpressionStatement): thisType = (getDeclaredTypeOfSymbol(getMergedSymbol(container.symbol)) as InterfaceType).thisType; */
                }
                /* TODO(ExpressionStatement): thisType ||= getContextualThisParameterType(container); */
            }
            if thisType {
                 getFlowTypeOfReference(node, thisType)
            }
        }
        if isClassLike(/* TODO(PropertyAccessExpression): container.parent */ TODO) {
            symbol := getSymbolOfDeclaration(/* TODO(PropertyAccessExpression): container.parent */ TODO)
            type_ := /* TODO(ConditionalExpression): isStatic(container) ? getTypeOfSymbol(symbol) : (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType! */ TODO
             getFlowTypeOfReference(node, type_)
        }
        if isSourceFile(container) {
            if /* TODO(PropertyAccessExpression): container.commonJsModuleIndicator */ TODO {
                fileSymbol := getSymbolOfDeclaration(container)
                 /* TODO(BinaryExpression): fileSymbol && getTypeOfSymbol(fileSymbol) */ TODO
            } else if /* TODO(PropertyAccessExpression): container.externalModuleIndicator */ TODO {
                 undefinedType
            } else if includeGlobalThis {
                 getTypeOfSymbol(globalThisSymbol)
            }
        }
    }
    getExplicitThisType := func(node Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        container := getThisContainer(node, /* TODO(FalseKeyword): false */ TODO, /* TODO(FalseKeyword): false */ TODO)
        if isFunctionLike(container) {
            signature := getSignatureFromDeclaration(container)
            if /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO {
                 getExplicitTypeOfSymbol(/* TODO(PropertyAccessExpression): signature.thisParameter */ TODO)
            }
        }
        if isClassLike(/* TODO(PropertyAccessExpression): container.parent */ TODO) {
            symbol := getSymbolOfDeclaration(/* TODO(PropertyAccessExpression): container.parent */ TODO)
             /* TODO(ConditionalExpression): isStatic(container) ? getTypeOfSymbol(symbol) : (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType! */ TODO
        }
    }
    getClassNameFromPrototypeMethod := func(container Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").LeftHandSideExpression | undefined */ TODO {
        if /* TODO(BinaryExpression): container.kind === SyntaxKind.FunctionExpression &&             isBinaryExpression(container.parent) &&             getAssignmentDeclarationKind(container.parent) === AssignmentDeclarationKind.PrototypeProperty */ TODO {
             /* TODO(PropertyAccessExpression): ((container.parent // x.prototype.y = container                 .left as PropertyAccessExpression) // x.prototype.y                 .expression as PropertyAccessExpression) // x.prototype                 .expression */ TODO
        } else if /* TODO(BinaryExpression): container.kind === SyntaxKind.MethodDeclaration &&             container.parent.kind === SyntaxKind.ObjectLiteralExpression &&             isBinaryExpression(container.parent.parent) &&             getAssignmentDeclarationKind(container.parent.parent) === AssignmentDeclarationKind.Prototype */ TODO {
             /* TODO(PropertyAccessExpression): (container.parent.parent.left as PropertyAccessExpression).expression */ TODO
        } else if /* TODO(BinaryExpression): container.kind === SyntaxKind.FunctionExpression &&             container.parent.kind === SyntaxKind.PropertyAssignment &&             container.parent.parent.kind === SyntaxKind.ObjectLiteralExpression &&             isBinaryExpression(container.parent.parent.parent) &&             getAssignmentDeclarationKind(container.parent.parent.parent) === AssignmentDeclarationKind.Prototype */ TODO {
             /* TODO(PropertyAccessExpression): (container.parent.parent.parent.left as PropertyAccessExpression).expression */ TODO
        } else if /* TODO(BinaryExpression): container.kind === SyntaxKind.FunctionExpression &&             isPropertyAssignment(container.parent) &&             isIdentifier(container.parent.name) &&             (container.parent.name.escapedText === "value" || container.parent.name.escapedText === "get" || container.parent.name.escapedText === "set") &&             isObjectLiteralExpression(container.parent.parent) &&             isCallExpression(container.parent.parent.parent) &&             container.parent.parent.parent.arguments[2] === container.parent.parent &&             getAssignmentDeclarationKind(container.parent.parent.parent) === AssignmentDeclarationKind.ObjectDefinePrototypeProperty */ TODO {
             /* TODO(PropertyAccessExpression): (container.parent.parent.parent.arguments[0] as PropertyAccessExpression).expression */ TODO
        } else if /* TODO(BinaryExpression): isMethodDeclaration(container) &&             isIdentifier(container.name) &&             (container.name.escapedText === "value" || container.name.escapedText === "get" || container.name.escapedText === "set") &&             isObjectLiteralExpression(container.parent) &&             isCallExpression(container.parent.parent) &&             container.parent.parent.arguments[2] === container.parent &&             getAssignmentDeclarationKind(container.parent.parent) === AssignmentDeclarationKind.ObjectDefinePrototypeProperty */ TODO {
             /* TODO(PropertyAccessExpression): (container.parent.parent.arguments[0] as PropertyAccessExpression).expression */ TODO
        }
    }
    getTypeForThisExpressionFromJSDoc := func(node SignatureDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        thisTag := getJSDocThisTag(node)
        if /* TODO(BinaryExpression): thisTag && thisTag.typeExpression */ TODO {
             getTypeFromTypeNode(/* TODO(PropertyAccessExpression): thisTag.typeExpression */ TODO)
        }
        signature := getSignatureOfTypeTag(node)
        if signature {
             getThisTypeOfSignature(signature)
        }
    }
    isInConstructorArgumentInitializer := func(node Node, constructorDecl Node) bool {
         /* TODO(PrefixUnaryExpression): !!findAncestor(node, n => isFunctionLikeDeclaration(n) ? "quit" : n.kind === SyntaxKind.Parameter && n.parent === constructorDecl) */ TODO
    }
    checkSuperExpression := func(node Node) Type {
        isCallExpression := /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.CallExpression && (node.parent as CallExpression).expression === node */ TODO
        immediateContainer := getSuperContainer(node, /* TODO(TrueKeyword): true */ TODO)
        container := immediateContainer
        needToCaptureLexicalThis := /* TODO(FalseKeyword): false */ TODO
        inAsyncFunction := /* TODO(FalseKeyword): false */ TODO
        if /* TODO(PrefixUnaryExpression): !isCallExpression */ TODO {
            /* TODO(WhileStatement): while (container && container.kind === SyntaxKind.ArrowFunction) {                 if (hasSyntacticModifier(container, ModifierFlags.Async)) inAsyncFunction = true;                 container = getSuperContainer(container, /*stopOnFunctions* / true);                 needToCaptureLexicalThis = languageVersion < ScriptTarget.ES2015;             } */
            if /* TODO(BinaryExpression): container && hasSyntacticModifier(container, ModifierFlags.Async) */ TODO {
                /* TODO(BinaryExpression): inAsyncFunction = true */
            }
        }
        var nodeCheckFlag NodeCheckFlags = 0
        if /* TODO(BinaryExpression): !container || !isLegalUsageOfSuperExpression(container) */ TODO {
            current := findAncestor(node, /* TODO(ArrowFunction): n => n === container ? "quit" : n.kind === SyntaxKind.ComputedPropertyName */ TODO)
            if /* TODO(BinaryExpression): current && current.kind === SyntaxKind.ComputedPropertyName */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.super_cannot_be_referenced_in_a_computed_property_name); */
            } else if isCallExpression {
                /* TODO(ExpressionStatement): error(node, Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors); */
            } else if /* TODO(BinaryExpression): !container || !container.parent || !(isClassLike(container.parent) || container.parent.kind === SyntaxKind.ObjectLiteralExpression) */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions); */
            } else {
                /* TODO(ExpressionStatement): error(node, Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class); */
            }
             errorType
        }
        if /* TODO(BinaryExpression): !isCallExpression && immediateContainer!.kind === SyntaxKind.Constructor */ TODO {
            /* TODO(ExpressionStatement): checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class); */
        }
        if /* TODO(BinaryExpression): isStatic(container) || isCallExpression */ TODO {
            /* TODO(ExpressionStatement): nodeCheckFlag = NodeCheckFlags.SuperStatic; */
            if /* TODO(BinaryExpression): !isCallExpression &&                 languageVersion >= ScriptTarget.ES2015 && languageVersion <= ScriptTarget.ES2021 &&                 (isPropertyDeclaration(container) || isClassStaticBlockDeclaration(container)) */ TODO {
                /* TODO(ExpressionStatement): forEachEnclosingBlockScopeContainer(node.parent, current => {                     if (!isSourceFile(current) || isExternalOrCommonJsModule(current)) {                         getNodeLinks(current).flags |= NodeCheckFlags.ContainsSuperPropertyInStaticInitializer;                     }                 }); */
            }
        } else {
            /* TODO(ExpressionStatement): nodeCheckFlag = NodeCheckFlags.SuperInstance; */
        }
        /* TODO(ExpressionStatement): getNodeLinks(node).flags |= nodeCheckFlag; */
        if /* TODO(BinaryExpression): container.kind === SyntaxKind.MethodDeclaration && inAsyncFunction */ TODO {
            if /* TODO(BinaryExpression): isSuperProperty(node.parent) && isAssignmentTarget(node.parent) */ TODO {
                /* TODO(ExpressionStatement): getNodeLinks(container).flags |= NodeCheckFlags.MethodWithSuperPropertyAssignmentInAsync; */
            } else {
                /* TODO(ExpressionStatement): getNodeLinks(container).flags |= NodeCheckFlags.MethodWithSuperPropertyAccessInAsync; */
            }
        }
        if needToCaptureLexicalThis {
            /* TODO(ExpressionStatement): captureLexicalThis(node.parent, container); */
        }
        if /* TODO(BinaryExpression): container.parent.kind === SyntaxKind.ObjectLiteralExpression */ TODO {
            if /* TODO(BinaryExpression): languageVersion < ScriptTarget.ES2015 */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher); */
                 errorType
            } else {
                 anyType
            }
        }
        classLikeDeclaration := /* TODO(PropertyAccessExpression): container.parent */ TODO /* as */ /* TODO(TypeReference): ClassLikeDeclaration */
        if /* TODO(PrefixUnaryExpression): !getClassExtendsHeritageElement(classLikeDeclaration) */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.super_can_only_be_referenced_in_a_derived_class); */
             errorType
        }
        if classDeclarationExtendsNull(classLikeDeclaration) {
             /* TODO(ConditionalExpression): isCallExpression ? errorType : nullWideningType */ TODO
        }
        classType := getDeclaredTypeOfSymbol(getSymbolOfDeclaration(classLikeDeclaration)) /* as */ /* TODO(TypeReference): InterfaceType */
        baseClassType := /* TODO(BinaryExpression): classType && getBaseTypes(classType)[0] */ TODO
        if /* TODO(PrefixUnaryExpression): !baseClassType */ TODO {
             errorType
        }
        if /* TODO(BinaryExpression): container.kind === SyntaxKind.Constructor && isInConstructorArgumentInitializer(node, container) */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.super_cannot_be_referenced_in_constructor_arguments); */
             errorType
        }
         /* TODO(ConditionalExpression): nodeCheckFlag === NodeCheckFlags.SuperStatic             ? getBaseConstructorTypeOfClass(classType)             : getTypeWithThisArgument(baseClassType, classType.thisType) */ TODO
        isLegalUsageOfSuperExpression := func(container Node) bool {
            if isCallExpression {
                 /* TODO(BinaryExpression): container.kind === SyntaxKind.Constructor */ TODO
            } else {
                if /* TODO(BinaryExpression): isClassLike(container.parent) || container.parent.kind === SyntaxKind.ObjectLiteralExpression */ TODO {
                    if isStatic(container) {
                         /* TODO(BinaryExpression): container.kind === SyntaxKind.MethodDeclaration ||                             container.kind === SyntaxKind.MethodSignature ||                             container.kind === SyntaxKind.GetAccessor ||                             container.kind === SyntaxKind.SetAccessor ||                             container.kind === SyntaxKind.PropertyDeclaration ||                             container.kind === SyntaxKind.ClassStaticBlockDeclaration */ TODO
                    } else {
                         /* TODO(BinaryExpression): container.kind === SyntaxKind.MethodDeclaration ||                             container.kind === SyntaxKind.MethodSignature ||                             container.kind === SyntaxKind.GetAccessor ||                             container.kind === SyntaxKind.SetAccessor ||                             container.kind === SyntaxKind.PropertyDeclaration ||                             container.kind === SyntaxKind.PropertySignature ||                             container.kind === SyntaxKind.Constructor */ TODO
                    }
                }
            }
             /* TODO(FalseKeyword): false */ TODO
        }
    }
    getContainingObjectLiteral := func(func_ SignatureDeclaration) *ObjectLiteralExpression {
         /* TODO(ConditionalExpression): (func.kind === SyntaxKind.MethodDeclaration ||                 func.kind === SyntaxKind.GetAccessor ||                 func.kind === SyntaxKind.SetAccessor) && func.parent.kind === SyntaxKind.ObjectLiteralExpression ? func.parent :             func.kind === SyntaxKind.FunctionExpression && func.parent.kind === SyntaxKind.PropertyAssignment ? func.parent.parent as ObjectLiteralExpression :             undefined */ TODO
    }
    getThisTypeArgument := func(type_ Type) *Type {
         /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference).target === globalThisType ? getTypeArguments(type as TypeReference)[0] : undefined */ TODO
    }
    getThisTypeFromContextualType := func(type_ Type) *Type {
         mapType(type_, /* TODO(ArrowFunction): t => {             return t.flags & TypeFlags.Intersection ? forEach((t as IntersectionType).types, getThisTypeArgument) : getThisTypeArgument(t);         } */ TODO)
    }
    getThisTypeOfObjectLiteralFromContextualType := func(containingLiteral ObjectLiteralExpression, contextualType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        literal := containingLiteral
        type_ := contextualType
        /* TODO(WhileStatement): while (type) {             const thisType = getThisTypeFromContextualType(type);             if (thisType) {                 return thisType;             }             if (literal.parent.kind !== SyntaxKind.PropertyAssignment) {                 break;             }             literal = literal.parent.parent as ObjectLiteralExpression;             type = getApparentTypeOfContextualType(literal, /*contextFlags* / undefined);         } */
    }
    getContextualThisParameterType := func(func_ SignatureDeclaration) *Type {
        if /* TODO(BinaryExpression): func.kind === SyntaxKind.ArrowFunction */ TODO {
             undefined
        }
        if isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
            contextualSignature := getContextualSignature(func_)
            if contextualSignature {
                thisParameter := /* TODO(PropertyAccessExpression): contextualSignature.thisParameter */ TODO
                if thisParameter {
                     getTypeOfSymbol(thisParameter)
                }
            }
        }
        inJs := isInJSFile(func_)
        if /* TODO(BinaryExpression): noImplicitThis || inJs */ TODO {
            containingLiteral := getContainingObjectLiteral(func_)
            if containingLiteral {
                contextualType := getApparentTypeOfContextualType(containingLiteral, undefined)
                thisType := getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
                if thisType {
                     instantiateType(thisType, getMapperFromContext(getInferenceContext(containingLiteral)))
                }
                 getWidenedType(/* TODO(ConditionalExpression): contextualType ? getNonNullableType(contextualType) : checkExpressionCached(containingLiteral) */ TODO)
            }
            parent := walkUpParenthesizedExpressions(/* TODO(PropertyAccessExpression): func.parent */ TODO)
            if isAssignmentExpression(parent) {
                target := /* TODO(PropertyAccessExpression): parent.left */ TODO
                if isAccessExpression(target) {
                    TODO_IDENTIFIER := target
                    if /* TODO(BinaryExpression): inJs && isIdentifier(expression) */ TODO {
                        sourceFile := getSourceFileOfNode(parent)
                        if /* TODO(BinaryExpression): sourceFile.commonJsModuleIndicator && getResolvedSymbol(expression) === sourceFile.symbol */ TODO {
                             undefined
                        }
                    }
                     getWidenedType(checkExpressionCached(expression))
                }
            }
        }
         undefined
    }
    getContextuallyTypedParameterType := func(parameter ParameterDeclaration) *Type {
        func_ := /* TODO(PropertyAccessExpression): parameter.parent */ TODO
        if /* TODO(PrefixUnaryExpression): !isContextSensitiveFunctionOrObjectLiteralMethod(func) */ TODO {
             undefined
        }
        iife := getImmediatelyInvokedFunctionExpression(func_)
        if /* TODO(BinaryExpression): iife && iife.arguments */ TODO {
            args := getEffectiveCallArguments(iife)
            indexOfParameter := /* TODO(PropertyAccessExpression): func.parameters.indexOf */ TODO(parameter)
            if /* TODO(PropertyAccessExpression): parameter.dotDotDotToken */ TODO {
                 getSpreadArgumentType(args, indexOfParameter, /* TODO(PropertyAccessExpression): args.length */ TODO, anyType, undefined, /* TODO(PropertyAccessExpression): CheckMode.Normal */ TODO)
            }
            links := getNodeLinks(iife)
            cached := /* TODO(PropertyAccessExpression): links.resolvedSignature */ TODO
            /* TODO(ExpressionStatement): links.resolvedSignature = anySignature; */
            type_ := /* TODO(ConditionalExpression): indexOfParameter < args.length ?                 getWidenedLiteralType(checkExpression(args[indexOfParameter])) :                 parameter.initializer ? undefined : undefinedWideningType */ TODO
            /* TODO(ExpressionStatement): links.resolvedSignature = cached; */
             type_
        }
        contextualSignature := getContextualSignature(func_)
        if contextualSignature {
            index := /* TODO(BinaryExpression): func.parameters.indexOf(parameter) - (getThisParameter(func) ? 1 : 0) */ TODO
             /* TODO(ConditionalExpression): parameter.dotDotDotToken && lastOrUndefined(func.parameters) === parameter ?                 getRestTypeAtPosition(contextualSignature, index) :                 tryGetTypeAtPosition(contextualSignature, index) */ TODO
        }
    }
    getContextualTypeForVariableLikeDeclaration := func(declaration VariableLikeDeclaration, contextFlags *ContextFlags) *Type {
        typeNode := /* TODO(BinaryExpression): getEffectiveTypeAnnotationNode(declaration) || (isInJSFile(declaration) ? tryGetJSDocSatisfiesTypeNode(declaration) : undefined) */ TODO
        if typeNode {
             getTypeFromTypeNode(typeNode)
        }
        /* TODO(SwitchStatement): switch (declaration.kind) {             case SyntaxKind.Parameter:                 return getContextuallyTypedParameterType(declaration);             case SyntaxKind.BindingElement:                 return getContextualTypeForBindingElement(declaration, contextFlags);             case SyntaxKind.PropertyDeclaration:                 if (isStatic(declaration)) {                     return getContextualTypeForStaticPropertyDeclaration(declaration, contextFlags);                 }                 // By default, do nothing and return undefined - only the above cases have context implied by a parent         } */
    }
    getContextualTypeForBindingElement := func(declaration BindingElement, contextFlags *ContextFlags) *Type {
        parent := /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO
        name := /* TODO(BinaryExpression): declaration.propertyName || declaration.name */ TODO
        parentType := /* TODO(BinaryExpression): getContextualTypeForVariableLikeDeclaration(parent, contextFlags) ||             parent.kind !== SyntaxKind.BindingElement && parent.initializer && checkDeclarationInitializer(parent, declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal) */ TODO
        if /* TODO(BinaryExpression): !parentType || isBindingPattern(name) || isComputedNonLiteralName(name) */ TODO {
            /* TODO(Identifier): undefined */
        }
        if /* TODO(BinaryExpression): parent.name.kind === SyntaxKind.ArrayBindingPattern */ TODO {
            index := indexOfNode(/* TODO(PropertyAccessExpression): declaration.parent.elements */ TODO, declaration)
            if /* TODO(BinaryExpression): index < 0 */ TODO {
                /* TODO(Identifier): undefined */
            }
             getContextualTypeForElementExpression(parentType, index)
        }
        nameType := getLiteralTypeFromPropertyName(name)
        if isTypeUsableAsPropertyName(nameType) {
            text := getPropertyNameFromType(nameType)
             getTypeOfPropertyOfType(parentType, text)
        }
    }
    getContextualTypeForStaticPropertyDeclaration := func(declaration PropertyDeclaration, contextFlags *ContextFlags) *Type {
        parentType := /* TODO(BinaryExpression): isExpression(declaration.parent) && getContextualType(declaration.parent, contextFlags) */ TODO
        if /* TODO(PrefixUnaryExpression): !parentType */ TODO {
            /* TODO(Identifier): undefined */
        }
         getTypeOfPropertyOfContextualType(parentType, /* TODO(PropertyAccessExpression): getSymbolOfDeclaration(declaration).escapedName */ TODO)
    }
    getContextualTypeForInitializerExpression := func(node Expression, contextFlags *ContextFlags) *Type {
        declaration := /* TODO(PropertyAccessExpression): node.parent */ TODO /* as */ /* TODO(TypeReference): VariableLikeDeclaration */
        if /* TODO(BinaryExpression): hasInitializer(declaration) && node === declaration.initializer */ TODO {
            result := getContextualTypeForVariableLikeDeclaration(declaration, contextFlags)
            if result {
                 result
            }
            if /* TODO(BinaryExpression): !(contextFlags! & ContextFlags.SkipBindingPatterns) && isBindingPattern(declaration.name) && declaration.name.elements.length > 0 */ TODO {
                 getTypeFromBindingPattern(/* TODO(PropertyAccessExpression): declaration.name */ TODO, /* TODO(TrueKeyword): true */ TODO, /* TODO(FalseKeyword): false */ TODO)
            }
        }
         undefined
    }
    getContextualTypeForReturnExpression := func(node Expression, contextFlags *ContextFlags) *Type {
        func_ := getContainingFunction(node)
        if func_ {
            contextualReturnType := getContextualReturnType(func_, contextFlags)
            if contextualReturnType {
                functionFlags := getFunctionFlags(func_)
                if /* TODO(BinaryExpression): functionFlags & FunctionFlags.Generator */ TODO {
                    isAsyncGenerator := /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */ TODO
                    if /* TODO(BinaryExpression): contextualReturnType.flags & TypeFlags.Union */ TODO {
                        /* TODO(ExpressionStatement): contextualReturnType = filterType(contextualReturnType, type => !!getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, type, isAsyncGenerator)); */
                    }
                    iterationReturnType := getIterationTypeOfGeneratorFunctionReturnType(/* TODO(PropertyAccessExpression): IterationTypeKind.Return */ TODO, contextualReturnType, /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */ TODO)
                    if /* TODO(PrefixUnaryExpression): !iterationReturnType */ TODO {
                         undefined
                    }
                    /* TODO(ExpressionStatement): contextualReturnType = iterationReturnType; */
                }
                if /* TODO(BinaryExpression): functionFlags & FunctionFlags.Async */ TODO {
                    contextualAwaitedType := mapType(contextualReturnType, getAwaitedTypeNoAlias)
                     /* TODO(BinaryExpression): contextualAwaitedType && getUnionType([contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)]) */ TODO
                }
                 contextualReturnType
            }
        }
         undefined
    }
    getContextualTypeForAwaitOperand := func(node AwaitExpression, contextFlags *ContextFlags) *Type {
        contextualType := getContextualType(node, contextFlags)
        if contextualType {
            contextualAwaitedType := getAwaitedTypeNoAlias(contextualType)
             /* TODO(BinaryExpression): contextualAwaitedType && getUnionType([contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)]) */ TODO
        }
         undefined
    }
    getContextualTypeForYieldOperand := func(node YieldExpression, contextFlags *ContextFlags) *Type {
        func_ := getContainingFunction(node)
        if func_ {
            functionFlags := getFunctionFlags(func_)
            contextualReturnType := getContextualReturnType(func_, contextFlags)
            if contextualReturnType {
                isAsyncGenerator := /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */ TODO
                if /* TODO(BinaryExpression): !node.asteriskToken && contextualReturnType.flags & TypeFlags.Union */ TODO {
                    /* TODO(ExpressionStatement): contextualReturnType = filterType(contextualReturnType, type => !!getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, type, isAsyncGenerator)); */
                }
                if /* TODO(PropertyAccessExpression): node.asteriskToken */ TODO {
                    iterationTypes := getIterationTypesOfGeneratorFunctionReturnType(contextualReturnType, isAsyncGenerator)
                    yieldType := /* TODO(BinaryExpression): iterationTypes?.yieldType ?? silentNeverType */ TODO
                    returnType := /* TODO(BinaryExpression): getContextualType(node, contextFlags) ?? silentNeverType */ TODO
                    nextType := /* TODO(BinaryExpression): iterationTypes?.nextType ?? unknownType */ TODO
                    generatorType := createGeneratorType(yieldType, returnType, nextType, /* TODO(FalseKeyword): false */ TODO)
                    if isAsyncGenerator {
                        asyncGeneratorType := createGeneratorType(yieldType, returnType, nextType, /* TODO(TrueKeyword): true */ TODO)
                         getUnionType(/* TODO(ArrayLiteralExpression): [generatorType, asyncGeneratorType] */ TODO)
                    }
                     generatorType
                }
                 getIterationTypeOfGeneratorFunctionReturnType(/* TODO(PropertyAccessExpression): IterationTypeKind.Yield */ TODO, contextualReturnType, isAsyncGenerator)
            }
        }
         undefined
    }
    isInParameterInitializerBeforeContainingFunction := func(node Node) /* TODO(undefined): boolean */ TODO {
        inBindingInitializer := /* TODO(FalseKeyword): false */ TODO
        /* TODO(WhileStatement): while (node.parent && !isFunctionLike(node.parent)) {             if (isParameter(node.parent) && (inBindingInitializer || node.parent.initializer === node)) {                 return true;             }             if (isBindingElement(node.parent) && node.parent.initializer === node) {                 inBindingInitializer = true;             }              node = node.parent;         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    getContextualIterationType := func(kind IterationTypeKind, functionDecl SignatureDeclaration) *Type {
        isAsync := /* TODO(PrefixUnaryExpression): !!(getFunctionFlags(functionDecl) & FunctionFlags.Async) */ TODO
        contextualReturnType := getContextualReturnType(functionDecl, undefined)
        if contextualReturnType {
             /* TODO(BinaryExpression): getIterationTypeOfGeneratorFunctionReturnType(kind, contextualReturnType, isAsync)                 || undefined */ TODO
        }
         undefined
    }
    getContextualReturnType := func(functionDecl SignatureDeclaration, contextFlags *ContextFlags) *Type {
        returnType := getReturnTypeFromAnnotation(functionDecl)
        if returnType {
             returnType
        }
        signature := getContextualSignatureForFunctionLikeDeclaration(functionDecl /* as */ /* TODO(TypeReference): FunctionExpression */)
        if /* TODO(BinaryExpression): signature && !isResolvingReturnTypeOfSignature(signature) */ TODO {
            returnType := getReturnTypeOfSignature(signature)
            functionFlags := getFunctionFlags(functionDecl)
            if /* TODO(BinaryExpression): functionFlags & FunctionFlags.Generator */ TODO {
                 filterType(returnType, /* TODO(ArrowFunction): t => {                     return !!(t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.InstantiableNonPrimitive)) || checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags, /*errorNode* / undefined);                 } */ TODO)
            }
            if /* TODO(BinaryExpression): functionFlags & FunctionFlags.Async */ TODO {
                 filterType(returnType, /* TODO(ArrowFunction): t => {                     return !!(t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.InstantiableNonPrimitive)) || !!getAwaitedTypeOfPromise(t);                 } */ TODO)
            }
             returnType
        }
        iife := getImmediatelyInvokedFunctionExpression(functionDecl)
        if iife {
             getContextualType(iife, contextFlags)
        }
         undefined
    }
    getContextualTypeForArgument := func(callTarget CallLikeExpression, arg Expression) *Type {
        args := getEffectiveCallArguments(callTarget)
        argIndex := /* TODO(PropertyAccessExpression): args.indexOf */ TODO(arg)
         /* TODO(ConditionalExpression): argIndex === -1 ? undefined : getContextualTypeForArgumentAtIndex(callTarget, argIndex) */ TODO
    }
    getContextualTypeForArgumentAtIndex := func(callTarget CallLikeExpression, argIndex number) Type {
        if isImportCall(callTarget) {
             /* TODO(ConditionalExpression): argIndex === 0 ? stringType :                 argIndex === 1 ? getGlobalImportCallOptionsType(/*reportErrors* / false) :                 anyType */ TODO
        }
        signature := /* TODO(ConditionalExpression): getNodeLinks(callTarget).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(callTarget) */ TODO
        if /* TODO(BinaryExpression): isJsxOpeningLikeElement(callTarget) && argIndex === 0 */ TODO {
             getEffectiveFirstArgumentForJsxSignature(signature, callTarget)
        }
        restIndex := /* TODO(BinaryExpression): signature.parameters.length - 1 */ TODO
         /* TODO(ConditionalExpression): signatureHasRestParameter(signature) && argIndex >= restIndex ?             getIndexedAccessType(getTypeOfSymbol(signature.parameters[restIndex]), getNumberLiteralType(argIndex - restIndex), AccessFlags.Contextual) :             getTypeAtPosition(signature, argIndex) */ TODO
    }
    getContextualTypeForDecorator := func(decorator Decorator) *Type {
        signature := getDecoratorCallSignature(decorator)
         /* TODO(ConditionalExpression): signature ? getOrCreateTypeFromSignature(signature) : undefined */ TODO
    }
    getContextualTypeForSubstitutionExpression := func(template TemplateExpression, substitutionExpression Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(BinaryExpression): template.parent.kind === SyntaxKind.TaggedTemplateExpression */ TODO {
             getContextualTypeForArgument(/* TODO(PropertyAccessExpression): template.parent */ TODO /* as */ /* TODO(TypeReference): TaggedTemplateExpression */, substitutionExpression)
        }
         undefined
    }
    getContextualTypeForBinaryOperand := func(node Expression, contextFlags *ContextFlags) *Type {
        binaryExpression := /* TODO(PropertyAccessExpression): node.parent */ TODO /* as */ /* TODO(TypeReference): BinaryExpression */
        TODO_IDENTIFIER := binaryExpression
        /* TODO(SwitchStatement): switch (operatorToken.kind) {             case SyntaxKind.EqualsToken:             case SyntaxKind.AmpersandAmpersandEqualsToken:             case SyntaxKind.BarBarEqualsToken:             case SyntaxKind.QuestionQuestionEqualsToken:                 return node === right ? getContextualTypeForAssignmentDeclaration(binaryExpression) : undefined;             case SyntaxKind.BarBarToken:             case SyntaxKind.QuestionQuestionToken:                 // When an || expression has a contextual type, the operands are contextually typed by that type, except                 // when that type originates in a binding pattern, the right operand is contextually typed by the type of                 // the left operand. When an || expression has no contextual type, the right operand is contextually typed                 // by the type of the left operand, except for the special case of Javascript declarations of the form                 // `namespace.prop = namespace.prop || {}`.                 const type = getContextualType(binaryExpression, contextFlags);                 return node === right && (type && type.pattern || !type && !isDefaultedExpandoInitializer(binaryExpression)) ?                     getTypeOfExpression(left) : type;             case SyntaxKind.AmpersandAmpersandToken:             case SyntaxKind.CommaToken:                 return node === right ? getContextualType(binaryExpression, contextFlags) : undefined;             default:                 return undefined;         } */
    }
    getSymbolForExpression := func(e Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        if /* TODO(BinaryExpression): canHaveSymbol(e) && e.symbol */ TODO {
             /* TODO(PropertyAccessExpression): e.symbol */ TODO
        }
        if isIdentifier(e) {
             getResolvedSymbol(e)
        }
        if isPropertyAccessExpression(e) {
            lhsType := getTypeOfExpression(/* TODO(PropertyAccessExpression): e.expression */ TODO)
             /* TODO(ConditionalExpression): isPrivateIdentifier(e.name) ? tryGetPrivateIdentifierPropertyOfType(lhsType, e.name) : getPropertyOfType(lhsType, e.name.escapedText) */ TODO
        }
        if isElementAccessExpression(e) {
            propType := checkExpressionCached(/* TODO(PropertyAccessExpression): e.argumentExpression */ TODO)
            if /* TODO(PrefixUnaryExpression): !isTypeUsableAsPropertyName(propType) */ TODO {
                 undefined
            }
            lhsType := getTypeOfExpression(/* TODO(PropertyAccessExpression): e.expression */ TODO)
             getPropertyOfType(lhsType, getPropertyNameFromType(propType))
        }
         undefined
        tryGetPrivateIdentifierPropertyOfType := func(type_ Type, id PrivateIdentifier) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
            lexicallyScopedSymbol := lookupSymbolForPrivateIdentifierDeclaration(/* TODO(PropertyAccessExpression): id.escapedText */ TODO, id)
             /* TODO(BinaryExpression): lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(type, lexicallyScopedSymbol) */ TODO
        }
    }
    getContextualTypeForAssignmentDeclaration := func(binaryExpression BinaryExpression) *Type {
        kind := getAssignmentDeclarationKind(binaryExpression)
        /* TODO(SwitchStatement): switch (kind) {             case AssignmentDeclarationKind.None:             case AssignmentDeclarationKind.ThisProperty:                 const lhsSymbol = getSymbolForExpression(binaryExpression.left);                 const decl = lhsSymbol && lhsSymbol.valueDeclaration;                 // Unannotated, uninitialized property declarations have a type implied by their usage in the constructor.                 // We avoid calling back into `getTypeOfExpression` and reentering contextual typing to avoid a bogus circularity error in that case.                 if (decl && (isPropertyDeclaration(decl) || isPropertySignature(decl))) {                     const overallAnnotation = getEffectiveTypeAnnotationNode(decl);                     return (overallAnnotation && instantiateType(getTypeFromTypeNode(overallAnnotation), getSymbolLinks(lhsSymbol).mapper)) ||                         (isPropertyDeclaration(decl) ? decl.initializer && getTypeOfExpression(binaryExpression.left) : undefined);                 }                 if (kind === AssignmentDeclarationKind.None) {                     return getTypeOfExpression(binaryExpression.left);                 }                 return getContextualTypeForThisPropertyAssignment(binaryExpression);             case AssignmentDeclarationKind.Property:                 if (isPossiblyAliasedThisProperty(binaryExpression, kind)) {                     return getContextualTypeForThisPropertyAssignment(binaryExpression);                 }                 // If `binaryExpression.left` was assigned a symbol, then this is a new declaration; otherwise it is an assignment to an existing declaration.                 // See `bindStaticPropertyAssignment` in `binder.ts`.                 else if (!canHaveSymbol(binaryExpression.left) || !binaryExpression.left.symbol) {                     return getTypeOfExpression(binaryExpression.left);                 }                 else {                     const decl = binaryExpression.left.symbol.valueDeclaration;                     if (!decl) {                         return undefined;                     }                     const lhs = cast(binaryExpression.left, isAccessExpression);                     const overallAnnotation = getEffectiveTypeAnnotationNode(decl);                     if (overallAnnotation) {                         return getTypeFromTypeNode(overallAnnotation);                     }                     else if (isIdentifier(lhs.expression)) {                         const id = lhs.expression;                         const parentSymbol = resolveName(id, id.escapedText, SymbolFlags.Value, /*nameNotFoundMessage* / undefined, /*isUse* / true);                         if (parentSymbol) {                             const annotated = parentSymbol.valueDeclaration && getEffectiveTypeAnnotationNode(parentSymbol.valueDeclaration);                             if (annotated) {                                 const nameStr = getElementOrPropertyAccessName(lhs);                                 if (nameStr !== undefined) {                                     return getTypeOfPropertyOfContextualType(getTypeFromTypeNode(annotated), nameStr);                                 }                             }                             return undefined;                         }                     }                     return isInJSFile(decl) || decl === binaryExpression.left ? undefined : getTypeOfExpression(binaryExpression.left);                 }             case AssignmentDeclarationKind.ExportsProperty:             case AssignmentDeclarationKind.Prototype:             case AssignmentDeclarationKind.PrototypeProperty:             case AssignmentDeclarationKind.ModuleExports:                 let valueDeclaration: Declaration | undefined;                 if (kind !== AssignmentDeclarationKind.ModuleExports) {                     valueDeclaration = canHaveSymbol(binaryExpression.left) ? binaryExpression.left.symbol?.valueDeclaration : undefined;                 }                 valueDeclaration ||= binaryExpression.symbol?.valueDeclaration;                 const annotated = valueDeclaration && getEffectiveTypeAnnotationNode(valueDeclaration);                 return annotated ? getTypeFromTypeNode(annotated) : undefined;             case AssignmentDeclarationKind.ObjectDefinePropertyValue:             case AssignmentDeclarationKind.ObjectDefinePropertyExports:             case AssignmentDeclarationKind.ObjectDefinePrototypeProperty:                 return Debug.fail("Does not apply");             default:                 return Debug.assertNever(kind);         } */
    }
    isPossiblyAliasedThisProperty := func(declaration BinaryExpression, kind /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").AssignmentDeclarationKind */ TODO /* = */ /* TODO(CallExpression): getAssignmentDeclarationKind(declaration) */) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): kind === AssignmentDeclarationKind.ThisProperty */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): !isInJSFile(declaration) || kind !== AssignmentDeclarationKind.Property || !isIdentifier((declaration.left as AccessExpression).expression) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        name := /* TODO(PropertyAccessExpression): ((declaration.left as AccessExpression).expression as Identifier).escapedText */ TODO
        symbol := resolveName(/* TODO(PropertyAccessExpression): declaration.left */ TODO, name, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO, undefined, /* TODO(TrueKeyword): true */ TODO, /* TODO(TrueKeyword): true */ TODO)
         isThisInitializedDeclaration(/* TODO(PropertyAccessExpression): symbol?.valueDeclaration */ TODO)
    }
    getContextualTypeForThisPropertyAssignment := func(binaryExpression BinaryExpression) *Type {
        if /* TODO(PrefixUnaryExpression): !binaryExpression.symbol */ TODO {
            /* TODO(CallExpression): getTypeOfExpression(binaryExpression.left) */
        }
        if /* TODO(PropertyAccessExpression): binaryExpression.symbol.valueDeclaration */ TODO {
            annotated := getEffectiveTypeAnnotationNode(/* TODO(PropertyAccessExpression): binaryExpression.symbol.valueDeclaration */ TODO)
            if annotated {
                type_ := getTypeFromTypeNode(annotated)
                if type_ {
                     type_
                }
            }
        }
        thisAccess := cast(/* TODO(PropertyAccessExpression): binaryExpression.left */ TODO, isAccessExpression)
        if /* TODO(PrefixUnaryExpression): !isObjectLiteralMethod(getThisContainer(thisAccess.expression, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false)) */ TODO {
             undefined
        }
        thisType := checkThisExpression(/* TODO(PropertyAccessExpression): thisAccess.expression */ TODO)
        nameStr := getElementOrPropertyAccessName(thisAccess)
         /* TODO(BinaryExpression): nameStr !== undefined && getTypeOfPropertyOfContextualType(thisType, nameStr) || undefined */ TODO
    }
    isCircularMappedProperty := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(getCheckFlags(symbol) & CheckFlags.Mapped && !(symbol as MappedSymbol).links.type && findResolutionCycleStartIndex(symbol, TypeSystemPropertyName.Type) >= 0) */ TODO
    }
    isExcludedMappedPropertyName := func(constraint Type, propertyNameType Type) bool {
        if /* TODO(BinaryExpression): constraint.flags & TypeFlags.Conditional */ TODO {
            type_ := constraint /* as */ /* TODO(TypeReference): ConditionalType */
             /* TODO(BinaryExpression): !!(getReducedType(getTrueTypeFromConditionalType(type)).flags & TypeFlags.Never) &&                 getActualTypeVariable(getFalseTypeFromConditionalType(type)) === getActualTypeVariable(type.checkType) &&                 isTypeAssignableTo(propertyNameType, type.extendsType) */ TODO
        }
        if /* TODO(BinaryExpression): constraint.flags & TypeFlags.Intersection */ TODO {
             some(/* TODO(PropertyAccessExpression): (constraint as IntersectionType).types */ TODO, /* TODO(ArrowFunction): t => isExcludedMappedPropertyName(t, propertyNameType) */ TODO)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    getTypeOfPropertyOfContextualType := func(type_ Type, name __String, nameType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
         mapType(type_, /* TODO(ArrowFunction): t => {             if (t.flags & TypeFlags.Intersection) {                 let types: Type[] | undefined;                 let indexInfoCandidates: Type[] | undefined;                 let ignoreIndexInfos = false;                 for (const constituentType of (t as IntersectionType).types) {                     if (!(constituentType.flags & TypeFlags.Object)) {                         continue;                     }                     if (isGenericMappedType(constituentType) && getMappedTypeNameTypeKind(constituentType) !== MappedTypeNameTypeKind.Remapping) {                         const substitutedType = getIndexedMappedTypeSubstitutedTypeOfContextualType(constituentType, name, nameType);                         types = appendContextualPropertyTypeConstituent(types, substitutedType);                         continue;                     }                     const propertyType = getTypeOfConcretePropertyOfContextualType(constituentType, name);                     if (!propertyType) {                         if (!ignoreIndexInfos) {                             indexInfoCandidates = append(indexInfoCandidates, constituentType);                         }                         continue;                     }                     ignoreIndexInfos = true;                     indexInfoCandidates = undefined;                     types = appendContextualPropertyTypeConstituent(types, propertyType);                 }                 if (indexInfoCandidates) {                     for (const candidate of indexInfoCandidates) {                         const indexInfoType = getTypeFromIndexInfosOfContextualType(candidate, name, nameType);                         types = appendContextualPropertyTypeConstituent(types, indexInfoType);                     }                 }                 if (!types) {                     return;                 }                 if (types.length === 1) {                     return types[0];                 }                 return getIntersectionType(types);             }             if (!(t.flags & TypeFlags.Object)) {                 return;             }             return isGenericMappedType(t) && getMappedTypeNameTypeKind(t) !== MappedTypeNameTypeKind.Remapping                 ? getIndexedMappedTypeSubstitutedTypeOfContextualType(t, name, nameType)                 : getTypeOfConcretePropertyOfContextualType(t, name) ?? getTypeFromIndexInfosOfContextualType(t, name, nameType);         } */ TODO, /* TODO(TrueKeyword): true */ TODO)
    }
    appendContextualPropertyTypeConstituent := func(types /* TODO(ArrayType): Type[] */ any, type_ *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ TODO {
         /* TODO(ConditionalExpression): type ? append(types, type.flags & TypeFlags.Any ? unknownType : type) : types */ TODO
    }
    getIndexedMappedTypeSubstitutedTypeOfContextualType := func(type_ MappedType, name __String, nameType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        propertyNameType := /* TODO(BinaryExpression): nameType || getStringLiteralType(unescapeLeadingUnderscores(name)) */ TODO
        constraint := getConstraintTypeFromMappedType(type_)
        if /* TODO(BinaryExpression): type.nameType && isExcludedMappedPropertyName(type.nameType, propertyNameType) || isExcludedMappedPropertyName(constraint, propertyNameType) */ TODO {

        }
        constraintOfConstraint := /* TODO(BinaryExpression): getBaseConstraintOfType(constraint) || constraint */ TODO
        if /* TODO(PrefixUnaryExpression): !isTypeAssignableTo(propertyNameType, constraintOfConstraint) */ TODO {

        }
         substituteIndexedMappedType(type_, propertyNameType)
    }
    getTypeOfConcretePropertyOfContextualType := func(type_ Type, name __String) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        prop := getPropertyOfType(type_, name)
        if /* TODO(BinaryExpression): !prop || isCircularMappedProperty(prop) */ TODO {

        }
         removeMissingType(getTypeOfSymbol(prop), /* TODO(PrefixUnaryExpression): !!(prop.flags & SymbolFlags.Optional) */ TODO)
    }
    getTypeFromIndexInfosOfContextualType := func(type_ Type, name __String, nameType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(BinaryExpression): isTupleType(type) && isNumericLiteralName(name) && +name >= 0 */ TODO {
            restType := getElementTypeOfSliceOfTupleType(type_, /* TODO(PropertyAccessExpression): type.target.fixedLength */ TODO, 0, /* TODO(FalseKeyword): false */ TODO, /* TODO(TrueKeyword): true */ TODO)
            if restType {
                 restType
            }
        }
         /* TODO(PropertyAccessExpression): findApplicableIndexInfo(getIndexInfosOfStructuredType(type), nameType || getStringLiteralType(unescapeLeadingUnderscores(name)))?.type */ TODO
    }
    getContextualTypeForObjectLiteralMethod := func(node MethodDeclaration, contextFlags *ContextFlags) *Type {
        /* TODO(ExpressionStatement): Debug.assert(isObjectLiteralMethod(node)); */
        if /* TODO(BinaryExpression): node.flags & NodeFlags.InWithStatement */ TODO {
             undefined
        }
         getContextualTypeForObjectLiteralElement(node, contextFlags)
    }
    getContextualTypeForObjectLiteralElement := func(element ObjectLiteralElementLike, contextFlags *ContextFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        objectLiteral := /* TODO(PropertyAccessExpression): element.parent */ TODO /* as */ /* TODO(TypeReference): ObjectLiteralExpression */
        propertyAssignmentType := /* TODO(BinaryExpression): isPropertyAssignment(element) && getContextualTypeForVariableLikeDeclaration(element, contextFlags) */ TODO
        if propertyAssignmentType {
             propertyAssignmentType
        }
        type_ := getApparentTypeOfContextualType(objectLiteral, contextFlags)
        if type_ {
            if hasBindableName(element) {
                symbol := getSymbolOfDeclaration(element)
                 getTypeOfPropertyOfContextualType(type_, /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO, /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).nameType */ TODO)
            }
            if hasDynamicName(element) {
                name := getNameOfDeclaration(element)
                if /* TODO(BinaryExpression): name && isComputedPropertyName(name) */ TODO {
                    exprType := checkExpression(/* TODO(PropertyAccessExpression): name.expression */ TODO)
                    propType := /* TODO(BinaryExpression): isTypeUsableAsPropertyName(exprType) && getTypeOfPropertyOfContextualType(type, getPropertyNameFromType(exprType)) */ TODO
                    if propType {
                         propType
                    }
                }
            }
            if /* TODO(PropertyAccessExpression): element.name */ TODO {
                nameType := getLiteralTypeFromPropertyName(/* TODO(PropertyAccessExpression): element.name */ TODO)
                 mapType(type_, /* TODO(ArrowFunction): t => findApplicableIndexInfo(getIndexInfosOfStructuredType(t), nameType)?.type */ TODO, /* TODO(TrueKeyword): true */ TODO)
            }
        }
         undefined
    }
    getSpreadIndices := func(elements []Node) /* TODO(undefined): { first: number | undefined; last: number | undefined; } */ TODO {
        firstlast
        )
        /* TODO(ForStatement): for (let i = 0; i < elements.length; i++) {             if (isSpreadElement(elements[i])) {                 first ??= i;                 last = i;             }         } */
         /* TODO(ObjectLiteralExpression): { first, last } */ TODO
    }
    getContextualTypeForElementExpression := func(type_ *Type, index number, length number, firstSpreadIndex number, lastSpreadIndex number) *Type {
         /* TODO(BinaryExpression): type && mapType(type, t => {             if (isTupleType(t)) {                 // If index is before any spread element and within the fixed part of the contextual tuple type, return                 // the type of the contextual tuple element.                 if ((firstSpreadIndex === undefined || index < firstSpreadIndex) && index < t.target.fixedLength) {                     return removeMissingType(getTypeArguments(t)[index], !!(t.target.elementFlags[index] && ElementFlags.Optional));                 }                 // When the length is known and the index is after all spread elements we compute the offset from the element                 // to the end and the number of ending fixed elements in the contextual tuple type.                 const offset = length !== undefined && (lastSpreadIndex === undefined || index > lastSpreadIndex) ? length - index : 0;                 const fixedEndLength = offset > 0 && (t.target.combinedFlags & ElementFlags.Variable) ? getEndElementCount(t.target, ElementFlags.Fixed) : 0;                 // If the offset is within the ending fixed part of the contextual tuple type, return the type of the contextual                 // tuple element.                 if (offset > 0 && offset <= fixedEndLength) {                     return getTypeArguments(t)[getTypeReferenceArity(t) - offset];                 }                 // Return a union of the possible contextual element types with no subtype reduction.                 return getElementTypeOfSliceOfTupleType(t, firstSpreadIndex === undefined ? t.target.fixedLength : Math.min(t.target.fixedLength, firstSpreadIndex), length === undefined || lastSpreadIndex === undefined ? fixedEndLength : Math.min(fixedEndLength, length - lastSpreadIndex), /*writing* / false, /*noReductions* / true);             }             // If element index is known and a contextual property with that name exists, return it. Otherwise return the             // iterated or element type of the contextual type.             return (!firstSpreadIndex || index < firstSpreadIndex) && getTypeOfPropertyOfContextualType(t, "" + index as __String) ||                 getIteratedTypeOrElementType(IterationUse.Element, t, undefinedType, /*errorNode* / undefined, /*checkAssignability* / false);         }, /*noReductions* / true) */ TODO
    }
    getContextualTypeForConditionalOperand := func(node Expression, contextFlags *ContextFlags) *Type {
        conditional := /* TODO(PropertyAccessExpression): node.parent */ TODO /* as */ /* TODO(TypeReference): ConditionalExpression */
         /* TODO(ConditionalExpression): node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional, contextFlags) : undefined */ TODO
    }
    getContextualTypeForChildJsxExpression := func(node JsxElement, child JsxChild, contextFlags *ContextFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        attributesType := getApparentTypeOfContextualType(/* TODO(PropertyAccessExpression): node.openingElement.attributes */ TODO, contextFlags)
        jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
        if /* TODO(PrefixUnaryExpression): !(attributesType && !isTypeAny(attributesType) && jsxChildrenPropertyName && jsxChildrenPropertyName !== "") */ TODO {
             undefined
        }
        realChildren := getSemanticJsxChildren(/* TODO(PropertyAccessExpression): node.children */ TODO)
        childIndex := /* TODO(PropertyAccessExpression): realChildren.indexOf */ TODO(child)
        childFieldType := getTypeOfPropertyOfContextualType(attributesType, jsxChildrenPropertyName)
         /* TODO(BinaryExpression): childFieldType && (realChildren.length === 1 ? childFieldType : mapType(childFieldType, t => {             if (isArrayLikeType(t)) {                 return getIndexedAccessType(t, getNumberLiteralType(childIndex));             }             else {                 return t;             }         }, /*noReductions* / true)) */ TODO
    }
    getContextualTypeForJsxExpression := func(node JsxExpression, contextFlags *ContextFlags) *Type {
        exprParent := /* TODO(PropertyAccessExpression): node.parent */ TODO
         /* TODO(ConditionalExpression): isJsxAttributeLike(exprParent)             ? getContextualType(node, contextFlags)             : isJsxElement(exprParent)             ? getContextualTypeForChildJsxExpression(exprParent, node, contextFlags)             : undefined */ TODO
    }
    getContextualTypeForJsxAttribute := func(attribute /* TODO(UnionType): JsxAttribute | JsxSpreadAttribute */ any, contextFlags *ContextFlags) *Type {
        if isJsxAttribute(attribute) {
            attributesType := getApparentTypeOfContextualType(/* TODO(PropertyAccessExpression): attribute.parent */ TODO, contextFlags)
            if /* TODO(BinaryExpression): !attributesType || isTypeAny(attributesType) */ TODO {
                 undefined
            }
             getTypeOfPropertyOfContextualType(attributesType, getEscapedTextOfJsxAttributeName(/* TODO(PropertyAccessExpression): attribute.name */ TODO))
        } else {
             getContextualType(/* TODO(PropertyAccessExpression): attribute.parent */ TODO, contextFlags)
        }
    }
    isPossiblyDiscriminantValue := func(node Expression) bool {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.StringLiteral:             case SyntaxKind.NumericLiteral:             case SyntaxKind.BigIntLiteral:             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.TemplateExpression:             case SyntaxKind.TrueKeyword:             case SyntaxKind.FalseKeyword:             case SyntaxKind.NullKeyword:             case SyntaxKind.Identifier:             case SyntaxKind.UndefinedKeyword:                 return true;             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ParenthesizedExpression:                 return isPossiblyDiscriminantValue((node as PropertyAccessExpression | ParenthesizedExpression).expression);             case SyntaxKind.JsxExpression:                 return !(node as JsxExpression).expression || isPossiblyDiscriminantValue((node as JsxExpression).expression!);         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    discriminateContextualTypeByObjectMembers := func(node ObjectLiteralExpression, contextualType UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        key := /* TODO(TemplateExpression): `D${getNodeId(node)},${getTypeId(contextualType)}` */ TODO
         /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(             key,             getMatchingUnionConstituentForObjectLiteral(contextualType, node) ?? discriminateTypeByDiscriminableItems(                 contextualType,                 concatenate(                     map(                         filter(node.properties, (p): p is PropertyAssignment | ShorthandPropertyAssignment => {                             if (!p.symbol) {                                 return false;                             }                             if (p.kind === SyntaxKind.PropertyAssignment) {                                 return isPossiblyDiscriminantValue(p.initializer) && isDiscriminantProperty(contextualType, p.symbol.escapedName);                             }                             if (p.kind === SyntaxKind.ShorthandPropertyAssignment) {                                 return isDiscriminantProperty(contextualType, p.symbol.escapedName);                             }                             return false;                         }),                         prop => ([() => getContextFreeTypeOfExpression(prop.kind === SyntaxKind.PropertyAssignment ? prop.initializer : prop.name), prop.symbol.escapedName] as const),                     ),                     map(                         filter(getPropertiesOfType(contextualType), s => !!(s.flags & SymbolFlags.Optional) && !!node?.symbol?.members && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)),                         s => [() => undefinedType, s.escapedName] as const,                     ),                 ),                 isTypeAssignableTo,             ),         ) */ TODO
    }
    discriminateContextualTypeByJSXAttributes := func(node JsxAttributes, contextualType UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        key := /* TODO(TemplateExpression): `D${getNodeId(node)},${getTypeId(contextualType)}` */ TODO
        cached := getCachedType(key)
        if cached {
            /* TODO(Identifier): cached */
        }
        jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
         setCachedType(key, discriminateTypeByDiscriminableItems(contextualType, concatenate(map_(filter(/* TODO(PropertyAccessExpression): node.properties */ TODO, /* TODO(ArrowFunction): p => !!p.symbol && p.kind === SyntaxKind.JsxAttribute && isDiscriminantProperty(contextualType, p.symbol.escapedName) && (!p.initializer || isPossiblyDiscriminantValue(p.initializer)) */ TODO), /* TODO(ArrowFunction): prop => ([!(prop as JsxAttribute).initializer ? (() => trueType) : (() => getContextFreeTypeOfExpression((prop as JsxAttribute).initializer!)), prop.symbol.escapedName] as const) */ TODO), map_(filter(getPropertiesOfType(contextualType), /* TODO(ArrowFunction): s => {                             if (!(s.flags & SymbolFlags.Optional) || !node?.symbol?.members) {                                 return false;                             }                             const element = node.parent.parent;                             if (s.escapedName === jsxChildrenPropertyName && isJsxElement(element) && getSemanticJsxChildren(element.children).length) {                                 return false;                             }                             return !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName);                         } */ TODO), /* TODO(ArrowFunction): s => [() => undefinedType, s.escapedName] as const */ TODO)), isTypeAssignableTo))
    }
    getApparentTypeOfContextualType := func(node /* TODO(UnionType): Expression | MethodDeclaration */ any, contextFlags *ContextFlags) *Type {
        contextualType := /* TODO(ConditionalExpression): isObjectLiteralMethod(node) ?             getContextualTypeForObjectLiteralMethod(node, contextFlags) :             getContextualType(node, contextFlags) */ TODO
        instantiatedType := instantiateContextualType(contextualType, node, contextFlags)
        if /* TODO(BinaryExpression): instantiatedType && !(contextFlags && contextFlags & ContextFlags.NoConstraints && instantiatedType.flags & TypeFlags.TypeVariable) */ TODO {
            apparentType := mapType(instantiatedType, /* TODO(ArrowFunction): t => getObjectFlags(t) & ObjectFlags.Mapped ? t : getApparentType(t) */ TODO, /* TODO(TrueKeyword): true */ TODO)
             /* TODO(ConditionalExpression): apparentType.flags & TypeFlags.Union && isObjectLiteralExpression(node) ? discriminateContextualTypeByObjectMembers(node, apparentType as UnionType) :                 apparentType.flags & TypeFlags.Union && isJsxAttributes(node) ? discriminateContextualTypeByJSXAttributes(node, apparentType as UnionType) :                 apparentType */ TODO
        }
    }
    instantiateContextualType := func(contextualType *Type, node Node, contextFlags *ContextFlags) *Type {
        if /* TODO(BinaryExpression): contextualType && maybeTypeOfKind(contextualType, TypeFlags.Instantiable) */ TODO {
            inferenceContext := getInferenceContext(node)
            if /* TODO(BinaryExpression): inferenceContext && contextFlags! & ContextFlags.Signature && some(inferenceContext.inferences, hasInferenceCandidatesOrDefault) */ TODO {
                 instantiateInstantiableTypes(contextualType, /* TODO(PropertyAccessExpression): inferenceContext.nonFixingMapper */ TODO)
            }
            if /* TODO(PropertyAccessExpression): inferenceContext?.returnMapper */ TODO {
                type_ := instantiateInstantiableTypes(contextualType, /* TODO(PropertyAccessExpression): inferenceContext.returnMapper */ TODO)
                 /* TODO(ConditionalExpression): type.flags & TypeFlags.Union && containsType((type as UnionType).types, regularFalseType) && containsType((type as UnionType).types, regularTrueType) ?                     filterType(type, t => t !== regularFalseType && t !== regularTrueType) :                     type */ TODO
            }
        }
         contextualType
    }
    instantiateInstantiableTypes := func(type_ Type, mapper TypeMapper) Type {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Instantiable */ TODO {
             instantiateType(type_, mapper)
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
             getUnionType(map_(/* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, /* TODO(ArrowFunction): t => instantiateInstantiableTypes(t, mapper) */ TODO), /* TODO(PropertyAccessExpression): UnionReduction.None */ TODO)
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
             getIntersectionType(map_(/* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, /* TODO(ArrowFunction): t => instantiateInstantiableTypes(t, mapper) */ TODO))
        }
         type_
    }
    getContextualType := func(node Expression, contextFlags *ContextFlags) *Type {
        if /* TODO(BinaryExpression): node.flags & NodeFlags.InWithStatement */ TODO {
             undefined
        }
        index := findContextualNode(node, /* TODO(PrefixUnaryExpression): !contextFlags */ TODO)
        if /* TODO(BinaryExpression): index >= 0 */ TODO {
             /* TODO(ElementAccessExpression): contextualTypes[index] */ TODO
        }
        TODO_IDENTIFIER := node
        /* TODO(SwitchStatement): switch (parent.kind) {             case SyntaxKind.VariableDeclaration:             case SyntaxKind.Parameter:             case SyntaxKind.PropertyDeclaration:             case SyntaxKind.PropertySignature:             case SyntaxKind.BindingElement:                 return getContextualTypeForInitializerExpression(node, contextFlags);             case SyntaxKind.ArrowFunction:             case SyntaxKind.ReturnStatement:                 return getContextualTypeForReturnExpression(node, contextFlags);             case SyntaxKind.YieldExpression:                 return getContextualTypeForYieldOperand(parent as YieldExpression, contextFlags);             case SyntaxKind.AwaitExpression:                 return getContextualTypeForAwaitOperand(parent as AwaitExpression, contextFlags);             case SyntaxKind.CallExpression:             case SyntaxKind.NewExpression:                 return getContextualTypeForArgument(parent as CallExpression | NewExpression | Decorator, node);             case SyntaxKind.Decorator:                 return getContextualTypeForDecorator(parent as Decorator);             case SyntaxKind.TypeAssertionExpression:             case SyntaxKind.AsExpression:                 return isConstTypeReference((parent as AssertionExpression).type) ? getContextualType(parent as AssertionExpression, contextFlags) : getTypeFromTypeNode((parent as AssertionExpression).type);             case SyntaxKind.BinaryExpression:                 return getContextualTypeForBinaryOperand(node, contextFlags);             case SyntaxKind.PropertyAssignment:             case SyntaxKind.ShorthandPropertyAssignment:                 return getContextualTypeForObjectLiteralElement(parent as PropertyAssignment | ShorthandPropertyAssignment, contextFlags);             case SyntaxKind.SpreadAssignment:                 return getContextualType(parent.parent as ObjectLiteralExpression, contextFlags);             case SyntaxKind.ArrayLiteralExpression: {                 const arrayLiteral = parent as ArrayLiteralExpression;                 const type = getApparentTypeOfContextualType(arrayLiteral, contextFlags);                 const elementIndex = indexOfNode(arrayLiteral.elements, node);                 const spreadIndices = getNodeLinks(arrayLiteral).spreadIndices ??= getSpreadIndices(arrayLiteral.elements);                 return getContextualTypeForElementExpression(type, elementIndex, arrayLiteral.elements.length, spreadIndices.first, spreadIndices.last);             }             case SyntaxKind.ConditionalExpression:                 return getContextualTypeForConditionalOperand(node, contextFlags);             case SyntaxKind.TemplateSpan:                 Debug.assert(parent.parent.kind === SyntaxKind.TemplateExpression);                 return getContextualTypeForSubstitutionExpression(parent.parent as TemplateExpression, node);             case SyntaxKind.ParenthesizedExpression: {                 if (isInJSFile(parent)) {                     if (isJSDocSatisfiesExpression(parent)) {                         return getTypeFromTypeNode(getJSDocSatisfiesExpressionType(parent));                     }                     // Like in `checkParenthesizedExpression`, an `/** @type {xyz} * /` comment before a parenthesized expression acts as a type cast.                     const typeTag = getJSDocTypeTag(parent);                     if (typeTag && !isConstTypeReference(typeTag.typeExpression.type)) {                         return getTypeFromTypeNode(typeTag.typeExpression.type);                     }                 }                 return getContextualType(parent as ParenthesizedExpression, contextFlags);             }             case SyntaxKind.NonNullExpression:                 return getContextualType(parent as NonNullExpression, contextFlags);             case SyntaxKind.SatisfiesExpression:                 return getTypeFromTypeNode((parent as SatisfiesExpression).type);             case SyntaxKind.ExportAssignment:                 return tryGetTypeFromEffectiveTypeNode(parent as ExportAssignment);             case SyntaxKind.JsxExpression:                 return getContextualTypeForJsxExpression(parent as JsxExpression, contextFlags);             case SyntaxKind.JsxAttribute:             case SyntaxKind.JsxSpreadAttribute:                 return getContextualTypeForJsxAttribute(parent as JsxAttribute | JsxSpreadAttribute, contextFlags);             case SyntaxKind.JsxOpeningElement:             case SyntaxKind.JsxSelfClosingElement:                 return getContextualJsxElementAttributesType(parent as JsxOpeningLikeElement, contextFlags);             case SyntaxKind.ImportAttribute:                 return getContextualImportAttributeType(parent as ImportAttribute);         } */
         undefined
    }
    pushCachedContextualType := func(node Expression) {
        /* TODO(ExpressionStatement): pushContextualType(node, getContextualType(node, /*contextFlags* / undefined), /*isCache* / true); */
    }
    pushContextualType := func(node Expression, type_ *Type, isCache bool) {
        /* TODO(ExpressionStatement): contextualTypeNodes[contextualTypeCount] = node; */
        /* TODO(ExpressionStatement): contextualTypes[contextualTypeCount] = type; */
        /* TODO(ExpressionStatement): contextualIsCache[contextualTypeCount] = isCache; */
        /* TODO(ExpressionStatement): contextualTypeCount++; */
    }
    popContextualType := func() {
        /* TODO(ExpressionStatement): contextualTypeCount--; */
    }
    findContextualNode := func(node Node, includeCaches bool) /* TODO(undefined): number */ TODO {
        /* TODO(ForStatement): for (let i = contextualTypeCount - 1; i >= 0; i--) {             if (node === contextualTypeNodes[i] && (includeCaches || !contextualIsCache[i])) {                 return i;             }         } */
         /* TODO(PrefixUnaryExpression): -1 */ TODO
    }
    pushInferenceContext := func(node Node, inferenceContext *InferenceContext) {
        /* TODO(ExpressionStatement): inferenceContextNodes[inferenceContextCount] = node; */
        /* TODO(ExpressionStatement): inferenceContexts[inferenceContextCount] = inferenceContext; */
        /* TODO(ExpressionStatement): inferenceContextCount++; */
    }
    popInferenceContext := func() {
        /* TODO(ExpressionStatement): inferenceContextCount--; */
    }
    getInferenceContext := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceContext | undefined */ TODO {
        /* TODO(ForStatement): for (let i = inferenceContextCount - 1; i >= 0; i--) {             if (isNodeDescendantOf(node, inferenceContextNodes[i])) {                 return inferenceContexts[i];             }         } */
    }
    getContextualImportAttributeType := func(node ImportAttribute) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
         getTypeOfPropertyOfContextualType(getGlobalImportAttributesType(/* TODO(FalseKeyword): false */ TODO), getNameFromImportAttribute(node))
    }
    getContextualJsxElementAttributesType := func(node JsxOpeningLikeElement, contextFlags *ContextFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(BinaryExpression): isJsxOpeningElement(node) && contextFlags !== ContextFlags.Completions */ TODO {
            index := findContextualNode(/* TODO(PropertyAccessExpression): node.parent */ TODO, /* TODO(PrefixUnaryExpression): !contextFlags */ TODO)
            if /* TODO(BinaryExpression): index >= 0 */ TODO {
                 /* TODO(ElementAccessExpression): contextualTypes[index] */ TODO
            }
        }
         getContextualTypeForArgumentAtIndex(node, 0)
    }
    getEffectiveFirstArgumentForJsxSignature := func(signature Signature, node JsxOpeningLikeElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): getJsxReferenceKind(node) !== JsxReferenceKind.Component             ? getJsxPropsTypeFromCallSignature(signature, node)             : getJsxPropsTypeFromClassType(signature, node) */ TODO
    }
    getJsxPropsTypeFromCallSignature := func(sig Signature, context JsxOpeningLikeElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        propsType := getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)
        /* TODO(ExpressionStatement): propsType = getJsxManagedAttributesFromLocatedAttributes(context, getJsxNamespaceAt(context), propsType); */
        intrinsicAttribs := getJsxType(/* TODO(PropertyAccessExpression): JsxNames.IntrinsicAttributes */ TODO, context)
        if /* TODO(PrefixUnaryExpression): !isErrorType(intrinsicAttribs) */ TODO {
            /* TODO(ExpressionStatement): propsType = intersectTypes(intrinsicAttribs, propsType); */
        }
         propsType
    }
    getJsxPropsTypeForSignatureFromMember := func(sig Signature, forcedLookupLocation __String) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(PropertyAccessExpression): sig.compositeSignatures */ TODO {
            var results []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(ForOfStatement): for (const signature of sig.compositeSignatures) {                 const instance = getReturnTypeOfSignature(signature);                 if (isTypeAny(instance)) {                     return instance;                 }                 const propType = getTypeOfPropertyOfType(instance, forcedLookupLocation);                 if (!propType) {                     return;                 }                 results.push(propType);             } */
             getIntersectionType(results)
        }
        instanceType := getReturnTypeOfSignature(sig)
         /* TODO(ConditionalExpression): isTypeAny(instanceType) ? instanceType : getTypeOfPropertyOfType(instanceType, forcedLookupLocation) */ TODO
    }
    getStaticTypeOfReferencedJsxConstructor := func(context JsxOpeningLikeElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if isJsxIntrinsicTagName(/* TODO(PropertyAccessExpression): context.tagName */ TODO) {
            result := getIntrinsicAttributesTypeFromJsxOpeningLikeElement(context)
            fakeSignature := createSignatureForJSXIntrinsic(context, result)
             getOrCreateTypeFromSignature(fakeSignature)
        }
        tagType := checkExpressionCached(/* TODO(PropertyAccessExpression): context.tagName */ TODO)
        if /* TODO(BinaryExpression): tagType.flags & TypeFlags.StringLiteral */ TODO {
            result := getIntrinsicAttributesTypeFromStringLiteralType(tagType /* as */ /* TODO(TypeReference): StringLiteralType */, context)
            if /* TODO(PrefixUnaryExpression): !result */ TODO {
                 errorType
            }
            fakeSignature := createSignatureForJSXIntrinsic(context, result)
             getOrCreateTypeFromSignature(fakeSignature)
        }
         tagType
    }
    getJsxManagedAttributesFromLocatedAttributes := func(context JsxOpeningLikeElement, ns Symbol, attributesType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        managedSym := getJsxLibraryManagedAttributes(ns)
        if managedSym {
            ctorType := getStaticTypeOfReferencedJsxConstructor(context)
            result := instantiateAliasOrInterfaceWithDefaults(managedSym, isInJSFile(context), ctorType, attributesType)
            if result {
                 result
            }
        }
         attributesType
    }
    getJsxPropsTypeFromClassType := func(sig Signature, context JsxOpeningLikeElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        ns := getJsxNamespaceAt(context)
        forcedLookupLocation := getJsxElementPropertiesName(ns)
        attributesType := /* TODO(ConditionalExpression): forcedLookupLocation === undefined             // If there is no type ElementAttributesProperty, return the type of the first parameter of the signature, which should be the props type             ? getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)             : forcedLookupLocation === ""             // If there is no e.g. 'props' member in ElementAttributesProperty, use the element class type instead             ? getReturnTypeOfSignature(sig)             // Otherwise get the type of the property on the signature return type             : getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation) */ TODO
        if /* TODO(PrefixUnaryExpression): !attributesType */ TODO {
            if /* TODO(BinaryExpression): !!forcedLookupLocation && !!length(context.attributes.properties) */ TODO {
                /* TODO(ExpressionStatement): error(context, Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property, unescapeLeadingUnderscores(forcedLookupLocation)); */
            }
             unknownType
        }
        /* TODO(ExpressionStatement): attributesType = getJsxManagedAttributesFromLocatedAttributes(context, ns, attributesType); */
        if isTypeAny(attributesType) {
             attributesType
        } else {
            apparentAttributesType := attributesType
            intrinsicClassAttribs := getJsxType(/* TODO(PropertyAccessExpression): JsxNames.IntrinsicClassAttributes */ TODO, context)
            if /* TODO(PrefixUnaryExpression): !isErrorType(intrinsicClassAttribs) */ TODO {
                typeParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(/* TODO(PropertyAccessExpression): intrinsicClassAttribs.symbol */ TODO)
                hostClassType := getReturnTypeOfSignature(sig)
                var libraryManagedAttributeType Type
                if typeParams {
                    inferredArgs := fillMissingTypeArguments(/* TODO(ArrayLiteralExpression): [hostClassType] */ TODO, typeParams, getMinTypeArgumentCount(typeParams), isInJSFile(context))
                    /* TODO(ExpressionStatement): libraryManagedAttributeType = instantiateType(intrinsicClassAttribs, createTypeMapper(typeParams, inferredArgs)); */
                } else {
                    /* TODO(BinaryExpression): libraryManagedAttributeType = intrinsicClassAttribs */
                }
                /* TODO(ExpressionStatement): apparentAttributesType = intersectTypes(libraryManagedAttributeType, apparentAttributesType); */
            }
            intrinsicAttribs := getJsxType(/* TODO(PropertyAccessExpression): JsxNames.IntrinsicAttributes */ TODO, context)
            if /* TODO(PrefixUnaryExpression): !isErrorType(intrinsicAttribs) */ TODO {
                /* TODO(ExpressionStatement): apparentAttributesType = intersectTypes(intrinsicAttribs, apparentAttributesType); */
            }
             apparentAttributesType
        }
    }
    getIntersectedSignatures := func(signatures []Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
         /* TODO(ConditionalExpression): getStrictOptionValue(compilerOptions, "noImplicitAny")             ? reduceLeft(                 signatures,                 (left: Signature | undefined, right) =>                     left === right || !left ? left                         : compareTypeParametersIdentical(left.typeParameters, right!.typeParameters) ? combineSignaturesOfIntersectionMembers(left, right!)                         : undefined,             )             : undefined */ TODO
    }
    combineIntersectionThisParam := func(left *Symbol, right *Symbol, mapper *TypeMapper) *Symbol {
        if /* TODO(BinaryExpression): !left || !right */ TODO {
             /* TODO(BinaryExpression): left || right */ TODO
        }
        thisType := getUnionType(/* TODO(ArrayLiteralExpression): [getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)] */ TODO)
         createSymbolWithType(left, thisType)
    }
    combineIntersectionParameters := func(left Signature, right Signature, mapper *TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
        leftCount := getParameterCount(left)
        rightCount := getParameterCount(right)
        longest := /* TODO(ConditionalExpression): leftCount >= rightCount ? left : right */ TODO
        shorter := /* TODO(ConditionalExpression): longest === left ? right : left */ TODO
        longestCount := /* TODO(ConditionalExpression): longest === left ? leftCount : rightCount */ TODO
        eitherHasEffectiveRest := /* TODO(BinaryExpression): hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right) */ TODO
        needsExtraRestElement := /* TODO(BinaryExpression): eitherHasEffectiveRest && !hasEffectiveRestParameter(longest) */ TODO
        params := /* TODO(NewExpression): new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0)) */ TODO
        /* TODO(ForStatement): for (let i = 0; i < longestCount; i++) {             let longestParamType = tryGetTypeAtPosition(longest, i)!;             if (longest === right) {                 longestParamType = instantiateType(longestParamType, mapper);             }             let shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;             if (shorter === right) {                 shorterParamType = instantiateType(shorterParamType, mapper);             }             const unionParamType = getUnionType([longestParamType, shorterParamType]);             const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);             const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);             const leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);             const rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);              const paramName = leftName === rightName ? leftName :                 !leftName ? rightName :                 !rightName ? leftName :                 undefined;             const paramSymbol = createSymbol(                 SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0),                 paramName || `arg${i}` as __String,             );             paramSymbol.links.type = isRestParam ? createArrayType(unionParamType) : unionParamType;             params[i] = paramSymbol;         } */
        if needsExtraRestElement {
            restParamSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.FunctionScopedVariable */ TODO, "args" /* as */ /* TODO(TypeReference): __String */)
            /* TODO(ExpressionStatement): restParamSymbol.links.type = createArrayType(getTypeAtPosition(shorter, longestCount)); */
            if /* TODO(BinaryExpression): shorter === right */ TODO {
                /* TODO(ExpressionStatement): restParamSymbol.links.type = instantiateType(restParamSymbol.links.type, mapper); */
            }
            /* TODO(ExpressionStatement): params[longestCount] = restParamSymbol; */
        }
         params
    }
    combineSignaturesOfIntersectionMembers := func(left Signature, right Signature) Signature {
        typeParams := /* TODO(BinaryExpression): left.typeParameters || right.typeParameters */ TODO
        var paramMapper *TypeMapper
        if /* TODO(BinaryExpression): left.typeParameters && right.typeParameters */ TODO {
            /* TODO(ExpressionStatement): paramMapper = createTypeMapper(right.typeParameters, left.typeParameters); */
        }
        declaration := /* TODO(PropertyAccessExpression): left.declaration */ TODO
        params := combineIntersectionParameters(left, right, paramMapper)
        thisParam := combineIntersectionThisParam(/* TODO(PropertyAccessExpression): left.thisParameter */ TODO, /* TODO(PropertyAccessExpression): right.thisParameter */ TODO, paramMapper)
        minArgCount := /* TODO(PropertyAccessExpression): Math.max */ TODO(/* TODO(PropertyAccessExpression): left.minArgumentCount */ TODO, /* TODO(PropertyAccessExpression): right.minArgumentCount */ TODO)
        result := createSignature(declaration, typeParams, thisParam, params, undefined, undefined, minArgCount, /* TODO(BinaryExpression): (left.flags | right.flags) & SignatureFlags.PropagatingFlags */ TODO)
        /* TODO(ExpressionStatement): result.compositeKind = TypeFlags.Intersection; */
        /* TODO(ExpressionStatement): result.compositeSignatures = concatenate(left.compositeKind === TypeFlags.Intersection && left.compositeSignatures || [left], [right]); */
        if paramMapper {
            /* TODO(ExpressionStatement): result.mapper = left.compositeKind === TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper; */
        }
         result
    }
    getContextualCallSignature := func(type_ Type, node SignatureDeclaration) *Signature {
        signatures := getSignaturesOfType(type_, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
        applicableByArity := filter(signatures, /* TODO(ArrowFunction): s => !isAritySmaller(s, node) */ TODO)
         /* TODO(ConditionalExpression): applicableByArity.length === 1 ? applicableByArity[0] : getIntersectedSignatures(applicableByArity) */ TODO
    }
    isAritySmaller := func(signature Signature, target SignatureDeclaration) /* TODO(undefined): boolean */ TODO {
        targetParameterCount := 0
        /* TODO(ForStatement): for (; targetParameterCount < target.parameters.length; targetParameterCount++) {             const param = target.parameters[targetParameterCount];             if (param.initializer || param.questionToken || param.dotDotDotToken || isJSDocOptionalParameter(param)) {                 break;             }         } */
        if /* TODO(BinaryExpression): target.parameters.length && parameterIsThisKeyword(target.parameters[0]) */ TODO {
            /* TODO(ExpressionStatement): targetParameterCount--; */
        }
         /* TODO(BinaryExpression): !hasEffectiveRestParameter(signature) && getParameterCount(signature) < targetParameterCount */ TODO
    }
    getContextualSignatureForFunctionLikeDeclaration := func(node FunctionLikeDeclaration) *Signature {
         /* TODO(ConditionalExpression): isFunctionExpressionOrArrowFunction(node) || isObjectLiteralMethod(node)             ? getContextualSignature(node as FunctionExpression)             : undefined */ TODO
    }
    getContextualSignature := func(node /* TODO(UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any) *Signature {
        /* TODO(ExpressionStatement): Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(node)); */
        typeTagSignature := getSignatureOfTypeTag(node)
        if typeTagSignature {
             typeTagSignature
        }
        type_ := getApparentTypeOfContextualType(node, /* TODO(PropertyAccessExpression): ContextFlags.Signature */ TODO)
        if /* TODO(PrefixUnaryExpression): !type */ TODO {
             undefined
        }
        if /* TODO(PrefixUnaryExpression): !(type.flags & TypeFlags.Union) */ TODO {
             getContextualCallSignature(type_, node)
        }
        var signatureList /* TODO(ArrayType): Signature[] */ any
        types := /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO
        /* TODO(ForOfStatement): for (const current of types) {             const signature = getContextualCallSignature(current, node);             if (signature) {                 if (!signatureList) {                     // This signature will contribute to contextual union signature                     signatureList = [signature];                 }                 else if (!compareSignaturesIdentical(signatureList[0], signature, /*partialMatch* / false, /*ignoreThisTypes* / true, /*ignoreReturnTypes* / true, compareTypesIdentical)) {                     // Signatures aren't identical, do not use                     return undefined;                 }                 else {                     // Use this signature for contextual union signature                     signatureList.push(signature);                 }             }         } */
        if signatureList {
             /* TODO(ConditionalExpression): signatureList.length === 1 ? signatureList[0] : createUnionSignature(signatureList[0], signatureList) */ TODO
        }
    }
    checkGrammarRegularExpressionLiteral := func(node RegularExpressionLiteral) /* TODO(undefined): boolean */ TODO {
        sourceFile := getSourceFileOfNode(node)
        if /* TODO(BinaryExpression): !hasParseDiagnostics(sourceFile) && !node.isUnterminated */ TODO {
            var lastError *DiagnosticWithLocation
            /* TODO(ExpressionStatement): scanner ??= createScanner(ScriptTarget.ESNext, /*skipTrivia* / true); */
            /* TODO(ExpressionStatement): scanner.setScriptTarget(sourceFile.languageVersion); */
            /* TODO(ExpressionStatement): scanner.setLanguageVariant(sourceFile.languageVariant); */
            /* TODO(ExpressionStatement): scanner.setOnError((message, length, arg0) => {                 // For providing spelling suggestions                 const start = scanner!.getTokenEnd();                 if (message.category === DiagnosticCategory.Message && lastError && start === lastError.start && length === lastError.length) {                     const error = createDetachedDiagnostic(sourceFile.fileName, sourceFile.text, start, length, message, arg0);                     addRelatedInfo(lastError, error);                 }                 else if (!lastError || start !== lastError.start) {                     lastError = createFileDiagnostic(sourceFile, start, length, message, arg0);                     diagnostics.add(lastError);                 }             }); */
            /* TODO(ExpressionStatement): scanner.setText(sourceFile.text, node.pos, node.end - node.pos); */
            /* TODO(TryStatement): try {                 scanner.scan();                 Debug.assert(scanner.reScanSlashToken(/*reportErrors* / true) === SyntaxKind.RegularExpressionLiteral, "Expected scanner to rescan RegularExpressionLiteral");                 return !!lastError;             }             finally {                 scanner.setText("");                 scanner.setOnError(/*onError* / undefined);             } */
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkRegularExpressionLiteral := func(node RegularExpressionLiteral) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
        nodeLinks := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !(nodeLinks.flags & NodeCheckFlags.TypeChecked) */ TODO {
            /* TODO(ExpressionStatement): nodeLinks.flags |= NodeCheckFlags.TypeChecked; */
            /* TODO(ExpressionStatement): addLazyDiagnostic(() => checkGrammarRegularExpressionLiteral(node)); */
        }
         globalRegExpType
    }
    checkSpreadExpression := func(node SpreadElement, checkMode CheckMode) Type {
        if /* TODO(BinaryExpression): languageVersion < LanguageFeatureMinimumTarget.SpreadElements */ TODO {
            /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray); */
        }
        arrayOrIterableType := checkExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO, checkMode)
         checkIteratedTypeOrElementType(/* TODO(PropertyAccessExpression): IterationUse.Spread */ TODO, arrayOrIterableType, undefinedType, /* TODO(PropertyAccessExpression): node.expression */ TODO)
    }
    checkSyntheticExpression := func(node SyntheticExpression) Type {
         /* TODO(ConditionalExpression): node.isSpread ? getIndexedAccessType(node.type, numberType) : node.type */ TODO
    }
    hasDefaultValue := func(node /* TODO(UnionType): BindingElement | ObjectLiteralElementLike | Expression */ any) bool {
         /* TODO(BinaryExpression): node.kind === SyntaxKind.BindingElement && !!(node as BindingElement).initializer ||             node.kind === SyntaxKind.PropertyAssignment && hasDefaultValue((node as PropertyAssignment).initializer) ||             node.kind === SyntaxKind.ShorthandPropertyAssignment && !!(node as ShorthandPropertyAssignment).objectAssignmentInitializer ||             node.kind === SyntaxKind.BinaryExpression && (node as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken */ TODO
    }
    isSpreadIntoCallOrNew := func(node ArrayLiteralExpression) /* TODO(undefined): boolean */ TODO {
        parent := walkUpParenthesizedExpressions(/* TODO(PropertyAccessExpression): node.parent */ TODO)
         /* TODO(BinaryExpression): isSpreadElement(parent) && isCallOrNewExpression(parent.parent) */ TODO
    }
    checkArrayLiteral := func(node ArrayLiteralExpression, checkMode *CheckMode, forceTuple /* TODO(BooleanKeyword): boolean */ any) Type {
        elements := /* TODO(PropertyAccessExpression): node.elements */ TODO
        elementCount := /* TODO(PropertyAccessExpression): elements.length */ TODO
        var elementTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        var elementFlags []ElementFlags = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ExpressionStatement): pushCachedContextualType(node); */
        inDestructuringPattern := isAssignmentTarget(node)
        inConstContext := isConstContext(node)
        contextualType := getApparentTypeOfContextualType(node, undefined)
        inTupleContext := /* TODO(BinaryExpression): isSpreadIntoCallOrNew(node) || !!contextualType && someType(contextualType, t => isTupleLikeType(t) || isGenericMappedType(t) && !t.nameType && !!getHomomorphicTypeVariable(t.target as MappedType || t)) */ TODO
        hasOmittedExpression := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForStatement): for (let i = 0; i < elementCount; i++) {             const e = elements[i];             if (e.kind === SyntaxKind.SpreadElement) {                 if (languageVersion < LanguageFeatureMinimumTarget.SpreadElements) {                     checkExternalEmitHelpers(e, compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray);                 }                 const spreadType = checkExpression((e as SpreadElement).expression, checkMode, forceTuple);                 if (isArrayLikeType(spreadType)) {                     elementTypes.push(spreadType);                     elementFlags.push(ElementFlags.Variadic);                 }                 else if (inDestructuringPattern) {                     // Given the following situation:                     //    var c: {};                     //    [...c] = ["", 0];                     //                     // c is represented in the tree as a spread element in an array literal.                     // But c really functions as a rest element, and its purpose is to provide                     // a contextual type for the right hand side of the assignment. Therefore,                     // instead of calling checkExpression on "...c", which will give an error                     // if c is not iterable/array-like, we need to act as if we are trying to                     // get the contextual element type from it. So we do something similar to                     // getContextualTypeForElementExpression, which will crucially not error                     // if there is no index type / iterated type.                     const restElementType = getIndexTypeOfType(spreadType, numberType) ||                         getIteratedTypeOrElementType(IterationUse.Destructuring, spreadType, undefinedType, /*errorNode* / undefined, /*checkAssignability* / false) ||                         unknownType;                     elementTypes.push(restElementType);                     elementFlags.push(ElementFlags.Rest);                 }                 else {                     elementTypes.push(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, (e as SpreadElement).expression));                     elementFlags.push(ElementFlags.Rest);                 }             }             else if (exactOptionalPropertyTypes && e.kind === SyntaxKind.OmittedExpression) {                 hasOmittedExpression = true;                 elementTypes.push(undefinedOrMissingType);                 elementFlags.push(ElementFlags.Optional);             }             else {                 const type = checkExpressionForMutableLocation(e, checkMode, forceTuple);                 elementTypes.push(addOptionality(type, /*isProperty* / true, hasOmittedExpression));                 elementFlags.push(hasOmittedExpression ? ElementFlags.Optional : ElementFlags.Required);                 if (inTupleContext && checkMode && checkMode & CheckMode.Inferential && !(checkMode & CheckMode.SkipContextSensitive) && isContextSensitive(e)) {                     const inferenceContext = getInferenceContext(node);                     Debug.assert(inferenceContext); // In CheckMode.Inferential we should always have an inference context                     addIntraExpressionInferenceSite(inferenceContext, e, type);                 }             }         } */
        /* TODO(ExpressionStatement): popContextualType(); */
        if inDestructuringPattern {
             createTupleType(elementTypes, elementFlags)
        }
        if /* TODO(BinaryExpression): forceTuple || inConstContext || inTupleContext */ TODO {
             createArrayLiteralType(createTupleType(elementTypes, elementFlags, /* TODO(BinaryExpression): inConstContext && !(contextualType && someType(contextualType, isMutableArrayLikeType)) */ TODO))
        }
         createArrayLiteralType(createArrayType(/* TODO(ConditionalExpression): elementTypes.length ?                 getUnionType(sameMap(elementTypes, (t, i) => elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessTypeOrUndefined(t, numberType) || anyType : t), UnionReduction.Subtype) :                 strictNullChecks ? implicitNeverType : undefinedWideningType */ TODO, inConstContext))
    }
    createArrayLiteralType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(PrefixUnaryExpression): !(getObjectFlags(type) & ObjectFlags.Reference) */ TODO {
             type_
        }
        literalType := /* TODO(PropertyAccessExpression): (type as TypeReference).literalType */ TODO
        if /* TODO(PrefixUnaryExpression): !literalType */ TODO {
            /* TODO(ExpressionStatement): literalType = (type as TypeReference).literalType = cloneTypeReference(type as TypeReference); */
            /* TODO(ExpressionStatement): literalType.objectFlags |= ObjectFlags.ArrayLiteral | ObjectFlags.ContainsObjectOrArrayLiteral; */
        }
         literalType
    }
    isNumericName := func(name DeclarationName) bool {
        /* TODO(SwitchStatement): switch (name.kind) {             case SyntaxKind.ComputedPropertyName:                 return isNumericComputedName(name);             case SyntaxKind.Identifier:                 return isNumericLiteralName(name.escapedText);             case SyntaxKind.NumericLiteral:             case SyntaxKind.StringLiteral:                 return isNumericLiteralName(name.text);             default:                 return false;         } */
    }
    isNumericComputedName := func(name ComputedPropertyName) bool {
         isTypeAssignableToKind(checkComputedPropertyName(name), /* TODO(PropertyAccessExpression): TypeFlags.NumberLike */ TODO)
    }
    checkComputedPropertyName := func(node ComputedPropertyName) Type {
        links := getNodeLinks(/* TODO(PropertyAccessExpression): node.expression */ TODO)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            if /* TODO(BinaryExpression): (isTypeLiteralNode(node.parent.parent) || isClassLike(node.parent.parent) || isInterfaceDeclaration(node.parent.parent))                 && isBinaryExpression(node.expression) && node.expression.operatorToken.kind === SyntaxKind.InKeyword                 && node.parent.kind !== SyntaxKind.GetAccessor && node.parent.kind !== SyntaxKind.SetAccessor */ TODO {
                 /* TODO(BinaryExpression): links.resolvedType = errorType */ TODO
            }
            /* TODO(ExpressionStatement): links.resolvedType = checkExpression(node.expression); */
            if /* TODO(BinaryExpression): isPropertyDeclaration(node.parent) && !hasStaticModifier(node.parent) && isClassExpression(node.parent.parent) */ TODO {
                container := getEnclosingBlockScopeContainer(/* TODO(PropertyAccessExpression): node.parent.parent */ TODO)
                enclosingIterationStatement := getEnclosingIterationStatement(container)
                if enclosingIterationStatement {
                    /* TODO(ExpressionStatement): getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding; */
                    /* TODO(ExpressionStatement): getNodeLinks(node).flags |= NodeCheckFlags.BlockScopedBindingInLoop; */
                    /* TODO(ExpressionStatement): getNodeLinks(node.parent.parent).flags |= NodeCheckFlags.BlockScopedBindingInLoop; */
                }
            }
            if /* TODO(BinaryExpression): links.resolvedType.flags & TypeFlags.Nullable ||                 !isTypeAssignableToKind(links.resolvedType, TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.ESSymbolLike) &&                     !isTypeAssignableTo(links.resolvedType, stringNumberSymbolType) */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any); */
            }
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    isSymbolWithNumericName := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
        firstDecl := /* TODO(ElementAccessExpression): symbol.declarations?.[0] */ TODO
         /* TODO(BinaryExpression): isNumericLiteralName(symbol.escapedName) || (firstDecl && isNamedDeclaration(firstDecl) && isNumericName(firstDecl.name)) */ TODO
    }
    isSymbolWithSymbolName := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
        firstDecl := /* TODO(ElementAccessExpression): symbol.declarations?.[0] */ TODO
         /* TODO(BinaryExpression): isKnownSymbol(symbol) || (firstDecl && isNamedDeclaration(firstDecl) && isComputedPropertyName(firstDecl.name) &&             isTypeAssignableToKind(checkComputedPropertyName(firstDecl.name), TypeFlags.ESSymbol)) */ TODO
    }
    getObjectLiteralIndexInfo := func(node ObjectLiteralExpression, offset number, properties []Symbol, keyType Type) IndexInfo {
        var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForStatement): for (let i = offset; i < properties.length; i++) {             const prop = properties[i];             if (                 keyType === stringType && !isSymbolWithSymbolName(prop) ||                 keyType === numberType && isSymbolWithNumericName(prop) ||                 keyType === esSymbolType && isSymbolWithSymbolName(prop)             ) {                 propTypes.push(getTypeOfSymbol(properties[i]));             }         } */
        unionType := /* TODO(ConditionalExpression): propTypes.length ? getUnionType(propTypes, UnionReduction.Subtype) : undefinedType */ TODO
         createIndexInfo(keyType, unionType, isConstContext(node))
    }
    getImmediateAliasedSymbol := func(symbol Symbol) *Symbol {
        /* TODO(ExpressionStatement): Debug.assert((symbol.flags & SymbolFlags.Alias) !== 0, "Should only get Alias here."); */
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.immediateTarget */ TODO {
            node := getDeclarationOfAliasSymbol(symbol)
            if /* TODO(PrefixUnaryExpression): !node */ TODO {
                /* TODO(CallExpression): Debug.fail() */
            }
            /* TODO(ExpressionStatement): links.immediateTarget = getTargetOfAliasDeclaration(node, /*dontRecursivelyResolve* / true); */
        }
         /* TODO(PropertyAccessExpression): links.immediateTarget */ TODO
    }
    checkObjectLiteral := func(node ObjectLiteralExpression, checkMode CheckMode /* = */ /* TODO(PropertyAccessExpression): CheckMode.Normal */) Type {
        inDestructuringPattern := isAssignmentTarget(node)
        /* TODO(ExpressionStatement): checkGrammarObjectLiteralExpression(node, inDestructuringPattern); */
        allPropertiesTable := /* TODO(ConditionalExpression): strictNullChecks ? createSymbolTable() : undefined */ TODO
        propertiesTable := createSymbolTable()
        var propertiesArray []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
        var spread Type = emptyObjectType
        /* TODO(ExpressionStatement): pushCachedContextualType(node); */
        contextualType := getApparentTypeOfContextualType(node, undefined)
        contextualTypeHasPattern := /* TODO(BinaryExpression): contextualType && contextualType.pattern &&             (contextualType.pattern.kind === SyntaxKind.ObjectBindingPattern || contextualType.pattern.kind === SyntaxKind.ObjectLiteralExpression) */ TODO
        inConstContext := isConstContext(node)
        checkFlags := /* TODO(ConditionalExpression): inConstContext ? CheckFlags.Readonly : 0 */ TODO
        isInJavascript := /* TODO(BinaryExpression): isInJSFile(node) && !isInJsonFile(node) */ TODO
        enumTag := /* TODO(ConditionalExpression): isInJavascript ? getJSDocEnumTag(node) : undefined */ TODO
        isJSObjectLiteral := /* TODO(BinaryExpression): !contextualType && isInJavascript && !enumTag */ TODO
        var objectFlags ObjectFlags = /* TODO(PropertyAccessExpression): ObjectFlags.FreshLiteral */ TODO
        patternWithComputedProperties := /* TODO(FalseKeyword): false */ TODO
        hasComputedStringProperty := /* TODO(FalseKeyword): false */ TODO
        hasComputedNumberProperty := /* TODO(FalseKeyword): false */ TODO
        hasComputedSymbolProperty := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForOfStatement): for (const elem of node.properties) {             if (elem.name && isComputedPropertyName(elem.name)) {                 checkComputedPropertyName(elem.name);             }         } */
        offset := 0
        /* TODO(ForOfStatement): for (const memberDecl of node.properties) {             let member = getSymbolOfDeclaration(memberDecl);             const computedNameType = memberDecl.name && memberDecl.name.kind === SyntaxKind.ComputedPropertyName ?                 checkComputedPropertyName(memberDecl.name) : undefined;             if (                 memberDecl.kind === SyntaxKind.PropertyAssignment ||                 memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment ||                 isObjectLiteralMethod(memberDecl)             ) {                 let type = memberDecl.kind === SyntaxKind.PropertyAssignment ? checkPropertyAssignment(memberDecl, checkMode) :                     // avoid resolving the left side of the ShorthandPropertyAssignment outside of the destructuring                     // for error recovery purposes. For example, if a user wrote `{ a = 100 }` instead of `{ a: 100 }`.                     // we don't want to say "could not find 'a'".                     memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment ? checkExpressionForMutableLocation(!inDestructuringPattern && memberDecl.objectAssignmentInitializer ? memberDecl.objectAssignmentInitializer : memberDecl.name, checkMode) :                     checkObjectLiteralMethod(memberDecl, checkMode);                 if (isInJavascript) {                     const jsDocType = getTypeForDeclarationFromJSDocComment(memberDecl);                     if (jsDocType) {                         checkTypeAssignableTo(type, jsDocType, memberDecl);                         type = jsDocType;                     }                     else if (enumTag && enumTag.typeExpression) {                         checkTypeAssignableTo(type, getTypeFromTypeNode(enumTag.typeExpression), memberDecl);                     }                 }                 objectFlags |= getObjectFlags(type) & ObjectFlags.PropagatingFlags;                 const nameType = computedNameType && isTypeUsableAsPropertyName(computedNameType) ? computedNameType : undefined;                 const prop = nameType ?                     createSymbol(SymbolFlags.Property | member.flags, getPropertyNameFromType(nameType), checkFlags | CheckFlags.Late) :                     createSymbol(SymbolFlags.Property | member.flags, member.escapedName, checkFlags);                 if (nameType) {                     prop.links.nameType = nameType;                 }                  if (inDestructuringPattern && hasDefaultValue(memberDecl)) {                     // If object literal is an assignment pattern and if the assignment pattern specifies a default value                     // for the property, make the property optional.                     prop.flags |= SymbolFlags.Optional;                 }                 else if (contextualTypeHasPattern && !(getObjectFlags(contextualType) & ObjectFlags.ObjectLiteralPatternWithComputedProperties)) {                     // If object literal is contextually typed by the implied type of a binding pattern, and if the                     // binding pattern specifies a default value for the property, make the property optional.                     const impliedProp = getPropertyOfType(contextualType, member.escapedName);                     if (impliedProp) {                         prop.flags |= impliedProp.flags & SymbolFlags.Optional;                     }                     else if (!getIndexInfoOfType(contextualType, stringType)) {                         error(memberDecl.name, Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(member), typeToString(contextualType));                     }                 }                  prop.declarations = member.declarations;                 prop.parent = member.parent;                 if (member.valueDeclaration) {                     prop.valueDeclaration = member.valueDeclaration;                 }                  prop.links.type = type;                 prop.links.target = member;                 member = prop;                 allPropertiesTable?.set(prop.escapedName, prop);                  if (                     contextualType && checkMode & CheckMode.Inferential && !(checkMode & CheckMode.SkipContextSensitive) &&                     (memberDecl.kind === SyntaxKind.PropertyAssignment || memberDecl.kind === SyntaxKind.MethodDeclaration) && isContextSensitive(memberDecl)                 ) {                     const inferenceContext = getInferenceContext(node);                     Debug.assert(inferenceContext); // In CheckMode.Inferential we should always have an inference context                     const inferenceNode = memberDecl.kind === SyntaxKind.PropertyAssignment ? memberDecl.initializer : memberDecl;                     addIntraExpressionInferenceSite(inferenceContext, inferenceNode, type);                 }             }             else if (memberDecl.kind === SyntaxKind.SpreadAssignment) {                 if (languageVersion < LanguageFeatureMinimumTarget.ObjectAssign) {                     checkExternalEmitHelpers(memberDecl, ExternalEmitHelpers.Assign);                 }                 if (propertiesArray.length > 0) {                     spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext);                     propertiesArray = [];                     propertiesTable = createSymbolTable();                     hasComputedStringProperty = false;                     hasComputedNumberProperty = false;                     hasComputedSymbolProperty = false;                 }                 const type = getReducedType(checkExpression(memberDecl.expression, checkMode & CheckMode.Inferential));                 if (isValidSpreadType(type)) {                     const mergedType = tryMergeUnionOfObjectTypeAndEmptyObject(type, inConstContext);                     if (allPropertiesTable) {                         checkSpreadPropOverrides(mergedType, allPropertiesTable, memberDecl);                     }                     offset = propertiesArray.length;                     if (isErrorType(spread)) {                         continue;                     }                     spread = getSpreadType(spread, mergedType, node.symbol, objectFlags, inConstContext);                 }                 else {                     error(memberDecl, Diagnostics.Spread_types_may_only_be_created_from_object_types);                     spread = errorType;                 }                 continue;             }             else {                 // TypeScript 1.0 spec (April 2014)                 // A get accessor declaration is processed in the same manner as                 // an ordinary function declaration(section 6.1) with no parameters.                 // A set accessor declaration is processed in the same manner                 // as an ordinary function declaration with a single parameter and a Void return type.                 Debug.assert(memberDecl.kind === SyntaxKind.GetAccessor || memberDecl.kind === SyntaxKind.SetAccessor);                 checkNodeDeferred(memberDecl);             }              if (computedNameType && !(computedNameType.flags & TypeFlags.StringOrNumberLiteralOrUnique)) {                 if (isTypeAssignableTo(computedNameType, stringNumberSymbolType)) {                     if (isTypeAssignableTo(computedNameType, numberType)) {                         hasComputedNumberProperty = true;                     }                     else if (isTypeAssignableTo(computedNameType, esSymbolType)) {                         hasComputedSymbolProperty = true;                     }                     else {                         hasComputedStringProperty = true;                     }                     if (inDestructuringPattern) {                         patternWithComputedProperties = true;                     }                 }             }             else {                 propertiesTable.set(member.escapedName, member);             }             propertiesArray.push(member);         } */
        /* TODO(ExpressionStatement): popContextualType(); */
        if isErrorType(spread) {
             errorType
        }
        if /* TODO(BinaryExpression): spread !== emptyObjectType */ TODO {
            if /* TODO(BinaryExpression): propertiesArray.length > 0 */ TODO {
                /* TODO(ExpressionStatement): spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext); */
                /* TODO(ExpressionStatement): propertiesArray = []; */
                /* TODO(ExpressionStatement): propertiesTable = createSymbolTable(); */
                /* TODO(ExpressionStatement): hasComputedStringProperty = false; */
                /* TODO(ExpressionStatement): hasComputedNumberProperty = false; */
            }
             mapType(spread, /* TODO(ArrowFunction): t => t === emptyObjectType ? createObjectLiteralType() : t */ TODO)
        }
         createObjectLiteralType()
        createObjectLiteralType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
            indexInfos := /* TODO(ArrayLiteralExpression): [] */ TODO
            if hasComputedStringProperty {
                /* TODO(CallExpression): indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, stringType)) */
            }
            if hasComputedNumberProperty {
                /* TODO(CallExpression): indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, numberType)) */
            }
            if hasComputedSymbolProperty {
                /* TODO(CallExpression): indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, esSymbolType)) */
            }
            result := createAnonymousType(/* TODO(PropertyAccessExpression): node.symbol */ TODO, propertiesTable, emptyArray, emptyArray, indexInfos)
            /* TODO(ExpressionStatement): result.objectFlags |= objectFlags | ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral; */
            if isJSObjectLiteral {
                /* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.JSLiteral; */
            }
            if patternWithComputedProperties {
                /* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.ObjectLiteralPatternWithComputedProperties; */
            }
            if inDestructuringPattern {
                /* TODO(ExpressionStatement): result.pattern = node; */
            }
             result
        }
    }
    isValidSpreadType := func(type_ Type) bool {
        t := removeDefinitelyFalsyTypes(mapType(type_, getBaseConstraintOrType))
         /* TODO(PrefixUnaryExpression): !!(t.flags & (TypeFlags.Any | TypeFlags.NonPrimitive | TypeFlags.Object | TypeFlags.InstantiableNonPrimitive) ||             t.flags & TypeFlags.UnionOrIntersection && every((t as UnionOrIntersectionType).types, isValidSpreadType)) */ TODO
    }
    checkJsxSelfClosingElementDeferred := func(node JsxSelfClosingElement) {
        /* TODO(ExpressionStatement): checkJsxOpeningLikeElementOrOpeningFragment(node); */
    }
    checkJsxSelfClosingElement := func(node JsxSelfClosingElement, _checkMode *CheckMode) Type {
        /* TODO(ExpressionStatement): checkNodeDeferred(node); */
         /* TODO(BinaryExpression): getJsxElementTypeAt(node) || anyType */ TODO
    }
    checkJsxElementDeferred := func(node JsxElement) {
        /* TODO(ExpressionStatement): checkJsxOpeningLikeElementOrOpeningFragment(node.openingElement); */
        if isJsxIntrinsicTagName(/* TODO(PropertyAccessExpression): node.closingElement.tagName */ TODO) {
            /* TODO(ExpressionStatement): getIntrinsicTagSymbol(node.closingElement); */
        } else {
            /* TODO(ExpressionStatement): checkExpression(node.closingElement.tagName); */
        }
        /* TODO(ExpressionStatement): checkJsxChildren(node); */
    }
    checkJsxElement := func(node JsxElement, _checkMode *CheckMode) Type {
        /* TODO(ExpressionStatement): checkNodeDeferred(node); */
         /* TODO(BinaryExpression): getJsxElementTypeAt(node) || anyType */ TODO
    }
    checkJsxFragment := func(node JsxFragment) Type {
        /* TODO(ExpressionStatement): checkJsxOpeningLikeElementOrOpeningFragment(node.openingFragment); */
        nodeSourceFile := getSourceFileOfNode(node)
        if /* TODO(BinaryExpression): getJSXTransformEnabled(compilerOptions) && (compilerOptions.jsxFactory || nodeSourceFile.pragmas.has("jsx"))             && !compilerOptions.jsxFragmentFactory && !nodeSourceFile.pragmas.has("jsxfrag") */ TODO {
            /* TODO(ExpressionStatement): error(                 node,                 compilerOptions.jsxFactory                     ? Diagnostics.The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option                     : Diagnostics.An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments,             ); */
        }
        /* TODO(ExpressionStatement): checkJsxChildren(node); */
         /* TODO(BinaryExpression): getJsxElementTypeAt(node) || anyType */ TODO
    }
    isHyphenatedJsxName := func(name /* TODO(UnionType): string | __String */ any) /* TODO(undefined): boolean */ TODO {
         /* TODO(PropertyAccessExpression): (name as string).includes */ TODO("-")
    }
    isJsxIntrinsicTagName := func(tagName Node) /* TODO(TypePredicate): tagName is Identifier | JsxNamespacedName */ TODO {
         /* TODO(BinaryExpression): isIdentifier(tagName) && isIntrinsicJsxName(tagName.escapedText) || isJsxNamespacedName(tagName) */ TODO
    }
    checkJsxAttribute := func(node JsxAttribute, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): node.initializer             ? checkExpressionForMutableLocation(node.initializer, checkMode)             : trueType */ TODO
    }
    createJsxAttributesTypeFromAttributesProperty := func(openingLikeElement JsxOpeningLikeElement, checkMode CheckMode /* = */ /* TODO(PropertyAccessExpression): CheckMode.Normal */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        attributes := /* TODO(PropertyAccessExpression): openingLikeElement.attributes */ TODO
        contextualType := getContextualType(attributes, /* TODO(PropertyAccessExpression): ContextFlags.None */ TODO)
        allAttributesTable := /* TODO(ConditionalExpression): strictNullChecks ? createSymbolTable() : undefined */ TODO
        attributesTable := createSymbolTable()
        var spread Type = emptyJsxObjectType
        hasSpreadAnyType := /* TODO(FalseKeyword): false */ TODO
        var typeToIntersect *Type
        explicitlySpecifyChildrenAttribute := /* TODO(FalseKeyword): false */ TODO
        var objectFlags ObjectFlags = /* TODO(PropertyAccessExpression): ObjectFlags.JsxAttributes */ TODO
        jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(openingLikeElement))
        /* TODO(ForOfStatement): for (const attributeDecl of attributes.properties) {             const member = attributeDecl.symbol;             if (isJsxAttribute(attributeDecl)) {                 const exprType = checkJsxAttribute(attributeDecl, checkMode);                 objectFlags |= getObjectFlags(exprType) & ObjectFlags.PropagatingFlags;                  const attributeSymbol = createSymbol(SymbolFlags.Property | member.flags, member.escapedName);                 attributeSymbol.declarations = member.declarations;                 attributeSymbol.parent = member.parent;                 if (member.valueDeclaration) {                     attributeSymbol.valueDeclaration = member.valueDeclaration;                 }                 attributeSymbol.links.type = exprType;                 attributeSymbol.links.target = member;                 attributesTable.set(attributeSymbol.escapedName, attributeSymbol);                 allAttributesTable?.set(attributeSymbol.escapedName, attributeSymbol);                 if (getEscapedTextOfJsxAttributeName(attributeDecl.name) === jsxChildrenPropertyName) {                     explicitlySpecifyChildrenAttribute = true;                 }                 if (contextualType) {                     const prop = getPropertyOfType(contextualType, member.escapedName);                     if (prop && prop.declarations && isDeprecatedSymbol(prop) && isIdentifier(attributeDecl.name)) {                         addDeprecatedSuggestion(attributeDecl.name, prop.declarations, attributeDecl.name.escapedText as string);                     }                 }                 if (contextualType && checkMode & CheckMode.Inferential && !(checkMode & CheckMode.SkipContextSensitive) && isContextSensitive(attributeDecl)) {                     const inferenceContext = getInferenceContext(attributes);                     Debug.assert(inferenceContext); // In CheckMode.Inferential we should always have an inference context                     const inferenceNode = (attributeDecl.initializer as JsxExpression).expression!;                     addIntraExpressionInferenceSite(inferenceContext, inferenceNode, exprType);                 }             }             else {                 Debug.assert(attributeDecl.kind === SyntaxKind.JsxSpreadAttribute);                 if (attributesTable.size > 0) {                     spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, /*readonly* / false);                     attributesTable = createSymbolTable();                 }                 const exprType = getReducedType(checkExpression(attributeDecl.expression, checkMode & CheckMode.Inferential));                 if (isTypeAny(exprType)) {                     hasSpreadAnyType = true;                 }                 if (isValidSpreadType(exprType)) {                     spread = getSpreadType(spread, exprType, attributes.symbol, objectFlags, /*readonly* / false);                     if (allAttributesTable) {                         checkSpreadPropOverrides(exprType, allAttributesTable, attributeDecl);                     }                 }                 else {                     error(attributeDecl.expression, Diagnostics.Spread_types_may_only_be_created_from_object_types);                     typeToIntersect = typeToIntersect ? getIntersectionType([typeToIntersect, exprType]) : exprType;                 }             }         } */
        if /* TODO(PrefixUnaryExpression): !hasSpreadAnyType */ TODO {
            if /* TODO(BinaryExpression): attributesTable.size > 0 */ TODO {
                /* TODO(ExpressionStatement): spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, /*readonly* / false); */
            }
        }
        parent := /* TODO(ConditionalExpression): openingLikeElement.parent.kind === SyntaxKind.JsxElement ? openingLikeElement.parent as JsxElement : undefined */ TODO
        if /* TODO(BinaryExpression): parent && parent.openingElement === openingLikeElement && getSemanticJsxChildren(parent.children).length > 0 */ TODO {
            var childrenTypes []Type = checkJsxChildren(parent, checkMode)
            if /* TODO(BinaryExpression): !hasSpreadAnyType && jsxChildrenPropertyName && jsxChildrenPropertyName !== "" */ TODO {
                if explicitlySpecifyChildrenAttribute {
                    /* TODO(ExpressionStatement): error(attributes, Diagnostics._0_are_specified_twice_The_attribute_named_0_will_be_overwritten, unescapeLeadingUnderscores(jsxChildrenPropertyName)); */
                }
                contextualType := getApparentTypeOfContextualType(/* TODO(PropertyAccessExpression): openingLikeElement.attributes */ TODO, undefined)
                childrenContextualType := /* TODO(BinaryExpression): contextualType && getTypeOfPropertyOfContextualType(contextualType, jsxChildrenPropertyName) */ TODO
                childrenPropSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, jsxChildrenPropertyName)
                /* TODO(ExpressionStatement): childrenPropSymbol.links.type = childrenTypes.length === 1 ? childrenTypes[0] :                     childrenContextualType && someType(childrenContextualType, isTupleLikeType) ? createTupleType(childrenTypes) :                     createArrayType(getUnionType(childrenTypes)); */
                /* TODO(ExpressionStatement): childrenPropSymbol.valueDeclaration = factory.createPropertySignature(/*modifiers* / undefined, unescapeLeadingUnderscores(jsxChildrenPropertyName), /*questionToken* / undefined, /*type* / undefined); */
                /* TODO(ExpressionStatement): setParent(childrenPropSymbol.valueDeclaration, attributes); */
                /* TODO(ExpressionStatement): childrenPropSymbol.valueDeclaration.symbol = childrenPropSymbol; */
                childPropMap := createSymbolTable()
                /* TODO(ExpressionStatement): childPropMap.set(jsxChildrenPropertyName, childrenPropSymbol); */
                /* TODO(ExpressionStatement): spread = getSpreadType(spread, createAnonymousType(attributes.symbol, childPropMap, emptyArray, emptyArray, emptyArray), attributes.symbol, objectFlags, /*readonly* / false); */
            }
        }
        if hasSpreadAnyType {
             anyType
        }
        if /* TODO(BinaryExpression): typeToIntersect && spread !== emptyJsxObjectType */ TODO {
             getIntersectionType(/* TODO(ArrayLiteralExpression): [typeToIntersect, spread] */ TODO)
        }
         /* TODO(BinaryExpression): typeToIntersect || (spread === emptyJsxObjectType ? createJsxAttributesType() : spread) */ TODO
        createJsxAttributesType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
            /* TODO(ExpressionStatement): objectFlags |= ObjectFlags.FreshLiteral; */
            result := createAnonymousType(/* TODO(PropertyAccessExpression): attributes.symbol */ TODO, attributesTable, emptyArray, emptyArray, emptyArray)
            /* TODO(ExpressionStatement): result.objectFlags |= objectFlags | ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral; */
             result
        }
    }
    checkJsxChildren := func(node /* TODO(UnionType): JsxElement | JsxFragment */ any, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
        var childrenTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForOfStatement): for (const child of node.children) {             // In React, JSX text that contains only whitespaces will be ignored so we don't want to type-check that             // because then type of children property will have constituent of string type.             if (child.kind === SyntaxKind.JsxText) {                 if (!child.containsOnlyTriviaWhiteSpaces) {                     childrenTypes.push(stringType);                 }             }             else if (child.kind === SyntaxKind.JsxExpression && !child.expression) {                 continue; // empty jsx expressions don't *really* count as present children             }             else {                 childrenTypes.push(checkExpressionForMutableLocation(child, checkMode));             }         } */
         childrenTypes
    }
    checkSpreadPropOverrides := func(type_ Type, props SymbolTable, spread /* TODO(UnionType): SpreadAssignment | JsxSpreadAttribute */ any) {
        /* TODO(ForOfStatement): for (const right of getPropertiesOfType(type)) {             if (!(right.flags & SymbolFlags.Optional)) {                 const left = props.get(right.escapedName);                 if (left) {                     const diagnostic = error(left.valueDeclaration, Diagnostics._0_is_specified_more_than_once_so_this_usage_will_be_overwritten, unescapeLeadingUnderscores(left.escapedName));                     addRelatedInfo(diagnostic, createDiagnosticForNode(spread, Diagnostics.This_spread_always_overwrites_this_property));                 }             }         } */
    }
    checkJsxAttributes := func(node JsxAttributes, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         createJsxAttributesTypeFromAttributesProperty(/* TODO(PropertyAccessExpression): node.parent */ TODO, checkMode)
    }
    getJsxType := func(name __String, location Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        namespace := getJsxNamespaceAt(location)
        exports := /* TODO(BinaryExpression): namespace && getExportsOfSymbol(namespace) */ TODO
        typeSymbol := /* TODO(BinaryExpression): exports && getSymbol(exports, name, SymbolFlags.Type) */ TODO
         /* TODO(ConditionalExpression): typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType */ TODO
    }
    getIntrinsicTagSymbol := func(node /* TODO(UnionType): JsxOpeningLikeElement | JsxClosingElement */ any) Symbol {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedSymbol */ TODO {
            intrinsicElementsType := getJsxType(/* TODO(PropertyAccessExpression): JsxNames.IntrinsicElements */ TODO, node)
            if /* TODO(PrefixUnaryExpression): !isErrorType(intrinsicElementsType) */ TODO {
                if /* TODO(BinaryExpression): !isIdentifier(node.tagName) && !isJsxNamespacedName(node.tagName) */ TODO {
                    /* TODO(CallExpression): Debug.fail() */
                }
                propName := /* TODO(ConditionalExpression): isJsxNamespacedName(node.tagName) ? getEscapedTextOfJsxNamespacedName(node.tagName) : node.tagName.escapedText */ TODO
                intrinsicProp := getPropertyOfType(intrinsicElementsType, propName)
                if intrinsicProp {
                    /* TODO(ExpressionStatement): links.jsxFlags |= JsxFlags.IntrinsicNamedElement; */
                     /* TODO(BinaryExpression): links.resolvedSymbol = intrinsicProp */ TODO
                }
                indexSymbol := getApplicableIndexSymbol(intrinsicElementsType, getStringLiteralType(unescapeLeadingUnderscores(propName)))
                if indexSymbol {
                    /* TODO(ExpressionStatement): links.jsxFlags |= JsxFlags.IntrinsicIndexedElement; */
                     /* TODO(BinaryExpression): links.resolvedSymbol = indexSymbol */ TODO
                }
                if getTypeOfPropertyOrIndexSignatureOfType(intrinsicElementsType, propName) {
                    /* TODO(ExpressionStatement): links.jsxFlags |= JsxFlags.IntrinsicIndexedElement; */
                     /* TODO(BinaryExpression): links.resolvedSymbol = intrinsicElementsType.symbol */ TODO
                }
                /* TODO(ExpressionStatement): error(node, Diagnostics.Property_0_does_not_exist_on_type_1, intrinsicTagNameToString(node.tagName), "JSX." + JsxNames.IntrinsicElements); */
                 /* TODO(BinaryExpression): links.resolvedSymbol = unknownSymbol */ TODO
            } else {
                if noImplicitAny {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists, unescapeLeadingUnderscores(JsxNames.IntrinsicElements)); */
                }
                 /* TODO(BinaryExpression): links.resolvedSymbol = unknownSymbol */ TODO
            }
        }
         /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO
    }
    getJsxNamespaceContainerForImplicitImport := func(location Node) *Symbol {
        file := /* TODO(BinaryExpression): location && getSourceFileOfNode(location) */ TODO
        links := /* TODO(BinaryExpression): file && getNodeLinks(file) */ TODO
        if /* TODO(BinaryExpression): links && links.jsxImplicitImportContainer === false */ TODO {
             undefined
        }
        if /* TODO(BinaryExpression): links && links.jsxImplicitImportContainer */ TODO {
             /* TODO(PropertyAccessExpression): links.jsxImplicitImportContainer */ TODO
        }
        runtimeImportSpecifier := getJSXRuntimeImport(getJSXImplicitImportBase(compilerOptions, file), compilerOptions)
        if /* TODO(PrefixUnaryExpression): !runtimeImportSpecifier */ TODO {
             undefined
        }
        isClassic := /* TODO(BinaryExpression): getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.Classic */ TODO
        errorMessage := /* TODO(ConditionalExpression): isClassic             ? Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option             : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations */ TODO
        specifier := getJSXRuntimeImportSpecifier(file, runtimeImportSpecifier)
        mod := resolveExternalModule(/* TODO(BinaryExpression): specifier || location! */ TODO, runtimeImportSpecifier, errorMessage, location)
        result := /* TODO(ConditionalExpression): mod && mod !== unknownSymbol ? getMergedSymbol(resolveSymbol(mod)) : undefined */ TODO
        if links {
            /* TODO(ExpressionStatement): links.jsxImplicitImportContainer = result || false; */
        }
         result
    }
    getJsxNamespaceAt := func(location Node) Symbol {
        links := /* TODO(BinaryExpression): location && getNodeLinks(location) */ TODO
        if /* TODO(BinaryExpression): links && links.jsxNamespace */ TODO {
             /* TODO(PropertyAccessExpression): links.jsxNamespace */ TODO
        }
        if /* TODO(BinaryExpression): !links || links.jsxNamespace !== false */ TODO {
            resolvedNamespace := getJsxNamespaceContainerForImplicitImport(location)
            if /* TODO(BinaryExpression): !resolvedNamespace || resolvedNamespace === unknownSymbol */ TODO {
                namespaceName := getJsxNamespace(location)
                /* TODO(ExpressionStatement): resolvedNamespace = resolveName(location, namespaceName, SymbolFlags.Namespace, /*nameNotFoundMessage* / undefined, /*isUse* / false); */
            }
            if resolvedNamespace {
                candidate := resolveSymbol(getSymbol(getExportsOfSymbol(resolveSymbol(resolvedNamespace)), /* TODO(PropertyAccessExpression): JsxNames.JSX */ TODO, /* TODO(PropertyAccessExpression): SymbolFlags.Namespace */ TODO))
                if /* TODO(BinaryExpression): candidate && candidate !== unknownSymbol */ TODO {
                    if links {
                        /* TODO(ExpressionStatement): links.jsxNamespace = candidate; */
                    }
                     candidate
                }
            }
            if links {
                /* TODO(ExpressionStatement): links.jsxNamespace = false; */
            }
        }
        s := resolveSymbol(getGlobalSymbol(/* TODO(PropertyAccessExpression): JsxNames.JSX */ TODO, /* TODO(PropertyAccessExpression): SymbolFlags.Namespace */ TODO, undefined))
        if /* TODO(BinaryExpression): s === unknownSymbol */ TODO {
             /* TODO(NonNullExpression): undefined! */ TODO
        }
         /* TODO(NonNullExpression): s! */ TODO
    }
    getNameFromJsxElementAttributesContainer := func(nameOfAttribPropContainer __String, jsxNamespace Symbol) *__String {
        jsxElementAttribPropInterfaceSym := /* TODO(BinaryExpression): jsxNamespace && getSymbol(jsxNamespace.exports!, nameOfAttribPropContainer, SymbolFlags.Type) */ TODO
        jsxElementAttribPropInterfaceType := /* TODO(BinaryExpression): jsxElementAttribPropInterfaceSym && getDeclaredTypeOfSymbol(jsxElementAttribPropInterfaceSym) */ TODO
        propertiesOfJsxElementAttribPropInterface := /* TODO(BinaryExpression): jsxElementAttribPropInterfaceType && getPropertiesOfType(jsxElementAttribPropInterfaceType) */ TODO
        if propertiesOfJsxElementAttribPropInterface {
            if /* TODO(BinaryExpression): propertiesOfJsxElementAttribPropInterface.length === 0 */ TODO {
                 "" /* as */ /* TODO(TypeReference): __String */
            } else if /* TODO(BinaryExpression): propertiesOfJsxElementAttribPropInterface.length === 1 */ TODO {
                 /* TODO(PropertyAccessExpression): propertiesOfJsxElementAttribPropInterface[0].escapedName */ TODO
            } else if /* TODO(BinaryExpression): propertiesOfJsxElementAttribPropInterface.length > 1 && jsxElementAttribPropInterfaceSym.declarations */ TODO {
                /* TODO(ExpressionStatement): error(jsxElementAttribPropInterfaceSym.declarations[0], Diagnostics.The_global_type_JSX_0_may_not_have_more_than_one_property, unescapeLeadingUnderscores(nameOfAttribPropContainer)); */
            }
        }
         undefined
    }
    getJsxLibraryManagedAttributes := func(jsxNamespace Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
         /* TODO(BinaryExpression): jsxNamespace && getSymbol(jsxNamespace.exports!, JsxNames.LibraryManagedAttributes, SymbolFlags.Type) */ TODO
    }
    getJsxElementTypeSymbol := func(jsxNamespace Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
         /* TODO(BinaryExpression): jsxNamespace && getSymbol(jsxNamespace.exports!, JsxNames.ElementType, SymbolFlags.Type) */ TODO
    }
    getJsxElementPropertiesName := func(jsxNamespace Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
         getNameFromJsxElementAttributesContainer(/* TODO(PropertyAccessExpression): JsxNames.ElementAttributesPropertyNameContainer */ TODO, jsxNamespace)
    }
    getJsxElementChildrenPropertyName := func(jsxNamespace Symbol) *__String {
         getNameFromJsxElementAttributesContainer(/* TODO(PropertyAccessExpression): JsxNames.ElementChildrenAttributeNameContainer */ TODO, jsxNamespace)
    }
    getUninstantiatedJsxSignaturesOfType := func(elementType Type, caller JsxOpeningLikeElement) []Signature {
        if /* TODO(BinaryExpression): elementType.flags & TypeFlags.String */ TODO {
             /* TODO(ArrayLiteralExpression): [anySignature] */ TODO
        } else if /* TODO(BinaryExpression): elementType.flags & TypeFlags.StringLiteral */ TODO {
            intrinsicType := getIntrinsicAttributesTypeFromStringLiteralType(elementType /* as */ /* TODO(TypeReference): StringLiteralType */, caller)
            if /* TODO(PrefixUnaryExpression): !intrinsicType */ TODO {
                /* TODO(ExpressionStatement): error(caller, Diagnostics.Property_0_does_not_exist_on_type_1, (elementType as StringLiteralType).value, "JSX." + JsxNames.IntrinsicElements); */
                 emptyArray
            } else {
                fakeSignature := createSignatureForJSXIntrinsic(caller, intrinsicType)
                 /* TODO(ArrayLiteralExpression): [fakeSignature] */ TODO
            }
        }
        apparentElemType := getApparentType(elementType)
        signatures := getSignaturesOfType(apparentElemType, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO)
        if /* TODO(BinaryExpression): signatures.length === 0 */ TODO {
            /* TODO(ExpressionStatement): signatures = getSignaturesOfType(apparentElemType, SignatureKind.Call); */
        }
        if /* TODO(BinaryExpression): signatures.length === 0 && apparentElemType.flags & TypeFlags.Union */ TODO {
            /* TODO(ExpressionStatement): signatures = getUnionSignatures(map((apparentElemType as UnionType).types, t => getUninstantiatedJsxSignaturesOfType(t, caller))); */
        }
         signatures
    }
    getIntrinsicAttributesTypeFromStringLiteralType := func(type_ StringLiteralType, location Node) *Type {
        intrinsicElementsType := getJsxType(/* TODO(PropertyAccessExpression): JsxNames.IntrinsicElements */ TODO, location)
        if /* TODO(PrefixUnaryExpression): !isErrorType(intrinsicElementsType) */ TODO {
            stringLiteralTypeName := /* TODO(PropertyAccessExpression): type.value */ TODO
            intrinsicProp := getPropertyOfType(intrinsicElementsType, escapeLeadingUnderscores(stringLiteralTypeName))
            if intrinsicProp {
                 getTypeOfSymbol(intrinsicProp)
            }
            indexSignatureType := getIndexTypeOfType(intrinsicElementsType, stringType)
            if indexSignatureType {
                 indexSignatureType
            }
             undefined
        }
         anyType
    }
    checkJsxReturnAssignableToAppropriateBound := func(refKind JsxReferenceKind, elemInstanceType Type, openingLikeElement JsxOpeningLikeElement) {
        if /* TODO(BinaryExpression): refKind === JsxReferenceKind.Function */ TODO {
            sfcReturnConstraint := getJsxStatelessElementTypeAt(openingLikeElement)
            if sfcReturnConstraint {
                /* TODO(ExpressionStatement): checkTypeRelatedTo(elemInstanceType, sfcReturnConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_return_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain); */
            }
        } else if /* TODO(BinaryExpression): refKind === JsxReferenceKind.Component */ TODO {
            classConstraint := getJsxElementClassTypeAt(openingLikeElement)
            if classConstraint {
                /* TODO(ExpressionStatement): checkTypeRelatedTo(elemInstanceType, classConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_instance_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain); */
            }
        } else {
            sfcReturnConstraint := getJsxStatelessElementTypeAt(openingLikeElement)
            classConstraint := getJsxElementClassTypeAt(openingLikeElement)
            if /* TODO(BinaryExpression): !sfcReturnConstraint || !classConstraint */ TODO {

            }
            combined := getUnionType(/* TODO(ArrayLiteralExpression): [sfcReturnConstraint, classConstraint] */ TODO)
            /* TODO(ExpressionStatement): checkTypeRelatedTo(elemInstanceType, combined, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_element_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain); */
        }
        generateInitialErrorChain := func() DiagnosticMessageChain {
            componentName := getTextOfNode(/* TODO(PropertyAccessExpression): openingLikeElement.tagName */ TODO)
             chainDiagnosticMessages(undefined, /* TODO(PropertyAccessExpression): Diagnostics._0_cannot_be_used_as_a_JSX_component */ TODO, componentName)
        }
    }
    getIntrinsicAttributesTypeFromJsxOpeningLikeElement := func(node JsxOpeningLikeElement) Type {
        /* TODO(ExpressionStatement): Debug.assert(isJsxIntrinsicTagName(node.tagName)); */
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedJsxElementAttributesType */ TODO {
            symbol := getIntrinsicTagSymbol(node)
            if /* TODO(BinaryExpression): links.jsxFlags & JsxFlags.IntrinsicNamedElement */ TODO {
                 /* TODO(BinaryExpression): links.resolvedJsxElementAttributesType = getTypeOfSymbol(symbol) || errorType */ TODO
            } else if /* TODO(BinaryExpression): links.jsxFlags & JsxFlags.IntrinsicIndexedElement */ TODO {
                propName := /* TODO(ConditionalExpression): isJsxNamespacedName(node.tagName) ? getEscapedTextOfJsxNamespacedName(node.tagName) : node.tagName.escapedText */ TODO
                 /* TODO(BinaryExpression): links.resolvedJsxElementAttributesType = getApplicableIndexInfoForName(getJsxType(JsxNames.IntrinsicElements, node), propName)?.type || errorType */ TODO
            } else {
                 /* TODO(BinaryExpression): links.resolvedJsxElementAttributesType = errorType */ TODO
            }
        }
         /* TODO(PropertyAccessExpression): links.resolvedJsxElementAttributesType */ TODO
    }
    getJsxElementClassTypeAt := func(location Node) *Type {
        type_ := getJsxType(/* TODO(PropertyAccessExpression): JsxNames.ElementClass */ TODO, location)
        if isErrorType(type_) {
            /* TODO(Identifier): undefined */
        }
         type_
    }
    getJsxElementTypeAt := func(location Node) Type {
         getJsxType(/* TODO(PropertyAccessExpression): JsxNames.Element */ TODO, location)
    }
    getJsxStatelessElementTypeAt := func(location Node) *Type {
        jsxElementType := getJsxElementTypeAt(location)
        if jsxElementType {
             getUnionType(/* TODO(ArrayLiteralExpression): [jsxElementType, nullType] */ TODO)
        }
    }
    getJsxElementTypeTypeAt := func(location Node) *Type {
        ns := getJsxNamespaceAt(location)
        if /* TODO(PrefixUnaryExpression): !ns */ TODO {
            /* TODO(Identifier): undefined */
        }
        sym := getJsxElementTypeSymbol(ns)
        if /* TODO(PrefixUnaryExpression): !sym */ TODO {
            /* TODO(Identifier): undefined */
        }
        type_ := instantiateAliasOrInterfaceWithDefaults(sym, isInJSFile(location))
        if /* TODO(BinaryExpression): !type || isErrorType(type) */ TODO {
            /* TODO(Identifier): undefined */
        }
         type_
    }
    instantiateAliasOrInterfaceWithDefaults := func(managedSym Symbol, inJs bool, typeArguments []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        declaredManagedType := getDeclaredTypeOfSymbol(managedSym)
        if /* TODO(BinaryExpression): managedSym.flags & SymbolFlags.TypeAlias */ TODO {
            params := /* TODO(PropertyAccessExpression): getSymbolLinks(managedSym).typeParameters */ TODO
            if /* TODO(BinaryExpression): length(params) >= typeArguments.length */ TODO {
                args := fillMissingTypeArguments(typeArguments, params, /* TODO(PropertyAccessExpression): typeArguments.length */ TODO, inJs)
                 /* TODO(ConditionalExpression): length(args) === 0 ? declaredManagedType : getTypeAliasInstantiation(managedSym, args) */ TODO
            }
        }
        if /* TODO(BinaryExpression): length((declaredManagedType as GenericType).typeParameters) >= typeArguments.length */ TODO {
            args := fillMissingTypeArguments(typeArguments, /* TODO(PropertyAccessExpression): (declaredManagedType as GenericType).typeParameters */ TODO, /* TODO(PropertyAccessExpression): typeArguments.length */ TODO, inJs)
             createTypeReference(declaredManagedType /* as */ /* TODO(TypeReference): GenericType */, args)
        }
         undefined
    }
    getJsxIntrinsicTagNamesAt := func(location Node) []Symbol {
        intrinsics := getJsxType(/* TODO(PropertyAccessExpression): JsxNames.IntrinsicElements */ TODO, location)
         /* TODO(ConditionalExpression): intrinsics ? getPropertiesOfType(intrinsics) : emptyArray */ TODO
    }
    checkJsxPreconditions := func(errorNode Node) {
        if /* TODO(BinaryExpression): (compilerOptions.jsx || JsxEmit.None) === JsxEmit.None */ TODO {
            /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided); */
        }
        if /* TODO(BinaryExpression): getJsxElementTypeAt(errorNode) === undefined */ TODO {
            if noImplicitAny {
                /* TODO(ExpressionStatement): error(errorNode, Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist); */
            }
        }
    }
    checkJsxOpeningLikeElementOrOpeningFragment := func(node /* TODO(UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any) {
        isNodeOpeningLikeElement := isJsxOpeningLikeElement(node)
        if isNodeOpeningLikeElement {
            /* TODO(ExpressionStatement): checkGrammarJsxElement(node); */
        }
        /* TODO(ExpressionStatement): checkJsxPreconditions(node); */
        /* TODO(ExpressionStatement): markJsxAliasReferenced(node); */
        if isNodeOpeningLikeElement {
            jsxOpeningLikeNode := node
            sig := getResolvedSignature(jsxOpeningLikeNode)
            /* TODO(ExpressionStatement): checkDeprecatedSignature(sig, node); */
            elementTypeConstraint := getJsxElementTypeTypeAt(jsxOpeningLikeNode)
            if /* TODO(BinaryExpression): elementTypeConstraint !== undefined */ TODO {
                tagName := /* TODO(PropertyAccessExpression): jsxOpeningLikeNode.tagName */ TODO
                tagType := /* TODO(ConditionalExpression): isJsxIntrinsicTagName(tagName)                     ? getStringLiteralType(intrinsicTagNameToString(tagName))                     : checkExpression(tagName) */ TODO
                /* TODO(ExpressionStatement): checkTypeRelatedTo(tagType, elementTypeConstraint, assignableRelation, tagName, Diagnostics.Its_type_0_is_not_a_valid_JSX_element_type, () => {                     const componentName = getTextOfNode(tagName);                     return chainDiagnosticMessages(/*details* / undefined, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName);                 }); */
            } else {
                /* TODO(ExpressionStatement): checkJsxReturnAssignableToAppropriateBound(getJsxReferenceKind(jsxOpeningLikeNode), getReturnTypeOfSignature(sig), jsxOpeningLikeNode); */
            }
        }
    }
    isKnownProperty := func(targetType Type, name __String, isComparingJsxAttributes bool) bool {
        if /* TODO(BinaryExpression): targetType.flags & TypeFlags.Object */ TODO {
            if /* TODO(BinaryExpression): getPropertyOfObjectType(targetType, name) ||                 getApplicableIndexInfoForName(targetType, name) ||                 isLateBoundName(name) && getIndexInfoOfType(targetType, stringType) ||                 isComparingJsxAttributes && isHyphenatedJsxName(name) */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
        }
        if /* TODO(BinaryExpression): targetType.flags & TypeFlags.Substitution */ TODO {
             isKnownProperty(/* TODO(PropertyAccessExpression): (targetType as SubstitutionType).baseType */ TODO, name, isComparingJsxAttributes)
        }
        if /* TODO(BinaryExpression): targetType.flags & TypeFlags.UnionOrIntersection && isExcessPropertyCheckTarget(targetType) */ TODO {
            /* TODO(ForOfStatement): for (const t of (targetType as UnionOrIntersectionType).types) {                 if (isKnownProperty(t, name, isComparingJsxAttributes)) {                     return true;                 }             } */
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isExcessPropertyCheckTarget := func(type_ Type) bool {
         /* TODO(PrefixUnaryExpression): !!(type.flags & TypeFlags.Object && !(getObjectFlags(type) & ObjectFlags.ObjectLiteralPatternWithComputedProperties) ||             type.flags & TypeFlags.NonPrimitive ||             type.flags & TypeFlags.Substitution && isExcessPropertyCheckTarget((type as SubstitutionType).baseType) ||             type.flags & TypeFlags.Union && some((type as UnionType).types, isExcessPropertyCheckTarget) ||             type.flags & TypeFlags.Intersection && every((type as IntersectionType).types, isExcessPropertyCheckTarget)) */ TODO
    }
    checkJsxExpression := func(node JsxExpression, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        /* TODO(ExpressionStatement): checkGrammarJsxExpression(node); */
        if /* TODO(PropertyAccessExpression): node.expression */ TODO {
            type_ := checkExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO, checkMode)
            if /* TODO(BinaryExpression): node.dotDotDotToken && type !== anyType && !isArrayType(type) */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.JSX_spread_child_must_be_an_array_type); */
            }
             type_
        } else {
             errorType
        }
    }
    getDeclarationNodeFlagsFromSymbol := func(s Symbol) NodeFlags {
         /* TODO(ConditionalExpression): s.valueDeclaration ? getCombinedNodeFlagsCached(s.valueDeclaration) : 0 */ TODO
    }
    isPrototypeProperty := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Method || getCheckFlags(symbol) & CheckFlags.SyntheticMethod */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if isInJSFile(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO) {
            parent := /* TODO(PropertyAccessExpression): symbol.valueDeclaration!.parent */ TODO
             /* TODO(BinaryExpression): parent && isBinaryExpression(parent) &&                 getAssignmentDeclarationKind(parent) === AssignmentDeclarationKind.PrototypeProperty */ TODO
        }
    }
    checkPropertyAccessibility := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName | PropertyAccessExpression | VariableDeclaration | ParameterDeclaration | ImportTypeNode | PropertyAssignment | ShorthandPropertyAssignment | BindingElement */ any, isSuper bool, writing bool, type_ Type, prop Symbol, reportError /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) bool {
        errorNode := /* TODO(ConditionalExpression): !reportError ? undefined :             node.kind === SyntaxKind.QualifiedName ? node.right :             node.kind === SyntaxKind.ImportType ? node :             node.kind === SyntaxKind.BindingElement && node.propertyName ? node.propertyName : node.name */ TODO
         checkPropertyAccessibilityAtLocation(node, isSuper, writing, type_, prop, errorNode)
    }
    checkPropertyAccessibilityAtLocation := func(location Node, isSuper bool, writing bool, containingType Type, prop Symbol, errorNode Node) bool {
        flags := getDeclarationModifierFlagsFromSymbol(prop, writing)
        if isSuper {
            if /* TODO(BinaryExpression): languageVersion < ScriptTarget.ES2015 */ TODO {
                if symbolHasNonMethodDeclaration(prop) {
                    if errorNode {
                        /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword); */
                    }
                     /* TODO(FalseKeyword): false */ TODO
                }
            }
            if /* TODO(BinaryExpression): flags & ModifierFlags.Abstract */ TODO {
                if errorNode {
                    /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, symbolToString(prop), typeToString(getDeclaringClass(prop)!)); */
                }
                 /* TODO(FalseKeyword): false */ TODO
            }
            if /* TODO(BinaryExpression): !(flags & ModifierFlags.Static) && prop.declarations?.some(isClassInstanceProperty) */ TODO {
                if errorNode {
                    /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super, symbolToString(prop)); */
                }
                 /* TODO(FalseKeyword): false */ TODO
            }
        }
        if /* TODO(BinaryExpression): (flags & ModifierFlags.Abstract) && symbolHasNonMethodDeclaration(prop) &&             (isThisProperty(location) || isThisInitializedObjectBindingExpression(location) || isObjectBindingPattern(location.parent) && isThisInitializedDeclaration(location.parent.parent)) */ TODO {
            declaringClassDeclaration := getClassLikeDeclarationOfSymbol(/* TODO(NonNullExpression): getParentOfSymbol(prop)! */ TODO)
            if /* TODO(BinaryExpression): declaringClassDeclaration && isNodeUsedDuringClassInitialization(location) */ TODO {
                if errorNode {
                    /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor, symbolToString(prop), getTextOfIdentifierOrLiteral(declaringClassDeclaration.name!)); */
                }
                 /* TODO(FalseKeyword): false */ TODO
            }
        }
        if /* TODO(PrefixUnaryExpression): !(flags & ModifierFlags.NonPublicAccessibilityModifier) */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): flags & ModifierFlags.Private */ TODO {
            declaringClassDeclaration := /* TODO(NonNullExpression): getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop)!)! */ TODO
            if /* TODO(PrefixUnaryExpression): !isNodeWithinClass(location, declaringClassDeclaration) */ TODO {
                if errorNode {
                    /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(getDeclaringClass(prop)!)); */
                }
                 /* TODO(FalseKeyword): false */ TODO
            }
             /* TODO(TrueKeyword): true */ TODO
        }
        if isSuper {
             /* TODO(TrueKeyword): true */ TODO
        }
        enclosingClass := forEachEnclosingClass(location, /* TODO(ArrowFunction): enclosingDeclaration => {             const enclosingClass = getDeclaredTypeOfSymbol(getSymbolOfDeclaration(enclosingDeclaration)) as InterfaceType;             return isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing);         } */ TODO)
        if /* TODO(PrefixUnaryExpression): !enclosingClass */ TODO {
            /* TODO(ExpressionStatement): enclosingClass = getEnclosingClassFromThisParameter(location); */
            /* TODO(ExpressionStatement): enclosingClass = enclosingClass && isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing); */
            if /* TODO(BinaryExpression): flags & ModifierFlags.Static || !enclosingClass */ TODO {
                if errorNode {
                    /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(getDeclaringClass(prop) || containingType)); */
                }
                 /* TODO(FalseKeyword): false */ TODO
            }
        }
        if /* TODO(BinaryExpression): flags & ModifierFlags.Static */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): containingType.flags & TypeFlags.TypeParameter */ TODO {
            /* TODO(ExpressionStatement): containingType = (containingType as TypeParameter).isThisType ? getConstraintOfTypeParameter(containingType as TypeParameter)! : getBaseConstraintOfType(containingType as TypeParameter)!; */
        }
        if /* TODO(BinaryExpression): !containingType || !hasBaseType(containingType, enclosingClass) */ TODO {
            if errorNode {
                /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2, symbolToString(prop), typeToString(enclosingClass), typeToString(containingType)); */
            }
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(TrueKeyword): true */ TODO
    }
    getEnclosingClassFromThisParameter := func(node Node) *InterfaceType {
        thisParameter := getThisParameterFromNodeContext(node)
        thisType := /* TODO(BinaryExpression): thisParameter?.type && getTypeFromTypeNode(thisParameter.type) */ TODO
        if thisType {
            if /* TODO(BinaryExpression): thisType.flags & TypeFlags.TypeParameter */ TODO {
                /* TODO(ExpressionStatement): thisType = getConstraintOfTypeParameter(thisType as TypeParameter); */
            }
        } else {
            thisContainer := getThisContainer(node, /* TODO(FalseKeyword): false */ TODO, /* TODO(FalseKeyword): false */ TODO)
            if isFunctionLike(thisContainer) {
                /* TODO(ExpressionStatement): thisType = getContextualThisParameterType(thisContainer); */
            }
        }
        if /* TODO(BinaryExpression): thisType && getObjectFlags(thisType) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference) */ TODO {
             getTargetType(thisType) /* as */ /* TODO(TypeReference): InterfaceType */
        }
         undefined
    }
    getThisParameterFromNodeContext := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined */ TODO {
        thisContainer := getThisContainer(node, /* TODO(FalseKeyword): false */ TODO, /* TODO(FalseKeyword): false */ TODO)
         /* TODO(ConditionalExpression): thisContainer && isFunctionLike(thisContainer) ? getThisParameter(thisContainer) : undefined */ TODO
    }
    symbolHasNonMethodDeclaration := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!forEachProperty(symbol, prop => !(prop.flags & SymbolFlags.Method)) */ TODO
    }
    checkNonNullExpression := func(node /* TODO(UnionType): Expression | QualifiedName */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         checkNonNullType(checkExpression(node), node)
    }
    isNullableType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         hasTypeFacts(type_, /* TODO(PropertyAccessExpression): TypeFacts.IsUndefinedOrNull */ TODO)
    }
    getNonNullableTypeIfNeeded := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): isNullableType(type) ? getNonNullableType(type) : type */ TODO
    }
    reportObjectPossiblyNullOrUndefinedError := func(node Node, facts TypeFacts) {
        nodeText := /* TODO(ConditionalExpression): isEntityNameExpression(node) ? entityNameToString(node) : undefined */ TODO
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.NullKeyword */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.The_value_0_cannot_be_used_here, "null"); */

        }
        if /* TODO(BinaryExpression): nodeText !== undefined && nodeText.length < 100 */ TODO {
            if /* TODO(BinaryExpression): isIdentifier(node) && nodeText === "undefined" */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.The_value_0_cannot_be_used_here, "undefined"); */

            }
            /* TODO(ExpressionStatement): error(                 node,                 facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?                     Diagnostics._0_is_possibly_null_or_undefined :                     Diagnostics._0_is_possibly_undefined :                     Diagnostics._0_is_possibly_null,                 nodeText,             ); */
        } else {
            /* TODO(ExpressionStatement): error(                 node,                 facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?                     Diagnostics.Object_is_possibly_null_or_undefined :                     Diagnostics.Object_is_possibly_undefined :                     Diagnostics.Object_is_possibly_null,             ); */
        }
    }
    reportCannotInvokePossiblyNullOrUndefinedError := func(node Node, facts TypeFacts) {
        /* TODO(ExpressionStatement): error(             node,             facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?                 Diagnostics.Cannot_invoke_an_object_which_is_possibly_null_or_undefined :                 Diagnostics.Cannot_invoke_an_object_which_is_possibly_undefined :                 Diagnostics.Cannot_invoke_an_object_which_is_possibly_null,         ); */
    }
    checkNonNullTypeWithReporter := func(type_ Type, node Node, reportError func(node Node, facts TypeFacts) ) Type {
        if /* TODO(BinaryExpression): strictNullChecks && type.flags & TypeFlags.Unknown */ TODO {
            if isEntityNameExpression(node) {
                nodeText := entityNameToString(node)
                if /* TODO(BinaryExpression): nodeText.length < 100 */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics._0_is_of_type_unknown, nodeText); */
                     errorType
                }
            }
            /* TODO(ExpressionStatement): error(node, Diagnostics.Object_is_of_type_unknown); */
             errorType
        }
        facts := getTypeFacts(type_, /* TODO(PropertyAccessExpression): TypeFacts.IsUndefinedOrNull */ TODO)
        if /* TODO(BinaryExpression): facts & TypeFacts.IsUndefinedOrNull */ TODO {
            /* TODO(ExpressionStatement): reportError(node, facts); */
            t := getNonNullableType(type_)
             /* TODO(ConditionalExpression): t.flags & (TypeFlags.Nullable | TypeFlags.Never) ? errorType : t */ TODO
        }
         type_
    }
    checkNonNullType := func(type_ Type, node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         checkNonNullTypeWithReporter(type_, node, reportObjectPossiblyNullOrUndefinedError)
    }
    checkNonNullNonVoidType := func(type_ Type, node Node) Type {
        nonNullType := checkNonNullType(type_, node)
        if /* TODO(BinaryExpression): nonNullType.flags & TypeFlags.Void */ TODO {
            if isEntityNameExpression(node) {
                nodeText := entityNameToString(node)
                if /* TODO(BinaryExpression): isIdentifier(node) && nodeText === "undefined" */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.The_value_0_cannot_be_used_here, nodeText); */
                     nonNullType
                }
                if /* TODO(BinaryExpression): nodeText.length < 100 */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics._0_is_possibly_undefined, nodeText); */
                     nonNullType
                }
            }
            /* TODO(ExpressionStatement): error(node, Diagnostics.Object_is_possibly_undefined); */
        }
         nonNullType
    }
    checkPropertyAccessExpression := func(node PropertyAccessExpression, checkMode *CheckMode, writeOnly bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): node.flags & NodeFlags.OptionalChain ? checkPropertyAccessChain(node as PropertyAccessChain, checkMode) :             checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullExpression(node.expression), node.name, checkMode, writeOnly) */ TODO
    }
    checkPropertyAccessChain := func(node PropertyAccessChain, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        leftType := checkExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO)
        nonOptionalType := getOptionalExpressionType(leftType, /* TODO(PropertyAccessExpression): node.expression */ TODO)
         propagateOptionalTypeMarker(checkPropertyAccessExpressionOrQualifiedName(node, /* TODO(PropertyAccessExpression): node.expression */ TODO, checkNonNullType(nonOptionalType, /* TODO(PropertyAccessExpression): node.expression */ TODO), /* TODO(PropertyAccessExpression): node.name */ TODO, checkMode), node, /* TODO(BinaryExpression): nonOptionalType !== leftType */ TODO)
    }
    checkQualifiedName := func(node QualifiedName, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        leftType := /* TODO(ConditionalExpression): isPartOfTypeQuery(node) && isThisIdentifier(node.left) ? checkNonNullType(checkThisExpression(node.left), node.left) : checkNonNullExpression(node.left) */ TODO
         checkPropertyAccessExpressionOrQualifiedName(node, /* TODO(PropertyAccessExpression): node.left */ TODO, leftType, /* TODO(PropertyAccessExpression): node.right */ TODO, checkMode)
    }
    isMethodAccessForCall := func(node Node) /* TODO(undefined): boolean */ TODO {
        /* TODO(WhileStatement): while (node.parent.kind === SyntaxKind.ParenthesizedExpression) {             node = node.parent;         } */
         /* TODO(BinaryExpression): isCallOrNewExpression(node.parent) && node.parent.expression === node */ TODO
    }
    lookupSymbolForPrivateIdentifierDeclaration := func(propName __String, location Node) *Symbol {
        /* TODO(ForStatement): for (let containingClass = getContainingClassExcludingClassDecorators(location); !!containingClass; containingClass = getContainingClass(containingClass)) {             const { symbol } = containingClass;             const name = getSymbolNameForPrivateIdentifier(symbol, propName);             const prop = (symbol.members && symbol.members.get(name)) || (symbol.exports && symbol.exports.get(name));             if (prop) {                 return prop;             }         } */
    }
    checkGrammarPrivateIdentifierExpression := func(privId PrivateIdentifier) bool {
        if /* TODO(PrefixUnaryExpression): !getContainingClass(privId) */ TODO {
             grammarErrorOnNode(privId, /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies */ TODO)
        }
        if /* TODO(PrefixUnaryExpression): !isForInStatement(privId.parent) */ TODO {
            if /* TODO(PrefixUnaryExpression): !isExpressionNode(privId) */ TODO {
                 grammarErrorOnNode(privId, /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression */ TODO)
            }
            isInOperation := /* TODO(BinaryExpression): isBinaryExpression(privId.parent) && privId.parent.operatorToken.kind === SyntaxKind.InKeyword */ TODO
            if /* TODO(BinaryExpression): !getSymbolForPrivateIdentifierExpression(privId) && !isInOperation */ TODO {
                 grammarErrorOnNode(privId, /* TODO(PropertyAccessExpression): Diagnostics.Cannot_find_name_0 */ TODO, idText(privId))
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkPrivateIdentifierExpression := func(privId PrivateIdentifier) Type {
        /* TODO(ExpressionStatement): checkGrammarPrivateIdentifierExpression(privId); */
        symbol := getSymbolForPrivateIdentifierExpression(privId)
        if symbol {
            /* TODO(ExpressionStatement): markPropertyAsReferenced(symbol, /*nodeForCheckWriteOnly* / undefined, /*isSelfTypeAccess* / false); */
        }
         anyType
    }
    getSymbolForPrivateIdentifierExpression := func(privId PrivateIdentifier) *Symbol {
        if /* TODO(PrefixUnaryExpression): !isExpressionNode(privId) */ TODO {
             undefined
        }
        links := getNodeLinks(privId)
        if /* TODO(BinaryExpression): links.resolvedSymbol === undefined */ TODO {
            /* TODO(ExpressionStatement): links.resolvedSymbol = lookupSymbolForPrivateIdentifierDeclaration(privId.escapedText, privId); */
        }
         /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO
    }
    getPrivateIdentifierPropertyOfType := func(leftType Type, lexicallyScopedIdentifier Symbol) *Symbol {
         getPropertyOfType(leftType, /* TODO(PropertyAccessExpression): lexicallyScopedIdentifier.escapedName */ TODO)
    }
    checkPrivateIdentifierPropertyAccess := func(leftType Type, right PrivateIdentifier, lexicallyScopedIdentifier *Symbol) bool {
        var propertyOnType *Symbol
        properties := getPropertiesOfType(leftType)
        if properties {
            /* TODO(ExpressionStatement): forEach(properties, (symbol: Symbol) => {                 const decl = symbol.valueDeclaration;                 if (decl && isNamedDeclaration(decl) && isPrivateIdentifier(decl.name) && decl.name.escapedText === right.escapedText) {                     propertyOnType = symbol;                     return true;                 }             }); */
        }
        diagName := diagnosticName(right)
        if propertyOnType {
            typeValueDecl := /* TODO(PropertyAccessExpression): Debug.checkDefined */ TODO(/* TODO(PropertyAccessExpression): propertyOnType.valueDeclaration */ TODO)
            typeClass := /* TODO(PropertyAccessExpression): Debug.checkDefined */ TODO(getContainingClass(typeValueDecl))
            if /* TODO(PropertyAccessExpression): lexicallyScopedIdentifier?.valueDeclaration */ TODO {
                lexicalValueDecl := /* TODO(PropertyAccessExpression): lexicallyScopedIdentifier.valueDeclaration */ TODO
                lexicalClass := getContainingClass(lexicalValueDecl)
                /* TODO(ExpressionStatement): Debug.assert(!!lexicalClass); */
                if findAncestor(lexicalClass, /* TODO(ArrowFunction): n => typeClass === n */ TODO) {
                    diagnostic := error(right, /* TODO(PropertyAccessExpression): Diagnostics.The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling */ TODO, diagName, typeToString(leftType))
                    /* TODO(ExpressionStatement): addRelatedInfo(                         diagnostic,                         createDiagnosticForNode(                             lexicalValueDecl,                             Diagnostics.The_shadowing_declaration_of_0_is_defined_here,                             diagName,                         ),                         createDiagnosticForNode(                             typeValueDecl,                             Diagnostics.The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here,                             diagName,                         ),                     ); */
                     /* TODO(TrueKeyword): true */ TODO
                }
            }
            /* TODO(ExpressionStatement): error(                 right,                 Diagnostics.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier,                 diagName,                 diagnosticName(typeClass.name || anon),             ); */
             /* TODO(TrueKeyword): true */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isThisPropertyAccessInConstructor := func(node /* TODO(UnionType): ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop Symbol) /* TODO(undefined): boolean | undefined */ TODO {
         /* TODO(BinaryExpression): (isConstructorDeclaredProperty(prop) || isThisProperty(node) && isAutoTypedProperty(prop))             && getThisContainer(node, /*includeArrowFunctions* / true, /*includeClassComputedPropertyName* / false) === getDeclaringConstructor(prop) */ TODO
    }
    checkPropertyAccessExpressionOrQualifiedName := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, left /* TODO(UnionType): Expression | QualifiedName */ any, leftType Type, right /* TODO(UnionType): Identifier | PrivateIdentifier */ any, checkMode *CheckMode, writeOnly bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        parentSymbol := /* TODO(PropertyAccessExpression): getNodeLinks(left).resolvedSymbol */ TODO
        assignmentKind := getAssignmentTargetKind(node)
        apparentType := getApparentType(/* TODO(ConditionalExpression): assignmentKind !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(leftType) : leftType */ TODO)
        isAnyLike := /* TODO(BinaryExpression): isTypeAny(apparentType) || apparentType === silentNeverType */ TODO
        var prop *Symbol
        if isPrivateIdentifier(right) {
            if /* TODO(BinaryExpression): languageVersion < LanguageFeatureMinimumTarget.PrivateNamesAndClassStaticBlocks ||                 languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators ||                 !useDefineForClassFields */ TODO {
                if /* TODO(BinaryExpression): assignmentKind !== AssignmentKind.None */ TODO {
                    /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.ClassPrivateFieldSet); */
                }
                if /* TODO(BinaryExpression): assignmentKind !== AssignmentKind.Definite */ TODO {
                    /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.ClassPrivateFieldGet); */
                }
            }
            lexicallyScopedSymbol := lookupSymbolForPrivateIdentifierDeclaration(/* TODO(PropertyAccessExpression): right.escapedText */ TODO, right)
            if /* TODO(BinaryExpression): assignmentKind && lexicallyScopedSymbol && lexicallyScopedSymbol.valueDeclaration && isMethodDeclaration(lexicallyScopedSymbol.valueDeclaration) */ TODO {
                /* TODO(ExpressionStatement): grammarErrorOnNode(right, Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable, idText(right)); */
            }
            if isAnyLike {
                if lexicallyScopedSymbol {
                     /* TODO(ConditionalExpression): isErrorType(apparentType) ? errorType : apparentType */ TODO
                }
                if /* TODO(BinaryExpression): getContainingClassExcludingClassDecorators(right) === undefined */ TODO {
                    /* TODO(ExpressionStatement): grammarErrorOnNode(right, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies); */
                     anyType
                }
            }
            /* TODO(ExpressionStatement): prop = lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedSymbol); */
            if /* TODO(BinaryExpression): prop === undefined */ TODO {
                if checkPrivateIdentifierPropertyAccess(leftType, right, lexicallyScopedSymbol) {
                     errorType
                }
                containingClass := getContainingClassExcludingClassDecorators(right)
                if /* TODO(BinaryExpression): containingClass && isPlainJsFile(getSourceFileOfNode(containingClass), compilerOptions.checkJs) */ TODO {
                    /* TODO(ExpressionStatement): grammarErrorOnNode(right, Diagnostics.Private_field_0_must_be_declared_in_an_enclosing_class, idText(right)); */
                }
            } else {
                isSetonlyAccessor := /* TODO(BinaryExpression): prop.flags & SymbolFlags.SetAccessor && !(prop.flags & SymbolFlags.GetAccessor) */ TODO
                if /* TODO(BinaryExpression): isSetonlyAccessor && assignmentKind !== AssignmentKind.Definite */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.Private_accessor_was_defined_without_a_getter); */
                }
            }
        } else {
            if isAnyLike {
                if /* TODO(BinaryExpression): isIdentifier(left) && parentSymbol */ TODO {
                    /* TODO(ExpressionStatement): markLinkedReferences(node, ReferenceHint.Property, /*propSymbol* / undefined, leftType); */
                }
                 /* TODO(ConditionalExpression): isErrorType(apparentType) ? errorType : apparentType */ TODO
            }
            /* TODO(ExpressionStatement): prop = getPropertyOfType(apparentType, right.escapedText, /*skipObjectFunctionPropertyAugment* / isConstEnumObjectType(apparentType), /*includeTypeOnlyMembers* / node.kind === SyntaxKind.QualifiedName); */
        }
        /* TODO(ExpressionStatement): markLinkedReferences(node, ReferenceHint.Property, prop, leftType); */
        var propType Type
        if /* TODO(PrefixUnaryExpression): !prop */ TODO {
            indexInfo := /* TODO(ConditionalExpression): !isPrivateIdentifier(right) && (assignmentKind === AssignmentKind.None || !isGenericObjectType(leftType) || isThisTypeParameter(leftType)) ?                 getApplicableIndexInfoForName(apparentType, right.escapedText) : undefined */ TODO
            if /* TODO(PrefixUnaryExpression): !(indexInfo && indexInfo.type) */ TODO {
                isUncheckedJS := isUncheckedJSSuggestion(node, /* TODO(PropertyAccessExpression): leftType.symbol */ TODO, /* TODO(TrueKeyword): true */ TODO)
                if /* TODO(BinaryExpression): !isUncheckedJS && isJSLiteralType(leftType) */ TODO {
                     anyType
                }
                if /* TODO(BinaryExpression): leftType.symbol === globalThisSymbol */ TODO {
                    if /* TODO(BinaryExpression): globalThisSymbol.exports!.has(right.escapedText) && (globalThisSymbol.exports!.get(right.escapedText)!.flags & SymbolFlags.BlockScoped) */ TODO {
                        /* TODO(ExpressionStatement): error(right, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(right.escapedText), typeToString(leftType)); */
                    } else if noImplicitAny {
                        /* TODO(ExpressionStatement): error(right, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature, typeToString(leftType)); */
                    }
                     anyType
                }
                if /* TODO(BinaryExpression): right.escapedText && !checkAndReportErrorForExtendingInterface(node) */ TODO {
                    /* TODO(ExpressionStatement): reportNonexistentProperty(right, isThisTypeParameter(leftType) ? apparentType : leftType, isUncheckedJS); */
                }
                 errorType
            }
            if /* TODO(BinaryExpression): indexInfo.isReadonly && (isAssignmentTarget(node) || isDeleteTarget(node)) */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(apparentType)); */
            }
            /* TODO(ExpressionStatement): propType = indexInfo.type; */
            if /* TODO(BinaryExpression): compilerOptions.noUncheckedIndexedAccess && getAssignmentTargetKind(node) !== AssignmentKind.Definite */ TODO {
                /* TODO(ExpressionStatement): propType = getUnionType([propType, missingType]); */
            }
            if /* TODO(BinaryExpression): compilerOptions.noPropertyAccessFromIndexSignature && isPropertyAccessExpression(node) */ TODO {
                /* TODO(ExpressionStatement): error(right, Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0, unescapeLeadingUnderscores(right.escapedText)); */
            }
            if /* TODO(BinaryExpression): indexInfo.declaration && isDeprecatedDeclaration(indexInfo.declaration) */ TODO {
                /* TODO(ExpressionStatement): addDeprecatedSuggestion(right, [indexInfo.declaration], right.escapedText as string); */
            }
        } else {
            targetPropSymbol := resolveAliasWithDeprecationCheck(prop, right)
            if /* TODO(BinaryExpression): isDeprecatedSymbol(targetPropSymbol) && isUncalledFunctionReference(node, targetPropSymbol) && targetPropSymbol.declarations */ TODO {
                /* TODO(ExpressionStatement): addDeprecatedSuggestion(right, targetPropSymbol.declarations, right.escapedText as string); */
            }
            /* TODO(ExpressionStatement): checkPropertyNotUsedBeforeDeclaration(prop, node, right); */
            /* TODO(ExpressionStatement): markPropertyAsReferenced(prop, node, isSelfTypeAccess(left, parentSymbol)); */
            /* TODO(ExpressionStatement): getNodeLinks(node).resolvedSymbol = prop; */
            /* TODO(ExpressionStatement): checkPropertyAccessibility(node, left.kind === SyntaxKind.SuperKeyword, isWriteAccess(node), apparentType, prop); */
            if isAssignmentToReadonlyEntity(node /* as */ /* TODO(TypeReference): Expression */, prop, assignmentKind) {
                /* TODO(ExpressionStatement): error(right, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, idText(right)); */
                 errorType
            }
            /* TODO(ExpressionStatement): propType = isThisPropertyAccessInConstructor(node, prop) ? autoType : writeOnly || isWriteOnlyAccess(node) ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop); */
        }
         getFlowTypeOfAccessExpression(node, prop, propType, right, checkMode)
    }
    isUncheckedJSSuggestion := func(node Node, suggestion *Symbol, excludeClasses bool) bool {
        file := getSourceFileOfNode(node)
        if file {
            if /* TODO(BinaryExpression): compilerOptions.checkJs === undefined && file.checkJsDirective === undefined && (file.scriptKind === ScriptKind.JS || file.scriptKind === ScriptKind.JSX) */ TODO {
                declarationFile := forEach(/* TODO(PropertyAccessExpression): suggestion?.declarations */ TODO, getSourceFileOfNode)
                suggestionHasNoExtendsOrDecorators := /* TODO(BinaryExpression): !suggestion?.valueDeclaration                     || !isClassLike(suggestion.valueDeclaration)                     || suggestion.valueDeclaration.heritageClauses?.length                     || classOrConstructorParameterIsDecorated(/*useLegacyDecorators* / false, suggestion.valueDeclaration) */ TODO
                 /* TODO(BinaryExpression): !(file !== declarationFile && !!declarationFile && isGlobalSourceFile(declarationFile))                     && !(excludeClasses && suggestion && suggestion.flags & SymbolFlags.Class && suggestionHasNoExtendsOrDecorators)                     && !(!!node && excludeClasses && isPropertyAccessExpression(node) && node.expression.kind === SyntaxKind.ThisKeyword && suggestionHasNoExtendsOrDecorators) */ TODO
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    getFlowTypeOfAccessExpression := func(node /* TODO(UnionType): ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop *Symbol, propType Type, errorNode Node, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        assignmentKind := getAssignmentTargetKind(node)
        if /* TODO(BinaryExpression): assignmentKind === AssignmentKind.Definite */ TODO {
             removeMissingType(propType, /* TODO(PrefixUnaryExpression): !!(prop && prop.flags & SymbolFlags.Optional) */ TODO)
        }
        if /* TODO(BinaryExpression): prop &&             !(prop.flags & (SymbolFlags.Variable | SymbolFlags.Property | SymbolFlags.Accessor))             && !(prop.flags & SymbolFlags.Method && propType.flags & TypeFlags.Union)             && !isDuplicatedCommonJSExport(prop.declarations) */ TODO {
             propType
        }
        if /* TODO(BinaryExpression): propType === autoType */ TODO {
             getFlowTypeOfProperty(node, prop)
        }
        /* TODO(ExpressionStatement): propType = getNarrowableTypeForReference(propType, node, checkMode); */
        assumeUninitialized := /* TODO(FalseKeyword): false */ TODO
        if /* TODO(BinaryExpression): strictNullChecks && strictPropertyInitialization && isAccessExpression(node) && node.expression.kind === SyntaxKind.ThisKeyword */ TODO {
            declaration := /* TODO(BinaryExpression): prop && prop.valueDeclaration */ TODO
            if /* TODO(BinaryExpression): declaration && isPropertyWithoutInitializer(declaration) */ TODO {
                if /* TODO(PrefixUnaryExpression): !isStatic(declaration) */ TODO {
                    flowContainer := getControlFlowContainer(node)
                    if /* TODO(BinaryExpression): flowContainer.kind === SyntaxKind.Constructor && flowContainer.parent === declaration.parent && !(declaration.flags & NodeFlags.Ambient) */ TODO {
                        /* TODO(ExpressionStatement): assumeUninitialized = true; */
                    }
                }
            }
        } else if /* TODO(BinaryExpression): strictNullChecks && prop && prop.valueDeclaration &&             isPropertyAccessExpression(prop.valueDeclaration) &&             getAssignmentDeclarationPropertyAccessKind(prop.valueDeclaration) &&             getControlFlowContainer(node) === getControlFlowContainer(prop.valueDeclaration) */ TODO {
            /* TODO(ExpressionStatement): assumeUninitialized = true; */
        }
        flowType := getFlowTypeOfReference(node, propType, /* TODO(ConditionalExpression): assumeUninitialized ? getOptionalType(propType) : propType */ TODO)
        if /* TODO(BinaryExpression): assumeUninitialized && !containsUndefinedType(propType) && containsUndefinedType(flowType) */ TODO {
            /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(prop!)); */
             propType
        }
         /* TODO(ConditionalExpression): assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType */ TODO
    }
    checkPropertyNotUsedBeforeDeclaration := func(prop Symbol, node /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, right /* TODO(UnionType): Identifier | PrivateIdentifier */ any) {
        TODO_IDENTIFIER := prop
        if /* TODO(BinaryExpression): !valueDeclaration || getSourceFileOfNode(node).isDeclarationFile */ TODO {

        }
        diagnosticMessage
        declarationName := idText(right)
        if /* TODO(BinaryExpression): isInPropertyInitializerOrClassStaticBlock(node)             && !isOptionalPropertyDeclaration(valueDeclaration)             && !(isAccessExpression(node) && isAccessExpression(node.expression))             && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right)             && !(isMethodDeclaration(valueDeclaration) && getCombinedModifierFlagsCached(valueDeclaration) & ModifierFlags.Static)             && (useDefineForClassFields || !isPropertyDeclaredInAncestorClass(prop)) */ TODO {
            /* TODO(ExpressionStatement): diagnosticMessage = error(right, Diagnostics.Property_0_is_used_before_its_initialization, declarationName); */
        } else if /* TODO(BinaryExpression): valueDeclaration.kind === SyntaxKind.ClassDeclaration &&             node.parent.kind !== SyntaxKind.TypeReference &&             !(valueDeclaration.flags & NodeFlags.Ambient) &&             !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) */ TODO {
            /* TODO(ExpressionStatement): diagnosticMessage = error(right, Diagnostics.Class_0_used_before_its_declaration, declarationName); */
        }
        if diagnosticMessage {
            /* TODO(ExpressionStatement): addRelatedInfo(diagnosticMessage, createDiagnosticForNode(valueDeclaration, Diagnostics._0_is_declared_here, declarationName)); */
        }
    }
    isInPropertyInitializerOrClassStaticBlock := func(node Node) bool {
         /* TODO(PrefixUnaryExpression): !!findAncestor(node, node => {             switch (node.kind) {                 case SyntaxKind.PropertyDeclaration:                     return true;                 case SyntaxKind.PropertyAssignment:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                 case SyntaxKind.SpreadAssignment:                 case SyntaxKind.ComputedPropertyName:                 case SyntaxKind.TemplateSpan:                 case SyntaxKind.JsxExpression:                 case SyntaxKind.JsxAttribute:                 case SyntaxKind.JsxAttributes:                 case SyntaxKind.JsxSpreadAttribute:                 case SyntaxKind.JsxOpeningElement:                 case SyntaxKind.ExpressionWithTypeArguments:                 case SyntaxKind.HeritageClause:                     return false;                 case SyntaxKind.ArrowFunction:                 case SyntaxKind.ExpressionStatement:                     return isBlock(node.parent) && isClassStaticBlockDeclaration(node.parent.parent) ? true : "quit";                 default:                     return isExpressionNode(node) ? false : "quit";             }         }) */ TODO
    }
    isPropertyDeclaredInAncestorClass := func(prop Symbol) bool {
        if /* TODO(PrefixUnaryExpression): !(prop.parent!.flags & SymbolFlags.Class) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        var classType *InterfaceType = getTypeOfSymbol(/* TODO(NonNullExpression): prop.parent! */ TODO) /* as */ /* TODO(TypeReference): InterfaceType */
        /* TODO(WhileStatement): while (true) {             classType = classType.symbol && getSuperClass(classType) as InterfaceType | undefined;             if (!classType) {                 return false;             }             const superProperty = getPropertyOfType(classType, prop.escapedName);             if (superProperty && superProperty.valueDeclaration) {                 return true;             }         } */
    }
    getSuperClass := func(classType InterfaceType) *Type {
        x := getBaseTypes(classType)
        if /* TODO(BinaryExpression): x.length === 0 */ TODO {
             undefined
        }
         getIntersectionType(x)
    }
    reportNonexistentProperty := func(propNode /* TODO(UnionType): Identifier | PrivateIdentifier */ any, containingType Type, isUncheckedJS bool) {
        var errorInfo *DiagnosticMessageChain
        var relatedInfo *Diagnostic
        if /* TODO(BinaryExpression): !isPrivateIdentifier(propNode) && containingType.flags & TypeFlags.Union && !(containingType.flags & TypeFlags.Primitive) */ TODO {
            /* TODO(ForOfStatement): for (const subtype of (containingType as UnionType).types) {                 if (!getPropertyOfType(subtype, propNode.escapedText) && !getApplicableIndexInfoForName(subtype, propNode.escapedText)) {                     errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(subtype));                     break;                 }             } */
        }
        if typeHasStaticProperty(/* TODO(PropertyAccessExpression): propNode.escapedText */ TODO, containingType) {
            propName := declarationNameToString(propNode)
            typeName := typeToString(containingType)
            /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName, typeName + "." + propName); */
        } else {
            promisedType := getPromisedTypeOfPromise(containingType)
            if /* TODO(BinaryExpression): promisedType && getPropertyOfType(promisedType, propNode.escapedText) */ TODO {
                /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(containingType)); */
                /* TODO(ExpressionStatement): relatedInfo = createDiagnosticForNode(propNode, Diagnostics.Did_you_forget_to_use_await); */
            } else {
                missingProperty := declarationNameToString(propNode)
                container := typeToString(containingType)
                libSuggestion := getSuggestedLibForNonExistentProperty(missingProperty, containingType)
                if /* TODO(BinaryExpression): libSuggestion !== undefined */ TODO {
                    /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later, missingProperty, container, libSuggestion); */
                } else {
                    suggestion := getSuggestedSymbolForNonexistentProperty(propNode, containingType)
                    if /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
                        suggestedName := symbolName(suggestion)
                        message := /* TODO(ConditionalExpression): isUncheckedJS ? Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2 : Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2 */ TODO
                        /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(errorInfo, message, missingProperty, container, suggestedName); */
                        /* TODO(ExpressionStatement): relatedInfo = suggestion.valueDeclaration && createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestedName); */
                    } else {
                        diagnostic := /* TODO(ConditionalExpression): containerSeemsToBeEmptyDomElement(containingType)                             ? Diagnostics.Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom                             : Diagnostics.Property_0_does_not_exist_on_type_1 */ TODO
                        /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(elaborateNeverIntersection(errorInfo, containingType), diagnostic, missingProperty, container); */
                    }
                }
            }
        }
        resultDiagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(propNode), propNode, errorInfo)
        if relatedInfo {
            /* TODO(ExpressionStatement): addRelatedInfo(resultDiagnostic, relatedInfo); */
        }
        /* TODO(ExpressionStatement): addErrorOrSuggestion(!isUncheckedJS || errorInfo.code !== Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2.code, resultDiagnostic); */
    }
    containerSeemsToBeEmptyDomElement := func(containingType Type) /* TODO(undefined): boolean | undefined */ TODO {
         /* TODO(BinaryExpression): (compilerOptions.lib && !compilerOptions.lib.includes("dom")) &&             everyContainedType(containingType, type => type.symbol && /^(?:EventTarget|Node|(?:HTML[a-zA-Z]*)?Element)$/.test(unescapeLeadingUnderscores(type.symbol.escapedName))) &&             isEmptyObjectType(containingType) */ TODO
    }
    typeHasStaticProperty := func(propName __String, containingType Type) bool {
        prop := /* TODO(BinaryExpression): containingType.symbol && getPropertyOfType(getTypeOfSymbol(containingType.symbol), propName) */ TODO
         /* TODO(BinaryExpression): prop !== undefined && !!prop.valueDeclaration && isStatic(prop.valueDeclaration) */ TODO
    }
    getSuggestedLibForNonExistentName := func(name /* TODO(UnionType): __String | Identifier */ any) /* TODO(undefined): string | undefined */ TODO {
        missingName := diagnosticName(name)
        allFeatures := getScriptTargetFeatures()
        typeFeatures := /* TODO(PropertyAccessExpression): allFeatures.get */ TODO(missingName)
         /* TODO(BinaryExpression): typeFeatures && firstIterator(typeFeatures.keys()) */ TODO
    }
    getSuggestedLibForNonExistentProperty := func(missingProperty string, containingType Type) /* TODO(undefined): string | undefined */ TODO {
        container := /* TODO(PropertyAccessExpression): getApparentType(containingType).symbol */ TODO
        if /* TODO(PrefixUnaryExpression): !container */ TODO {
             undefined
        }
        containingTypeName := symbolName(container)
        allFeatures := getScriptTargetFeatures()
        typeFeatures := /* TODO(PropertyAccessExpression): allFeatures.get */ TODO(containingTypeName)
        if typeFeatures {
            /* TODO(ForOfStatement): for (const [libTarget, featuresOfType] of typeFeatures) {                 if (contains(featuresOfType, missingProperty)) {                     return libTarget;                 }             } */
        }
    }
    getSuggestedSymbolForNonexistentClassMember := func(name string, baseType Type) *Symbol {
         getSpellingSuggestionForName(name, getPropertiesOfType(baseType), /* TODO(PropertyAccessExpression): SymbolFlags.ClassMember */ TODO)
    }
    getSuggestedSymbolForNonexistentProperty := func(name /* TODO(UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) *Symbol {
        props := getPropertiesOfType(containingType)
        if /* TODO(BinaryExpression): typeof name !== "string" */ TODO {
            parent := /* TODO(PropertyAccessExpression): name.parent */ TODO
            if isPropertyAccessExpression(parent) {
                /* TODO(ExpressionStatement): props = filter(props, prop => isValidPropertyAccessForCompletions(parent, containingType, prop)); */
            }
            /* TODO(ExpressionStatement): name = idText(name); */
        }
         getSpellingSuggestionForName(name, props, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO)
    }
    getSuggestedSymbolForNonexistentJSXAttribute := func(name /* TODO(UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) *Symbol {
        strName := /* TODO(ConditionalExpression): isString(name) ? name : idText(name) */ TODO
        properties := getPropertiesOfType(containingType)
        jsxSpecific := /* TODO(ConditionalExpression): strName === "for" ? find(properties, x => symbolName(x) === "htmlFor")             : strName === "class" ? find(properties, x => symbolName(x) === "className")             : undefined */ TODO
         /* TODO(BinaryExpression): jsxSpecific ?? getSpellingSuggestionForName(strName, properties, SymbolFlags.Value) */ TODO
    }
    getSuggestionForNonexistentProperty := func(name /* TODO(UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) /* TODO(StringKeyword): string */ any {
        suggestion := getSuggestedSymbolForNonexistentProperty(name, containingType)
         /* TODO(BinaryExpression): suggestion && symbolName(suggestion) */ TODO
    }
    getSuggestionForSymbolNameLookup := func(symbols SymbolTable, name __String, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        symbol := getSymbol(symbols, name, meaning)
        if symbol {
            /* TODO(Identifier): symbol */
        }
        var candidates []Symbol
        if /* TODO(BinaryExpression): symbols === globals */ TODO {
            primitives := mapDefined(/* TODO(ArrayLiteralExpression): ["string", "number", "boolean", "object", "bigint", "symbol"] */ TODO, /* TODO(ArrowFunction): s => symbols.has((s.charAt(0).toUpperCase() + s.slice(1)) as __String)                     ? createSymbol(SymbolFlags.TypeAlias, s as __String) as Symbol                     : undefined */ TODO)
            /* TODO(ExpressionStatement): candidates = primitives.concat(arrayFrom(symbols.values())); */
        } else {
            /* TODO(ExpressionStatement): candidates = arrayFrom(symbols.values()); */
        }
         getSpellingSuggestionForName(unescapeLeadingUnderscores(name), candidates, meaning)
    }
    getSuggestedSymbolForNonexistentSymbol := func(location Node, outerName __String, meaning SymbolFlags) *Symbol {
        /* TODO(ExpressionStatement): Debug.assert(outerName !== undefined, "outername should always be defined"); */
        result := resolveNameForSymbolSuggestion(location, outerName, meaning, undefined, /* TODO(FalseKeyword): false */ TODO, /* TODO(FalseKeyword): false */ TODO)
         result
    }
    getSuggestedSymbolForNonexistentModule := func(name Identifier, targetModule Symbol) *Symbol {
         /* TODO(BinaryExpression): targetModule.exports && getSpellingSuggestionForName(idText(name), getExportsOfModuleAsArray(targetModule), SymbolFlags.ModuleMember) */ TODO
    }
    getSuggestionForNonexistentIndexSignature := func(objectType Type, expr ElementAccessExpression, keyedType Type) /* TODO(StringKeyword): string */ any {
        hasProp := func(name /* TODO(UnionType): "set" | "get" */ any) /* TODO(undefined): boolean */ TODO {
            prop := getPropertyOfObjectType(objectType, name /* as */ /* TODO(TypeReference): __String */)
            if prop {
                s := getSingleCallSignature(getTypeOfSymbol(prop))
                 /* TODO(BinaryExpression): !!s && getMinArgumentCount(s) >= 1 && isTypeAssignableTo(keyedType, getTypeAtPosition(s, 0)) */ TODO
            }
             /* TODO(FalseKeyword): false */ TODO
        }
        suggestedMethod := /* TODO(ConditionalExpression): isAssignmentTarget(expr) ? "set" : "get" */ TODO
        if /* TODO(PrefixUnaryExpression): !hasProp(suggestedMethod) */ TODO {
             undefined
        }
        suggestion := tryGetPropertyAccessOrIdentifierToString(/* TODO(PropertyAccessExpression): expr.expression */ TODO)
        if /* TODO(BinaryExpression): suggestion === undefined */ TODO {
            /* TODO(ExpressionStatement): suggestion = suggestedMethod; */
        } else {
            /* TODO(ExpressionStatement): suggestion += "." + suggestedMethod; */
        }
         suggestion
    }
    getSuggestedTypeForNonexistentStringLiteralType := func(source StringLiteralType, target UnionType) *StringLiteralType {
        candidates := /* TODO(PropertyAccessExpression): target.types.filter */ TODO(/* TODO(ArrowFunction): (type): type is StringLiteralType => !!(type.flags & TypeFlags.StringLiteral) */ TODO)
         getSpellingSuggestion(/* TODO(PropertyAccessExpression): source.value */ TODO, candidates, /* TODO(ArrowFunction): type => type.value */ TODO)
    }
    getSpellingSuggestionForName := func(name string, symbols []Symbol, meaning SymbolFlags) *Symbol {
         getSpellingSuggestion(name, symbols, getCandidateName)
        getCandidateName := func(candidate Symbol) /* TODO(undefined): string | undefined */ TODO {
            candidateName := symbolName(candidate)
            if startsWith(candidateName, '"') {
                 undefined
            }
            if /* TODO(BinaryExpression): candidate.flags & meaning */ TODO {
                 candidateName
            }
            if /* TODO(BinaryExpression): candidate.flags & SymbolFlags.Alias */ TODO {
                alias := tryResolveAlias(candidate)
                if /* TODO(BinaryExpression): alias && alias.flags & meaning */ TODO {
                     candidateName
                }
            }
             undefined
        }
    }
    markPropertyAsReferenced := func(prop Symbol, nodeForCheckWriteOnly Node, isSelfTypeAccess bool) {
        valueDeclaration := /* TODO(BinaryExpression): prop && (prop.flags & SymbolFlags.ClassMember) && prop.valueDeclaration */ TODO
        if /* TODO(PrefixUnaryExpression): !valueDeclaration */ TODO {

        }
        hasPrivateModifier := hasEffectiveModifier(valueDeclaration, /* TODO(PropertyAccessExpression): ModifierFlags.Private */ TODO)
        hasPrivateIdentifier := /* TODO(BinaryExpression): prop.valueDeclaration && isNamedDeclaration(prop.valueDeclaration) && isPrivateIdentifier(prop.valueDeclaration.name) */ TODO
        if /* TODO(BinaryExpression): !hasPrivateModifier && !hasPrivateIdentifier */ TODO {

        }
        if /* TODO(BinaryExpression): nodeForCheckWriteOnly && isWriteOnlyAccess(nodeForCheckWriteOnly) && !(prop.flags & SymbolFlags.SetAccessor) */ TODO {

        }
        if isSelfTypeAccess {
            containingMethod := findAncestor(nodeForCheckWriteOnly, isFunctionLikeDeclaration)
            if /* TODO(BinaryExpression): containingMethod && containingMethod.symbol === prop */ TODO {

            }
        }
        /* TODO(ExpressionStatement): (getCheckFlags(prop) & CheckFlags.Instantiated ? getSymbolLinks(prop).target : prop)!.isReferenced = SymbolFlags.All; */
    }
    isSelfTypeAccess := func(name /* TODO(UnionType): Expression | QualifiedName */ any, parent *Symbol) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): name.kind === SyntaxKind.ThisKeyword             || !!parent && isEntityNameExpression(name) && parent === getResolvedSymbol(getFirstIdentifier(name)) */ TODO
    }
    isValidPropertyAccess := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, propertyName __String) bool {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.PropertyAccessExpression:                 return isValidPropertyAccessWithType(node, node.expression.kind === SyntaxKind.SuperKeyword, propertyName, getWidenedType(checkExpression(node.expression)));             case SyntaxKind.QualifiedName:                 return isValidPropertyAccessWithType(node, /*isSuper* / false, propertyName, getWidenedType(checkExpression(node.left)));             case SyntaxKind.ImportType:                 return isValidPropertyAccessWithType(node, /*isSuper* / false, propertyName, getTypeFromTypeNode(node));         } */
    }
    isValidPropertyAccessForCompletions := func(node /* TODO(UnionType): PropertyAccessExpression | ImportTypeNode | QualifiedName */ any, type_ Type, property Symbol) bool {
         isPropertyAccessible(node, /* TODO(BinaryExpression): node.kind === SyntaxKind.PropertyAccessExpression && node.expression.kind === SyntaxKind.SuperKeyword */ TODO, /* TODO(FalseKeyword): false */ TODO, type_, property)
    }
    isValidPropertyAccessWithType := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, isSuper bool, propertyName __String, type_ Type) bool {
        if isTypeAny(type_) {
             /* TODO(TrueKeyword): true */ TODO
        }
        prop := getPropertyOfType(type_, propertyName)
         /* TODO(BinaryExpression): !!prop && isPropertyAccessible(node, isSuper, /*isWrite* / false, type, prop) */ TODO
    }
    isPropertyAccessible := func(node Node, isSuper bool, isWrite bool, containingType Type, property Symbol) bool {
        if isTypeAny(containingType) {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): property.valueDeclaration && isPrivateIdentifierClassElementDeclaration(property.valueDeclaration) */ TODO {
            declClass := getContainingClass(/* TODO(PropertyAccessExpression): property.valueDeclaration */ TODO)
             /* TODO(BinaryExpression): !isOptionalChain(node) && !!findAncestor(node, parent => parent === declClass) */ TODO
        }
         checkPropertyAccessibilityAtLocation(node, isSuper, isWrite, containingType, property)
    }
    getForInVariableSymbol := func(node ForInStatement) *Symbol {
        initializer := /* TODO(PropertyAccessExpression): node.initializer */ TODO
        if /* TODO(BinaryExpression): initializer.kind === SyntaxKind.VariableDeclarationList */ TODO {
            variable := /* TODO(ElementAccessExpression): (initializer as VariableDeclarationList).declarations[0] */ TODO
            if /* TODO(BinaryExpression): variable && !isBindingPattern(variable.name) */ TODO {
                 getSymbolOfDeclaration(variable)
            }
        } else if /* TODO(BinaryExpression): initializer.kind === SyntaxKind.Identifier */ TODO {
             getResolvedSymbol(initializer /* as */ /* TODO(TypeReference): Identifier */)
        }
         undefined
    }
    hasNumericPropertyNames := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): getIndexInfosOfType(type).length === 1 && !!getIndexInfoOfType(type, numberType) */ TODO
    }
    isForInVariableForNumericPropertyNames := func(expr Expression) /* TODO(undefined): boolean */ TODO {
        e := skipParentheses(expr)
        if /* TODO(BinaryExpression): e.kind === SyntaxKind.Identifier */ TODO {
            symbol := getResolvedSymbol(e /* as */ /* TODO(TypeReference): Identifier */)
            if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Variable */ TODO {
                var child Node = expr
                node := /* TODO(PropertyAccessExpression): expr.parent */ TODO
                /* TODO(WhileStatement): while (node) {                     if (                         node.kind === SyntaxKind.ForInStatement &&                         child === (node as ForInStatement).statement &&                         getForInVariableSymbol(node as ForInStatement) === symbol &&                         hasNumericPropertyNames(getTypeOfExpression((node as ForInStatement).expression))                     ) {                         return true;                     }                     child = node;                     node = node.parent;                 } */
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkIndexedAccess := func(node ElementAccessExpression, checkMode *CheckMode) Type {
         /* TODO(ConditionalExpression): node.flags & NodeFlags.OptionalChain ? checkElementAccessChain(node as ElementAccessChain, checkMode) :             checkElementAccessExpression(node, checkNonNullExpression(node.expression), checkMode) */ TODO
    }
    checkElementAccessChain := func(node ElementAccessChain, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        exprType := checkExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO)
        nonOptionalType := getOptionalExpressionType(exprType, /* TODO(PropertyAccessExpression): node.expression */ TODO)
         propagateOptionalTypeMarker(checkElementAccessExpression(node, checkNonNullType(nonOptionalType, /* TODO(PropertyAccessExpression): node.expression */ TODO), checkMode), node, /* TODO(BinaryExpression): nonOptionalType !== exprType */ TODO)
    }
    checkElementAccessExpression := func(node ElementAccessExpression, exprType Type, checkMode *CheckMode) Type {
        objectType := /* TODO(ConditionalExpression): getAssignmentTargetKind(node) !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(exprType) : exprType */ TODO
        indexExpression := /* TODO(PropertyAccessExpression): node.argumentExpression */ TODO
        indexType := checkExpression(indexExpression)
        if /* TODO(BinaryExpression): isErrorType(objectType) || objectType === silentNeverType */ TODO {
             objectType
        }
        if /* TODO(BinaryExpression): isConstEnumObjectType(objectType) && !isStringLiteralLike(indexExpression) */ TODO {
            /* TODO(ExpressionStatement): error(indexExpression, Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal); */
             errorType
        }
        effectiveIndexType := /* TODO(ConditionalExpression): isForInVariableForNumericPropertyNames(indexExpression) ? numberType : indexType */ TODO
        assignmentTargetKind := getAssignmentTargetKind(node)
        var accessFlags AccessFlags
        if /* TODO(BinaryExpression): assignmentTargetKind === AssignmentKind.None */ TODO {
            /* TODO(ExpressionStatement): accessFlags = AccessFlags.ExpressionPosition; */
        } else {
            /* TODO(ExpressionStatement): accessFlags = AccessFlags.Writing | (isGenericObjectType(objectType) && !isThisTypeParameter(objectType) ? AccessFlags.NoIndexSignatures : 0); */
            if /* TODO(BinaryExpression): assignmentTargetKind === AssignmentKind.Compound */ TODO {
                /* TODO(ExpressionStatement): accessFlags |= AccessFlags.ExpressionPosition; */
            }
        }
        indexedAccessType := /* TODO(BinaryExpression): getIndexedAccessTypeOrUndefined(objectType, effectiveIndexType, accessFlags, node) || errorType */ TODO
         checkIndexedAccessIndexType(getFlowTypeOfAccessExpression(node, /* TODO(PropertyAccessExpression): getNodeLinks(node).resolvedSymbol */ TODO, indexedAccessType, indexExpression, checkMode), node)
    }
    callLikeExpressionMayHaveTypeArguments := func(node CallLikeExpression) /* TODO(TypePredicate): node is CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement */ TODO {
         /* TODO(BinaryExpression): isCallOrNewExpression(node) || isTaggedTemplateExpression(node) || isJsxOpeningLikeElement(node) */ TODO
    }
    resolveUntypedCall := func(node CallLikeExpression) Signature {
        if callLikeExpressionMayHaveTypeArguments(node) {
            /* TODO(ExpressionStatement): forEach(node.typeArguments, checkSourceElement); */
        }
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.TaggedTemplateExpression */ TODO {
            /* TODO(ExpressionStatement): checkExpression(node.template); */
        } else if isJsxOpeningLikeElement(node) {
            /* TODO(ExpressionStatement): checkExpression(node.attributes); */
        } else if isBinaryExpression(node) {
            /* TODO(ExpressionStatement): checkExpression(node.left); */
        } else if isCallOrNewExpression(node) {
            /* TODO(ExpressionStatement): forEach(node.arguments, argument => {                 checkExpression(argument);             }); */
        }
         anySignature
    }
    resolveErrorCall := func(node CallLikeExpression) Signature {
        /* TODO(ExpressionStatement): resolveUntypedCall(node); */
         unknownSignature
    }
    reorderCandidates := func(signatures []Signature, result []Signature, callChainFlags SignatureFlags) {
        var lastParent Node
        var lastSymbol *Symbol
        cutoffIndex := 0
        var index /* TODO(NumberKeyword): number */ any
        specializedIndex := /* TODO(PrefixUnaryExpression): -1 */ TODO
        var spliceIndex number
        /* TODO(ExpressionStatement): Debug.assert(!result.length); */
        /* TODO(ForOfStatement): for (const signature of signatures) {             const symbol = signature.declaration && getSymbolOfDeclaration(signature.declaration);             const parent = signature.declaration && signature.declaration.parent;             if (!lastSymbol || symbol === lastSymbol) {                 if (lastParent && parent === lastParent) {                     index = index! + 1;                 }                 else {                     lastParent = parent;                     index = cutoffIndex;                 }             }             else {                 // current declaration belongs to a different symbol                 // set cutoffIndex so re-orderings in the future won't change result set from 0 to cutoffIndex                 index = cutoffIndex = result.length;                 lastParent = parent;             }             lastSymbol = symbol;              // specialized signatures always need to be placed before non-specialized signatures regardless             // of the cutoff position; see GH#1133             if (signatureHasLiteralTypes(signature)) {                 specializedIndex++;                 spliceIndex = specializedIndex;                 // The cutoff index always needs to be greater than or equal to the specialized signature index                 // in order to prevent non-specialized signatures from being added before a specialized                 // signature.                 cutoffIndex++;             }             else {                 spliceIndex = index;             }              result.splice(spliceIndex, 0, callChainFlags ? getOptionalCallSignature(signature, callChainFlags) : signature);         } */
    }
    isSpreadArgument := func(arg *Expression) /* TODO(TypePredicate): arg is Expression */ TODO {
         /* TODO(BinaryExpression): !!arg && (arg.kind === SyntaxKind.SpreadElement || arg.kind === SyntaxKind.SyntheticExpression && (arg as SyntheticExpression).isSpread) */ TODO
    }
    getSpreadArgumentIndex := func(args []Expression) number {
         findIndex(args, isSpreadArgument)
    }
    acceptsVoid := func(t Type) bool {
         /* TODO(PrefixUnaryExpression): !!(t.flags & TypeFlags.Void) */ TODO
    }
    acceptsVoidUndefinedUnknownOrAny := func(t Type) bool {
         /* TODO(PrefixUnaryExpression): !!(t.flags & (TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Unknown | TypeFlags.Any)) */ TODO
    }
    hasCorrectArity := func(node CallLikeExpression, args []Expression, signature Signature, signatureHelpTrailingComma /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) /* TODO(undefined): boolean */ TODO {
        var argCount number
        callIsIncomplete := /* TODO(FalseKeyword): false */ TODO
        effectiveParameterCount := getParameterCount(signature)
        effectiveMinimumArguments := getMinArgumentCount(signature)
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.TaggedTemplateExpression */ TODO {
            /* TODO(ExpressionStatement): argCount = args.length; */
            if /* TODO(BinaryExpression): node.template.kind === SyntaxKind.TemplateExpression */ TODO {
                lastSpan := last(/* TODO(PropertyAccessExpression): node.template.templateSpans */ TODO)
                /* TODO(ExpressionStatement): callIsIncomplete = nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated; */
            } else {
                templateLiteral := /* TODO(PropertyAccessExpression): node.template */ TODO /* as */ /* TODO(TypeReference): LiteralExpression */
                /* TODO(ExpressionStatement): Debug.assert(templateLiteral.kind === SyntaxKind.NoSubstitutionTemplateLiteral); */
                /* TODO(ExpressionStatement): callIsIncomplete = !!templateLiteral.isUnterminated; */
            }
        } else if /* TODO(BinaryExpression): node.kind === SyntaxKind.Decorator */ TODO {
            /* TODO(ExpressionStatement): argCount = getDecoratorArgumentCount(node, signature); */
        } else if /* TODO(BinaryExpression): node.kind === SyntaxKind.BinaryExpression */ TODO {
            /* TODO(ExpressionStatement): argCount = 1; */
        } else if isJsxOpeningLikeElement(node) {
            /* TODO(ExpressionStatement): callIsIncomplete = node.attributes.end === node.end; */
            if callIsIncomplete {
                 /* TODO(TrueKeyword): true */ TODO
            }
            /* TODO(ExpressionStatement): argCount = effectiveMinimumArguments === 0 ? args.length : 1; */
            /* TODO(ExpressionStatement): effectiveParameterCount = args.length === 0 ? effectiveParameterCount : 1; */
            /* TODO(ExpressionStatement): effectiveMinimumArguments = Math.min(effectiveMinimumArguments, 1); */
        } else if /* TODO(PrefixUnaryExpression): !node.arguments */ TODO {
            /* TODO(ExpressionStatement): Debug.assert(node.kind === SyntaxKind.NewExpression); */
             /* TODO(BinaryExpression): getMinArgumentCount(signature) === 0 */ TODO
        } else {
            /* TODO(ExpressionStatement): argCount = signatureHelpTrailingComma ? args.length + 1 : args.length; */
            /* TODO(ExpressionStatement): callIsIncomplete = node.arguments.end === node.end; */
            spreadArgIndex := getSpreadArgumentIndex(args)
            if /* TODO(BinaryExpression): spreadArgIndex >= 0 */ TODO {
                 /* TODO(BinaryExpression): spreadArgIndex >= getMinArgumentCount(signature) && (hasEffectiveRestParameter(signature) || spreadArgIndex < getParameterCount(signature)) */ TODO
            }
        }
        if /* TODO(BinaryExpression): !hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): callIsIncomplete || argCount >= effectiveMinimumArguments */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        /* TODO(ForStatement): for (let i = argCount; i < effectiveMinimumArguments; i++) {             const type = getTypeAtPosition(signature, i);             if (filterType(type, isInJSFile(node) && !strictNullChecks ? acceptsVoidUndefinedUnknownOrAny : acceptsVoid).flags & TypeFlags.Never) {                 return false;             }         } */
         /* TODO(TrueKeyword): true */ TODO
    }
    hasCorrectTypeArgumentArity := func(signature Signature, typeArguments *NodeArray[TypeNode]) /* TODO(undefined): boolean */ TODO {
        numTypeParameters := length(/* TODO(PropertyAccessExpression): signature.typeParameters */ TODO)
        minTypeArgumentCount := getMinTypeArgumentCount(/* TODO(PropertyAccessExpression): signature.typeParameters */ TODO)
         /* TODO(BinaryExpression): !some(typeArguments) ||             (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters) */ TODO
    }
    isInstantiatedGenericParameter := func(signature Signature, pos number) /* TODO(undefined): boolean */ TODO {
        type_
         /* TODO(PrefixUnaryExpression): !!(signature.target && (type = tryGetTypeAtPosition(signature.target, pos)) && isGenericType(type)) */ TODO
    }
    getSingleCallSignature := func(type_ Type) *Signature {
         getSingleSignature(type_, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO, /* TODO(FalseKeyword): false */ TODO)
    }
    getSingleCallOrConstructSignature := func(type_ Type) *Signature {
         /* TODO(BinaryExpression): getSingleSignature(type, SignatureKind.Call, /*allowMembers* / false) ||             getSingleSignature(type, SignatureKind.Construct, /*allowMembers* / false) */ TODO
    }
    getSingleSignature := func(type_ Type, kind SignatureKind, allowMembers bool) *Signature {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
            resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
            if /* TODO(BinaryExpression): allowMembers || resolved.properties.length === 0 && resolved.indexInfos.length === 0 */ TODO {
                if /* TODO(BinaryExpression): kind === SignatureKind.Call && resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0 */ TODO {
                     /* TODO(ElementAccessExpression): resolved.callSignatures[0] */ TODO
                }
                if /* TODO(BinaryExpression): kind === SignatureKind.Construct && resolved.constructSignatures.length === 1 && resolved.callSignatures.length === 0 */ TODO {
                     /* TODO(ElementAccessExpression): resolved.constructSignatures[0] */ TODO
                }
            }
        }
         undefined
    }
    instantiateSignatureInContextOf := func(signature Signature, contextualSignature Signature, inferenceContext InferenceContext, compareTypes TypeComparer) Signature {
        context := createInferenceContext(/* TODO(NonNullExpression): getTypeParametersForMapper(signature)! */ TODO, signature, /* TODO(PropertyAccessExpression): InferenceFlags.None */ TODO, compareTypes)
        restType := getEffectiveRestType(contextualSignature)
        mapper := /* TODO(BinaryExpression): inferenceContext && (restType && restType.flags & TypeFlags.TypeParameter ? inferenceContext.nonFixingMapper : inferenceContext.mapper) */ TODO
        sourceSignature := /* TODO(ConditionalExpression): mapper ? instantiateSignature(contextualSignature, mapper) : contextualSignature */ TODO
        /* TODO(ExpressionStatement): applyToParameterTypes(sourceSignature, signature, (source, target) => {             // Type parameters from outer context referenced by source type are fixed by instantiation of the source type             inferTypes(context.inferences, source, target);         }); */
        if /* TODO(PrefixUnaryExpression): !inferenceContext */ TODO {
            /* TODO(ExpressionStatement): applyToReturnTypes(contextualSignature, signature, (source, target) => {                 inferTypes(context.inferences, source, target, InferencePriority.ReturnType);             }); */
        }
         getSignatureInstantiation(signature, getInferredTypes(context), isInJSFile(/* TODO(PropertyAccessExpression): contextualSignature.declaration */ TODO))
    }
    inferJsxTypeArguments := func(node JsxOpeningLikeElement, signature Signature, checkMode CheckMode, context InferenceContext) []Type {
        paramType := getEffectiveFirstArgumentForJsxSignature(signature, node)
        checkAttrType := checkExpressionWithContextualType(/* TODO(PropertyAccessExpression): node.attributes */ TODO, paramType, context, checkMode)
        /* TODO(ExpressionStatement): inferTypes(context.inferences, checkAttrType, paramType); */
         getInferredTypes(context)
    }
    getThisArgumentType := func(thisArgumentNode *Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(PrefixUnaryExpression): !thisArgumentNode */ TODO {
             voidType
        }
        thisArgumentType := checkExpression(thisArgumentNode)
         /* TODO(ConditionalExpression): isRightSideOfInstanceofExpression(thisArgumentNode) ? thisArgumentType :             isOptionalChainRoot(thisArgumentNode.parent) ? getNonNullableType(thisArgumentType) :             isOptionalChain(thisArgumentNode.parent) ? removeOptionalTypeMarker(thisArgumentType) :             thisArgumentType */ TODO
    }
    inferTypeArguments := func(node CallLikeExpression, signature Signature, args []Expression, checkMode CheckMode, context InferenceContext) []Type {
        if isJsxOpeningLikeElement(node) {
             inferJsxTypeArguments(node, signature, checkMode, context)
        }
        if /* TODO(BinaryExpression): node.kind !== SyntaxKind.Decorator && node.kind !== SyntaxKind.BinaryExpression */ TODO {
            skipBindingPatterns := every(/* TODO(PropertyAccessExpression): signature.typeParameters */ TODO, /* TODO(ArrowFunction): p => !!getDefaultFromTypeParameter(p) */ TODO)
            contextualType := getContextualType(node, /* TODO(ConditionalExpression): skipBindingPatterns ? ContextFlags.SkipBindingPatterns : ContextFlags.None */ TODO)
            if contextualType {
                inferenceTargetType := getReturnTypeOfSignature(signature)
                if couldContainTypeVariables(inferenceTargetType) {
                    outerContext := getInferenceContext(node)
                    isFromBindingPattern := /* TODO(BinaryExpression): !skipBindingPatterns && getContextualType(node, ContextFlags.SkipBindingPatterns) !== contextualType */ TODO
                    if /* TODO(PrefixUnaryExpression): !isFromBindingPattern */ TODO {
                        outerMapper := getMapperFromContext(cloneInferenceContext(outerContext, /* TODO(PropertyAccessExpression): InferenceFlags.NoDefault */ TODO))
                        instantiatedType := instantiateType(contextualType, outerMapper)
                        contextualSignature := getSingleCallSignature(instantiatedType)
                        inferenceSourceType := /* TODO(ConditionalExpression): contextualSignature && contextualSignature.typeParameters ?                             getOrCreateTypeFromSignature(getSignatureInstantiationWithoutFillingInTypeArguments(contextualSignature, contextualSignature.typeParameters)) :                             instantiatedType */ TODO
                        /* TODO(ExpressionStatement): inferTypes(context.inferences, inferenceSourceType, inferenceTargetType, InferencePriority.ReturnType); */
                    }
                    returnContext := createInferenceContext(/* TODO(NonNullExpression): signature.typeParameters! */ TODO, signature, /* TODO(PropertyAccessExpression): context.flags */ TODO)
                    returnSourceType := instantiateType(contextualType, /* TODO(BinaryExpression): outerContext && outerContext.returnMapper */ TODO)
                    /* TODO(ExpressionStatement): inferTypes(returnContext.inferences, returnSourceType, inferenceTargetType); */
                    /* TODO(ExpressionStatement): context.returnMapper = some(returnContext.inferences, hasInferenceCandidates) ? getMapperFromContext(cloneInferredPartOfContext(returnContext)) : undefined; */
                }
            }
        }
        restType := getNonArrayRestType(signature)
        argCount := /* TODO(ConditionalExpression): restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length */ TODO
        if /* TODO(BinaryExpression): restType && restType.flags & TypeFlags.TypeParameter */ TODO {
            info := find(/* TODO(PropertyAccessExpression): context.inferences */ TODO, /* TODO(ArrowFunction): info => info.typeParameter === restType */ TODO)
            if info {
                /* TODO(ExpressionStatement): info.impliedArity = findIndex(args, isSpreadArgument, argCount) < 0 ? args.length - argCount : undefined; */
            }
        }
        thisType := getThisTypeOfSignature(signature)
        if /* TODO(BinaryExpression): thisType && couldContainTypeVariables(thisType) */ TODO {
            thisArgumentNode := getThisArgumentOfCall(node)
            /* TODO(ExpressionStatement): inferTypes(context.inferences, getThisArgumentType(thisArgumentNode), thisType); */
        }
        /* TODO(ForStatement): for (let i = 0; i < argCount; i++) {             const arg = args[i];             if (arg.kind !== SyntaxKind.OmittedExpression) {                 const paramType = getTypeAtPosition(signature, i);                 if (couldContainTypeVariables(paramType)) {                     const argType = checkExpressionWithContextualType(arg, paramType, context, checkMode);                     inferTypes(context.inferences, argType, paramType);                 }             }         } */
        if /* TODO(BinaryExpression): restType && couldContainTypeVariables(restType) */ TODO {
            spreadType := getSpreadArgumentType(args, argCount, /* TODO(PropertyAccessExpression): args.length */ TODO, restType, context, checkMode)
            /* TODO(ExpressionStatement): inferTypes(context.inferences, spreadType, restType); */
        }
         getInferredTypes(context)
    }
    getMutableArrayOrTupleType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? mapType(type, getMutableArrayOrTupleType) :             type.flags & TypeFlags.Any || isMutableArrayOrTuple(getBaseConstraintOfType(type) || type) ? type :             isTupleType(type) ? createTupleType(getElementTypes(type), type.target.elementFlags, /*readonly* / false, type.target.labeledElementDeclarations) :             createTupleType([type], [ElementFlags.Variadic]) */ TODO
    }
    getSpreadArgumentType := func(args []Expression, index number, argCount number, restType Type, context *InferenceContext, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        inConstContext := isConstTypeVariable(restType)
        if /* TODO(BinaryExpression): index >= argCount - 1 */ TODO {
            arg := /* TODO(ElementAccessExpression): args[argCount - 1] */ TODO
            if isSpreadArgument(arg) {
                spreadType := /* TODO(ConditionalExpression): arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type :                     checkExpressionWithContextualType((arg as SpreadElement).expression, restType, context, checkMode) */ TODO
                if isArrayLikeType(spreadType) {
                     getMutableArrayOrTupleType(spreadType)
                }
                 createArrayType(checkIteratedTypeOrElementType(/* TODO(PropertyAccessExpression): IterationUse.Spread */ TODO, spreadType, undefinedType, /* TODO(ConditionalExpression): arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg */ TODO), inConstContext)
            }
        }
        types := /* TODO(ArrayLiteralExpression): [] */ TODO
        flags := /* TODO(ArrayLiteralExpression): [] */ TODO
        names := /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForStatement): for (let i = index; i < argCount; i++) {             const arg = args[i];             if (isSpreadArgument(arg)) {                 const spreadType = arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type : checkExpression((arg as SpreadElement).expression);                 if (isArrayLikeType(spreadType)) {                     types.push(spreadType);                     flags.push(ElementFlags.Variadic);                 }                 else {                     types.push(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg));                     flags.push(ElementFlags.Rest);                 }             }             else {                 const contextualType = isTupleType(restType) ?                     getContextualTypeForElementExpression(restType, i - index, argCount - index) || unknownType :                     getIndexedAccessType(restType, getNumberLiteralType(i - index), AccessFlags.Contextual);                 const argType = checkExpressionWithContextualType(arg, contextualType, context, checkMode);                 const hasPrimitiveContextualType = inConstContext || maybeTypeOfKind(contextualType, TypeFlags.Primitive | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping);                 types.push(hasPrimitiveContextualType ? getRegularTypeOfLiteralType(argType) : getWidenedLiteralType(argType));                 flags.push(ElementFlags.Required);             }             if (arg.kind === SyntaxKind.SyntheticExpression && (arg as SyntheticExpression).tupleNameSource) {                 names.push((arg as SyntheticExpression).tupleNameSource!);             }             else {                 names.push(undefined);             }         } */
         createTupleType(types, flags, /* TODO(BinaryExpression): inConstContext && !someType(restType, isMutableArrayLikeType) */ TODO, names)
    }
    checkTypeArguments := func(signature Signature, typeArgumentNodes []TypeNode, reportErrors bool, headMessage DiagnosticMessage) /* TODO(ArrayType): Type[] */ any {
        isJavascript := isInJSFile(/* TODO(PropertyAccessExpression): signature.declaration */ TODO)
        typeParameters := /* TODO(NonNullExpression): signature.typeParameters! */ TODO
        typeArgumentTypes := fillMissingTypeArguments(map_(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript)
        var mapper *TypeMapper
        /* TODO(ForStatement): for (let i = 0; i < typeArgumentNodes.length; i++) {             Debug.assert(typeParameters[i] !== undefined, "Should not call checkTypeArguments with too many type arguments");             const constraint = getConstraintOfTypeParameter(typeParameters[i]);             if (constraint) {                 const errorInfo = reportErrors && headMessage ? (() => chainDiagnosticMessages(/*details* / undefined, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)) : undefined;                 const typeArgumentHeadMessage = headMessage || Diagnostics.Type_0_does_not_satisfy_the_constraint_1;                 if (!mapper) {                     mapper = createTypeMapper(typeParameters, typeArgumentTypes);                 }                 const typeArgument = typeArgumentTypes[i];                 if (                     !checkTypeAssignableTo(                         typeArgument,                         getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument),                         reportErrors ? typeArgumentNodes[i] : undefined,                         typeArgumentHeadMessage,                         errorInfo,                     )                 ) {                     return undefined;                 }             }         } */
         typeArgumentTypes
    }
    getJsxReferenceKind := func(node JsxOpeningLikeElement) JsxReferenceKind {
        if isJsxIntrinsicTagName(/* TODO(PropertyAccessExpression): node.tagName */ TODO) {
             /* TODO(PropertyAccessExpression): JsxReferenceKind.Mixed */ TODO
        }
        tagType := getApparentType(checkExpression(/* TODO(PropertyAccessExpression): node.tagName */ TODO))
        if length(getSignaturesOfType(tagType, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO)) {
             /* TODO(PropertyAccessExpression): JsxReferenceKind.Component */ TODO
        }
        if length(getSignaturesOfType(tagType, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)) {
             /* TODO(PropertyAccessExpression): JsxReferenceKind.Function */ TODO
        }
         /* TODO(PropertyAccessExpression): JsxReferenceKind.Mixed */ TODO
    }
    checkApplicableSignatureForJsxOpeningLikeElement := func(node JsxOpeningLikeElement, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ TODO) /* TODO(undefined): boolean */ TODO {
        paramType := getEffectiveFirstArgumentForJsxSignature(signature, node)
        attributesType := checkExpressionWithContextualType(/* TODO(PropertyAccessExpression): node.attributes */ TODO, paramType, undefined, checkMode)
        checkAttributesType := /* TODO(ConditionalExpression): checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(attributesType) : attributesType */ TODO
         /* TODO(BinaryExpression): checkTagNameDoesNotExpectTooManyArguments() && checkTypeRelatedToAndOptionallyElaborate(             checkAttributesType,             paramType,             relation,             reportErrors ? node.tagName : undefined,             node.attributes,             /*headMessage* / undefined,             containingMessageChain,             errorOutputContainer,         ) */ TODO
        checkTagNameDoesNotExpectTooManyArguments := func() bool {
            if getJsxNamespaceContainerForImplicitImport(node) {
                 /* TODO(TrueKeyword): true */ TODO
            }
            tagType := /* TODO(ConditionalExpression): (isJsxOpeningElement(node) || isJsxSelfClosingElement(node)) && !(isJsxIntrinsicTagName(node.tagName) || isJsxNamespacedName(node.tagName)) ? checkExpression(node.tagName) : undefined */ TODO
            if /* TODO(PrefixUnaryExpression): !tagType */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            tagCallSignatures := getSignaturesOfType(tagType, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
            if /* TODO(PrefixUnaryExpression): !length(tagCallSignatures) */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            factory := getJsxFactoryEntity(node)
            if /* TODO(PrefixUnaryExpression): !factory */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            factorySymbol := resolveEntityName(factory, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO, /* TODO(TrueKeyword): true */ TODO, /* TODO(FalseKeyword): false */ TODO, node)
            if /* TODO(PrefixUnaryExpression): !factorySymbol */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            factoryType := getTypeOfSymbol(factorySymbol)
            callSignatures := getSignaturesOfType(factoryType, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
            if /* TODO(PrefixUnaryExpression): !length(callSignatures) */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            hasFirstParamSignatures := /* TODO(FalseKeyword): false */ TODO
            maxParamCount := 0
            /* TODO(ForOfStatement): for (const sig of callSignatures) {                 const firstparam = getTypeAtPosition(sig, 0);                 const signaturesOfParam = getSignaturesOfType(firstparam, SignatureKind.Call);                 if (!length(signaturesOfParam)) continue;                 for (const paramSig of signaturesOfParam) {                     hasFirstParamSignatures = true;                     if (hasEffectiveRestParameter(paramSig)) {                         return true; // some signature has a rest param, so function components can have an arbitrary number of arguments                     }                     const paramCount = getParameterCount(paramSig);                     if (paramCount > maxParamCount) {                         maxParamCount = paramCount;                     }                 }             } */
            if /* TODO(PrefixUnaryExpression): !hasFirstParamSignatures */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            absoluteMinArgCount := Infinity
            /* TODO(ForOfStatement): for (const tagSig of tagCallSignatures) {                 const tagRequiredArgCount = getMinArgumentCount(tagSig);                 if (tagRequiredArgCount < absoluteMinArgCount) {                     absoluteMinArgCount = tagRequiredArgCount;                 }             } */
            if /* TODO(BinaryExpression): absoluteMinArgCount <= maxParamCount */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            if reportErrors {
                diag := createDiagnosticForNode(/* TODO(PropertyAccessExpression): node.tagName */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3 */ TODO, entityNameToString(/* TODO(PropertyAccessExpression): node.tagName */ TODO), absoluteMinArgCount, entityNameToString(factory), maxParamCount)
                tagNameDeclaration := /* TODO(PropertyAccessExpression): getSymbolAtLocation(node.tagName)?.valueDeclaration */ TODO
                if tagNameDeclaration {
                    /* TODO(ExpressionStatement): addRelatedInfo(diag, createDiagnosticForNode(tagNameDeclaration, Diagnostics._0_is_declared_here, entityNameToString(node.tagName))); */
                }
                if /* TODO(BinaryExpression): errorOutputContainer && errorOutputContainer.skipLogging */ TODO {
                    /* TODO(ExpressionStatement): (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag); */
                }
                if /* TODO(PrefixUnaryExpression): !errorOutputContainer.skipLogging */ TODO {
                    /* TODO(ExpressionStatement): diagnostics.add(diag); */
                }
            }
             /* TODO(FalseKeyword): false */ TODO
        }
    }
    getEffectiveCheckNode := func(argument Expression) Expression {
        /* TODO(ExpressionStatement): argument = skipParentheses(argument); */
         /* TODO(ConditionalExpression): isSatisfiesExpression(argument) ? skipParentheses(argument.expression) : argument */ TODO
    }
    getSignatureApplicabilityError := func(node CallLikeExpression, args []Expression, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, inferenceContext *InferenceContext) /* TODO(TypeOperator): readonly Diagnostic[] */ any {
        var errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ TODO = /* TODO(ObjectLiteralExpression): { errors: undefined, skipLogging: true } */ TODO
        if isJsxOpeningLikeElement(node) {
            if /* TODO(PrefixUnaryExpression): !checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors, containingMessageChain, errorOutputContainer) */ TODO {
                /* TODO(ExpressionStatement): Debug.assert(!reportErrors || !!errorOutputContainer.errors, "jsx should have errors when reporting errors"); */
                 /* TODO(BinaryExpression): errorOutputContainer.errors || emptyArray */ TODO
            }
             undefined
        }
        thisType := getThisTypeOfSignature(signature)
        if /* TODO(BinaryExpression): thisType && thisType !== voidType && !(isNewExpression(node) || isCallExpression(node) && isSuperProperty(node.expression)) */ TODO {
            thisArgumentNode := getThisArgumentOfCall(node)
            thisArgumentType := getThisArgumentType(thisArgumentNode)
            errorNode := /* TODO(ConditionalExpression): reportErrors ? (thisArgumentNode || node) : undefined */ TODO
            headMessage := /* TODO(PropertyAccessExpression): Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1 */ TODO
            if /* TODO(PrefixUnaryExpression): !checkTypeRelatedTo(thisArgumentType, thisType, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer) */ TODO {
                /* TODO(ExpressionStatement): Debug.assert(!reportErrors || !!errorOutputContainer.errors, "this parameter should have errors when reporting errors"); */
                 /* TODO(BinaryExpression): errorOutputContainer.errors || emptyArray */ TODO
            }
        }
        headMessage := /* TODO(PropertyAccessExpression): Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1 */ TODO
        restType := getNonArrayRestType(signature)
        argCount := /* TODO(ConditionalExpression): restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length */ TODO
        /* TODO(ForStatement): for (let i = 0; i < argCount; i++) {             const arg = args[i];             if (arg.kind !== SyntaxKind.OmittedExpression) {                 const paramType = getTypeAtPosition(signature, i);                 const argType = checkExpressionWithContextualType(arg, paramType, /*inferenceContext* / undefined, checkMode);                 // If one or more arguments are still excluded (as indicated by CheckMode.SkipContextSensitive),                 // we obtain the regular type of any object literal arguments because we may not have inferred complete                 // parameter types yet and therefore excess property checks may yield false positives (see #17041).                 const regularArgType = checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(argType) : argType;                 // If this was inferred under a given inference context, we may need to instantiate the expression type to finish resolving                 // the type variables in the expression.                 const checkArgType = inferenceContext ? instantiateType(regularArgType, inferenceContext.nonFixingMapper) : regularArgType;                 const effectiveCheckArgumentNode = getEffectiveCheckNode(arg);                 if (!checkTypeRelatedToAndOptionallyElaborate(checkArgType, paramType, relation, reportErrors ? effectiveCheckArgumentNode : undefined, effectiveCheckArgumentNode, headMessage, containingMessageChain, errorOutputContainer)) {                     Debug.assert(!reportErrors || !!errorOutputContainer.errors, "parameter should have errors when reporting errors");                     maybeAddMissingAwaitInfo(arg, checkArgType, paramType);                     return errorOutputContainer.errors || emptyArray;                 }             }         } */
        if restType {
            spreadType := getSpreadArgumentType(args, argCount, /* TODO(PropertyAccessExpression): args.length */ TODO, restType, undefined, checkMode)
            restArgCount := /* TODO(BinaryExpression): args.length - argCount */ TODO
            errorNode := /* TODO(ConditionalExpression): !reportErrors ? undefined :                 restArgCount === 0 ? node :                 restArgCount === 1 ? getEffectiveCheckNode(args[argCount]) :                 setTextRangePosEnd(createSyntheticExpression(node, spreadType), args[argCount].pos, args[args.length - 1].end) */ TODO
            if /* TODO(PrefixUnaryExpression): !checkTypeRelatedTo(spreadType, restType, relation, errorNode, headMessage, /*containingMessageChain* / undefined, errorOutputContainer) */ TODO {
                /* TODO(ExpressionStatement): Debug.assert(!reportErrors || !!errorOutputContainer.errors, "rest parameter should have errors when reporting errors"); */
                /* TODO(ExpressionStatement): maybeAddMissingAwaitInfo(errorNode, spreadType, restType); */
                 /* TODO(BinaryExpression): errorOutputContainer.errors || emptyArray */ TODO
            }
        }
         undefined
        maybeAddMissingAwaitInfo := func(errorNode Node, source Type, target Type) {
            if /* TODO(BinaryExpression): errorNode && reportErrors && errorOutputContainer.errors && errorOutputContainer.errors.length */ TODO {
                if getAwaitedTypeOfPromise(target) {

                }
                awaitedTypeOfSource := getAwaitedTypeOfPromise(source)
                if /* TODO(BinaryExpression): awaitedTypeOfSource && isTypeRelatedTo(awaitedTypeOfSource, target, relation) */ TODO {
                    /* TODO(ExpressionStatement): addRelatedInfo(errorOutputContainer.errors[0], createDiagnosticForNode(errorNode, Diagnostics.Did_you_forget_to_use_await)); */
                }
            }
        }
    }
    getThisArgumentOfCall := func(node CallLikeExpression) *Expression {
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.BinaryExpression */ TODO {
             /* TODO(PropertyAccessExpression): node.right */ TODO
        }
        expression := /* TODO(ConditionalExpression): node.kind === SyntaxKind.CallExpression ? node.expression :             node.kind === SyntaxKind.TaggedTemplateExpression ? node.tag :             node.kind === SyntaxKind.Decorator && !legacyDecorators ? node.expression :             undefined */ TODO
        if expression {
            callee := skipOuterExpressions(expression)
            if isAccessExpression(callee) {
                 /* TODO(PropertyAccessExpression): callee.expression */ TODO
            }
        }
    }
    createSyntheticExpression := func(parent Node, type_ Type, isSpread bool, tupleNameSource /* TODO(UnionType): ParameterDeclaration | NamedTupleMember */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SyntheticExpression */ TODO {
        result := /* TODO(PropertyAccessExpression): parseNodeFactory.createSyntheticExpression */ TODO(type_, isSpread, tupleNameSource)
        /* TODO(ExpressionStatement): setTextRangeWorker(result, parent); */
        /* TODO(ExpressionStatement): setParent(result, parent); */
         result
    }
    getEffectiveCallArguments := func(node CallLikeExpression) []Expression {
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.TaggedTemplateExpression */ TODO {
            template := /* TODO(PropertyAccessExpression): node.template */ TODO
            var args []Expression = /* TODO(ArrayLiteralExpression): [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())] */ TODO
            if /* TODO(BinaryExpression): template.kind === SyntaxKind.TemplateExpression */ TODO {
                /* TODO(ExpressionStatement): forEach(template.templateSpans, span => {                     args.push(span.expression);                 }); */
            }
             args
        }
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.Decorator */ TODO {
             getEffectiveDecoratorArguments(node)
        }
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.BinaryExpression */ TODO {
             /* TODO(ArrayLiteralExpression): [node.left] */ TODO
        }
        if isJsxOpeningLikeElement(node) {
             /* TODO(ConditionalExpression): node.attributes.properties.length > 0 || (isJsxOpeningElement(node) && node.parent.children.length > 0) ? [node.attributes] : emptyArray */ TODO
        }
        args := /* TODO(BinaryExpression): node.arguments || emptyArray */ TODO
        spreadIndex := getSpreadArgumentIndex(args)
        if /* TODO(BinaryExpression): spreadIndex >= 0 */ TODO {
            effectiveArgs := /* TODO(PropertyAccessExpression): args.slice */ TODO(0, spreadIndex)
            /* TODO(ForStatement): for (let i = spreadIndex; i < args.length; i++) {                 const arg = args[i];                 // We can call checkExpressionCached because spread expressions never have a contextual type.                 const spreadType = arg.kind === SyntaxKind.SpreadElement && (flowLoopCount ? checkExpression((arg as SpreadElement).expression) : checkExpressionCached((arg as SpreadElement).expression));                 if (spreadType && isTupleType(spreadType)) {                     forEach(getElementTypes(spreadType), (t, i) => {                         const flags = spreadType.target.elementFlags[i];                         const syntheticArg = createSyntheticExpression(arg, flags & ElementFlags.Rest ? createArrayType(t) : t, !!(flags & ElementFlags.Variable), spreadType.target.labeledElementDeclarations?.[i]);                         effectiveArgs.push(syntheticArg);                     });                 }                 else {                     effectiveArgs.push(arg);                 }             } */
             effectiveArgs
        }
         args
    }
    getEffectiveDecoratorArguments := func(node Decorator) []Expression {
        expr := /* TODO(PropertyAccessExpression): node.expression */ TODO
        signature := getDecoratorCallSignature(node)
        if signature {
            var args []Expression = /* TODO(ArrayLiteralExpression): [] */ TODO
            /* TODO(ForOfStatement): for (const param of signature.parameters) {                 const type = getTypeOfSymbol(param);                 args.push(createSyntheticExpression(expr, type));             } */
             args
        }
         /* TODO(PropertyAccessExpression): Debug.fail */ TODO()
    }
    getDecoratorArgumentCount := func(node Decorator, signature Signature) /* TODO(undefined): number */ TODO {
         /* TODO(ConditionalExpression): compilerOptions.experimentalDecorators ?             getLegacyDecoratorArgumentCount(node, signature) :             // Allow the runtime to oversupply arguments to an ES decorator as long as there's at least one parameter.             Math.min(Math.max(getParameterCount(signature), 1), 2) */ TODO
    }
    getLegacyDecoratorArgumentCount := func(node Decorator, signature Signature) /* TODO(undefined): 1 | 2 | 3 */ TODO {
        /* TODO(SwitchStatement): switch (node.parent.kind) {             case SyntaxKind.ClassDeclaration:             case SyntaxKind.ClassExpression:                 return 1;             case SyntaxKind.PropertyDeclaration:                 return hasAccessorModifier(node.parent) ? 3 : 2;             case SyntaxKind.MethodDeclaration:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 // For decorators with only two parameters we supply only two arguments                 return signature.parameters.length <= 2 ? 2 : 3;             case SyntaxKind.Parameter:                 return 3;             default:                 return Debug.fail();         } */
    }
    getDiagnosticSpanForCallNode := func(node CallExpression) /* TODO(undefined): { start: number; length: number; sourceFile: import("/home/jabaile/work/TypeScript/src/compiler/types").SourceFile; } */ TODO {
        sourceFile := getSourceFileOfNode(node)
        TODO_IDENTIFIER := getErrorSpanForNode(sourceFile, /* TODO(ConditionalExpression): isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression */ TODO)
         /* TODO(ObjectLiteralExpression): { start, length, sourceFile } */ TODO
    }
    getDiagnosticForCallNode := func(node CallLikeExpression, message /* TODO(UnionType): DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) DiagnosticWithLocation {
        if isCallExpression(node) {
            TODO_IDENTIFIER := getDiagnosticSpanForCallNode(node)
            if /* TODO(BinaryExpression): "message" in message */ TODO {
                 createFileDiagnostic(sourceFile, start, length, message, /* TODO(SpreadElement): ...args */ TODO)
            }
             createDiagnosticForFileFromMessageChain(sourceFile, message)
        } else {
            if /* TODO(BinaryExpression): "message" in message */ TODO {
                 createDiagnosticForNode(node, message, /* TODO(SpreadElement): ...args */ TODO)
            }
             createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), node, message)
        }
    }
    getErrorNodeForCallNode := func(callLike CallLikeExpression) Node {
        if isCallOrNewExpression(callLike) {
             /* TODO(ConditionalExpression): isPropertyAccessExpression(callLike.expression) ? callLike.expression.name : callLike.expression */ TODO
        }
        if isTaggedTemplateExpression(callLike) {
             /* TODO(ConditionalExpression): isPropertyAccessExpression(callLike.tag) ? callLike.tag.name : callLike.tag */ TODO
        }
        if isJsxOpeningLikeElement(callLike) {
             /* TODO(PropertyAccessExpression): callLike.tagName */ TODO
        }
         callLike
    }
    isPromiseResolveArityError := func(node CallLikeExpression) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): !isCallExpression(node) || !isIdentifier(node.expression) */ TODO {
            /* TODO(FalseKeyword): false */
        }
        symbol := resolveName(/* TODO(PropertyAccessExpression): node.expression */ TODO, /* TODO(PropertyAccessExpression): node.expression.escapedText */ TODO, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO, undefined, /* TODO(FalseKeyword): false */ TODO)
        decl := /* TODO(PropertyAccessExpression): symbol?.valueDeclaration */ TODO
        if /* TODO(BinaryExpression): !decl || !isParameter(decl) || !isFunctionExpressionOrArrowFunction(decl.parent) || !isNewExpression(decl.parent.parent) || !isIdentifier(decl.parent.parent.expression) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        globalPromiseSymbol := getGlobalPromiseConstructorSymbol(/* TODO(FalseKeyword): false */ TODO)
        if /* TODO(PrefixUnaryExpression): !globalPromiseSymbol */ TODO {
            /* TODO(FalseKeyword): false */
        }
        constructorSymbol := getSymbolAtLocation(/* TODO(PropertyAccessExpression): decl.parent.parent.expression */ TODO, /* TODO(TrueKeyword): true */ TODO)
         /* TODO(BinaryExpression): constructorSymbol === globalPromiseSymbol */ TODO
    }
    getArgumentArityError := func(node CallLikeExpression, signatures []Signature, args []Expression, headMessage DiagnosticMessage) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic */ TODO {
        spreadIndex := getSpreadArgumentIndex(args)
        if /* TODO(BinaryExpression): spreadIndex > -1 */ TODO {
             createDiagnosticForNode(/* TODO(ElementAccessExpression): args[spreadIndex] */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter */ TODO)
        }
        min := /* TODO(PropertyAccessExpression): Number.POSITIVE_INFINITY */ TODO
        max := /* TODO(PropertyAccessExpression): Number.NEGATIVE_INFINITY */ TODO
        maxBelow := /* TODO(PropertyAccessExpression): Number.NEGATIVE_INFINITY */ TODO
        minAbove := /* TODO(PropertyAccessExpression): Number.POSITIVE_INFINITY */ TODO
        var closestSignature *Signature
        /* TODO(ForOfStatement): for (const sig of signatures) {             const minParameter = getMinArgumentCount(sig);             const maxParameter = getParameterCount(sig);             // smallest/largest parameter counts             if (minParameter < min) {                 min = minParameter;                 closestSignature = sig;             }             max = Math.max(max, maxParameter);             // shortest parameter count *longer than the call* /longest parameter count *shorter than the call*             if (minParameter < args.length && minParameter > maxBelow) maxBelow = minParameter;             if (args.length < maxParameter && maxParameter < minAbove) minAbove = maxParameter;         } */
        hasRestParameter := some(signatures, hasEffectiveRestParameter)
        parameterRange := /* TODO(ConditionalExpression): hasRestParameter ? min             : min < max ? min + "-" + max             : min */ TODO
        isVoidPromiseError := /* TODO(BinaryExpression): !hasRestParameter && parameterRange === 1 && args.length === 0 && isPromiseResolveArityError(node) */ TODO
        if /* TODO(BinaryExpression): isVoidPromiseError && isInJSFile(node) */ TODO {
             getDiagnosticForCallNode(node, /* TODO(PropertyAccessExpression): Diagnostics.Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments */ TODO)
        }
        error := /* TODO(ConditionalExpression): isDecorator(node) ?             hasRestParameter ? Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0 :                 Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0 :             hasRestParameter ? Diagnostics.Expected_at_least_0_arguments_but_got_1 :             isVoidPromiseError ? Diagnostics.Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise :             Diagnostics.Expected_0_arguments_but_got_1 */ TODO
        if /* TODO(BinaryExpression): min < args.length && args.length < max */ TODO {
            if headMessage {
                chain := chainDiagnosticMessages(undefined, /* TODO(PropertyAccessExpression): Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments */ TODO, /* TODO(PropertyAccessExpression): args.length */ TODO, maxBelow, minAbove)
                /* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
                 getDiagnosticForCallNode(node, chain)
            }
             getDiagnosticForCallNode(node, /* TODO(PropertyAccessExpression): Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments */ TODO, /* TODO(PropertyAccessExpression): args.length */ TODO, maxBelow, minAbove)
        } else if /* TODO(BinaryExpression): args.length < min */ TODO {
            var diagnostic Diagnostic
            if headMessage {
                chain := chainDiagnosticMessages(undefined, error, parameterRange, /* TODO(PropertyAccessExpression): args.length */ TODO)
                /* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
                /* TODO(ExpressionStatement): diagnostic = getDiagnosticForCallNode(node, chain); */
            } else {
                /* TODO(ExpressionStatement): diagnostic = getDiagnosticForCallNode(node, error, parameterRange, args.length); */
            }
            parameter := /* TODO(ElementAccessExpression): closestSignature?.declaration?.parameters[closestSignature.thisParameter ? args.length + 1 : args.length] */ TODO
            if parameter {
                var messageAndArgs DiagnosticAndArguments = /* TODO(ConditionalExpression): isBindingPattern(parameter.name) ? [Diagnostics.An_argument_matching_this_binding_pattern_was_not_provided]                     : isRestParameter(parameter) ? [Diagnostics.Arguments_for_the_rest_parameter_0_were_not_provided, idText(getFirstIdentifier(parameter.name))]                     : [Diagnostics.An_argument_for_0_was_not_provided, !parameter.name ? args.length : idText(getFirstIdentifier(parameter.name))] */ TODO
                parameterError := createDiagnosticForNode(parameter, /* TODO(SpreadElement): ...messageAndArgs */ TODO)
                 addRelatedInfo(diagnostic, parameterError)
            }
             diagnostic
        } else {
            errorSpan := /* TODO(PropertyAccessExpression): factory.createNodeArray */ TODO(/* TODO(PropertyAccessExpression): args.slice */ TODO(max))
            pos := /* TODO(PropertyAccessExpression): first(errorSpan).pos */ TODO
            end := /* TODO(PropertyAccessExpression): last(errorSpan).end */ TODO
            if /* TODO(BinaryExpression): end === pos */ TODO {
                /* TODO(ExpressionStatement): end++; */
            }
            /* TODO(ExpressionStatement): setTextRangePosEnd(errorSpan, pos, end); */
            if headMessage {
                chain := chainDiagnosticMessages(undefined, error, parameterRange, /* TODO(PropertyAccessExpression): args.length */ TODO)
                /* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
                 createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), errorSpan, chain)
            }
             createDiagnosticForNodeArray(getSourceFileOfNode(node), errorSpan, error, parameterRange, /* TODO(PropertyAccessExpression): args.length */ TODO)
        }
    }
    getTypeArgumentArityError := func(node Node, signatures []Signature, typeArguments NodeArray[TypeNode], headMessage DiagnosticMessage) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
        argCount := /* TODO(PropertyAccessExpression): typeArguments.length */ TODO
        if /* TODO(BinaryExpression): signatures.length === 1 */ TODO {
            sig := /* TODO(ElementAccessExpression): signatures[0] */ TODO
            min := getMinTypeArgumentCount(/* TODO(PropertyAccessExpression): sig.typeParameters */ TODO)
            max := length(/* TODO(PropertyAccessExpression): sig.typeParameters */ TODO)
            if headMessage {
                chain := chainDiagnosticMessages(undefined, /* TODO(PropertyAccessExpression): Diagnostics.Expected_0_type_arguments_but_got_1 */ TODO, /* TODO(ConditionalExpression): min < max ? min + "-" + max : min */ TODO, argCount)
                /* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
                 createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
            }
             createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, /* TODO(PropertyAccessExpression): Diagnostics.Expected_0_type_arguments_but_got_1 */ TODO, /* TODO(ConditionalExpression): min < max ? min + "-" + max : min */ TODO, argCount)
        }
        belowArgCount := /* TODO(PrefixUnaryExpression): -Infinity */ TODO
        aboveArgCount := Infinity
        /* TODO(ForOfStatement): for (const sig of signatures) {             const min = getMinTypeArgumentCount(sig.typeParameters);             const max = length(sig.typeParameters);             if (min > argCount) {                 aboveArgCount = Math.min(aboveArgCount, min);             }             else if (max < argCount) {                 belowArgCount = Math.max(belowArgCount, max);             }         } */
        if /* TODO(BinaryExpression): belowArgCount !== -Infinity && aboveArgCount !== Infinity */ TODO {
            if headMessage {
                chain := chainDiagnosticMessages(undefined, /* TODO(PropertyAccessExpression): Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments */ TODO, argCount, belowArgCount, aboveArgCount)
                /* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
                 createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
            }
             createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, /* TODO(PropertyAccessExpression): Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments */ TODO, argCount, belowArgCount, aboveArgCount)
        }
        if headMessage {
            chain := chainDiagnosticMessages(undefined, /* TODO(PropertyAccessExpression): Diagnostics.Expected_0_type_arguments_but_got_1 */ TODO, /* TODO(ConditionalExpression): belowArgCount === -Infinity ? aboveArgCount : belowArgCount */ TODO, argCount)
            /* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
             createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
        }
         createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, /* TODO(PropertyAccessExpression): Diagnostics.Expected_0_type_arguments_but_got_1 */ TODO, /* TODO(ConditionalExpression): belowArgCount === -Infinity ? aboveArgCount : belowArgCount */ TODO, argCount)
    }
    resolveCall := func(node CallLikeExpression, signatures []Signature, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode, callChainFlags SignatureFlags, headMessage DiagnosticMessage) Signature {
        isTaggedTemplate := /* TODO(BinaryExpression): node.kind === SyntaxKind.TaggedTemplateExpression */ TODO
        isDecorator := /* TODO(BinaryExpression): node.kind === SyntaxKind.Decorator */ TODO
        isJsxOpeningOrSelfClosingElement := isJsxOpeningLikeElement(node)
        isInstanceof := /* TODO(BinaryExpression): node.kind === SyntaxKind.BinaryExpression */ TODO
        reportErrors := /* TODO(BinaryExpression): !isInferencePartiallyBlocked && !candidatesOutArray */ TODO
        var typeArguments *NodeArray[TypeNode]
        if /* TODO(BinaryExpression): !isDecorator && !isInstanceof && !isSuperCall(node) */ TODO {
            /* TODO(ExpressionStatement): typeArguments = (node as CallExpression).typeArguments; */
            if /* TODO(BinaryExpression): isTaggedTemplate || isJsxOpeningOrSelfClosingElement || (node as CallExpression).expression.kind !== SyntaxKind.SuperKeyword */ TODO {
                /* TODO(ExpressionStatement): forEach(typeArguments, checkSourceElement); */
            }
        }
        candidates := /* TODO(BinaryExpression): candidatesOutArray || [] */ TODO
        /* TODO(ExpressionStatement): reorderCandidates(signatures, candidates, callChainFlags); */
        /* TODO(ExpressionStatement): Debug.assert(candidates.length, "Revert #54442 and add a testcase with whatever triggered this"); */
        args := getEffectiveCallArguments(node)
        isSingleNonGenericCandidate := /* TODO(BinaryExpression): candidates.length === 1 && !candidates[0].typeParameters */ TODO
        argCheckMode := /* TODO(ConditionalExpression): !isDecorator && !isSingleNonGenericCandidate && some(args, isContextSensitive) ? CheckMode.SkipContextSensitive : CheckMode.Normal */ TODO
        var candidatesForArgumentError /* TODO(ArrayType): Signature[] */ any
        var candidateForArgumentArityError *Signature
        var candidateForTypeArgumentError *Signature
        var result *Signature
        signatureHelpTrailingComma := /* TODO(BinaryExpression): !!(checkMode & CheckMode.IsForSignatureHelp) && node.kind === SyntaxKind.CallExpression && node.arguments.hasTrailingComma */ TODO
        if /* TODO(BinaryExpression): candidates.length > 1 */ TODO {
            /* TODO(ExpressionStatement): result = chooseOverload(candidates, subtypeRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma); */
        }
        if /* TODO(PrefixUnaryExpression): !result */ TODO {
            /* TODO(ExpressionStatement): result = chooseOverload(candidates, assignableRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma); */
        }
        if result {
             result
        }
        /* TODO(ExpressionStatement): result = getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray, checkMode); */
        /* TODO(ExpressionStatement): getNodeLinks(node).resolvedSignature = result; */
        if reportErrors {
            if /* TODO(BinaryExpression): !headMessage && isInstanceof */ TODO {
                /* TODO(ExpressionStatement): headMessage = Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_hand_side_s_Symbol_hasInstance_method; */
            }
            if candidatesForArgumentError {
                if /* TODO(BinaryExpression): candidatesForArgumentError.length === 1 || candidatesForArgumentError.length > 3 */ TODO {
                    last := /* TODO(ElementAccessExpression): candidatesForArgumentError[candidatesForArgumentError.length - 1] */ TODO
                    var chain *DiagnosticMessageChain
                    if /* TODO(BinaryExpression): candidatesForArgumentError.length > 3 */ TODO {
                        /* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, Diagnostics.The_last_overload_gave_the_following_error); */
                        /* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, Diagnostics.No_overload_matches_this_call); */
                    }
                    if headMessage {
                        /* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
                    }
                    diags := getSignatureApplicabilityError(node, args, last, assignableRelation, /* TODO(PropertyAccessExpression): CheckMode.Normal */ TODO, /* TODO(TrueKeyword): true */ TODO, /* TODO(ArrowFunction): () => chain */ TODO, undefined)
                    if diags {
                        /* TODO(ForOfStatement): for (const d of diags) {                             if (last.declaration && candidatesForArgumentError.length > 3) {                                 addRelatedInfo(d, createDiagnosticForNode(last.declaration, Diagnostics.The_last_overload_is_declared_here));                             }                             addImplementationSuccessElaboration(last, d);                             diagnostics.add(d);                         } */
                    } else {
                        /* TODO(ExpressionStatement): Debug.fail("No error for last overload signature"); */
                    }
                } else {
                    var allDiagnostics [][]DiagnosticRelatedInformation = /* TODO(ArrayLiteralExpression): [] */ TODO
                    max := 0
                    min := /* TODO(PropertyAccessExpression): Number.MAX_VALUE */ TODO
                    minIndex := 0
                    i := 0
                    /* TODO(ForOfStatement): for (const c of candidatesForArgumentError) {                         const chain = () => chainDiagnosticMessages(/*details* / undefined, Diagnostics.Overload_0_of_1_2_gave_the_following_error, i + 1, candidates.length, signatureToString(c));                         const diags = getSignatureApplicabilityError(node, args, c, assignableRelation, CheckMode.Normal, /*reportErrors* / true, chain, /*inferenceContext* / undefined);                         if (diags) {                             if (diags.length <= min) {                                 min = diags.length;                                 minIndex = i;                             }                             max = Math.max(max, diags.length);                             allDiagnostics.push(diags);                         }                         else {                             Debug.fail("No error for 3 or fewer overload signatures");                         }                         i++;                     } */
                    diags := /* TODO(ConditionalExpression): max > 1 ? allDiagnostics[minIndex] : flatten(allDiagnostics) */ TODO
                    /* TODO(ExpressionStatement): Debug.assert(diags.length > 0, "No errors reported for 3 or fewer overload signatures"); */
                    chain := chainDiagnosticMessages(map_(diags, createDiagnosticMessageChainFromDiagnostic), /* TODO(PropertyAccessExpression): Diagnostics.No_overload_matches_this_call */ TODO)
                    if headMessage {
                        /* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
                    }
                    related := /* TODO(ArrayLiteralExpression): [...flatMap(diags, d => (d as Diagnostic).relatedInformation) as DiagnosticRelatedInformation[]] */ TODO
                    var diag Diagnostic
                    if every(diags, /* TODO(ArrowFunction): d => d.start === diags[0].start && d.length === diags[0].length && d.file === diags[0].file */ TODO) {
                        TODO_IDENTIFIER := /* TODO(ElementAccessExpression): diags[0] */ TODO
                        /* TODO(ExpressionStatement): diag = { file, start, length, code: chain.code, category: chain.category, messageText: chain, relatedInformation: related }; */
                    } else {
                        /* TODO(ExpressionStatement): diag = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), getErrorNodeForCallNode(node), chain, related); */
                    }
                    /* TODO(ExpressionStatement): addImplementationSuccessElaboration(candidatesForArgumentError[0], diag); */
                    /* TODO(ExpressionStatement): diagnostics.add(diag); */
                }
            } else if candidateForArgumentArityError {
                /* TODO(ExpressionStatement): diagnostics.add(getArgumentArityError(node, [candidateForArgumentArityError], args, headMessage)); */
            } else if candidateForTypeArgumentError {
                /* TODO(ExpressionStatement): checkTypeArguments(candidateForTypeArgumentError, (node as CallExpression | TaggedTemplateExpression | JsxOpeningLikeElement).typeArguments!, /*reportErrors* / true, headMessage); */
            } else {
                signaturesWithCorrectTypeArgumentArity := filter(signatures, /* TODO(ArrowFunction): s => hasCorrectTypeArgumentArity(s, typeArguments) */ TODO)
                if /* TODO(BinaryExpression): signaturesWithCorrectTypeArgumentArity.length === 0 */ TODO {
                    /* TODO(ExpressionStatement): diagnostics.add(getTypeArgumentArityError(node, signatures, typeArguments!, headMessage)); */
                } else {
                    /* TODO(ExpressionStatement): diagnostics.add(getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args, headMessage)); */
                }
            }
        }
         result
        addImplementationSuccessElaboration := func(failed Signature, diagnostic Diagnostic) {
            oldCandidatesForArgumentError := candidatesForArgumentError
            oldCandidateForArgumentArityError := candidateForArgumentArityError
            oldCandidateForTypeArgumentError := candidateForTypeArgumentError
            failedSignatureDeclarations := /* TODO(BinaryExpression): failed.declaration?.symbol?.declarations || emptyArray */ TODO
            isOverload := /* TODO(BinaryExpression): failedSignatureDeclarations.length > 1 */ TODO
            implDecl := /* TODO(ConditionalExpression): isOverload ? find(failedSignatureDeclarations, d => isFunctionLikeDeclaration(d) && nodeIsPresent(d.body)) : undefined */ TODO
            if implDecl {
                candidate := getSignatureFromDeclaration(implDecl /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */)
                isSingleNonGenericCandidate := /* TODO(PrefixUnaryExpression): !candidate.typeParameters */ TODO
                if chooseOverload(/* TODO(ArrayLiteralExpression): [candidate] */ TODO, assignableRelation, isSingleNonGenericCandidate) {
                    /* TODO(ExpressionStatement): addRelatedInfo(diagnostic, createDiagnosticForNode(implDecl, Diagnostics.The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible)); */
                }
            }
            /* TODO(ExpressionStatement): candidatesForArgumentError = oldCandidatesForArgumentError; */
            /* TODO(ExpressionStatement): candidateForArgumentArityError = oldCandidateForArgumentArityError; */
            /* TODO(ExpressionStatement): candidateForTypeArgumentError = oldCandidateForTypeArgumentError; */
        }
        chooseOverload := func(candidates []Signature, relation Map[string, RelationComparisonResult], isSingleNonGenericCandidate bool, signatureHelpTrailingComma /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
            /* TODO(ExpressionStatement): candidatesForArgumentError = undefined; */
            /* TODO(ExpressionStatement): candidateForArgumentArityError = undefined; */
            /* TODO(ExpressionStatement): candidateForTypeArgumentError = undefined; */
            if isSingleNonGenericCandidate {
                candidate := /* TODO(ElementAccessExpression): candidates[0] */ TODO
                if /* TODO(BinaryExpression): some(typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma) */ TODO {
                     undefined
                }
                if getSignatureApplicabilityError(node, args, candidate, relation, /* TODO(PropertyAccessExpression): CheckMode.Normal */ TODO, /* TODO(FalseKeyword): false */ TODO, undefined, undefined) {
                    /* TODO(ExpressionStatement): candidatesForArgumentError = [candidate]; */
                     undefined
                }
                 candidate
            }
            /* TODO(ForStatement): for (let candidateIndex = 0; candidateIndex < candidates.length; candidateIndex++) {                 let candidate = candidates[candidateIndex];                 if (!hasCorrectTypeArgumentArity(candidate, typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) {                     continue;                 }                  let checkCandidate: Signature;                 let inferenceContext: InferenceContext | undefined;                  if (candidate.typeParameters) {                     // If we are *inside the body of candidate*, we need to create a clone of `candidate` with differing type parameter identities,                     // so our inference results for this call doesn't pollute expression types referencing the outer type parameter!                     const paramLocation = candidate.typeParameters[0].symbol.declarations?.[0]?.parent;                     const candidateParameterContext = paramLocation || (candidate.declaration && isConstructorDeclaration(candidate.declaration) ? candidate.declaration.parent : candidate.declaration);                     if (candidateParameterContext && findAncestor(node, a => a === candidateParameterContext)) {                         candidate = getImplementationSignature(candidate);                     }                     let typeArgumentTypes: readonly Type[] | undefined;                     if (some(typeArguments)) {                         typeArgumentTypes = checkTypeArguments(candidate, typeArguments, /*reportErrors* / false);                         if (!typeArgumentTypes) {                             candidateForTypeArgumentError = candidate;                             continue;                         }                     }                     else {                         inferenceContext = createInferenceContext(candidate.typeParameters!, candidate, /*flags* / isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None);                         // The resulting type arguments are instantiated with the inference context mapper, as the inferred types may still contain references to the inference context's                         //  type variables via contextual projection. These are kept generic until all inferences are locked in, so the dependencies expressed can pass constraint checks.                         typeArgumentTypes = instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode | CheckMode.SkipGenericFunctions, inferenceContext), inferenceContext.nonFixingMapper);                         argCheckMode |= inferenceContext.flags & InferenceFlags.SkippedGenericFunction ? CheckMode.SkipGenericFunctions : CheckMode.Normal;                     }                     checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters);                     // If the original signature has a generic rest type, instantiation may produce a                     // signature with different arity and we need to perform another arity check.                     if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {                         candidateForArgumentArityError = checkCandidate;                         continue;                     }                 }                 else {                     checkCandidate = candidate;                 }                 if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors* / false, /*containingMessageChain* / undefined, inferenceContext)) {                     // Give preference to error candidates that have no rest parameters (as they are more specific)                     (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);                     continue;                 }                 if (argCheckMode) {                     // If one or more context sensitive arguments were excluded, we start including                     // them now (and keeping do so for any subsequent candidates) and perform a second                     // round of type inference and applicability checking for this particular candidate.                     argCheckMode = CheckMode.Normal;                     if (inferenceContext) {                         const typeArgumentTypes = instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode, inferenceContext), inferenceContext.mapper);                         checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext.inferredTypeParameters);                         // If the original signature has a generic rest type, instantiation may produce a                         // signature with different arity and we need to perform another arity check.                         if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {                             candidateForArgumentArityError = checkCandidate;                             continue;                         }                     }                     if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors* / false, /*containingMessageChain* / undefined, inferenceContext)) {                         // Give preference to error candidates that have no rest parameters (as they are more specific)                         (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);                         continue;                     }                 }                 candidates[candidateIndex] = checkCandidate;                 return checkCandidate;             } */
             undefined
        }
    }
    getCandidateForOverloadFailure := func(node CallLikeExpression, candidates []Signature, args []Expression, hasCandidatesOutArray bool, checkMode CheckMode) Signature {
        /* TODO(ExpressionStatement): Debug.assert(candidates.length > 0); */
        /* TODO(ExpressionStatement): checkNodeDeferred(node); */
         /* TODO(ConditionalExpression): hasCandidatesOutArray || candidates.length === 1 || candidates.some(c => !!c.typeParameters)             ? pickLongestCandidateSignature(node, candidates, args, checkMode)             : createUnionOfSignaturesForOverloadFailure(candidates) */ TODO
    }
    createUnionOfSignaturesForOverloadFailure := func(candidates []Signature) Signature {
        thisParameters := mapDefined(candidates, /* TODO(ArrowFunction): c => c.thisParameter */ TODO)
        var thisParameter *Symbol
        if /* TODO(PropertyAccessExpression): thisParameters.length */ TODO {
            /* TODO(ExpressionStatement): thisParameter = createCombinedSymbolFromTypes(thisParameters, thisParameters.map(getTypeOfParameter)); */
        }
        TODO_IDENTIFIER := minAndMax(candidates, getNumNonRestParameters)
        var parameters []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForStatement): for (let i = 0; i < maxNonRestParam; i++) {             const symbols = mapDefined(candidates, s =>                 signatureHasRestParameter(s) ?                     i < s.parameters.length - 1 ? s.parameters[i] : last(s.parameters) :                     i < s.parameters.length ? s.parameters[i] : undefined);             Debug.assert(symbols.length !== 0);             parameters.push(createCombinedSymbolFromTypes(symbols, mapDefined(candidates, candidate => tryGetTypeAtPosition(candidate, i))));         } */
        restParameterSymbols := mapDefined(candidates, /* TODO(ArrowFunction): c => signatureHasRestParameter(c) ? last(c.parameters) : undefined */ TODO)
        flags := /* TODO(PropertyAccessExpression): SignatureFlags.IsSignatureCandidateForOverloadFailure */ TODO
        if /* TODO(BinaryExpression): restParameterSymbols.length !== 0 */ TODO {
            type_ := createArrayType(getUnionType(mapDefined(candidates, tryGetRestTypeOfSignature), /* TODO(PropertyAccessExpression): UnionReduction.Subtype */ TODO))
            /* TODO(ExpressionStatement): parameters.push(createCombinedSymbolForOverloadFailure(restParameterSymbols, type)); */
            /* TODO(ExpressionStatement): flags |= SignatureFlags.HasRestParameter; */
        }
        if /* TODO(PropertyAccessExpression): candidates.some */ TODO(signatureHasLiteralTypes) {
            /* TODO(ExpressionStatement): flags |= SignatureFlags.HasLiteralTypes; */
        }
         createSignature(/* TODO(PropertyAccessExpression): candidates[0].declaration */ TODO, undefined, thisParameter, parameters, getIntersectionType(/* TODO(PropertyAccessExpression): candidates.map */ TODO(getReturnTypeOfSignature)), undefined, minArgumentCount, flags)
    }
    getNumNonRestParameters := func(signature Signature) number {
        numParams := /* TODO(PropertyAccessExpression): signature.parameters.length */ TODO
         /* TODO(ConditionalExpression): signatureHasRestParameter(signature) ? numParams - 1 : numParams */ TODO
    }
    createCombinedSymbolFromTypes := func(sources []Symbol, types []Type) Symbol {
         createCombinedSymbolForOverloadFailure(sources, getUnionType(types, /* TODO(PropertyAccessExpression): UnionReduction.Subtype */ TODO))
    }
    createCombinedSymbolForOverloadFailure := func(sources []Symbol, type_ Type) Symbol {
         createSymbolWithType(first(sources), type_)
    }
    pickLongestCandidateSignature := func(node CallLikeExpression, candidates []Signature, args []Expression, checkMode CheckMode) Signature {
        bestIndex := getLongestCandidateIndex(candidates, /* TODO(ConditionalExpression): apparentArgumentCount === undefined ? args.length : apparentArgumentCount */ TODO)
        candidate := /* TODO(ElementAccessExpression): candidates[bestIndex] */ TODO
        TODO_IDENTIFIER := candidate
        if /* TODO(PrefixUnaryExpression): !typeParameters */ TODO {
             candidate
        }
        var typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any = /* TODO(ConditionalExpression): callLikeExpressionMayHaveTypeArguments(node) ? node.typeArguments : undefined */ TODO
        instantiated := /* TODO(ConditionalExpression): typeArgumentNodes             ? createSignatureInstantiation(candidate, getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isInJSFile(node)))             : inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args, checkMode) */ TODO
        /* TODO(ExpressionStatement): candidates[bestIndex] = instantiated; */
         instantiated
    }
    getTypeArgumentsFromNodes := func(typeArgumentNodes []TypeNode, typeParameters []TypeParameter, isJs bool) []Type {
        typeArguments := /* TODO(PropertyAccessExpression): typeArgumentNodes.map */ TODO(getTypeOfNode)
        /* TODO(WhileStatement): while (typeArguments.length > typeParameters.length) {             typeArguments.pop();         } */
        /* TODO(WhileStatement): while (typeArguments.length < typeParameters.length) {             typeArguments.push(getDefaultFromTypeParameter(typeParameters[typeArguments.length]) || getConstraintOfTypeParameter(typeParameters[typeArguments.length]) || getDefaultTypeArgumentType(isJs));         } */
         typeArguments
    }
    inferSignatureInstantiationForOverloadFailure := func(node CallLikeExpression, typeParameters []TypeParameter, candidate Signature, args []Expression, checkMode CheckMode) Signature {
        inferenceContext := createInferenceContext(typeParameters, candidate, /* TODO(ConditionalExpression): isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None */ TODO)
        typeArgumentTypes := inferTypeArguments(node, candidate, args, /* TODO(BinaryExpression): checkMode | CheckMode.SkipContextSensitive | CheckMode.SkipGenericFunctions */ TODO, inferenceContext)
         createSignatureInstantiation(candidate, typeArgumentTypes)
    }
    getLongestCandidateIndex := func(candidates []Signature, argsCount number) number {
        maxParamsIndex := /* TODO(PrefixUnaryExpression): -1 */ TODO
        maxParams := /* TODO(PrefixUnaryExpression): -1 */ TODO
        /* TODO(ForStatement): for (let i = 0; i < candidates.length; i++) {             const candidate = candidates[i];             const paramCount = getParameterCount(candidate);             if (hasEffectiveRestParameter(candidate) || paramCount >= argsCount) {                 return i;             }             if (paramCount > maxParams) {                 maxParams = paramCount;                 maxParamsIndex = i;             }         } */
         maxParamsIndex
    }
    resolveCallExpression := func(node CallExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
        if /* TODO(BinaryExpression): node.expression.kind === SyntaxKind.SuperKeyword */ TODO {
            superType := checkSuperExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO)
            if isTypeAny(superType) {
                /* TODO(ForOfStatement): for (const arg of node.arguments) {                     checkExpression(arg); // Still visit arguments so they get marked for visibility, etc                 } */
                 anySignature
            }
            if /* TODO(PrefixUnaryExpression): !isErrorType(superType) */ TODO {
                baseTypeNode := getEffectiveBaseTypeNode(/* TODO(NonNullExpression): getContainingClass(node)! */ TODO)
                if baseTypeNode {
                    baseConstructors := getInstantiatedConstructorsForTypeArguments(superType, /* TODO(PropertyAccessExpression): baseTypeNode.typeArguments */ TODO, baseTypeNode)
                     resolveCall(node, baseConstructors, candidatesOutArray, checkMode, /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO)
                }
            }
             resolveUntypedCall(node)
        }
        var callChainFlags SignatureFlags
        funcType := checkExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO)
        if isCallChain(node) {
            nonOptionalType := getOptionalExpressionType(funcType, /* TODO(PropertyAccessExpression): node.expression */ TODO)
            /* TODO(ExpressionStatement): callChainFlags = nonOptionalType === funcType ? SignatureFlags.None :                 isOutermostOptionalChain(node) ? SignatureFlags.IsOuterCallChain :                 SignatureFlags.IsInnerCallChain; */
            /* TODO(ExpressionStatement): funcType = nonOptionalType; */
        } else {
            /* TODO(ExpressionStatement): callChainFlags = SignatureFlags.None; */
        }
        /* TODO(ExpressionStatement): funcType = checkNonNullTypeWithReporter(             funcType,             node.expression,             reportCannotInvokePossiblyNullOrUndefinedError,         ); */
        if /* TODO(BinaryExpression): funcType === silentNeverType */ TODO {
             silentNeverSignature
        }
        apparentType := getApparentType(funcType)
        if isErrorType(apparentType) {
             resolveErrorCall(node)
        }
        callSignatures := getSignaturesOfType(apparentType, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
        numConstructSignatures := /* TODO(PropertyAccessExpression): getSignaturesOfType(apparentType, SignatureKind.Construct).length */ TODO
        if isUntypedFunctionCall(funcType, apparentType, /* TODO(PropertyAccessExpression): callSignatures.length */ TODO, numConstructSignatures) {
            if /* TODO(BinaryExpression): !isErrorType(funcType) && node.typeArguments */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments); */
            }
             resolveUntypedCall(node)
        }
        if /* TODO(PrefixUnaryExpression): !callSignatures.length */ TODO {
            if numConstructSignatures {
                /* TODO(ExpressionStatement): error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType)); */
            } else {
                var relatedInformation *DiagnosticRelatedInformation
                if /* TODO(BinaryExpression): node.arguments.length === 1 */ TODO {
                    text := /* TODO(PropertyAccessExpression): getSourceFileOfNode(node).text */ TODO
                    if isLineBreak(/* TODO(PropertyAccessExpression): text.charCodeAt */ TODO(/* TODO(BinaryExpression): skipTrivia(text, node.expression.end, /*stopAfterLineBreak* / true) - 1 */ TODO)) {
                        /* TODO(ExpressionStatement): relatedInformation = createDiagnosticForNode(node.expression, Diagnostics.Are_you_missing_a_semicolon); */
                    }
                }
                /* TODO(ExpressionStatement): invocationError(node.expression, apparentType, SignatureKind.Call, relatedInformation); */
            }
             resolveErrorCall(node)
        }
        if /* TODO(BinaryExpression): checkMode & CheckMode.SkipGenericFunctions && !node.typeArguments && callSignatures.some(isGenericFunctionReturningFunction) */ TODO {
            /* TODO(ExpressionStatement): skippedGenericFunction(node, checkMode); */
             resolvingSignature
        }
        if /* TODO(PropertyAccessExpression): callSignatures.some */ TODO(/* TODO(ArrowFunction): sig => isInJSFile(sig.declaration) && !!getJSDocClassTag(sig.declaration!) */ TODO) {
            /* TODO(ExpressionStatement): error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType)); */
             resolveErrorCall(node)
        }
         resolveCall(node, callSignatures, candidatesOutArray, checkMode, callChainFlags)
    }
    isGenericFunctionReturningFunction := func(signature Signature) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(signature.typeParameters && isFunctionType(getReturnTypeOfSignature(signature))) */ TODO
    }
    isUntypedFunctionCall := func(funcType Type, apparentFuncType Type, numCallSignatures number, numConstructSignatures number) bool {
         /* TODO(BinaryExpression): isTypeAny(funcType) || isTypeAny(apparentFuncType) && !!(funcType.flags & TypeFlags.TypeParameter) ||             !numCallSignatures && !numConstructSignatures && !(apparentFuncType.flags & TypeFlags.Union) && !(getReducedType(apparentFuncType).flags & TypeFlags.Never) && isTypeAssignableTo(funcType, globalFunctionType) */ TODO
    }
    resolveNewExpression := func(node NewExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
        expressionType := checkNonNullExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO)
        if /* TODO(BinaryExpression): expressionType === silentNeverType */ TODO {
             silentNeverSignature
        }
        /* TODO(ExpressionStatement): expressionType = getApparentType(expressionType); */
        if isErrorType(expressionType) {
             resolveErrorCall(node)
        }
        if isTypeAny(expressionType) {
            if /* TODO(PropertyAccessExpression): node.typeArguments */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments); */
            }
             resolveUntypedCall(node)
        }
        constructSignatures := getSignaturesOfType(expressionType, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO)
        if /* TODO(PropertyAccessExpression): constructSignatures.length */ TODO {
            if /* TODO(PrefixUnaryExpression): !isConstructorAccessible(node, constructSignatures[0]) */ TODO {
                 resolveErrorCall(node)
            }
            if someSignature(constructSignatures, /* TODO(ArrowFunction): signature => !!(signature.flags & SignatureFlags.Abstract) */ TODO) {
                /* TODO(ExpressionStatement): error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class); */
                 resolveErrorCall(node)
            }
            valueDecl := /* TODO(BinaryExpression): expressionType.symbol && getClassLikeDeclarationOfSymbol(expressionType.symbol) */ TODO
            if /* TODO(BinaryExpression): valueDecl && hasSyntacticModifier(valueDecl, ModifierFlags.Abstract) */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class); */
                 resolveErrorCall(node)
            }
             resolveCall(node, constructSignatures, candidatesOutArray, checkMode, /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO)
        }
        callSignatures := getSignaturesOfType(expressionType, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
        if /* TODO(PropertyAccessExpression): callSignatures.length */ TODO {
            signature := resolveCall(node, callSignatures, candidatesOutArray, checkMode, /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO)
            if /* TODO(PrefixUnaryExpression): !noImplicitAny */ TODO {
                if /* TODO(BinaryExpression): signature.declaration && !isJSConstructor(signature.declaration) && getReturnTypeOfSignature(signature) !== voidType */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword); */
                }
                if /* TODO(BinaryExpression): getThisTypeOfSignature(signature) === voidType */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void); */
                }
            }
             signature
        }
        /* TODO(ExpressionStatement): invocationError(node.expression, expressionType, SignatureKind.Construct); */
         resolveErrorCall(node)
    }
    someSignature := func(signatures /* TODO(UnionType): Signature | readonly Signature[] */ any, f func(s Signature) bool) bool {
        if isArray(signatures) {
             some(signatures, /* TODO(ArrowFunction): signature => someSignature(signature, f) */ TODO)
        }
         /* TODO(ConditionalExpression): signatures.compositeKind === TypeFlags.Union ? some(signatures.compositeSignatures, f) : f(signatures) */ TODO
    }
    typeHasProtectedAccessibleBase := func(target Symbol, type_ InterfaceType) bool {
        baseTypes := getBaseTypes(type_)
        if /* TODO(PrefixUnaryExpression): !length(baseTypes) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        firstBase := /* TODO(ElementAccessExpression): baseTypes[0] */ TODO
        if /* TODO(BinaryExpression): firstBase.flags & TypeFlags.Intersection */ TODO {
            types := /* TODO(PropertyAccessExpression): (firstBase as IntersectionType).types */ TODO
            mixinFlags := findMixins(types)
            i := 0
            /* TODO(ForOfStatement): for (const intersectionMember of (firstBase as IntersectionType).types) {                 // We want to ignore mixin ctors                 if (!mixinFlags[i]) {                     if (getObjectFlags(intersectionMember) & (ObjectFlags.Class | ObjectFlags.Interface)) {                         if (intersectionMember.symbol === target) {                             return true;                         }                         if (typeHasProtectedAccessibleBase(target, intersectionMember as InterfaceType)) {                             return true;                         }                     }                 }                 i++;             } */
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): firstBase.symbol === target */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
         typeHasProtectedAccessibleBase(target, firstBase /* as */ /* TODO(TypeReference): InterfaceType */)
    }
    isConstructorAccessible := func(node NewExpression, signature Signature) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): !signature || !signature.declaration */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        declaration := /* TODO(PropertyAccessExpression): signature.declaration */ TODO
        modifiers := getSelectedEffectiveModifierFlags(declaration, /* TODO(PropertyAccessExpression): ModifierFlags.NonPublicAccessibilityModifier */ TODO)
        if /* TODO(BinaryExpression): !modifiers || declaration.kind !== SyntaxKind.Constructor */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        declaringClassDeclaration := /* TODO(NonNullExpression): getClassLikeDeclarationOfSymbol(declaration.parent.symbol)! */ TODO
        declaringClass := getDeclaredTypeOfSymbol(/* TODO(PropertyAccessExpression): declaration.parent.symbol */ TODO) /* as */ /* TODO(TypeReference): InterfaceType */
        if /* TODO(PrefixUnaryExpression): !isNodeWithinClass(node, declaringClassDeclaration) */ TODO {
            containingClass := getContainingClass(node)
            if /* TODO(BinaryExpression): containingClass && modifiers & ModifierFlags.Protected */ TODO {
                containingType := getTypeOfNode(containingClass)
                if typeHasProtectedAccessibleBase(/* TODO(PropertyAccessExpression): declaration.parent.symbol */ TODO, containingType /* as */ /* TODO(TypeReference): InterfaceType */) {
                     /* TODO(TrueKeyword): true */ TODO
                }
            }
            if /* TODO(BinaryExpression): modifiers & ModifierFlags.Private */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, typeToString(declaringClass)); */
            }
            if /* TODO(BinaryExpression): modifiers & ModifierFlags.Protected */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, typeToString(declaringClass)); */
            }
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(TrueKeyword): true */ TODO
    }
    invocationErrorDetails := func(errorTarget Node, apparentType Type, kind SignatureKind) /* TODO(TypeLiteral): { messageChain: DiagnosticMessageChain; relatedMessage: DiagnosticMessage | undefined; } */ TODO {
        var errorInfo *DiagnosticMessageChain
        isCall := /* TODO(BinaryExpression): kind === SignatureKind.Call */ TODO
        awaitedType := getAwaitedType(apparentType)
        maybeMissingAwait := /* TODO(BinaryExpression): awaitedType && getSignaturesOfType(awaitedType, kind).length > 0 */ TODO
        if /* TODO(BinaryExpression): apparentType.flags & TypeFlags.Union */ TODO {
            types := /* TODO(PropertyAccessExpression): (apparentType as UnionType).types */ TODO
            hasSignatures := /* TODO(FalseKeyword): false */ TODO
            /* TODO(ForOfStatement): for (const constituent of types) {                 const signatures = getSignaturesOfType(constituent, kind);                 if (signatures.length !== 0) {                     hasSignatures = true;                     if (errorInfo) {                         // Bail early if we already have an error, no chance of "No constituent of type is callable"                         break;                     }                 }                 else {                     // Error on the first non callable constituent only                     if (!errorInfo) {                         errorInfo = chainDiagnosticMessages(                             errorInfo,                             isCall ?                                 Diagnostics.Type_0_has_no_call_signatures :                                 Diagnostics.Type_0_has_no_construct_signatures,                             typeToString(constituent),                         );                         errorInfo = chainDiagnosticMessages(                             errorInfo,                             isCall ?                                 Diagnostics.Not_all_constituents_of_type_0_are_callable :                                 Diagnostics.Not_all_constituents_of_type_0_are_constructable,                             typeToString(apparentType),                         );                     }                     if (hasSignatures) {                         // Bail early if we already found a siganture, no chance of "No constituent of type is callable"                         break;                     }                 }             } */
            if /* TODO(PrefixUnaryExpression): !hasSignatures */ TODO {
                /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(                     /*details* / undefined,                     isCall ?                         Diagnostics.No_constituent_of_type_0_is_callable :                         Diagnostics.No_constituent_of_type_0_is_constructable,                     typeToString(apparentType),                 ); */
            }
            if /* TODO(PrefixUnaryExpression): !errorInfo */ TODO {
                /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(                     errorInfo,                     isCall ?                         Diagnostics.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other :                         Diagnostics.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other,                     typeToString(apparentType),                 ); */
            }
        } else {
            /* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(                 errorInfo,                 isCall ?                     Diagnostics.Type_0_has_no_call_signatures :                     Diagnostics.Type_0_has_no_construct_signatures,                 typeToString(apparentType),             ); */
        }
        headMessage := /* TODO(ConditionalExpression): isCall ? Diagnostics.This_expression_is_not_callable : Diagnostics.This_expression_is_not_constructable */ TODO
        if /* TODO(BinaryExpression): isCallExpression(errorTarget.parent) && errorTarget.parent.arguments.length === 0 */ TODO {
            TODO_IDENTIFIER := getNodeLinks(errorTarget)
            if /* TODO(BinaryExpression): resolvedSymbol && resolvedSymbol.flags & SymbolFlags.GetAccessor */ TODO {
                /* TODO(ExpressionStatement): headMessage = Diagnostics.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without; */
            }
        }
         /* TODO(ObjectLiteralExpression): {             messageChain: chainDiagnosticMessages(errorInfo, headMessage),             relatedMessage: maybeMissingAwait ? Diagnostics.Did_you_forget_to_use_await : undefined,         } */ TODO
    }
    invocationError := func(errorTarget Node, apparentType Type, kind SignatureKind, relatedInformation DiagnosticRelatedInformation) {
        TODO_IDENTIFIER := invocationErrorDetails(errorTarget, apparentType, kind)
        diagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorTarget), errorTarget, messageChain)
        if relatedInfo {
            /* TODO(ExpressionStatement): addRelatedInfo(diagnostic, createDiagnosticForNode(errorTarget, relatedInfo)); */
        }
        if isCallExpression(/* TODO(PropertyAccessExpression): errorTarget.parent */ TODO) {
            TODO_IDENTIFIER := getDiagnosticSpanForCallNode(/* TODO(PropertyAccessExpression): errorTarget.parent */ TODO)
            /* TODO(ExpressionStatement): diagnostic.start = start; */
            /* TODO(ExpressionStatement): diagnostic.length = length; */
        }
        /* TODO(ExpressionStatement): diagnostics.add(diagnostic); */
        /* TODO(ExpressionStatement): invocationErrorRecovery(apparentType, kind, relatedInformation ? addRelatedInfo(diagnostic, relatedInformation) : diagnostic); */
    }
    invocationErrorRecovery := func(apparentType Type, kind SignatureKind, diagnostic Diagnostic) {
        if /* TODO(PrefixUnaryExpression): !apparentType.symbol */ TODO {

        }
        importNode := /* TODO(PropertyAccessExpression): getSymbolLinks(apparentType.symbol).originatingImport */ TODO
        if /* TODO(BinaryExpression): importNode && !isImportCall(importNode) */ TODO {
            sigs := getSignaturesOfType(getTypeOfSymbol(/* TODO(NonNullExpression): getSymbolLinks(apparentType.symbol).target! */ TODO), kind)
            if /* TODO(BinaryExpression): !sigs || !sigs.length */ TODO {
            }
            /* TODO(ExpressionStatement): addRelatedInfo(diagnostic, createDiagnosticForNode(importNode, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead)); */
        }
    }
    resolveTaggedTemplateExpression := func(node TaggedTemplateExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
        tagType := checkExpression(/* TODO(PropertyAccessExpression): node.tag */ TODO)
        apparentType := getApparentType(tagType)
        if isErrorType(apparentType) {
             resolveErrorCall(node)
        }
        callSignatures := getSignaturesOfType(apparentType, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
        numConstructSignatures := /* TODO(PropertyAccessExpression): getSignaturesOfType(apparentType, SignatureKind.Construct).length */ TODO
        if isUntypedFunctionCall(tagType, apparentType, /* TODO(PropertyAccessExpression): callSignatures.length */ TODO, numConstructSignatures) {
             resolveUntypedCall(node)
        }
        if /* TODO(PrefixUnaryExpression): !callSignatures.length */ TODO {
            if isArrayLiteralExpression(/* TODO(PropertyAccessExpression): node.parent */ TODO) {
                diagnostic := createDiagnosticForNode(/* TODO(PropertyAccessExpression): node.tag */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked */ TODO)
                /* TODO(ExpressionStatement): diagnostics.add(diagnostic); */
                 resolveErrorCall(node)
            }
            /* TODO(ExpressionStatement): invocationError(node.tag, apparentType, SignatureKind.Call); */
             resolveErrorCall(node)
        }
         resolveCall(node, callSignatures, candidatesOutArray, checkMode, /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO)
    }
    getDiagnosticHeadMessageForDecoratorResolution := func(node Decorator) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO {
        /* TODO(SwitchStatement): switch (node.parent.kind) {             case SyntaxKind.ClassDeclaration:             case SyntaxKind.ClassExpression:                 return Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;              case SyntaxKind.Parameter:                 return Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;              case SyntaxKind.PropertyDeclaration:                 return Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;              case SyntaxKind.MethodDeclaration:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 return Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;              default:                 return Debug.fail();         } */
    }
    resolveDecorator := func(node Decorator, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
        funcType := checkExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO)
        apparentType := getApparentType(funcType)
        if isErrorType(apparentType) {
             resolveErrorCall(node)
        }
        callSignatures := getSignaturesOfType(apparentType, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
        numConstructSignatures := /* TODO(PropertyAccessExpression): getSignaturesOfType(apparentType, SignatureKind.Construct).length */ TODO
        if isUntypedFunctionCall(funcType, apparentType, /* TODO(PropertyAccessExpression): callSignatures.length */ TODO, numConstructSignatures) {
             resolveUntypedCall(node)
        }
        if /* TODO(BinaryExpression): isPotentiallyUncalledDecorator(node, callSignatures) && !isParenthesizedExpression(node.expression) */ TODO {
            nodeStr := getTextOfNode(/* TODO(PropertyAccessExpression): node.expression */ TODO, /* TODO(FalseKeyword): false */ TODO)
            /* TODO(ExpressionStatement): error(node, Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0, nodeStr); */
             resolveErrorCall(node)
        }
        headMessage := getDiagnosticHeadMessageForDecoratorResolution(node)
        if /* TODO(PrefixUnaryExpression): !callSignatures.length */ TODO {
            errorDetails := invocationErrorDetails(/* TODO(PropertyAccessExpression): node.expression */ TODO, apparentType, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
            messageChain := chainDiagnosticMessages(/* TODO(PropertyAccessExpression): errorDetails.messageChain */ TODO, headMessage)
            diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(/* TODO(PropertyAccessExpression): node.expression */ TODO), /* TODO(PropertyAccessExpression): node.expression */ TODO, messageChain)
            if /* TODO(PropertyAccessExpression): errorDetails.relatedMessage */ TODO {
                /* TODO(ExpressionStatement): addRelatedInfo(diag, createDiagnosticForNode(node.expression, errorDetails.relatedMessage)); */
            }
            /* TODO(ExpressionStatement): diagnostics.add(diag); */
            /* TODO(ExpressionStatement): invocationErrorRecovery(apparentType, SignatureKind.Call, diag); */
             resolveErrorCall(node)
        }
         resolveCall(node, callSignatures, candidatesOutArray, checkMode, /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO, headMessage)
    }
    createSignatureForJSXIntrinsic := func(node JsxOpeningLikeElement, result Type) Signature {
        namespace := getJsxNamespaceAt(node)
        exports := /* TODO(BinaryExpression): namespace && getExportsOfSymbol(namespace) */ TODO
        typeSymbol := /* TODO(BinaryExpression): exports && getSymbol(exports, JsxNames.Element, SymbolFlags.Type) */ TODO
        returnNode := /* TODO(BinaryExpression): typeSymbol && nodeBuilder.symbolToEntityName(typeSymbol, SymbolFlags.Type, node) */ TODO
        declaration := /* TODO(PropertyAccessExpression): factory.createFunctionTypeNode */ TODO(undefined, /* TODO(ArrayLiteralExpression): [factory.createParameterDeclaration(/*modifiers* / undefined, /*dotDotDotToken* / undefined, "props", /*questionToken* / undefined, nodeBuilder.typeToTypeNode(result, node))] */ TODO, /* TODO(ConditionalExpression): returnNode ? factory.createTypeReferenceNode(returnNode, /*typeArguments* / undefined) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword) */ TODO)
        parameterSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.FunctionScopedVariable */ TODO, "props" /* as */ /* TODO(TypeReference): __String */)
        /* TODO(ExpressionStatement): parameterSymbol.links.type = result; */
         createSignature(declaration, undefined, undefined, /* TODO(ArrayLiteralExpression): [parameterSymbol] */ TODO, /* TODO(ConditionalExpression): typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType */ TODO, undefined, 1, /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO)
    }
    resolveJsxOpeningLikeElement := func(node JsxOpeningLikeElement, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
        if isJsxIntrinsicTagName(/* TODO(PropertyAccessExpression): node.tagName */ TODO) {
            result := getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node)
            fakeSignature := createSignatureForJSXIntrinsic(node, result)
            /* TODO(ExpressionStatement): checkTypeAssignableToAndOptionallyElaborate(checkExpressionWithContextualType(node.attributes, getEffectiveFirstArgumentForJsxSignature(fakeSignature, node), /*inferenceContext* / undefined, CheckMode.Normal), result, node.tagName, node.attributes); */
            if length(/* TODO(PropertyAccessExpression): node.typeArguments */ TODO) {
                /* TODO(ExpressionStatement): forEach(node.typeArguments, checkSourceElement); */
                /* TODO(ExpressionStatement): diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), node.typeArguments!, Diagnostics.Expected_0_type_arguments_but_got_1, 0, length(node.typeArguments))); */
            }
             fakeSignature
        }
        exprTypes := checkExpression(/* TODO(PropertyAccessExpression): node.tagName */ TODO)
        apparentType := getApparentType(exprTypes)
        if isErrorType(apparentType) {
             resolveErrorCall(node)
        }
        signatures := getUninstantiatedJsxSignaturesOfType(exprTypes, node)
        if isUntypedFunctionCall(exprTypes, apparentType, /* TODO(PropertyAccessExpression): signatures.length */ TODO, 0) {
             resolveUntypedCall(node)
        }
        if /* TODO(BinaryExpression): signatures.length === 0 */ TODO {
            /* TODO(ExpressionStatement): error(node.tagName, Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, getTextOfNode(node.tagName)); */
             resolveErrorCall(node)
        }
         resolveCall(node, signatures, candidatesOutArray, checkMode, /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO)
    }
    resolveInstanceofExpression := func(node InstanceofExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
        rightType := checkExpression(/* TODO(PropertyAccessExpression): node.right */ TODO)
        if /* TODO(PrefixUnaryExpression): !isTypeAny(rightType) */ TODO {
            hasInstanceMethodType := getSymbolHasInstanceMethodOfObjectType(rightType)
            if hasInstanceMethodType {
                apparentType := getApparentType(hasInstanceMethodType)
                if isErrorType(apparentType) {
                     resolveErrorCall(node)
                }
                callSignatures := getSignaturesOfType(apparentType, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
                constructSignatures := getSignaturesOfType(apparentType, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO)
                if isUntypedFunctionCall(hasInstanceMethodType, apparentType, /* TODO(PropertyAccessExpression): callSignatures.length */ TODO, /* TODO(PropertyAccessExpression): constructSignatures.length */ TODO) {
                     resolveUntypedCall(node)
                }
                if /* TODO(PropertyAccessExpression): callSignatures.length */ TODO {
                     resolveCall(node, callSignatures, candidatesOutArray, checkMode, /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO)
                }
            } else if /* TODO(PrefixUnaryExpression): !(typeHasCallOrConstructSignatures(rightType) || isTypeSubtypeOf(rightType, globalFunctionType)) */ TODO {
                /* TODO(ExpressionStatement): error(node.right, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_either_of_type_any_a_class_function_or_other_type_assignable_to_the_Function_interface_type_or_an_object_type_with_a_Symbol_hasInstance_method); */
                 resolveErrorCall(node)
            }
        }
         anySignature
    }
    isPotentiallyUncalledDecorator := func(decorator Decorator, signatures []Signature) /* TODO(undefined): boolean | 0 */ TODO {
         /* TODO(BinaryExpression): signatures.length && every(signatures, signature =>             signature.minArgumentCount === 0 &&             !signatureHasRestParameter(signature) &&             signature.parameters.length < getDecoratorArgumentCount(decorator, signature)) */ TODO
    }
    resolveSignature := func(node CallLikeExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.CallExpression:                 return resolveCallExpression(node, candidatesOutArray, checkMode);             case SyntaxKind.NewExpression:                 return resolveNewExpression(node, candidatesOutArray, checkMode);             case SyntaxKind.TaggedTemplateExpression:                 return resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode);             case SyntaxKind.Decorator:                 return resolveDecorator(node, candidatesOutArray, checkMode);             case SyntaxKind.JsxOpeningElement:             case SyntaxKind.JsxSelfClosingElement:                 return resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode);             case SyntaxKind.BinaryExpression:                 return resolveInstanceofExpression(node, candidatesOutArray, checkMode);         } */
        /* TODO(ExpressionStatement): Debug.assertNever(node, "Branch in 'resolveSignature' should be unreachable."); */
    }
    getResolvedSignature := func(node CallLikeExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
        links := getNodeLinks(node)
        cached := /* TODO(PropertyAccessExpression): links.resolvedSignature */ TODO
        if /* TODO(BinaryExpression): cached && cached !== resolvingSignature && !candidatesOutArray */ TODO {
             cached
        }
        saveResolutionStart := resolutionStart
        if /* TODO(PrefixUnaryExpression): !cached */ TODO {
            /* TODO(ExpressionStatement): resolutionStart = resolutionTargets.length; */
        }
        /* TODO(ExpressionStatement): links.resolvedSignature = resolvingSignature; */
        result := resolveSignature(node, candidatesOutArray, /* TODO(BinaryExpression): checkMode || CheckMode.Normal */ TODO)
        /* TODO(ExpressionStatement): resolutionStart = saveResolutionStart; */
        if /* TODO(BinaryExpression): result !== resolvingSignature */ TODO {
            if /* TODO(BinaryExpression): links.resolvedSignature !== resolvingSignature */ TODO {
                /* TODO(ExpressionStatement): result = links.resolvedSignature; */
            }
            /* TODO(ExpressionStatement): links.resolvedSignature = flowLoopStart === flowLoopCount ? result : cached; */
        }
         result
    }
    isJSConstructor := func(node Node) /* TODO(TypePredicate): node is FunctionDeclaration | FunctionExpression */ TODO {
        if /* TODO(BinaryExpression): !node || !isInJSFile(node) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        func_ := /* TODO(ConditionalExpression): isFunctionDeclaration(node) || isFunctionExpression(node) ? node :             (isVariableDeclaration(node) || isPropertyAssignment(node)) && node.initializer && isFunctionExpression(node.initializer) ? node.initializer :             undefined */ TODO
        if func_ {
            if getJSDocClassTag(node) {
                /* TODO(TrueKeyword): true */
            }
            if isPropertyAssignment(walkUpParenthesizedExpressions(/* TODO(PropertyAccessExpression): func.parent */ TODO)) {
                /* TODO(FalseKeyword): false */
            }
            symbol := getSymbolOfDeclaration(func_)
             /* TODO(PrefixUnaryExpression): !!symbol?.members?.size */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    mergeJSSymbols := func(target Symbol, source *Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol | undefined */ TODO {
        if source {
            links := getSymbolLinks(source)
            if /* TODO(BinaryExpression): !links.inferredClassSymbol || !links.inferredClassSymbol.has(getSymbolId(target)) */ TODO {
                inferred := /* TODO(ConditionalExpression): isTransientSymbol(target) ? target : cloneSymbol(target) */ TODO
                /* TODO(ExpressionStatement): inferred.exports = inferred.exports || createSymbolTable(); */
                /* TODO(ExpressionStatement): inferred.members = inferred.members || createSymbolTable(); */
                /* TODO(ExpressionStatement): inferred.flags |= source.flags & SymbolFlags.Class; */
                if /* TODO(PropertyAccessExpression): source.exports?.size */ TODO {
                    /* TODO(ExpressionStatement): mergeSymbolTable(inferred.exports, source.exports); */
                }
                if /* TODO(PropertyAccessExpression): source.members?.size */ TODO {
                    /* TODO(ExpressionStatement): mergeSymbolTable(inferred.members, source.members); */
                }
                /* TODO(ExpressionStatement): (links.inferredClassSymbol || (links.inferredClassSymbol = new Map())).set(getSymbolId(inferred), inferred); */
                 inferred
            }
             /* TODO(PropertyAccessExpression): links.inferredClassSymbol.get */ TODO(getSymbolId(target))
        }
    }
    getAssignedClassSymbol := func(decl Declaration) *Symbol {
        assignmentSymbol := /* TODO(BinaryExpression): decl && getSymbolOfExpando(decl, /*allowDeclaration* / true) */ TODO
        prototype := /* TODO(PropertyAccessExpression): assignmentSymbol?.exports?.get */ TODO("prototype" /* as */ /* TODO(TypeReference): __String */)
        init := /* TODO(BinaryExpression): prototype?.valueDeclaration && getAssignedJSPrototype(prototype.valueDeclaration) */ TODO
         /* TODO(ConditionalExpression): init ? getSymbolOfDeclaration(init) : undefined */ TODO
    }
    getSymbolOfExpando := func(node Node, allowDeclaration bool) *Symbol {
        if /* TODO(PrefixUnaryExpression): !node.parent */ TODO {
             undefined
        }
        var name /* TODO(UnionType): Expression | BindingName | undefined */ any
        var decl Node
        if /* TODO(BinaryExpression): isVariableDeclaration(node.parent) && node.parent.initializer === node */ TODO {
            if /* TODO(BinaryExpression): !isInJSFile(node) && !(isVarConstLike(node.parent) && isFunctionLikeDeclaration(node)) */ TODO {
                 undefined
            }
            /* TODO(ExpressionStatement): name = node.parent.name; */
            /* TODO(ExpressionStatement): decl = node.parent; */
        } else if isBinaryExpression(/* TODO(PropertyAccessExpression): node.parent */ TODO) {
            parentNode := /* TODO(PropertyAccessExpression): node.parent */ TODO
            parentNodeOperator := /* TODO(PropertyAccessExpression): node.parent.operatorToken.kind */ TODO
            if /* TODO(BinaryExpression): parentNodeOperator === SyntaxKind.EqualsToken && (allowDeclaration || parentNode.right === node) */ TODO {
                /* TODO(ExpressionStatement): name = parentNode.left; */
                /* TODO(ExpressionStatement): decl = name; */
            } else if /* TODO(BinaryExpression): parentNodeOperator === SyntaxKind.BarBarToken || parentNodeOperator === SyntaxKind.QuestionQuestionToken */ TODO {
                if /* TODO(BinaryExpression): isVariableDeclaration(parentNode.parent) && parentNode.parent.initializer === parentNode */ TODO {
                    /* TODO(ExpressionStatement): name = parentNode.parent.name; */
                    /* TODO(ExpressionStatement): decl = parentNode.parent; */
                } else if /* TODO(BinaryExpression): isBinaryExpression(parentNode.parent) && parentNode.parent.operatorToken.kind === SyntaxKind.EqualsToken && (allowDeclaration || parentNode.parent.right === parentNode) */ TODO {
                    /* TODO(ExpressionStatement): name = parentNode.parent.left; */
                    /* TODO(ExpressionStatement): decl = name; */
                }
                if /* TODO(BinaryExpression): !name || !isBindableStaticNameExpression(name) || !isSameEntityName(name, parentNode.left) */ TODO {
                     undefined
                }
            }
        } else if /* TODO(BinaryExpression): allowDeclaration && isFunctionDeclaration(node) */ TODO {
            /* TODO(ExpressionStatement): name = node.name; */
            /* TODO(ExpressionStatement): decl = node; */
        }
        if /* TODO(BinaryExpression): !decl || !name || (!allowDeclaration && !getExpandoInitializer(node, isPrototypeAccess(name))) */ TODO {
             undefined
        }
         getSymbolOfNode(decl)
    }
    getAssignedJSPrototype := func(node Node) /* TODO(undefined): false | import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectLiteralExpression | undefined */ TODO {
        if /* TODO(PrefixUnaryExpression): !node.parent */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        var parent Node = /* TODO(PropertyAccessExpression): node.parent */ TODO
        /* TODO(WhileStatement): while (parent && parent.kind === SyntaxKind.PropertyAccessExpression) {             parent = parent.parent;         } */
        if /* TODO(BinaryExpression): parent && isBinaryExpression(parent) && isPrototypeAccess(parent.left) && parent.operatorToken.kind === SyntaxKind.EqualsToken */ TODO {
            right := getInitializerOfBinaryExpression(parent)
             /* TODO(BinaryExpression): isObjectLiteralExpression(right) && right */ TODO
        }
    }
    checkCallExpression := func(node /* TODO(UnionType): CallExpression | NewExpression */ any, checkMode CheckMode) Type {
        /* TODO(ExpressionStatement): checkGrammarTypeArguments(node, node.typeArguments); */
        signature := getResolvedSignature(node, undefined, checkMode)
        if /* TODO(BinaryExpression): signature === resolvingSignature */ TODO {
             silentNeverType
        }
        /* TODO(ExpressionStatement): checkDeprecatedSignature(signature, node); */
        if /* TODO(BinaryExpression): node.expression.kind === SyntaxKind.SuperKeyword */ TODO {
             voidType
        }
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.NewExpression */ TODO {
            declaration := /* TODO(PropertyAccessExpression): signature.declaration */ TODO
            if /* TODO(BinaryExpression): declaration &&                 declaration.kind !== SyntaxKind.Constructor &&                 declaration.kind !== SyntaxKind.ConstructSignature &&                 declaration.kind !== SyntaxKind.ConstructorType &&                 !(isJSDocSignature(declaration) && getJSDocRoot(declaration)?.parent?.kind === SyntaxKind.Constructor) &&                 !isJSDocConstructSignature(declaration) &&                 !isJSConstructor(declaration) */ TODO {
                if noImplicitAny {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type); */
                }
                 anyType
            }
        }
        if /* TODO(BinaryExpression): isInJSFile(node) && isCommonJsRequire(node) */ TODO {
             resolveExternalModuleTypeByLiteral(/* TODO(ElementAccessExpression): node.arguments![0] */ TODO /* as */ /* TODO(TypeReference): StringLiteral */)
        }
        returnType := getReturnTypeOfSignature(signature)
        if /* TODO(BinaryExpression): returnType.flags & TypeFlags.ESSymbolLike && isSymbolOrSymbolForCall(node) */ TODO {
             getESSymbolLikeTypeForNode(walkUpParenthesizedExpressions(/* TODO(PropertyAccessExpression): node.parent */ TODO))
        }
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.CallExpression && !node.questionDotToken && node.parent.kind === SyntaxKind.ExpressionStatement &&             returnType.flags & TypeFlags.Void && getTypePredicateOfSignature(signature) */ TODO {
            if /* TODO(PrefixUnaryExpression): !isDottedName(node.expression) */ TODO {
                /* TODO(ExpressionStatement): error(node.expression, Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name); */
            } else if /* TODO(PrefixUnaryExpression): !getEffectsSignature(node) */ TODO {
                diagnostic := error(/* TODO(PropertyAccessExpression): node.expression */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation */ TODO)
                /* TODO(ExpressionStatement): getTypeOfDottedName(node.expression, diagnostic); */
            }
        }
        if isInJSFile(node) {
            jsSymbol := getSymbolOfExpando(node, /* TODO(FalseKeyword): false */ TODO)
            if /* TODO(PropertyAccessExpression): jsSymbol?.exports?.size */ TODO {
                jsAssignmentType := createAnonymousType(jsSymbol, /* TODO(PropertyAccessExpression): jsSymbol.exports */ TODO, emptyArray, emptyArray, emptyArray)
                /* TODO(ExpressionStatement): jsAssignmentType.objectFlags |= ObjectFlags.JSLiteral; */
                 getIntersectionType(/* TODO(ArrayLiteralExpression): [returnType, jsAssignmentType] */ TODO)
            }
        }
         returnType
    }
    checkDeprecatedSignature := func(signature Signature, node CallLikeExpression) {
        if /* TODO(BinaryExpression): signature.flags & SignatureFlags.IsSignatureCandidateForOverloadFailure */ TODO {
        }
        if /* TODO(BinaryExpression): signature.declaration && signature.declaration.flags & NodeFlags.Deprecated */ TODO {
            suggestionNode := getDeprecatedSuggestionNode(node)
            name := tryGetPropertyAccessOrIdentifierToString(getInvokedExpression(node))
            /* TODO(ExpressionStatement): addDeprecatedSuggestionWithSignature(suggestionNode, signature.declaration, name, signatureToString(signature)); */
        }
    }
    getDeprecatedSuggestionNode := func(node Node) Node {
        /* TODO(ExpressionStatement): node = skipParentheses(node); */
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.CallExpression:             case SyntaxKind.Decorator:             case SyntaxKind.NewExpression:                 return getDeprecatedSuggestionNode((node as Decorator | CallExpression | NewExpression).expression);             case SyntaxKind.TaggedTemplateExpression:                 return getDeprecatedSuggestionNode((node as TaggedTemplateExpression).tag);             case SyntaxKind.JsxOpeningElement:             case SyntaxKind.JsxSelfClosingElement:                 return getDeprecatedSuggestionNode((node as JsxOpeningLikeElement).tagName);             case SyntaxKind.ElementAccessExpression:                 return (node as ElementAccessExpression).argumentExpression;             case SyntaxKind.PropertyAccessExpression:                 return (node as PropertyAccessExpression).name;             case SyntaxKind.TypeReference:                 const typeReference = node as TypeReferenceNode;                 return isQualifiedName(typeReference.typeName) ? typeReference.typeName.right : typeReference;             default:                 return node;         } */
    }
    isSymbolOrSymbolForCall := func(node Node) /* TODO(undefined): boolean */ TODO {
        if /* TODO(PrefixUnaryExpression): !isCallExpression(node) */ TODO {
            /* TODO(FalseKeyword): false */
        }
        left := /* TODO(PropertyAccessExpression): node.expression */ TODO
        if /* TODO(BinaryExpression): isPropertyAccessExpression(left) && left.name.escapedText === "for" */ TODO {
            /* TODO(ExpressionStatement): left = left.expression; */
        }
        if /* TODO(BinaryExpression): !isIdentifier(left) || left.escapedText !== "Symbol" */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        globalESSymbol := getGlobalESSymbolConstructorSymbol(/* TODO(FalseKeyword): false */ TODO)
        if /* TODO(PrefixUnaryExpression): !globalESSymbol */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(BinaryExpression): globalESSymbol === resolveName(left, "Symbol" as __String, SymbolFlags.Value, /*nameNotFoundMessage* / undefined, /*isUse* / false) */ TODO
    }
    checkImportCallExpression := func(node ImportCall) Type {
        /* TODO(ExpressionStatement): checkGrammarImportCallExpression(node); */
        if /* TODO(BinaryExpression): node.arguments.length === 0 */ TODO {
             createPromiseReturnType(node, anyType)
        }
        specifier := /* TODO(ElementAccessExpression): node.arguments[0] */ TODO
        specifierType := checkExpressionCached(specifier)
        optionsType := /* TODO(ConditionalExpression): node.arguments.length > 1 ? checkExpressionCached(node.arguments[1]) : undefined */ TODO
        /* TODO(ForStatement): for (let i = 2; i < node.arguments.length; ++i) {             checkExpressionCached(node.arguments[i]);         } */
        if /* TODO(BinaryExpression): specifierType.flags & TypeFlags.Undefined || specifierType.flags & TypeFlags.Null || !isTypeAssignableTo(specifierType, stringType) */ TODO {
            /* TODO(ExpressionStatement): error(specifier, Diagnostics.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0, typeToString(specifierType)); */
        }
        if optionsType {
            importCallOptionsType := getGlobalImportCallOptionsType(/* TODO(TrueKeyword): true */ TODO)
            if /* TODO(BinaryExpression): importCallOptionsType !== emptyObjectType */ TODO {
                /* TODO(ExpressionStatement): checkTypeAssignableTo(optionsType, getNullableType(importCallOptionsType, TypeFlags.Undefined), node.arguments[1]); */
            }
        }
        moduleSymbol := resolveExternalModuleName(node, specifier)
        if moduleSymbol {
            esModuleSymbol := resolveESModuleSymbol(moduleSymbol, specifier, /* TODO(TrueKeyword): true */ TODO, /* TODO(FalseKeyword): false */ TODO)
            if esModuleSymbol {
                 createPromiseReturnType(node, /* TODO(BinaryExpression): getTypeWithSyntheticDefaultOnly(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier) ||                         getTypeWithSyntheticDefaultImportType(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier) */ TODO)
            }
        }
         createPromiseReturnType(node, anyType)
    }
    createDefaultPropertyWrapperForModule := func(symbol Symbol, originalSymbol *Symbol, anonymousSymbol *Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
        memberTable := createSymbolTable()
        newSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Alias */ TODO, /* TODO(PropertyAccessExpression): InternalSymbolName.Default */ TODO)
        /* TODO(ExpressionStatement): newSymbol.parent = originalSymbol; */
        /* TODO(ExpressionStatement): newSymbol.links.nameType = getStringLiteralType("default"); */
        /* TODO(ExpressionStatement): newSymbol.links.aliasTarget = resolveSymbol(symbol); */
        /* TODO(ExpressionStatement): memberTable.set(InternalSymbolName.Default, newSymbol); */
         createAnonymousType(anonymousSymbol, memberTable, emptyArray, emptyArray, emptyArray)
    }
    getTypeWithSyntheticDefaultOnly := func(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        hasDefaultOnly := isOnlyImportableAsDefault(moduleSpecifier)
        if /* TODO(BinaryExpression): hasDefaultOnly && type && !isErrorType(type) */ TODO {
            synthType := type_ /* as */ /* TODO(TypeReference): SyntheticDefaultModuleType */
            if /* TODO(PrefixUnaryExpression): !synthType.defaultOnlyType */ TODO {
                type_ := createDefaultPropertyWrapperForModule(symbol, originalSymbol)
                /* TODO(ExpressionStatement): synthType.defaultOnlyType = type; */
            }
             /* TODO(PropertyAccessExpression): synthType.defaultOnlyType */ TODO
        }
         undefined
    }
    getTypeWithSyntheticDefaultImportType := func(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) Type {
        if /* TODO(BinaryExpression): allowSyntheticDefaultImports && type && !isErrorType(type) */ TODO {
            synthType := type_ /* as */ /* TODO(TypeReference): SyntheticDefaultModuleType */
            if /* TODO(PrefixUnaryExpression): !synthType.syntheticType */ TODO {
                file := /* TODO(PropertyAccessExpression): originalSymbol.declarations?.find */ TODO(isSourceFile)
                hasSyntheticDefault := canHaveSyntheticDefault(file, originalSymbol, /* TODO(FalseKeyword): false */ TODO, moduleSpecifier)
                if hasSyntheticDefault {
                    anonymousSymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.TypeLiteral */ TODO, /* TODO(PropertyAccessExpression): InternalSymbolName.Type */ TODO)
                    defaultContainingObject := createDefaultPropertyWrapperForModule(symbol, originalSymbol, anonymousSymbol)
                    /* TODO(ExpressionStatement): anonymousSymbol.links.type = defaultContainingObject; */
                    /* TODO(ExpressionStatement): synthType.syntheticType = isValidSpreadType(type) ? getSpreadType(type, defaultContainingObject, anonymousSymbol, /*objectFlags* / 0, /*readonly* / false) : defaultContainingObject; */
                } else {
                    /* TODO(ExpressionStatement): synthType.syntheticType = type; */
                }
            }
             /* TODO(PropertyAccessExpression): synthType.syntheticType */ TODO
        }
         type_
    }
    isCommonJsRequire := func(node Node) bool {
        if /* TODO(PrefixUnaryExpression): !isRequireCall(node, /*requireStringLiteralLikeArgument* / true) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(PrefixUnaryExpression): !isIdentifier(node.expression) */ TODO {
            /* TODO(CallExpression): Debug.fail() */
        }
        resolvedRequire := /* TODO(NonNullExpression): resolveName(node.expression, node.expression.escapedText, SymbolFlags.Value, /*nameNotFoundMessage* / undefined, /*isUse* / true)! */ TODO
        if /* TODO(BinaryExpression): resolvedRequire === requireSymbol */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): resolvedRequire.flags & SymbolFlags.Alias */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        targetDeclarationKind := /* TODO(ConditionalExpression): resolvedRequire.flags & SymbolFlags.Function             ? SyntaxKind.FunctionDeclaration             : resolvedRequire.flags & SymbolFlags.Variable             ? SyntaxKind.VariableDeclaration             : SyntaxKind.Unknown */ TODO
        if /* TODO(BinaryExpression): targetDeclarationKind !== SyntaxKind.Unknown */ TODO {
            decl := /* TODO(NonNullExpression): getDeclarationOfKind(resolvedRequire, targetDeclarationKind)! */ TODO
             /* TODO(BinaryExpression): !!decl && !!(decl.flags & NodeFlags.Ambient) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkTaggedTemplateExpression := func(node TaggedTemplateExpression) Type {
        if /* TODO(PrefixUnaryExpression): !checkGrammarTaggedTemplateChain(node) */ TODO {
            /* TODO(CallExpression): checkGrammarTypeArguments(node, node.typeArguments) */
        }
        if /* TODO(BinaryExpression): languageVersion < LanguageFeatureMinimumTarget.TaggedTemplates */ TODO {
            /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.MakeTemplateObject); */
        }
        signature := getResolvedSignature(node)
        /* TODO(ExpressionStatement): checkDeprecatedSignature(signature, node); */
         getReturnTypeOfSignature(signature)
    }
    checkAssertion := func(node AssertionExpression, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.TypeAssertionExpression */ TODO {
            file := getSourceFileOfNode(node)
            if /* TODO(BinaryExpression): file && fileExtensionIsOneOf(file.fileName, [Extension.Cts, Extension.Mts]) */ TODO {
                /* TODO(ExpressionStatement): grammarErrorOnNode(node, Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead); */
            }
        }
         checkAssertionWorker(node, checkMode)
    }
    isValidConstAssertionArgument := func(node Node) bool {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.StringLiteral:             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.NumericLiteral:             case SyntaxKind.BigIntLiteral:             case SyntaxKind.TrueKeyword:             case SyntaxKind.FalseKeyword:             case SyntaxKind.ArrayLiteralExpression:             case SyntaxKind.ObjectLiteralExpression:             case SyntaxKind.TemplateExpression:                 return true;             case SyntaxKind.ParenthesizedExpression:                 return isValidConstAssertionArgument((node as ParenthesizedExpression).expression);             case SyntaxKind.PrefixUnaryExpression:                 const op = (node as PrefixUnaryExpression).operator;                 const arg = (node as PrefixUnaryExpression).operand;                 return op === SyntaxKind.MinusToken && (arg.kind === SyntaxKind.NumericLiteral || arg.kind === SyntaxKind.BigIntLiteral) ||                     op === SyntaxKind.PlusToken && arg.kind === SyntaxKind.NumericLiteral;             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 const expr = skipParentheses((node as PropertyAccessExpression | ElementAccessExpression).expression);                 const symbol = isEntityNameExpression(expr) ? resolveEntityName(expr, SymbolFlags.Value, /*ignoreErrors* / true) : undefined;                 return !!(symbol && symbol.flags & SymbolFlags.Enum);         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    checkAssertionWorker := func(node /* TODO(UnionType): JSDocTypeAssertion | AssertionExpression */ any, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        TODO_IDENTIFIER := getAssertionTypeAndExpression(node)
        exprType := checkExpression(expression, checkMode)
        if isConstTypeReference(type_) {
            if /* TODO(PrefixUnaryExpression): !isValidConstAssertionArgument(expression) */ TODO {
                /* TODO(ExpressionStatement): error(expression, Diagnostics.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals); */
            }
             getRegularTypeOfLiteralType(exprType)
        }
        links := getNodeLinks(node)
        /* TODO(ExpressionStatement): links.assertionExpressionType = exprType; */
        /* TODO(ExpressionStatement): checkSourceElement(type); */
        /* TODO(ExpressionStatement): checkNodeDeferred(node); */
         getTypeFromTypeNode(type_)
    }
    getAssertionTypeAndExpression := func(node /* TODO(UnionType): JSDocTypeAssertion | AssertionExpression */ any) /* TODO(undefined): { type: import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode; expression: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; } */ TODO {
        var type_ TypeNode
        var expression Expression
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AsExpression:             case SyntaxKind.TypeAssertionExpression:                 type = node.type;                 expression = node.expression;                 break;             case SyntaxKind.ParenthesizedExpression:                 type = getJSDocTypeAssertionType(node);                 expression = node.expression;                 break;         } */
         /* TODO(ObjectLiteralExpression): { type, expression } */ TODO
    }
    checkAssertionDeferred := func(node /* TODO(UnionType): JSDocTypeAssertion | AssertionExpression */ any) {
        TODO_IDENTIFIER := getAssertionTypeAndExpression(node)
        errNode := /* TODO(ConditionalExpression): isParenthesizedExpression(node) ? type : node */ TODO
        links := getNodeLinks(node)
        /* TODO(ExpressionStatement): Debug.assertIsDefined(links.assertionExpressionType); */
        exprType := getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(/* TODO(PropertyAccessExpression): links.assertionExpressionType */ TODO))
        targetType := getTypeFromTypeNode(type_)
        if /* TODO(PrefixUnaryExpression): !isErrorType(targetType) */ TODO {
            /* TODO(ExpressionStatement): addLazyDiagnostic(() => {                 const widenedType = getWidenedType(exprType);                 if (!isTypeComparableTo(targetType, widenedType)) {                     checkTypeComparableTo(exprType, targetType, errNode, Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first);                 }             }); */
        }
    }
    checkNonNullChain := func(node NonNullChain) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        leftType := checkExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO)
        nonOptionalType := getOptionalExpressionType(leftType, /* TODO(PropertyAccessExpression): node.expression */ TODO)
         propagateOptionalTypeMarker(getNonNullableType(nonOptionalType), node, /* TODO(BinaryExpression): nonOptionalType !== leftType */ TODO)
    }
    checkNonNullAssertion := func(node NonNullExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): node.flags & NodeFlags.OptionalChain ? checkNonNullChain(node as NonNullChain) :             getNonNullableType(checkExpression(node.expression)) */ TODO
    }
    checkExpressionWithTypeArguments := func(node /* TODO(UnionType): ExpressionWithTypeArguments | TypeQueryNode */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        /* TODO(ExpressionStatement): checkGrammarExpressionWithTypeArguments(node); */
        /* TODO(ExpressionStatement): forEach(node.typeArguments, checkSourceElement); */
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.ExpressionWithTypeArguments */ TODO {
            parent := walkUpParenthesizedExpressions(/* TODO(PropertyAccessExpression): node.parent */ TODO)
            if /* TODO(BinaryExpression): parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.InstanceOfKeyword && isNodeDescendantOf(node, (parent as BinaryExpression).right) */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_not_be_an_instantiation_expression); */
            }
        }
        exprType := /* TODO(ConditionalExpression): node.kind === SyntaxKind.ExpressionWithTypeArguments ? checkExpression(node.expression) :             isThisIdentifier(node.exprName) ? checkThisExpression(node.exprName) :             checkExpression(node.exprName) */ TODO
         getInstantiationExpressionType(exprType, node)
    }
    getInstantiationExpressionType := func(exprType Type, node NodeWithTypeArguments) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        typeArguments := /* TODO(PropertyAccessExpression): node.typeArguments */ TODO
        if /* TODO(BinaryExpression): exprType === silentNeverType || isErrorType(exprType) || !some(typeArguments) */ TODO {
             exprType
        }
        hasSomeApplicableSignature := /* TODO(FalseKeyword): false */ TODO
        var nonApplicableType *Type
        result := getInstantiatedType(exprType)
        errorType := /* TODO(ConditionalExpression): hasSomeApplicableSignature ? nonApplicableType : exprType */ TODO
        if errorType {
            /* TODO(ExpressionStatement): diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable, typeToString(errorType))); */
        }
         result
        getInstantiatedType := func(type_ Type) Type {
            hasSignatures := /* TODO(FalseKeyword): false */ TODO
            hasApplicableSignature := /* TODO(FalseKeyword): false */ TODO
            result := getInstantiatedTypePart(type_)
            /* TODO(ExpressionStatement): hasSomeApplicableSignature ||= hasApplicableSignature; */
            if /* TODO(BinaryExpression): hasSignatures && !hasApplicableSignature */ TODO {
                /* TODO(ExpressionStatement): nonApplicableType ??= type; */
            }
             result
            getInstantiatedTypePart := func(type_ Type) Type {
                if /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
                    resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
                    callSignatures := getInstantiatedSignatures(/* TODO(PropertyAccessExpression): resolved.callSignatures */ TODO)
                    constructSignatures := getInstantiatedSignatures(/* TODO(PropertyAccessExpression): resolved.constructSignatures */ TODO)
                    /* TODO(ExpressionStatement): hasSignatures ||= resolved.callSignatures.length !== 0 || resolved.constructSignatures.length !== 0; */
                    /* TODO(ExpressionStatement): hasApplicableSignature ||= callSignatures.length !== 0 || constructSignatures.length !== 0; */
                    if /* TODO(BinaryExpression): callSignatures !== resolved.callSignatures || constructSignatures !== resolved.constructSignatures */ TODO {
                        result := createAnonymousType(createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.None */ TODO, /* TODO(PropertyAccessExpression): InternalSymbolName.InstantiationExpression */ TODO), /* TODO(PropertyAccessExpression): resolved.members */ TODO, callSignatures, constructSignatures, /* TODO(PropertyAccessExpression): resolved.indexInfos */ TODO) /* as */ /* TODO(IntersectionType): ResolvedType & InstantiationExpressionType */
                        /* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.InstantiationExpressionType; */
                        /* TODO(ExpressionStatement): result.node = node; */
                         result
                    }
                } else if /* TODO(BinaryExpression): type.flags & TypeFlags.InstantiableNonPrimitive */ TODO {
                    constraint := getBaseConstraintOfType(type_)
                    if constraint {
                        instantiated := getInstantiatedTypePart(constraint)
                        if /* TODO(BinaryExpression): instantiated !== constraint */ TODO {
                             instantiated
                        }
                    }
                } else if /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
                     mapType(type_, getInstantiatedType)
                } else if /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
                     getIntersectionType(sameMap(/* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, getInstantiatedTypePart))
                }
                 type_
            }
        }
        getInstantiatedSignatures := func(signatures []Signature) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
            applicableSignatures := filter(signatures, /* TODO(ArrowFunction): sig => !!sig.typeParameters && hasCorrectTypeArgumentArity(sig, typeArguments) */ TODO)
             sameMap(applicableSignatures, /* TODO(ArrowFunction): sig => {                 const typeArgumentTypes = checkTypeArguments(sig, typeArguments!, /*reportErrors* / true);                 return typeArgumentTypes ? getSignatureInstantiation(sig, typeArgumentTypes, isInJSFile(sig.declaration)) : sig;             } */ TODO)
        }
    }
    checkSatisfiesExpression := func(node SatisfiesExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        /* TODO(ExpressionStatement): checkSourceElement(node.type); */
         checkSatisfiesExpressionWorker(/* TODO(PropertyAccessExpression): node.expression */ TODO, /* TODO(PropertyAccessExpression): node.type */ TODO)
    }
    checkSatisfiesExpressionWorker := func(expression Expression, target TypeNode, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        exprType := checkExpression(expression, checkMode)
        targetType := getTypeFromTypeNode(target)
        if isErrorType(targetType) {
             targetType
        }
        errorNode := findAncestor(/* TODO(PropertyAccessExpression): target.parent */ TODO, /* TODO(ArrowFunction): n => n.kind === SyntaxKind.SatisfiesExpression || n.kind === SyntaxKind.JSDocSatisfiesTag */ TODO)
        /* TODO(ExpressionStatement): checkTypeAssignableToAndOptionallyElaborate(exprType, targetType, errorNode, expression, Diagnostics.Type_0_does_not_satisfy_the_expected_type_1); */
         exprType
    }
    checkMetaProperty := func(node MetaProperty) Type {
        /* TODO(ExpressionStatement): checkGrammarMetaProperty(node); */
        if /* TODO(BinaryExpression): node.keywordToken === SyntaxKind.NewKeyword */ TODO {
             checkNewTargetMetaProperty(node)
        }
        if /* TODO(BinaryExpression): node.keywordToken === SyntaxKind.ImportKeyword */ TODO {
             checkImportMetaProperty(node)
        }
         /* TODO(PropertyAccessExpression): Debug.assertNever */ TODO(/* TODO(PropertyAccessExpression): node.keywordToken */ TODO)
    }
    checkMetaPropertyKeyword := func(node MetaProperty) Type {
        /* TODO(SwitchStatement): switch (node.keywordToken) {             case SyntaxKind.ImportKeyword:                 return getGlobalImportMetaExpressionType();             case SyntaxKind.NewKeyword:                 const type = checkNewTargetMetaProperty(node);                 return isErrorType(type) ? errorType : createNewTargetExpressionType(type);             default:                 Debug.assertNever(node.keywordToken);         } */
    }
    checkNewTargetMetaProperty := func(node MetaProperty) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        container := getNewTargetContainer(node)
        if /* TODO(PrefixUnaryExpression): !container */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor, "new.target"); */
             errorType
        } else if /* TODO(BinaryExpression): container.kind === SyntaxKind.Constructor */ TODO {
            symbol := getSymbolOfDeclaration(/* TODO(PropertyAccessExpression): container.parent */ TODO)
             getTypeOfSymbol(symbol)
        } else {
            symbol := getSymbolOfDeclaration(container)
             getTypeOfSymbol(symbol)
        }
    }
    checkImportMetaProperty := func(node MetaProperty) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType | import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
        if /* TODO(BinaryExpression): moduleKind === ModuleKind.Node16 || moduleKind === ModuleKind.NodeNext */ TODO {
            if /* TODO(BinaryExpression): getSourceFileOfNode(node).impliedNodeFormat !== ModuleKind.ESNext */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output); */
            }
        } else if /* TODO(BinaryExpression): moduleKind < ModuleKind.ES2020 && moduleKind !== ModuleKind.System */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext); */
        }
        file := getSourceFileOfNode(node)
        /* TODO(ExpressionStatement): Debug.assert(!!(file.flags & NodeFlags.PossiblyContainsImportMeta), "Containing file is missing import meta node flag."); */
         /* TODO(ConditionalExpression): node.name.escapedText === "meta" ? getGlobalImportMetaType() : errorType */ TODO
    }
    getTypeOfParameter := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
         addOptionality(getTypeOfSymbol(symbol), /* TODO(FalseKeyword): false */ TODO, /* TODO(BinaryExpression): !!declaration && (hasInitializer(declaration) || isOptionalDeclaration(declaration)) */ TODO)
    }
    getTupleElementLabelFromBindingElement := func(node /* TODO(UnionType): BindingElement | ParameterDeclaration */ any, index number, elementFlags ElementFlags) __String {
        /* TODO(SwitchStatement): switch (node.name.kind) {             case SyntaxKind.Identifier: {                 const name = node.name.escapedText;                 if (node.dotDotDotToken) {                     // given                     //   (...[x, y, ...z]: [number, number, ...number[]]) => ...                     // this produces                     //   (x: number, y: number, ...z: number[]) => ...                     // which preserves rest elements of 'z'                      // given                     //   (...[x, y, ...z]: [number, number, ...[...number[], number]]) => ...                     // this produces                     //   (x: number, y: number, ...z: number[], z_1: number) => ...                     // which preserves rest elements of z but gives distinct numbers to fixed elements of 'z'                     return elementFlags & ElementFlags.Variable ? name : `${name}_${index}` as __String;                 }                 else {                     // given                     //   (...[x]: [number]) => ...                     // this produces                     //   (x: number) => ...                     // which preserves fixed elements of 'x'                      // given                     //   (...[x]: ...number[]) => ...                     // this produces                     //   (x_0: number) => ...                     // which which numbers fixed elements of 'x' whose tuple element type is variable                     return elementFlags & ElementFlags.Fixed ? name : `${name}_n` as __String;                 }             }             case SyntaxKind.ArrayBindingPattern: {                 if (node.dotDotDotToken) {                     const elements = node.name.elements;                     const lastElement = tryCast(lastOrUndefined(elements), isBindingElement);                     const elementCount = elements.length - (lastElement?.dotDotDotToken ? 1 : 0);                     if (index < elementCount) {                         const element = elements[index];                         if (isBindingElement(element)) {                             return getTupleElementLabelFromBindingElement(element, index, elementFlags);                         }                     }                     else if (lastElement?.dotDotDotToken) {                         return getTupleElementLabelFromBindingElement(lastElement, index - elementCount, elementFlags);                     }                 }                 break;             }         } */
         /* TODO(TemplateExpression): `arg_${index}` */ TODO /* as */ /* TODO(TypeReference): __String */
    }
    // OVERLOAD: getTupleElementLabel := func(d /* TODO(UnionType): ParameterDeclaration | NamedTupleMember */ any) __String
    // OVERLOAD: getTupleElementLabel := func(d /* TODO(UnionType): ParameterDeclaration | NamedTupleMember | undefined */ any, index number, elementFlags ElementFlags, restSymbol Symbol) __String
    getTupleElementLabel := func(d /* TODO(UnionType): ParameterDeclaration | NamedTupleMember | undefined */ any, index /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */, elementFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): ElementFlags.Fixed */, restSymbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
        if /* TODO(PrefixUnaryExpression): !d */ TODO {
            restParameter := tryCast(/* TODO(PropertyAccessExpression): restSymbol?.valueDeclaration */ TODO, isParameter)
             /* TODO(ConditionalExpression): restParameter ? getTupleElementLabelFromBindingElement(restParameter, index, elementFlags) :                 `${restSymbol?.escapedName ?? "arg"}_${index}` as __String */ TODO
        }
        /* TODO(ExpressionStatement): Debug.assert(isIdentifier(d.name)); */
         /* TODO(PropertyAccessExpression): d.name.escapedText */ TODO
    }
    getParameterNameAtPosition := func(signature Signature, pos number, overrideRestType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
        paramCount := /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
        if /* TODO(BinaryExpression): pos < paramCount */ TODO {
             /* TODO(PropertyAccessExpression): signature.parameters[pos].escapedName */ TODO
        }
        restParameter := /* TODO(BinaryExpression): signature.parameters[paramCount] || unknownSymbol */ TODO
        restType := /* TODO(BinaryExpression): overrideRestType || getTypeOfSymbol(restParameter) */ TODO
        if isTupleType(restType) {
            tupleType := /* TODO(PropertyAccessExpression): (restType as TypeReference).target */ TODO /* as */ /* TODO(TypeReference): TupleType */
            index := /* TODO(BinaryExpression): pos - paramCount */ TODO
            associatedName := /* TODO(ElementAccessExpression): tupleType.labeledElementDeclarations?.[index] */ TODO
            elementFlags := /* TODO(ElementAccessExpression): tupleType.elementFlags[index] */ TODO
             getTupleElementLabel(associatedName, index, elementFlags, restParameter)
        }
         /* TODO(PropertyAccessExpression): restParameter.escapedName */ TODO
    }
    getParameterIdentifierInfoAtPosition := func(signature Signature, pos number) /* TODO(TypeLiteral): { parameter: Identifier; parameterName: __String; isRestParameter: boolean; } */ any {
        if /* TODO(BinaryExpression): signature.declaration?.kind === SyntaxKind.JSDocFunctionType */ TODO {
             undefined
        }
        paramCount := /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
        if /* TODO(BinaryExpression): pos < paramCount */ TODO {
            param := /* TODO(ElementAccessExpression): signature.parameters[pos] */ TODO
            paramIdent := getParameterDeclarationIdentifier(param)
             /* TODO(ConditionalExpression): paramIdent ? {                 parameter: paramIdent,                 parameterName: param.escapedName,                 isRestParameter: false,             } : undefined */ TODO
        }
        restParameter := /* TODO(BinaryExpression): signature.parameters[paramCount] || unknownSymbol */ TODO
        restIdent := getParameterDeclarationIdentifier(restParameter)
        if /* TODO(PrefixUnaryExpression): !restIdent */ TODO {
             undefined
        }
        restType := getTypeOfSymbol(restParameter)
        if isTupleType(restType) {
            associatedNames := /* TODO(PropertyAccessExpression): ((restType as TypeReference).target as TupleType).labeledElementDeclarations */ TODO
            index := /* TODO(BinaryExpression): pos - paramCount */ TODO
            associatedName := /* TODO(ElementAccessExpression): associatedNames?.[index] */ TODO
            isRestTupleElement := /* TODO(PrefixUnaryExpression): !!associatedName?.dotDotDotToken */ TODO
            if associatedName {
                /* TODO(ExpressionStatement): Debug.assert(isIdentifier(associatedName.name)); */
                 /* TODO(ObjectLiteralExpression): { parameter: associatedName.name, parameterName: associatedName.name.escapedText, isRestParameter: isRestTupleElement } */ TODO
            }
             undefined
        }
        if /* TODO(BinaryExpression): pos === paramCount */ TODO {
             /* TODO(ObjectLiteralExpression): { parameter: restIdent, parameterName: restParameter.escapedName, isRestParameter: true } */ TODO
        }
         undefined
    }
    getParameterDeclarationIdentifier := func(symbol Symbol) /* TODO(undefined): false | import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | undefined */ TODO {
         /* TODO(BinaryExpression): symbol.valueDeclaration && isParameter(symbol.valueDeclaration) && isIdentifier(symbol.valueDeclaration.name) && symbol.valueDeclaration.name */ TODO
    }
    isValidDeclarationForTupleLabel := func(d Declaration) /* TODO(TypePredicate): d is NamedTupleMember | (ParameterDeclaration & { name: Identifier; }) */ TODO {
         /* TODO(BinaryExpression): d.kind === SyntaxKind.NamedTupleMember || (isParameter(d) && d.name && isIdentifier(d.name)) */ TODO
    }
    getNameableDeclarationAtPosition := func(signature Signature, pos number) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember | undefined */ TODO {
        paramCount := /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
        if /* TODO(BinaryExpression): pos < paramCount */ TODO {
            decl := /* TODO(PropertyAccessExpression): signature.parameters[pos].valueDeclaration */ TODO
             /* TODO(ConditionalExpression): decl && isValidDeclarationForTupleLabel(decl) ? decl : undefined */ TODO
        }
        restParameter := /* TODO(BinaryExpression): signature.parameters[paramCount] || unknownSymbol */ TODO
        restType := getTypeOfSymbol(restParameter)
        if isTupleType(restType) {
            associatedNames := /* TODO(PropertyAccessExpression): ((restType as TypeReference).target as TupleType).labeledElementDeclarations */ TODO
            index := /* TODO(BinaryExpression): pos - paramCount */ TODO
             /* TODO(BinaryExpression): associatedNames && associatedNames[index] */ TODO
        }
         /* TODO(ConditionalExpression): restParameter.valueDeclaration && isValidDeclarationForTupleLabel(restParameter.valueDeclaration) ? restParameter.valueDeclaration : undefined */ TODO
    }
    getTypeAtPosition := func(signature Signature, pos number) Type {
         /* TODO(BinaryExpression): tryGetTypeAtPosition(signature, pos) || anyType */ TODO
    }
    tryGetTypeAtPosition := func(signature Signature, pos number) *Type {
        paramCount := /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
        if /* TODO(BinaryExpression): pos < paramCount */ TODO {
             getTypeOfParameter(/* TODO(ElementAccessExpression): signature.parameters[pos] */ TODO)
        }
        if signatureHasRestParameter(signature) {
            restType := getTypeOfSymbol(/* TODO(ElementAccessExpression): signature.parameters[paramCount] */ TODO)
            index := /* TODO(BinaryExpression): pos - paramCount */ TODO
            if /* TODO(BinaryExpression): !isTupleType(restType) || restType.target.combinedFlags & ElementFlags.Variable || index < restType.target.fixedLength */ TODO {
                 getIndexedAccessType(restType, getNumberLiteralType(index))
            }
        }
         undefined
    }
    getRestTypeAtPosition := func(source Signature, pos number, readonly bool) Type {
        parameterCount := getParameterCount(source)
        minArgumentCount := getMinArgumentCount(source)
        restType := getEffectiveRestType(source)
        if /* TODO(BinaryExpression): restType && pos >= parameterCount - 1 */ TODO {
             /* TODO(ConditionalExpression): pos === parameterCount - 1 ? restType : createArrayType(getIndexedAccessType(restType, numberType)) */ TODO
        }
        types := /* TODO(ArrayLiteralExpression): [] */ TODO
        flags := /* TODO(ArrayLiteralExpression): [] */ TODO
        names := /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForStatement): for (let i = pos; i < parameterCount; i++) {             if (!restType || i < parameterCount - 1) {                 types.push(getTypeAtPosition(source, i));                 flags.push(i < minArgumentCount ? ElementFlags.Required : ElementFlags.Optional);             }             else {                 types.push(restType);                 flags.push(ElementFlags.Variadic);             }             names.push(getNameableDeclarationAtPosition(source, i));         } */
         createTupleType(types, flags, readonly, names)
    }
    getRestOrAnyTypeAtPosition := func(source Signature, pos number) Type {
        restType := getRestTypeAtPosition(source, pos)
        elementType := /* TODO(BinaryExpression): restType && getElementTypeOfArrayType(restType) */ TODO
         /* TODO(ConditionalExpression): elementType && isTypeAny(elementType) ? anyType : restType */ TODO
    }
    getParameterCount := func(signature Signature) /* TODO(undefined): number */ TODO {
        length := /* TODO(PropertyAccessExpression): signature.parameters.length */ TODO
        if signatureHasRestParameter(signature) {
            restType := getTypeOfSymbol(/* TODO(ElementAccessExpression): signature.parameters[length - 1] */ TODO)
            if isTupleType(restType) {
                 /* TODO(BinaryExpression): length + restType.target.fixedLength - (restType.target.combinedFlags & ElementFlags.Variable ? 0 : 1) */ TODO
            }
        }
         length
    }
    getMinArgumentCount := func(signature Signature, flags MinArgumentCountFlags) /* TODO(undefined): number */ TODO {
        strongArityForUntypedJS := /* TODO(BinaryExpression): flags! & MinArgumentCountFlags.StrongArityForUntypedJS */ TODO
        voidIsNonOptional := /* TODO(BinaryExpression): flags! & MinArgumentCountFlags.VoidIsNonOptional */ TODO
        if /* TODO(BinaryExpression): voidIsNonOptional || signature.resolvedMinArgumentCount === undefined */ TODO {
            var minArgumentCount /* TODO(NumberKeyword): number */ any
            if signatureHasRestParameter(signature) {
                restType := getTypeOfSymbol(/* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
                if isTupleType(restType) {
                    firstOptionalIndex := findIndex(/* TODO(PropertyAccessExpression): restType.target.elementFlags */ TODO, /* TODO(ArrowFunction): f => !(f & ElementFlags.Required) */ TODO)
                    requiredCount := /* TODO(ConditionalExpression): firstOptionalIndex < 0 ? restType.target.fixedLength : firstOptionalIndex */ TODO
                    if /* TODO(BinaryExpression): requiredCount > 0 */ TODO {
                        /* TODO(ExpressionStatement): minArgumentCount = signature.parameters.length - 1 + requiredCount; */
                    }
                }
            }
            if /* TODO(BinaryExpression): minArgumentCount === undefined */ TODO {
                if /* TODO(BinaryExpression): !strongArityForUntypedJS && signature.flags & SignatureFlags.IsUntypedSignatureInJSFile */ TODO {
                     0
                }
                /* TODO(ExpressionStatement): minArgumentCount = signature.minArgumentCount; */
            }
            if voidIsNonOptional {
                 minArgumentCount
            }
            /* TODO(ForStatement): for (let i = minArgumentCount - 1; i >= 0; i--) {                 const type = getTypeAtPosition(signature, i);                 if (filterType(type, acceptsVoid).flags & TypeFlags.Never) {                     break;                 }                 minArgumentCount = i;             } */
            /* TODO(ExpressionStatement): signature.resolvedMinArgumentCount = minArgumentCount; */
        }
         /* TODO(PropertyAccessExpression): signature.resolvedMinArgumentCount */ TODO
    }
    hasEffectiveRestParameter := func(signature Signature) /* TODO(undefined): boolean */ TODO {
        if signatureHasRestParameter(signature) {
            restType := getTypeOfSymbol(/* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
             /* TODO(BinaryExpression): !isTupleType(restType) || !!(restType.target.combinedFlags & ElementFlags.Variable) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    getEffectiveRestType := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if signatureHasRestParameter(signature) {
            restType := getTypeOfSymbol(/* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
            if /* TODO(PrefixUnaryExpression): !isTupleType(restType) */ TODO {
                 /* TODO(ConditionalExpression): isTypeAny(restType) ? anyArrayType : restType */ TODO
            }
            if /* TODO(BinaryExpression): restType.target.combinedFlags & ElementFlags.Variable */ TODO {
                 sliceTupleType(restType, /* TODO(PropertyAccessExpression): restType.target.fixedLength */ TODO)
            }
        }
         undefined
    }
    getNonArrayRestType := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        restType := getEffectiveRestType(signature)
         /* TODO(ConditionalExpression): restType && !isArrayType(restType) && !isTypeAny(restType) ? restType : undefined */ TODO
    }
    getTypeOfFirstParameterOfSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         getTypeOfFirstParameterOfSignatureWithFallback(signature, neverType)
    }
    getTypeOfFirstParameterOfSignatureWithFallback := func(signature Signature, fallbackType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): signature.parameters.length > 0 ? getTypeAtPosition(signature, 0) : fallbackType */ TODO
    }
    inferFromAnnotatedParameters := func(signature Signature, context Signature, inferenceContext InferenceContext) {
        len := /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
        /* TODO(ForStatement): for (let i = 0; i < len; i++) {             const declaration = signature.parameters[i].valueDeclaration as ParameterDeclaration;             const typeNode = getEffectiveTypeAnnotationNode(declaration);             if (typeNode) {                 const source = addOptionality(getTypeFromTypeNode(typeNode), /*isProperty* / false, isOptionalDeclaration(declaration));                 const target = getTypeAtPosition(context, i);                 inferTypes(inferenceContext.inferences, source, target);             }         } */
    }
    assignContextualParameterTypes := func(signature Signature, context Signature) {
        if /* TODO(PropertyAccessExpression): context.typeParameters */ TODO {
            if /* TODO(PrefixUnaryExpression): !signature.typeParameters */ TODO {
                /* TODO(ExpressionStatement): signature.typeParameters = context.typeParameters; */
            } else {

            }
        }
        if /* TODO(PropertyAccessExpression): context.thisParameter */ TODO {
            parameter := /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO
            if /* TODO(BinaryExpression): !parameter || parameter.valueDeclaration && !(parameter.valueDeclaration as ParameterDeclaration).type */ TODO {
                if /* TODO(PrefixUnaryExpression): !parameter */ TODO {
                    /* TODO(ExpressionStatement): signature.thisParameter = createSymbolWithType(context.thisParameter, /*type* / undefined); */
                }
                /* TODO(ExpressionStatement): assignParameterType(signature.thisParameter!, getTypeOfSymbol(context.thisParameter)); */
            }
        }
        len := /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
        /* TODO(ForStatement): for (let i = 0; i < len; i++) {             const parameter = signature.parameters[i];             const declaration = parameter.valueDeclaration as ParameterDeclaration;             if (!getEffectiveTypeAnnotationNode(declaration)) {                 let type = tryGetTypeAtPosition(context, i);                 if (type && declaration.initializer) {                     let initializerType = checkDeclarationInitializer(declaration, CheckMode.Normal);                     if (!isTypeAssignableTo(initializerType, type) && isTypeAssignableTo(type, initializerType = widenTypeInferredFromInitializer(declaration, initializerType))) {                         type = initializerType;                     }                 }                 assignParameterType(parameter, type);             }         } */
        if signatureHasRestParameter(signature) {
            parameter := last(/* TODO(PropertyAccessExpression): signature.parameters */ TODO)
            if /* TODO(ConditionalExpression): parameter.valueDeclaration                     ? !getEffectiveTypeAnnotationNode(parameter.valueDeclaration as ParameterDeclaration)                     // a declarationless parameter may still have a `.type` already set by its construction logic                     // (which may pull a type from a jsdoc) - only allow fixing on `DeferredType` parameters with a fallback type                     : !!(getCheckFlags(parameter) & CheckFlags.DeferredType) */ TODO {
                contextualParameterType := getRestTypeAtPosition(context, len)
                /* TODO(ExpressionStatement): assignParameterType(parameter, contextualParameterType); */
            }
        }
    }
    assignNonContextualParameterTypes := func(signature Signature) {
        if /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO {
            /* TODO(ExpressionStatement): assignParameterType(signature.thisParameter); */
        }
        /* TODO(ForOfStatement): for (const parameter of signature.parameters) {             assignParameterType(parameter);         } */
    }
    assignParameterType := func(parameter Symbol, contextualType Type) {
        links := getSymbolLinks(parameter)
        if /* TODO(PrefixUnaryExpression): !links.type */ TODO {
            declaration := /* TODO(PropertyAccessExpression): parameter.valueDeclaration */ TODO /* as */ /* TODO(UnionType): ParameterDeclaration | undefined */
            /* TODO(ExpressionStatement): links.type = addOptionality(                 contextualType || (declaration ? getWidenedTypeForVariableLikeDeclaration(declaration, /*reportErrors* / true) : getTypeOfSymbol(parameter)),                 /*isProperty* / false,                 /*isOptional* / !!declaration && !declaration.initializer && isOptionalDeclaration(declaration),             ); */
            if /* TODO(BinaryExpression): declaration && declaration.name.kind !== SyntaxKind.Identifier */ TODO {
                if /* TODO(BinaryExpression): links.type === unknownType */ TODO {
                    /* TODO(ExpressionStatement): links.type = getTypeFromBindingPattern(declaration.name); */
                }
                /* TODO(ExpressionStatement): assignBindingElementTypes(declaration.name, links.type); */
            }
        } else if contextualType {
            /* TODO(ExpressionStatement): Debug.assertEqual(links.type, contextualType, "Parameter symbol already has a cached type which differs from newly assigned type"); */
        }
    }
    assignBindingElementTypes := func(pattern BindingPattern, parentType Type) {
        /* TODO(ForOfStatement): for (const element of pattern.elements) {             if (!isOmittedExpression(element)) {                 const type = getBindingElementTypeFromParentType(element, parentType, /*noTupleBoundsCheck* / false);                 if (element.name.kind === SyntaxKind.Identifier) {                     getSymbolLinks(getSymbolOfDeclaration(element)).type = type;                 }                 else {                     assignBindingElementTypes(element.name, type);                 }             }         } */
    }
    createClassDecoratorContextType := func(classType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         tryCreateTypeReference(getGlobalClassDecoratorContextType(/* TODO(TrueKeyword): true */ TODO), /* TODO(ArrayLiteralExpression): [classType] */ TODO)
    }
    createClassMethodDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         tryCreateTypeReference(getGlobalClassMethodDecoratorContextType(/* TODO(TrueKeyword): true */ TODO), /* TODO(ArrayLiteralExpression): [thisType, valueType] */ TODO)
    }
    createClassGetterDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         tryCreateTypeReference(getGlobalClassGetterDecoratorContextType(/* TODO(TrueKeyword): true */ TODO), /* TODO(ArrayLiteralExpression): [thisType, valueType] */ TODO)
    }
    createClassSetterDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         tryCreateTypeReference(getGlobalClassSetterDecoratorContextType(/* TODO(TrueKeyword): true */ TODO), /* TODO(ArrayLiteralExpression): [thisType, valueType] */ TODO)
    }
    createClassAccessorDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         tryCreateTypeReference(getGlobalClassAccessorDecoratorContextType(/* TODO(TrueKeyword): true */ TODO), /* TODO(ArrayLiteralExpression): [thisType, valueType] */ TODO)
    }
    createClassFieldDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         tryCreateTypeReference(getGlobalClassFieldDecoratorContextType(/* TODO(TrueKeyword): true */ TODO), /* TODO(ArrayLiteralExpression): [thisType, valueType] */ TODO)
    }
    getClassMemberDecoratorContextOverrideType := func(nameType Type, isPrivate bool, isStatic bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        key := /* TODO(TemplateExpression): `${isPrivate ? "p" : "P"}${isStatic ? "s" : "S"}${nameType.id}` */ TODO /* as */ /* TODO(TypeReference): const */
        overrideType := /* TODO(PropertyAccessExpression): decoratorContextOverrideTypeCache.get */ TODO(key)
        if /* TODO(PrefixUnaryExpression): !overrideType */ TODO {
            members := createSymbolTable()
            /* TODO(ExpressionStatement): members.set("name" as __String, createProperty("name" as __String, nameType)); */
            /* TODO(ExpressionStatement): members.set("private" as __String, createProperty("private" as __String, isPrivate ? trueType : falseType)); */
            /* TODO(ExpressionStatement): members.set("static" as __String, createProperty("static" as __String, isStatic ? trueType : falseType)); */
            /* TODO(ExpressionStatement): overrideType = createAnonymousType(/*symbol* / undefined, members, emptyArray, emptyArray, emptyArray); */
            /* TODO(ExpressionStatement): decoratorContextOverrideTypeCache.set(key, overrideType); */
        }
         overrideType
    }
    createClassMemberDecoratorContextTypeForNode := func(node /* TODO(UnionType): MethodDeclaration | AccessorDeclaration | PropertyDeclaration */ any, thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        isStatic := hasStaticModifier(node)
        isPrivate := isPrivateIdentifier(/* TODO(PropertyAccessExpression): node.name */ TODO)
        nameType := /* TODO(ConditionalExpression): isPrivate ? getStringLiteralType(idText(node.name)) : getLiteralTypeFromPropertyName(node.name) */ TODO
        contextType := /* TODO(ConditionalExpression): isMethodDeclaration(node) ? createClassMethodDecoratorContextType(thisType, valueType) :             isGetAccessorDeclaration(node) ? createClassGetterDecoratorContextType(thisType, valueType) :             isSetAccessorDeclaration(node) ? createClassSetterDecoratorContextType(thisType, valueType) :             isAutoAccessorPropertyDeclaration(node) ? createClassAccessorDecoratorContextType(thisType, valueType) :             isPropertyDeclaration(node) ? createClassFieldDecoratorContextType(thisType, valueType) :             Debug.failBadSyntaxKind(node) */ TODO
        overrideType := getClassMemberDecoratorContextOverrideType(nameType, isPrivate, isStatic)
         getIntersectionType(/* TODO(ArrayLiteralExpression): [contextType, overrideType] */ TODO)
    }
    createClassAccessorDecoratorTargetType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         tryCreateTypeReference(getGlobalClassAccessorDecoratorTargetType(/* TODO(TrueKeyword): true */ TODO), /* TODO(ArrayLiteralExpression): [thisType, valueType] */ TODO)
    }
    createClassAccessorDecoratorResultType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         tryCreateTypeReference(getGlobalClassAccessorDecoratorResultType(/* TODO(TrueKeyword): true */ TODO), /* TODO(ArrayLiteralExpression): [thisType, valueType] */ TODO)
    }
    createClassFieldDecoratorInitializerMutatorType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
        thisParam := createParameter("this" /* as */ /* TODO(TypeReference): __String */, thisType)
        valueParam := createParameter("value" /* as */ /* TODO(TypeReference): __String */, valueType)
         createFunctionType(undefined, thisParam, /* TODO(ArrayLiteralExpression): [valueParam] */ TODO, valueType, undefined, 1)
    }
    createESDecoratorCallSignature := func(targetType Type, contextType Type, nonOptionalReturnType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
        targetParam := createParameter("target" /* as */ /* TODO(TypeReference): __String */, targetType)
        contextParam := createParameter("context" /* as */ /* TODO(TypeReference): __String */, contextType)
        returnType := getUnionType(/* TODO(ArrayLiteralExpression): [nonOptionalReturnType, voidType] */ TODO)
         createCallSignature(undefined, undefined, /* TODO(ArrayLiteralExpression): [targetParam, contextParam] */ TODO, returnType)
    }
    getESDecoratorCallSignature := func(decorator Decorator) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
        TODO_IDENTIFIER := decorator
        links := getNodeLinks(parent)
        if /* TODO(PrefixUnaryExpression): !links.decoratorSignature */ TODO {
            /* TODO(ExpressionStatement): links.decoratorSignature = anySignature; */
            /* TODO(SwitchStatement): switch (parent.kind) {                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression: {                     // Class decorators have a `context` of `ClassDecoratorContext<Class>`, where the `Class` type                     // argument will be the "final type" of the class after all decorators are applied.                      const node = parent as ClassDeclaration | ClassExpression;                     const targetType = getTypeOfSymbol(getSymbolOfDeclaration(node));                     const contextType = createClassDecoratorContextType(targetType);                     links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, targetType);                     break;                 }                  case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor: {                     const node = parent as MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration;                     if (!isClassLike(node.parent)) break;                      // Method decorators have a `context` of `ClassMethodDecoratorContext<This, Value>`, where the                     // `Value` type argument corresponds to the "final type" of the method.                     //                     // Getter decorators have a `context` of `ClassGetterDecoratorContext<This, Value>`, where the                     // `Value` type argument corresponds to the "final type" of the value returned by the getter.                     //                     // Setter decorators have a `context` of `ClassSetterDecoratorContext<This, Value>`, where the                     // `Value` type argument corresponds to the "final type" of the parameter of the setter.                     //                     // In all three cases, the `This` type argument is the "final type" of either the class or                     // instance, depending on whether the member was `static`.                      const valueType = isMethodDeclaration(node) ? getOrCreateTypeFromSignature(getSignatureFromDeclaration(node)) :                         getTypeOfNode(node);                      const thisType = hasStaticModifier(node) ?                         getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) :                         getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent));                      // We wrap the "input type", if necessary, to match the decoration target. For getters this is                     // something like `() => inputType`, for setters it's `(value: inputType) => void` and for                     // methods it is just the input type.                     const targetType = isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) :                         isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) :                         valueType;                      const contextType = createClassMemberDecoratorContextTypeForNode(node, thisType, valueType);                      // We also wrap the "output type", as needed.                     const returnType = isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) :                         isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) :                         valueType;                      links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType);                     break;                 }                  case SyntaxKind.PropertyDeclaration: {                     const node = parent as PropertyDeclaration;                     if (!isClassLike(node.parent)) break;                      // Field decorators have a `context` of `ClassFieldDecoratorContext<This, Value>` and                     // auto-accessor decorators have a `context` of `ClassAccessorDecoratorContext<This, Value>. In                     // both cases, the `This` type argument is the "final type" of either the class or instance,                     // depending on whether the member was `static`, and the `Value` type argument corresponds to                     // the "final type" of the value stored in the field.                      const valueType = getTypeOfNode(node);                     const thisType = hasStaticModifier(node) ?                         getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) :                         getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent));                      // The `target` of an auto-accessor decorator is a `{ get, set }` object, representing the                     // runtime-generated getter and setter that are added to the class/prototype. The `target` of a                     // regular field decorator is always `undefined` as it isn't installed until it is initialized.                     const targetType = hasAccessorModifier(node) ? createClassAccessorDecoratorTargetType(thisType, valueType) :                         undefinedType;                      const contextType = createClassMemberDecoratorContextTypeForNode(node, thisType, valueType);                      // We wrap the "output type" depending on the declaration. For auto-accessors, we wrap the                     // "output type" in a `ClassAccessorDecoratorResult<This, In, Out>` type, which allows for                     // mutation of the runtime-generated getter and setter, as well as the injection of an                     // initializer mutator. For regular fields, we wrap the "output type" in an initializer mutator.                     const returnType = hasAccessorModifier(node) ? createClassAccessorDecoratorResultType(thisType, valueType) :                         createClassFieldDecoratorInitializerMutatorType(thisType, valueType);                      links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType);                     break;                 }             } */
        }
         /* TODO(ConditionalExpression): links.decoratorSignature === anySignature ? undefined : links.decoratorSignature */ TODO
    }
    getLegacyDecoratorCallSignature := func(decorator Decorator) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
        TODO_IDENTIFIER := decorator
        links := getNodeLinks(parent)
        if /* TODO(PrefixUnaryExpression): !links.decoratorSignature */ TODO {
            /* TODO(ExpressionStatement): links.decoratorSignature = anySignature; */
            /* TODO(SwitchStatement): switch (parent.kind) {                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression: {                     const node = parent as ClassDeclaration | ClassExpression;                     // For a class decorator, the `target` is the type of the class (e.g. the                     // "static" or "constructor" side of the class).                     const targetType = getTypeOfSymbol(getSymbolOfDeclaration(node));                     const targetParam = createParameter("target" as __String, targetType);                     links.decoratorSignature = createCallSignature(                         /*typeParameters* / undefined,                         /*thisParameter* / undefined,                         [targetParam],                         getUnionType([targetType, voidType]),                     );                     break;                 }                 case SyntaxKind.Parameter: {                     const node = parent as ParameterDeclaration;                     if (                         !isConstructorDeclaration(node.parent) &&                         !(isMethodDeclaration(node.parent) || isSetAccessorDeclaration(node.parent) && isClassLike(node.parent.parent))                     ) {                         break;                     }                      if (getThisParameter(node.parent) === node) {                         break;                     }                      const index = getThisParameter(node.parent) ?                         node.parent.parameters.indexOf(node) - 1 :                         node.parent.parameters.indexOf(node);                     Debug.assert(index >= 0);                      // A parameter declaration decorator will have three arguments (see `ParameterDecorator` in                     // core.d.ts).                      const targetType = isConstructorDeclaration(node.parent) ? getTypeOfSymbol(getSymbolOfDeclaration(node.parent.parent)) :                         getParentTypeOfClassElement(node.parent);                      const keyType = isConstructorDeclaration(node.parent) ? undefinedType :                         getClassElementPropertyKeyType(node.parent);                      const indexType = getNumberLiteralType(index);                      const targetParam = createParameter("target" as __String, targetType);                     const keyParam = createParameter("propertyKey" as __String, keyType);                     const indexParam = createParameter("parameterIndex" as __String, indexType);                     links.decoratorSignature = createCallSignature(                         /*typeParameters* / undefined,                         /*thisParameter* / undefined,                         [targetParam, keyParam, indexParam],                         voidType,                     );                     break;                 }                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                 case SyntaxKind.PropertyDeclaration: {                     const node = parent as MethodDeclaration | AccessorDeclaration | PropertyDeclaration;                     if (!isClassLike(node.parent)) break;                      // A method or accessor declaration decorator will have either two or three arguments (see                     // `PropertyDecorator` and `MethodDecorator` in core.d.ts).                      const targetType = getParentTypeOfClassElement(node);                     const targetParam = createParameter("target" as __String, targetType);                      const keyType = getClassElementPropertyKeyType(node);                     const keyParam = createParameter("propertyKey" as __String, keyType);                      const returnType = isPropertyDeclaration(node) ? voidType :                         createTypedPropertyDescriptorType(getTypeOfNode(node));                      const hasPropDesc = !isPropertyDeclaration(parent) || hasAccessorModifier(parent);                     if (hasPropDesc) {                         const descriptorType = createTypedPropertyDescriptorType(getTypeOfNode(node));                         const descriptorParam = createParameter("descriptor" as __String, descriptorType);                         links.decoratorSignature = createCallSignature(                             /*typeParameters* / undefined,                             /*thisParameter* / undefined,                             [targetParam, keyParam, descriptorParam],                             getUnionType([returnType, voidType]),                         );                     }                     else {                         links.decoratorSignature = createCallSignature(                             /*typeParameters* / undefined,                             /*thisParameter* / undefined,                             [targetParam, keyParam],                             getUnionType([returnType, voidType]),                         );                     }                     break;                 }             } */
        }
         /* TODO(ConditionalExpression): links.decoratorSignature === anySignature ? undefined : links.decoratorSignature */ TODO
    }
    getDecoratorCallSignature := func(decorator Decorator) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
         /* TODO(ConditionalExpression): legacyDecorators ? getLegacyDecoratorCallSignature(decorator) :             getESDecoratorCallSignature(decorator) */ TODO
    }
    createPromiseType := func(promisedType Type) Type {
        globalPromiseType := getGlobalPromiseType(/* TODO(TrueKeyword): true */ TODO)
        if /* TODO(BinaryExpression): globalPromiseType !== emptyGenericType */ TODO {
            /* TODO(ExpressionStatement): promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType; */
             createTypeReference(globalPromiseType, /* TODO(ArrayLiteralExpression): [promisedType] */ TODO)
        }
         unknownType
    }
    createPromiseLikeType := func(promisedType Type) Type {
        globalPromiseLikeType := getGlobalPromiseLikeType(/* TODO(TrueKeyword): true */ TODO)
        if /* TODO(BinaryExpression): globalPromiseLikeType !== emptyGenericType */ TODO {
            /* TODO(ExpressionStatement): promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType; */
             createTypeReference(globalPromiseLikeType, /* TODO(ArrayLiteralExpression): [promisedType] */ TODO)
        }
         unknownType
    }
    createPromiseReturnType := func(func_ /* TODO(UnionType): FunctionLikeDeclaration | ImportCall */ any, promisedType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        promiseType := createPromiseType(promisedType)
        if /* TODO(BinaryExpression): promiseType === unknownType */ TODO {
            /* TODO(ExpressionStatement): error(                 func,                 isImportCall(func) ?                     Diagnostics.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option :                     Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option,             ); */
             errorType
        } else if /* TODO(PrefixUnaryExpression): !getGlobalPromiseConstructorSymbol(/*reportErrors* / true) */ TODO {
            /* TODO(ExpressionStatement): error(                 func,                 isImportCall(func) ?                     Diagnostics.A_dynamic_import_call_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option :                     Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option,             ); */
        }
         promiseType
    }
    createNewTargetExpressionType := func(targetType Type) Type {
        symbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.None */ TODO, "NewTargetExpression" /* as */ /* TODO(TypeReference): __String */)
        targetPropertySymbol := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "target" /* as */ /* TODO(TypeReference): __String */, /* TODO(PropertyAccessExpression): CheckFlags.Readonly */ TODO)
        /* TODO(ExpressionStatement): targetPropertySymbol.parent = symbol; */
        /* TODO(ExpressionStatement): targetPropertySymbol.links.type = targetType; */
        members := createSymbolTable(/* TODO(ArrayLiteralExpression): [targetPropertySymbol] */ TODO)
        /* TODO(ExpressionStatement): symbol.members = members; */
         createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
    }
    getReturnTypeFromBody := func(func_ FunctionLikeDeclaration, checkMode CheckMode) Type {
        if /* TODO(PrefixUnaryExpression): !func.body */ TODO {
             errorType
        }
        functionFlags := getFunctionFlags(func_)
        isAsync := /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */ TODO
        isGenerator := /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Generator) !== 0 */ TODO
        var returnType *Type
        var yieldType *Type
        var nextType *Type
        var fallbackReturnType Type = voidType
        if /* TODO(BinaryExpression): func.body.kind !== SyntaxKind.Block */ TODO {
            /* TODO(ExpressionStatement): returnType = checkExpressionCached(func.body, checkMode && checkMode & ~CheckMode.SkipGenericFunctions); */
            if isAsync {
                /* TODO(ExpressionStatement): returnType = unwrapAwaitedType(checkAwaitedType(returnType, /*withAlias* / false, /*errorNode* / func, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)); */
            }
        } else if isGenerator {
            returnTypes := checkAndAggregateReturnExpressionTypes(func_, checkMode)
            if /* TODO(PrefixUnaryExpression): !returnTypes */ TODO {
                /* TODO(ExpressionStatement): fallbackReturnType = neverType; */
            } else if /* TODO(BinaryExpression): returnTypes.length > 0 */ TODO {
                /* TODO(ExpressionStatement): returnType = getUnionType(returnTypes, UnionReduction.Subtype); */
            }
            TODO_IDENTIFIER := checkAndAggregateYieldOperandTypes(func_, checkMode)
            /* TODO(ExpressionStatement): yieldType = some(yieldTypes) ? getUnionType(yieldTypes, UnionReduction.Subtype) : undefined; */
            /* TODO(ExpressionStatement): nextType = some(nextTypes) ? getIntersectionType(nextTypes) : undefined; */
        } else {
            types := checkAndAggregateReturnExpressionTypes(func_, checkMode)
            if /* TODO(PrefixUnaryExpression): !types */ TODO {
                 /* TODO(ConditionalExpression): functionFlags & FunctionFlags.Async                     ? createPromiseReturnType(func, neverType) // Async function                     : neverType */ TODO
            }
            if /* TODO(BinaryExpression): types.length === 0 */ TODO {
                contextualReturnType := getContextualReturnType(func_, undefined)
                returnType := /* TODO(ConditionalExpression): contextualReturnType && (unwrapReturnType(contextualReturnType, functionFlags) || voidType).flags & TypeFlags.Undefined ? undefinedType : voidType */ TODO
                 /* TODO(ConditionalExpression): functionFlags & FunctionFlags.Async ? createPromiseReturnType(func, returnType) : // Async function                     returnType */ TODO
            }
            /* TODO(ExpressionStatement): returnType = getUnionType(types, UnionReduction.Subtype); */
        }
        if /* TODO(BinaryExpression): returnType || yieldType || nextType */ TODO {
            if yieldType {
                /* TODO(CallExpression): reportErrorsFromWidening(func, yieldType, WideningKind.GeneratorYield) */
            }
            if returnType {
                /* TODO(CallExpression): reportErrorsFromWidening(func, returnType, WideningKind.FunctionReturn) */
            }
            if nextType {
                /* TODO(CallExpression): reportErrorsFromWidening(func, nextType, WideningKind.GeneratorNext) */
            }
            if /* TODO(BinaryExpression): returnType && isUnitType(returnType) ||                 yieldType && isUnitType(yieldType) ||                 nextType && isUnitType(nextType) */ TODO {
                contextualSignature := getContextualSignatureForFunctionLikeDeclaration(func_)
                contextualType := /* TODO(ConditionalExpression): !contextualSignature ? undefined :                     contextualSignature === getSignatureFromDeclaration(func) ? isGenerator ? undefined : returnType :                     instantiateContextualType(getReturnTypeOfSignature(contextualSignature), func, /*contextFlags* / undefined) */ TODO
                if isGenerator {
                    /* TODO(ExpressionStatement): yieldType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(yieldType, contextualType, IterationTypeKind.Yield, isAsync); */
                    /* TODO(ExpressionStatement): returnType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(returnType, contextualType, IterationTypeKind.Return, isAsync); */
                    /* TODO(ExpressionStatement): nextType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(nextType, contextualType, IterationTypeKind.Next, isAsync); */
                } else {
                    /* TODO(ExpressionStatement): returnType = getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(returnType, contextualType, isAsync); */
                }
            }
            if yieldType {
                /* TODO(BinaryExpression): yieldType = getWidenedType(yieldType) */
            }
            if returnType {
                /* TODO(BinaryExpression): returnType = getWidenedType(returnType) */
            }
            if nextType {
                /* TODO(BinaryExpression): nextType = getWidenedType(nextType) */
            }
        }
        if isGenerator {
             createGeneratorType(/* TODO(BinaryExpression): yieldType || neverType */ TODO, /* TODO(BinaryExpression): returnType || fallbackReturnType */ TODO, /* TODO(BinaryExpression): nextType || getContextualIterationType(IterationTypeKind.Next, func) || unknownType */ TODO, isAsync)
        } else {
             /* TODO(ConditionalExpression): isAsync                 ? createPromiseType(returnType || fallbackReturnType)                 : returnType || fallbackReturnType */ TODO
        }
    }
    createGeneratorType := func(yieldType Type, returnType Type, nextType Type, isAsyncGenerator bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
        resolver := /* TODO(ConditionalExpression): isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver */ TODO
        globalGeneratorType := /* TODO(PropertyAccessExpression): resolver.getGlobalGeneratorType */ TODO(/* TODO(FalseKeyword): false */ TODO)
        /* TODO(ExpressionStatement): yieldType = resolver.resolveIterationType(yieldType, /*errorNode* / undefined) || unknownType; */
        /* TODO(ExpressionStatement): returnType = resolver.resolveIterationType(returnType, /*errorNode* / undefined) || unknownType; */
        if /* TODO(BinaryExpression): globalGeneratorType === emptyGenericType */ TODO {
            globalIterableIteratorType := /* TODO(PropertyAccessExpression): resolver.getGlobalIterableIteratorType */ TODO(/* TODO(FalseKeyword): false */ TODO)
            if /* TODO(BinaryExpression): globalIterableIteratorType !== emptyGenericType */ TODO {
                 createTypeFromGenericGlobalType(globalIterableIteratorType, /* TODO(ArrayLiteralExpression): [yieldType, returnType, nextType] */ TODO)
            }
            /* TODO(ExpressionStatement): resolver.getGlobalIterableIteratorType(/*reportErrors* / true); */
             emptyObjectType
        }
         createTypeFromGenericGlobalType(globalGeneratorType, /* TODO(ArrayLiteralExpression): [yieldType, returnType, nextType] */ TODO)
    }
    checkAndAggregateYieldOperandTypes := func(func_ FunctionLikeDeclaration, checkMode *CheckMode) /* TODO(undefined): { yieldTypes: import("/home/jabaile/work/TypeScript/src/compiler/types").Type[]; nextTypes: import("/home/jabaile/work/TypeScript/src/compiler/types").Type[]; } */ TODO {
        var yieldTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        var nextTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        isAsync := /* TODO(BinaryExpression): (getFunctionFlags(func) & FunctionFlags.Async) !== 0 */ TODO
        /* TODO(ExpressionStatement): forEachYieldExpression(func.body as Block, yieldExpression => {             const yieldExpressionType = yieldExpression.expression ? checkExpression(yieldExpression.expression, checkMode) : undefinedWideningType;             pushIfUnique(yieldTypes, getYieldedTypeOfYieldExpression(yieldExpression, yieldExpressionType, anyType, isAsync));             let nextType: Type | undefined;             if (yieldExpression.asteriskToken) {                 const iterationTypes = getIterationTypesOfIterable(                     yieldExpressionType,                     isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar,                     yieldExpression.expression,                 );                 nextType = iterationTypes && iterationTypes.nextType;             }             else {                 nextType = getContextualType(yieldExpression, /*contextFlags* / undefined);             }             if (nextType) pushIfUnique(nextTypes, nextType);         }); */
         /* TODO(ObjectLiteralExpression): { yieldTypes, nextTypes } */ TODO
    }
    getYieldedTypeOfYieldExpression := func(node YieldExpression, expressionType Type, sentType Type, isAsync bool) *Type {
        errorNode := /* TODO(BinaryExpression): node.expression || node */ TODO
        yieldedType := /* TODO(ConditionalExpression): node.asteriskToken ? checkIteratedTypeOrElementType(isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar, expressionType, sentType, errorNode) : expressionType */ TODO
         /* TODO(ConditionalExpression): !isAsync ? yieldedType : getAwaitedType(             yieldedType,             errorNode,             node.asteriskToken                 ? Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member                 : Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,         ) */ TODO
    }
    getNotEqualFactsFromTypeofSwitch := func(start number, end number, witnesses []/* TODO(StringKeyword): string */ any) TypeFacts {
        var facts TypeFacts = /* TODO(PropertyAccessExpression): TypeFacts.None */ TODO
        /* TODO(ForStatement): for (let i = 0; i < witnesses.length; i++) {             const witness = i < start || i >= end ? witnesses[i] : undefined;             facts |= witness !== undefined ? typeofNEFacts.get(witness) || TypeFacts.TypeofNEHostObject : 0;         } */
         facts
    }
    isExhaustiveSwitchStatement := func(node SwitchStatement) bool {
        links := getNodeLinks(node)
        if /* TODO(BinaryExpression): links.isExhaustive === undefined */ TODO {
            /* TODO(ExpressionStatement): links.isExhaustive = 0; */
            exhaustive := computeExhaustiveSwitchStatement(node)
            if /* TODO(BinaryExpression): links.isExhaustive === 0 */ TODO {
                /* TODO(ExpressionStatement): links.isExhaustive = exhaustive; */
            }
        } else if /* TODO(BinaryExpression): links.isExhaustive === 0 */ TODO {
            /* TODO(ExpressionStatement): links.isExhaustive = false; */
        }
         /* TODO(PropertyAccessExpression): links.isExhaustive */ TODO
    }
    computeExhaustiveSwitchStatement := func(node SwitchStatement) bool {
        if /* TODO(BinaryExpression): node.expression.kind === SyntaxKind.TypeOfExpression */ TODO {
            witnesses := getSwitchClauseTypeOfWitnesses(node)
            if /* TODO(PrefixUnaryExpression): !witnesses */ TODO {
                 /* TODO(FalseKeyword): false */ TODO
            }
            operandConstraint := getBaseConstraintOrType(checkExpressionCached(/* TODO(PropertyAccessExpression): (node.expression as TypeOfExpression).expression */ TODO))
            notEqualFacts := getNotEqualFactsFromTypeofSwitch(0, 0, witnesses)
            if /* TODO(BinaryExpression): operandConstraint.flags & TypeFlags.AnyOrUnknown */ TODO {
                 /* TODO(BinaryExpression): (TypeFacts.AllTypeofNE & notEqualFacts) === TypeFacts.AllTypeofNE */ TODO
            }
             /* TODO(PrefixUnaryExpression): !someType(operandConstraint, t => getTypeFacts(t, notEqualFacts) === notEqualFacts) */ TODO
        }
        type_ := checkExpressionCached(/* TODO(PropertyAccessExpression): node.expression */ TODO)
        if /* TODO(PrefixUnaryExpression): !isLiteralType(type) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        switchTypes := getSwitchClauseTypes(node)
        if /* TODO(BinaryExpression): !switchTypes.length || some(switchTypes, isNeitherUnitTypeNorNever) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
         eachTypeContainedIn(mapType(type_, getRegularTypeOfLiteralType), switchTypes)
    }
    functionHasImplicitReturn := func(func_ FunctionLikeDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
         /* TODO(BinaryExpression): func.endFlowNode && isReachableFlowNode(func.endFlowNode) */ TODO
    }
    checkAndAggregateReturnExpressionTypes := func(func_ FunctionLikeDeclaration, checkMode *CheckMode) /* TODO(ArrayType): Type[] */ any {
        functionFlags := getFunctionFlags(func_)
        var aggregatedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
        hasReturnWithNoExpression := functionHasImplicitReturn(func_)
        hasReturnOfTypeNever := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ExpressionStatement): forEachReturnStatement(func.body as Block, returnStatement => {             let expr = returnStatement.expression;             if (expr) {                 expr = skipParentheses(expr, /*excludeJSDocTypeAssertions* / true);                 // Bare calls to this same function don't contribute to inference                 // and `return await` is also safe to unwrap here                 if (functionFlags & FunctionFlags.Async && expr.kind === SyntaxKind.AwaitExpression) {                     expr = skipParentheses((expr as AwaitExpression).expression, /*excludeJSDocTypeAssertions* / true);                 }                 if (                     expr.kind === SyntaxKind.CallExpression &&                     (expr as CallExpression).expression.kind === SyntaxKind.Identifier &&                     checkExpressionCached((expr as CallExpression).expression).symbol === getMergedSymbol(func.symbol) &&                     (!isFunctionExpressionOrArrowFunction(func.symbol.valueDeclaration!) || isConstantReference((expr as CallExpression).expression))                 ) {                     hasReturnOfTypeNever = true;                     return;                 }                  let type = checkExpressionCached(expr, checkMode && checkMode & ~CheckMode.SkipGenericFunctions);                 if (functionFlags & FunctionFlags.Async) {                     // From within an async function you can return either a non-promise value or a promise. Any                     // Promise/A+ compatible implementation will always assimilate any foreign promise, so the                     // return type of the body should be unwrapped to its awaited type, which should be wrapped in                     // the native Promise<T> type by the caller.                     type = unwrapAwaitedType(checkAwaitedType(type, /*withAlias* / false, func, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member));                 }                 if (type.flags & TypeFlags.Never) {                     hasReturnOfTypeNever = true;                 }                 pushIfUnique(aggregatedTypes, type);             }             else {                 hasReturnWithNoExpression = true;             }         }); */
        if /* TODO(BinaryExpression): aggregatedTypes.length === 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever || mayReturnNever(func)) */ TODO {
             undefined
        }
        if /* TODO(BinaryExpression): strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression &&             !(isJSConstructor(func) && aggregatedTypes.some(t => t.symbol === func.symbol)) */ TODO {
            /* TODO(ExpressionStatement): pushIfUnique(aggregatedTypes, undefinedType); */
        }
         aggregatedTypes
    }
    mayReturnNever := func(func_ FunctionLikeDeclaration) bool {
        /* TODO(SwitchStatement): switch (func.kind) {             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:                 return true;             case SyntaxKind.MethodDeclaration:                 return func.parent.kind === SyntaxKind.ObjectLiteralExpression;             default:                 return false;         } */
    }
    getTypePredicateFromBody := func(func_ FunctionLikeDeclaration) *TypePredicate {
        /* TODO(SwitchStatement): switch (func.kind) {             case SyntaxKind.Constructor:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 return undefined;         } */
        functionFlags := getFunctionFlags(func_)
        if /* TODO(BinaryExpression): functionFlags !== FunctionFlags.Normal */ TODO {
            /* TODO(Identifier): undefined */
        }
        var singleReturn *Expression
        if /* TODO(BinaryExpression): func.body && func.body.kind !== SyntaxKind.Block */ TODO {
            /* TODO(ExpressionStatement): singleReturn = func.body; */
        } else {
            bailedEarly := forEachReturnStatement(/* TODO(PropertyAccessExpression): func.body */ TODO /* as */ /* TODO(TypeReference): Block */, /* TODO(ArrowFunction): returnStatement => {                 if (singleReturn || !returnStatement.expression) return true;                 singleReturn = returnStatement.expression;             } */ TODO)
            if /* TODO(BinaryExpression): bailedEarly || !singleReturn || functionHasImplicitReturn(func) */ TODO {
                /* TODO(Identifier): undefined */
            }
        }
         checkIfExpressionRefinesAnyParameter(func_, singleReturn)
    }
    checkIfExpressionRefinesAnyParameter := func(func_ FunctionLikeDeclaration, expr Expression) *TypePredicate {
        /* TODO(ExpressionStatement): expr = skipParentheses(expr, /*excludeJSDocTypeAssertions* / true); */
        returnType := checkExpressionCached(expr)
        if /* TODO(PrefixUnaryExpression): !(returnType.flags & TypeFlags.Boolean) */ TODO {
            /* TODO(Identifier): undefined */
        }
         forEach(/* TODO(PropertyAccessExpression): func.parameters */ TODO, /* TODO(ArrowFunction): (param, i) => {             const initType = getTypeOfSymbol(param.symbol);             if (!initType || initType.flags & TypeFlags.Boolean || !isIdentifier(param.name) || isSymbolAssigned(param.symbol) || isRestParameter(param)) {                 // Refining "x: boolean" to "x is true" or "x is false" isn't useful.                 return;             }             const trueType = checkIfExpressionRefinesParameter(func, expr, param, initType);             if (trueType) {                 return createTypePredicate(TypePredicateKind.Identifier, unescapeLeadingUnderscores(param.name.escapedText), i, trueType);             }         } */ TODO)
    }
    checkIfExpressionRefinesParameter := func(func_ FunctionLikeDeclaration, expr Expression, param ParameterDeclaration, initType Type) *Type {
        antecedent := /* TODO(BinaryExpression): (expr as Expression & { flowNode?: FlowNode; }).flowNode ||             expr.parent.kind === SyntaxKind.ReturnStatement && (expr.parent as ReturnStatement).flowNode ||             createFlowNode(FlowFlags.Start, /*node* / undefined, /*antecedent* / undefined) */ TODO
        trueCondition := createFlowNode(/* TODO(PropertyAccessExpression): FlowFlags.TrueCondition */ TODO, expr, antecedent)
        trueType := getFlowTypeOfReference(/* TODO(PropertyAccessExpression): param.name */ TODO, initType, initType, func_, trueCondition)
        if /* TODO(BinaryExpression): trueType === initType */ TODO {
            /* TODO(Identifier): undefined */
        }
        falseCondition := createFlowNode(/* TODO(PropertyAccessExpression): FlowFlags.FalseCondition */ TODO, expr, antecedent)
        falseSubtype := getFlowTypeOfReference(/* TODO(PropertyAccessExpression): param.name */ TODO, initType, trueType, func_, falseCondition)
         /* TODO(ConditionalExpression): falseSubtype.flags & TypeFlags.Never ? trueType : undefined */ TODO
    }
    checkAllCodePathsInNonVoidFunctionReturnOrThrow := func(func_ /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any, returnType *Type) {
        /* TODO(ExpressionStatement): addLazyDiagnostic(checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics); */

        checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics := func() {
            functionFlags := getFunctionFlags(func_)
            type_ := /* TODO(BinaryExpression): returnType && unwrapReturnType(returnType, functionFlags) */ TODO
            if /* TODO(BinaryExpression): type && (maybeTypeOfKind(type, TypeFlags.Void) || type.flags & (TypeFlags.Any | TypeFlags.Undefined)) */ TODO {

            }
            if /* TODO(BinaryExpression): func.kind === SyntaxKind.MethodSignature || nodeIsMissing(func.body) || func.body!.kind !== SyntaxKind.Block || !functionHasImplicitReturn(func) */ TODO {

            }
            hasExplicitReturn := /* TODO(BinaryExpression): func.flags & NodeFlags.HasExplicitReturn */ TODO
            errorNode := /* TODO(BinaryExpression): getEffectiveReturnTypeNode(func) || func */ TODO
            if /* TODO(BinaryExpression): type && type.flags & TypeFlags.Never */ TODO {
                /* TODO(ExpressionStatement): error(errorNode, Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point); */
            } else if /* TODO(BinaryExpression): type && !hasExplicitReturn */ TODO {
                /* TODO(ExpressionStatement): error(errorNode, Diagnostics.A_function_whose_declared_type_is_neither_undefined_void_nor_any_must_return_a_value); */
            } else if /* TODO(BinaryExpression): type && strictNullChecks && !isTypeAssignableTo(undefinedType, type) */ TODO {
                /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined); */
            } else if /* TODO(PropertyAccessExpression): compilerOptions.noImplicitReturns */ TODO {
                if /* TODO(PrefixUnaryExpression): !type */ TODO {
                    if /* TODO(PrefixUnaryExpression): !hasExplicitReturn */ TODO {

                    }
                    inferredReturnType := getReturnTypeOfSignature(getSignatureFromDeclaration(func_))
                    if isUnwrappedReturnTypeUndefinedVoidOrAny(func_, inferredReturnType) {

                    }
                }
                /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Not_all_code_paths_return_a_value); */
            }
        }
    }
    checkFunctionExpressionOrObjectLiteralMethod := func(node /* TODO(UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) Type {
        /* TODO(ExpressionStatement): Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(node)); */
        /* TODO(ExpressionStatement): checkNodeDeferred(node); */
        if isFunctionExpression(node) {
            /* TODO(ExpressionStatement): checkCollisionsForDeclarationName(node, node.name); */
        }
        if /* TODO(BinaryExpression): checkMode && checkMode & CheckMode.SkipContextSensitive && isContextSensitive(node) */ TODO {
            if /* TODO(BinaryExpression): !getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(node) */ TODO {
                contextualSignature := getContextualSignature(node)
                if /* TODO(BinaryExpression): contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature)) */ TODO {
                    links := getNodeLinks(node)
                    if /* TODO(PropertyAccessExpression): links.contextFreeType */ TODO {
                         /* TODO(PropertyAccessExpression): links.contextFreeType */ TODO
                    }
                    returnType := getReturnTypeFromBody(node, checkMode)
                    returnOnlySignature := createSignature(undefined, undefined, undefined, emptyArray, returnType, undefined, 0, /* TODO(PropertyAccessExpression): SignatureFlags.IsNonInferrable */ TODO)
                    returnOnlyType := createAnonymousType(/* TODO(PropertyAccessExpression): node.symbol */ TODO, emptySymbols, /* TODO(ArrayLiteralExpression): [returnOnlySignature] */ TODO, emptyArray, emptyArray)
                    /* TODO(ExpressionStatement): returnOnlyType.objectFlags |= ObjectFlags.NonInferrableType; */
                     /* TODO(BinaryExpression): links.contextFreeType = returnOnlyType */ TODO
                }
            }
             anyFunctionType
        }
        hasGrammarError := checkGrammarFunctionLikeDeclaration(node)
        if /* TODO(BinaryExpression): !hasGrammarError && node.kind === SyntaxKind.FunctionExpression */ TODO {
            /* TODO(ExpressionStatement): checkGrammarForGenerator(node); */
        }
        /* TODO(ExpressionStatement): contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode); */
         getTypeOfSymbol(getSymbolOfDeclaration(node))
    }
    contextuallyCheckFunctionExpressionOrObjectLiteralMethod := func(node /* TODO(UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !(links.flags & NodeCheckFlags.ContextChecked) */ TODO {
            contextualSignature := getContextualSignature(node)
            if /* TODO(PrefixUnaryExpression): !(links.flags & NodeCheckFlags.ContextChecked) */ TODO {
                /* TODO(ExpressionStatement): links.flags |= NodeCheckFlags.ContextChecked; */
                signature := firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node)), /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO))
                if /* TODO(PrefixUnaryExpression): !signature */ TODO {

                }
                if isContextSensitive(node) {
                    if contextualSignature {
                        inferenceContext := getInferenceContext(node)
                        var instantiatedContextualSignature *Signature
                        if /* TODO(BinaryExpression): checkMode && checkMode & CheckMode.Inferential */ TODO {
                            /* TODO(ExpressionStatement): inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext!); */
                            restType := getEffectiveRestType(contextualSignature)
                            if /* TODO(BinaryExpression): restType && restType.flags & TypeFlags.TypeParameter */ TODO {
                                /* TODO(ExpressionStatement): instantiatedContextualSignature = instantiateSignature(contextualSignature, inferenceContext!.nonFixingMapper); */
                            }
                        }
                        /* TODO(ExpressionStatement): instantiatedContextualSignature ||= inferenceContext ?                             instantiateSignature(contextualSignature, inferenceContext.mapper) : contextualSignature; */
                        /* TODO(ExpressionStatement): assignContextualParameterTypes(signature, instantiatedContextualSignature); */
                    } else {
                        /* TODO(ExpressionStatement): assignNonContextualParameterTypes(signature); */
                    }
                } else if /* TODO(BinaryExpression): contextualSignature && !node.typeParameters && contextualSignature.parameters.length > node.parameters.length */ TODO {
                    inferenceContext := getInferenceContext(node)
                    if /* TODO(BinaryExpression): checkMode && checkMode & CheckMode.Inferential */ TODO {
                        /* TODO(ExpressionStatement): inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext!); */
                    }
                }
                if /* TODO(BinaryExpression): contextualSignature && !getReturnTypeFromAnnotation(node) && !signature.resolvedReturnType */ TODO {
                    returnType := getReturnTypeFromBody(node, checkMode)
                    if /* TODO(PrefixUnaryExpression): !signature.resolvedReturnType */ TODO {
                        /* TODO(ExpressionStatement): signature.resolvedReturnType = returnType; */
                    }
                }
                /* TODO(ExpressionStatement): checkSignatureDeclaration(node); */
            }
        }
    }
    checkFunctionExpressionOrObjectLiteralMethodDeferred := func(node /* TODO(UnionType): ArrowFunction | FunctionExpression | MethodDeclaration */ any) {
        /* TODO(ExpressionStatement): Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(node)); */
        functionFlags := getFunctionFlags(node)
        returnType := getReturnTypeFromAnnotation(node)
        /* TODO(ExpressionStatement): checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType); */
        if /* TODO(PropertyAccessExpression): node.body */ TODO {
            if /* TODO(PrefixUnaryExpression): !getEffectiveReturnTypeNode(node) */ TODO {
                /* TODO(ExpressionStatement): getReturnTypeOfSignature(getSignatureFromDeclaration(node)); */
            }
            if /* TODO(BinaryExpression): node.body.kind === SyntaxKind.Block */ TODO {
                /* TODO(ExpressionStatement): checkSourceElement(node.body); */
            } else {
                exprType := checkExpression(/* TODO(PropertyAccessExpression): node.body */ TODO)
                returnOrPromisedType := /* TODO(BinaryExpression): returnType && unwrapReturnType(returnType, functionFlags) */ TODO
                if returnOrPromisedType {
                    effectiveCheckNode := getEffectiveCheckNode(/* TODO(PropertyAccessExpression): node.body */ TODO)
                    if /* TODO(BinaryExpression): (functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.Async */ TODO {
                        awaitedType := checkAwaitedType(exprType, /* TODO(FalseKeyword): false */ TODO, effectiveCheckNode, /* TODO(PropertyAccessExpression): Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member */ TODO)
                        /* TODO(ExpressionStatement): checkTypeAssignableToAndOptionallyElaborate(awaitedType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode); */
                    } else {
                        /* TODO(ExpressionStatement): checkTypeAssignableToAndOptionallyElaborate(exprType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode); */
                    }
                }
            }
        }
    }
    checkArithmeticOperandType := func(operand Node, type_ Type, diagnostic DiagnosticMessage, isAwaitValid /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) bool {
        if /* TODO(PrefixUnaryExpression): !isTypeAssignableTo(type, numberOrBigIntType) */ TODO {
            awaitedType := /* TODO(BinaryExpression): isAwaitValid && getAwaitedTypeOfPromise(type) */ TODO
            /* TODO(ExpressionStatement): errorAndMaybeSuggestAwait(                 operand,                 !!awaitedType && isTypeAssignableTo(awaitedType, numberOrBigIntType),                 diagnostic,             ); */
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(TrueKeyword): true */ TODO
    }
    isReadonlyAssignmentDeclaration := func(d Declaration) /* TODO(undefined): boolean */ TODO {
        if /* TODO(PrefixUnaryExpression): !isCallExpression(d) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(PrefixUnaryExpression): !isBindableObjectDefinePropertyCall(d) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        objectLitType := checkExpressionCached(/* TODO(ElementAccessExpression): d.arguments[2] */ TODO)
        valueType := getTypeOfPropertyOfType(objectLitType, "value" /* as */ /* TODO(TypeReference): __String */)
        if valueType {
            writableProp := getPropertyOfType(objectLitType, "writable" /* as */ /* TODO(TypeReference): __String */)
            writableType := /* TODO(BinaryExpression): writableProp && getTypeOfSymbol(writableProp) */ TODO
            if /* TODO(BinaryExpression): !writableType || writableType === falseType || writableType === regularFalseType */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            if /* TODO(BinaryExpression): writableProp && writableProp.valueDeclaration && isPropertyAssignment(writableProp.valueDeclaration) */ TODO {
                initializer := /* TODO(PropertyAccessExpression): writableProp.valueDeclaration.initializer */ TODO
                rawOriginalType := checkExpression(initializer)
                if /* TODO(BinaryExpression): rawOriginalType === falseType || rawOriginalType === regularFalseType */ TODO {
                     /* TODO(TrueKeyword): true */ TODO
                }
            }
             /* TODO(FalseKeyword): false */ TODO
        }
        setProp := getPropertyOfType(objectLitType, "set" /* as */ /* TODO(TypeReference): __String */)
         /* TODO(PrefixUnaryExpression): !setProp */ TODO
    }
    isReadonlySymbol := func(symbol Symbol) bool {
         /* TODO(PrefixUnaryExpression): !!(getCheckFlags(symbol) & CheckFlags.Readonly ||             symbol.flags & SymbolFlags.Property && getDeclarationModifierFlagsFromSymbol(symbol) & ModifierFlags.Readonly ||             symbol.flags & SymbolFlags.Variable && getDeclarationNodeFlagsFromSymbol(symbol) & NodeFlags.Constant ||             symbol.flags & SymbolFlags.Accessor && !(symbol.flags & SymbolFlags.SetAccessor) ||             symbol.flags & SymbolFlags.EnumMember ||             some(symbol.declarations, isReadonlyAssignmentDeclaration)) */ TODO
    }
    isAssignmentToReadonlyEntity := func(expr Expression, symbol Symbol, assignmentKind AssignmentKind) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): assignmentKind === AssignmentKind.None */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if isReadonlySymbol(symbol) {
            if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Property &&                 isAccessExpression(expr) &&                 expr.expression.kind === SyntaxKind.ThisKeyword */ TODO {
                ctor := getContainingFunction(expr)
                if /* TODO(PrefixUnaryExpression): !(ctor && (ctor.kind === SyntaxKind.Constructor || isJSConstructor(ctor))) */ TODO {
                     /* TODO(TrueKeyword): true */ TODO
                }
                if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
                    isAssignmentDeclaration := isBinaryExpression(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
                    isLocalPropertyDeclaration := /* TODO(BinaryExpression): ctor.parent === symbol.valueDeclaration.parent */ TODO
                    isLocalParameterProperty := /* TODO(BinaryExpression): ctor === symbol.valueDeclaration.parent */ TODO
                    isLocalThisPropertyAssignment := /* TODO(BinaryExpression): isAssignmentDeclaration && symbol.parent?.valueDeclaration === ctor.parent */ TODO
                    isLocalThisPropertyAssignmentConstructorFunction := /* TODO(BinaryExpression): isAssignmentDeclaration && symbol.parent?.valueDeclaration === ctor */ TODO
                    isWriteableSymbol := /* TODO(BinaryExpression): isLocalPropertyDeclaration                         || isLocalParameterProperty                         || isLocalThisPropertyAssignment                         || isLocalThisPropertyAssignmentConstructorFunction */ TODO
                     /* TODO(PrefixUnaryExpression): !isWriteableSymbol */ TODO
                }
            }
             /* TODO(TrueKeyword): true */ TODO
        }
        if isAccessExpression(expr) {
            node := skipParentheses(/* TODO(PropertyAccessExpression): expr.expression */ TODO)
            if /* TODO(BinaryExpression): node.kind === SyntaxKind.Identifier */ TODO {
                symbol := /* TODO(NonNullExpression): getNodeLinks(node).resolvedSymbol! */ TODO
                if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO {
                    declaration := getDeclarationOfAliasSymbol(symbol)
                     /* TODO(BinaryExpression): !!declaration && declaration.kind === SyntaxKind.NamespaceImport */ TODO
                }
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkReferenceExpression := func(expr Expression, invalidReferenceMessage DiagnosticMessage, invalidOptionalChainMessage DiagnosticMessage) bool {
        node := skipOuterExpressions(expr, /* TODO(BinaryExpression): OuterExpressionKinds.Assertions | OuterExpressionKinds.Parentheses */ TODO)
        if /* TODO(BinaryExpression): node.kind !== SyntaxKind.Identifier && !isAccessExpression(node) */ TODO {
            /* TODO(ExpressionStatement): error(expr, invalidReferenceMessage); */
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): node.flags & NodeFlags.OptionalChain */ TODO {
            /* TODO(ExpressionStatement): error(expr, invalidOptionalChainMessage); */
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(TrueKeyword): true */ TODO
    }
    checkDeleteExpression := func(node DeleteExpression) Type {
        /* TODO(ExpressionStatement): checkExpression(node.expression); */
        expr := skipParentheses(/* TODO(PropertyAccessExpression): node.expression */ TODO)
        if /* TODO(PrefixUnaryExpression): !isAccessExpression(expr) */ TODO {
            /* TODO(ExpressionStatement): error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference); */
             booleanType
        }
        if /* TODO(BinaryExpression): isPropertyAccessExpression(expr) && isPrivateIdentifier(expr.name) */ TODO {
            /* TODO(ExpressionStatement): error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_private_identifier); */
        }
        links := getNodeLinks(expr)
        symbol := getExportSymbolOfValueSymbolIfExported(/* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO)
        if symbol {
            if isReadonlySymbol(symbol) {
                /* TODO(ExpressionStatement): error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property); */
            } else {
                /* TODO(ExpressionStatement): checkDeleteExpressionMustBeOptional(expr, symbol); */
            }
        }
         booleanType
    }
    checkDeleteExpressionMustBeOptional := func(expr AccessExpression, symbol Symbol) {
        type_ := getTypeOfSymbol(symbol)
        if /* TODO(BinaryExpression): strictNullChecks &&             !(type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Never)) &&             !(exactOptionalPropertyTypes ? symbol.flags & SymbolFlags.Optional : hasTypeFacts(type, TypeFacts.IsUndefined)) */ TODO {
            /* TODO(ExpressionStatement): error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_optional); */
        }
    }
    checkTypeOfExpression := func(node TypeOfExpression) Type {
        /* TODO(ExpressionStatement): checkExpression(node.expression); */
         typeofType
    }
    checkVoidExpression := func(node VoidExpression) Type {
        /* TODO(ExpressionStatement): checkNodeDeferred(node); */
         undefinedWideningType
    }
    checkAwaitGrammar := func(node /* TODO(UnionType): AwaitExpression | VariableDeclarationList */ any) bool {
        hasError := /* TODO(FalseKeyword): false */ TODO
        container := getContainingFunctionOrClassStaticBlock(node)
        if /* TODO(BinaryExpression): container && isClassStaticBlockDeclaration(container) */ TODO {
            message := /* TODO(ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expression_cannot_be_used_inside_a_class_static_block :                 Diagnostics.await_using_statements_cannot_be_used_inside_a_class_static_block */ TODO
            /* TODO(ExpressionStatement): error(node, message); */
            /* TODO(ExpressionStatement): hasError = true; */
        } else if /* TODO(PrefixUnaryExpression): !(node.flags & NodeFlags.AwaitContext) */ TODO {
            if isInTopLevelContext(node) {
                sourceFile := getSourceFileOfNode(node)
                if /* TODO(PrefixUnaryExpression): !hasParseDiagnostics(sourceFile) */ TODO {
                    var span *TextSpan
                    if /* TODO(PrefixUnaryExpression): !isEffectiveExternalModule(sourceFile, compilerOptions) */ TODO {
                        /* TODO(ExpressionStatement): span ??= getSpanOfTokenAtPosition(sourceFile, node.pos); */
                        message := /* TODO(ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module :                             Diagnostics.await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module */ TODO
                        diagnostic := createFileDiagnostic(sourceFile, /* TODO(PropertyAccessExpression): span.start */ TODO, /* TODO(PropertyAccessExpression): span.length */ TODO, message)
                        /* TODO(ExpressionStatement): diagnostics.add(diagnostic); */
                        /* TODO(ExpressionStatement): hasError = true; */
                    }
                    /* TODO(SwitchStatement): switch (moduleKind) {                         case ModuleKind.Node16:                         case ModuleKind.NodeNext:                             if (sourceFile.impliedNodeFormat === ModuleKind.CommonJS) {                                 span ??= getSpanOfTokenAtPosition(sourceFile, node.pos);                                 diagnostics.add(                                     createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level),                                 );                                 hasError = true;                                 break;                             }                             // fallthrough                         case ModuleKind.ES2022:                         case ModuleKind.ESNext:                         case ModuleKind.Preserve:                         case ModuleKind.System:                             if (languageVersion >= ScriptTarget.ES2017) {                                 break;                             }                             // fallthrough                         default:                             span ??= getSpanOfTokenAtPosition(sourceFile, node.pos);                             const message = isAwaitExpression(node) ? Diagnostics.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher :                                 Diagnostics.Top_level_await_using_statements_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher;                             diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message));                             hasError = true;                             break;                     } */
                }
            } else {
                sourceFile := getSourceFileOfNode(node)
                if /* TODO(PrefixUnaryExpression): !hasParseDiagnostics(sourceFile) */ TODO {
                    span := getSpanOfTokenAtPosition(sourceFile, /* TODO(PropertyAccessExpression): node.pos */ TODO)
                    message := /* TODO(ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules :                         Diagnostics.await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules */ TODO
                    diagnostic := createFileDiagnostic(sourceFile, /* TODO(PropertyAccessExpression): span.start */ TODO, /* TODO(PropertyAccessExpression): span.length */ TODO, message)
                    if /* TODO(BinaryExpression): container && container.kind !== SyntaxKind.Constructor && (getFunctionFlags(container) & FunctionFlags.Async) === 0 */ TODO {
                        relatedInfo := createDiagnosticForNode(container, /* TODO(PropertyAccessExpression): Diagnostics.Did_you_mean_to_mark_this_function_as_async */ TODO)
                        /* TODO(ExpressionStatement): addRelatedInfo(diagnostic, relatedInfo); */
                    }
                    /* TODO(ExpressionStatement): diagnostics.add(diagnostic); */
                    /* TODO(ExpressionStatement): hasError = true; */
                }
            }
        }
        if /* TODO(BinaryExpression): isAwaitExpression(node) && isInParameterInitializerBeforeContainingFunction(node) */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer); */
            /* TODO(ExpressionStatement): hasError = true; */
        }
         hasError
    }
    checkAwaitExpression := func(node AwaitExpression) Type {
        /* TODO(ExpressionStatement): addLazyDiagnostic(() => checkAwaitGrammar(node)); */
        operandType := checkExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO)
        awaitedType := checkAwaitedType(operandType, /* TODO(TrueKeyword): true */ TODO, node, /* TODO(PropertyAccessExpression): Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member */ TODO)
        if /* TODO(BinaryExpression): awaitedType === operandType && !isErrorType(awaitedType) && !(operandType.flags & TypeFlags.AnyOrUnknown) */ TODO {
            /* TODO(ExpressionStatement): addErrorOrSuggestion(/*isError* / false, createDiagnosticForNode(node, Diagnostics.await_has_no_effect_on_the_type_of_this_expression)); */
        }
         awaitedType
    }
    checkPrefixUnaryExpression := func(node PrefixUnaryExpression) Type {
        operandType := checkExpression(/* TODO(PropertyAccessExpression): node.operand */ TODO)
        if /* TODO(BinaryExpression): operandType === silentNeverType */ TODO {
             silentNeverType
        }
        /* TODO(SwitchStatement): switch (node.operand.kind) {             case SyntaxKind.NumericLiteral:                 switch (node.operator) {                     case SyntaxKind.MinusToken:                         return getFreshTypeOfLiteralType(getNumberLiteralType(-(node.operand as NumericLiteral).text));                     case SyntaxKind.PlusToken:                         return getFreshTypeOfLiteralType(getNumberLiteralType(+(node.operand as NumericLiteral).text));                 }                 break;             case SyntaxKind.BigIntLiteral:                 if (node.operator === SyntaxKind.MinusToken) {                     return getFreshTypeOfLiteralType(getBigIntLiteralType({                         negative: true,                         base10Value: parsePseudoBigInt((node.operand as BigIntLiteral).text),                     }));                 }         } */
        /* TODO(SwitchStatement): switch (node.operator) {             case SyntaxKind.PlusToken:             case SyntaxKind.MinusToken:             case SyntaxKind.TildeToken:                 checkNonNullType(operandType, node.operand);                 if (maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlags.ESSymbolLike)) {                     error(node.operand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(node.operator));                 }                 if (node.operator === SyntaxKind.PlusToken) {                     if (maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlags.BigIntLike)) {                         error(node.operand, Diagnostics.Operator_0_cannot_be_applied_to_type_1, tokenToString(node.operator), typeToString(getBaseTypeOfLiteralType(operandType)));                     }                     return numberType;                 }                 return getUnaryResultType(operandType);             case SyntaxKind.ExclamationToken:                 checkTruthinessOfType(operandType, node.operand);                 const facts = getTypeFacts(operandType, TypeFacts.Truthy | TypeFacts.Falsy);                 return facts === TypeFacts.Truthy ? falseType :                     facts === TypeFacts.Falsy ? trueType :                     booleanType;             case SyntaxKind.PlusPlusToken:             case SyntaxKind.MinusMinusToken:                 const ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type);                 if (ok) {                     // run check only if former checks succeeded to avoid reporting cascading errors                     checkReferenceExpression(                         node.operand,                         Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,                         Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access,                     );                 }                 return getUnaryResultType(operandType);         } */
         errorType
    }
    checkPostfixUnaryExpression := func(node PostfixUnaryExpression) Type {
        operandType := checkExpression(/* TODO(PropertyAccessExpression): node.operand */ TODO)
        if /* TODO(BinaryExpression): operandType === silentNeverType */ TODO {
             silentNeverType
        }
        ok := checkArithmeticOperandType(/* TODO(PropertyAccessExpression): node.operand */ TODO, checkNonNullType(operandType, /* TODO(PropertyAccessExpression): node.operand */ TODO), /* TODO(PropertyAccessExpression): Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type */ TODO)
        if ok {
            /* TODO(ExpressionStatement): checkReferenceExpression(                 node.operand,                 Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,                 Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access,             ); */
        }
         getUnaryResultType(operandType)
    }
    getUnaryResultType := func(operandType Type) Type {
        if maybeTypeOfKind(operandType, /* TODO(PropertyAccessExpression): TypeFlags.BigIntLike */ TODO) {
             /* TODO(ConditionalExpression): isTypeAssignableToKind(operandType, TypeFlags.AnyOrUnknown) || maybeTypeOfKind(operandType, TypeFlags.NumberLike)                 ? numberOrBigIntType                 : bigintType */ TODO
        }
         numberType
    }
    maybeTypeOfKindConsideringBaseConstraint := func(type_ Type, kind TypeFlags) bool {
        if maybeTypeOfKind(type_, kind) {
             /* TODO(TrueKeyword): true */ TODO
        }
        baseConstraint := getBaseConstraintOrType(type_)
         /* TODO(BinaryExpression): !!baseConstraint && maybeTypeOfKind(baseConstraint, kind) */ TODO
    }
    maybeTypeOfKind := func(type_ Type, kind TypeFlags) bool {
        if /* TODO(BinaryExpression): type.flags & kind */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.UnionOrIntersection */ TODO {
            types := /* TODO(PropertyAccessExpression): (type as UnionOrIntersectionType).types */ TODO
            /* TODO(ForOfStatement): for (const t of types) {                 if (maybeTypeOfKind(t, kind)) {                     return true;                 }             } */
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isTypeAssignableToKind := func(source Type, kind TypeFlags, strict bool) bool {
        if /* TODO(BinaryExpression): source.flags & kind */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): strict && source.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(BinaryExpression): !!(kind & TypeFlags.NumberLike) && isTypeAssignableTo(source, numberType) ||             !!(kind & TypeFlags.BigIntLike) && isTypeAssignableTo(source, bigintType) ||             !!(kind & TypeFlags.StringLike) && isTypeAssignableTo(source, stringType) ||             !!(kind & TypeFlags.BooleanLike) && isTypeAssignableTo(source, booleanType) ||             !!(kind & TypeFlags.Void) && isTypeAssignableTo(source, voidType) ||             !!(kind & TypeFlags.Never) && isTypeAssignableTo(source, neverType) ||             !!(kind & TypeFlags.Null) && isTypeAssignableTo(source, nullType) ||             !!(kind & TypeFlags.Undefined) && isTypeAssignableTo(source, undefinedType) ||             !!(kind & TypeFlags.ESSymbol) && isTypeAssignableTo(source, esSymbolType) ||             !!(kind & TypeFlags.NonPrimitive) && isTypeAssignableTo(source, nonPrimitiveType) */ TODO
    }
    allTypesAssignableToKind := func(source Type, kind TypeFlags, strict bool) bool {
         /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ?             every((source as UnionType).types, subType => allTypesAssignableToKind(subType, kind, strict)) :             isTypeAssignableToKind(source, kind, strict) */ TODO
    }
    isConstEnumObjectType := func(type_ Type) bool {
         /* TODO(BinaryExpression): !!(getObjectFlags(type) & ObjectFlags.Anonymous) && !!type.symbol && isConstEnumSymbol(type.symbol) */ TODO
    }
    isConstEnumSymbol := func(symbol Symbol) bool {
         /* TODO(BinaryExpression): (symbol.flags & SymbolFlags.ConstEnum) !== 0 */ TODO
    }
    getSymbolHasInstanceMethodOfObjectType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        hasInstancePropertyName := getPropertyNameForKnownSymbolName("hasInstance")
        if allTypesAssignableToKind(type_, /* TODO(PropertyAccessExpression): TypeFlags.NonPrimitive */ TODO) {
            hasInstanceProperty := getPropertyOfType(type_, hasInstancePropertyName)
            if hasInstanceProperty {
                hasInstancePropertyType := getTypeOfSymbol(hasInstanceProperty)
                if /* TODO(BinaryExpression): hasInstancePropertyType && getSignaturesOfType(hasInstancePropertyType, SignatureKind.Call).length !== 0 */ TODO {
                     hasInstancePropertyType
                }
            }
        }
    }
    checkInstanceOfExpression := func(left Expression, right Expression, leftType Type, rightType Type, checkMode CheckMode) Type {
        if /* TODO(BinaryExpression): leftType === silentNeverType || rightType === silentNeverType */ TODO {
             silentNeverType
        }
        if /* TODO(BinaryExpression): !isTypeAny(leftType) &&             allTypesAssignableToKind(leftType, TypeFlags.Primitive) */ TODO {
            /* TODO(ExpressionStatement): error(left, Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter); */
        }
        /* TODO(ExpressionStatement): Debug.assert(isInstanceOfExpression(left.parent)); */
        signature := getResolvedSignature(/* TODO(PropertyAccessExpression): left.parent */ TODO, undefined, checkMode)
        if /* TODO(BinaryExpression): signature === resolvingSignature */ TODO {
             silentNeverType
        }
        returnType := getReturnTypeOfSignature(signature)
        /* TODO(ExpressionStatement): checkTypeAssignableTo(returnType, booleanType, right, Diagnostics.An_object_s_Symbol_hasInstance_method_must_return_a_boolean_value_for_it_to_be_used_on_the_right_hand_side_of_an_instanceof_expression); */
         booleanType
    }
    hasEmptyObjectIntersection := func(type_ Type) bool {
         someType(type_, /* TODO(ArrowFunction): t => t === unknownEmptyObjectType || !!(t.flags & TypeFlags.Intersection) && isEmptyAnonymousObjectType(getBaseConstraintOrType(t)) */ TODO)
    }
    checkInExpression := func(left Expression, right Expression, leftType Type, rightType Type) Type {
        if /* TODO(BinaryExpression): leftType === silentNeverType || rightType === silentNeverType */ TODO {
             silentNeverType
        }
        if isPrivateIdentifier(left) {
            if /* TODO(BinaryExpression): languageVersion < LanguageFeatureMinimumTarget.PrivateNamesAndClassStaticBlocks ||                 languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators ||                 !useDefineForClassFields */ TODO {
                /* TODO(ExpressionStatement): checkExternalEmitHelpers(left, ExternalEmitHelpers.ClassPrivateFieldIn); */
            }
            if /* TODO(BinaryExpression): !getNodeLinks(left).resolvedSymbol && getContainingClass(left) */ TODO {
                isUncheckedJS := isUncheckedJSSuggestion(left, /* TODO(PropertyAccessExpression): rightType.symbol */ TODO, /* TODO(TrueKeyword): true */ TODO)
                /* TODO(ExpressionStatement): reportNonexistentProperty(left, rightType, isUncheckedJS); */
            }
        } else {
            /* TODO(ExpressionStatement): checkTypeAssignableTo(checkNonNullType(leftType, left), stringNumberSymbolType, left); */
        }
        if checkTypeAssignableTo(checkNonNullType(rightType, right), nonPrimitiveType, right) {
            if hasEmptyObjectIntersection(rightType) {
                /* TODO(ExpressionStatement): error(right, Diagnostics.Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator, typeToString(rightType)); */
            }
        }
         booleanType
    }
    checkObjectLiteralAssignment := func(node ObjectLiteralExpression, sourceType Type, rightIsThis bool) Type {
        properties := /* TODO(PropertyAccessExpression): node.properties */ TODO
        if /* TODO(BinaryExpression): strictNullChecks && properties.length === 0 */ TODO {
             checkNonNullType(sourceType, node)
        }
        /* TODO(ForStatement): for (let i = 0; i < properties.length; i++) {             checkObjectLiteralDestructuringPropertyAssignment(node, sourceType, i, properties, rightIsThis);         } */
         sourceType
    }
    checkObjectLiteralDestructuringPropertyAssignment := func(node ObjectLiteralExpression, objectLiteralType Type, propertyIndex number, allProperties NodeArray[ObjectLiteralElementLike], rightIsThis /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        properties := /* TODO(PropertyAccessExpression): node.properties */ TODO
        property := /* TODO(ElementAccessExpression): properties[propertyIndex] */ TODO
        if /* TODO(BinaryExpression): property.kind === SyntaxKind.PropertyAssignment || property.kind === SyntaxKind.ShorthandPropertyAssignment */ TODO {
            name := /* TODO(PropertyAccessExpression): property.name */ TODO
            exprType := getLiteralTypeFromPropertyName(name)
            if isTypeUsableAsPropertyName(exprType) {
                text := getPropertyNameFromType(exprType)
                prop := getPropertyOfType(objectLiteralType, text)
                if prop {
                    /* TODO(ExpressionStatement): markPropertyAsReferenced(prop, property, rightIsThis); */
                    /* TODO(ExpressionStatement): checkPropertyAccessibility(property, /*isSuper* / false, /*writing* / true, objectLiteralType, prop); */
                }
            }
            elementType := getIndexedAccessType(objectLiteralType, exprType, /* TODO(BinaryExpression): AccessFlags.ExpressionPosition | (hasDefaultValue(property) ? AccessFlags.AllowMissing : 0) */ TODO, name)
            type_ := getFlowTypeOfDestructuring(property, elementType)
             checkDestructuringAssignment(/* TODO(ConditionalExpression): property.kind === SyntaxKind.ShorthandPropertyAssignment ? property : property.initializer */ TODO, type_)
        } else if /* TODO(BinaryExpression): property.kind === SyntaxKind.SpreadAssignment */ TODO {
            if /* TODO(BinaryExpression): propertyIndex < properties.length - 1 */ TODO {
                /* TODO(ExpressionStatement): error(property, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern); */
            } else {
                if /* TODO(BinaryExpression): languageVersion < LanguageFeatureMinimumTarget.ObjectSpreadRest */ TODO {
                    /* TODO(ExpressionStatement): checkExternalEmitHelpers(property, ExternalEmitHelpers.Rest); */
                }
                var nonRestNames []PropertyName = /* TODO(ArrayLiteralExpression): [] */ TODO
                if allProperties {
                    /* TODO(ForOfStatement): for (const otherProperty of allProperties) {                         if (!isSpreadAssignment(otherProperty)) {                             nonRestNames.push(otherProperty.name);                         }                     } */
                }
                type_ := getRestType(objectLiteralType, nonRestNames, /* TODO(PropertyAccessExpression): objectLiteralType.symbol */ TODO)
                /* TODO(ExpressionStatement): checkGrammarForDisallowedTrailingComma(allProperties, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma); */
                 checkDestructuringAssignment(/* TODO(PropertyAccessExpression): property.expression */ TODO, type_)
            }
        } else {
            /* TODO(ExpressionStatement): error(property, Diagnostics.Property_assignment_expected); */
        }
    }
    checkArrayLiteralAssignment := func(node ArrayLiteralExpression, sourceType Type, checkMode CheckMode) Type {
        elements := /* TODO(PropertyAccessExpression): node.elements */ TODO
        if /* TODO(BinaryExpression): languageVersion < LanguageFeatureMinimumTarget.DestructuringAssignment && compilerOptions.downlevelIteration */ TODO {
            /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.Read); */
        }
        possiblyOutOfBoundsType := /* TODO(BinaryExpression): checkIteratedTypeOrElementType(IterationUse.Destructuring | IterationUse.PossiblyOutOfBounds, sourceType, undefinedType, node) || errorType */ TODO
        var inBoundsType *Type = /* TODO(ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ? undefined : possiblyOutOfBoundsType */ TODO
        /* TODO(ForStatement): for (let i = 0; i < elements.length; i++) {             let type = possiblyOutOfBoundsType;             if (node.elements[i].kind === SyntaxKind.SpreadElement) {                 type = inBoundsType = inBoundsType ?? (checkIteratedTypeOrElementType(IterationUse.Destructuring, sourceType, undefinedType, node) || errorType);             }             checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, type, checkMode);         } */
         sourceType
    }
    checkArrayLiteralDestructuringElementAssignment := func(node ArrayLiteralExpression, sourceType Type, elementIndex number, elementType Type, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        elements := /* TODO(PropertyAccessExpression): node.elements */ TODO
        element := /* TODO(ElementAccessExpression): elements[elementIndex] */ TODO
        if /* TODO(BinaryExpression): element.kind !== SyntaxKind.OmittedExpression */ TODO {
            if /* TODO(BinaryExpression): element.kind !== SyntaxKind.SpreadElement */ TODO {
                indexType := getNumberLiteralType(elementIndex)
                if isArrayLikeType(sourceType) {
                    accessFlags := /* TODO(BinaryExpression): AccessFlags.ExpressionPosition | (hasDefaultValue(element) ? AccessFlags.AllowMissing : 0) */ TODO
                    elementType := /* TODO(BinaryExpression): getIndexedAccessTypeOrUndefined(sourceType, indexType, accessFlags, createSyntheticExpression(element, indexType)) || errorType */ TODO
                    assignedType := /* TODO(ConditionalExpression): hasDefaultValue(element) ? getTypeWithFacts(elementType, TypeFacts.NEUndefined) : elementType */ TODO
                    type_ := getFlowTypeOfDestructuring(element, assignedType)
                     checkDestructuringAssignment(element, type_, checkMode)
                }
                 checkDestructuringAssignment(element, elementType, checkMode)
            }
            if /* TODO(BinaryExpression): elementIndex < elements.length - 1 */ TODO {
                /* TODO(ExpressionStatement): error(element, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern); */
            } else {
                restExpression := /* TODO(PropertyAccessExpression): (element as SpreadElement).expression */ TODO
                if /* TODO(BinaryExpression): restExpression.kind === SyntaxKind.BinaryExpression && (restExpression as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken */ TODO {
                    /* TODO(ExpressionStatement): error((restExpression as BinaryExpression).operatorToken, Diagnostics.A_rest_element_cannot_have_an_initializer); */
                } else {
                    /* TODO(ExpressionStatement): checkGrammarForDisallowedTrailingComma(node.elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma); */
                    type_ := /* TODO(ConditionalExpression): everyType(sourceType, isTupleType) ?                         mapType(sourceType, t => sliceTupleType(t as TupleTypeReference, elementIndex)) :                         createArrayType(elementType) */ TODO
                     checkDestructuringAssignment(restExpression, type_, checkMode)
                }
            }
        }
         undefined
    }
    checkDestructuringAssignment := func(exprOrAssignment /* TODO(UnionType): Expression | ShorthandPropertyAssignment */ any, sourceType Type, checkMode CheckMode, rightIsThis bool) Type {
        var target Expression
        if /* TODO(BinaryExpression): exprOrAssignment.kind === SyntaxKind.ShorthandPropertyAssignment */ TODO {
            prop := exprOrAssignment /* as */ /* TODO(TypeReference): ShorthandPropertyAssignment */
            if /* TODO(PropertyAccessExpression): prop.objectAssignmentInitializer */ TODO {
                if /* TODO(BinaryExpression): strictNullChecks &&                     !(hasTypeFacts(checkExpression(prop.objectAssignmentInitializer), TypeFacts.IsUndefined)) */ TODO {
                    /* TODO(ExpressionStatement): sourceType = getTypeWithFacts(sourceType, TypeFacts.NEUndefined); */
                }
                /* TODO(ExpressionStatement): checkBinaryLikeExpression(prop.name, prop.equalsToken!, prop.objectAssignmentInitializer, checkMode); */
            }
            /* TODO(ExpressionStatement): target = (exprOrAssignment as ShorthandPropertyAssignment).name; */
        } else {
            /* TODO(ExpressionStatement): target = exprOrAssignment; */
        }
        if /* TODO(BinaryExpression): target.kind === SyntaxKind.BinaryExpression && (target as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken */ TODO {
            /* TODO(ExpressionStatement): checkBinaryExpression(target as BinaryExpression, checkMode); */
            /* TODO(ExpressionStatement): target = (target as BinaryExpression).left; */
            if strictNullChecks {
                /* TODO(ExpressionStatement): sourceType = getTypeWithFacts(sourceType, TypeFacts.NEUndefined); */
            }
        }
        if /* TODO(BinaryExpression): target.kind === SyntaxKind.ObjectLiteralExpression */ TODO {
             checkObjectLiteralAssignment(target /* as */ /* TODO(TypeReference): ObjectLiteralExpression */, sourceType, rightIsThis)
        }
        if /* TODO(BinaryExpression): target.kind === SyntaxKind.ArrayLiteralExpression */ TODO {
             checkArrayLiteralAssignment(target /* as */ /* TODO(TypeReference): ArrayLiteralExpression */, sourceType, checkMode)
        }
         checkReferenceAssignment(target, sourceType, checkMode)
    }
    checkReferenceAssignment := func(target Expression, sourceType Type, checkMode CheckMode) Type {
        targetType := checkExpression(target, checkMode)
        error := /* TODO(ConditionalExpression): target.parent.kind === SyntaxKind.SpreadAssignment ?             Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access :             Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access */ TODO
        optionalError := /* TODO(ConditionalExpression): target.parent.kind === SyntaxKind.SpreadAssignment ?             Diagnostics.The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access :             Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access */ TODO
        if checkReferenceExpression(target, error, optionalError) {
            /* TODO(ExpressionStatement): checkTypeAssignableToAndOptionallyElaborate(sourceType, targetType, target, target); */
        }
        if isPrivateIdentifierPropertyAccessExpression(target) {
            /* TODO(ExpressionStatement): checkExternalEmitHelpers(target.parent, ExternalEmitHelpers.ClassPrivateFieldSet); */
        }
         sourceType
    }
    isSideEffectFree := func(node Node) bool {
        /* TODO(ExpressionStatement): node = skipParentheses(node); */
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:             case SyntaxKind.StringLiteral:             case SyntaxKind.RegularExpressionLiteral:             case SyntaxKind.TaggedTemplateExpression:             case SyntaxKind.TemplateExpression:             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.NumericLiteral:             case SyntaxKind.BigIntLiteral:             case SyntaxKind.TrueKeyword:             case SyntaxKind.FalseKeyword:             case SyntaxKind.NullKeyword:             case SyntaxKind.UndefinedKeyword:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ClassExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.ArrayLiteralExpression:             case SyntaxKind.ObjectLiteralExpression:             case SyntaxKind.TypeOfExpression:             case SyntaxKind.NonNullExpression:             case SyntaxKind.JsxSelfClosingElement:             case SyntaxKind.JsxElement:                 return true;              case SyntaxKind.ConditionalExpression:                 return isSideEffectFree((node as ConditionalExpression).whenTrue) &&                     isSideEffectFree((node as ConditionalExpression).whenFalse);              case SyntaxKind.BinaryExpression:                 if (isAssignmentOperator((node as BinaryExpression).operatorToken.kind)) {                     return false;                 }                 return isSideEffectFree((node as BinaryExpression).left) &&                     isSideEffectFree((node as BinaryExpression).right);              case SyntaxKind.PrefixUnaryExpression:             case SyntaxKind.PostfixUnaryExpression:                 // Unary operators ~, !, +, and - have no side effects.                 // The rest do.                 switch ((node as PrefixUnaryExpression).operator) {                     case SyntaxKind.ExclamationToken:                     case SyntaxKind.PlusToken:                     case SyntaxKind.MinusToken:                     case SyntaxKind.TildeToken:                         return true;                 }                 return false;              // Some forms listed here for clarity             case SyntaxKind.VoidExpression: // Explicit opt-out             case SyntaxKind.TypeAssertionExpression: // Not SEF, but can produce useful type warnings             case SyntaxKind.AsExpression: // Not SEF, but can produce useful type warnings             default:                 return false;         } */
    }
    isTypeEqualityComparableTo := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): (target.flags & TypeFlags.Nullable) !== 0 || isTypeComparableTo(source, target) */ TODO
    }
    createCheckBinaryExpression := func() /* TODO(undefined): (node: import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression, checkMode: import("/home/jabaile/work/TypeScript/src/compiler/checker").CheckMode | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        type WorkArea struct {
            checkMode *CheckMode
            skip bool
            stackIndex number
            typeStack []*Type
        }
        trampoline := createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState)
         /* TODO(ArrowFunction): (node: BinaryExpression, checkMode: CheckMode | undefined) => {             const result = trampoline(node, checkMode);             Debug.assertIsDefined(result);             return result;         } */ TODO
        onEnter := func(node BinaryExpression, state *WorkArea, checkMode *CheckMode) /* TODO(undefined): WorkArea */ TODO {
            if state {
                /* TODO(ExpressionStatement): state.stackIndex++; */
                /* TODO(ExpressionStatement): state.skip = false; */
                /* TODO(ExpressionStatement): setLeftType(state, /*type* / undefined); */
                /* TODO(ExpressionStatement): setLastResult(state, /*type* / undefined); */
            } else {
                /* TODO(ExpressionStatement): state = {                     checkMode,                     skip: false,                     stackIndex: 0,                     typeStack: [undefined, undefined],                 }; */
            }
            if /* TODO(BinaryExpression): isInJSFile(node) && getAssignedExpandoInitializer(node) */ TODO {
                /* TODO(ExpressionStatement): state.skip = true; */
                /* TODO(ExpressionStatement): setLastResult(state, checkExpression(node.right, checkMode)); */
                 state
            }
            /* TODO(ExpressionStatement): checkNullishCoalesceOperands(node); */
            operator := /* TODO(PropertyAccessExpression): node.operatorToken.kind */ TODO
            if /* TODO(BinaryExpression): operator === SyntaxKind.EqualsToken && (node.left.kind === SyntaxKind.ObjectLiteralExpression || node.left.kind === SyntaxKind.ArrayLiteralExpression) */ TODO {
                /* TODO(ExpressionStatement): state.skip = true; */
                /* TODO(ExpressionStatement): setLastResult(state, checkDestructuringAssignment(node.left, checkExpression(node.right, checkMode), checkMode, node.right.kind === SyntaxKind.ThisKeyword)); */
                 state
            }
             state
        }
        onLeft := func(left Expression, state WorkArea, _node BinaryExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | undefined */ TODO {
            if /* TODO(PrefixUnaryExpression): !state.skip */ TODO {
                 maybeCheckExpression(state, left)
            }
        }
        onOperator := func(operatorToken BinaryOperatorToken, state WorkArea, node BinaryExpression) {
            if /* TODO(PrefixUnaryExpression): !state.skip */ TODO {
                leftType := getLastResult(state)
                /* TODO(ExpressionStatement): Debug.assertIsDefined(leftType); */
                /* TODO(ExpressionStatement): setLeftType(state, leftType); */
                /* TODO(ExpressionStatement): setLastResult(state, /*type* / undefined); */
                operator := /* TODO(PropertyAccessExpression): operatorToken.kind */ TODO
                if isLogicalOrCoalescingBinaryOperator(operator) {
                    parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
                    /* TODO(WhileStatement): while (parent.kind === SyntaxKind.ParenthesizedExpression || isLogicalOrCoalescingBinaryExpression(parent)) {                         parent = parent.parent;                     } */
                    if /* TODO(BinaryExpression): operator === SyntaxKind.AmpersandAmpersandToken || isIfStatement(parent) */ TODO {
                        /* TODO(ExpressionStatement): checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.left, leftType, isIfStatement(parent) ? parent.thenStatement : undefined); */
                    }
                    if isBinaryLogicalOperator(operator) {
                        /* TODO(ExpressionStatement): checkTruthinessOfType(leftType, node.left); */
                    }
                }
            }
        }
        onRight := func(right Expression, state WorkArea, _node BinaryExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | undefined */ TODO {
            if /* TODO(PrefixUnaryExpression): !state.skip */ TODO {
                 maybeCheckExpression(state, right)
            }
        }
        onExit := func(node BinaryExpression, state WorkArea) *Type {
            var result *Type
            if /* TODO(PropertyAccessExpression): state.skip */ TODO {
                /* TODO(ExpressionStatement): result = getLastResult(state); */
            } else {
                leftType := getLeftType(state)
                /* TODO(ExpressionStatement): Debug.assertIsDefined(leftType); */
                rightType := getLastResult(state)
                /* TODO(ExpressionStatement): Debug.assertIsDefined(rightType); */
                /* TODO(ExpressionStatement): result = checkBinaryLikeExpressionWorker(node.left, node.operatorToken, node.right, leftType, rightType, state.checkMode, node); */
            }
            /* TODO(ExpressionStatement): state.skip = false; */
            /* TODO(ExpressionStatement): setLeftType(state, /*type* / undefined); */
            /* TODO(ExpressionStatement): setLastResult(state, /*type* / undefined); */
            /* TODO(ExpressionStatement): state.stackIndex--; */
             result
        }
        foldState := func(state WorkArea, result *Type, _side /* TODO(UnionType): "left" | "right" */ any) /* TODO(undefined): WorkArea */ TODO {
            /* TODO(ExpressionStatement): setLastResult(state, result); */
             state
        }
        maybeCheckExpression := func(state WorkArea, node Expression) *BinaryExpression {
            if isBinaryExpression(node) {
                 node
            }
            /* TODO(ExpressionStatement): setLastResult(state, checkExpression(node, state.checkMode)); */
        }
        getLeftType := func(state WorkArea) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
             /* TODO(ElementAccessExpression): state.typeStack[state.stackIndex] */ TODO
        }
        setLeftType := func(state WorkArea, type_ *Type) {
            /* TODO(ExpressionStatement): state.typeStack[state.stackIndex] = type; */
        }
        getLastResult := func(state WorkArea) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
             /* TODO(ElementAccessExpression): state.typeStack[state.stackIndex + 1] */ TODO
        }
        setLastResult := func(state WorkArea, type_ *Type) {
            /* TODO(ExpressionStatement): state.typeStack[state.stackIndex + 1] = type; */
        }
    }
    checkNullishCoalesceOperands := func(node BinaryExpression) {
        TODO_IDENTIFIER := node
        if /* TODO(BinaryExpression): operatorToken.kind === SyntaxKind.QuestionQuestionToken */ TODO {
            if /* TODO(BinaryExpression): isBinaryExpression(left) && (left.operatorToken.kind === SyntaxKind.BarBarToken || left.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken) */ TODO {
                /* TODO(ExpressionStatement): grammarErrorOnNode(left, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(left.operatorToken.kind), tokenToString(operatorToken.kind)); */
            }
            if /* TODO(BinaryExpression): isBinaryExpression(right) && (right.operatorToken.kind === SyntaxKind.BarBarToken || right.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken) */ TODO {
                /* TODO(ExpressionStatement): grammarErrorOnNode(right, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(right.operatorToken.kind), tokenToString(operatorToken.kind)); */
            }
            leftTarget := skipOuterExpressions(left, /* TODO(PropertyAccessExpression): OuterExpressionKinds.All */ TODO)
            nullishSemantics := getSyntacticNullishnessSemantics(leftTarget)
            if /* TODO(BinaryExpression): nullishSemantics !== PredicateSemantics.Sometimes */ TODO {
                if /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.BinaryExpression */ TODO {
                    /* TODO(ExpressionStatement): error(leftTarget, Diagnostics.This_binary_expression_is_never_nullish_Are_you_missing_parentheses); */
                } else {
                    if /* TODO(BinaryExpression): nullishSemantics === PredicateSemantics.Always */ TODO {
                        /* TODO(ExpressionStatement): error(leftTarget, Diagnostics.This_expression_is_always_nullish); */
                    } else {
                        /* TODO(ExpressionStatement): error(leftTarget, Diagnostics.Right_operand_of_is_unreachable_because_the_left_operand_is_never_nullish); */
                    }
                }
            }
        }
    }
    getSyntacticNullishnessSemantics := func(node Node) PredicateSemantics {
        /* TODO(ExpressionStatement): node = skipOuterExpressions(node); */
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AwaitExpression:             case SyntaxKind.CallExpression:             case SyntaxKind.ElementAccessExpression:             case SyntaxKind.NewExpression:             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.YieldExpression:                 return PredicateSemantics.Sometimes;             case SyntaxKind.BinaryExpression:                 // List of operators that can produce null/undefined:                 // = ??= ?? || ||= && &&=                 switch ((node as BinaryExpression).operatorToken.kind) {                     case SyntaxKind.EqualsToken:                     case SyntaxKind.QuestionQuestionToken:                     case SyntaxKind.QuestionQuestionEqualsToken:                     case SyntaxKind.BarBarToken:                     case SyntaxKind.BarBarEqualsToken:                     case SyntaxKind.AmpersandAmpersandToken:                     case SyntaxKind.AmpersandAmpersandEqualsToken:                         return PredicateSemantics.Sometimes;                 }                 return PredicateSemantics.Never;             case SyntaxKind.ConditionalExpression:                 return getSyntacticNullishnessSemantics((node as ConditionalExpression).whenTrue) | getSyntacticNullishnessSemantics((node as ConditionalExpression).whenFalse);             case SyntaxKind.NullKeyword:                 return PredicateSemantics.Always;             case SyntaxKind.Identifier:                 if (getResolvedSymbol(node as Identifier) === undefinedSymbol) {                     return PredicateSemantics.Always;                 }                 return PredicateSemantics.Sometimes;         } */
         /* TODO(PropertyAccessExpression): PredicateSemantics.Never */ TODO
    }
    checkBinaryLikeExpression := func(left Expression, operatorToken BinaryOperatorToken, right Expression, checkMode CheckMode, errorNode Node) Type {
        operator := /* TODO(PropertyAccessExpression): operatorToken.kind */ TODO
        if /* TODO(BinaryExpression): operator === SyntaxKind.EqualsToken && (left.kind === SyntaxKind.ObjectLiteralExpression || left.kind === SyntaxKind.ArrayLiteralExpression) */ TODO {
             checkDestructuringAssignment(left, checkExpression(right, checkMode), checkMode, /* TODO(BinaryExpression): right.kind === SyntaxKind.ThisKeyword */ TODO)
        }
        var leftType Type
        if isBinaryLogicalOperator(operator) {
            /* TODO(ExpressionStatement): leftType = checkTruthinessExpression(left, checkMode); */
        } else {
            /* TODO(ExpressionStatement): leftType = checkExpression(left, checkMode); */
        }
        rightType := checkExpression(right, checkMode)
         checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, checkMode, errorNode)
    }
    checkBinaryLikeExpressionWorker := func(left Expression, operatorToken BinaryOperatorToken, right Expression, leftType Type, rightType Type, checkMode CheckMode, errorNode Node) Type {
        operator := /* TODO(PropertyAccessExpression): operatorToken.kind */ TODO
        /* TODO(SwitchStatement): switch (operator) {             case SyntaxKind.AsteriskToken:             case SyntaxKind.AsteriskAsteriskToken:             case SyntaxKind.AsteriskEqualsToken:             case SyntaxKind.AsteriskAsteriskEqualsToken:             case SyntaxKind.SlashToken:             case SyntaxKind.SlashEqualsToken:             case SyntaxKind.PercentToken:             case SyntaxKind.PercentEqualsToken:             case SyntaxKind.MinusToken:             case SyntaxKind.MinusEqualsToken:             case SyntaxKind.LessThanLessThanToken:             case SyntaxKind.LessThanLessThanEqualsToken:             case SyntaxKind.GreaterThanGreaterThanToken:             case SyntaxKind.GreaterThanGreaterThanEqualsToken:             case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:             case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:             case SyntaxKind.BarToken:             case SyntaxKind.BarEqualsToken:             case SyntaxKind.CaretToken:             case SyntaxKind.CaretEqualsToken:             case SyntaxKind.AmpersandToken:             case SyntaxKind.AmpersandEqualsToken:                 if (leftType === silentNeverType || rightType === silentNeverType) {                     return silentNeverType;                 }                  leftType = checkNonNullType(leftType, left);                 rightType = checkNonNullType(rightType, right);                  let suggestedOperator: PunctuationSyntaxKind | undefined;                 // if a user tries to apply a bitwise operator to 2 boolean operands                 // try and return them a helpful suggestion                 if (                     (leftType.flags & TypeFlags.BooleanLike) &&                     (rightType.flags & TypeFlags.BooleanLike) &&                     (suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind)) !== undefined                 ) {                     error(errorNode || operatorToken, Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, tokenToString(operatorToken.kind), tokenToString(suggestedOperator));                     return numberType;                 }                 else {                     // otherwise just check each operand separately and report errors as normal                     const leftOk = checkArithmeticOperandType(left, leftType, Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid* / true);                     const rightOk = checkArithmeticOperandType(right, rightType, Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid* / true);                     let resultType: Type;                     // If both are any or unknown, allow operation; assume it will resolve to number                     if (                         (isTypeAssignableToKind(leftType, TypeFlags.AnyOrUnknown) && isTypeAssignableToKind(rightType, TypeFlags.AnyOrUnknown)) ||                         // Or, if neither could be bigint, implicit coercion results in a number result                         !(maybeTypeOfKind(leftType, TypeFlags.BigIntLike) || maybeTypeOfKind(rightType, TypeFlags.BigIntLike))                     ) {                         resultType = numberType;                     }                     // At least one is assignable to bigint, so check that both are                     else if (bothAreBigIntLike(leftType, rightType)) {                         switch (operator) {                             case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:                             case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:                                 reportOperatorError();                                 break;                             case SyntaxKind.AsteriskAsteriskToken:                             case SyntaxKind.AsteriskAsteriskEqualsToken:                                 if (languageVersion < ScriptTarget.ES2016) {                                     error(errorNode, Diagnostics.Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later);                                 }                         }                         resultType = bigintType;                     }                     // Exactly one of leftType/rightType is assignable to bigint                     else {                         reportOperatorError(bothAreBigIntLike);                         resultType = errorType;                     }                     if (leftOk && rightOk) {                         checkAssignmentOperator(resultType);                         switch (operator) {                             case SyntaxKind.LessThanLessThanToken:                             case SyntaxKind.LessThanLessThanEqualsToken:                             case SyntaxKind.GreaterThanGreaterThanToken:                             case SyntaxKind.GreaterThanGreaterThanEqualsToken:                             case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:                             case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:                                 const rhsEval = evaluate(right);                                 if (typeof rhsEval.value === "number" && Math.abs(rhsEval.value) >= 32) {                                     errorOrSuggestion(                                         isEnumMember(walkUpParenthesizedExpressions(right.parent.parent)), // elevate from suggestion to error within an enum member                                         errorNode || operatorToken,                                         Diagnostics.This_operation_can_be_simplified_This_shift_is_identical_to_0_1_2,                                         getTextOfNode(left),                                         tokenToString(operator),                                         rhsEval.value % 32,                                     );                                 }                                 break;                             default:                                 break;                         }                     }                     return resultType;                 }             case SyntaxKind.PlusToken:             case SyntaxKind.PlusEqualsToken:                 if (leftType === silentNeverType || rightType === silentNeverType) {                     return silentNeverType;                 }                  if (!isTypeAssignableToKind(leftType, TypeFlags.StringLike) && !isTypeAssignableToKind(rightType, TypeFlags.StringLike)) {                     leftType = checkNonNullType(leftType, left);                     rightType = checkNonNullType(rightType, right);                 }                  let resultType: Type | undefined;                 if (isTypeAssignableToKind(leftType, TypeFlags.NumberLike, /*strict* / true) && isTypeAssignableToKind(rightType, TypeFlags.NumberLike, /*strict* / true)) {                     // Operands of an enum type are treated as having the primitive type Number.                     // If both operands are of the Number primitive type, the result is of the Number primitive type.                     resultType = numberType;                 }                 else if (isTypeAssignableToKind(leftType, TypeFlags.BigIntLike, /*strict* / true) && isTypeAssignableToKind(rightType, TypeFlags.BigIntLike, /*strict* / true)) {                     // If both operands are of the BigInt primitive type, the result is of the BigInt primitive type.                     resultType = bigintType;                 }                 else if (isTypeAssignableToKind(leftType, TypeFlags.StringLike, /*strict* / true) || isTypeAssignableToKind(rightType, TypeFlags.StringLike, /*strict* / true)) {                     // If one or both operands are of the String primitive type, the result is of the String primitive type.                     resultType = stringType;                 }                 else if (isTypeAny(leftType) || isTypeAny(rightType)) {                     // Otherwise, the result is of type Any.                     // NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.                     resultType = isErrorType(leftType) || isErrorType(rightType) ? errorType : anyType;                 }                  // Symbols are not allowed at all in arithmetic expressions                 if (resultType && !checkForDisallowedESSymbolOperand(operator)) {                     return resultType;                 }                  if (!resultType) {                     // Types that have a reasonably good chance of being a valid operand type.                     // If both types have an awaited type of one of these, we'll assume the user                     // might be missing an await without doing an exhaustive check that inserting                     // await(s) will actually be a completely valid binary expression.                     const closeEnoughKind = TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.AnyOrUnknown;                     reportOperatorError((left, right) =>                         isTypeAssignableToKind(left, closeEnoughKind) &&                         isTypeAssignableToKind(right, closeEnoughKind)                     );                     return anyType;                 }                  if (operator === SyntaxKind.PlusEqualsToken) {                     checkAssignmentOperator(resultType);                 }                 return resultType;             case SyntaxKind.LessThanToken:             case SyntaxKind.GreaterThanToken:             case SyntaxKind.LessThanEqualsToken:             case SyntaxKind.GreaterThanEqualsToken:                 if (checkForDisallowedESSymbolOperand(operator)) {                     leftType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(leftType, left));                     rightType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(rightType, right));                     reportOperatorErrorUnless((left, right) => {                         if (isTypeAny(left) || isTypeAny(right)) {                             return true;                         }                         const leftAssignableToNumber = isTypeAssignableTo(left, numberOrBigIntType);                         const rightAssignableToNumber = isTypeAssignableTo(right, numberOrBigIntType);                         return leftAssignableToNumber && rightAssignableToNumber ||                             !leftAssignableToNumber && !rightAssignableToNumber && areTypesComparable(left, right);                     });                 }                 return booleanType;             case SyntaxKind.EqualsEqualsToken:             case SyntaxKind.ExclamationEqualsToken:             case SyntaxKind.EqualsEqualsEqualsToken:             case SyntaxKind.ExclamationEqualsEqualsToken:                 // We suppress errors in CheckMode.TypeOnly (meaning the invocation came from getTypeOfExpression). During                 // control flow analysis it is possible for operands to temporarily have narrower types, and those narrower                 // types may cause the operands to not be comparable. We don't want such errors reported (see #46475).                 if (!(checkMode && checkMode & CheckMode.TypeOnly)) {                     if (                         (isLiteralExpressionOfObject(left) || isLiteralExpressionOfObject(right)) &&                         // only report for === and !== in JS, not == or !=                         (!isInJSFile(left) || (operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken))                     ) {                         const eqType = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.EqualsEqualsEqualsToken;                         error(errorNode, Diagnostics.This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value, eqType ? "false" : "true");                     }                     checkNaNEquality(errorNode, operator, left, right);                     reportOperatorErrorUnless((left, right) => isTypeEqualityComparableTo(left, right) || isTypeEqualityComparableTo(right, left));                 }                 return booleanType;             case SyntaxKind.InstanceOfKeyword:                 return checkInstanceOfExpression(left, right, leftType, rightType, checkMode);             case SyntaxKind.InKeyword:                 return checkInExpression(left, right, leftType, rightType);             case SyntaxKind.AmpersandAmpersandToken:             case SyntaxKind.AmpersandAmpersandEqualsToken: {                 const resultType = hasTypeFacts(leftType, TypeFacts.Truthy) ?                     getUnionType([extractDefinitelyFalsyTypes(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType)), rightType]) :                     leftType;                 if (operator === SyntaxKind.AmpersandAmpersandEqualsToken) {                     checkAssignmentOperator(rightType);                 }                 return resultType;             }             case SyntaxKind.BarBarToken:             case SyntaxKind.BarBarEqualsToken: {                 const resultType = hasTypeFacts(leftType, TypeFacts.Falsy) ?                     getUnionType([getNonNullableType(removeDefinitelyFalsyTypes(leftType)), rightType], UnionReduction.Subtype) :                     leftType;                 if (operator === SyntaxKind.BarBarEqualsToken) {                     checkAssignmentOperator(rightType);                 }                 return resultType;             }             case SyntaxKind.QuestionQuestionToken:             case SyntaxKind.QuestionQuestionEqualsToken: {                 const resultType = hasTypeFacts(leftType, TypeFacts.EQUndefinedOrNull) ?                     getUnionType([getNonNullableType(leftType), rightType], UnionReduction.Subtype) :                     leftType;                 if (operator === SyntaxKind.QuestionQuestionEqualsToken) {                     checkAssignmentOperator(rightType);                 }                 return resultType;             }             case SyntaxKind.EqualsToken:                 const declKind = isBinaryExpression(left.parent) ? getAssignmentDeclarationKind(left.parent) : AssignmentDeclarationKind.None;                 checkAssignmentDeclaration(declKind, rightType);                 if (isAssignmentDeclaration(declKind)) {                     if (                         !(rightType.flags & TypeFlags.Object) ||                         declKind !== AssignmentDeclarationKind.ModuleExports &&                             declKind !== AssignmentDeclarationKind.Prototype &&                             !isEmptyObjectType(rightType) &&                             !isFunctionObjectType(rightType as ObjectType) &&                             !(getObjectFlags(rightType) & ObjectFlags.Class)                     ) {                         // don't check assignability of module.exports=, C.prototype=, or expando types because they will necessarily be incomplete                         checkAssignmentOperator(rightType);                     }                     return leftType;                 }                 else {                     checkAssignmentOperator(rightType);                     return rightType;                 }             case SyntaxKind.CommaToken:                 if (!compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isIndirectCall(left.parent as BinaryExpression)) {                     const sf = getSourceFileOfNode(left);                     const sourceText = sf.text;                     const start = skipTrivia(sourceText, left.pos);                     const isInDiag2657 = sf.parseDiagnostics.some(diag => {                         if (diag.code !== Diagnostics.JSX_expressions_must_have_one_parent_element.code) return false;                         return textSpanContainsPosition(diag, start);                     });                     if (!isInDiag2657) error(left, Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects);                 }                 return rightType;              default:                 return Debug.fail();         } */
        bothAreBigIntLike := func(left Type, right Type) bool {
             /* TODO(BinaryExpression): isTypeAssignableToKind(left, TypeFlags.BigIntLike) && isTypeAssignableToKind(right, TypeFlags.BigIntLike) */ TODO
        }
        checkAssignmentDeclaration := func(kind AssignmentDeclarationKind, rightType Type) {
            if /* TODO(BinaryExpression): kind === AssignmentDeclarationKind.ModuleExports */ TODO {
                /* TODO(ForOfStatement): for (const prop of getPropertiesOfObjectType(rightType)) {                     const propType = getTypeOfSymbol(prop);                     if (propType.symbol && propType.symbol.flags & SymbolFlags.Class) {                         const name = prop.escapedName;                         const symbol = resolveName(prop.valueDeclaration, name, SymbolFlags.Type, /*nameNotFoundMessage* / undefined, /*isUse* / false);                         if (symbol?.declarations && symbol.declarations.some(isJSDocTypedefTag)) {                             addDuplicateDeclarationErrorsForSymbols(symbol, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), prop);                             addDuplicateDeclarationErrorsForSymbols(prop, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), symbol);                         }                     }                 } */
            }
        }
        isIndirectCall := func(node BinaryExpression) bool {
             /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.ParenthesizedExpression &&                 isNumericLiteral(node.left) &&                 node.left.text === "0" &&                 (isCallExpression(node.parent.parent) && node.parent.parent.expression === node.parent || node.parent.parent.kind === SyntaxKind.TaggedTemplateExpression) &&                 // special-case for "eval" because it's the only non-access case where an indirect call actually affects behavior.                 (isAccessExpression(node.right) || isIdentifier(node.right) && node.right.escapedText === "eval") */ TODO
        }
        checkForDisallowedESSymbolOperand := func(operator PunctuationSyntaxKind) bool {
            offendingSymbolOperand := /* TODO(ConditionalExpression): maybeTypeOfKindConsideringBaseConstraint(leftType, TypeFlags.ESSymbolLike) ? left :                 maybeTypeOfKindConsideringBaseConstraint(rightType, TypeFlags.ESSymbolLike) ? right :                 undefined */ TODO
            if offendingSymbolOperand {
                /* TODO(ExpressionStatement): error(offendingSymbolOperand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(operator)); */
                 /* TODO(FalseKeyword): false */ TODO
            }
             /* TODO(TrueKeyword): true */ TODO
        }
        getSuggestedBooleanOperator := func(operator SyntaxKind) *PunctuationSyntaxKind {
            /* TODO(SwitchStatement): switch (operator) {                 case SyntaxKind.BarToken:                 case SyntaxKind.BarEqualsToken:                     return SyntaxKind.BarBarToken;                 case SyntaxKind.CaretToken:                 case SyntaxKind.CaretEqualsToken:                     return SyntaxKind.ExclamationEqualsEqualsToken;                 case SyntaxKind.AmpersandToken:                 case SyntaxKind.AmpersandEqualsToken:                     return SyntaxKind.AmpersandAmpersandToken;                 default:                     return undefined;             } */
        }
        checkAssignmentOperator := func(valueType Type) {
            if isAssignmentOperator(operator) {
                /* TODO(ExpressionStatement): addLazyDiagnostic(checkAssignmentOperatorWorker); */
            }
            checkAssignmentOperatorWorker := func() {
                assigneeType := leftType
                if /* TODO(BinaryExpression): isCompoundAssignment(operatorToken.kind) && left.kind === SyntaxKind.PropertyAccessExpression */ TODO {
                    /* TODO(ExpressionStatement): assigneeType = checkPropertyAccessExpression(left as PropertyAccessExpression, /*checkMode* / undefined, /*writeOnly* / true); */
                }
                if checkReferenceExpression(left, /* TODO(PropertyAccessExpression): Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access */ TODO) {
                    var headMessage *DiagnosticMessage
                    if /* TODO(BinaryExpression): exactOptionalPropertyTypes && isPropertyAccessExpression(left) && maybeTypeOfKind(valueType, TypeFlags.Undefined) */ TODO {
                        target := getTypeOfPropertyOfType(getTypeOfExpression(/* TODO(PropertyAccessExpression): left.expression */ TODO), /* TODO(PropertyAccessExpression): left.name.escapedText */ TODO)
                        if isExactOptionalPropertyMismatch(valueType, target) {
                            /* TODO(ExpressionStatement): headMessage = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target; */
                        }
                    }
                    /* TODO(ExpressionStatement): checkTypeAssignableToAndOptionallyElaborate(valueType, assigneeType, left, right, headMessage); */
                }
            }
        }
        isAssignmentDeclaration := func(kind AssignmentDeclarationKind) /* TODO(undefined): boolean */ TODO {
            /* TODO(SwitchStatement): switch (kind) {                 case AssignmentDeclarationKind.ModuleExports:                     return true;                 case AssignmentDeclarationKind.ExportsProperty:                 case AssignmentDeclarationKind.Property:                 case AssignmentDeclarationKind.Prototype:                 case AssignmentDeclarationKind.PrototypeProperty:                 case AssignmentDeclarationKind.ThisProperty:                     const symbol = getSymbolOfNode(left);                     const init = getAssignedExpandoInitializer(right);                     return !!init && isObjectLiteralExpression(init) &&                         !!symbol?.exports?.size;                 default:                     return false;             } */
        }
        reportOperatorErrorUnless := func(typesAreCompatible func(left Type, right Type) bool) bool {
            if /* TODO(PrefixUnaryExpression): !typesAreCompatible(leftType, rightType) */ TODO {
                /* TODO(ExpressionStatement): reportOperatorError(typesAreCompatible); */
                 /* TODO(TrueKeyword): true */ TODO
            }
             /* TODO(FalseKeyword): false */ TODO
        }
        reportOperatorError := func(isRelated func(left Type, right Type) bool) {
            wouldWorkWithAwait := /* TODO(FalseKeyword): false */ TODO
            errNode := /* TODO(BinaryExpression): errorNode || operatorToken */ TODO
            if isRelated {
                awaitedLeftType := getAwaitedTypeNoAlias(leftType)
                awaitedRightType := getAwaitedTypeNoAlias(rightType)
                /* TODO(ExpressionStatement): wouldWorkWithAwait = !(awaitedLeftType === leftType && awaitedRightType === rightType)                     && !!(awaitedLeftType && awaitedRightType)                     && isRelated(awaitedLeftType, awaitedRightType); */
            }
            effectiveLeft := leftType
            effectiveRight := rightType
            if /* TODO(BinaryExpression): !wouldWorkWithAwait && isRelated */ TODO {
                /* TODO(ExpressionStatement): [effectiveLeft, effectiveRight] = getBaseTypesIfUnrelated(leftType, rightType, isRelated); */
            }
            TODO_IDENTIFIER := getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight)
            if /* TODO(PrefixUnaryExpression): !tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr) */ TODO {
                /* TODO(ExpressionStatement): errorAndMaybeSuggestAwait(                     errNode,                     wouldWorkWithAwait,                     Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2,                     tokenToString(operatorToken.kind),                     leftStr,                     rightStr,                 ); */
            }
        }
        tryGiveBetterPrimaryError := func(errNode Node, maybeMissingAwait bool, leftStr string, rightStr string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic | undefined */ TODO {
            /* TODO(SwitchStatement): switch (operatorToken.kind) {                 case SyntaxKind.EqualsEqualsEqualsToken:                 case SyntaxKind.EqualsEqualsToken:                 case SyntaxKind.ExclamationEqualsEqualsToken:                 case SyntaxKind.ExclamationEqualsToken:                     return errorAndMaybeSuggestAwait(                         errNode,                         maybeMissingAwait,                         Diagnostics.This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap,                         leftStr,                         rightStr,                     );                 default:                     return undefined;             } */
        }
        checkNaNEquality := func(errorNode Node, operator SyntaxKind, left Expression, right Expression) {
            isLeftNaN := isGlobalNaN(skipParentheses(left))
            isRightNaN := isGlobalNaN(skipParentheses(right))
            if /* TODO(BinaryExpression): isLeftNaN || isRightNaN */ TODO {
                err := error(errorNode, /* TODO(PropertyAccessExpression): Diagnostics.This_condition_will_always_return_0 */ TODO, tokenToString(/* TODO(ConditionalExpression): operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.EqualsEqualsToken ? SyntaxKind.FalseKeyword : SyntaxKind.TrueKeyword */ TODO))
                if /* TODO(BinaryExpression): isLeftNaN && isRightNaN */ TODO {
                }
                operatorString := /* TODO(ConditionalExpression): operator === SyntaxKind.ExclamationEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? tokenToString(SyntaxKind.ExclamationToken) : "" */ TODO
                location := /* TODO(ConditionalExpression): isLeftNaN ? right : left */ TODO
                expression := skipParentheses(location)
                /* TODO(ExpressionStatement): addRelatedInfo(err, createDiagnosticForNode(location, Diagnostics.Did_you_mean_0, `${operatorString}Number.isNaN(${isEntityNameExpression(expression) ? entityNameToString(expression) : "..."})`)); */
            }
        }
        isGlobalNaN := func(expr Expression) bool {
            if /* TODO(BinaryExpression): isIdentifier(expr) && expr.escapedText === "NaN" */ TODO {
                globalNaNSymbol := getGlobalNaNSymbol()
                 /* TODO(BinaryExpression): !!globalNaNSymbol && globalNaNSymbol === getResolvedSymbol(expr) */ TODO
            }
             /* TODO(FalseKeyword): false */ TODO
        }
    }
    getBaseTypesIfUnrelated := func(leftType Type, rightType Type, isRelated func(left Type, right Type) bool) /* TODO(TupleType): [Type, Type] */ TODO {
        effectiveLeft := leftType
        effectiveRight := rightType
        leftBase := getBaseTypeOfLiteralType(leftType)
        rightBase := getBaseTypeOfLiteralType(rightType)
        if /* TODO(PrefixUnaryExpression): !isRelated(leftBase, rightBase) */ TODO {
            /* TODO(ExpressionStatement): effectiveLeft = leftBase; */
            /* TODO(ExpressionStatement): effectiveRight = rightBase; */
        }
         /* TODO(ArrayLiteralExpression): [effectiveLeft, effectiveRight] */ TODO
    }
    checkYieldExpression := func(node YieldExpression) Type {
        /* TODO(ExpressionStatement): addLazyDiagnostic(checkYieldExpressionGrammar); */
        func_ := getContainingFunction(node)
        if /* TODO(PrefixUnaryExpression): !func */ TODO {
            /* TODO(Identifier): anyType */
        }
        functionFlags := getFunctionFlags(func_)
        if /* TODO(PrefixUnaryExpression): !(functionFlags & FunctionFlags.Generator) */ TODO {
             anyType
        }
        isAsync := /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */ TODO
        if /* TODO(PropertyAccessExpression): node.asteriskToken */ TODO {
            if /* TODO(BinaryExpression): isAsync && languageVersion < LanguageFeatureMinimumTarget.AsyncGenerators */ TODO {
                /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.AsyncDelegatorIncludes); */
            }
            if /* TODO(BinaryExpression): !isAsync && languageVersion < LanguageFeatureMinimumTarget.Generators && compilerOptions.downlevelIteration */ TODO {
                /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.Values); */
            }
        }
        returnType := getReturnTypeFromAnnotation(func_)
        if /* TODO(BinaryExpression): returnType && returnType.flags & TypeFlags.Union */ TODO {
            /* TODO(ExpressionStatement): returnType = filterType(returnType, t => checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags, /*errorNode* / undefined)); */
        }
        iterationTypes := /* TODO(BinaryExpression): returnType && getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsync) */ TODO
        signatureYieldType := /* TODO(BinaryExpression): iterationTypes && iterationTypes.yieldType || anyType */ TODO
        signatureNextType := /* TODO(BinaryExpression): iterationTypes && iterationTypes.nextType || anyType */ TODO
        yieldExpressionType := /* TODO(ConditionalExpression): node.expression ? checkExpression(node.expression) : undefinedWideningType */ TODO
        yieldedType := getYieldedTypeOfYieldExpression(node, yieldExpressionType, signatureNextType, isAsync)
        if /* TODO(BinaryExpression): returnType && yieldedType */ TODO {
            /* TODO(ExpressionStatement): checkTypeAssignableToAndOptionallyElaborate(yieldedType, signatureYieldType, node.expression || node, node.expression); */
        }
        if /* TODO(PropertyAccessExpression): node.asteriskToken */ TODO {
            use := /* TODO(ConditionalExpression): isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar */ TODO
             /* TODO(BinaryExpression): getIterationTypeOfIterable(use, IterationTypeKind.Return, yieldExpressionType, node.expression)                 || anyType */ TODO
        } else if returnType {
             /* TODO(BinaryExpression): getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Next, returnType, isAsync)                 || anyType */ TODO
        }
        type_ := getContextualIterationType(/* TODO(PropertyAccessExpression): IterationTypeKind.Next */ TODO, func_)
        if /* TODO(PrefixUnaryExpression): !type */ TODO {
            /* TODO(ExpressionStatement): type = anyType; */
            /* TODO(ExpressionStatement): addLazyDiagnostic(() => {                 if (noImplicitAny && !expressionResultIsUnused(node)) {                     const contextualType = getContextualType(node, /*contextFlags* / undefined);                     if (!contextualType || isTypeAny(contextualType)) {                         error(node, Diagnostics.yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation);                     }                 }             }); */
        }
         type_
        checkYieldExpressionGrammar := func() {
            if /* TODO(PrefixUnaryExpression): !(node.flags & NodeFlags.YieldContext) */ TODO {
                /* TODO(ExpressionStatement): grammarErrorOnFirstToken(node, Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body); */
            }
            if isInParameterInitializerBeforeContainingFunction(node) {
                /* TODO(ExpressionStatement): error(node, Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer); */
            }
        }
    }
    checkConditionalExpression := func(node ConditionalExpression, checkMode CheckMode) Type {
        type_ := checkTruthinessExpression(/* TODO(PropertyAccessExpression): node.condition */ TODO, checkMode)
        /* TODO(ExpressionStatement): checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.condition, type, node.whenTrue); */
        type1 := checkExpression(/* TODO(PropertyAccessExpression): node.whenTrue */ TODO, checkMode)
        type2 := checkExpression(/* TODO(PropertyAccessExpression): node.whenFalse */ TODO, checkMode)
         getUnionType(/* TODO(ArrayLiteralExpression): [type1, type2] */ TODO, /* TODO(PropertyAccessExpression): UnionReduction.Subtype */ TODO)
    }
    isTemplateLiteralContext := func(node Node) bool {
        parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
         /* TODO(BinaryExpression): isParenthesizedExpression(parent) && isTemplateLiteralContext(parent) ||             isElementAccessExpression(parent) && parent.argumentExpression === node */ TODO
    }
    checkTemplateExpression := func(node TemplateExpression) Type {
        texts := /* TODO(ArrayLiteralExpression): [node.head.text] */ TODO
        types := /* TODO(ArrayLiteralExpression): [] */ TODO
        /* TODO(ForOfStatement): for (const span of node.templateSpans) {             const type = checkExpression(span.expression);             if (maybeTypeOfKindConsideringBaseConstraint(type, TypeFlags.ESSymbolLike)) {                 error(span.expression, Diagnostics.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String);             }             texts.push(span.literal.text);             types.push(isTypeAssignableTo(type, templateConstraintType) ? type : stringType);         } */
        evaluated := /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.TaggedTemplateExpression && evaluate(node).value */ TODO
        if evaluated {
             getFreshTypeOfLiteralType(getStringLiteralType(evaluated))
        }
        if /* TODO(BinaryExpression): isConstContext(node) || isTemplateLiteralContext(node) || someType(getContextualType(node, /*contextFlags* / undefined) || unknownType, isTemplateLiteralContextualType) */ TODO {
             getTemplateLiteralType(texts, types)
        }
         stringType
    }
    isTemplateLiteralContextualType := func(type_ Type) bool {
         /* TODO(PrefixUnaryExpression): !!(type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral) ||             type.flags & TypeFlags.InstantiableNonPrimitive && maybeTypeOfKind(getBaseConstraintOfType(type) || unknownType, TypeFlags.StringLike)) */ TODO
    }
    getContextNode := func(node Expression) Expression {
        if /* TODO(BinaryExpression): isJsxAttributes(node) && !isJsxSelfClosingElement(node.parent) */ TODO {
             /* TODO(PropertyAccessExpression): node.parent.parent */ TODO
        }
         node
    }
    checkExpressionWithContextualType := func(node Expression, contextualType Type, inferenceContext *InferenceContext, checkMode CheckMode) Type {
        contextNode := getContextNode(node)
        /* TODO(ExpressionStatement): pushContextualType(contextNode, contextualType, /*isCache* / false); */
        /* TODO(ExpressionStatement): pushInferenceContext(contextNode, inferenceContext); */
        type_ := checkExpression(node, /* TODO(BinaryExpression): checkMode | CheckMode.Contextual | (inferenceContext ? CheckMode.Inferential : 0) */ TODO)
        if /* TODO(BinaryExpression): inferenceContext && inferenceContext.intraExpressionInferenceSites */ TODO {
            /* TODO(ExpressionStatement): inferenceContext.intraExpressionInferenceSites = undefined; */
        }
        result := /* TODO(ConditionalExpression): maybeTypeOfKind(type, TypeFlags.Literal) && isLiteralOfContextualType(type, instantiateContextualType(contextualType, node, /*contextFlags* / undefined)) ?             getRegularTypeOfLiteralType(type) : type */ TODO
        /* TODO(ExpressionStatement): popInferenceContext(); */
        /* TODO(ExpressionStatement): popContextualType(); */
         result
    }
    checkExpressionCached := func(node /* TODO(UnionType): Expression | QualifiedName */ any, checkMode CheckMode) Type {
        if checkMode {
             checkExpression(node, checkMode)
        }
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !links.resolvedType */ TODO {
            saveFlowLoopStart := flowLoopStart
            saveFlowTypeCache := flowTypeCache
            /* TODO(ExpressionStatement): flowLoopStart = flowLoopCount; */
            /* TODO(ExpressionStatement): flowTypeCache = undefined; */
            /* TODO(ExpressionStatement): links.resolvedType = checkExpression(node, checkMode); */
            /* TODO(ExpressionStatement): flowTypeCache = saveFlowTypeCache; */
            /* TODO(ExpressionStatement): flowLoopStart = saveFlowLoopStart; */
        }
         /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
    }
    isTypeAssertion := func(node Expression) /* TODO(undefined): boolean */ TODO {
        /* TODO(ExpressionStatement): node = skipParentheses(node, /*excludeJSDocTypeAssertions* / true); */
         /* TODO(BinaryExpression): node.kind === SyntaxKind.TypeAssertionExpression ||             node.kind === SyntaxKind.AsExpression ||             isJSDocTypeAssertion(node) */ TODO
    }
    checkDeclarationInitializer := func(declaration HasExpressionInitializer, checkMode CheckMode, contextualType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        initializer := /* TODO(NonNullExpression): getEffectiveInitializer(declaration)! */ TODO
        if isInJSFile(declaration) {
            typeNode := tryGetJSDocSatisfiesTypeNode(declaration)
            if typeNode {
                 checkSatisfiesExpressionWorker(initializer, typeNode, checkMode)
            }
        }
        type_ := /* TODO(BinaryExpression): getQuickTypeOfExpression(initializer) || (contextualType ?             checkExpressionWithContextualType(initializer, contextualType, /*inferenceContext* / undefined, checkMode || CheckMode.Normal) :             checkExpressionCached(initializer, checkMode)) */ TODO
        if isParameter(/* TODO(ConditionalExpression): isBindingElement(declaration) ? walkUpBindingElementsAndPatterns(declaration) : declaration */ TODO) {
            if /* TODO(BinaryExpression): declaration.name.kind === SyntaxKind.ObjectBindingPattern && isObjectLiteralType(type) */ TODO {
                 padObjectLiteralType(type_ /* as */ /* TODO(TypeReference): ObjectType */, /* TODO(PropertyAccessExpression): declaration.name */ TODO)
            }
            if /* TODO(BinaryExpression): declaration.name.kind === SyntaxKind.ArrayBindingPattern && isTupleType(type) */ TODO {
                 padTupleType(type_, /* TODO(PropertyAccessExpression): declaration.name */ TODO)
            }
        }
         type_
    }
    padObjectLiteralType := func(type_ ObjectType, pattern ObjectBindingPattern) Type {
        var missingElements /* TODO(ArrayType): BindingElement[] */ any
        /* TODO(ForOfStatement): for (const e of pattern.elements) {             if (e.initializer) {                 const name = getPropertyNameFromBindingElement(e);                 if (name && !getPropertyOfType(type, name)) {                     missingElements = append(missingElements, e);                 }             }         } */
        if /* TODO(PrefixUnaryExpression): !missingElements */ TODO {
             type_
        }
        members := createSymbolTable()
        /* TODO(ForOfStatement): for (const prop of getPropertiesOfObjectType(type)) {             members.set(prop.escapedName, prop);         } */
        /* TODO(ForOfStatement): for (const e of missingElements) {             const symbol = createSymbol(SymbolFlags.Property | SymbolFlags.Optional, getPropertyNameFromBindingElement(e)!);             symbol.links.type = getTypeFromBindingElement(e, /*includePatternInType* / false, /*reportErrors* / false);             members.set(symbol.escapedName, symbol);         } */
        result := createAnonymousType(/* TODO(PropertyAccessExpression): type.symbol */ TODO, members, emptyArray, emptyArray, getIndexInfosOfType(type_))
        /* TODO(ExpressionStatement): result.objectFlags = type.objectFlags; */
         result
    }
    getPropertyNameFromBindingElement := func(e BindingElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
        exprType := getLiteralTypeFromPropertyName(/* TODO(BinaryExpression): e.propertyName || e.name as Identifier */ TODO)
         /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(exprType) ? getPropertyNameFromType(exprType) : undefined */ TODO
    }
    padTupleType := func(type_ TupleTypeReference, pattern ArrayBindingPattern) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(BinaryExpression): type.target.combinedFlags & ElementFlags.Variable || getTypeReferenceArity(type) >= pattern.elements.length */ TODO {
             type_
        }
        patternElements := /* TODO(PropertyAccessExpression): pattern.elements */ TODO
        elementTypes := /* TODO(PropertyAccessExpression): getElementTypes(type).slice */ TODO()
        elementFlags := /* TODO(PropertyAccessExpression): type.target.elementFlags.slice */ TODO()
        /* TODO(ForStatement): for (let i = getTypeReferenceArity(type); i < patternElements.length; i++) {             const e = patternElements[i];             if (i < patternElements.length - 1 || !(e.kind === SyntaxKind.BindingElement && e.dotDotDotToken)) {                 elementTypes.push(!isOmittedExpression(e) && hasDefaultValue(e) ? getTypeFromBindingElement(e, /*includePatternInType* / false, /*reportErrors* / false) : anyType);                 elementFlags.push(ElementFlags.Optional);                 if (!isOmittedExpression(e) && !hasDefaultValue(e)) {                     reportImplicitAny(e, anyType);                 }             }         } */
         createTupleType(elementTypes, elementFlags, /* TODO(PropertyAccessExpression): type.target.readonly */ TODO)
    }
    widenTypeInferredFromInitializer := func(declaration HasExpressionInitializer, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        widened := /* TODO(ConditionalExpression): getCombinedNodeFlagsCached(declaration) & NodeFlags.Constant || isDeclarationReadonly(declaration) ? type : getWidenedLiteralType(type) */ TODO
        if isInJSFile(declaration) {
            if isEmptyLiteralType(widened) {
                /* TODO(ExpressionStatement): reportImplicitAny(declaration, anyType); */
                 anyType
            } else if isEmptyArrayLiteralType(widened) {
                /* TODO(ExpressionStatement): reportImplicitAny(declaration, anyArrayType); */
                 anyArrayType
            }
        }
         widened
    }
    isLiteralOfContextualType := func(candidateType Type, contextualType *Type) bool {
        if contextualType {
            if /* TODO(BinaryExpression): contextualType.flags & TypeFlags.UnionOrIntersection */ TODO {
                types := /* TODO(PropertyAccessExpression): (contextualType as UnionType).types */ TODO
                 some(types, /* TODO(ArrowFunction): t => isLiteralOfContextualType(candidateType, t) */ TODO)
            }
            if /* TODO(BinaryExpression): contextualType.flags & TypeFlags.InstantiableNonPrimitive */ TODO {
                constraint := /* TODO(BinaryExpression): getBaseConstraintOfType(contextualType) || unknownType */ TODO
                 /* TODO(BinaryExpression): maybeTypeOfKind(constraint, TypeFlags.String) && maybeTypeOfKind(candidateType, TypeFlags.StringLiteral) ||                     maybeTypeOfKind(constraint, TypeFlags.Number) && maybeTypeOfKind(candidateType, TypeFlags.NumberLiteral) ||                     maybeTypeOfKind(constraint, TypeFlags.BigInt) && maybeTypeOfKind(candidateType, TypeFlags.BigIntLiteral) ||                     maybeTypeOfKind(constraint, TypeFlags.ESSymbol) && maybeTypeOfKind(candidateType, TypeFlags.UniqueESSymbol) ||                     isLiteralOfContextualType(candidateType, constraint) */ TODO
            }
             /* TODO(PrefixUnaryExpression): !!(contextualType.flags & (TypeFlags.StringLiteral | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && maybeTypeOfKind(candidateType, TypeFlags.StringLiteral) ||                 contextualType.flags & TypeFlags.NumberLiteral && maybeTypeOfKind(candidateType, TypeFlags.NumberLiteral) ||                 contextualType.flags & TypeFlags.BigIntLiteral && maybeTypeOfKind(candidateType, TypeFlags.BigIntLiteral) ||                 contextualType.flags & TypeFlags.BooleanLiteral && maybeTypeOfKind(candidateType, TypeFlags.BooleanLiteral) ||                 contextualType.flags & TypeFlags.UniqueESSymbol && maybeTypeOfKind(candidateType, TypeFlags.UniqueESSymbol)) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isConstContext := func(node Expression) bool {
        parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
         /* TODO(BinaryExpression): isAssertionExpression(parent) && isConstTypeReference(parent.type) ||             isJSDocTypeAssertion(parent) && isConstTypeReference(getJSDocTypeAssertionType(parent)) ||             isValidConstAssertionArgument(node) && isConstTypeVariable(getContextualType(node, ContextFlags.None)) ||             (isParenthesizedExpression(parent) || isArrayLiteralExpression(parent) || isSpreadElement(parent)) && isConstContext(parent) ||             (isPropertyAssignment(parent) || isShorthandPropertyAssignment(parent) || isTemplateSpan(parent)) && isConstContext(parent.parent) */ TODO
    }
    checkExpressionForMutableLocation := func(node Expression, checkMode *CheckMode, forceTuple bool) Type {
        type_ := checkExpression(node, checkMode, forceTuple)
         /* TODO(ConditionalExpression): isConstContext(node) || isCommonJsExportedExpression(node) ? getRegularTypeOfLiteralType(type) :             isTypeAssertion(node) ? type :             getWidenedLiteralLikeTypeForContextualType(type, instantiateContextualType(getContextualType(node, /*contextFlags* / undefined), node, /*contextFlags* / undefined)) */ TODO
    }
    checkPropertyAssignment := func(node PropertyAssignment, checkMode CheckMode) Type {
        if /* TODO(BinaryExpression): node.name.kind === SyntaxKind.ComputedPropertyName */ TODO {
            /* TODO(ExpressionStatement): checkComputedPropertyName(node.name); */
        }
         checkExpressionForMutableLocation(/* TODO(PropertyAccessExpression): node.initializer */ TODO, checkMode)
    }
    checkObjectLiteralMethod := func(node MethodDeclaration, checkMode CheckMode) Type {
        /* TODO(ExpressionStatement): checkGrammarMethod(node); */
        if /* TODO(BinaryExpression): node.name.kind === SyntaxKind.ComputedPropertyName */ TODO {
            /* TODO(ExpressionStatement): checkComputedPropertyName(node.name); */
        }
        uninstantiatedType := checkFunctionExpressionOrObjectLiteralMethod(node, checkMode)
         instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
    }
    instantiateTypeWithSingleGenericCallSignature := func(node /* TODO(UnionType): Expression | MethodDeclaration | QualifiedName */ any, type_ Type, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(BinaryExpression): checkMode && checkMode & (CheckMode.Inferential | CheckMode.SkipGenericFunctions) */ TODO {
            callSignature := getSingleSignature(type_, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO, /* TODO(TrueKeyword): true */ TODO)
            constructSignature := getSingleSignature(type_, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO, /* TODO(TrueKeyword): true */ TODO)
            signature := /* TODO(BinaryExpression): callSignature || constructSignature */ TODO
            if /* TODO(BinaryExpression): signature && signature.typeParameters */ TODO {
                contextualType := getApparentTypeOfContextualType(node /* as */ /* TODO(TypeReference): Expression */, /* TODO(PropertyAccessExpression): ContextFlags.NoConstraints */ TODO)
                if contextualType {
                    contextualSignature := getSingleSignature(getNonNullableType(contextualType), /* TODO(ConditionalExpression): callSignature ? SignatureKind.Call : SignatureKind.Construct */ TODO, /* TODO(FalseKeyword): false */ TODO)
                    if /* TODO(BinaryExpression): contextualSignature && !contextualSignature.typeParameters */ TODO {
                        if /* TODO(BinaryExpression): checkMode & CheckMode.SkipGenericFunctions */ TODO {
                            /* TODO(ExpressionStatement): skippedGenericFunction(node, checkMode); */
                             anyFunctionType
                        }
                        context := /* TODO(NonNullExpression): getInferenceContext(node)! */ TODO
                        returnType := /* TODO(BinaryExpression): context.signature && getReturnTypeOfSignature(context.signature) */ TODO
                        returnSignature := /* TODO(BinaryExpression): returnType && getSingleCallOrConstructSignature(returnType) */ TODO
                        if /* TODO(BinaryExpression): returnSignature && !returnSignature.typeParameters && !every(context.inferences, hasInferenceCandidates) */ TODO {
                            uniqueTypeParameters := getUniqueTypeParameters(context, /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO)
                            instantiatedSignature := getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters)
                            inferences := map_(/* TODO(PropertyAccessExpression): context.inferences */ TODO, /* TODO(ArrowFunction): info => createInferenceInfo(info.typeParameter) */ TODO)
                            /* TODO(ExpressionStatement): applyToParameterTypes(instantiatedSignature, contextualSignature, (source, target) => {                                 inferTypes(inferences, source, target, /*priority* / 0, /*contravariant* / true);                             }); */
                            if some(inferences, hasInferenceCandidates) {
                                /* TODO(ExpressionStatement): applyToReturnTypes(instantiatedSignature, contextualSignature, (source, target) => {                                     inferTypes(inferences, source, target);                                 }); */
                                if /* TODO(PrefixUnaryExpression): !hasOverlappingInferences(context.inferences, inferences) */ TODO {
                                    /* TODO(ExpressionStatement): mergeInferences(context.inferences, inferences); */
                                    /* TODO(ExpressionStatement): context.inferredTypeParameters = concatenate(context.inferredTypeParameters, uniqueTypeParameters); */
                                     getOrCreateTypeFromSignature(instantiatedSignature)
                                }
                            }
                        }
                         getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context), /* TODO(PropertyAccessExpression): flatMap(inferenceContexts, c => c && map(c.inferences, i => i.typeParameter)).slice */ TODO())
                    }
                }
            }
        }
         type_
    }
    skippedGenericFunction := func(node Node, checkMode CheckMode) {
        if /* TODO(BinaryExpression): checkMode & CheckMode.Inferential */ TODO {
            context := /* TODO(NonNullExpression): getInferenceContext(node)! */ TODO
            /* TODO(ExpressionStatement): context.flags |= InferenceFlags.SkippedGenericFunction; */
        }
    }
    hasInferenceCandidates := func(info InferenceInfo) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(info.candidates || info.contraCandidates) */ TODO
    }
    hasInferenceCandidatesOrDefault := func(info InferenceInfo) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!(info.candidates || info.contraCandidates || hasTypeParameterDefault(info.typeParameter)) */ TODO
    }
    hasOverlappingInferences := func(a []InferenceInfo, b []InferenceInfo) /* TODO(undefined): boolean */ TODO {
        /* TODO(ForStatement): for (let i = 0; i < a.length; i++) {             if (hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i])) {                 return true;             }         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    mergeInferences := func(target []InferenceInfo, source []InferenceInfo) {
        /* TODO(ForStatement): for (let i = 0; i < target.length; i++) {             if (!hasInferenceCandidates(target[i]) && hasInferenceCandidates(source[i])) {                 target[i] = source[i];             }         } */
    }
    getUniqueTypeParameters := func(context InferenceContext, typeParameters []TypeParameter) []TypeParameter {
        var result []TypeParameter = /* TODO(ArrayLiteralExpression): [] */ TODO
        var oldTypeParameters /* TODO(ArrayType): TypeParameter[] */ any
        var newTypeParameters /* TODO(ArrayType): TypeParameter[] */ any
        /* TODO(ForOfStatement): for (const tp of typeParameters) {             const name = tp.symbol.escapedName;             if (hasTypeParameterByName(context.inferredTypeParameters, name) || hasTypeParameterByName(result, name)) {                 const newName = getUniqueTypeParameterName(concatenate(context.inferredTypeParameters, result), name);                 const symbol = createSymbol(SymbolFlags.TypeParameter, newName);                 const newTypeParameter = createTypeParameter(symbol);                 newTypeParameter.target = tp;                 oldTypeParameters = append(oldTypeParameters, tp);                 newTypeParameters = append(newTypeParameters, newTypeParameter);                 result.push(newTypeParameter);             }             else {                 result.push(tp);             }         } */
        if newTypeParameters {
            mapper := createTypeMapper(/* TODO(NonNullExpression): oldTypeParameters! */ TODO, newTypeParameters)
            /* TODO(ForOfStatement): for (const tp of newTypeParameters) {                 tp.mapper = mapper;             } */
        }
         result
    }
    hasTypeParameterByName := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, name __String) /* TODO(undefined): boolean */ TODO {
         some(typeParameters, /* TODO(ArrowFunction): tp => tp.symbol.escapedName === name */ TODO)
    }
    getUniqueTypeParameterName := func(typeParameters []TypeParameter, baseName __String) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
        len := /* TODO(PropertyAccessExpression): (baseName as string).length */ TODO
        /* TODO(WhileStatement): while (len > 1 && (baseName as string).charCodeAt(len - 1) >= CharacterCodes._0 && (baseName as string).charCodeAt(len - 1) <= CharacterCodes._9) len--; */
        s := /* TODO(PropertyAccessExpression): (baseName as string).slice */ TODO(0, len)
        /* TODO(ForStatement): for (let index = 1; true; index++) {             const augmentedName = s + index as __String;             if (!hasTypeParameterByName(typeParameters, augmentedName)) {                 return augmentedName;             }         } */
    }
    getReturnTypeOfSingleNonGenericCallSignature := func(funcType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        signature := getSingleCallSignature(funcType)
        if /* TODO(BinaryExpression): signature && !signature.typeParameters */ TODO {
             getReturnTypeOfSignature(signature)
        }
    }
    getReturnTypeOfSingleNonGenericSignatureOfCallChain := func(expr CallChain) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        funcType := checkExpression(/* TODO(PropertyAccessExpression): expr.expression */ TODO)
        nonOptionalType := getOptionalExpressionType(funcType, /* TODO(PropertyAccessExpression): expr.expression */ TODO)
        returnType := getReturnTypeOfSingleNonGenericCallSignature(funcType)
         /* TODO(BinaryExpression): returnType && propagateOptionalTypeMarker(returnType, expr, nonOptionalType !== funcType) */ TODO
    }
    getTypeOfExpression := func(node Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        quickType := getQuickTypeOfExpression(node)
        if quickType {
             quickType
        }
        if /* TODO(BinaryExpression): node.flags & NodeFlags.TypeCached && flowTypeCache */ TODO {
            cachedType := /* TODO(ElementAccessExpression): flowTypeCache[getNodeId(node)] */ TODO
            if cachedType {
                 cachedType
            }
        }
        startInvocationCount := flowInvocationCount
        type_ := checkExpression(node, /* TODO(PropertyAccessExpression): CheckMode.TypeOnly */ TODO)
        if /* TODO(BinaryExpression): flowInvocationCount !== startInvocationCount */ TODO {
            cache := /* TODO(BinaryExpression): flowTypeCache || (flowTypeCache = []) */ TODO
            /* TODO(ExpressionStatement): cache[getNodeId(node)] = type; */
            /* TODO(ExpressionStatement): setNodeFlags(node, node.flags | NodeFlags.TypeCached); */
        }
         type_
    }
    getQuickTypeOfExpression := func(node Expression) *Type {
        expr := skipParentheses(node, /* TODO(TrueKeyword): true */ TODO)
        if isJSDocTypeAssertion(expr) {
            type_ := getJSDocTypeAssertionType(expr)
            if /* TODO(PrefixUnaryExpression): !isConstTypeReference(type) */ TODO {
                 getTypeFromTypeNode(type_)
            }
        }
        /* TODO(ExpressionStatement): expr = skipParentheses(node); */
        if isAwaitExpression(expr) {
            type_ := getQuickTypeOfExpression(/* TODO(PropertyAccessExpression): expr.expression */ TODO)
             /* TODO(ConditionalExpression): type ? getAwaitedType(type) : undefined */ TODO
        }
        if /* TODO(BinaryExpression): isCallExpression(expr) && expr.expression.kind !== SyntaxKind.SuperKeyword && !isRequireCall(expr, /*requireStringLiteralLikeArgument* / true) && !isSymbolOrSymbolForCall(expr) */ TODO {
             /* TODO(ConditionalExpression): isCallChain(expr) ? getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) :                 getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(expr.expression)) */ TODO
        } else if /* TODO(BinaryExpression): isAssertionExpression(expr) && !isConstTypeReference(expr.type) */ TODO {
             getTypeFromTypeNode(/* TODO(PropertyAccessExpression): (expr as TypeAssertion).type */ TODO)
        } else if /* TODO(BinaryExpression): isLiteralExpression(node) || isBooleanLiteral(node) */ TODO {
             checkExpression(node)
        }
         undefined
    }
    getContextFreeTypeOfExpression := func(node Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        links := getNodeLinks(node)
        if /* TODO(PropertyAccessExpression): links.contextFreeType */ TODO {
             /* TODO(PropertyAccessExpression): links.contextFreeType */ TODO
        }
        /* TODO(ExpressionStatement): pushContextualType(node, anyType, /*isCache* / false); */
        type_ := /* TODO(BinaryExpression): links.contextFreeType = checkExpression(node, CheckMode.SkipContextSensitive) */ TODO
        /* TODO(ExpressionStatement): popContextualType(); */
         type_
    }
    checkExpression := func(node /* TODO(UnionType): Expression | QualifiedName */ any, checkMode CheckMode, forceTuple bool) Type {
        /* TODO(ExpressionStatement): tracing?.push(tracing.Phase.Check, "checkExpression", { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath }); */
        saveCurrentNode := currentNode
        /* TODO(ExpressionStatement): currentNode = node; */
        /* TODO(ExpressionStatement): instantiationCount = 0; */
        uninstantiatedType := checkExpressionWorker(node, checkMode, forceTuple)
        type_ := instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
        if isConstEnumObjectType(type_) {
            /* TODO(ExpressionStatement): checkConstEnumAccess(node, type); */
        }
        /* TODO(ExpressionStatement): currentNode = saveCurrentNode; */
        /* TODO(ExpressionStatement): tracing?.pop(); */
         type_
    }
    checkConstEnumAccess := func(node /* TODO(UnionType): Expression | QualifiedName */ any, type_ Type) {
        ok := /* TODO(BinaryExpression): (node.parent.kind === SyntaxKind.PropertyAccessExpression && (node.parent as PropertyAccessExpression).expression === node) ||             (node.parent.kind === SyntaxKind.ElementAccessExpression && (node.parent as ElementAccessExpression).expression === node) ||             ((node.kind === SyntaxKind.Identifier || node.kind === SyntaxKind.QualifiedName) && isInRightSideOfImportOrExportAssignment(node as Identifier) ||                 (node.parent.kind === SyntaxKind.TypeQuery && (node.parent as TypeQueryNode).exprName === node)) ||             (node.parent.kind === SyntaxKind.ExportSpecifier) */ TODO
        if /* TODO(PrefixUnaryExpression): !ok */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query); */
        }
        if /* TODO(BinaryExpression): compilerOptions.isolatedModules             || compilerOptions.verbatimModuleSyntax                 && ok                 && !resolveName(                     node,                     getFirstIdentifier(node as EntityNameOrEntityNameExpression),                     SymbolFlags.Alias,                     /*nameNotFoundMessage* / undefined,                     /*isUse* / false,                     /*excludeGlobals* / true,                 ) */ TODO {
            /* TODO(ExpressionStatement): Debug.assert(!!(type.symbol.flags & SymbolFlags.ConstEnum)); */
            constEnumDeclaration := /* TODO(PropertyAccessExpression): type.symbol.valueDeclaration */ TODO /* as */ /* TODO(TypeReference): EnumDeclaration */
            redirect := /* TODO(PropertyAccessExpression): host.getRedirectReferenceForResolutionFromSourceOfProject */ TODO(/* TODO(PropertyAccessExpression): getSourceFileOfNode(constEnumDeclaration).resolvedPath */ TODO)
            if /* TODO(BinaryExpression): constEnumDeclaration.flags & NodeFlags.Ambient && !isValidTypeOnlyAliasUseSite(node) && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName); */
            }
        }
    }
    checkParenthesizedExpression := func(node ParenthesizedExpression, checkMode CheckMode) Type {
        if hasJSDocNodes(node) {
            if isJSDocSatisfiesExpression(node) {
                 checkSatisfiesExpressionWorker(/* TODO(PropertyAccessExpression): node.expression */ TODO, getJSDocSatisfiesExpressionType(node), checkMode)
            }
            if isJSDocTypeAssertion(node) {
                 checkAssertionWorker(node, checkMode)
            }
        }
         checkExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO, checkMode)
    }
    checkExpressionWorker := func(node /* TODO(UnionType): Expression | QualifiedName */ any, checkMode *CheckMode, forceTuple bool) Type {
        kind := /* TODO(PropertyAccessExpression): node.kind */ TODO
        if cancellationToken {
            /* TODO(SwitchStatement): switch (kind) {                 case SyntaxKind.ClassExpression:                 case SyntaxKind.FunctionExpression:                 case SyntaxKind.ArrowFunction:                     cancellationToken.throwIfCancellationRequested();             } */
        }
        /* TODO(SwitchStatement): switch (kind) {             case SyntaxKind.Identifier:                 return checkIdentifier(node as Identifier, checkMode);             case SyntaxKind.PrivateIdentifier:                 return checkPrivateIdentifierExpression(node as PrivateIdentifier);             case SyntaxKind.ThisKeyword:                 return checkThisExpression(node);             case SyntaxKind.SuperKeyword:                 return checkSuperExpression(node);             case SyntaxKind.NullKeyword:                 return nullWideningType;             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.StringLiteral:                 return hasSkipDirectInferenceFlag(node) ?                     blockedStringType :                     getFreshTypeOfLiteralType(getStringLiteralType((node as StringLiteralLike).text));             case SyntaxKind.NumericLiteral:                 checkGrammarNumericLiteral(node as NumericLiteral);                 return getFreshTypeOfLiteralType(getNumberLiteralType(+(node as NumericLiteral).text));             case SyntaxKind.BigIntLiteral:                 checkGrammarBigIntLiteral(node as BigIntLiteral);                 return getFreshTypeOfLiteralType(getBigIntLiteralType({                     negative: false,                     base10Value: parsePseudoBigInt((node as BigIntLiteral).text),                 }));             case SyntaxKind.TrueKeyword:                 return trueType;             case SyntaxKind.FalseKeyword:                 return falseType;             case SyntaxKind.TemplateExpression:                 return checkTemplateExpression(node as TemplateExpression);             case SyntaxKind.RegularExpressionLiteral:                 return checkRegularExpressionLiteral(node as RegularExpressionLiteral);             case SyntaxKind.ArrayLiteralExpression:                 return checkArrayLiteral(node as ArrayLiteralExpression, checkMode, forceTuple);             case SyntaxKind.ObjectLiteralExpression:                 return checkObjectLiteral(node as ObjectLiteralExpression, checkMode);             case SyntaxKind.PropertyAccessExpression:                 return checkPropertyAccessExpression(node as PropertyAccessExpression, checkMode);             case SyntaxKind.QualifiedName:                 return checkQualifiedName(node as QualifiedName, checkMode);             case SyntaxKind.ElementAccessExpression:                 return checkIndexedAccess(node as ElementAccessExpression, checkMode);             case SyntaxKind.CallExpression:                 if ((node as CallExpression).expression.kind === SyntaxKind.ImportKeyword) {                     return checkImportCallExpression(node as ImportCall);                 }                 // falls through             case SyntaxKind.NewExpression:                 return checkCallExpression(node as CallExpression, checkMode);             case SyntaxKind.TaggedTemplateExpression:                 return checkTaggedTemplateExpression(node as TaggedTemplateExpression);             case SyntaxKind.ParenthesizedExpression:                 return checkParenthesizedExpression(node as ParenthesizedExpression, checkMode);             case SyntaxKind.ClassExpression:                 return checkClassExpression(node as ClassExpression);             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:                 return checkFunctionExpressionOrObjectLiteralMethod(node as FunctionExpression | ArrowFunction, checkMode);             case SyntaxKind.TypeOfExpression:                 return checkTypeOfExpression(node as TypeOfExpression);             case SyntaxKind.TypeAssertionExpression:             case SyntaxKind.AsExpression:                 return checkAssertion(node as AssertionExpression, checkMode);             case SyntaxKind.NonNullExpression:                 return checkNonNullAssertion(node as NonNullExpression);             case SyntaxKind.ExpressionWithTypeArguments:                 return checkExpressionWithTypeArguments(node as ExpressionWithTypeArguments);             case SyntaxKind.SatisfiesExpression:                 return checkSatisfiesExpression(node as SatisfiesExpression);             case SyntaxKind.MetaProperty:                 return checkMetaProperty(node as MetaProperty);             case SyntaxKind.DeleteExpression:                 return checkDeleteExpression(node as DeleteExpression);             case SyntaxKind.VoidExpression:                 return checkVoidExpression(node as VoidExpression);             case SyntaxKind.AwaitExpression:                 return checkAwaitExpression(node as AwaitExpression);             case SyntaxKind.PrefixUnaryExpression:                 return checkPrefixUnaryExpression(node as PrefixUnaryExpression);             case SyntaxKind.PostfixUnaryExpression:                 return checkPostfixUnaryExpression(node as PostfixUnaryExpression);             case SyntaxKind.BinaryExpression:                 return checkBinaryExpression(node as BinaryExpression, checkMode);             case SyntaxKind.ConditionalExpression:                 return checkConditionalExpression(node as ConditionalExpression, checkMode);             case SyntaxKind.SpreadElement:                 return checkSpreadExpression(node as SpreadElement, checkMode);             case SyntaxKind.OmittedExpression:                 return undefinedWideningType;             case SyntaxKind.YieldExpression:                 return checkYieldExpression(node as YieldExpression);             case SyntaxKind.SyntheticExpression:                 return checkSyntheticExpression(node as SyntheticExpression);             case SyntaxKind.JsxExpression:                 return checkJsxExpression(node as JsxExpression, checkMode);             case SyntaxKind.JsxElement:                 return checkJsxElement(node as JsxElement, checkMode);             case SyntaxKind.JsxSelfClosingElement:                 return checkJsxSelfClosingElement(node as JsxSelfClosingElement, checkMode);             case SyntaxKind.JsxFragment:                 return checkJsxFragment(node as JsxFragment);             case SyntaxKind.JsxAttributes:                 return checkJsxAttributes(node as JsxAttributes, checkMode);             case SyntaxKind.JsxOpeningElement:                 Debug.fail("Shouldn't ever directly check a JsxOpeningElement");         } */
         errorType
    }
    checkTypeParameter := func(node TypeParameterDeclaration) {
        /* TODO(ExpressionStatement): checkGrammarModifiers(node); */
        if /* TODO(PropertyAccessExpression): node.expression */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnFirstToken(node.expression, Diagnostics.Type_expected); */
        }
        /* TODO(ExpressionStatement): checkSourceElement(node.constraint); */
        /* TODO(ExpressionStatement): checkSourceElement(node.default); */
        typeParameter := getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node))
        /* TODO(ExpressionStatement): getBaseConstraintOfType(typeParameter); */
        if /* TODO(PrefixUnaryExpression): !hasNonCircularTypeParameterDefault(typeParameter) */ TODO {
            /* TODO(ExpressionStatement): error(node.default, Diagnostics.Type_parameter_0_has_a_circular_default, typeToString(typeParameter)); */
        }
        constraintType := getConstraintOfTypeParameter(typeParameter)
        defaultType := getDefaultFromTypeParameter(typeParameter)
        if /* TODO(BinaryExpression): constraintType && defaultType */ TODO {
            /* TODO(ExpressionStatement): checkTypeAssignableTo(defaultType, getTypeWithThisArgument(instantiateType(constraintType, makeUnaryTypeMapper(typeParameter, defaultType)), defaultType), node.default, Diagnostics.Type_0_does_not_satisfy_the_constraint_1); */
        }
        /* TODO(ExpressionStatement): checkNodeDeferred(node); */
        /* TODO(ExpressionStatement): addLazyDiagnostic(() => checkTypeNameIsReserved(node.name, Diagnostics.Type_parameter_name_cannot_be_0)); */
    }
    checkTypeParameterDeferred := func(node TypeParameterDeclaration) {
        if /* TODO(BinaryExpression): isInterfaceDeclaration(node.parent) || isClassLike(node.parent) || isTypeAliasDeclaration(node.parent) */ TODO {
            typeParameter := getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node))
            modifiers := /* TODO(BinaryExpression): getTypeParameterModifiers(typeParameter) & (ModifierFlags.In | ModifierFlags.Out) */ TODO
            if modifiers {
                symbol := getSymbolOfDeclaration(/* TODO(PropertyAccessExpression): node.parent */ TODO)
                if /* TODO(BinaryExpression): isTypeAliasDeclaration(node.parent) && !(getObjectFlags(getDeclaredTypeOfSymbol(symbol)) & (ObjectFlags.Reference | ObjectFlags.Anonymous | ObjectFlags.Mapped)) */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types); */
                } else if /* TODO(BinaryExpression): modifiers === ModifierFlags.In || modifiers === ModifierFlags.Out */ TODO {
                    /* TODO(ExpressionStatement): tracing?.push(tracing.Phase.CheckTypes, "checkTypeParameterDeferred", { parent: getTypeId(getDeclaredTypeOfSymbol(symbol)), id: getTypeId(typeParameter) }); */
                    source := createMarkerType(symbol, typeParameter, /* TODO(ConditionalExpression): modifiers === ModifierFlags.Out ? markerSubTypeForCheck : markerSuperTypeForCheck */ TODO)
                    target := createMarkerType(symbol, typeParameter, /* TODO(ConditionalExpression): modifiers === ModifierFlags.Out ? markerSuperTypeForCheck : markerSubTypeForCheck */ TODO)
                    saveVarianceTypeParameter := typeParameter
                    /* TODO(ExpressionStatement): varianceTypeParameter = typeParameter; */
                    /* TODO(ExpressionStatement): checkTypeAssignableTo(source, target, node, Diagnostics.Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation); */
                    /* TODO(ExpressionStatement): varianceTypeParameter = saveVarianceTypeParameter; */
                    /* TODO(ExpressionStatement): tracing?.pop(); */
                }
            }
        }
    }
    checkParameter := func(node ParameterDeclaration) {
        /* TODO(ExpressionStatement): checkGrammarModifiers(node); */
        /* TODO(ExpressionStatement): checkVariableLikeDeclaration(node); */
        func_ := /* TODO(NonNullExpression): getContainingFunction(node)! */ TODO
        if hasSyntacticModifier(node, /* TODO(PropertyAccessExpression): ModifierFlags.ParameterPropertyModifier */ TODO) {
            if /* TODO(PrefixUnaryExpression): !(func.kind === SyntaxKind.Constructor && nodeIsPresent(func.body)) */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation); */
            }
            if /* TODO(BinaryExpression): func.kind === SyntaxKind.Constructor && isIdentifier(node.name) && node.name.escapedText === "constructor" */ TODO {
                /* TODO(ExpressionStatement): error(node.name, Diagnostics.constructor_cannot_be_used_as_a_parameter_property_name); */
            }
        }
        if /* TODO(BinaryExpression): !node.initializer && isOptionalDeclaration(node) && isBindingPattern(node.name) && (func as FunctionLikeDeclaration).body */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature); */
        }
        if /* TODO(BinaryExpression): node.name && isIdentifier(node.name) && (node.name.escapedText === "this" || node.name.escapedText === "new") */ TODO {
            if /* TODO(BinaryExpression): func.parameters.indexOf(node) !== 0 */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.A_0_parameter_must_be_the_first_parameter, node.name.escapedText as string); */
            }
            if /* TODO(BinaryExpression): func.kind === SyntaxKind.Constructor || func.kind === SyntaxKind.ConstructSignature || func.kind === SyntaxKind.ConstructorType */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.A_constructor_cannot_have_a_this_parameter); */
            }
            if /* TODO(BinaryExpression): func.kind === SyntaxKind.ArrowFunction */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.An_arrow_function_cannot_have_a_this_parameter); */
            }
            if /* TODO(BinaryExpression): func.kind === SyntaxKind.GetAccessor || func.kind === SyntaxKind.SetAccessor */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.get_and_set_accessors_cannot_declare_this_parameters); */
            }
        }
        if /* TODO(BinaryExpression): node.dotDotDotToken && !isBindingPattern(node.name) && !isTypeAssignableTo(getReducedType(getTypeOfSymbol(node.symbol)), anyReadonlyArrayType) */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.A_rest_parameter_must_be_of_an_array_type); */
        }
    }
    checkTypePredicate := func(node TypePredicateNode) {
        parent := getTypePredicateParent(node)
        if /* TODO(PrefixUnaryExpression): !parent */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods); */

        }
        signature := getSignatureFromDeclaration(parent)
        typePredicate := getTypePredicateOfSignature(signature)
        if /* TODO(PrefixUnaryExpression): !typePredicate */ TODO {

        }
        /* TODO(ExpressionStatement): checkSourceElement(node.type); */
        TODO_IDENTIFIER := node
        if /* TODO(BinaryExpression): typePredicate.kind !== TypePredicateKind.This && typePredicate.kind !== TypePredicateKind.AssertsThis */ TODO {
            if /* TODO(BinaryExpression): typePredicate.parameterIndex >= 0 */ TODO {
                if /* TODO(BinaryExpression): signatureHasRestParameter(signature) && typePredicate.parameterIndex === signature.parameters.length - 1 */ TODO {
                    /* TODO(ExpressionStatement): error(parameterName, Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter); */
                } else {
                    if /* TODO(PropertyAccessExpression): typePredicate.type */ TODO {
                        leadingError := /* TODO(ArrowFunction): () => chainDiagnosticMessages(/*details* / undefined, Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type) */ TODO
                        /* TODO(ExpressionStatement): checkTypeAssignableTo(typePredicate.type, getTypeOfSymbol(signature.parameters[typePredicate.parameterIndex]), node.type, /*headMessage* / undefined, leadingError); */
                    }
                }
            } else if parameterName {
                hasReportedError := /* TODO(FalseKeyword): false */ TODO
                /* TODO(ForOfStatement): for (const { name } of parent.parameters) {                     if (                         isBindingPattern(name) &&                         checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName)                     ) {                         hasReportedError = true;                         break;                     }                 } */
                if /* TODO(PrefixUnaryExpression): !hasReportedError */ TODO {
                    /* TODO(ExpressionStatement): error(node.parameterName, Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName); */
                }
            }
        }
    }
    getTypePredicateParent := func(node Node) *SignatureDeclaration {
        /* TODO(SwitchStatement): switch (node.parent.kind) {             case SyntaxKind.ArrowFunction:             case SyntaxKind.CallSignature:             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.FunctionExpression:             case SyntaxKind.FunctionType:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:                 const parent = node.parent as SignatureDeclaration;                 if (node === parent.type) {                     return parent;                 }         } */
    }
    checkIfTypePredicateVariableIsDeclaredInBindingPattern := func(pattern BindingPattern, predicateVariableNode Node, predicateVariableName string) /* TODO(undefined): true | undefined */ TODO {
        /* TODO(ForOfStatement): for (const element of pattern.elements) {             if (isOmittedExpression(element)) {                 continue;             }              const name = element.name;             if (name.kind === SyntaxKind.Identifier && name.escapedText === predicateVariableName) {                 error(predicateVariableNode, Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName);                 return true;             }             else if (name.kind === SyntaxKind.ArrayBindingPattern || name.kind === SyntaxKind.ObjectBindingPattern) {                 if (                     checkIfTypePredicateVariableIsDeclaredInBindingPattern(                         name,                         predicateVariableNode,                         predicateVariableName,                     )                 ) {                     return true;                 }             }         } */
    }
    checkSignatureDeclaration := func(node SignatureDeclaration) {
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.IndexSignature */ TODO {
            /* TODO(ExpressionStatement): checkGrammarIndexSignature(node); */
        } else if /* TODO(BinaryExpression): node.kind === SyntaxKind.FunctionType || node.kind === SyntaxKind.FunctionDeclaration || node.kind === SyntaxKind.ConstructorType ||             node.kind === SyntaxKind.CallSignature || node.kind === SyntaxKind.Constructor ||             node.kind === SyntaxKind.ConstructSignature */ TODO {
            /* TODO(ExpressionStatement): checkGrammarFunctionLikeDeclaration(node as FunctionLikeDeclaration); */
        }
        functionFlags := getFunctionFlags(node /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */)
        if /* TODO(PrefixUnaryExpression): !(functionFlags & FunctionFlags.Invalid) */ TODO {
            if /* TODO(BinaryExpression): (functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.AsyncGenerator && languageVersion < LanguageFeatureMinimumTarget.AsyncGenerators */ TODO {
                /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.AsyncGeneratorIncludes); */
            }
            if /* TODO(BinaryExpression): (functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.Async && languageVersion < LanguageFeatureMinimumTarget.AsyncFunctions */ TODO {
                /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.Awaiter); */
            }
            if /* TODO(BinaryExpression): (functionFlags & FunctionFlags.AsyncGenerator) !== FunctionFlags.Normal && languageVersion < LanguageFeatureMinimumTarget.Generators */ TODO {
                /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.Generator); */
            }
        }
        /* TODO(ExpressionStatement): checkTypeParameters(getEffectiveTypeParameterDeclarations(node)); */
        /* TODO(ExpressionStatement): checkUnmatchedJSDocParameters(node); */
        /* TODO(ExpressionStatement): forEach(node.parameters, checkParameter); */
        if /* TODO(PropertyAccessExpression): node.type */ TODO {
            /* TODO(ExpressionStatement): checkSourceElement(node.type); */
        }
        /* TODO(ExpressionStatement): addLazyDiagnostic(checkSignatureDeclarationDiagnostics); */
        checkSignatureDeclarationDiagnostics := func() {
            /* TODO(ExpressionStatement): checkCollisionWithArgumentsInGeneratedCode(node); */
            returnTypeNode := getEffectiveReturnTypeNode(node)
            returnTypeErrorLocation := returnTypeNode
            if isInJSFile(node) {
                typeTag := getJSDocTypeTag(node)
                if /* TODO(BinaryExpression): typeTag && typeTag.typeExpression && isTypeReferenceNode(typeTag.typeExpression.type) */ TODO {
                    signature := getSingleCallSignature(getTypeFromTypeNode(/* TODO(PropertyAccessExpression): typeTag.typeExpression */ TODO))
                    if /* TODO(BinaryExpression): signature && signature.declaration */ TODO {
                        /* TODO(ExpressionStatement): returnTypeNode = getEffectiveReturnTypeNode(signature.declaration); */
                        /* TODO(ExpressionStatement): returnTypeErrorLocation = typeTag.typeExpression.type; */
                    }
                }
            }
            if /* TODO(BinaryExpression): noImplicitAny && !returnTypeNode */ TODO {
                /* TODO(SwitchStatement): switch (node.kind) {                     case SyntaxKind.ConstructSignature:                         error(node, Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);                         break;                     case SyntaxKind.CallSignature:                         error(node, Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);                         break;                 } */
            }
            if /* TODO(BinaryExpression): returnTypeNode && returnTypeErrorLocation */ TODO {
                functionFlags := getFunctionFlags(node /* as */ /* TODO(TypeReference): FunctionDeclaration */)
                if /* TODO(BinaryExpression): (functionFlags & (FunctionFlags.Invalid | FunctionFlags.Generator)) === FunctionFlags.Generator */ TODO {
                    returnType := getTypeFromTypeNode(returnTypeNode)
                    if /* TODO(BinaryExpression): returnType === voidType */ TODO {
                        /* TODO(ExpressionStatement): error(returnTypeErrorLocation, Diagnostics.A_generator_cannot_have_a_void_type_annotation); */
                    } else {
                        /* TODO(ExpressionStatement): checkGeneratorInstantiationAssignabilityToReturnType(returnType, functionFlags, returnTypeErrorLocation); */
                    }
                } else if /* TODO(BinaryExpression): (functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.Async */ TODO {
                    /* TODO(ExpressionStatement): checkAsyncFunctionReturnType(node as FunctionLikeDeclaration, returnTypeNode, returnTypeErrorLocation); */
                }
            }
            if /* TODO(BinaryExpression): node.kind !== SyntaxKind.IndexSignature && node.kind !== SyntaxKind.JSDocFunctionType */ TODO {
                /* TODO(ExpressionStatement): registerForUnusedIdentifiersCheck(node); */
            }
        }
    }
    checkGeneratorInstantiationAssignabilityToReturnType := func(returnType Type, functionFlags FunctionFlags, errorNode TypeNode) /* TODO(undefined): boolean */ TODO {
        generatorYieldType := /* TODO(BinaryExpression): getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Yield, returnType, (functionFlags & FunctionFlags.Async) !== 0) || anyType */ TODO
        generatorReturnType := /* TODO(BinaryExpression): getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, returnType, (functionFlags & FunctionFlags.Async) !== 0) || generatorYieldType */ TODO
        generatorNextType := /* TODO(BinaryExpression): getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Next, returnType, (functionFlags & FunctionFlags.Async) !== 0) || unknownType */ TODO
        generatorInstantiation := createGeneratorType(generatorYieldType, generatorReturnType, generatorNextType, /* TODO(PrefixUnaryExpression): !!(functionFlags & FunctionFlags.Async) */ TODO)
         checkTypeAssignableTo(generatorInstantiation, returnType, errorNode)
    }
    checkClassForDuplicateDeclarations := func(node ClassLikeDeclaration) {
        instanceNames := /* TODO(NewExpression): new Map<__String, DeclarationMeaning>() */ TODO
        staticNames := /* TODO(NewExpression): new Map<__String, DeclarationMeaning>() */ TODO
        privateIdentifiers := /* TODO(NewExpression): new Map<__String, DeclarationMeaning>() */ TODO
        /* TODO(ForOfStatement): for (const member of node.members) {             if (member.kind === SyntaxKind.Constructor) {                 for (const param of (member as ConstructorDeclaration).parameters) {                     if (isParameterPropertyDeclaration(param, member) && !isBindingPattern(param.name)) {                         addName(instanceNames, param.name, param.name.escapedText, DeclarationMeaning.GetOrSetAccessor);                     }                 }             }             else {                 const isStaticMember = isStatic(member);                 const name = member.name;                 if (!name) {                     continue;                 }                 const isPrivate = isPrivateIdentifier(name);                 const privateStaticFlags = isPrivate && isStaticMember ? DeclarationMeaning.PrivateStatic : 0;                 const names = isPrivate ? privateIdentifiers :                     isStaticMember ? staticNames :                     instanceNames;                  const memberName = name && getEffectivePropertyNameForPropertyNameNode(name);                 if (memberName) {                     switch (member.kind) {                         case SyntaxKind.GetAccessor:                             addName(names, name, memberName, DeclarationMeaning.GetAccessor | privateStaticFlags);                             break;                          case SyntaxKind.SetAccessor:                             addName(names, name, memberName, DeclarationMeaning.SetAccessor | privateStaticFlags);                             break;                          case SyntaxKind.PropertyDeclaration:                             addName(names, name, memberName, DeclarationMeaning.GetOrSetAccessor | privateStaticFlags);                             break;                          case SyntaxKind.MethodDeclaration:                             addName(names, name, memberName, DeclarationMeaning.Method | privateStaticFlags);                             break;                     }                 }             }         } */
        addName := func(names Map[__String, DeclarationMeaning], location Node, name __String, meaning DeclarationMeaning) {
            prev := /* TODO(PropertyAccessExpression): names.get */ TODO(name)
            if prev {
                if /* TODO(BinaryExpression): (prev & DeclarationMeaning.PrivateStatic) !== (meaning & DeclarationMeaning.PrivateStatic) */ TODO {
                    /* TODO(ExpressionStatement): error(location, Diagnostics.Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name, getTextOfNode(location)); */
                } else {
                    prevIsMethod := /* TODO(PrefixUnaryExpression): !!(prev & DeclarationMeaning.Method) */ TODO
                    isMethod := /* TODO(PrefixUnaryExpression): !!(meaning & DeclarationMeaning.Method) */ TODO
                    if /* TODO(BinaryExpression): prevIsMethod || isMethod */ TODO {
                        if /* TODO(BinaryExpression): prevIsMethod !== isMethod */ TODO {
                            /* TODO(ExpressionStatement): error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location)); */
                        }
                    } else if /* TODO(BinaryExpression): prev & meaning & ~DeclarationMeaning.PrivateStatic */ TODO {
                        /* TODO(ExpressionStatement): error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location)); */
                    } else {
                        /* TODO(ExpressionStatement): names.set(name, prev | meaning); */
                    }
                }
            } else {
                /* TODO(ExpressionStatement): names.set(name, meaning); */
            }
        }
    }
    checkClassForStaticPropertyNameConflicts := func(node ClassLikeDeclaration) {
        /* TODO(ForOfStatement): for (const member of node.members) {             const memberNameNode = member.name;             const isStaticMember = isStatic(member);             if (isStaticMember && memberNameNode) {                 const memberName = getEffectivePropertyNameForPropertyNameNode(memberNameNode);                 switch (memberName) {                     case "name":                     case "length":                     case "caller":                     case "arguments":                         if (useDefineForClassFields) {                             break;                         }                         // fall through                     case "prototype":                         const message = Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1;                         const className = getNameOfSymbolAsWritten(getSymbolOfDeclaration(node));                         error(memberNameNode, message, memberName, className);                         break;                 }             }         } */
    }
    checkObjectTypeForDuplicateDeclarations := func(node /* TODO(UnionType): TypeLiteralNode | InterfaceDeclaration */ any) {
        names := /* TODO(NewExpression): new Map<string, boolean>() */ TODO
        /* TODO(ForOfStatement): for (const member of node.members) {             if (member.kind === SyntaxKind.PropertySignature) {                 let memberName: string;                 const name = member.name!;                 switch (name.kind) {                     case SyntaxKind.StringLiteral:                     case SyntaxKind.NumericLiteral:                         memberName = name.text;                         break;                     case SyntaxKind.Identifier:                         memberName = idText(name);                         break;                     default:                         continue;                 }                  if (names.get(memberName)) {                     error(getNameOfDeclaration(member.symbol.valueDeclaration), Diagnostics.Duplicate_identifier_0, memberName);                     error(member.name, Diagnostics.Duplicate_identifier_0, memberName);                 }                 else {                     names.set(memberName, true);                 }             }         } */
    }
    checkTypeForDuplicateIndexSignatures := func(node /* TODO(UnionType): ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode */ any) {
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.InterfaceDeclaration */ TODO {
            nodeSymbol := getSymbolOfDeclaration(node)
            if /* TODO(BinaryExpression): nodeSymbol.declarations && nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node */ TODO {

            }
        }
        indexSymbol := getIndexSymbol(getSymbolOfDeclaration(node))
        if /* TODO(PropertyAccessExpression): indexSymbol?.declarations */ TODO {
            indexSignatureMap := /* TODO(NewExpression): new Map<TypeId, { type: Type; declarations: IndexSignatureDeclaration[]; }>() */ TODO
            /* TODO(ForOfStatement): for (const declaration of (indexSymbol.declarations as IndexSignatureDeclaration[])) {                 if (declaration.parameters.length === 1 && declaration.parameters[0].type) {                     forEachType(getTypeFromTypeNode(declaration.parameters[0].type), type => {                         const entry = indexSignatureMap.get(getTypeId(type));                         if (entry) {                             entry.declarations.push(declaration);                         }                         else {                             indexSignatureMap.set(getTypeId(type), { type, declarations: [declaration] });                         }                     });                 }             } */
            /* TODO(ExpressionStatement): indexSignatureMap.forEach(entry => {                 if (entry.declarations.length > 1) {                     for (const declaration of entry.declarations) {                         error(declaration, Diagnostics.Duplicate_index_signature_for_type_0, typeToString(entry.type));                     }                 }             }); */
        }
    }
    checkPropertyDeclaration := func(node /* TODO(UnionType): PropertyDeclaration | PropertySignature */ any) {
        if /* TODO(BinaryExpression): !checkGrammarModifiers(node) && !checkGrammarProperty(node) */ TODO {
            /* TODO(CallExpression): checkGrammarComputedPropertyName(node.name) */
        }
        /* TODO(ExpressionStatement): checkVariableLikeDeclaration(node); */
        /* TODO(ExpressionStatement): setNodeLinksForPrivateIdentifierScope(node); */
        if /* TODO(BinaryExpression): hasSyntacticModifier(node, ModifierFlags.Abstract) && node.kind === SyntaxKind.PropertyDeclaration && node.initializer */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.Property_0_cannot_have_an_initializer_because_it_is_marked_abstract, declarationNameToString(node.name)); */
        }
    }
    checkPropertySignature := func(node PropertySignature) {
        if isPrivateIdentifier(/* TODO(PropertyAccessExpression): node.name */ TODO) {
            /* TODO(ExpressionStatement): error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies); */
        }
         checkPropertyDeclaration(node)
    }
    checkMethodDeclaration := func(node /* TODO(UnionType): MethodDeclaration | MethodSignature */ any) {
        if /* TODO(PrefixUnaryExpression): !checkGrammarMethod(node) */ TODO {
            /* TODO(CallExpression): checkGrammarComputedPropertyName(node.name) */
        }
        if /* TODO(BinaryExpression): isMethodDeclaration(node) && node.asteriskToken && isIdentifier(node.name) && idText(node.name) === "constructor" */ TODO {
            /* TODO(ExpressionStatement): error(node.name, Diagnostics.Class_constructor_may_not_be_a_generator); */
        }
        /* TODO(ExpressionStatement): checkFunctionOrMethodDeclaration(node); */
        if /* TODO(BinaryExpression): hasSyntacticModifier(node, ModifierFlags.Abstract) && node.kind === SyntaxKind.MethodDeclaration && node.body */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, declarationNameToString(node.name)); */
        }
        if /* TODO(BinaryExpression): isPrivateIdentifier(node.name) && !getContainingClass(node) */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies); */
        }
        /* TODO(ExpressionStatement): setNodeLinksForPrivateIdentifierScope(node); */
    }
    setNodeLinksForPrivateIdentifierScope := func(node /* TODO(UnionType): PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration */ any) {
        if isPrivateIdentifier(/* TODO(PropertyAccessExpression): node.name */ TODO) {
            if /* TODO(BinaryExpression): languageVersion < LanguageFeatureMinimumTarget.PrivateNamesAndClassStaticBlocks ||                 languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators ||                 !useDefineForClassFields */ TODO {
                /* TODO(ForStatement): for (let lexicalScope = getEnclosingBlockScopeContainer(node); !!lexicalScope; lexicalScope = getEnclosingBlockScopeContainer(lexicalScope)) {                     getNodeLinks(lexicalScope).flags |= NodeCheckFlags.ContainsClassWithPrivateIdentifiers;                 } */
                if isClassExpression(/* TODO(PropertyAccessExpression): node.parent */ TODO) {
                    enclosingIterationStatement := getEnclosingIterationStatement(/* TODO(PropertyAccessExpression): node.parent */ TODO)
                    if enclosingIterationStatement {
                        /* TODO(ExpressionStatement): getNodeLinks(node.name).flags |= NodeCheckFlags.BlockScopedBindingInLoop; */
                        /* TODO(ExpressionStatement): getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding; */
                    }
                }
            }
        }
    }
    checkClassStaticBlockDeclaration := func(node ClassStaticBlockDeclaration) {
        /* TODO(ExpressionStatement): checkGrammarModifiers(node); */
        /* TODO(ExpressionStatement): forEachChild(node, checkSourceElement); */
    }
    checkConstructorDeclaration := func(node ConstructorDeclaration) {
        /* TODO(ExpressionStatement): checkSignatureDeclaration(node); */
        if /* TODO(PrefixUnaryExpression): !checkGrammarConstructorTypeParameters(node) */ TODO {
            /* TODO(CallExpression): checkGrammarConstructorTypeAnnotation(node) */
        }
        /* TODO(ExpressionStatement): checkSourceElement(node.body); */
        symbol := getSymbolOfDeclaration(node)
        firstDeclaration := getDeclarationOfKind(symbol, /* TODO(PropertyAccessExpression): node.kind */ TODO)
        if /* TODO(BinaryExpression): node === firstDeclaration */ TODO {
            /* TODO(ExpressionStatement): checkFunctionOrConstructorSymbol(symbol); */
        }
        if nodeIsMissing(/* TODO(PropertyAccessExpression): node.body */ TODO) {

        }
        /* TODO(ExpressionStatement): addLazyDiagnostic(checkConstructorDeclarationDiagnostics); */

        isInstancePropertyWithInitializerOrPrivateIdentifierProperty := func(n Node) bool {
            if isPrivateIdentifierClassElementDeclaration(n) {
                 /* TODO(TrueKeyword): true */ TODO
            }
             /* TODO(BinaryExpression): n.kind === SyntaxKind.PropertyDeclaration &&                 !isStatic(n) &&                 !!(n as PropertyDeclaration).initializer */ TODO
        }
        checkConstructorDeclarationDiagnostics := func() {
            containingClassDecl := /* TODO(PropertyAccessExpression): node.parent */ TODO
            if getClassExtendsHeritageElement(containingClassDecl) {
                /* TODO(ExpressionStatement): captureLexicalThis(node.parent, containingClassDecl); */
                classExtendsNull := classDeclarationExtendsNull(containingClassDecl)
                superCall := findFirstSuperCall(/* TODO(NonNullExpression): node.body! */ TODO)
                if superCall {
                    if classExtendsNull {
                        /* TODO(ExpressionStatement): error(superCall, Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null); */
                    }
                    superCallShouldBeRootLevel := /* TODO(BinaryExpression): !emitStandardClassFields &&                         (some(node.parent.members, isInstancePropertyWithInitializerOrPrivateIdentifierProperty) ||                             some(node.parameters, p => hasSyntacticModifier(p, ModifierFlags.ParameterPropertyModifier))) */ TODO
                    if superCallShouldBeRootLevel {
                        if /* TODO(PrefixUnaryExpression): !superCallIsRootLevelInConstructor(superCall, node.body!) */ TODO {
                            /* TODO(ExpressionStatement): error(superCall, Diagnostics.A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers); */
                        } else {
                            var superCallStatement *ExpressionStatement
                            /* TODO(ForOfStatement): for (const statement of node.body!.statements) {                                 if (isExpressionStatement(statement) && isSuperCall(skipOuterExpressions(statement.expression))) {                                     superCallStatement = statement;                                     break;                                 }                                 if (nodeImmediatelyReferencesSuperOrThis(statement)) {                                     break;                                 }                             } */
                            if /* TODO(BinaryExpression): superCallStatement === undefined */ TODO {
                                /* TODO(ExpressionStatement): error(node, Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers); */
                            }
                        }
                    }
                } else if /* TODO(PrefixUnaryExpression): !classExtendsNull */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call); */
                }
            }
        }
    }
    superCallIsRootLevelInConstructor := func(superCall Node, body Block) /* TODO(undefined): boolean */ TODO {
        superCallParent := walkUpParenthesizedExpressions(/* TODO(PropertyAccessExpression): superCall.parent */ TODO)
         /* TODO(BinaryExpression): isExpressionStatement(superCallParent) && superCallParent.parent === body */ TODO
    }
    nodeImmediatelyReferencesSuperOrThis := func(node Node) bool {
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.SuperKeyword || node.kind === SyntaxKind.ThisKeyword */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if isThisContainerOrFunctionBlock(node) {
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(PrefixUnaryExpression): !!forEachChild(node, nodeImmediatelyReferencesSuperOrThis) */ TODO
    }
    checkAccessorDeclaration := func(node AccessorDeclaration) {
        if /* TODO(BinaryExpression): isIdentifier(node.name) && idText(node.name) === "constructor" && isClassLike(node.parent) */ TODO {
            /* TODO(ExpressionStatement): error(node.name, Diagnostics.Class_constructor_may_not_be_an_accessor); */
        }
        /* TODO(ExpressionStatement): addLazyDiagnostic(checkAccessorDeclarationDiagnostics); */
        /* TODO(ExpressionStatement): checkSourceElement(node.body); */
        /* TODO(ExpressionStatement): setNodeLinksForPrivateIdentifierScope(node); */
        checkAccessorDeclarationDiagnostics := func() {
            if /* TODO(BinaryExpression): !checkGrammarFunctionLikeDeclaration(node) && !checkGrammarAccessor(node) */ TODO {
                /* TODO(CallExpression): checkGrammarComputedPropertyName(node.name) */
            }
            /* TODO(ExpressionStatement): checkDecorators(node); */
            /* TODO(ExpressionStatement): checkSignatureDeclaration(node); */
            if /* TODO(BinaryExpression): node.kind === SyntaxKind.GetAccessor */ TODO {
                if /* TODO(BinaryExpression): !(node.flags & NodeFlags.Ambient) && nodeIsPresent(node.body) && (node.flags & NodeFlags.HasImplicitReturn) */ TODO {
                    if /* TODO(PrefixUnaryExpression): !(node.flags & NodeFlags.HasExplicitReturn) */ TODO {
                        /* TODO(ExpressionStatement): error(node.name, Diagnostics.A_get_accessor_must_return_a_value); */
                    }
                }
            }
            if /* TODO(BinaryExpression): node.name.kind === SyntaxKind.ComputedPropertyName */ TODO {
                /* TODO(ExpressionStatement): checkComputedPropertyName(node.name); */
            }
            if hasBindableName(node) {
                symbol := getSymbolOfDeclaration(node)
                getter := getDeclarationOfKind(symbol, /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */ TODO)
                setter := getDeclarationOfKind(symbol, /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */ TODO)
                if /* TODO(BinaryExpression): getter && setter && !(getNodeCheckFlags(getter) & NodeCheckFlags.TypeChecked) */ TODO {
                    /* TODO(ExpressionStatement): getNodeLinks(getter).flags |= NodeCheckFlags.TypeChecked; */
                    getterFlags := getEffectiveModifierFlags(getter)
                    setterFlags := getEffectiveModifierFlags(setter)
                    if /* TODO(BinaryExpression): (getterFlags & ModifierFlags.Abstract) !== (setterFlags & ModifierFlags.Abstract) */ TODO {
                        /* TODO(ExpressionStatement): error(getter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract); */
                        /* TODO(ExpressionStatement): error(setter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract); */
                    }
                    if /* TODO(BinaryExpression): ((getterFlags & ModifierFlags.Protected) && !(setterFlags & (ModifierFlags.Protected | ModifierFlags.Private))) ||                         ((getterFlags & ModifierFlags.Private) && !(setterFlags & ModifierFlags.Private)) */ TODO {
                        /* TODO(ExpressionStatement): error(getter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter); */
                        /* TODO(ExpressionStatement): error(setter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter); */
                    }
                }
            }
            returnType := getTypeOfAccessors(getSymbolOfDeclaration(node))
            if /* TODO(BinaryExpression): node.kind === SyntaxKind.GetAccessor */ TODO {
                /* TODO(ExpressionStatement): checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType); */
            }
        }
    }
    checkMissingDeclaration := func(node Node) {
        /* TODO(ExpressionStatement): checkDecorators(node); */
    }
    getEffectiveTypeArgumentAtIndex := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments */ any, typeParameters []TypeParameter, index number) Type {
        if /* TODO(BinaryExpression): node.typeArguments && index < node.typeArguments.length */ TODO {
             getTypeFromTypeNode(/* TODO(ElementAccessExpression): node.typeArguments[index] */ TODO)
        }
         /* TODO(ElementAccessExpression): getEffectiveTypeArguments(node, typeParameters)[index] */ TODO
    }
    getEffectiveTypeArguments := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) []Type {
         fillMissingTypeArguments(map_(/* TODO(NonNullExpression): node.typeArguments! */ TODO, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(node))
    }
    checkTypeArgumentConstraints := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) bool {
        var typeArguments /* TODO(ArrayType): Type[] */ any
        var mapper *TypeMapper
        result := /* TODO(TrueKeyword): true */ TODO
        /* TODO(ForStatement): for (let i = 0; i < typeParameters.length; i++) {             const constraint = getConstraintOfTypeParameter(typeParameters[i]);             if (constraint) {                 if (!typeArguments) {                     typeArguments = getEffectiveTypeArguments(node, typeParameters);                     mapper = createTypeMapper(typeParameters, typeArguments);                 }                 result = result && checkTypeAssignableTo(                     typeArguments[i],                     instantiateType(constraint, mapper),                     node.typeArguments![i],                     Diagnostics.Type_0_does_not_satisfy_the_constraint_1,                 );             }         } */
         result
    }
    getTypeParametersForTypeAndSymbol := func(type_ Type, symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
        if /* TODO(PrefixUnaryExpression): !isErrorType(type) */ TODO {
             /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeAlias && getSymbolLinks(symbol).typeParameters ||                 (getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).target.localTypeParameters : undefined) */ TODO
        }
         undefined
    }
    getTypeParametersForTypeReferenceOrImport := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
        type_ := getTypeFromTypeNode(node)
        if /* TODO(PrefixUnaryExpression): !isErrorType(type) */ TODO {
            symbol := /* TODO(PropertyAccessExpression): getNodeLinks(node).resolvedSymbol */ TODO
            if symbol {
                 getTypeParametersForTypeAndSymbol(type_, symbol)
            }
        }
         undefined
    }
    checkTypeReferenceNode := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments */ any) {
        /* TODO(ExpressionStatement): checkGrammarTypeArguments(node, node.typeArguments); */
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.TypeReference && !isInJSFile(node) && !isInJSDoc(node) && node.typeArguments && node.typeName.end !== node.typeArguments.pos */ TODO {
            sourceFile := getSourceFileOfNode(node)
            if /* TODO(BinaryExpression): scanTokenAtPosition(sourceFile, node.typeName.end) === SyntaxKind.DotToken */ TODO {
                /* TODO(ExpressionStatement): grammarErrorAtPos(node, skipTrivia(sourceFile.text, node.typeName.end), 1, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments); */
            }
        }
        /* TODO(ExpressionStatement): forEach(node.typeArguments, checkSourceElement); */
        /* TODO(ExpressionStatement): checkTypeReferenceOrImport(node); */
    }
    checkTypeReferenceOrImport := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) {
        type_ := getTypeFromTypeNode(node)
        if /* TODO(PrefixUnaryExpression): !isErrorType(type) */ TODO {
            if /* TODO(PropertyAccessExpression): node.typeArguments */ TODO {
                /* TODO(ExpressionStatement): addLazyDiagnostic(() => {                     const typeParameters = getTypeParametersForTypeReferenceOrImport(node);                     if (typeParameters) {                         checkTypeArgumentConstraints(node, typeParameters);                     }                 }); */
            }
            symbol := /* TODO(PropertyAccessExpression): getNodeLinks(node).resolvedSymbol */ TODO
            if symbol {
                if some(/* TODO(PropertyAccessExpression): symbol.declarations */ TODO, /* TODO(ArrowFunction): d => isTypeDeclaration(d) && !!(d.flags & NodeFlags.Deprecated) */ TODO) {
                    /* TODO(ExpressionStatement): addDeprecatedSuggestion(                         getDeprecatedSuggestionNode(node),                         symbol.declarations!,                         symbol.escapedName as string,                     ); */
                }
            }
        }
    }
    getTypeArgumentConstraint := func(node TypeNode) *Type {
        typeReferenceNode := tryCast(/* TODO(PropertyAccessExpression): node.parent */ TODO, isTypeReferenceType)
        if /* TODO(PrefixUnaryExpression): !typeReferenceNode */ TODO {
            /* TODO(Identifier): undefined */
        }
        typeParameters := getTypeParametersForTypeReferenceOrImport(typeReferenceNode)
        if /* TODO(PrefixUnaryExpression): !typeParameters */ TODO {
            /* TODO(Identifier): undefined */
        }
        constraint := getConstraintOfTypeParameter(/* TODO(ElementAccessExpression): typeParameters[typeReferenceNode.typeArguments!.indexOf(node)] */ TODO)
         /* TODO(BinaryExpression): constraint && instantiateType(constraint, createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReferenceNode, typeParameters))) */ TODO
    }
    checkTypeQuery := func(node TypeQueryNode) {
        /* TODO(ExpressionStatement): getTypeFromTypeQueryNode(node); */
    }
    checkTypeLiteral := func(node TypeLiteralNode) {
        /* TODO(ExpressionStatement): forEach(node.members, checkSourceElement); */
        /* TODO(ExpressionStatement): addLazyDiagnostic(checkTypeLiteralDiagnostics); */
        checkTypeLiteralDiagnostics := func() {
            type_ := getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node)
            /* TODO(ExpressionStatement): checkIndexConstraints(type, type.symbol); */
            /* TODO(ExpressionStatement): checkTypeForDuplicateIndexSignatures(node); */
            /* TODO(ExpressionStatement): checkObjectTypeForDuplicateDeclarations(node); */
        }
    }
    checkArrayType := func(node ArrayTypeNode) {
        /* TODO(ExpressionStatement): checkSourceElement(node.elementType); */
    }
    checkTupleType := func(node TupleTypeNode) {
        seenOptionalElement := /* TODO(FalseKeyword): false */ TODO
        seenRestElement := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForOfStatement): for (const e of node.elements) {             let flags = getTupleElementFlags(e);             if (flags & ElementFlags.Variadic) {                 const type = getTypeFromTypeNode((e as RestTypeNode | NamedTupleMember).type);                 if (!isArrayLikeType(type)) {                     error(e, Diagnostics.A_rest_element_type_must_be_an_array_type);                     break;                 }                 if (isArrayType(type) || isTupleType(type) && type.target.combinedFlags & ElementFlags.Rest) {                     flags |= ElementFlags.Rest;                 }             }             if (flags & ElementFlags.Rest) {                 if (seenRestElement) {                     grammarErrorOnNode(e, Diagnostics.A_rest_element_cannot_follow_another_rest_element);                     break;                 }                 seenRestElement = true;             }             else if (flags & ElementFlags.Optional) {                 if (seenRestElement) {                     grammarErrorOnNode(e, Diagnostics.An_optional_element_cannot_follow_a_rest_element);                     break;                 }                 seenOptionalElement = true;             }             else if (flags & ElementFlags.Required && seenOptionalElement) {                 grammarErrorOnNode(e, Diagnostics.A_required_element_cannot_follow_an_optional_element);                 break;             }         } */
        /* TODO(ExpressionStatement): forEach(node.elements, checkSourceElement); */
        /* TODO(ExpressionStatement): getTypeFromTypeNode(node); */
    }
    checkUnionOrIntersectionType := func(node UnionOrIntersectionTypeNode) {
        /* TODO(ExpressionStatement): forEach(node.types, checkSourceElement); */
        /* TODO(ExpressionStatement): getTypeFromTypeNode(node); */
    }
    checkIndexedAccessIndexType := func(type_ Type, accessNode /* TODO(UnionType): IndexedAccessTypeNode | ElementAccessExpression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(PrefixUnaryExpression): !(type.flags & TypeFlags.IndexedAccess) */ TODO {
             type_
        }
        objectType := /* TODO(PropertyAccessExpression): (type as IndexedAccessType).objectType */ TODO
        indexType := /* TODO(PropertyAccessExpression): (type as IndexedAccessType).indexType */ TODO
        objectIndexType := /* TODO(ConditionalExpression): isGenericMappedType(objectType) && getMappedTypeNameTypeKind(objectType) === MappedTypeNameTypeKind.Remapping             ? getIndexTypeForMappedType(objectType, IndexFlags.None)             : getIndexType(objectType, IndexFlags.None) */ TODO
        hasNumberIndexInfo := /* TODO(PrefixUnaryExpression): !!getIndexInfoOfType(objectType, numberType) */ TODO
        if everyType(indexType, /* TODO(ArrowFunction): t => isTypeAssignableTo(t, objectIndexType) || hasNumberIndexInfo && isApplicableIndexType(t, numberType) */ TODO) {
            if /* TODO(BinaryExpression): accessNode.kind === SyntaxKind.ElementAccessExpression && isAssignmentTarget(accessNode) &&                 getObjectFlags(objectType) & ObjectFlags.Mapped && getMappedTypeModifiers(objectType as MappedType) & MappedTypeModifiers.IncludeReadonly */ TODO {
                /* TODO(ExpressionStatement): error(accessNode, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType)); */
            }
             type_
        }
        if isGenericObjectType(objectType) {
            propertyName := getPropertyNameFromIndex(indexType, accessNode)
            if propertyName {
                propertySymbol := forEachType(getApparentType(objectType), /* TODO(ArrowFunction): t => getPropertyOfType(t, propertyName) */ TODO)
                if /* TODO(BinaryExpression): propertySymbol && getDeclarationModifierFlagsFromSymbol(propertySymbol) & ModifierFlags.NonPublicAccessibilityModifier */ TODO {
                    /* TODO(ExpressionStatement): error(accessNode, Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, unescapeLeadingUnderscores(propertyName)); */
                     errorType
                }
            }
        }
        /* TODO(ExpressionStatement): error(accessNode, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType)); */
         errorType
    }
    checkIndexedAccessType := func(node IndexedAccessTypeNode) {
        /* TODO(ExpressionStatement): checkSourceElement(node.objectType); */
        /* TODO(ExpressionStatement): checkSourceElement(node.indexType); */
        /* TODO(ExpressionStatement): checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node); */
    }
    checkMappedType := func(node MappedTypeNode) {
        /* TODO(ExpressionStatement): checkGrammarMappedType(node); */
        /* TODO(ExpressionStatement): checkSourceElement(node.typeParameter); */
        /* TODO(ExpressionStatement): checkSourceElement(node.nameType); */
        /* TODO(ExpressionStatement): checkSourceElement(node.type); */
        if /* TODO(PrefixUnaryExpression): !node.type */ TODO {
            /* TODO(ExpressionStatement): reportImplicitAny(node, anyType); */
        }
        type_ := getTypeFromMappedTypeNode(node) /* as */ /* TODO(TypeReference): MappedType */
        nameType := getNameTypeFromMappedType(type_)
        if nameType {
            /* TODO(ExpressionStatement): checkTypeAssignableTo(nameType, stringNumberSymbolType, node.nameType); */
        } else {
            constraintType := getConstraintTypeFromMappedType(type_)
            /* TODO(ExpressionStatement): checkTypeAssignableTo(constraintType, stringNumberSymbolType, getEffectiveConstraintOfTypeParameter(node.typeParameter)); */
        }
    }
    checkGrammarMappedType := func(node MappedTypeNode) /* TODO(undefined): boolean | undefined */ TODO {
        if /* TODO(PropertyAccessExpression): node.members?.length */ TODO {
             grammarErrorOnNode(/* TODO(ElementAccessExpression): node.members[0] */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_mapped_type_may_not_declare_properties_or_methods */ TODO)
        }
    }
    checkThisType := func(node ThisTypeNode) {
        /* TODO(ExpressionStatement): getTypeFromThisTypeNode(node); */
    }
    checkTypeOperator := func(node TypeOperatorNode) {
        /* TODO(ExpressionStatement): checkGrammarTypeOperatorNode(node); */
        /* TODO(ExpressionStatement): checkSourceElement(node.type); */
    }
    checkConditionalType := func(node ConditionalTypeNode) {
        /* TODO(ExpressionStatement): forEachChild(node, checkSourceElement); */
    }
    checkInferType := func(node InferTypeNode) {
        if /* TODO(PrefixUnaryExpression): !findAncestor(node, n => n.parent && n.parent.kind === SyntaxKind.ConditionalType && (n.parent as ConditionalTypeNode).extendsType === n) */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnNode(node, Diagnostics.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type); */
        }
        /* TODO(ExpressionStatement): checkSourceElement(node.typeParameter); */
        symbol := getSymbolOfDeclaration(/* TODO(PropertyAccessExpression): node.typeParameter */ TODO)
        if /* TODO(BinaryExpression): symbol.declarations && symbol.declarations.length > 1 */ TODO {
            links := getSymbolLinks(symbol)
            if /* TODO(PrefixUnaryExpression): !links.typeParametersChecked */ TODO {
                /* TODO(ExpressionStatement): links.typeParametersChecked = true; */
                typeParameter := getDeclaredTypeOfTypeParameter(symbol)
                var declarations []TypeParameterDeclaration = getDeclarationsOfKind(symbol, /* TODO(PropertyAccessExpression): SyntaxKind.TypeParameter */ TODO)
                if /* TODO(PrefixUnaryExpression): !areTypeParametersIdentical(declarations, [typeParameter], decl => [decl]) */ TODO {
                    name := symbolToString(symbol)
                    /* TODO(ForOfStatement): for (const declaration of declarations) {                         error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_constraints, name);                     } */
                }
            }
        }
        /* TODO(ExpressionStatement): registerForUnusedIdentifiersCheck(node); */
    }
    checkTemplateLiteralType := func(node TemplateLiteralTypeNode) {
        /* TODO(ForOfStatement): for (const span of node.templateSpans) {             checkSourceElement(span.type);             const type = getTypeFromTypeNode(span.type);             checkTypeAssignableTo(type, templateConstraintType, span.type);         } */
        /* TODO(ExpressionStatement): getTypeFromTypeNode(node); */
    }
    checkImportType := func(node ImportTypeNode) {
        /* TODO(ExpressionStatement): checkSourceElement(node.argument); */
        if /* TODO(PropertyAccessExpression): node.attributes */ TODO {
            /* TODO(ExpressionStatement): getResolutionModeOverride(node.attributes, grammarErrorOnNode); */
        }
        /* TODO(ExpressionStatement): checkTypeReferenceOrImport(node); */
    }
    checkNamedTupleMember := func(node NamedTupleMember) {
        if /* TODO(BinaryExpression): node.dotDotDotToken && node.questionToken */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnNode(node, Diagnostics.A_tuple_member_cannot_be_both_optional_and_rest); */
        }
        if /* TODO(BinaryExpression): node.type.kind === SyntaxKind.OptionalType */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnNode(node.type, Diagnostics.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type); */
        }
        if /* TODO(BinaryExpression): node.type.kind === SyntaxKind.RestType */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnNode(node.type, Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type); */
        }
        /* TODO(ExpressionStatement): checkSourceElement(node.type); */
        /* TODO(ExpressionStatement): getTypeFromTypeNode(node); */
    }
    isPrivateWithinAmbient := func(node Node) bool {
         /* TODO(BinaryExpression): (hasEffectiveModifier(node, ModifierFlags.Private) || isPrivateIdentifierClassElementDeclaration(node)) && !!(node.flags & NodeFlags.Ambient) */ TODO
    }
    getEffectiveDeclarationFlags := func(n Declaration, flagsToCheck ModifierFlags) ModifierFlags {
        flags := getCombinedModifierFlagsCached(n)
        if /* TODO(BinaryExpression): n.parent.kind !== SyntaxKind.InterfaceDeclaration &&             n.parent.kind !== SyntaxKind.ClassDeclaration &&             n.parent.kind !== SyntaxKind.ClassExpression &&             n.flags & NodeFlags.Ambient */ TODO {
            container := getEnclosingContainer(n)
            if /* TODO(BinaryExpression): (container && container.flags & NodeFlags.ExportContext) && !(flags & ModifierFlags.Ambient) && !(isModuleBlock(n.parent) && isModuleDeclaration(n.parent.parent) && isGlobalScopeAugmentation(n.parent.parent)) */ TODO {
                /* TODO(ExpressionStatement): flags |= ModifierFlags.Export; */
            }
            /* TODO(ExpressionStatement): flags |= ModifierFlags.Ambient; */
        }
         /* TODO(BinaryExpression): flags & flagsToCheck */ TODO
    }
    checkFunctionOrConstructorSymbol := func(symbol Symbol) {
        /* TODO(ExpressionStatement): addLazyDiagnostic(() => checkFunctionOrConstructorSymbolWorker(symbol)); */
    }
    checkFunctionOrConstructorSymbolWorker := func(symbol Symbol) {
        getCanonicalOverload := func(overloads []Declaration, implementation *FunctionLikeDeclaration) Declaration {
            implementationSharesContainerWithFirstOverload := /* TODO(BinaryExpression): implementation !== undefined && implementation.parent === overloads[0].parent */ TODO
             /* TODO(ConditionalExpression): implementationSharesContainerWithFirstOverload ? implementation : overloads[0] */ TODO
        }
        checkFlagAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, flagsToCheck ModifierFlags, someOverloadFlags ModifierFlags, allOverloadFlags ModifierFlags) {
            someButNotAllOverloadFlags := /* TODO(BinaryExpression): someOverloadFlags ^ allOverloadFlags */ TODO
            if /* TODO(BinaryExpression): someButNotAllOverloadFlags !== 0 */ TODO {
                canonicalFlags := getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck)
                /* TODO(ExpressionStatement): group(overloads, o => getSourceFileOfNode(o).fileName).forEach(overloadsInFile => {                     const canonicalFlagsForFile = getEffectiveDeclarationFlags(getCanonicalOverload(overloadsInFile, implementation), flagsToCheck);                     for (const o of overloadsInFile) {                         const deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags;                         const deviationInFile = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlagsForFile;                         if (deviationInFile & ModifierFlags.Export) {                             // Overloads in different files need not all have export modifiers. This is ok:                             //   // lib.d.ts                             //   declare function foo(s: number): string;                             //   declare function foo(s: string): number;                             //   export { foo };                             //                             //   // app.ts                             //   declare module "lib" {                             //     export function foo(s: boolean): boolean;                             //   }                             error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported);                         }                         else if (deviationInFile & ModifierFlags.Ambient) {                             // Though rare, a module augmentation (necessarily ambient) is allowed to add overloads                             // to a non-ambient function in an implementation file.                             error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);                         }                         else if (deviation & (ModifierFlags.Private | ModifierFlags.Protected)) {                             error(getNameOfDeclaration(o) || o, Diagnostics.Overload_signatures_must_all_be_public_private_or_protected);                         }                         else if (deviation & ModifierFlags.Abstract) {                             error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract);                         }                     }                 }); */
            }
        }
        checkQuestionTokenAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, someHaveQuestionToken bool, allHaveQuestionToken bool) {
            if /* TODO(BinaryExpression): someHaveQuestionToken !== allHaveQuestionToken */ TODO {
                canonicalHasQuestionToken := hasQuestionToken(getCanonicalOverload(overloads, implementation))
                /* TODO(ExpressionStatement): forEach(overloads, o => {                     const deviation = hasQuestionToken(o) !== canonicalHasQuestionToken;                     if (deviation) {                         error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_optional_or_required);                     }                 }); */
            }
        }
        var flagsToCheck ModifierFlags = /* TODO(BinaryExpression): ModifierFlags.Export | ModifierFlags.Ambient | ModifierFlags.Private | ModifierFlags.Protected | ModifierFlags.Abstract */ TODO
        var someNodeFlags ModifierFlags = /* TODO(PropertyAccessExpression): ModifierFlags.None */ TODO
        allNodeFlags := flagsToCheck
        someHaveQuestionToken := /* TODO(FalseKeyword): false */ TODO
        allHaveQuestionToken := /* TODO(TrueKeyword): true */ TODO
        hasOverloads := /* TODO(FalseKeyword): false */ TODO
        var bodyDeclaration *FunctionLikeDeclaration
        var lastSeenNonAmbientDeclaration *FunctionLikeDeclaration
        var previousDeclaration *SignatureDeclaration
        declarations := /* TODO(PropertyAccessExpression): symbol.declarations */ TODO
        isConstructor := /* TODO(BinaryExpression): (symbol.flags & SymbolFlags.Constructor) !== 0 */ TODO
        reportImplementationExpectedError := func(node SignatureDeclaration) {
            if /* TODO(BinaryExpression): node.name && nodeIsMissing(node.name) */ TODO {

            }
            seen := /* TODO(FalseKeyword): false */ TODO
            subsequentNode := forEachChild(/* TODO(PropertyAccessExpression): node.parent */ TODO, /* TODO(ArrowFunction): c => {                 if (seen) {                     return c;                 }                 else {                     seen = c === node;                 }             } */ TODO)
            if /* TODO(BinaryExpression): subsequentNode && subsequentNode.pos === node.end */ TODO {
                if /* TODO(BinaryExpression): subsequentNode.kind === node.kind */ TODO {
                    var errorNode Node = /* TODO(BinaryExpression): (subsequentNode as FunctionLikeDeclaration).name || subsequentNode */ TODO
                    subsequentName := /* TODO(PropertyAccessExpression): (subsequentNode as FunctionLikeDeclaration).name */ TODO
                    if /* TODO(BinaryExpression): node.name && subsequentName && (                             // both are private identifiers                             isPrivateIdentifier(node.name) && isPrivateIdentifier(subsequentName) && node.name.escapedText === subsequentName.escapedText ||                             // Both are computed property names                             isComputedPropertyName(node.name) && isComputedPropertyName(subsequentName) && isTypeIdenticalTo(checkComputedPropertyName(node.name), checkComputedPropertyName(subsequentName)) ||                             // Both are literal property names that are the same.                             isPropertyNameLiteral(node.name) && isPropertyNameLiteral(subsequentName) &&                                 getEscapedTextOfIdentifierOrLiteral(node.name) === getEscapedTextOfIdentifierOrLiteral(subsequentName)                         ) */ TODO {
                        reportError := /* TODO(BinaryExpression): (node.kind === SyntaxKind.MethodDeclaration || node.kind === SyntaxKind.MethodSignature) &&                             isStatic(node) !== isStatic(subsequentNode) */ TODO
                        if reportError {
                            diagnostic := /* TODO(ConditionalExpression): isStatic(node) ? Diagnostics.Function_overload_must_be_static : Diagnostics.Function_overload_must_not_be_static */ TODO
                            /* TODO(ExpressionStatement): error(errorNode, diagnostic); */
                        }

                    }
                    if nodeIsPresent(/* TODO(PropertyAccessExpression): (subsequentNode as FunctionLikeDeclaration).body */ TODO) {
                        /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Function_implementation_name_must_be_0, declarationNameToString(node.name)); */

                    }
                }
            }
            var errorNode Node = /* TODO(BinaryExpression): node.name || node */ TODO
            if isConstructor {
                /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Constructor_implementation_is_missing); */
            } else {
                if hasSyntacticModifier(node, /* TODO(PropertyAccessExpression): ModifierFlags.Abstract */ TODO) {
                    /* TODO(ExpressionStatement): error(errorNode, Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive); */
                } else {
                    /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration); */
                }
            }
        }
        duplicateFunctionDeclaration := /* TODO(FalseKeyword): false */ TODO
        multipleConstructorImplementation := /* TODO(FalseKeyword): false */ TODO
        hasNonAmbientClass := /* TODO(FalseKeyword): false */ TODO
        functionDeclarations := /* TODO(ArrayLiteralExpression): [] */ TODO /* as */ /* TODO(ArrayType): Declaration[] */
        if declarations {
            /* TODO(ForOfStatement): for (const current of declarations) {                 const node = current as SignatureDeclaration | ClassDeclaration | ClassExpression;                 const inAmbientContext = node.flags & NodeFlags.Ambient;                 const inAmbientContextOrInterface = node.parent && (node.parent.kind === SyntaxKind.InterfaceDeclaration || node.parent.kind === SyntaxKind.TypeLiteral) || inAmbientContext;                 if (inAmbientContextOrInterface) {                     // check if declarations are consecutive only if they are non-ambient                     // 1. ambient declarations can be interleaved                     // i.e. this is legal                     //     declare function foo();                     //     declare function bar();                     //     declare function foo();                     // 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one                     previousDeclaration = undefined;                 }                  if ((node.kind === SyntaxKind.ClassDeclaration || node.kind === SyntaxKind.ClassExpression) && !inAmbientContext) {                     hasNonAmbientClass = true;                 }                  if (node.kind === SyntaxKind.FunctionDeclaration || node.kind === SyntaxKind.MethodDeclaration || node.kind === SyntaxKind.MethodSignature || node.kind === SyntaxKind.Constructor) {                     functionDeclarations.push(node);                     const currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);                     someNodeFlags |= currentNodeFlags;                     allNodeFlags &= currentNodeFlags;                     someHaveQuestionToken = someHaveQuestionToken || hasQuestionToken(node);                     allHaveQuestionToken = allHaveQuestionToken && hasQuestionToken(node);                     const bodyIsPresent = nodeIsPresent((node as FunctionLikeDeclaration).body);                      if (bodyIsPresent && bodyDeclaration) {                         if (isConstructor) {                             multipleConstructorImplementation = true;                         }                         else {                             duplicateFunctionDeclaration = true;                         }                     }                     else if (previousDeclaration?.parent === node.parent && previousDeclaration.end !== node.pos) {                         reportImplementationExpectedError(previousDeclaration);                     }                      if (bodyIsPresent) {                         if (!bodyDeclaration) {                             bodyDeclaration = node as FunctionLikeDeclaration;                         }                     }                     else {                         hasOverloads = true;                     }                      previousDeclaration = node;                      if (!inAmbientContextOrInterface) {                         lastSeenNonAmbientDeclaration = node as FunctionLikeDeclaration;                     }                 }                 if (isInJSFile(current) && isFunctionLike(current) && current.jsDoc) {                     hasOverloads = length(getJSDocOverloadTags(current)) > 0;                 }             } */
        }
        if multipleConstructorImplementation {
            /* TODO(ExpressionStatement): forEach(functionDeclarations, declaration => {                 error(declaration, Diagnostics.Multiple_constructor_implementations_are_not_allowed);             }); */
        }
        if duplicateFunctionDeclaration {
            /* TODO(ExpressionStatement): forEach(functionDeclarations, declaration => {                 error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Duplicate_function_implementation);             }); */
        }
        if /* TODO(BinaryExpression): hasNonAmbientClass && !isConstructor && symbol.flags & SymbolFlags.Function && declarations */ TODO {
            relatedDiagnostics := /* TODO(PropertyAccessExpression): filter(declarations, d => d.kind === SyntaxKind.ClassDeclaration)                 .map */ TODO(/* TODO(ArrowFunction): d => createDiagnosticForNode(d, Diagnostics.Consider_adding_a_declare_modifier_to_this_class) */ TODO)
            /* TODO(ExpressionStatement): forEach(declarations, declaration => {                 const diagnostic = declaration.kind === SyntaxKind.ClassDeclaration                     ? Diagnostics.Class_declaration_cannot_implement_overload_list_for_0                     : declaration.kind === SyntaxKind.FunctionDeclaration                     ? Diagnostics.Function_with_bodies_can_only_merge_with_classes_that_are_ambient                     : undefined;                 if (diagnostic) {                     addRelatedInfo(                         error(getNameOfDeclaration(declaration) || declaration, diagnostic, symbolName(symbol)),                         ...relatedDiagnostics,                     );                 }             }); */
        }
        if /* TODO(BinaryExpression): lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body &&             !hasSyntacticModifier(lastSeenNonAmbientDeclaration, ModifierFlags.Abstract) && !lastSeenNonAmbientDeclaration.questionToken */ TODO {
            /* TODO(ExpressionStatement): reportImplementationExpectedError(lastSeenNonAmbientDeclaration); */
        }
        if hasOverloads {
            if declarations {
                /* TODO(ExpressionStatement): checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags); */
                /* TODO(ExpressionStatement): checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken); */
            }
            if bodyDeclaration {
                signatures := getSignaturesOfSymbol(symbol)
                bodySignature := getSignatureFromDeclaration(bodyDeclaration)
                /* TODO(ForOfStatement): for (const signature of signatures) {                     if (!isImplementationCompatibleWithOverload(bodySignature, signature)) {                         const errorNode = signature.declaration && isJSDocSignature(signature.declaration)                             ? (signature.declaration.parent as JSDocOverloadTag | JSDocCallbackTag).tagName                             : signature.declaration;                         addRelatedInfo(                             error(errorNode, Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature),                             createDiagnosticForNode(bodyDeclaration, Diagnostics.The_implementation_signature_is_declared_here),                         );                         break;                     }                 } */
            }
        }
    }
    checkExportsOnMergedDeclarations := func(node Declaration) {
        /* TODO(ExpressionStatement): addLazyDiagnostic(() => checkExportsOnMergedDeclarationsWorker(node)); */
    }
    checkExportsOnMergedDeclarationsWorker := func(node Declaration) {
        symbol := /* TODO(PropertyAccessExpression): node.localSymbol */ TODO
        if /* TODO(PrefixUnaryExpression): !symbol */ TODO {
            /* TODO(ExpressionStatement): symbol = getSymbolOfDeclaration(node)!; */
            if /* TODO(PrefixUnaryExpression): !symbol.exportSymbol */ TODO {

            }
        }
        if /* TODO(BinaryExpression): getDeclarationOfKind(symbol, node.kind) !== node */ TODO {

        }
        exportedDeclarationSpaces := /* TODO(PropertyAccessExpression): DeclarationSpaces.None */ TODO
        nonExportedDeclarationSpaces := /* TODO(PropertyAccessExpression): DeclarationSpaces.None */ TODO
        defaultExportedDeclarationSpaces := /* TODO(PropertyAccessExpression): DeclarationSpaces.None */ TODO
        /* TODO(ForOfStatement): for (const d of symbol.declarations!) {             const declarationSpaces = getDeclarationSpaces(d);             const effectiveDeclarationFlags = getEffectiveDeclarationFlags(d, ModifierFlags.Export | ModifierFlags.Default);              if (effectiveDeclarationFlags & ModifierFlags.Export) {                 if (effectiveDeclarationFlags & ModifierFlags.Default) {                     defaultExportedDeclarationSpaces |= declarationSpaces;                 }                 else {                     exportedDeclarationSpaces |= declarationSpaces;                 }             }             else {                 nonExportedDeclarationSpaces |= declarationSpaces;             }         } */
        nonDefaultExportedDeclarationSpaces := /* TODO(BinaryExpression): exportedDeclarationSpaces | nonExportedDeclarationSpaces */ TODO
        commonDeclarationSpacesForExportsAndLocals := /* TODO(BinaryExpression): exportedDeclarationSpaces & nonExportedDeclarationSpaces */ TODO
        commonDeclarationSpacesForDefaultAndNonDefault := /* TODO(BinaryExpression): defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces */ TODO
        if /* TODO(BinaryExpression): commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault */ TODO {
            /* TODO(ForOfStatement): for (const d of symbol.declarations!) {                 const declarationSpaces = getDeclarationSpaces(d);                  const name = getNameOfDeclaration(d);                 // Only error on the declarations that contributed to the intersecting spaces.                 if (declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault) {                     error(name, Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, declarationNameToString(name));                 }                 else if (declarationSpaces & commonDeclarationSpacesForExportsAndLocals) {                     error(name, Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, declarationNameToString(name));                 }             } */
        }
        getDeclarationSpaces := func(decl Declaration) DeclarationSpaces {
            d := decl /* as */ /* TODO(TypeReference): Node */
            /* TODO(SwitchStatement): switch (d.kind) {                 case SyntaxKind.InterfaceDeclaration:                 case SyntaxKind.TypeAliasDeclaration:                  // A jsdoc typedef and callback are, by definition, type aliases.                 // falls through                 case SyntaxKind.JSDocTypedefTag:                 case SyntaxKind.JSDocCallbackTag:                 case SyntaxKind.JSDocEnumTag:                     return DeclarationSpaces.ExportType;                 case SyntaxKind.ModuleDeclaration:                     return isAmbientModule(d as ModuleDeclaration) || getModuleInstanceState(d as ModuleDeclaration) !== ModuleInstanceState.NonInstantiated                         ? DeclarationSpaces.ExportNamespace | DeclarationSpaces.ExportValue                         : DeclarationSpaces.ExportNamespace;                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.EnumDeclaration:                 case SyntaxKind.EnumMember:                     return DeclarationSpaces.ExportType | DeclarationSpaces.ExportValue;                 case SyntaxKind.SourceFile:                     return DeclarationSpaces.ExportType | DeclarationSpaces.ExportValue | DeclarationSpaces.ExportNamespace;                 case SyntaxKind.ExportAssignment:                 case SyntaxKind.BinaryExpression:                     const node = d as ExportAssignment | BinaryExpression;                     const expression = isExportAssignment(node) ? node.expression : node.right;                     // Export assigned entity name expressions act as aliases and should fall through, otherwise they export values                     if (!isEntityNameExpression(expression)) {                         return DeclarationSpaces.ExportValue;                     }                     d = expression;                  // The below options all declare an Alias, which is allowed to merge with other values within the importing module.                 // falls through                 case SyntaxKind.ImportEqualsDeclaration:                 case SyntaxKind.NamespaceImport:                 case SyntaxKind.ImportClause:                     let result = DeclarationSpaces.None;                     const target = resolveAlias(getSymbolOfDeclaration(d as ImportEqualsDeclaration | NamespaceImport | ImportClause | ExportAssignment | BinaryExpression));                     forEach(target.declarations, d => {                         result |= getDeclarationSpaces(d);                     });                     return result;                 case SyntaxKind.VariableDeclaration:                 case SyntaxKind.BindingElement:                 case SyntaxKind.FunctionDeclaration:                 case SyntaxKind.ImportSpecifier: // https://github.com/Microsoft/TypeScript/pull/7591                 case SyntaxKind.Identifier: // https://github.com/microsoft/TypeScript/issues/36098                     // Identifiers are used as declarations of assignment declarations whose parents may be                     // SyntaxKind.CallExpression - `Object.defineProperty(thing, "aField", {value: 42});`                     // SyntaxKind.ElementAccessExpression - `thing["aField"] = 42;` or `thing["aField"];` (with a doc comment on it)                     // or SyntaxKind.PropertyAccessExpression - `thing.aField = 42;`                     // all of which are pretty much always values, or at least imply a value meaning.                     // It may be apprpriate to treat these as aliases in the future.                     return DeclarationSpaces.ExportValue;                 case SyntaxKind.MethodSignature:                 case SyntaxKind.PropertySignature:                     return DeclarationSpaces.ExportType;                 default:                     return Debug.failBadSyntaxKind(d);             } */
        }
    }
    getAwaitedTypeOfPromise := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
        promisedType := getPromisedTypeOfPromise(type_, errorNode)
         /* TODO(BinaryExpression): promisedType && getAwaitedType(promisedType, errorNode, diagnosticMessage, ...args) */ TODO
    }
    getPromisedTypeOfPromise := func(type_ Type, errorNode Node, thisTypeForErrorOut /* TODO(TypeLiteral): { value?: Type; } */ TODO) *Type {
        if isTypeAny(type_) {
             undefined
        }
        typeAsPromise := type_ /* as */ /* TODO(TypeReference): PromiseOrAwaitableType */
        if /* TODO(PropertyAccessExpression): typeAsPromise.promisedTypeOfPromise */ TODO {
             /* TODO(PropertyAccessExpression): typeAsPromise.promisedTypeOfPromise */ TODO
        }
        if isReferenceToType(type_, getGlobalPromiseType(/* TODO(FalseKeyword): false */ TODO)) {
             /* TODO(BinaryExpression): typeAsPromise.promisedTypeOfPromise = getTypeArguments(type as GenericType)[0] */ TODO
        }
        if allTypesAssignableToKind(getBaseConstraintOrType(type_), /* TODO(BinaryExpression): TypeFlags.Primitive | TypeFlags.Never */ TODO) {
             undefined
        }
        thenFunction := /* TODO(NonNullExpression): getTypeOfPropertyOfType(type, "then" as __String)! */ TODO
        if isTypeAny(thenFunction) {
             undefined
        }
        thenSignatures := /* TODO(ConditionalExpression): thenFunction ? getSignaturesOfType(thenFunction, SignatureKind.Call) : emptyArray */ TODO
        if /* TODO(BinaryExpression): thenSignatures.length === 0 */ TODO {
            if errorNode {
                /* TODO(ExpressionStatement): error(errorNode, Diagnostics.A_promise_must_have_a_then_method); */
            }
             undefined
        }
        var thisTypeForError *Type
        var candidates /* TODO(ArrayType): Signature[] */ any
        /* TODO(ForOfStatement): for (const thenSignature of thenSignatures) {             const thisType = getThisTypeOfSignature(thenSignature);             if (thisType && thisType !== voidType && !isTypeRelatedTo(type, thisType, subtypeRelation)) {                 thisTypeForError = thisType;             }             else {                 candidates = append(candidates, thenSignature);             }         } */
        if /* TODO(PrefixUnaryExpression): !candidates */ TODO {
            /* TODO(ExpressionStatement): Debug.assertIsDefined(thisTypeForError); */
            if thisTypeForErrorOut {
                /* TODO(ExpressionStatement): thisTypeForErrorOut.value = thisTypeForError; */
            }
            if errorNode {
                /* TODO(ExpressionStatement): error(errorNode, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type), typeToString(thisTypeForError)); */
            }
             undefined
        }
        onfulfilledParameterType := getTypeWithFacts(getUnionType(map_(candidates, getTypeOfFirstParameterOfSignature)), /* TODO(PropertyAccessExpression): TypeFacts.NEUndefinedOrNull */ TODO)
        if isTypeAny(onfulfilledParameterType) {
             undefined
        }
        onfulfilledParameterSignatures := getSignaturesOfType(onfulfilledParameterType, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
        if /* TODO(BinaryExpression): onfulfilledParameterSignatures.length === 0 */ TODO {
            if errorNode {
                /* TODO(ExpressionStatement): error(errorNode, Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback); */
            }
             undefined
        }
         /* TODO(BinaryExpression): typeAsPromise.promisedTypeOfPromise = getUnionType(map(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature), UnionReduction.Subtype) */ TODO
    }
    checkAwaitedType := func(type_ Type, withAlias bool, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) Type {
        awaitedType := /* TODO(ConditionalExpression): withAlias ?             getAwaitedType(type, errorNode, diagnosticMessage, ...args) :             getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, ...args) */ TODO
         /* TODO(BinaryExpression): awaitedType || errorType */ TODO
    }
    isThenableType := func(type_ Type) bool {
        if allTypesAssignableToKind(getBaseConstraintOrType(type_), /* TODO(BinaryExpression): TypeFlags.Primitive | TypeFlags.Never */ TODO) {
             /* TODO(FalseKeyword): false */ TODO
        }
        thenFunction := getTypeOfPropertyOfType(type_, "then" /* as */ /* TODO(TypeReference): __String */)
         /* TODO(BinaryExpression): !!thenFunction && getSignaturesOfType(getTypeWithFacts(thenFunction, TypeFacts.NEUndefinedOrNull), SignatureKind.Call).length > 0 */ TODO
    }
    type AwaitedTypeInstantiation struct {
        _awaitedTypeBrand /* TODO(NeverKeyword): never */ TODO
        aliasSymbol Symbol
        aliasTypeArguments []Type
    }
    isAwaitedTypeInstantiation := func(type_ Type) /* TODO(TypePredicate): type is AwaitedTypeInstantiation */ TODO {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Conditional */ TODO {
            awaitedSymbol := getGlobalAwaitedSymbol(/* TODO(FalseKeyword): false */ TODO)
             /* TODO(BinaryExpression): !!awaitedSymbol && type.aliasSymbol === awaitedSymbol && type.aliasTypeArguments?.length === 1 */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    unwrapAwaitedType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? mapType(type, unwrapAwaitedType) :             isAwaitedTypeInstantiation(type) ? type.aliasTypeArguments[0] :             type */ TODO
    }
    isAwaitedTypeNeeded := func(type_ Type) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): isTypeAny(type) || isAwaitedTypeInstantiation(type) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if isGenericObjectType(type_) {
            baseConstraint := getBaseConstraintOfType(type_)
            if /* TODO(ConditionalExpression): baseConstraint ?                     baseConstraint.flags & TypeFlags.AnyOrUnknown || isEmptyObjectType(baseConstraint) || someType(baseConstraint, isThenableType) :                     maybeTypeOfKind(type, TypeFlags.TypeVariable) */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    tryCreateAwaitedType := func(type_ Type) *Type {
        awaitedSymbol := getGlobalAwaitedSymbol(/* TODO(TrueKeyword): true */ TODO)
        if awaitedSymbol {
             getTypeAliasInstantiation(awaitedSymbol, /* TODO(ArrayLiteralExpression): [unwrapAwaitedType(type)] */ TODO)
        }
         undefined
    }
    createAwaitedTypeIfNeeded := func(type_ Type) Type {
        if isAwaitedTypeNeeded(type_) {
             /* TODO(BinaryExpression): tryCreateAwaitedType(type) ?? type */ TODO
        }
        /* TODO(ExpressionStatement): Debug.assert(isAwaitedTypeInstantiation(type) || getPromisedTypeOfPromise(type) === undefined, "type provided should not be a non-generic 'promise'-like."); */
         type_
    }
    getAwaitedType := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
        awaitedType := getAwaitedTypeNoAlias(type_, errorNode, diagnosticMessage, /* TODO(SpreadElement): ...args */ TODO)
         /* TODO(BinaryExpression): awaitedType && createAwaitedTypeIfNeeded(awaitedType) */ TODO
    }
    getAwaitedTypeNoAlias := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
        if isTypeAny(type_) {
             type_
        }
        if isAwaitedTypeInstantiation(type_) {
             type_
        }
        typeAsAwaitable := type_ /* as */ /* TODO(TypeReference): PromiseOrAwaitableType */
        if /* TODO(PropertyAccessExpression): typeAsAwaitable.awaitedTypeOfType */ TODO {
             /* TODO(PropertyAccessExpression): typeAsAwaitable.awaitedTypeOfType */ TODO
        }
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
            if /* TODO(BinaryExpression): awaitedTypeStack.lastIndexOf(type.id) >= 0 */ TODO {
                if errorNode {
                    /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method); */
                }
                 undefined
            }
            mapper := /* TODO(ConditionalExpression): errorNode ? (constituentType: Type) => getAwaitedTypeNoAlias(constituentType, errorNode, diagnosticMessage, ...args) : getAwaitedTypeNoAlias */ TODO
            /* TODO(ExpressionStatement): awaitedTypeStack.push(type.id); */
            mapped := mapType(type_, mapper)
            /* TODO(ExpressionStatement): awaitedTypeStack.pop(); */
             /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = mapped */ TODO
        }
        if isAwaitedTypeNeeded(type_) {
             /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = type */ TODO
        }
        var thisTypeForErrorOut /* TODO(TypeLiteral): { value: Type | undefined; } */ TODO = /* TODO(ObjectLiteralExpression): { value: undefined } */ TODO
        promisedType := getPromisedTypeOfPromise(type_, undefined, thisTypeForErrorOut)
        if promisedType {
            if /* TODO(BinaryExpression): type.id === promisedType.id || awaitedTypeStack.lastIndexOf(promisedType.id) >= 0 */ TODO {
                if errorNode {
                    /* TODO(ExpressionStatement): error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method); */
                }
                 undefined
            }
            /* TODO(ExpressionStatement): awaitedTypeStack.push(type.id); */
            awaitedType := getAwaitedTypeNoAlias(promisedType, errorNode, diagnosticMessage, /* TODO(SpreadElement): ...args */ TODO)
            /* TODO(ExpressionStatement): awaitedTypeStack.pop(); */
            if /* TODO(PrefixUnaryExpression): !awaitedType */ TODO {
                 undefined
            }
             /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = awaitedType */ TODO
        }
        if isThenableType(type_) {
            if errorNode {
                /* TODO(ExpressionStatement): Debug.assertIsDefined(diagnosticMessage); */
                var chain *DiagnosticMessageChain
                if /* TODO(PropertyAccessExpression): thisTypeForErrorOut.value */ TODO {
                    /* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type), typeToString(thisTypeForErrorOut.value)); */
                }
                /* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, diagnosticMessage, ...args); */
                /* TODO(ExpressionStatement): diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chain)); */
            }
             undefined
        }
         /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = type */ TODO
    }
    checkAsyncFunctionReturnType := func(node /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode) {
        returnType := getTypeFromTypeNode(returnTypeNode)
        if /* TODO(BinaryExpression): languageVersion >= ScriptTarget.ES2015 */ TODO {
            if isErrorType(returnType) {

            }
            globalPromiseType := getGlobalPromiseType(/* TODO(TrueKeyword): true */ TODO)
            if /* TODO(BinaryExpression): globalPromiseType !== emptyGenericType && !isReferenceToType(returnType, globalPromiseType) */ TODO {
                /* TODO(ExpressionStatement): reportErrorForInvalidReturnType(Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0, returnTypeNode, returnTypeErrorLocation, typeToString(getAwaitedTypeNoAlias(returnType) || voidType)); */

            }
        } else {
            /* TODO(ExpressionStatement): markLinkedReferences(node, ReferenceHint.AsyncFunction); */
            if isErrorType(returnType) {

            }
            promiseConstructorName := getEntityNameFromTypeNode(returnTypeNode)
            if /* TODO(BinaryExpression): promiseConstructorName === undefined */ TODO {
                /* TODO(ExpressionStatement): reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, typeToString(returnType)); */

            }
            promiseConstructorSymbol := resolveEntityName(promiseConstructorName, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO, /* TODO(TrueKeyword): true */ TODO)
            promiseConstructorType := /* TODO(ConditionalExpression): promiseConstructorSymbol ? getTypeOfSymbol(promiseConstructorSymbol) : errorType */ TODO
            if isErrorType(promiseConstructorType) {
                if /* TODO(BinaryExpression): promiseConstructorName.kind === SyntaxKind.Identifier && promiseConstructorName.escapedText === "Promise" && getTargetType(returnType) === getGlobalPromiseType(/*reportErrors* / false) */ TODO {
                    /* TODO(ExpressionStatement): error(returnTypeErrorLocation, Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option); */
                } else {
                    /* TODO(ExpressionStatement): reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName)); */
                }

            }
            globalPromiseConstructorLikeType := getGlobalPromiseConstructorLikeType(/* TODO(TrueKeyword): true */ TODO)
            if /* TODO(BinaryExpression): globalPromiseConstructorLikeType === emptyObjectType */ TODO {
                /* TODO(ExpressionStatement): reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName)); */

            }
            headMessage := /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value */ TODO
            errorInfo := /* TODO(ArrowFunction): () => returnTypeNode === returnTypeErrorLocation ? undefined : chainDiagnosticMessages(/*details* / undefined, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type) */ TODO
            if /* TODO(PrefixUnaryExpression): !checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, returnTypeErrorLocation, headMessage, errorInfo) */ TODO {

            }
            rootName := /* TODO(BinaryExpression): promiseConstructorName && getFirstIdentifier(promiseConstructorName) */ TODO
            collidingSymbol := getSymbol(/* TODO(NonNullExpression): node.locals! */ TODO, /* TODO(PropertyAccessExpression): rootName.escapedText */ TODO, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO)
            if collidingSymbol {
                /* TODO(ExpressionStatement): error(collidingSymbol.valueDeclaration, Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions, idText(rootName), entityNameToString(promiseConstructorName)); */

            }
        }
        /* TODO(ExpressionStatement): checkAwaitedType(returnType, /*withAlias* / false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member); */
        reportErrorForInvalidReturnType := func(message DiagnosticMessage, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode, typeName string) {
            if /* TODO(BinaryExpression): returnTypeNode === returnTypeErrorLocation */ TODO {
                /* TODO(ExpressionStatement): error(returnTypeErrorLocation, message, typeName); */
            } else {
                diag := error(returnTypeErrorLocation, /* TODO(PropertyAccessExpression): Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type */ TODO)
                /* TODO(ExpressionStatement): addRelatedInfo(diag, createDiagnosticForNode(returnTypeNode, message, typeName)); */
            }
        }
    }
    checkGrammarDecorator := func(decorator Decorator) bool {
        sourceFile := getSourceFileOfNode(decorator)
        if /* TODO(PrefixUnaryExpression): !hasParseDiagnostics(sourceFile) */ TODO {
            var node Expression = /* TODO(PropertyAccessExpression): decorator.expression */ TODO
            if isParenthesizedExpression(node) {
                 /* TODO(FalseKeyword): false */ TODO
            }
            canHaveCallExpression := /* TODO(TrueKeyword): true */ TODO
            var errorNode Node
            /* TODO(WhileStatement): while (true) {                 // Allow TS syntax such as non-null assertions and instantiation expressions                 if (isExpressionWithTypeArguments(node) || isNonNullExpression(node)) {                     node = node.expression;                     continue;                 }                  // DecoratorCallExpression :                 //   DecoratorMemberExpression Arguments                  if (isCallExpression(node)) {                     if (!canHaveCallExpression) {                         errorNode = node;                     }                     if (node.questionDotToken) {                         // Even if we already have an error node, error at the `?.` token since it appears earlier.                         errorNode = node.questionDotToken;                     }                     node = node.expression;                     canHaveCallExpression = false;                     continue;                 }                  // DecoratorMemberExpression :                 //   IdentifierReference                 //   DecoratorMemberExpression `.` IdentifierName                 //   DecoratorMemberExpression `.` PrivateIdentifier                  if (isPropertyAccessExpression(node)) {                     if (node.questionDotToken) {                         // Even if we already have an error node, error at the `?.` token since it appears earlier.                         errorNode = node.questionDotToken;                     }                     node = node.expression;                     canHaveCallExpression = false;                     continue;                 }                  if (!isIdentifier(node)) {                     // Even if we already have an error node, error at this node since it appears earlier.                     errorNode = node;                 }                  break;             } */
            if errorNode {
                /* TODO(ExpressionStatement): addRelatedInfo(                     error(decorator.expression, Diagnostics.Expression_must_be_enclosed_in_parentheses_to_be_used_as_a_decorator),                     createDiagnosticForNode(errorNode, Diagnostics.Invalid_syntax_in_decorator),                 ); */
                 /* TODO(TrueKeyword): true */ TODO
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkDecorator := func(node Decorator) {
        /* TODO(ExpressionStatement): checkGrammarDecorator(node); */
        signature := getResolvedSignature(node)
        /* TODO(ExpressionStatement): checkDeprecatedSignature(signature, node); */
        returnType := getReturnTypeOfSignature(signature)
        if /* TODO(BinaryExpression): returnType.flags & TypeFlags.Any */ TODO {

        }
        decoratorSignature := getDecoratorCallSignature(node)
        if /* TODO(PrefixUnaryExpression): !decoratorSignature?.resolvedReturnType */ TODO {
        }
        var headMessage DiagnosticMessage
        expectedReturnType := /* TODO(PropertyAccessExpression): decoratorSignature.resolvedReturnType */ TODO
        /* TODO(SwitchStatement): switch (node.parent.kind) {             case SyntaxKind.ClassDeclaration:             case SyntaxKind.ClassExpression:                 headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;                 break;              case SyntaxKind.PropertyDeclaration:                 if (!legacyDecorators) {                     headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;                     break;                 }                 // falls through              case SyntaxKind.Parameter:                 headMessage = Diagnostics.Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any;                 break;              case SyntaxKind.MethodDeclaration:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;                 break;              default:                 return Debug.failBadSyntaxKind(node.parent);         } */
        /* TODO(ExpressionStatement): checkTypeAssignableTo(returnType, expectedReturnType, node.expression, headMessage); */
    }
    createCallSignature := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, thisParameter *Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number /* = */ /* TODO(PropertyAccessExpression): parameters.length */, flags SignatureFlags /* = */ /* TODO(PropertyAccessExpression): SignatureFlags.None */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
        decl := /* TODO(PropertyAccessExpression): factory.createFunctionTypeNode */ TODO(undefined, emptyArray, /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO))
         createSignature(decl, typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
    }
    createFunctionType := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, thisParameter *Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number, flags SignatureFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
        signature := createCallSignature(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
         getOrCreateTypeFromSignature(signature)
    }
    createGetterFunctionType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
         createFunctionType(undefined, undefined, emptyArray, type_)
    }
    createSetterFunctionType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
        valueParam := createParameter("value" /* as */ /* TODO(TypeReference): __String */, type_)
         createFunctionType(undefined, undefined, /* TODO(ArrayLiteralExpression): [valueParam] */ TODO, voidType)
    }
    getEntityNameForDecoratorMetadata := func(node *TypeNode) *EntityName {
        if node {
            /* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.IntersectionType:                 case SyntaxKind.UnionType:                     return getEntityNameForDecoratorMetadataFromTypeList((node as UnionOrIntersectionTypeNode).types);                  case SyntaxKind.ConditionalType:                     return getEntityNameForDecoratorMetadataFromTypeList([(node as ConditionalTypeNode).trueType, (node as ConditionalTypeNode).falseType]);                  case SyntaxKind.ParenthesizedType:                 case SyntaxKind.NamedTupleMember:                     return getEntityNameForDecoratorMetadata((node as ParenthesizedTypeNode).type);                  case SyntaxKind.TypeReference:                     return (node as TypeReferenceNode).typeName;             } */
        }
    }
    getEntityNameForDecoratorMetadataFromTypeList := func(types []TypeNode) *EntityName {
        var commonEntityName *EntityName
        /* TODO(ForOfStatement): for (let typeNode of types) {             while (typeNode.kind === SyntaxKind.ParenthesizedType || typeNode.kind === SyntaxKind.NamedTupleMember) {                 typeNode = (typeNode as ParenthesizedTypeNode | NamedTupleMember).type; // Skip parens if need be             }             if (typeNode.kind === SyntaxKind.NeverKeyword) {                 continue; // Always elide `never` from the union/intersection if possible             }             if (!strictNullChecks && (typeNode.kind === SyntaxKind.LiteralType && (typeNode as LiteralTypeNode).literal.kind === SyntaxKind.NullKeyword || typeNode.kind === SyntaxKind.UndefinedKeyword)) {                 continue; // Elide null and undefined from unions for metadata, just like what we did prior to the implementation of strict null checks             }             const individualEntityName = getEntityNameForDecoratorMetadata(typeNode);             if (!individualEntityName) {                 // Individual is something like string number                 // So it would be serialized to either that type or object                 // Safe to return here                 return undefined;             }              if (commonEntityName) {                 // Note this is in sync with the transformation that happens for type node.                 // Keep this in sync with serializeUnionOrIntersectionType                 // Verify if they refer to same entity and is identifier                 // return undefined if they dont match because we would emit object                 if (                     !isIdentifier(commonEntityName) ||                     !isIdentifier(individualEntityName) ||                     commonEntityName.escapedText !== individualEntityName.escapedText                 ) {                     return undefined;                 }             }             else {                 commonEntityName = individualEntityName;             }         } */
         commonEntityName
    }
    getParameterTypeNodeForDecoratorCheck := func(node ParameterDeclaration) *TypeNode {
        typeNode := getEffectiveTypeAnnotationNode(node)
         /* TODO(ConditionalExpression): isRestParameter(node) ? getRestParameterElementType(typeNode) : typeNode */ TODO
    }
    checkDecorators := func(node Node) {
        if /* TODO(BinaryExpression): !canHaveDecorators(node) || !hasDecorators(node) || !node.modifiers || !nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent) */ TODO {

        }
        firstDecorator := find(/* TODO(PropertyAccessExpression): node.modifiers */ TODO, isDecorator)
        if /* TODO(PrefixUnaryExpression): !firstDecorator */ TODO {

        }
        if legacyDecorators {
            /* TODO(ExpressionStatement): checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.Decorate); */
            if /* TODO(BinaryExpression): node.kind === SyntaxKind.Parameter */ TODO {
                /* TODO(ExpressionStatement): checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.Param); */
            }
        } else if /* TODO(BinaryExpression): languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators */ TODO {
            /* TODO(ExpressionStatement): checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.ESDecorateAndRunInitializers); */
            if isClassDeclaration(node) {
                if /* TODO(PrefixUnaryExpression): !node.name */ TODO {
                    /* TODO(ExpressionStatement): checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.SetFunctionName); */
                } else {
                    member := getFirstTransformableStaticClassElement(node)
                    if member {
                        /* TODO(ExpressionStatement): checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.SetFunctionName); */
                    }
                }
            } else if /* TODO(PrefixUnaryExpression): !isClassExpression(node) */ TODO {
                if /* TODO(BinaryExpression): isPrivateIdentifier(node.name) && (isMethodDeclaration(node) || isAccessor(node) || isAutoAccessorPropertyDeclaration(node)) */ TODO {
                    /* TODO(ExpressionStatement): checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.SetFunctionName); */
                }
                if isComputedPropertyName(/* TODO(PropertyAccessExpression): node.name */ TODO) {
                    /* TODO(ExpressionStatement): checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.PropKey); */
                }
            }
        }
        /* TODO(ExpressionStatement): markLinkedReferences(node, ReferenceHint.Decorator); */
        /* TODO(ForOfStatement): for (const modifier of node.modifiers) {             if (isDecorator(modifier)) {                 checkDecorator(modifier);             }         } */
    }
    checkFunctionDeclaration := func(node FunctionDeclaration) {
        /* TODO(ExpressionStatement): addLazyDiagnostic(checkFunctionDeclarationDiagnostics); */
        checkFunctionDeclarationDiagnostics := func() {
            /* TODO(ExpressionStatement): checkFunctionOrMethodDeclaration(node); */
            /* TODO(ExpressionStatement): checkGrammarForGenerator(node); */
            /* TODO(ExpressionStatement): checkCollisionsForDeclarationName(node, node.name); */
        }
    }
    checkJSDocTypeAliasTag := func(node /* TODO(UnionType): JSDocTypedefTag | JSDocCallbackTag */ any) {
        if /* TODO(PrefixUnaryExpression): !node.typeExpression */ TODO {
            /* TODO(ExpressionStatement): error(node.name, Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags); */
        }
        if /* TODO(PropertyAccessExpression): node.name */ TODO {
            /* TODO(ExpressionStatement): checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0); */
        }
        /* TODO(ExpressionStatement): checkSourceElement(node.typeExpression); */
        /* TODO(ExpressionStatement): checkTypeParameters(getEffectiveTypeParameterDeclarations(node)); */
    }
    checkJSDocTemplateTag := func(node JSDocTemplateTag) {
        /* TODO(ExpressionStatement): checkSourceElement(node.constraint); */
        /* TODO(ForOfStatement): for (const tp of node.typeParameters) {             checkSourceElement(tp);         } */
    }
    checkJSDocTypeTag := func(node JSDocTypeTag) {
        /* TODO(ExpressionStatement): checkSourceElement(node.typeExpression); */
    }
    checkJSDocSatisfiesTag := func(node JSDocSatisfiesTag) {
        /* TODO(ExpressionStatement): checkSourceElement(node.typeExpression); */
        host := getEffectiveJSDocHost(node)
        if host {
            tags := getAllJSDocTags(host, isJSDocSatisfiesTag)
            if /* TODO(BinaryExpression): length(tags) > 1 */ TODO {
                /* TODO(ForStatement): for (let i = 1; i < length(tags); i++) {                     const tagName = tags[i].tagName;                     error(tagName, Diagnostics._0_tag_already_specified, idText(tagName));                 } */
            }
        }
    }
    checkJSDocLinkLikeTag := func(node /* TODO(UnionType): JSDocLink | JSDocLinkCode | JSDocLinkPlain */ any) {
        if /* TODO(PropertyAccessExpression): node.name */ TODO {
            /* TODO(ExpressionStatement): resolveJSDocMemberName(node.name, /*ignoreErrors* / true); */
        }
    }
    checkJSDocParameterTag := func(node JSDocParameterTag) {
        /* TODO(ExpressionStatement): checkSourceElement(node.typeExpression); */
    }
    checkJSDocPropertyTag := func(node JSDocPropertyTag) {
        /* TODO(ExpressionStatement): checkSourceElement(node.typeExpression); */
    }
    checkJSDocFunctionType := func(node JSDocFunctionType) {
        /* TODO(ExpressionStatement): addLazyDiagnostic(checkJSDocFunctionTypeImplicitAny); */
        /* TODO(ExpressionStatement): checkSignatureDeclaration(node); */
        checkJSDocFunctionTypeImplicitAny := func() {
            if /* TODO(BinaryExpression): !node.type && !isJSDocConstructSignature(node) */ TODO {
                /* TODO(ExpressionStatement): reportImplicitAny(node, anyType); */
            }
        }
    }
    checkJSDocThisTag := func(node JSDocThisTag) {
        host := getEffectiveJSDocHost(node)
        if /* TODO(BinaryExpression): host && isArrowFunction(host) */ TODO {
            /* TODO(ExpressionStatement): error(node.tagName, Diagnostics.An_arrow_function_cannot_have_a_this_parameter); */
        }
    }
    checkJSDocImportTag := func(node JSDocImportTag) {
        /* TODO(ExpressionStatement): checkImportAttributes(node); */
    }
    checkJSDocImplementsTag := func(node JSDocImplementsTag) {
        classLike := getEffectiveJSDocHost(node)
        if /* TODO(BinaryExpression): !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) */ TODO {
            /* TODO(ExpressionStatement): error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName)); */
        }
    }
    checkJSDocAugmentsTag := func(node JSDocAugmentsTag) {
        classLike := getEffectiveJSDocHost(node)
        if /* TODO(BinaryExpression): !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) */ TODO {
            /* TODO(ExpressionStatement): error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName)); */

        }
        augmentsTags := /* TODO(PropertyAccessExpression): getJSDocTags(classLike).filter */ TODO(isJSDocAugmentsTag)
        /* TODO(ExpressionStatement): Debug.assert(augmentsTags.length > 0); */
        if /* TODO(BinaryExpression): augmentsTags.length > 1 */ TODO {
            /* TODO(ExpressionStatement): error(augmentsTags[1], Diagnostics.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag); */
        }
        name := getIdentifierFromEntityNameExpression(/* TODO(PropertyAccessExpression): node.class.expression */ TODO)
        extend := getClassExtendsHeritageElement(classLike)
        if extend {
            className := getIdentifierFromEntityNameExpression(/* TODO(PropertyAccessExpression): extend.expression */ TODO)
            if /* TODO(BinaryExpression): className && name.escapedText !== className.escapedText */ TODO {
                /* TODO(ExpressionStatement): error(name, Diagnostics.JSDoc_0_1_does_not_match_the_extends_2_clause, idText(node.tagName), idText(name), idText(className)); */
            }
        }
    }
    checkJSDocAccessibilityModifiers := func(node /* TODO(UnionType): JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag */ any) {
        host := getJSDocHost(node)
        if /* TODO(BinaryExpression): host && isPrivateIdentifierClassElementDeclaration(host) */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier); */
        }
    }
    // OVERLOAD: getIdentifierFromEntityNameExpression := func(node /* TODO(UnionType): Identifier | PropertyAccessExpression */ any) /* TODO(UnionType): Identifier | PrivateIdentifier */ any
    // OVERLOAD: getIdentifierFromEntityNameExpression := func(node Expression) /* TODO(UnionType): Identifier | PrivateIdentifier | undefined */ any
    getIdentifierFromEntityNameExpression := func(node Expression) /* TODO(UnionType): Identifier | PrivateIdentifier | undefined */ any {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:                 return node as Identifier;             case SyntaxKind.PropertyAccessExpression:                 return (node as PropertyAccessExpression).name;             default:                 return undefined;         } */
    }
    checkFunctionOrMethodDeclaration := func(node /* TODO(UnionType): FunctionDeclaration | MethodDeclaration | MethodSignature */ any) {
        /* TODO(ExpressionStatement): checkDecorators(node); */
        /* TODO(ExpressionStatement): checkSignatureDeclaration(node); */
        functionFlags := getFunctionFlags(node)
        if /* TODO(BinaryExpression): node.name && node.name.kind === SyntaxKind.ComputedPropertyName */ TODO {
            /* TODO(ExpressionStatement): checkComputedPropertyName(node.name); */
        }
        if hasBindableName(node) {
            symbol := getSymbolOfDeclaration(node)
            localSymbol := /* TODO(BinaryExpression): node.localSymbol || symbol */ TODO
            firstDeclaration := /* TODO(PropertyAccessExpression): localSymbol.declarations?.find */ TODO(/* TODO(ArrowFunction): declaration => declaration.kind === node.kind && !(declaration.flags & NodeFlags.JavaScriptFile) */ TODO)
            if /* TODO(BinaryExpression): node === firstDeclaration */ TODO {
                /* TODO(ExpressionStatement): checkFunctionOrConstructorSymbol(localSymbol); */
            }
            if /* TODO(PropertyAccessExpression): symbol.parent */ TODO {
                /* TODO(ExpressionStatement): checkFunctionOrConstructorSymbol(symbol); */
            }
        }
        body := /* TODO(ConditionalExpression): node.kind === SyntaxKind.MethodSignature ? undefined : node.body */ TODO
        /* TODO(ExpressionStatement): checkSourceElement(body); */
        /* TODO(ExpressionStatement): checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, getReturnTypeFromAnnotation(node)); */
        /* TODO(ExpressionStatement): addLazyDiagnostic(checkFunctionOrMethodDeclarationDiagnostics); */
        if isInJSFile(node) {
            typeTag := getJSDocTypeTag(node)
            if /* TODO(BinaryExpression): typeTag && typeTag.typeExpression && !getContextualCallSignature(getTypeFromTypeNode(typeTag.typeExpression), node) */ TODO {
                /* TODO(ExpressionStatement): error(typeTag.typeExpression.type, Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature); */
            }
        }
        checkFunctionOrMethodDeclarationDiagnostics := func() {
            if /* TODO(PrefixUnaryExpression): !getEffectiveReturnTypeNode(node) */ TODO {
                if /* TODO(BinaryExpression): nodeIsMissing(body) && !isPrivateWithinAmbient(node) */ TODO {
                    /* TODO(ExpressionStatement): reportImplicitAny(node, anyType); */
                }
                if /* TODO(BinaryExpression): functionFlags & FunctionFlags.Generator && nodeIsPresent(body) */ TODO {
                    /* TODO(ExpressionStatement): getReturnTypeOfSignature(getSignatureFromDeclaration(node)); */
                }
            }
        }
    }
    registerForUnusedIdentifiersCheck := func(node PotentiallyUnusedIdentifier) {
        /* TODO(ExpressionStatement): addLazyDiagnostic(registerForUnusedIdentifiersCheckDiagnostics); */
        registerForUnusedIdentifiersCheckDiagnostics := func() {
            sourceFile := getSourceFileOfNode(node)
            potentiallyUnusedIdentifiers := /* TODO(PropertyAccessExpression): allPotentiallyUnusedIdentifiers.get */ TODO(/* TODO(PropertyAccessExpression): sourceFile.path */ TODO)
            if /* TODO(PrefixUnaryExpression): !potentiallyUnusedIdentifiers */ TODO {
                /* TODO(ExpressionStatement): potentiallyUnusedIdentifiers = []; */
                /* TODO(ExpressionStatement): allPotentiallyUnusedIdentifiers.set(sourceFile.path, potentiallyUnusedIdentifiers); */
            }
            /* TODO(ExpressionStatement): potentiallyUnusedIdentifiers.push(node); */
        }
    }
    type PotentiallyUnusedIdentifier /* TODO(UnionType): SourceFile | ModuleDeclaration | ClassLikeDeclaration | InterfaceDeclaration | Block | CaseBlock | ForStatement | ForInStatement | ForOfStatement | Exclude<SignatureDeclaration, IndexSignatureDeclaration | JSDocFunctionType> | TypeAliasDeclaration | InferTypeNode */ any
    checkUnusedIdentifiers := func(potentiallyUnusedIdentifiers []PotentiallyUnusedIdentifier, addDiagnostic AddUnusedDiagnostic) {
        /* TODO(ForOfStatement): for (const node of potentiallyUnusedIdentifiers) {             switch (node.kind) {                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression:                     checkUnusedClassMembers(node, addDiagnostic);                     checkUnusedTypeParameters(node, addDiagnostic);                     break;                 case SyntaxKind.SourceFile:                 case SyntaxKind.ModuleDeclaration:                 case SyntaxKind.Block:                 case SyntaxKind.CaseBlock:                 case SyntaxKind.ForStatement:                 case SyntaxKind.ForInStatement:                 case SyntaxKind.ForOfStatement:                     checkUnusedLocalsAndParameters(node, addDiagnostic);                     break;                 case SyntaxKind.Constructor:                 case SyntaxKind.FunctionExpression:                 case SyntaxKind.FunctionDeclaration:                 case SyntaxKind.ArrowFunction:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                     // Only report unused parameters on the implementation, not overloads.                     if (node.body) {                         checkUnusedLocalsAndParameters(node, addDiagnostic);                     }                     checkUnusedTypeParameters(node, addDiagnostic);                     break;                 case SyntaxKind.MethodSignature:                 case SyntaxKind.CallSignature:                 case SyntaxKind.ConstructSignature:                 case SyntaxKind.FunctionType:                 case SyntaxKind.ConstructorType:                 case SyntaxKind.TypeAliasDeclaration:                 case SyntaxKind.InterfaceDeclaration:                     checkUnusedTypeParameters(node, addDiagnostic);                     break;                 case SyntaxKind.InferType:                     checkUnusedInferTypeParameter(node, addDiagnostic);                     break;                 default:                     Debug.assertNever(node, "Node should not have been registered for unused identifiers check");             }         } */
    }
    errorUnusedLocal := func(declaration Declaration, name string, addDiagnostic AddUnusedDiagnostic) {
        node := /* TODO(BinaryExpression): getNameOfDeclaration(declaration) || declaration */ TODO
        message := /* TODO(ConditionalExpression): isTypeDeclaration(declaration) ? Diagnostics._0_is_declared_but_never_used : Diagnostics._0_is_declared_but_its_value_is_never_read */ TODO
        /* TODO(ExpressionStatement): addDiagnostic(declaration, UnusedKind.Local, createDiagnosticForNode(node, message, name)); */
    }
    isIdentifierThatStartsWithUnderscore := func(node Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isIdentifier(node) && idText(node).charCodeAt(0) === CharacterCodes._ */ TODO
    }
    checkUnusedClassMembers := func(node /* TODO(UnionType): ClassDeclaration | ClassExpression */ any, addDiagnostic AddUnusedDiagnostic) {
        /* TODO(ForOfStatement): for (const member of node.members) {             switch (member.kind) {                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.PropertyDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                     if (member.kind === SyntaxKind.SetAccessor && member.symbol.flags & SymbolFlags.GetAccessor) {                         // Already would have reported an error on the getter.                         break;                     }                     const symbol = getSymbolOfDeclaration(member);                     if (                         !symbol.isReferenced                         && (hasEffectiveModifier(member, ModifierFlags.Private) || isNamedDeclaration(member) && isPrivateIdentifier(member.name))                         && !(member.flags & NodeFlags.Ambient)                     ) {                         addDiagnostic(member, UnusedKind.Local, createDiagnosticForNode(member.name!, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolToString(symbol)));                     }                     break;                 case SyntaxKind.Constructor:                     for (const parameter of (member as ConstructorDeclaration).parameters) {                         if (!parameter.symbol.isReferenced && hasSyntacticModifier(parameter, ModifierFlags.Private)) {                             addDiagnostic(parameter, UnusedKind.Local, createDiagnosticForNode(parameter.name, Diagnostics.Property_0_is_declared_but_its_value_is_never_read, symbolName(parameter.symbol)));                         }                     }                     break;                 case SyntaxKind.IndexSignature:                 case SyntaxKind.SemicolonClassElement:                 case SyntaxKind.ClassStaticBlockDeclaration:                     // Can't be private                     break;                 default:                     Debug.fail("Unexpected class member");             }         } */
    }
    checkUnusedInferTypeParameter := func(node InferTypeNode, addDiagnostic AddUnusedDiagnostic) {
        TODO_IDENTIFIER := node
        if isTypeParameterUnused(typeParameter) {
            /* TODO(ExpressionStatement): addDiagnostic(node, UnusedKind.Parameter, createDiagnosticForNode(node, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(typeParameter.name))); */
        }
    }
    checkUnusedTypeParameters := func(node /* TODO(UnionType): ClassLikeDeclaration | SignatureDeclaration | InterfaceDeclaration | TypeAliasDeclaration */ any, addDiagnostic AddUnusedDiagnostic) {
        declarations := /* TODO(PropertyAccessExpression): getSymbolOfDeclaration(node).declarations */ TODO
        if /* TODO(BinaryExpression): !declarations || last(declarations) !== node */ TODO {
        }
        typeParameters := getEffectiveTypeParameterDeclarations(node)
        seenParentsWithEveryUnused := /* TODO(NewExpression): new Set<DeclarationWithTypeParameterChildren>() */ TODO
        /* TODO(ForOfStatement): for (const typeParameter of typeParameters) {             if (!isTypeParameterUnused(typeParameter)) continue;              const name = idText(typeParameter.name);             const { parent } = typeParameter;             if (parent.kind !== SyntaxKind.InferType && parent.typeParameters!.every(isTypeParameterUnused)) {                 if (tryAddToSet(seenParentsWithEveryUnused, parent)) {                     const sourceFile = getSourceFileOfNode(parent);                     const range = isJSDocTemplateTag(parent)                         // Whole @template tag                         ? rangeOfNode(parent)                         // Include the `<>` in the error message                         : rangeOfTypeParameters(sourceFile, parent.typeParameters!);                     const only = parent.typeParameters!.length === 1;                     // TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag                     const messageAndArg: DiagnosticAndArguments = only                         ? [Diagnostics._0_is_declared_but_its_value_is_never_read, name]                         : [Diagnostics.All_type_parameters_are_unused];                     addDiagnostic(typeParameter, UnusedKind.Parameter, createFileDiagnostic(sourceFile, range.pos, range.end - range.pos, ...messageAndArg));                 }             }             else {                 // TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag                 addDiagnostic(typeParameter, UnusedKind.Parameter, createDiagnosticForNode(typeParameter, Diagnostics._0_is_declared_but_its_value_is_never_read, name));             }         } */
    }
    isTypeParameterUnused := func(typeParameter TypeParameterDeclaration) bool {
         /* TODO(BinaryExpression): !(getMergedSymbol(typeParameter.symbol).isReferenced! & SymbolFlags.TypeParameter) && !isIdentifierThatStartsWithUnderscore(typeParameter.name) */ TODO
    }
    addToGroup := func(map_ Map[string, /* TODO(TupleType): [K, V[]] */ TODO], key K, value V, getKey func(key K) /* TODO(UnionType): number | string */ any) {
        keyString := String(getKey(key))
        group := /* TODO(PropertyAccessExpression): map.get */ TODO(keyString)
        if group {
            /* TODO(ExpressionStatement): group[1].push(value); */
        } else {
            /* TODO(ExpressionStatement): map.set(keyString, [key, [value]]); */
        }
    }
    tryGetRootParameterDeclaration := func(node Node) *ParameterDeclaration {
         tryCast(getRootDeclaration(node), isParameter)
    }
    isValidUnusedLocalDeclaration := func(declaration Declaration) bool {
        if isBindingElement(declaration) {
            if isObjectBindingPattern(/* TODO(PropertyAccessExpression): declaration.parent */ TODO) {
                 /* TODO(PrefixUnaryExpression): !!(declaration.propertyName && isIdentifierThatStartsWithUnderscore(declaration.name)) */ TODO
            }
             isIdentifierThatStartsWithUnderscore(/* TODO(PropertyAccessExpression): declaration.name */ TODO)
        }
         /* TODO(BinaryExpression): isAmbientModule(declaration) ||             (isVariableDeclaration(declaration) && isForInOrOfStatement(declaration.parent.parent) || isImportedDeclaration(declaration)) && isIdentifierThatStartsWithUnderscore(declaration.name!) */ TODO
    }
    checkUnusedLocalsAndParameters := func(nodeWithLocals HasLocals, addDiagnostic AddUnusedDiagnostic) {
        unusedImports := /* TODO(NewExpression): new Map<string, [ImportClause, ImportedDeclaration[]]>() */ TODO
        unusedDestructures := /* TODO(NewExpression): new Map<string, [BindingPattern, BindingElement[]]>() */ TODO
        unusedVariables := /* TODO(NewExpression): new Map<string, [VariableDeclarationList, VariableDeclaration[]]>() */ TODO
        /* TODO(ExpressionStatement): nodeWithLocals.locals!.forEach(local => {             // If it's purely a type parameter, ignore, will be checked in `checkUnusedTypeParameters`.             // If it's a type parameter merged with a parameter, check if the parameter-side is used.             if (local.flags & SymbolFlags.TypeParameter ? !(local.flags & SymbolFlags.Variable && !(local.isReferenced! & SymbolFlags.Variable)) : local.isReferenced || local.exportSymbol) {                 return;             }              if (local.declarations) {                 for (const declaration of local.declarations) {                     if (isValidUnusedLocalDeclaration(declaration)) {                         continue;                     }                      if (isImportedDeclaration(declaration)) {                         addToGroup(unusedImports, importClauseFromImported(declaration), declaration, getNodeId);                     }                     else if (isBindingElement(declaration) && isObjectBindingPattern(declaration.parent)) {                         // In `{ a, ...b }, `a` is considered used since it removes a property from `b`. `b` may still be unused though.                         const lastElement = last(declaration.parent.elements);                         if (declaration === lastElement || !last(declaration.parent.elements).dotDotDotToken) {                             addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);                         }                     }                     else if (isVariableDeclaration(declaration)) {                         const blockScopeKind = getCombinedNodeFlagsCached(declaration) & NodeFlags.BlockScoped;                         const name = getNameOfDeclaration(declaration);                         if (blockScopeKind !== NodeFlags.Using && blockScopeKind !== NodeFlags.AwaitUsing || !name || !isIdentifierThatStartsWithUnderscore(name)) {                             addToGroup(unusedVariables, declaration.parent, declaration, getNodeId);                         }                     }                     else {                         const parameter = local.valueDeclaration && tryGetRootParameterDeclaration(local.valueDeclaration);                         const name = local.valueDeclaration && getNameOfDeclaration(local.valueDeclaration);                         if (parameter && name) {                             if (!isParameterPropertyDeclaration(parameter, parameter.parent) && !parameterIsThisKeyword(parameter) && !isIdentifierThatStartsWithUnderscore(name)) {                                 if (isBindingElement(declaration) && isArrayBindingPattern(declaration.parent)) {                                     addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);                                 }                                 else {                                     addDiagnostic(parameter, UnusedKind.Parameter, createDiagnosticForNode(name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolName(local)));                                 }                             }                         }                         else {                             errorUnusedLocal(declaration, symbolName(local), addDiagnostic);                         }                     }                 }             }         }); */
        /* TODO(ExpressionStatement): unusedImports.forEach(([importClause, unuseds]) => {             const importDecl = importClause.parent;             const nDeclarations = (importClause.name ? 1 : 0) +                 (importClause.namedBindings ?                     (importClause.namedBindings.kind === SyntaxKind.NamespaceImport ? 1 : importClause.namedBindings.elements.length)                     : 0);             if (nDeclarations === unuseds.length) {                 addDiagnostic(                     importDecl,                     UnusedKind.Local,                     unuseds.length === 1                         ? createDiagnosticForNode(importDecl, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(first(unuseds).name!))                         : createDiagnosticForNode(importDecl, Diagnostics.All_imports_in_import_declaration_are_unused),                 );             }             else {                 for (const unused of unuseds) errorUnusedLocal(unused, idText(unused.name!), addDiagnostic);             }         }); */
        /* TODO(ExpressionStatement): unusedDestructures.forEach(([bindingPattern, bindingElements]) => {             const kind = tryGetRootParameterDeclaration(bindingPattern.parent) ? UnusedKind.Parameter : UnusedKind.Local;             if (bindingPattern.elements.length === bindingElements.length) {                 if (bindingElements.length === 1 && bindingPattern.parent.kind === SyntaxKind.VariableDeclaration && bindingPattern.parent.parent.kind === SyntaxKind.VariableDeclarationList) {                     addToGroup(unusedVariables, bindingPattern.parent.parent, bindingPattern.parent, getNodeId);                 }                 else {                     addDiagnostic(                         bindingPattern,                         kind,                         bindingElements.length === 1                             ? createDiagnosticForNode(bindingPattern, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(bindingElements).name))                             : createDiagnosticForNode(bindingPattern, Diagnostics.All_destructured_elements_are_unused),                     );                 }             }             else {                 for (const e of bindingElements) {                     addDiagnostic(e, kind, createDiagnosticForNode(e, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(e.name)));                 }             }         }); */
        /* TODO(ExpressionStatement): unusedVariables.forEach(([declarationList, declarations]) => {             if (declarationList.declarations.length === declarations.length) {                 addDiagnostic(                     declarationList,                     UnusedKind.Local,                     declarations.length === 1                         ? createDiagnosticForNode(first(declarations).name, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(declarations).name))                         : createDiagnosticForNode(declarationList.parent.kind === SyntaxKind.VariableStatement ? declarationList.parent : declarationList, Diagnostics.All_variables_are_unused),                 );             }             else {                 for (const decl of declarations) {                     addDiagnostic(decl, UnusedKind.Local, createDiagnosticForNode(decl, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(decl.name)));                 }             }         }); */
    }
    checkPotentialUncheckedRenamedBindingElementsInTypes := func() {
        /* TODO(ForOfStatement): for (const node of potentialUnusedRenamedBindingElementsInTypes) {             if (!getSymbolOfDeclaration(node)?.isReferenced) {                 const wrappingDeclaration = walkUpBindingElementsAndPatterns(node);                 Debug.assert(isPartOfParameterDeclaration(wrappingDeclaration), "Only parameter declaration should be checked here");                 const diagnostic = createDiagnosticForNode(node.name, Diagnostics._0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation, declarationNameToString(node.name), declarationNameToString(node.propertyName));                 if (!wrappingDeclaration.type) {                     // entire parameter does not have type annotation, suggest adding an annotation                     addRelatedInfo(                         diagnostic,                         createFileDiagnostic(getSourceFileOfNode(wrappingDeclaration), wrappingDeclaration.end, 0, Diagnostics.We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here, declarationNameToString(node.propertyName)),                     );                 }                 diagnostics.add(diagnostic);             }         } */
    }
    bindingNameText := func(name BindingName) string {
        /* TODO(SwitchStatement): switch (name.kind) {             case SyntaxKind.Identifier:                 return idText(name);             case SyntaxKind.ArrayBindingPattern:             case SyntaxKind.ObjectBindingPattern:                 return bindingNameText(cast(first(name.elements), isBindingElement).name);             default:                 return Debug.assertNever(name);         } */
    }
    type ImportedDeclaration /* TODO(UnionType): ImportClause | ImportSpecifier | NamespaceImport */ any
    isImportedDeclaration := func(node Node) /* TODO(TypePredicate): node is ImportedDeclaration */ TODO {
         /* TODO(BinaryExpression): node.kind === SyntaxKind.ImportClause || node.kind === SyntaxKind.ImportSpecifier || node.kind === SyntaxKind.NamespaceImport */ TODO
    }
    importClauseFromImported := func(decl ImportedDeclaration) ImportClause {
         /* TODO(ConditionalExpression): decl.kind === SyntaxKind.ImportClause ? decl : decl.kind === SyntaxKind.NamespaceImport ? decl.parent : decl.parent.parent */ TODO
    }
    checkBlock := func(node Block) {
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.Block */ TODO {
            /* TODO(ExpressionStatement): checkGrammarStatementInAmbientContext(node); */
        }
        if isFunctionOrModuleBlock(node) {
            saveFlowAnalysisDisabled := flowAnalysisDisabled
            /* TODO(ExpressionStatement): forEach(node.statements, checkSourceElement); */
            /* TODO(ExpressionStatement): flowAnalysisDisabled = saveFlowAnalysisDisabled; */
        } else {
            /* TODO(ExpressionStatement): forEach(node.statements, checkSourceElement); */
        }
        if /* TODO(PropertyAccessExpression): node.locals */ TODO {
            /* TODO(ExpressionStatement): registerForUnusedIdentifiersCheck(node); */
        }
    }
    checkCollisionWithArgumentsInGeneratedCode := func(node SignatureDeclaration) {
        if /* TODO(BinaryExpression): languageVersion >= ScriptTarget.ES2015 || !hasRestParameter(node) || node.flags & NodeFlags.Ambient || nodeIsMissing((node as FunctionLikeDeclaration).body) */ TODO {

        }
        /* TODO(ExpressionStatement): forEach(node.parameters, p => {             if (p.name && !isBindingPattern(p.name) && p.name.escapedText === argumentsSymbol.escapedName) {                 errorSkippedOn("noEmit", p, Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);             }         }); */
    }
    needCollisionCheckForIdentifier := func(node Node, identifier *Identifier, name string) bool {
        if /* TODO(BinaryExpression): identifier?.escapedText !== name */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.PropertyDeclaration ||             node.kind === SyntaxKind.PropertySignature ||             node.kind === SyntaxKind.MethodDeclaration ||             node.kind === SyntaxKind.MethodSignature ||             node.kind === SyntaxKind.GetAccessor ||             node.kind === SyntaxKind.SetAccessor ||             node.kind === SyntaxKind.PropertyAssignment */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): isImportClause(node) || isImportEqualsDeclaration(node) || isImportSpecifier(node) */ TODO {
            if isTypeOnlyImportOrExportDeclaration(node) {
                 /* TODO(FalseKeyword): false */ TODO
            }
        }
        root := getRootDeclaration(node)
        if /* TODO(BinaryExpression): isParameter(root) && nodeIsMissing((root.parent as FunctionLikeDeclaration).body) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(TrueKeyword): true */ TODO
    }
    checkIfThisIsCapturedInEnclosingScope := func(node Node) {
        /* TODO(ExpressionStatement): findAncestor(node, current => {             if (getNodeCheckFlags(current) & NodeCheckFlags.CaptureThis) {                 const isDeclaration = node.kind !== SyntaxKind.Identifier;                 if (isDeclaration) {                     error(getNameOfDeclaration(node as Declaration), Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);                 }                 else {                     error(node, Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);                 }                 return true;             }             return false;         }); */
    }
    checkIfNewTargetIsCapturedInEnclosingScope := func(node Node) {
        /* TODO(ExpressionStatement): findAncestor(node, current => {             if (getNodeCheckFlags(current) & NodeCheckFlags.CaptureNewTarget) {                 const isDeclaration = node.kind !== SyntaxKind.Identifier;                 if (isDeclaration) {                     error(getNameOfDeclaration(node as Declaration), Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference);                 }                 else {                     error(node, Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference);                 }                 return true;             }             return false;         }); */
    }
    checkCollisionWithRequireExportsInGeneratedCode := func(node Node, name *Identifier) {
        if /* TODO(BinaryExpression): host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) >= ModuleKind.ES2015 */ TODO {

        }
        if /* TODO(BinaryExpression): !name || !needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports") */ TODO {

        }
        if /* TODO(BinaryExpression): isModuleDeclaration(node) && getModuleInstanceState(node) !== ModuleInstanceState.Instantiated */ TODO {

        }
        parent := getDeclarationContainer(node)
        if /* TODO(BinaryExpression): parent.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(parent as SourceFile) */ TODO {
            /* TODO(ExpressionStatement): errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, declarationNameToString(name), declarationNameToString(name)); */
        }
    }
    checkCollisionWithGlobalPromiseInGeneratedCode := func(node Node, name *Identifier) {
        if /* TODO(BinaryExpression): !name || languageVersion >= ScriptTarget.ES2017 || !needCollisionCheckForIdentifier(node, name, "Promise") */ TODO {

        }
        if /* TODO(BinaryExpression): isModuleDeclaration(node) && getModuleInstanceState(node) !== ModuleInstanceState.Instantiated */ TODO {

        }
        parent := getDeclarationContainer(node)
        if /* TODO(BinaryExpression): parent.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(parent as SourceFile) && parent.flags & NodeFlags.HasAsyncFunctions */ TODO {
            /* TODO(ExpressionStatement): errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions, declarationNameToString(name), declarationNameToString(name)); */
        }
    }
    recordPotentialCollisionWithWeakMapSetInGeneratedCode := func(node Node, name Identifier) {
        if /* TODO(BinaryExpression): languageVersion <= ScriptTarget.ES2021             && (needCollisionCheckForIdentifier(node, name, "WeakMap") || needCollisionCheckForIdentifier(node, name, "WeakSet")) */ TODO {
            /* TODO(ExpressionStatement): potentialWeakMapSetCollisions.push(node); */
        }
    }
    checkWeakMapSetCollision := func(node Node) {
        enclosingBlockScope := getEnclosingBlockScopeContainer(node)
        if /* TODO(BinaryExpression): getNodeCheckFlags(enclosingBlockScope) & NodeCheckFlags.ContainsClassWithPrivateIdentifiers */ TODO {
            /* TODO(ExpressionStatement): Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name) && typeof node.name.escapedText === "string", "The target of a WeakMap/WeakSet collision check should be an identifier"); */
            /* TODO(ExpressionStatement): errorSkippedOn("noEmit", node, Diagnostics.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel, node.name.escapedText); */
        }
    }
    recordPotentialCollisionWithReflectInGeneratedCode := func(node Node, name *Identifier) {
        if /* TODO(BinaryExpression): name && languageVersion >= ScriptTarget.ES2015 && languageVersion <= ScriptTarget.ES2021             && needCollisionCheckForIdentifier(node, name, "Reflect") */ TODO {
            /* TODO(ExpressionStatement): potentialReflectCollisions.push(node); */
        }
    }
    checkReflectCollision := func(node Node) {
        hasCollision := /* TODO(FalseKeyword): false */ TODO
        if isClassExpression(node) {
            /* TODO(ForOfStatement): for (const member of node.members) {                 if (getNodeCheckFlags(member) & NodeCheckFlags.ContainsSuperPropertyInStaticInitializer) {                     hasCollision = true;                     break;                 }             } */
        } else if isFunctionExpression(node) {
            if /* TODO(BinaryExpression): getNodeCheckFlags(node) & NodeCheckFlags.ContainsSuperPropertyInStaticInitializer */ TODO {
                /* TODO(ExpressionStatement): hasCollision = true; */
            }
        } else {
            container := getEnclosingBlockScopeContainer(node)
            if /* TODO(BinaryExpression): container && getNodeCheckFlags(container) & NodeCheckFlags.ContainsSuperPropertyInStaticInitializer */ TODO {
                /* TODO(ExpressionStatement): hasCollision = true; */
            }
        }
        if hasCollision {
            /* TODO(ExpressionStatement): Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name), "The target of a Reflect collision check should be an identifier"); */
            /* TODO(ExpressionStatement): errorSkippedOn("noEmit", node, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers, declarationNameToString(node.name), "Reflect"); */
        }
    }
    checkCollisionsForDeclarationName := func(node Node, name *Identifier) {
        if /* TODO(PrefixUnaryExpression): !name */ TODO {
        }
        /* TODO(ExpressionStatement): checkCollisionWithRequireExportsInGeneratedCode(node, name); */
        /* TODO(ExpressionStatement): checkCollisionWithGlobalPromiseInGeneratedCode(node, name); */
        /* TODO(ExpressionStatement): recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name); */
        /* TODO(ExpressionStatement): recordPotentialCollisionWithReflectInGeneratedCode(node, name); */
        if isClassLike(node) {
            /* TODO(ExpressionStatement): checkTypeNameIsReserved(name, Diagnostics.Class_name_cannot_be_0); */
            if /* TODO(PrefixUnaryExpression): !(node.flags & NodeFlags.Ambient) */ TODO {
                /* TODO(ExpressionStatement): checkClassNameCollisionWithObject(name); */
            }
        } else if isEnumDeclaration(node) {
            /* TODO(ExpressionStatement): checkTypeNameIsReserved(name, Diagnostics.Enum_name_cannot_be_0); */
        }
    }
    checkVarDeclaredNamesNotShadowed := func(node /* TODO(UnionType): VariableDeclaration | BindingElement */ any) /* TODO(undefined): undefined */ TODO {
        if /* TODO(BinaryExpression): (getCombinedNodeFlagsCached(node) & NodeFlags.BlockScoped) !== 0 || isPartOfParameterDeclaration(node) */ TODO {

        }
        symbol := getSymbolOfDeclaration(node)
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.FunctionScopedVariable */ TODO {
            if /* TODO(PrefixUnaryExpression): !isIdentifier(node.name) */ TODO {
                /* TODO(CallExpression): Debug.fail() */
            }
            localDeclarationSymbol := resolveName(node, /* TODO(PropertyAccessExpression): node.name.escapedText */ TODO, /* TODO(PropertyAccessExpression): SymbolFlags.Variable */ TODO, undefined, /* TODO(FalseKeyword): false */ TODO)
            if /* TODO(BinaryExpression): localDeclarationSymbol &&                 localDeclarationSymbol !== symbol &&                 localDeclarationSymbol.flags & SymbolFlags.BlockScopedVariable */ TODO {
                if /* TODO(BinaryExpression): getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & NodeFlags.BlockScoped */ TODO {
                    varDeclList := /* TODO(NonNullExpression): getAncestor(localDeclarationSymbol.valueDeclaration, SyntaxKind.VariableDeclarationList)! */ TODO
                    container := /* TODO(ConditionalExpression): varDeclList.parent.kind === SyntaxKind.VariableStatement && varDeclList.parent.parent                         ? varDeclList.parent.parent                         : undefined */ TODO
                    namesShareScope := /* TODO(BinaryExpression): container &&                         (container.kind === SyntaxKind.Block && isFunctionLike(container.parent) ||                             container.kind === SyntaxKind.ModuleBlock ||                             container.kind === SyntaxKind.ModuleDeclaration ||                             container.kind === SyntaxKind.SourceFile) */ TODO
                    if /* TODO(PrefixUnaryExpression): !namesShareScope */ TODO {
                        name := symbolToString(localDeclarationSymbol)
                        /* TODO(ExpressionStatement): error(node, Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name); */
                    }
                }
            }
        }
    }
    convertAutoToAny := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         /* TODO(ConditionalExpression): type === autoType ? anyType : type === autoArrayType ? anyArrayType : type */ TODO
    }
    checkVariableLikeDeclaration := func(node /* TODO(UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement */ any) {
        /* TODO(ExpressionStatement): checkDecorators(node); */
        if /* TODO(PrefixUnaryExpression): !isBindingElement(node) */ TODO {
            /* TODO(ExpressionStatement): checkSourceElement(node.type); */
        }
        if /* TODO(PrefixUnaryExpression): !node.name */ TODO {

        }
        if /* TODO(BinaryExpression): node.name.kind === SyntaxKind.ComputedPropertyName */ TODO {
            /* TODO(ExpressionStatement): checkComputedPropertyName(node.name); */
            if /* TODO(BinaryExpression): hasOnlyExpressionInitializer(node) && node.initializer */ TODO {
                /* TODO(ExpressionStatement): checkExpressionCached(node.initializer); */
            }
        }
        if isBindingElement(node) {
            if /* TODO(BinaryExpression): node.propertyName &&                 isIdentifier(node.name) &&                 isPartOfParameterDeclaration(node) &&                 nodeIsMissing((getContainingFunction(node) as FunctionLikeDeclaration).body) */ TODO {
                /* TODO(ExpressionStatement): potentialUnusedRenamedBindingElementsInTypes.push(node); */

            }
            if /* TODO(BinaryExpression): isObjectBindingPattern(node.parent) && node.dotDotDotToken && languageVersion < LanguageFeatureMinimumTarget.ObjectSpreadRest */ TODO {
                /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.Rest); */
            }
            if /* TODO(BinaryExpression): node.propertyName && node.propertyName.kind === SyntaxKind.ComputedPropertyName */ TODO {
                /* TODO(ExpressionStatement): checkComputedPropertyName(node.propertyName); */
            }
            parent := /* TODO(PropertyAccessExpression): node.parent.parent */ TODO
            parentCheckMode := /* TODO(ConditionalExpression): node.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */ TODO
            parentType := getTypeForBindingElementParent(parent, parentCheckMode)
            name := /* TODO(BinaryExpression): node.propertyName || node.name */ TODO
            if /* TODO(BinaryExpression): parentType && !isBindingPattern(name) */ TODO {
                exprType := getLiteralTypeFromPropertyName(name)
                if isTypeUsableAsPropertyName(exprType) {
                    nameText := getPropertyNameFromType(exprType)
                    property := getPropertyOfType(parentType, nameText)
                    if property {
                        /* TODO(ExpressionStatement): markPropertyAsReferenced(property, /*nodeForCheckWriteOnly* / undefined, /*isSelfTypeAccess* / false); */
                        /* TODO(ExpressionStatement): checkPropertyAccessibility(node, !!parent.initializer && parent.initializer.kind === SyntaxKind.SuperKeyword, /*writing* / false, parentType, property); */
                    }
                }
            }
        }
        if isBindingPattern(/* TODO(PropertyAccessExpression): node.name */ TODO) {
            if /* TODO(BinaryExpression): node.name.kind === SyntaxKind.ArrayBindingPattern && languageVersion < LanguageFeatureMinimumTarget.BindingPatterns && compilerOptions.downlevelIteration */ TODO {
                /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.Read); */
            }
            /* TODO(ExpressionStatement): forEach(node.name.elements, checkSourceElement); */
        }
        if /* TODO(BinaryExpression): node.initializer && isPartOfParameterDeclaration(node) && nodeIsMissing((getContainingFunction(node) as FunctionLikeDeclaration).body) */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation); */

        }
        if isBindingPattern(/* TODO(PropertyAccessExpression): node.name */ TODO) {
            if isInAmbientOrTypeNode(node) {

            }
            needCheckInitializer := /* TODO(BinaryExpression): hasOnlyExpressionInitializer(node) && node.initializer && node.parent.parent.kind !== SyntaxKind.ForInStatement */ TODO
            needCheckWidenedType := /* TODO(PrefixUnaryExpression): !some(node.name.elements, not(isOmittedExpression)) */ TODO
            if /* TODO(BinaryExpression): needCheckInitializer || needCheckWidenedType */ TODO {
                widenedType := getWidenedTypeForVariableLikeDeclaration(node)
                if needCheckInitializer {
                    initializerType := checkExpressionCached(/* TODO(PropertyAccessExpression): node.initializer */ TODO)
                    if /* TODO(BinaryExpression): strictNullChecks && needCheckWidenedType */ TODO {
                        /* TODO(ExpressionStatement): checkNonNullNonVoidType(initializerType, node); */
                    } else {
                        /* TODO(ExpressionStatement): checkTypeAssignableToAndOptionallyElaborate(initializerType, getWidenedTypeForVariableLikeDeclaration(node), node, node.initializer); */
                    }
                }
                if needCheckWidenedType {
                    if isArrayBindingPattern(/* TODO(PropertyAccessExpression): node.name */ TODO) {
                        /* TODO(ExpressionStatement): checkIteratedTypeOrElementType(IterationUse.Destructuring, widenedType, undefinedType, node); */
                    } else if strictNullChecks {
                        /* TODO(ExpressionStatement): checkNonNullNonVoidType(widenedType, node); */
                    }
                }
            }

        }
        symbol := getSymbolOfDeclaration(node)
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias && (isVariableDeclarationInitializedToBareOrAccessedRequire(node) || isBindingElementOfBareOrAccessedRequire(node)) */ TODO {
            /* TODO(ExpressionStatement): checkAliasSymbol(node); */

        }
        if /* TODO(BinaryExpression): node.name.kind === SyntaxKind.BigIntLiteral */ TODO {
            /* TODO(ExpressionStatement): error(node.name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name); */
        }
        type_ := convertAutoToAny(getTypeOfSymbol(symbol))
        if /* TODO(BinaryExpression): node === symbol.valueDeclaration */ TODO {
            initializer := /* TODO(BinaryExpression): hasOnlyExpressionInitializer(node) && getEffectiveInitializer(node) */ TODO
            if initializer {
                isJSObjectLiteralInitializer := /* TODO(BinaryExpression): isInJSFile(node) &&                     isObjectLiteralExpression(initializer) &&                     (initializer.properties.length === 0 || isPrototypeAccess(node.name)) &&                     !!symbol.exports?.size */ TODO
                if /* TODO(BinaryExpression): !isJSObjectLiteralInitializer && node.parent.parent.kind !== SyntaxKind.ForInStatement */ TODO {
                    initializerType := checkExpressionCached(initializer)
                    /* TODO(ExpressionStatement): checkTypeAssignableToAndOptionallyElaborate(initializerType, type, node, initializer, /*headMessage* / undefined); */
                    blockScopeKind := /* TODO(BinaryExpression): getCombinedNodeFlagsCached(node) & NodeFlags.BlockScoped */ TODO
                    if /* TODO(BinaryExpression): blockScopeKind === NodeFlags.AwaitUsing */ TODO {
                        globalAsyncDisposableType := getGlobalAsyncDisposableType(/* TODO(TrueKeyword): true */ TODO)
                        globalDisposableType := getGlobalDisposableType(/* TODO(TrueKeyword): true */ TODO)
                        if /* TODO(BinaryExpression): globalAsyncDisposableType !== emptyObjectType && globalDisposableType !== emptyObjectType */ TODO {
                            optionalDisposableType := getUnionType(/* TODO(ArrayLiteralExpression): [globalAsyncDisposableType, globalDisposableType, nullType, undefinedType] */ TODO)
                            /* TODO(ExpressionStatement): checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_Symbol_dispose_method_or_be_null_or_undefined); */
                        }
                    } else if /* TODO(BinaryExpression): blockScopeKind === NodeFlags.Using */ TODO {
                        globalDisposableType := getGlobalDisposableType(/* TODO(TrueKeyword): true */ TODO)
                        if /* TODO(BinaryExpression): globalDisposableType !== emptyObjectType */ TODO {
                            optionalDisposableType := getUnionType(/* TODO(ArrayLiteralExpression): [globalDisposableType, nullType, undefinedType] */ TODO)
                            /* TODO(ExpressionStatement): checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_a_using_declaration_must_be_either_an_object_with_a_Symbol_dispose_method_or_be_null_or_undefined); */
                        }
                    }
                }
            }
            if /* TODO(BinaryExpression): symbol.declarations && symbol.declarations.length > 1 */ TODO {
                if some(/* TODO(PropertyAccessExpression): symbol.declarations */ TODO, /* TODO(ArrowFunction): d => d !== node && isVariableLike(d) && !areDeclarationFlagsIdentical(d, node) */ TODO) {
                    /* TODO(ExpressionStatement): error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name)); */
                }
            }
        } else {
            declarationType := convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node))
            if /* TODO(BinaryExpression): !isErrorType(type) && !isErrorType(declarationType) &&                 !isTypeIdenticalTo(type, declarationType) &&                 !(symbol.flags & SymbolFlags.Assignment) */ TODO {
                /* TODO(ExpressionStatement): errorNextVariableOrPropertyDeclarationMustHaveSameType(symbol.valueDeclaration, type, node, declarationType); */
            }
            if /* TODO(BinaryExpression): hasOnlyExpressionInitializer(node) && node.initializer */ TODO {
                /* TODO(ExpressionStatement): checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(node.initializer), declarationType, node, node.initializer, /*headMessage* / undefined); */
            }
            if /* TODO(BinaryExpression): symbol.valueDeclaration && !areDeclarationFlagsIdentical(node, symbol.valueDeclaration) */ TODO {
                /* TODO(ExpressionStatement): error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name)); */
            }
        }
        if /* TODO(BinaryExpression): node.kind !== SyntaxKind.PropertyDeclaration && node.kind !== SyntaxKind.PropertySignature */ TODO {
            /* TODO(ExpressionStatement): checkExportsOnMergedDeclarations(node); */
            if /* TODO(BinaryExpression): node.kind === SyntaxKind.VariableDeclaration || node.kind === SyntaxKind.BindingElement */ TODO {
                /* TODO(ExpressionStatement): checkVarDeclaredNamesNotShadowed(node); */
            }
            /* TODO(ExpressionStatement): checkCollisionsForDeclarationName(node, node.name); */
        }
    }
    errorNextVariableOrPropertyDeclarationMustHaveSameType := func(firstDeclaration Declaration, firstType Type, nextDeclaration Declaration, nextType Type) {
        nextDeclarationName := getNameOfDeclaration(nextDeclaration)
        message := /* TODO(ConditionalExpression): nextDeclaration.kind === SyntaxKind.PropertyDeclaration || nextDeclaration.kind === SyntaxKind.PropertySignature             ? Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2             : Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2 */ TODO
        declName := declarationNameToString(nextDeclarationName)
        err := error(nextDeclarationName, message, declName, typeToString(firstType), typeToString(nextType))
        if firstDeclaration {
            /* TODO(ExpressionStatement): addRelatedInfo(err, createDiagnosticForNode(firstDeclaration, Diagnostics._0_was_also_declared_here, declName)); */
        }
    }
    areDeclarationFlagsIdentical := func(left Declaration, right Declaration) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): (left.kind === SyntaxKind.Parameter && right.kind === SyntaxKind.VariableDeclaration) ||             (left.kind === SyntaxKind.VariableDeclaration && right.kind === SyntaxKind.Parameter) */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): hasQuestionToken(left) !== hasQuestionToken(right) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        interestingFlags := /* TODO(BinaryExpression): ModifierFlags.Private |             ModifierFlags.Protected |             ModifierFlags.Async |             ModifierFlags.Abstract |             ModifierFlags.Readonly |             ModifierFlags.Static */ TODO
         /* TODO(BinaryExpression): getSelectedEffectiveModifierFlags(left, interestingFlags) === getSelectedEffectiveModifierFlags(right, interestingFlags) */ TODO
    }
    checkVariableDeclaration := func(node VariableDeclaration) {
        /* TODO(ExpressionStatement): tracing?.push(tracing.Phase.Check, "checkVariableDeclaration", { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath }); */
        /* TODO(ExpressionStatement): checkGrammarVariableDeclaration(node); */
        /* TODO(ExpressionStatement): checkVariableLikeDeclaration(node); */
        /* TODO(ExpressionStatement): tracing?.pop(); */
    }
    checkBindingElement := func(node BindingElement) {
        /* TODO(ExpressionStatement): checkGrammarBindingElement(node); */
         checkVariableLikeDeclaration(node)
    }
    checkVariableDeclarationList := func(node VariableDeclarationList) {
        blockScopeKind := /* TODO(BinaryExpression): getCombinedNodeFlags(node) & NodeFlags.BlockScoped */ TODO
        if /* TODO(BinaryExpression): (blockScopeKind === NodeFlags.Using || blockScopeKind === NodeFlags.AwaitUsing) && languageVersion < LanguageFeatureMinimumTarget.UsingAndAwaitUsing */ TODO {
            /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.AddDisposableResourceAndDisposeResources); */
        }
        /* TODO(ExpressionStatement): forEach(node.declarations, checkSourceElement); */
    }
    checkVariableStatement := func(node VariableStatement) {
        if /* TODO(BinaryExpression): !checkGrammarModifiers(node) && !checkGrammarVariableDeclarationList(node.declarationList) */ TODO {
            /* TODO(CallExpression): checkGrammarForDisallowedBlockScopedVariableStatement(node) */
        }
        /* TODO(ExpressionStatement): checkVariableDeclarationList(node.declarationList); */
    }
    checkExpressionStatement := func(node ExpressionStatement) {
        /* TODO(ExpressionStatement): checkGrammarStatementInAmbientContext(node); */
        /* TODO(ExpressionStatement): checkExpression(node.expression); */
    }
    checkIfStatement := func(node IfStatement) {
        /* TODO(ExpressionStatement): checkGrammarStatementInAmbientContext(node); */
        type_ := checkTruthinessExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO)
        /* TODO(ExpressionStatement): checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.expression, type, node.thenStatement); */
        /* TODO(ExpressionStatement): checkSourceElement(node.thenStatement); */
        if /* TODO(BinaryExpression): node.thenStatement.kind === SyntaxKind.EmptyStatement */ TODO {
            /* TODO(ExpressionStatement): error(node.thenStatement, Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement); */
        }
        /* TODO(ExpressionStatement): checkSourceElement(node.elseStatement); */
    }
    checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType := func(condExpr Expression, condType Type, body /* TODO(UnionType): Statement | Expression */ any) {
        if /* TODO(PrefixUnaryExpression): !strictNullChecks */ TODO {
        }
        /* TODO(ExpressionStatement): bothHelper(condExpr, body); */
        bothHelper := func(condExpr Expression, body /* TODO(UnionType): Expression | Statement | undefined */ any) {
            /* TODO(ExpressionStatement): condExpr = skipParentheses(condExpr); */
            /* TODO(ExpressionStatement): helper(condExpr, body); */
            /* TODO(WhileStatement): while (isBinaryExpression(condExpr) && (condExpr.operatorToken.kind === SyntaxKind.BarBarToken || condExpr.operatorToken.kind === SyntaxKind.QuestionQuestionToken)) {                 condExpr = skipParentheses(condExpr.left);                 helper(condExpr, body);             } */
        }
        helper := func(condExpr Expression, body /* TODO(UnionType): Expression | Statement | undefined */ any) {
            location := /* TODO(ConditionalExpression): isLogicalOrCoalescingBinaryExpression(condExpr) ? skipParentheses(condExpr.right) : condExpr */ TODO
            if isModuleExportsAccessExpression(location) {

            }
            if isLogicalOrCoalescingBinaryExpression(location) {
                /* TODO(ExpressionStatement): bothHelper(location, body); */

            }
            type_ := /* TODO(ConditionalExpression): location === condExpr ? condType : checkExpression(location) */ TODO
            if /* TODO(BinaryExpression): type.flags & TypeFlags.EnumLiteral && isPropertyAccessExpression(location) && (getNodeLinks(location.expression).resolvedSymbol ?? unknownSymbol).flags & SymbolFlags.Enum */ TODO {
                /* TODO(ExpressionStatement): error(location, Diagnostics.This_condition_will_always_return_0, !!(type as LiteralType).value ? "true" : "false"); */

            }
            isPropertyExpressionCast := /* TODO(BinaryExpression): isPropertyAccessExpression(location) && isTypeAssertion(location.expression) */ TODO
            if /* TODO(BinaryExpression): !hasTypeFacts(type, TypeFacts.Truthy) || isPropertyExpressionCast */ TODO {
            }
            callSignatures := getSignaturesOfType(type_, /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO)
            isPromise := /* TODO(PrefixUnaryExpression): !!getAwaitedTypeOfPromise(type) */ TODO
            if /* TODO(BinaryExpression): callSignatures.length === 0 && !isPromise */ TODO {

            }
            testedNode := /* TODO(ConditionalExpression): isIdentifier(location) ? location                 : isPropertyAccessExpression(location) ? location.name                 : undefined */ TODO
            testedSymbol := /* TODO(BinaryExpression): testedNode && getSymbolAtLocation(testedNode) */ TODO
            if /* TODO(BinaryExpression): !testedSymbol && !isPromise */ TODO {

            }
            isUsed := /* TODO(BinaryExpression): testedSymbol && isBinaryExpression(condExpr.parent) && isSymbolUsedInBinaryExpressionChain(condExpr.parent, testedSymbol)                 || testedSymbol && body && isSymbolUsedInConditionBody(condExpr, body, testedNode, testedSymbol) */ TODO
            if /* TODO(PrefixUnaryExpression): !isUsed */ TODO {
                if isPromise {
                    /* TODO(ExpressionStatement): errorAndMaybeSuggestAwait(                         location,                         /*maybeMissingAwait* / true,                         Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined,                         getTypeNameForErrorDisplay(type),                     ); */
                } else {
                    /* TODO(ExpressionStatement): error(location, Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead); */
                }
            }
        }
    }
    isSymbolUsedInConditionBody := func(expr Expression, body /* TODO(UnionType): Statement | Expression */ any, testedNode Node, testedSymbol Symbol) bool {
         /* TODO(PrefixUnaryExpression): !!forEachChild(body, function check(childNode): boolean | undefined {             if (isIdentifier(childNode)) {                 const childSymbol = getSymbolAtLocation(childNode);                 if (childSymbol && childSymbol === testedSymbol) {                     // If the test was a simple identifier, the above check is sufficient                     if (isIdentifier(expr) || isIdentifier(testedNode) && isBinaryExpression(testedNode.parent)) {                         return true;                     }                     // Otherwise we need to ensure the symbol is called on the same target                     let testedExpression = testedNode.parent;                     let childExpression = childNode.parent;                     while (testedExpression && childExpression) {                         if (                             isIdentifier(testedExpression) && isIdentifier(childExpression) ||                             testedExpression.kind === SyntaxKind.ThisKeyword && childExpression.kind === SyntaxKind.ThisKeyword                         ) {                             return getSymbolAtLocation(testedExpression) === getSymbolAtLocation(childExpression);                         }                         else if (isPropertyAccessExpression(testedExpression) && isPropertyAccessExpression(childExpression)) {                             if (getSymbolAtLocation(testedExpression.name) !== getSymbolAtLocation(childExpression.name)) {                                 return false;                             }                             childExpression = childExpression.expression;                             testedExpression = testedExpression.expression;                         }                         else if (isCallExpression(testedExpression) && isCallExpression(childExpression)) {                             childExpression = childExpression.expression;                             testedExpression = testedExpression.expression;                         }                         else {                             return false;                         }                     }                 }             }             return forEachChild(childNode, check);         }) */ TODO
    }
    isSymbolUsedInBinaryExpressionChain := func(node Node, testedSymbol Symbol) bool {
        /* TODO(WhileStatement): while (isBinaryExpression(node) && node.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken) {             const isUsed = forEachChild(node.right, function visit(child): boolean | undefined {                 if (isIdentifier(child)) {                     const symbol = getSymbolAtLocation(child);                     if (symbol && symbol === testedSymbol) {                         return true;                     }                 }                 return forEachChild(child, visit);             });             if (isUsed) {                 return true;             }             node = node.parent;         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    checkDoStatement := func(node DoStatement) {
        /* TODO(ExpressionStatement): checkGrammarStatementInAmbientContext(node); */
        /* TODO(ExpressionStatement): checkSourceElement(node.statement); */
        /* TODO(ExpressionStatement): checkTruthinessExpression(node.expression); */
    }
    checkWhileStatement := func(node WhileStatement) {
        /* TODO(ExpressionStatement): checkGrammarStatementInAmbientContext(node); */
        /* TODO(ExpressionStatement): checkTruthinessExpression(node.expression); */
        /* TODO(ExpressionStatement): checkSourceElement(node.statement); */
    }
    checkTruthinessOfType := func(type_ Type, node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if /* TODO(BinaryExpression): type.flags & TypeFlags.Void */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness); */
        } else {
            semantics := getSyntacticTruthySemantics(node)
            if /* TODO(BinaryExpression): semantics !== PredicateSemantics.Sometimes */ TODO {
                /* TODO(ExpressionStatement): error(                     node,                     semantics === PredicateSemantics.Always ?                         Diagnostics.This_kind_of_expression_is_always_truthy :                         Diagnostics.This_kind_of_expression_is_always_falsy,                 ); */
            }
        }
         type_
    }
    getSyntacticTruthySemantics := func(node Node) PredicateSemantics {
        /* TODO(ExpressionStatement): node = skipOuterExpressions(node); */
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.NumericLiteral:                 // Allow `while(0)` or `while(1)`                 if ((node as NumericLiteral).text === "0" || (node as NumericLiteral).text === "1") {                     return PredicateSemantics.Sometimes;                 }                 return PredicateSemantics.Always;             case SyntaxKind.ArrayLiteralExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.BigIntLiteral:             case SyntaxKind.ClassExpression:             case SyntaxKind.FunctionExpression:             case SyntaxKind.JsxElement:             case SyntaxKind.JsxSelfClosingElement:             case SyntaxKind.ObjectLiteralExpression:             case SyntaxKind.RegularExpressionLiteral:                 return PredicateSemantics.Always;             case SyntaxKind.VoidExpression:             case SyntaxKind.NullKeyword:                 return PredicateSemantics.Never;             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.StringLiteral:                 return !!(node as StringLiteral | NoSubstitutionTemplateLiteral).text ? PredicateSemantics.Always : PredicateSemantics.Never;             case SyntaxKind.ConditionalExpression:                 return getSyntacticTruthySemantics((node as ConditionalExpression).whenTrue) | getSyntacticTruthySemantics((node as ConditionalExpression).whenFalse);             case SyntaxKind.Identifier:                 if (getResolvedSymbol(node as Identifier) === undefinedSymbol) {                     return PredicateSemantics.Never;                 }                 return PredicateSemantics.Sometimes;         } */
         /* TODO(PropertyAccessExpression): PredicateSemantics.Sometimes */ TODO
    }
    checkTruthinessExpression := func(node Expression, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         checkTruthinessOfType(checkExpression(node, checkMode), node)
    }
    checkForStatement := func(node ForStatement) {
        if /* TODO(PrefixUnaryExpression): !checkGrammarStatementInAmbientContext(node) */ TODO {
            if /* TODO(BinaryExpression): node.initializer && node.initializer.kind === SyntaxKind.VariableDeclarationList */ TODO {
                /* TODO(ExpressionStatement): checkGrammarVariableDeclarationList(node.initializer as VariableDeclarationList); */
            }
        }
        if /* TODO(PropertyAccessExpression): node.initializer */ TODO {
            if /* TODO(BinaryExpression): node.initializer.kind === SyntaxKind.VariableDeclarationList */ TODO {
                /* TODO(ExpressionStatement): checkVariableDeclarationList(node.initializer as VariableDeclarationList); */
            } else {
                /* TODO(ExpressionStatement): checkExpression(node.initializer); */
            }
        }
        if /* TODO(PropertyAccessExpression): node.condition */ TODO {
            /* TODO(CallExpression): checkTruthinessExpression(node.condition) */
        }
        if /* TODO(PropertyAccessExpression): node.incrementor */ TODO {
            /* TODO(CallExpression): checkExpression(node.incrementor) */
        }
        /* TODO(ExpressionStatement): checkSourceElement(node.statement); */
        if /* TODO(PropertyAccessExpression): node.locals */ TODO {
            /* TODO(ExpressionStatement): registerForUnusedIdentifiersCheck(node); */
        }
    }
    checkForOfStatement := func(node ForOfStatement) {
        /* TODO(ExpressionStatement): checkGrammarForInOrForOfStatement(node); */
        container := getContainingFunctionOrClassStaticBlock(node)
        if /* TODO(PropertyAccessExpression): node.awaitModifier */ TODO {
            if /* TODO(BinaryExpression): container && isClassStaticBlockDeclaration(container) */ TODO {
                /* TODO(ExpressionStatement): grammarErrorOnNode(node.awaitModifier, Diagnostics.for_await_loops_cannot_be_used_inside_a_class_static_block); */
            } else {
                functionFlags := getFunctionFlags(container)
                if /* TODO(BinaryExpression): (functionFlags & (FunctionFlags.Invalid | FunctionFlags.Async)) === FunctionFlags.Async && languageVersion < LanguageFeatureMinimumTarget.ForAwaitOf */ TODO {
                    /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.ForAwaitOfIncludes); */
                }
            }
        } else if /* TODO(BinaryExpression): compilerOptions.downlevelIteration && languageVersion < LanguageFeatureMinimumTarget.ForOf */ TODO {
            /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.ForOfIncludes); */
        }
        if /* TODO(BinaryExpression): node.initializer.kind === SyntaxKind.VariableDeclarationList */ TODO {
            /* TODO(ExpressionStatement): checkVariableDeclarationList(node.initializer as VariableDeclarationList); */
        } else {
            varExpr := /* TODO(PropertyAccessExpression): node.initializer */ TODO
            iteratedType := checkRightHandSideOfForOf(node)
            if /* TODO(BinaryExpression): varExpr.kind === SyntaxKind.ArrayLiteralExpression || varExpr.kind === SyntaxKind.ObjectLiteralExpression */ TODO {
                /* TODO(ExpressionStatement): checkDestructuringAssignment(varExpr, iteratedType || errorType); */
            } else {
                leftType := checkExpression(varExpr)
                /* TODO(ExpressionStatement): checkReferenceExpression(                     varExpr,                     Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access,                     Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access,                 ); */
                if iteratedType {
                    /* TODO(ExpressionStatement): checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr, node.expression); */
                }
            }
        }
        /* TODO(ExpressionStatement): checkSourceElement(node.statement); */
        if /* TODO(PropertyAccessExpression): node.locals */ TODO {
            /* TODO(ExpressionStatement): registerForUnusedIdentifiersCheck(node); */
        }
    }
    checkForInStatement := func(node ForInStatement) {
        /* TODO(ExpressionStatement): checkGrammarForInOrForOfStatement(node); */
        rightType := getNonNullableTypeIfNeeded(checkExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO))
        if /* TODO(BinaryExpression): node.initializer.kind === SyntaxKind.VariableDeclarationList */ TODO {
            variable := /* TODO(ElementAccessExpression): (node.initializer as VariableDeclarationList).declarations[0] */ TODO
            if /* TODO(BinaryExpression): variable && isBindingPattern(variable.name) */ TODO {
                /* TODO(ExpressionStatement): error(variable.name, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern); */
            }
            /* TODO(ExpressionStatement): checkVariableDeclarationList(node.initializer as VariableDeclarationList); */
        } else {
            varExpr := /* TODO(PropertyAccessExpression): node.initializer */ TODO
            leftType := checkExpression(varExpr)
            if /* TODO(BinaryExpression): varExpr.kind === SyntaxKind.ArrayLiteralExpression || varExpr.kind === SyntaxKind.ObjectLiteralExpression */ TODO {
                /* TODO(ExpressionStatement): error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern); */
            } else if /* TODO(PrefixUnaryExpression): !isTypeAssignableTo(getIndexTypeOrString(rightType), leftType) */ TODO {
                /* TODO(ExpressionStatement): error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any); */
            } else {
                /* TODO(ExpressionStatement): checkReferenceExpression(                     varExpr,                     Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access,                     Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access,                 ); */
            }
        }
        if /* TODO(BinaryExpression): rightType === neverType || !isTypeAssignableToKind(rightType, TypeFlags.NonPrimitive | TypeFlags.InstantiableNonPrimitive) */ TODO {
            /* TODO(ExpressionStatement): error(node.expression, Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0, typeToString(rightType)); */
        }
        /* TODO(ExpressionStatement): checkSourceElement(node.statement); */
        if /* TODO(PropertyAccessExpression): node.locals */ TODO {
            /* TODO(ExpressionStatement): registerForUnusedIdentifiersCheck(node); */
        }
    }
    checkRightHandSideOfForOf := func(statement ForOfStatement) Type {
        use := /* TODO(ConditionalExpression): statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf */ TODO
         checkIteratedTypeOrElementType(use, checkNonNullExpression(/* TODO(PropertyAccessExpression): statement.expression */ TODO), undefinedType, /* TODO(PropertyAccessExpression): statement.expression */ TODO)
    }
    checkIteratedTypeOrElementType := func(use IterationUse, inputType Type, sentType Type, errorNode Node) Type {
        if isTypeAny(inputType) {
             inputType
        }
         /* TODO(BinaryExpression): getIteratedTypeOrElementType(use, inputType, sentType, errorNode, /*checkAssignability* / true) || anyType */ TODO
    }
    getIteratedTypeOrElementType := func(use IterationUse, inputType Type, sentType Type, errorNode Node, checkAssignability bool) *Type {
        allowAsyncIterables := /* TODO(BinaryExpression): (use & IterationUse.AllowsAsyncIterablesFlag) !== 0 */ TODO
        if /* TODO(BinaryExpression): inputType === neverType */ TODO {
            if errorNode {
                /* TODO(ExpressionStatement): reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables); */
            }
             undefined
        }
        uplevelIteration := /* TODO(BinaryExpression): languageVersion >= ScriptTarget.ES2015 */ TODO
        downlevelIteration := /* TODO(BinaryExpression): !uplevelIteration && compilerOptions.downlevelIteration */ TODO
        possibleOutOfBounds := /* TODO(BinaryExpression): compilerOptions.noUncheckedIndexedAccess && !!(use & IterationUse.PossiblyOutOfBounds) */ TODO
        if /* TODO(BinaryExpression): uplevelIteration || downlevelIteration || allowAsyncIterables */ TODO {
            iterationTypes := getIterationTypesOfIterable(inputType, use, /* TODO(ConditionalExpression): uplevelIteration ? errorNode : undefined */ TODO)
            if checkAssignability {
                if iterationTypes {
                    diagnostic := /* TODO(ConditionalExpression): use & IterationUse.ForOfFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 :                         use & IterationUse.SpreadFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 :                         use & IterationUse.DestructuringFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 :                         use & IterationUse.YieldStarFlag ? Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 :                         undefined */ TODO
                    if diagnostic {
                        /* TODO(ExpressionStatement): checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic); */
                    }
                }
            }
            if /* TODO(BinaryExpression): iterationTypes || uplevelIteration */ TODO {
                 /* TODO(ConditionalExpression): possibleOutOfBounds ? includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType) : (iterationTypes && iterationTypes.yieldType) */ TODO
            }
        }
        arrayType := inputType
        hasStringConstituent := /* TODO(FalseKeyword): false */ TODO
        if /* TODO(BinaryExpression): use & IterationUse.AllowsStringInputFlag */ TODO {
            if /* TODO(BinaryExpression): arrayType.flags & TypeFlags.Union */ TODO {
                arrayTypes := /* TODO(PropertyAccessExpression): (inputType as UnionType).types */ TODO
                filteredTypes := filter(arrayTypes, /* TODO(ArrowFunction): t => !(t.flags & TypeFlags.StringLike) */ TODO)
                if /* TODO(BinaryExpression): filteredTypes !== arrayTypes */ TODO {
                    /* TODO(ExpressionStatement): arrayType = getUnionType(filteredTypes, UnionReduction.Subtype); */
                }
            } else if /* TODO(BinaryExpression): arrayType.flags & TypeFlags.StringLike */ TODO {
                /* TODO(ExpressionStatement): arrayType = neverType; */
            }
            /* TODO(ExpressionStatement): hasStringConstituent = arrayType !== inputType; */
            if hasStringConstituent {
                if /* TODO(BinaryExpression): arrayType.flags & TypeFlags.Never */ TODO {
                     /* TODO(ConditionalExpression): possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType */ TODO
                }
            }
        }
        if /* TODO(PrefixUnaryExpression): !isArrayLikeType(arrayType) */ TODO {
            if errorNode {
                allowsStrings := /* TODO(BinaryExpression): !!(use & IterationUse.AllowsStringInputFlag) && !hasStringConstituent */ TODO
                TODO_IDENTIFIER := getIterationDiagnosticDetails(allowsStrings, downlevelIteration)
                /* TODO(ExpressionStatement): errorAndMaybeSuggestAwait(                     errorNode,                     maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType),                     defaultDiagnostic,                     typeToString(arrayType),                 ); */
            }
             /* TODO(ConditionalExpression): hasStringConstituent ? possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType : undefined */ TODO
        }
        arrayElementType := getIndexTypeOfType(arrayType, numberType)
        if /* TODO(BinaryExpression): hasStringConstituent && arrayElementType */ TODO {
            if /* TODO(BinaryExpression): arrayElementType.flags & TypeFlags.StringLike && !compilerOptions.noUncheckedIndexedAccess */ TODO {
                 stringType
            }
             getUnionType(/* TODO(ConditionalExpression): possibleOutOfBounds ? [arrayElementType, stringType, undefinedType] : [arrayElementType, stringType] */ TODO, /* TODO(PropertyAccessExpression): UnionReduction.Subtype */ TODO)
        }
         /* TODO(ConditionalExpression): (use & IterationUse.PossiblyOutOfBounds) ? includeUndefinedInIndexSignature(arrayElementType) : arrayElementType */ TODO
        getIterationDiagnosticDetails := func(allowsStrings bool, downlevelIteration /* TODO(BooleanKeyword): boolean */ any) /* TODO(TupleType): [error: DiagnosticMessage, maybeMissingAwait: boolean] */ TODO {
            if downlevelIteration {
                 /* TODO(ConditionalExpression): allowsStrings                     ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true]                     : [Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true] */ TODO
            }
            yieldType := getIterationTypeOfIterable(use, /* TODO(PropertyAccessExpression): IterationTypeKind.Yield */ TODO, inputType, undefined)
            if yieldType {
                 /* TODO(ArrayLiteralExpression): [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, false] */ TODO
            }
            if isES2015OrLaterIterable(/* TODO(PropertyAccessExpression): inputType.symbol?.escapedName */ TODO) {
                 /* TODO(ArrayLiteralExpression): [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, true] */ TODO
            }
             /* TODO(ConditionalExpression): allowsStrings                 ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true]                 : [Diagnostics.Type_0_is_not_an_array_type, true] */ TODO
        }
    }
    isES2015OrLaterIterable := func(n __String) /* TODO(undefined): boolean */ TODO {
        /* TODO(SwitchStatement): switch (n) {             case "Float32Array":             case "Float64Array":             case "Int16Array":             case "Int32Array":             case "Int8Array":             case "NodeList":             case "Uint16Array":             case "Uint32Array":             case "Uint8Array":             case "Uint8ClampedArray":                 return true;         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    getIterationTypeOfIterable := func(use IterationUse, typeKind IterationTypeKind, inputType Type, errorNode Node) *Type {
        if isTypeAny(inputType) {
             undefined
        }
        iterationTypes := getIterationTypesOfIterable(inputType, use, errorNode)
         /* TODO(BinaryExpression): iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(typeKind)] */ TODO
    }
    createIterationTypes := func(yieldType Type /* = */ /* TODO(Identifier): neverType */, returnType Type /* = */ /* TODO(Identifier): neverType */, nextType Type /* = */ /* TODO(Identifier): unknownType */) IterationTypes {
        if /* TODO(BinaryExpression): yieldType.flags & TypeFlags.Intrinsic &&             returnType.flags & (TypeFlags.Any | TypeFlags.Never | TypeFlags.Unknown | TypeFlags.Void | TypeFlags.Undefined) &&             nextType.flags & (TypeFlags.Any | TypeFlags.Never | TypeFlags.Unknown | TypeFlags.Void | TypeFlags.Undefined) */ TODO {
            id := getTypeListId(/* TODO(ArrayLiteralExpression): [yieldType, returnType, nextType] */ TODO)
            iterationTypes := /* TODO(PropertyAccessExpression): iterationTypesCache.get */ TODO(id)
            if /* TODO(PrefixUnaryExpression): !iterationTypes */ TODO {
                /* TODO(ExpressionStatement): iterationTypes = { yieldType, returnType, nextType }; */
                /* TODO(ExpressionStatement): iterationTypesCache.set(id, iterationTypes); */
            }
             iterationTypes
        }
         /* TODO(ObjectLiteralExpression): { yieldType, returnType, nextType } */ TODO
    }
    combineIterationTypes := func(array []*IterationTypes) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
        var yieldTypes /* TODO(ArrayType): Type[] */ any
        var returnTypes /* TODO(ArrayType): Type[] */ any
        var nextTypes /* TODO(ArrayType): Type[] */ any
        /* TODO(ForOfStatement): for (const iterationTypes of array) {             if (iterationTypes === undefined || iterationTypes === noIterationTypes) {                 continue;             }             if (iterationTypes === anyIterationTypes) {                 return anyIterationTypes;             }             yieldTypes = append(yieldTypes, iterationTypes.yieldType);             returnTypes = append(returnTypes, iterationTypes.returnType);             nextTypes = append(nextTypes, iterationTypes.nextType);         } */
        if /* TODO(BinaryExpression): yieldTypes || returnTypes || nextTypes */ TODO {
             createIterationTypes(/* TODO(BinaryExpression): yieldTypes && getUnionType(yieldTypes) */ TODO, /* TODO(BinaryExpression): returnTypes && getUnionType(returnTypes) */ TODO, /* TODO(BinaryExpression): nextTypes && getIntersectionType(nextTypes) */ TODO)
        }
         noIterationTypes
    }
    getCachedIterationTypes := func(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes]) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
         /* TODO(ElementAccessExpression): (type as IterableOrIteratorType)[cacheKey] */ TODO
    }
    setCachedIterationTypes := func(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes], cachedTypes IterationTypes) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
         /* TODO(BinaryExpression): (type as IterableOrIteratorType)[cacheKey] = cachedTypes */ TODO
    }
    getIterationTypesOfIterable := func(type_ Type, use IterationUse, errorNode Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
        if isTypeAny(type_) {
             anyIterationTypes
        }
        if /* TODO(PrefixUnaryExpression): !(type.flags & TypeFlags.Union) */ TODO {
            var errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any = /* TODO(ConditionalExpression): errorNode ? { errors: undefined } : undefined */ TODO
            iterationTypes := getIterationTypesOfIterableWorker(type_, use, errorNode, errorOutputContainer)
            if /* TODO(BinaryExpression): iterationTypes === noIterationTypes */ TODO {
                if errorNode {
                    rootDiag := reportTypeNotIterableError(errorNode, type_, /* TODO(PrefixUnaryExpression): !!(use & IterationUse.AllowsAsyncIterablesFlag) */ TODO)
                    if /* TODO(PropertyAccessExpression): errorOutputContainer?.errors */ TODO {
                        /* TODO(ExpressionStatement): addRelatedInfo(rootDiag, ...errorOutputContainer.errors); */
                    }
                }
                 undefined
            } else if /* TODO(PropertyAccessExpression): errorOutputContainer?.errors?.length */ TODO {
                /* TODO(ForOfStatement): for (const diag of errorOutputContainer.errors) {                     diagnostics.add(diag);                 } */
            }
             iterationTypes
        }
        cacheKey := /* TODO(ConditionalExpression): use & IterationUse.AllowsAsyncIterablesFlag ? "iterationTypesOfAsyncIterable" : "iterationTypesOfIterable" */ TODO
        cachedTypes := getCachedIterationTypes(type_, cacheKey)
        if cachedTypes {
            /* TODO(ConditionalExpression): cachedTypes === noIterationTypes ? undefined : cachedTypes */
        }
        var allIterationTypes /* TODO(ArrayType): IterationTypes[] */ any
        /* TODO(ForOfStatement): for (const constituent of (type as UnionType).types) {             const errorOutputContainer: { errors: Diagnostic[] | undefined; } | undefined = errorNode ? { errors: undefined } : undefined;             const iterationTypes = getIterationTypesOfIterableWorker(constituent, use, errorNode, errorOutputContainer);             if (iterationTypes === noIterationTypes) {                 if (errorNode) {                     const rootDiag = reportTypeNotIterableError(errorNode, type, !!(use & IterationUse.AllowsAsyncIterablesFlag));                     if (errorOutputContainer?.errors) {                         addRelatedInfo(rootDiag, ...errorOutputContainer.errors);                     }                 }                 setCachedIterationTypes(type, cacheKey, noIterationTypes);                 return undefined;             }             else if (errorOutputContainer?.errors?.length) {                 for (const diag of errorOutputContainer.errors) {                     diagnostics.add(diag);                 }             }              allIterationTypes = append(allIterationTypes, iterationTypes);         } */
        iterationTypes := /* TODO(ConditionalExpression): allIterationTypes ? combineIterationTypes(allIterationTypes) : noIterationTypes */ TODO
        /* TODO(ExpressionStatement): setCachedIterationTypes(type, cacheKey, iterationTypes); */
         /* TODO(ConditionalExpression): iterationTypes === noIterationTypes ? undefined : iterationTypes */ TODO
    }
    getAsyncFromSyncIterationTypes := func(iterationTypes IterationTypes, errorNode Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
        if /* TODO(BinaryExpression): iterationTypes === noIterationTypes */ TODO {
            /* TODO(Identifier): noIterationTypes */
        }
        if /* TODO(BinaryExpression): iterationTypes === anyIterationTypes */ TODO {
            /* TODO(Identifier): anyIterationTypes */
        }
        TODO_IDENTIFIER := iterationTypes
        if errorNode {
            /* TODO(ExpressionStatement): getGlobalAwaitedSymbol(/*reportErrors* / true); */
        }
         createIterationTypes(/* TODO(BinaryExpression): getAwaitedType(yieldType, errorNode) || anyType */ TODO, /* TODO(BinaryExpression): getAwaitedType(returnType, errorNode) || anyType */ TODO, nextType)
    }
    getIterationTypesOfIterableWorker := func(type_ Type, use IterationUse, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
        if isTypeAny(type_) {
             anyIterationTypes
        }
        noCache := /* TODO(FalseKeyword): false */ TODO
        if /* TODO(BinaryExpression): use & IterationUse.AllowsAsyncIterablesFlag */ TODO {
            iterationTypes := /* TODO(BinaryExpression): getIterationTypesOfIterableCached(type, asyncIterationTypesResolver) ||                 getIterationTypesOfIterableFast(type, asyncIterationTypesResolver) */ TODO
            if iterationTypes {
                if /* TODO(BinaryExpression): iterationTypes === noIterationTypes && errorNode */ TODO {
                    /* TODO(ExpressionStatement): noCache = true; */
                } else {
                     /* TODO(ConditionalExpression): use & IterationUse.ForOfFlag ?                         getAsyncFromSyncIterationTypes(iterationTypes, errorNode) :                         iterationTypes */ TODO
                }
            }
        }
        if /* TODO(BinaryExpression): use & IterationUse.AllowsSyncIterablesFlag */ TODO {
            iterationTypes := /* TODO(BinaryExpression): getIterationTypesOfIterableCached(type, syncIterationTypesResolver) ||                 getIterationTypesOfIterableFast(type, syncIterationTypesResolver) */ TODO
            if iterationTypes {
                if /* TODO(BinaryExpression): iterationTypes === noIterationTypes && errorNode */ TODO {
                    /* TODO(ExpressionStatement): noCache = true; */
                } else {
                    if /* TODO(BinaryExpression): use & IterationUse.AllowsAsyncIterablesFlag */ TODO {
                        if /* TODO(BinaryExpression): iterationTypes !== noIterationTypes */ TODO {
                            /* TODO(ExpressionStatement): iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode); */
                             /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes) */ TODO
                        }
                    } else {
                         iterationTypes
                    }
                }
            }
        }
        if /* TODO(BinaryExpression): use & IterationUse.AllowsAsyncIterablesFlag */ TODO {
            iterationTypes := getIterationTypesOfIterableSlow(type_, asyncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
            if /* TODO(BinaryExpression): iterationTypes !== noIterationTypes */ TODO {
                 iterationTypes
            }
        }
        if /* TODO(BinaryExpression): use & IterationUse.AllowsSyncIterablesFlag */ TODO {
            iterationTypes := getIterationTypesOfIterableSlow(type_, syncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
            if /* TODO(BinaryExpression): iterationTypes !== noIterationTypes */ TODO {
                if /* TODO(BinaryExpression): use & IterationUse.AllowsAsyncIterablesFlag */ TODO {
                    /* TODO(ExpressionStatement): iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode); */
                     /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes) */ TODO
                } else {
                     iterationTypes
                }
            }
        }
         noIterationTypes
    }
    getIterationTypesOfIterableCached := func(type_ Type, resolver IterationTypesResolver) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
         getCachedIterationTypes(type_, /* TODO(PropertyAccessExpression): resolver.iterableCacheKey */ TODO)
    }
    getIterationTypesOfIterableFast := func(type_ Type, resolver IterationTypesResolver) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
        if /* TODO(BinaryExpression): isReferenceToType(type, resolver.getGlobalIterableType(/*reportErrors* / false)) ||             isReferenceToType(type, resolver.getGlobalIteratorObjectType(/*reportErrors* / false)) ||             isReferenceToType(type, resolver.getGlobalIterableIteratorType(/*reportErrors* / false)) ||             isReferenceToType(type, resolver.getGlobalGeneratorType(/*reportErrors* / false)) */ TODO {
            TODO_IDENTIFIER := getTypeArguments(type_ /* as */ /* TODO(TypeReference): GenericType */)
             setCachedIterationTypes(type_, /* TODO(PropertyAccessExpression): resolver.iterableCacheKey */ TODO, createIterationTypes(/* TODO(BinaryExpression): resolver.resolveIterationType(yieldType, /*errorNode* / undefined) || yieldType */ TODO, /* TODO(BinaryExpression): resolver.resolveIterationType(returnType, /*errorNode* / undefined) || returnType */ TODO, nextType))
        }
        if isReferenceToSomeType(type_, /* TODO(PropertyAccessExpression): resolver.getGlobalBuiltinIteratorTypes */ TODO()) {
            TODO_IDENTIFIER := getTypeArguments(type_ /* as */ /* TODO(TypeReference): GenericType */)
            returnType := getBuiltinIteratorReturnType()
            nextType := unknownType
             setCachedIterationTypes(type_, /* TODO(PropertyAccessExpression): resolver.iterableCacheKey */ TODO, createIterationTypes(/* TODO(BinaryExpression): resolver.resolveIterationType(yieldType, /*errorNode* / undefined) || yieldType */ TODO, /* TODO(BinaryExpression): resolver.resolveIterationType(returnType, /*errorNode* / undefined) || returnType */ TODO, nextType))
        }
    }
    getPropertyNameForKnownSymbolName := func(symbolName string) __String {
        ctorType := getGlobalESSymbolConstructorSymbol(/* TODO(FalseKeyword): false */ TODO)
        uniqueType := /* TODO(BinaryExpression): ctorType && getTypeOfPropertyOfType(getTypeOfSymbol(ctorType), escapeLeadingUnderscores(symbolName)) */ TODO
         /* TODO(ConditionalExpression): uniqueType && isTypeUsableAsPropertyName(uniqueType) ? getPropertyNameFromType(uniqueType) : `__@${symbolName}` as __String */ TODO
    }
    getIterationTypesOfIterableSlow := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
        method := getPropertyOfType(type_, getPropertyNameForKnownSymbolName(/* TODO(PropertyAccessExpression): resolver.iteratorSymbolName */ TODO))
        methodType := /* TODO(ConditionalExpression): method && !(method.flags & SymbolFlags.Optional) ? getTypeOfSymbol(method) : undefined */ TODO
        if isTypeAny(methodType) {
             /* TODO(ConditionalExpression): noCache ? anyIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, anyIterationTypes) */ TODO
        }
        signatures := /* TODO(ConditionalExpression): methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : undefined */ TODO
        if /* TODO(PrefixUnaryExpression): !some(signatures) */ TODO {
             /* TODO(ConditionalExpression): noCache ? noIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, noIterationTypes) */ TODO
        }
        iteratorType := getIntersectionType(map_(signatures, getReturnTypeOfSignature))
        iterationTypes := /* TODO(BinaryExpression): getIterationTypesOfIteratorWorker(iteratorType, resolver, errorNode, errorOutputContainer, noCache) ?? noIterationTypes */ TODO
         /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, iterationTypes) */ TODO
    }
    reportTypeNotIterableError := func(errorNode Node, type_ Type, allowAsyncIterables bool) Diagnostic {
        message := /* TODO(ConditionalExpression): allowAsyncIterables             ? Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator             : Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator */ TODO
        suggestAwait := /* TODO(BinaryExpression): !!getAwaitedTypeOfPromise(type)             // for (const x of AsyncIterable<...>)             || (                 !allowAsyncIterables &&                 isForOfStatement(errorNode.parent) &&                 errorNode.parent.expression === errorNode &&                 getGlobalAsyncIterableType(/*reportErrors* / false) !== emptyGenericType &&                 isTypeAssignableTo(type, createTypeFromGenericGlobalType(getGlobalAsyncIterableType(/*reportErrors* / false), [anyType, anyType, anyType]))             ) */ TODO
         errorAndMaybeSuggestAwait(errorNode, suggestAwait, message, typeToString(type_))
    }
    getIterationTypesOfIterator := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
         getIterationTypesOfIteratorWorker(type_, resolver, errorNode, errorOutputContainer, /* TODO(FalseKeyword): false */ TODO)
    }
    getIterationTypesOfIteratorWorker := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
        if isTypeAny(type_) {
             anyIterationTypes
        }
        iterationTypes := /* TODO(BinaryExpression): getIterationTypesOfIteratorCached(type, resolver) ||             getIterationTypesOfIteratorFast(type, resolver) */ TODO
        if /* TODO(BinaryExpression): iterationTypes === noIterationTypes && errorNode */ TODO {
            /* TODO(ExpressionStatement): iterationTypes = undefined; */
            /* TODO(ExpressionStatement): noCache = true; */
        }
        /* TODO(ExpressionStatement): iterationTypes ??= getIterationTypesOfIteratorSlow(type, resolver, errorNode, errorOutputContainer, noCache); */
         /* TODO(ConditionalExpression): iterationTypes === noIterationTypes ? undefined : iterationTypes */ TODO
    }
    getIterationTypesOfIteratorCached := func(type_ Type, resolver IterationTypesResolver) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
         getCachedIterationTypes(type_, /* TODO(PropertyAccessExpression): resolver.iteratorCacheKey */ TODO)
    }
    getIterationTypesOfIteratorFast := func(type_ Type, resolver IterationTypesResolver) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
        if /* TODO(BinaryExpression): isReferenceToType(type, resolver.getGlobalIterableIteratorType(/*reportErrors* / false)) ||             isReferenceToType(type, resolver.getGlobalIteratorType(/*reportErrors* / false)) ||             isReferenceToType(type, resolver.getGlobalIteratorObjectType(/*reportErrors* / false)) ||             isReferenceToType(type, resolver.getGlobalGeneratorType(/*reportErrors* / false)) */ TODO {
            TODO_IDENTIFIER := getTypeArguments(type_ /* as */ /* TODO(TypeReference): GenericType */)
             setCachedIterationTypes(type_, /* TODO(PropertyAccessExpression): resolver.iteratorCacheKey */ TODO, createIterationTypes(yieldType, returnType, nextType))
        }
        if isReferenceToSomeType(type_, /* TODO(PropertyAccessExpression): resolver.getGlobalBuiltinIteratorTypes */ TODO()) {
            TODO_IDENTIFIER := getTypeArguments(type_ /* as */ /* TODO(TypeReference): GenericType */)
            returnType := getBuiltinIteratorReturnType()
            nextType := unknownType
             setCachedIterationTypes(type_, /* TODO(PropertyAccessExpression): resolver.iteratorCacheKey */ TODO, createIterationTypes(yieldType, returnType, nextType))
        }
    }
    isIteratorResult := func(type_ Type, kind /* TODO(UnionType): IterationTypeKind.Yield | IterationTypeKind.Return */ any) /* TODO(undefined): boolean */ TODO {
        doneType := /* TODO(BinaryExpression): getTypeOfPropertyOfType(type, "done" as __String) || falseType */ TODO
         isTypeAssignableTo(/* TODO(ConditionalExpression): kind === IterationTypeKind.Yield ? falseType : trueType */ TODO, doneType)
    }
    isYieldIteratorResult := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         isIteratorResult(type_, /* TODO(PropertyAccessExpression): IterationTypeKind.Yield */ TODO)
    }
    isReturnIteratorResult := func(type_ Type) /* TODO(undefined): boolean */ TODO {
         isIteratorResult(type_, /* TODO(PropertyAccessExpression): IterationTypeKind.Return */ TODO)
    }
    getIterationTypesOfIteratorResult := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
        if isTypeAny(type_) {
             anyIterationTypes
        }
        cachedTypes := getCachedIterationTypes(type_, "iterationTypesOfIteratorResult")
        if cachedTypes {
             cachedTypes
        }
        if isReferenceToType(type_, getGlobalIteratorYieldResultType(/* TODO(FalseKeyword): false */ TODO)) {
            yieldType := /* TODO(ElementAccessExpression): getTypeArguments(type as GenericType)[0] */ TODO
             setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, undefined, undefined))
        }
        if isReferenceToType(type_, getGlobalIteratorReturnResultType(/* TODO(FalseKeyword): false */ TODO)) {
            returnType := /* TODO(ElementAccessExpression): getTypeArguments(type as GenericType)[0] */ TODO
             setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(undefined, returnType, undefined))
        }
        yieldIteratorResult := filterType(type_, isYieldIteratorResult)
        yieldType := /* TODO(ConditionalExpression): yieldIteratorResult !== neverType ? getTypeOfPropertyOfType(yieldIteratorResult, "value" as __String) : undefined */ TODO
        returnIteratorResult := filterType(type_, isReturnIteratorResult)
        returnType := /* TODO(ConditionalExpression): returnIteratorResult !== neverType ? getTypeOfPropertyOfType(returnIteratorResult, "value" as __String) : undefined */ TODO
        if /* TODO(BinaryExpression): !yieldType && !returnType */ TODO {
             setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", noIterationTypes)
        }
         setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, /* TODO(BinaryExpression): returnType || voidType */ TODO, undefined))
    }
    getIterationTypesOfMethod := func(type_ Type, resolver IterationTypesResolver, methodName /* TODO(UnionType): "next" | "return" | "throw" */ any, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) *IterationTypes {
        method := getPropertyOfType(type_, methodName /* as */ /* TODO(TypeReference): __String */)
        if /* TODO(BinaryExpression): !method && methodName !== "next" */ TODO {
             undefined
        }
        methodType := /* TODO(ConditionalExpression): method && !(methodName === "next" && (method.flags & SymbolFlags.Optional))             ? methodName === "next" ? getTypeOfSymbol(method) : getTypeWithFacts(getTypeOfSymbol(method), TypeFacts.NEUndefinedOrNull)             : undefined */ TODO
        if isTypeAny(methodType) {
             anyIterationTypes
        }
        methodSignatures := /* TODO(ConditionalExpression): methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : emptyArray */ TODO
        if /* TODO(BinaryExpression): methodSignatures.length === 0 */ TODO {
            if errorNode {
                diagnostic := /* TODO(ConditionalExpression): methodName === "next"                     ? resolver.mustHaveANextMethodDiagnostic                     : resolver.mustBeAMethodDiagnostic */ TODO
                if errorOutputContainer {
                    /* TODO(ExpressionStatement): errorOutputContainer.errors ??= []; */
                    /* TODO(ExpressionStatement): errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, diagnostic, methodName)); */
                } else {
                    /* TODO(ExpressionStatement): error(errorNode, diagnostic, methodName); */
                }
            }
             /* TODO(ConditionalExpression): methodName === "next" ? noIterationTypes : undefined */ TODO
        }
        if /* TODO(BinaryExpression): methodType?.symbol && methodSignatures.length === 1 */ TODO {
            globalGeneratorType := /* TODO(PropertyAccessExpression): resolver.getGlobalGeneratorType */ TODO(/* TODO(FalseKeyword): false */ TODO)
            globalIteratorType := /* TODO(PropertyAccessExpression): resolver.getGlobalIteratorType */ TODO(/* TODO(FalseKeyword): false */ TODO)
            isGeneratorMethod := /* TODO(BinaryExpression): globalGeneratorType.symbol?.members?.get(methodName as __String) === methodType.symbol */ TODO
            isIteratorMethod := /* TODO(BinaryExpression): !isGeneratorMethod && globalIteratorType.symbol?.members?.get(methodName as __String) === methodType.symbol */ TODO
            if /* TODO(BinaryExpression): isGeneratorMethod || isIteratorMethod */ TODO {
                globalType := /* TODO(ConditionalExpression): isGeneratorMethod ? globalGeneratorType : globalIteratorType */ TODO
                TODO_IDENTIFIER := methodType /* as */ /* TODO(TypeReference): AnonymousType */
                 createIterationTypes(getMappedType(/* TODO(ElementAccessExpression): globalType.typeParameters![0] */ TODO, /* TODO(NonNullExpression): mapper! */ TODO), getMappedType(/* TODO(ElementAccessExpression): globalType.typeParameters![1] */ TODO, /* TODO(NonNullExpression): mapper! */ TODO), /* TODO(ConditionalExpression): methodName === "next" ? getMappedType(globalType.typeParameters![2], mapper!) : undefined */ TODO)
            }
        }
        var methodParameterTypes /* TODO(ArrayType): Type[] */ any
        var methodReturnTypes /* TODO(ArrayType): Type[] */ any
        /* TODO(ForOfStatement): for (const signature of methodSignatures) {             if (methodName !== "throw" && some(signature.parameters)) {                 methodParameterTypes = append(methodParameterTypes, getTypeAtPosition(signature, 0));             }             methodReturnTypes = append(methodReturnTypes, getReturnTypeOfSignature(signature));         } */
        var returnTypes /* TODO(ArrayType): Type[] */ any
        var nextType *Type
        if /* TODO(BinaryExpression): methodName !== "throw" */ TODO {
            methodParameterType := /* TODO(ConditionalExpression): methodParameterTypes ? getUnionType(methodParameterTypes) : unknownType */ TODO
            if /* TODO(BinaryExpression): methodName === "next" */ TODO {
                /* TODO(ExpressionStatement): nextType = methodParameterType; */
            } else if /* TODO(BinaryExpression): methodName === "return" */ TODO {
                resolvedMethodParameterType := /* TODO(BinaryExpression): resolver.resolveIterationType(methodParameterType, errorNode) || anyType */ TODO
                /* TODO(ExpressionStatement): returnTypes = append(returnTypes, resolvedMethodParameterType); */
            }
        }
        var yieldType Type
        methodReturnType := /* TODO(ConditionalExpression): methodReturnTypes ? getIntersectionType(methodReturnTypes) : neverType */ TODO
        resolvedMethodReturnType := /* TODO(BinaryExpression): resolver.resolveIterationType(methodReturnType, errorNode) || anyType */ TODO
        iterationTypes := getIterationTypesOfIteratorResult(resolvedMethodReturnType)
        if /* TODO(BinaryExpression): iterationTypes === noIterationTypes */ TODO {
            if errorNode {
                if errorOutputContainer {
                    /* TODO(ExpressionStatement): errorOutputContainer.errors ??= []; */
                    /* TODO(ExpressionStatement): errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, resolver.mustHaveAValueDiagnostic, methodName)); */
                } else {
                    /* TODO(ExpressionStatement): error(errorNode, resolver.mustHaveAValueDiagnostic, methodName); */
                }
            }
            /* TODO(ExpressionStatement): yieldType = anyType; */
            /* TODO(ExpressionStatement): returnTypes = append(returnTypes, anyType); */
        } else {
            /* TODO(ExpressionStatement): yieldType = iterationTypes.yieldType; */
            /* TODO(ExpressionStatement): returnTypes = append(returnTypes, iterationTypes.returnType); */
        }
         createIterationTypes(yieldType, getUnionType(returnTypes), nextType)
    }
    getIterationTypesOfIteratorSlow := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
        iterationTypes := combineIterationTypes(/* TODO(ArrayLiteralExpression): [             getIterationTypesOfMethod(type, resolver, "next", errorNode, errorOutputContainer),             getIterationTypesOfMethod(type, resolver, "return", errorNode, errorOutputContainer),             getIterationTypesOfMethod(type, resolver, "throw", errorNode, errorOutputContainer),         ] */ TODO)
         /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iteratorCacheKey, iterationTypes) */ TODO
    }
    getIterationTypeOfGeneratorFunctionReturnType := func(kind IterationTypeKind, returnType Type, isAsyncGenerator bool) *Type {
        if isTypeAny(returnType) {
             undefined
        }
        iterationTypes := getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsyncGenerator)
         /* TODO(BinaryExpression): iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(kind)] */ TODO
    }
    getIterationTypesOfGeneratorFunctionReturnType := func(type_ Type, isAsyncGenerator bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
        if isTypeAny(type_) {
             anyIterationTypes
        }
        use := /* TODO(ConditionalExpression): isAsyncGenerator ? IterationUse.AsyncGeneratorReturnType : IterationUse.GeneratorReturnType */ TODO
        resolver := /* TODO(ConditionalExpression): isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver */ TODO
         /* TODO(BinaryExpression): getIterationTypesOfIterable(type, use, /*errorNode* / undefined) ||             getIterationTypesOfIterator(type, resolver, /*errorNode* / undefined, /*errorOutputContainer* / undefined) */ TODO
    }
    checkBreakOrContinueStatement := func(node BreakOrContinueStatement) {
        if /* TODO(PrefixUnaryExpression): !checkGrammarStatementInAmbientContext(node) */ TODO {
            /* TODO(CallExpression): checkGrammarBreakOrContinueStatement(node) */
        }
    }
    unwrapReturnType := func(returnType Type, functionFlags FunctionFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        isGenerator := /* TODO(PrefixUnaryExpression): !!(functionFlags & FunctionFlags.Generator) */ TODO
        isAsync := /* TODO(PrefixUnaryExpression): !!(functionFlags & FunctionFlags.Async) */ TODO
        if isGenerator {
            returnIterationType := getIterationTypeOfGeneratorFunctionReturnType(/* TODO(PropertyAccessExpression): IterationTypeKind.Return */ TODO, returnType, isAsync)
            if /* TODO(PrefixUnaryExpression): !returnIterationType */ TODO {
                 errorType
            }
             /* TODO(ConditionalExpression): isAsync ? getAwaitedTypeNoAlias(unwrapAwaitedType(returnIterationType)) : returnIterationType */ TODO
        }
         /* TODO(ConditionalExpression): isAsync ? getAwaitedTypeNoAlias(returnType) || errorType : returnType */ TODO
    }
    isUnwrappedReturnTypeUndefinedVoidOrAny := func(func_ SignatureDeclaration, returnType Type) bool {
        type_ := unwrapReturnType(returnType, getFunctionFlags(func_))
         /* TODO(PrefixUnaryExpression): !!(type && (maybeTypeOfKind(type, TypeFlags.Void) || type.flags & (TypeFlags.Any | TypeFlags.Undefined))) */ TODO
    }
    checkReturnStatement := func(node ReturnStatement) {
        if checkGrammarStatementInAmbientContext(node) {

        }
        container := getContainingFunctionOrClassStaticBlock(node)
        if /* TODO(BinaryExpression): container && isClassStaticBlockDeclaration(container) */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block); */

        }
        if /* TODO(PrefixUnaryExpression): !container */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_can_only_be_used_within_a_function_body); */

        }
        signature := getSignatureFromDeclaration(container)
        returnType := getReturnTypeOfSignature(signature)
        functionFlags := getFunctionFlags(container)
        if /* TODO(BinaryExpression): strictNullChecks || node.expression || returnType.flags & TypeFlags.Never */ TODO {
            exprType := /* TODO(ConditionalExpression): node.expression ? checkExpressionCached(node.expression) : undefinedType */ TODO
            if /* TODO(BinaryExpression): container.kind === SyntaxKind.SetAccessor */ TODO {
                if /* TODO(PropertyAccessExpression): node.expression */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.Setters_cannot_return_a_value); */
                }
            } else if /* TODO(BinaryExpression): container.kind === SyntaxKind.Constructor */ TODO {
                if /* TODO(BinaryExpression): node.expression && !checkTypeAssignableToAndOptionallyElaborate(exprType, returnType, node, node.expression) */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class); */
                }
            } else if getReturnTypeFromAnnotation(container) {
                unwrappedReturnType := /* TODO(BinaryExpression): unwrapReturnType(returnType, functionFlags) ?? returnType */ TODO
                unwrappedExprType := /* TODO(ConditionalExpression): functionFlags & FunctionFlags.Async                     ? checkAwaitedType(exprType, /*withAlias* / false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)                     : exprType */ TODO
                if unwrappedReturnType {
                    /* TODO(ExpressionStatement): checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, node, node.expression); */
                }
            }
        } else if /* TODO(BinaryExpression): container.kind !== SyntaxKind.Constructor && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeUndefinedVoidOrAny(container, returnType) */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.Not_all_code_paths_return_a_value); */
        }
    }
    checkWithStatement := func(node WithStatement) {
        if /* TODO(PrefixUnaryExpression): !checkGrammarStatementInAmbientContext(node) */ TODO {
            if /* TODO(BinaryExpression): node.flags & NodeFlags.AwaitContext */ TODO {
                /* TODO(ExpressionStatement): grammarErrorOnFirstToken(node, Diagnostics.with_statements_are_not_allowed_in_an_async_function_block); */
            }
        }
        /* TODO(ExpressionStatement): checkExpression(node.expression); */
        sourceFile := getSourceFileOfNode(node)
        if /* TODO(PrefixUnaryExpression): !hasParseDiagnostics(sourceFile) */ TODO {
            start := /* TODO(PropertyAccessExpression): getSpanOfTokenAtPosition(sourceFile, node.pos).start */ TODO
            end := /* TODO(PropertyAccessExpression): node.statement.pos */ TODO
            /* TODO(ExpressionStatement): grammarErrorAtPos(sourceFile, start, end - start, Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any); */
        }
    }
    checkSwitchStatement := func(node SwitchStatement) {
        /* TODO(ExpressionStatement): checkGrammarStatementInAmbientContext(node); */
        var firstDefaultClause CaseOrDefaultClause
        hasDuplicateDefaultClause := /* TODO(FalseKeyword): false */ TODO
        expressionType := checkExpression(/* TODO(PropertyAccessExpression): node.expression */ TODO)
        /* TODO(ExpressionStatement): forEach(node.caseBlock.clauses, clause => {             // Grammar check for duplicate default clauses, skip if we already report duplicate default clause             if (clause.kind === SyntaxKind.DefaultClause && !hasDuplicateDefaultClause) {                 if (firstDefaultClause === undefined) {                     firstDefaultClause = clause;                 }                 else {                     grammarErrorOnNode(clause, Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);                     hasDuplicateDefaultClause = true;                 }             }              if (clause.kind === SyntaxKind.CaseClause) {                 addLazyDiagnostic(createLazyCaseClauseDiagnostics(clause));             }             forEach(clause.statements, checkSourceElement);             if (compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(clause.fallthroughFlowNode)) {                 error(clause, Diagnostics.Fallthrough_case_in_switch);             }              function createLazyCaseClauseDiagnostics(clause: CaseClause) {                 return () => {                     // TypeScript 1.0 spec (April 2014): 5.9                     // In a 'switch' statement, each 'case' expression must be of a type that is comparable                     // to or from the type of the 'switch' expression.                     const caseType = checkExpression(clause.expression);                      if (!isTypeEqualityComparableTo(expressionType, caseType)) {                         // expressionType is not comparable to caseType, try the reversed check and report errors if it fails                         checkTypeComparableTo(caseType, expressionType, clause.expression, /*headMessage* / undefined);                     }                 };             }         }); */
        if /* TODO(PropertyAccessExpression): node.caseBlock.locals */ TODO {
            /* TODO(ExpressionStatement): registerForUnusedIdentifiersCheck(node.caseBlock); */
        }
    }
    checkLabeledStatement := func(node LabeledStatement) {
        if /* TODO(PrefixUnaryExpression): !checkGrammarStatementInAmbientContext(node) */ TODO {
            /* TODO(ExpressionStatement): findAncestor(node.parent, current => {                 if (isFunctionLike(current)) {                     return "quit";                 }                 if (current.kind === SyntaxKind.LabeledStatement && (current as LabeledStatement).label.escapedText === node.label.escapedText) {                     grammarErrorOnNode(node.label, Diagnostics.Duplicate_label_0, getTextOfNode(node.label));                     return true;                 }                 return false;             }); */
        }
        /* TODO(ExpressionStatement): checkSourceElement(node.statement); */
    }
    checkThrowStatement := func(node ThrowStatement) {
        if /* TODO(PrefixUnaryExpression): !checkGrammarStatementInAmbientContext(node) */ TODO {
            if /* TODO(BinaryExpression): isIdentifier(node.expression) && !node.expression.escapedText */ TODO {
                /* TODO(ExpressionStatement): grammarErrorAfterFirstToken(node, Diagnostics.Line_break_not_permitted_here); */
            }
        }
        if /* TODO(PropertyAccessExpression): node.expression */ TODO {
            /* TODO(ExpressionStatement): checkExpression(node.expression); */
        }
    }
    checkTryStatement := func(node TryStatement) {
        /* TODO(ExpressionStatement): checkGrammarStatementInAmbientContext(node); */
        /* TODO(ExpressionStatement): checkBlock(node.tryBlock); */
        catchClause := /* TODO(PropertyAccessExpression): node.catchClause */ TODO
        if catchClause {
            if /* TODO(PropertyAccessExpression): catchClause.variableDeclaration */ TODO {
                declaration := /* TODO(PropertyAccessExpression): catchClause.variableDeclaration */ TODO
                /* TODO(ExpressionStatement): checkVariableLikeDeclaration(declaration); */
                typeNode := getEffectiveTypeAnnotationNode(declaration)
                if typeNode {
                    type_ := getTypeFromTypeNode(typeNode)
                    if /* TODO(BinaryExpression): type && !(type.flags & TypeFlags.AnyOrUnknown) */ TODO {
                        /* TODO(ExpressionStatement): grammarErrorOnFirstToken(typeNode, Diagnostics.Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified); */
                    }
                } else if /* TODO(PropertyAccessExpression): declaration.initializer */ TODO {
                    /* TODO(ExpressionStatement): grammarErrorOnFirstToken(declaration.initializer, Diagnostics.Catch_clause_variable_cannot_have_an_initializer); */
                } else {
                    blockLocals := /* TODO(PropertyAccessExpression): catchClause.block.locals */ TODO
                    if blockLocals {
                        /* TODO(ExpressionStatement): forEachKey(catchClause.locals!, caughtName => {                             const blockLocal = blockLocals.get(caughtName);                             if (blockLocal?.valueDeclaration && (blockLocal.flags & SymbolFlags.BlockScopedVariable) !== 0) {                                 grammarErrorOnNode(blockLocal.valueDeclaration, Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, unescapeLeadingUnderscores(caughtName));                             }                         }); */
                    }
                }
            }
            /* TODO(ExpressionStatement): checkBlock(catchClause.block); */
        }
        if /* TODO(PropertyAccessExpression): node.finallyBlock */ TODO {
            /* TODO(ExpressionStatement): checkBlock(node.finallyBlock); */
        }
    }
    checkIndexConstraints := func(type_ Type, symbol Symbol, isStaticIndex bool) {
        indexInfos := getIndexInfosOfType(type_)
        if /* TODO(BinaryExpression): indexInfos.length === 0 */ TODO {

        }
        /* TODO(ForOfStatement): for (const prop of getPropertiesOfObjectType(type)) {             if (!(isStaticIndex && prop.flags & SymbolFlags.Prototype)) {                 checkIndexConstraintForProperty(type, prop, getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique, /*includeNonPublic* / true), getNonMissingTypeOfSymbol(prop));             }         } */
        typeDeclaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
        if /* TODO(BinaryExpression): typeDeclaration && isClassLike(typeDeclaration) */ TODO {
            /* TODO(ForOfStatement): for (const member of typeDeclaration.members) {                 // Only process instance properties with computed names here. Static properties cannot be in conflict with indexers,                 // and properties with literal names were already checked.                 if (!isStatic(member) && !hasBindableName(member)) {                     const symbol = getSymbolOfDeclaration(member);                     checkIndexConstraintForProperty(type, symbol, getTypeOfExpression((member as DynamicNamedDeclaration).name.expression), getNonMissingTypeOfSymbol(symbol));                 }             } */
        }
        if /* TODO(BinaryExpression): indexInfos.length > 1 */ TODO {
            /* TODO(ForOfStatement): for (const info of indexInfos) {                 checkIndexConstraintForIndexSignature(type, info);             } */
        }
    }
    checkIndexConstraintForProperty := func(type_ Type, prop Symbol, propNameType Type, propType Type) {
        declaration := /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO
        name := getNameOfDeclaration(declaration)
        if /* TODO(BinaryExpression): name && isPrivateIdentifier(name) */ TODO {

        }
        indexInfos := getApplicableIndexInfos(type_, propNameType)
        interfaceDeclaration := /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined */ TODO
        propDeclaration := /* TODO(ConditionalExpression): declaration && declaration.kind === SyntaxKind.BinaryExpression ||                 name && name.kind === SyntaxKind.ComputedPropertyName ? declaration : undefined */ TODO
        localPropDeclaration := /* TODO(ConditionalExpression): getParentOfSymbol(prop) === type.symbol ? declaration : undefined */ TODO
        /* TODO(ForOfStatement): for (const info of indexInfos) {             const localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined;             // We check only when (a) the property is declared in the containing type, or (b) the applicable index signature is declared             // in the containing type, or (c) the containing type is an interface and no base interface contains both the property and             // the index signature (i.e. property and index signature are declared in separate inherited interfaces).             const errorNode = localPropDeclaration || localIndexDeclaration ||                 (interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getPropertyOfObjectType(base, prop.escapedName) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined);             if (errorNode && !isTypeAssignableTo(propType, info.type)) {                 const diagnostic = createError(errorNode, Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3, symbolToString(prop), typeToString(propType), typeToString(info.keyType), typeToString(info.type));                 if (propDeclaration && errorNode !== propDeclaration) {                     addRelatedInfo(diagnostic, createDiagnosticForNode(propDeclaration, Diagnostics._0_is_declared_here, symbolToString(prop)));                 }                 diagnostics.add(diagnostic);             }         } */
    }
    checkIndexConstraintForIndexSignature := func(type_ Type, checkInfo IndexInfo) {
        declaration := /* TODO(PropertyAccessExpression): checkInfo.declaration */ TODO
        indexInfos := getApplicableIndexInfos(type_, /* TODO(PropertyAccessExpression): checkInfo.keyType */ TODO)
        interfaceDeclaration := /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined */ TODO
        localCheckDeclaration := /* TODO(ConditionalExpression): declaration && getParentOfSymbol(getSymbolOfDeclaration(declaration)) === type.symbol ? declaration : undefined */ TODO
        /* TODO(ForOfStatement): for (const info of indexInfos) {             if (info === checkInfo) continue;             const localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined;             // We check only when (a) the check index signature is declared in the containing type, or (b) the applicable index             // signature is declared in the containing type, or (c) the containing type is an interface and no base interface contains             // both index signatures (i.e. the index signatures are declared in separate inherited interfaces).             const errorNode = localCheckDeclaration || localIndexDeclaration ||                 (interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getIndexInfoOfType(base, checkInfo.keyType) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined);             if (errorNode && !isTypeAssignableTo(checkInfo.type, info.type)) {                 error(errorNode, Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3, typeToString(checkInfo.keyType), typeToString(checkInfo.type), typeToString(info.keyType), typeToString(info.type));             }         } */
    }
    checkTypeNameIsReserved := func(name Identifier, message DiagnosticMessage) {
        /* TODO(SwitchStatement): switch (name.escapedText) {             case "any":             case "unknown":             case "never":             case "number":             case "bigint":             case "boolean":             case "string":             case "symbol":             case "void":             case "object":             case "undefined":                 error(name, message, name.escapedText as string);         } */
    }
    checkClassNameCollisionWithObject := func(name Identifier) {
        if /* TODO(BinaryExpression): languageVersion >= ScriptTarget.ES5 && name.escapedText === "Object"             && host.getEmitModuleFormatOfFile(getSourceFileOfNode(name)) < ModuleKind.ES2015 */ TODO {
            /* TODO(ExpressionStatement): error(name, Diagnostics.Class_name_cannot_be_Object_when_targeting_ES5_with_module_0, ModuleKind[moduleKind]); */
        }
    }
    checkUnmatchedJSDocParameters := func(node SignatureDeclaration) {
        jsdocParameters := filter(getJSDocTags(node), isJSDocParameterTag)
        if /* TODO(PrefixUnaryExpression): !length(jsdocParameters) */ TODO {
        }
        isJs := isInJSFile(node)
        parameters := /* TODO(NewExpression): new Set<__String>() */ TODO
        excludedParameters := /* TODO(NewExpression): new Set<number>() */ TODO
        /* TODO(ExpressionStatement): forEach(node.parameters, ({ name }, index) => {             if (isIdentifier(name)) {                 parameters.add(name.escapedText);             }             if (isBindingPattern(name)) {                 excludedParameters.add(index);             }         }); */
        containsArguments := containsArgumentsReference(node)
        if containsArguments {
            lastJSDocParamIndex := /* TODO(BinaryExpression): jsdocParameters.length - 1 */ TODO
            lastJSDocParam := /* TODO(ElementAccessExpression): jsdocParameters[lastJSDocParamIndex] */ TODO
            if /* TODO(BinaryExpression): isJs && lastJSDocParam && isIdentifier(lastJSDocParam.name) && lastJSDocParam.typeExpression &&                 lastJSDocParam.typeExpression.type && !parameters.has(lastJSDocParam.name.escapedText) && !excludedParameters.has(lastJSDocParamIndex) && !isArrayType(getTypeFromTypeNode(lastJSDocParam.typeExpression.type)) */ TODO {
                /* TODO(ExpressionStatement): error(lastJSDocParam.name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type, idText(lastJSDocParam.name)); */
            }
        } else {
            /* TODO(ExpressionStatement): forEach(jsdocParameters, ({ name, isNameFirst }, index) => {                 if (excludedParameters.has(index) || isIdentifier(name) && parameters.has(name.escapedText)) {                     return;                 }                 if (isQualifiedName(name)) {                     if (isJs) {                         error(name, Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, entityNameToString(name), entityNameToString(name.left));                     }                 }                 else {                     if (!isNameFirst) {                         errorOrSuggestion(isJs, name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, idText(name));                     }                 }             }); */
        }
    }
    checkTypeParameters := func(typeParameterDeclarations /* TODO(TypeOperator): readonly TypeParameterDeclaration[] */ any) {
        seenDefault := /* TODO(FalseKeyword): false */ TODO
        if typeParameterDeclarations {
            /* TODO(ForStatement): for (let i = 0; i < typeParameterDeclarations.length; i++) {                 const node = typeParameterDeclarations[i];                 checkTypeParameter(node);                  addLazyDiagnostic(createCheckTypeParameterDiagnostic(node, i));             } */
        }
        createCheckTypeParameterDiagnostic := func(node TypeParameterDeclaration, i number) /* TODO(undefined): () => void */ TODO {
             /* TODO(ArrowFunction): () => {                 if (node.default) {                     seenDefault = true;                     checkTypeParametersNotReferenced(node.default, typeParameterDeclarations!, i);                 }                 else if (seenDefault) {                     error(node, Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters);                 }                 for (let j = 0; j < i; j++) {                     if (typeParameterDeclarations![j].symbol === node.symbol) {                         error(node.name, Diagnostics.Duplicate_identifier_0, declarationNameToString(node.name));                     }                 }             } */ TODO
        }
    }
    checkTypeParametersNotReferenced := func(root TypeNode, typeParameters []TypeParameterDeclaration, index number) {
        /* TODO(ExpressionStatement): visit(root); */
        visit := func(node Node) {
            if /* TODO(BinaryExpression): node.kind === SyntaxKind.TypeReference */ TODO {
                type_ := getTypeFromTypeReference(node /* as */ /* TODO(TypeReference): TypeReferenceNode */)
                if /* TODO(BinaryExpression): type.flags & TypeFlags.TypeParameter */ TODO {
                    /* TODO(ForStatement): for (let i = index; i < typeParameters.length; i++) {                         if (type.symbol === getSymbolOfDeclaration(typeParameters[i])) {                             error(node, Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters);                         }                     } */
                }
            }
            /* TODO(ExpressionStatement): forEachChild(node, visit); */
        }
    }
    checkTypeParameterListsIdentical := func(symbol Symbol) {
        if /* TODO(BinaryExpression): symbol.declarations && symbol.declarations.length === 1 */ TODO {

        }
        links := getSymbolLinks(symbol)
        if /* TODO(PrefixUnaryExpression): !links.typeParametersChecked */ TODO {
            /* TODO(ExpressionStatement): links.typeParametersChecked = true; */
            declarations := getClassOrInterfaceDeclarationsOfSymbol(symbol)
            if /* TODO(BinaryExpression): !declarations || declarations.length <= 1 */ TODO {

            }
            type_ := getDeclaredTypeOfSymbol(symbol) /* as */ /* TODO(TypeReference): InterfaceType */
            if /* TODO(PrefixUnaryExpression): !areTypeParametersIdentical(declarations, type.localTypeParameters!, getEffectiveTypeParameterDeclarations) */ TODO {
                name := symbolToString(symbol)
                /* TODO(ForOfStatement): for (const declaration of declarations) {                     error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, name);                 } */
            }
        }
    }
    areTypeParametersIdentical := func(declarations []T, targetParameters []TypeParameter, getTypeParameterDeclarations func(node T) []TypeParameterDeclaration) /* TODO(undefined): boolean */ TODO {
        maxTypeArgumentCount := length(targetParameters)
        minTypeArgumentCount := getMinTypeArgumentCount(targetParameters)
        /* TODO(ForOfStatement): for (const declaration of declarations) {             // If this declaration has too few or too many type parameters, we report an error             const sourceParameters = getTypeParameterDeclarations(declaration);             const numTypeParameters = sourceParameters.length;             if (numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount) {                 return false;             }              for (let i = 0; i < numTypeParameters; i++) {                 const source = sourceParameters[i];                 const target = targetParameters[i];                  // If the type parameter node does not have the same as the resolved type                 // parameter at this position, we report an error.                 if (source.name.escapedText !== target.symbol.escapedName) {                     return false;                 }                  // If the type parameter node does not have an identical constraint as the resolved                 // type parameter at this position, we report an error.                 const constraint = getEffectiveConstraintOfTypeParameter(source);                 const sourceConstraint = constraint && getTypeFromTypeNode(constraint);                 const targetConstraint = getConstraintOfTypeParameter(target);                 // relax check if later interface augmentation has no constraint, it's more broad and is OK to merge with                 // a more constrained interface (this could be generalized to a full hierarchy check, but that's maybe overkill)                 if (sourceConstraint && targetConstraint && !isTypeIdenticalTo(sourceConstraint, targetConstraint)) {                     return false;                 }                  // If the type parameter node has a default and it is not identical to the default                 // for the type parameter at this position, we report an error.                 const sourceDefault = source.default && getTypeFromTypeNode(source.default);                 const targetDefault = getDefaultFromTypeParameter(target);                 if (sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault)) {                     return false;                 }             }         } */
         /* TODO(TrueKeyword): true */ TODO
    }
    getFirstTransformableStaticClassElement := func(node ClassLikeDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ClassLikeDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").Decorator | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassStaticBlockDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierPropertyDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierMethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierGetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierSetAccessorDeclaration | (import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyDeclaration & { initializer: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; }) | undefined */ TODO {
        willTransformStaticElementsOfDecoratedClass := /* TODO(BinaryExpression): !legacyDecorators && languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators &&             classOrConstructorParameterIsDecorated(/*useLegacyDecorators* / false, node) */ TODO
        willTransformPrivateElementsOrClassStaticBlocks := /* TODO(BinaryExpression): languageVersion < LanguageFeatureMinimumTarget.PrivateNamesAndClassStaticBlocks ||             languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators */ TODO
        willTransformInitializers := /* TODO(PrefixUnaryExpression): !emitStandardClassFields */ TODO
        if /* TODO(BinaryExpression): willTransformStaticElementsOfDecoratedClass || willTransformPrivateElementsOrClassStaticBlocks */ TODO {
            /* TODO(ForOfStatement): for (const member of node.members) {                 if (willTransformStaticElementsOfDecoratedClass && classElementOrClassElementParameterIsDecorated(/*useLegacyDecorators* / false, member, node)) {                     return firstOrUndefined(getDecorators(node)) ?? node;                 }                 else if (willTransformPrivateElementsOrClassStaticBlocks) {                     if (isClassStaticBlockDeclaration(member)) {                         return member;                     }                     else if (isStatic(member)) {                         if (                             isPrivateIdentifierClassElementDeclaration(member) ||                             willTransformInitializers && isInitializedProperty(member)                         ) {                             return member;                         }                     }                 }             } */
        }
    }
    checkClassExpressionExternalHelpers := func(node ClassExpression) {
        if /* TODO(PropertyAccessExpression): node.name */ TODO {
        }
        parent := walkUpOuterExpressions(node)
        if /* TODO(PrefixUnaryExpression): !isNamedEvaluationSource(parent) */ TODO {
        }
        willTransformESDecorators := /* TODO(BinaryExpression): !legacyDecorators && languageVersion < LanguageFeatureMinimumTarget.ClassAndClassElementDecorators */ TODO
        var location Node
        if /* TODO(BinaryExpression): willTransformESDecorators && classOrConstructorParameterIsDecorated(/*useLegacyDecorators* / false, node) */ TODO {
            /* TODO(ExpressionStatement): location = firstOrUndefined(getDecorators(node)) ?? node; */
        } else {
            /* TODO(ExpressionStatement): location = getFirstTransformableStaticClassElement(node); */
        }
        if location {
            /* TODO(ExpressionStatement): checkExternalEmitHelpers(location, ExternalEmitHelpers.SetFunctionName); */
            if /* TODO(BinaryExpression): (isPropertyAssignment(parent) || isPropertyDeclaration(parent) || isBindingElement(parent)) && isComputedPropertyName(parent.name) */ TODO {
                /* TODO(ExpressionStatement): checkExternalEmitHelpers(location, ExternalEmitHelpers.PropKey); */
            }
        }
    }
    checkClassExpression := func(node ClassExpression) Type {
        /* TODO(ExpressionStatement): checkClassLikeDeclaration(node); */
        /* TODO(ExpressionStatement): checkNodeDeferred(node); */
        /* TODO(ExpressionStatement): checkClassExpressionExternalHelpers(node); */
         getTypeOfSymbol(getSymbolOfDeclaration(node))
    }
    checkClassExpressionDeferred := func(node ClassExpression) {
        /* TODO(ExpressionStatement): forEach(node.members, checkSourceElement); */
        /* TODO(ExpressionStatement): registerForUnusedIdentifiersCheck(node); */
    }
    checkClassDeclaration := func(node ClassDeclaration) {
        firstDecorator := find(/* TODO(PropertyAccessExpression): node.modifiers */ TODO, isDecorator)
        if /* TODO(BinaryExpression): legacyDecorators && firstDecorator && some(node.members, p => hasStaticModifier(p) && isPrivateIdentifierClassElementDeclaration(p)) */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnNode(firstDecorator, Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator); */
        }
        if /* TODO(BinaryExpression): !node.name && !hasSyntacticModifier(node, ModifierFlags.Default) */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnFirstToken(node, Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name); */
        }
        /* TODO(ExpressionStatement): checkClassLikeDeclaration(node); */
        /* TODO(ExpressionStatement): forEach(node.members, checkSourceElement); */
        /* TODO(ExpressionStatement): registerForUnusedIdentifiersCheck(node); */
    }
    checkClassLikeDeclaration := func(node ClassLikeDeclaration) {
        /* TODO(ExpressionStatement): checkGrammarClassLikeDeclaration(node); */
        /* TODO(ExpressionStatement): checkDecorators(node); */
        /* TODO(ExpressionStatement): checkCollisionsForDeclarationName(node, node.name); */
        /* TODO(ExpressionStatement): checkTypeParameters(getEffectiveTypeParameterDeclarations(node)); */
        /* TODO(ExpressionStatement): checkExportsOnMergedDeclarations(node); */
        symbol := getSymbolOfDeclaration(node)
        type_ := getDeclaredTypeOfSymbol(symbol) /* as */ /* TODO(TypeReference): InterfaceType */
        typeWithThis := getTypeWithThisArgument(type_)
        staticType := getTypeOfSymbol(symbol) /* as */ /* TODO(TypeReference): ObjectType */
        /* TODO(ExpressionStatement): checkTypeParameterListsIdentical(symbol); */
        /* TODO(ExpressionStatement): checkFunctionOrConstructorSymbol(symbol); */
        /* TODO(ExpressionStatement): checkClassForDuplicateDeclarations(node); */
        nodeInAmbientContext := /* TODO(PrefixUnaryExpression): !!(node.flags & NodeFlags.Ambient) */ TODO
        if /* TODO(PrefixUnaryExpression): !nodeInAmbientContext */ TODO {
            /* TODO(ExpressionStatement): checkClassForStaticPropertyNameConflicts(node); */
        }
        baseTypeNode := getEffectiveBaseTypeNode(node)
        if baseTypeNode {
            /* TODO(ExpressionStatement): forEach(baseTypeNode.typeArguments, checkSourceElement); */
            if /* TODO(BinaryExpression): languageVersion < LanguageFeatureMinimumTarget.Classes */ TODO {
                /* TODO(ExpressionStatement): checkExternalEmitHelpers(baseTypeNode.parent, ExternalEmitHelpers.Extends); */
            }
            extendsNode := getClassExtendsHeritageElement(node)
            if /* TODO(BinaryExpression): extendsNode && extendsNode !== baseTypeNode */ TODO {
                /* TODO(ExpressionStatement): checkExpression(extendsNode.expression); */
            }
            baseTypes := getBaseTypes(type_)
            if /* TODO(PropertyAccessExpression): baseTypes.length */ TODO {
                /* TODO(ExpressionStatement): addLazyDiagnostic(() => {                     const baseType = baseTypes[0];                     const baseConstructorType = getBaseConstructorTypeOfClass(type);                     const staticBaseType = getApparentType(baseConstructorType);                     checkBaseTypeAccessibility(staticBaseType, baseTypeNode);                     checkSourceElement(baseTypeNode.expression);                     if (some(baseTypeNode.typeArguments)) {                         forEach(baseTypeNode.typeArguments, checkSourceElement);                         for (const constructor of getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode)) {                             if (!checkTypeArgumentConstraints(baseTypeNode, constructor.typeParameters!)) {                                 break;                             }                         }                     }                     const baseWithThis = getTypeWithThisArgument(baseType, type.thisType);                     if (!checkTypeAssignableTo(typeWithThis, baseWithThis, /*errorNode* / undefined)) {                         issueMemberSpecificError(node, typeWithThis, baseWithThis, Diagnostics.Class_0_incorrectly_extends_base_class_1);                     }                     else {                         // Report static side error only when instance type is assignable                         checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);                     }                     if (baseConstructorType.flags & TypeFlags.TypeVariable) {                         if (!isMixinConstructorType(staticType)) {                             error(node.name || node, Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any);                         }                         else {                             const constructSignatures = getSignaturesOfType(baseConstructorType, SignatureKind.Construct);                             if (constructSignatures.some(signature => signature.flags & SignatureFlags.Abstract) && !hasSyntacticModifier(node, ModifierFlags.Abstract)) {                                 error(node.name || node, Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract);                             }                         }                     }                      if (!(staticBaseType.symbol && staticBaseType.symbol.flags & SymbolFlags.Class) && !(baseConstructorType.flags & TypeFlags.TypeVariable)) {                         // When the static base type is a "class-like" constructor function (but not actually a class), we verify                         // that all instantiated base constructor signatures return the same type.                         const constructors = getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode);                         if (forEach(constructors, sig => !isJSConstructor(sig.declaration) && !isTypeIdenticalTo(getReturnTypeOfSignature(sig), baseType))) {                             error(baseTypeNode.expression, Diagnostics.Base_constructors_must_all_have_the_same_return_type);                         }                     }                     checkKindsOfPropertyMemberOverrides(type, baseType);                 }); */
            }
        }
        /* TODO(ExpressionStatement): checkMembersForOverrideModifier(node, type, typeWithThis, staticType); */
        implementedTypeNodes := getEffectiveImplementsTypeNodes(node)
        if implementedTypeNodes {
            /* TODO(ForOfStatement): for (const typeRefNode of implementedTypeNodes) {                 if (!isEntityNameExpression(typeRefNode.expression) || isOptionalChain(typeRefNode.expression)) {                     error(typeRefNode.expression, Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments);                 }                 checkTypeReferenceNode(typeRefNode);                 addLazyDiagnostic(createImplementsDiagnostics(typeRefNode));             } */
        }
        /* TODO(ExpressionStatement): addLazyDiagnostic(() => {             checkIndexConstraints(type, symbol);             checkIndexConstraints(staticType, symbol, /*isStaticIndex* / true);             checkTypeForDuplicateIndexSignatures(node);             checkPropertyInitialization(node);         }); */
        createImplementsDiagnostics := func(typeRefNode ExpressionWithTypeArguments) /* TODO(undefined): () => void */ TODO {
             /* TODO(ArrowFunction): () => {                 const t = getReducedType(getTypeFromTypeNode(typeRefNode));                 if (!isErrorType(t)) {                     if (isValidBaseType(t)) {                         const genericDiag = t.symbol && t.symbol.flags & SymbolFlags.Class ?                             Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass :                             Diagnostics.Class_0_incorrectly_implements_interface_1;                         const baseWithThis = getTypeWithThisArgument(t, type.thisType);                         if (!checkTypeAssignableTo(typeWithThis, baseWithThis, /*errorNode* / undefined)) {                             issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag);                         }                     }                     else {                         error(typeRefNode, Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members);                     }                 }             } */ TODO
        }
    }
    checkMembersForOverrideModifier := func(node ClassLikeDeclaration, type_ InterfaceType, typeWithThis Type, staticType ObjectType) {
        baseTypeNode := getEffectiveBaseTypeNode(node)
        baseTypes := /* TODO(BinaryExpression): baseTypeNode && getBaseTypes(type) */ TODO
        baseWithThis := /* TODO(ConditionalExpression): baseTypes?.length ? getTypeWithThisArgument(first(baseTypes), type.thisType) : undefined */ TODO
        baseStaticType := getBaseConstructorTypeOfClass(type_)
        /* TODO(ForOfStatement): for (const member of node.members) {             if (hasAmbientModifier(member)) {                 continue;             }              if (isConstructorDeclaration(member)) {                 forEach(member.parameters, param => {                     if (isParameterPropertyDeclaration(param, member)) {                         checkExistingMemberForOverrideModifier(                             node,                             staticType,                             baseStaticType,                             baseWithThis,                             type,                             typeWithThis,                             param,                             /*memberIsParameterProperty* / true,                         );                     }                 });             }             checkExistingMemberForOverrideModifier(                 node,                 staticType,                 baseStaticType,                 baseWithThis,                 type,                 typeWithThis,                 member,                 /*memberIsParameterProperty* / false,             );         } */
    }
    checkExistingMemberForOverrideModifier := func(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis *Type, type_ InterfaceType, typeWithThis Type, member /* TODO(UnionType): ClassElement | ParameterPropertyDeclaration */ any, memberIsParameterProperty bool, reportErrors /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) MemberOverrideStatus {
        declaredProp := /* TODO(BinaryExpression): member.name                 && getSymbolAtLocation(member.name)             || getSymbolAtLocation(member) */ TODO
        if /* TODO(PrefixUnaryExpression): !declaredProp */ TODO {
             /* TODO(PropertyAccessExpression): MemberOverrideStatus.Ok */ TODO
        }
         checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, hasOverrideModifier(member), hasAbstractModifier(member), isStatic(member), memberIsParameterProperty, declaredProp, /* TODO(ConditionalExpression): reportErrors ? member : undefined */ TODO)
    }
    checkMemberForOverrideModifier := func(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis *Type, type_ InterfaceType, typeWithThis Type, memberHasOverrideModifier bool, memberHasAbstractModifier bool, memberIsStatic bool, memberIsParameterProperty bool, member Symbol, errorNode Node) MemberOverrideStatus {
        isJs := isInJSFile(node)
        nodeInAmbientContext := /* TODO(PrefixUnaryExpression): !!(node.flags & NodeFlags.Ambient) */ TODO
        if /* TODO(BinaryExpression): baseWithThis && (memberHasOverrideModifier || compilerOptions.noImplicitOverride) */ TODO {
            thisType := /* TODO(ConditionalExpression): memberIsStatic ? staticType : typeWithThis */ TODO
            baseType := /* TODO(ConditionalExpression): memberIsStatic ? baseStaticType : baseWithThis */ TODO
            prop := getPropertyOfType(thisType, /* TODO(PropertyAccessExpression): member.escapedName */ TODO)
            baseProp := getPropertyOfType(baseType, /* TODO(PropertyAccessExpression): member.escapedName */ TODO)
            baseClassName := typeToString(baseWithThis)
            if /* TODO(BinaryExpression): prop && !baseProp && memberHasOverrideModifier */ TODO {
                if errorNode {
                    suggestion := getSuggestedSymbolForNonexistentClassMember(symbolName(member), baseType)
                    /* TODO(ExpressionStatement): suggestion ?                         error(                             errorNode,                             isJs ?                                 Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1 :                                 Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1,                             baseClassName,                             symbolToString(suggestion),                         ) :                         error(                             errorNode,                             isJs ?                                 Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0 :                                 Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0,                             baseClassName,                         ); */
                }
                 /* TODO(PropertyAccessExpression): MemberOverrideStatus.HasInvalidOverride */ TODO
            } else if /* TODO(BinaryExpression): prop && baseProp?.declarations && compilerOptions.noImplicitOverride && !nodeInAmbientContext */ TODO {
                baseHasAbstract := some(/* TODO(PropertyAccessExpression): baseProp.declarations */ TODO, hasAbstractModifier)
                if memberHasOverrideModifier {
                     /* TODO(PropertyAccessExpression): MemberOverrideStatus.Ok */ TODO
                }
                if /* TODO(PrefixUnaryExpression): !baseHasAbstract */ TODO {
                    if errorNode {
                        diag := /* TODO(ConditionalExpression): memberIsParameterProperty ?                             isJs ?                                 Diagnostics.This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 :                                 Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0 :                             isJs ?                             Diagnostics.This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 :                             Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0 */ TODO
                        /* TODO(ExpressionStatement): error(errorNode, diag, baseClassName); */
                    }
                     /* TODO(PropertyAccessExpression): MemberOverrideStatus.NeedsOverride */ TODO
                } else if /* TODO(BinaryExpression): memberHasAbstractModifier && baseHasAbstract */ TODO {
                    if errorNode {
                        /* TODO(ExpressionStatement): error(errorNode, Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0, baseClassName); */
                    }
                     /* TODO(PropertyAccessExpression): MemberOverrideStatus.NeedsOverride */ TODO
                }
            }
        } else if memberHasOverrideModifier {
            if errorNode {
                className := typeToString(type_)
                /* TODO(ExpressionStatement): error(                     errorNode,                     isJs ?                         Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class :                         Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class,                     className,                 ); */
            }
             /* TODO(PropertyAccessExpression): MemberOverrideStatus.HasInvalidOverride */ TODO
        }
         /* TODO(PropertyAccessExpression): MemberOverrideStatus.Ok */ TODO
    }
    issueMemberSpecificError := func(node ClassLikeDeclaration, typeWithThis Type, baseWithThis Type, broadDiag DiagnosticMessage) {
        issuedMemberError := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForOfStatement): for (const member of node.members) {             if (isStatic(member)) {                 continue;             }             const declaredProp = member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member);             if (declaredProp) {                 const prop = getPropertyOfType(typeWithThis, declaredProp.escapedName);                 const baseProp = getPropertyOfType(baseWithThis, declaredProp.escapedName);                 if (prop && baseProp) {                     const rootChain = () =>                         chainDiagnosticMessages(                             /*details* / undefined,                             Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,                             symbolToString(declaredProp),                             typeToString(typeWithThis),                             typeToString(baseWithThis),                         );                     if (!checkTypeAssignableTo(getTypeOfSymbol(prop), getTypeOfSymbol(baseProp), member.name || member, /*headMessage* / undefined, rootChain)) {                         issuedMemberError = true;                     }                 }             }         } */
        if /* TODO(PrefixUnaryExpression): !issuedMemberError */ TODO {
            /* TODO(ExpressionStatement): checkTypeAssignableTo(typeWithThis, baseWithThis, node.name || node, broadDiag); */
        }
    }
    checkBaseTypeAccessibility := func(type_ Type, node ExpressionWithTypeArguments) {
        signatures := getSignaturesOfType(type_, /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO)
        if /* TODO(PropertyAccessExpression): signatures.length */ TODO {
            declaration := /* TODO(PropertyAccessExpression): signatures[0].declaration */ TODO
            if /* TODO(BinaryExpression): declaration && hasEffectiveModifier(declaration, ModifierFlags.Private) */ TODO {
                typeClassDeclaration := /* TODO(NonNullExpression): getClassLikeDeclarationOfSymbol(type.symbol)! */ TODO
                if /* TODO(PrefixUnaryExpression): !isNodeWithinClass(node, typeClassDeclaration) */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, getFullyQualifiedName(type.symbol)); */
                }
            }
        }
    }
    getMemberOverrideModifierStatus := func(node ClassLikeDeclaration, member ClassElement, memberSymbol Symbol) MemberOverrideStatus {
        if /* TODO(PrefixUnaryExpression): !member.name */ TODO {
             /* TODO(PropertyAccessExpression): MemberOverrideStatus.Ok */ TODO
        }
        classSymbol := getSymbolOfDeclaration(node)
        type_ := getDeclaredTypeOfSymbol(classSymbol) /* as */ /* TODO(TypeReference): InterfaceType */
        typeWithThis := getTypeWithThisArgument(type_)
        staticType := getTypeOfSymbol(classSymbol) /* as */ /* TODO(TypeReference): ObjectType */
        baseTypeNode := getEffectiveBaseTypeNode(node)
        baseTypes := /* TODO(BinaryExpression): baseTypeNode && getBaseTypes(type) */ TODO
        baseWithThis := /* TODO(ConditionalExpression): baseTypes?.length ? getTypeWithThisArgument(first(baseTypes), type.thisType) : undefined */ TODO
        baseStaticType := getBaseConstructorTypeOfClass(type_)
        memberHasOverrideModifier := /* TODO(ConditionalExpression): member.parent             ? hasOverrideModifier(member)             : hasSyntacticModifier(member, ModifierFlags.Override) */ TODO
         checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, memberHasOverrideModifier, hasAbstractModifier(member), isStatic(member), /* TODO(FalseKeyword): false */ TODO, memberSymbol)
    }
    getTargetSymbol := func(s Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
         /* TODO(ConditionalExpression): getCheckFlags(s) & CheckFlags.Instantiated ? (s as TransientSymbol).links.target! : s */ TODO
    }
    getClassOrInterfaceDeclarationsOfSymbol := func(symbol Symbol) /* TODO(undefined): (import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration)[] | undefined */ TODO {
         filter(/* TODO(PropertyAccessExpression): symbol.declarations */ TODO, /* TODO(ArrowFunction): (d: Declaration): d is ClassDeclaration | InterfaceDeclaration => d.kind === SyntaxKind.ClassDeclaration || d.kind === SyntaxKind.InterfaceDeclaration */ TODO)
    }
    checkKindsOfPropertyMemberOverrides := func(type_ InterfaceType, baseType BaseType) {
        baseProperties := getPropertiesOfType(baseType)
        type MemberInfo struct {
            missedProperties []string
            baseTypeName string
            typeName string
        }
        notImplementedInfo := /* TODO(NewExpression): new Map<ClassLikeDeclaration, MemberInfo>() */ TODO
        /* TODO(LabeledStatement): basePropertyCheck: for (const baseProperty of baseProperties) {             const base = getTargetSymbol(baseProperty);              if (base.flags & SymbolFlags.Prototype) {                 continue;             }             const baseSymbol = getPropertyOfObjectType(type, base.escapedName);             if (!baseSymbol) {                 continue;             }             const derived = getTargetSymbol(baseSymbol);             const baseDeclarationFlags = getDeclarationModifierFlagsFromSymbol(base);              Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration.");              // In order to resolve whether the inherited method was overridden in the base class or not,             // we compare the Symbols obtained. Since getTargetSymbol returns the symbol on the *uninstantiated*             // type declaration, derived and base resolve to the same symbol even in the case of generic classes.             if (derived === base) {                 // derived class inherits base without override/redeclaration                 const derivedClassDecl = getClassLikeDeclarationOfSymbol(type.symbol)!;                  // It is an error to inherit an abstract member without implementing it or being declared abstract.                 // If there is no declaration for the derived class (as in the case of class expressions),                 // then the class cannot be declared abstract.                 if (baseDeclarationFlags & ModifierFlags.Abstract && (!derivedClassDecl || !hasSyntacticModifier(derivedClassDecl, ModifierFlags.Abstract))) {                     // Searches other base types for a declaration that would satisfy the inherited abstract member.                     // (The class may have more than one base type via declaration merging with an interface with the                     // same name.)                     for (const otherBaseType of getBaseTypes(type)) {                         if (otherBaseType === baseType) continue;                         const baseSymbol = getPropertyOfObjectType(otherBaseType, base.escapedName);                         const derivedElsewhere = baseSymbol && getTargetSymbol(baseSymbol);                         if (derivedElsewhere && derivedElsewhere !== base) {                             continue basePropertyCheck;                         }                     }                     const baseTypeName = typeToString(baseType);                     const typeName = typeToString(type);                     const basePropertyName = symbolToString(baseProperty);                     const missedProperties = append(notImplementedInfo.get(derivedClassDecl)?.missedProperties, basePropertyName);                     notImplementedInfo.set(derivedClassDecl, { baseTypeName, typeName, missedProperties });                 }             }             else {                 // derived overrides base.                 const derivedDeclarationFlags = getDeclarationModifierFlagsFromSymbol(derived);                 if (baseDeclarationFlags & ModifierFlags.Private || derivedDeclarationFlags & ModifierFlags.Private) {                     // either base or derived property is private - not override, skip it                     continue;                 }                  let errorMessage: DiagnosticMessage;                 const basePropertyFlags = base.flags & SymbolFlags.PropertyOrAccessor;                 const derivedPropertyFlags = derived.flags & SymbolFlags.PropertyOrAccessor;                 if (basePropertyFlags && derivedPropertyFlags) {                     // property/accessor is overridden with property/accessor                     if (                         (getCheckFlags(base) & CheckFlags.Synthetic                             ? base.declarations?.some(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags))                             : base.declarations?.every(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags)))                         || getCheckFlags(base) & CheckFlags.Mapped                         || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration)                     ) {                         // when the base property is abstract or from an interface, base/derived flags don't need to match                         // for intersection properties, this must be true of *any* of the declarations, for others it must be true of *all*                         // same when the derived property is from an assignment                         continue;                     }                      const overriddenInstanceProperty = basePropertyFlags !== SymbolFlags.Property && derivedPropertyFlags === SymbolFlags.Property;                     const overriddenInstanceAccessor = basePropertyFlags === SymbolFlags.Property && derivedPropertyFlags !== SymbolFlags.Property;                     if (overriddenInstanceProperty || overriddenInstanceAccessor) {                         const errorMessage = overriddenInstanceProperty ?                             Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property :                             Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor;                         error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType), typeToString(type));                     }                     else if (useDefineForClassFields) {                         const uninitialized = derived.declarations?.find(d => d.kind === SyntaxKind.PropertyDeclaration && !(d as PropertyDeclaration).initializer);                         if (                             uninitialized                             && !(derived.flags & SymbolFlags.Transient)                             && !(baseDeclarationFlags & ModifierFlags.Abstract)                             && !(derivedDeclarationFlags & ModifierFlags.Abstract)                             && !derived.declarations?.some(d => !!(d.flags & NodeFlags.Ambient))                         ) {                             const constructor = findConstructorDeclaration(getClassLikeDeclarationOfSymbol(type.symbol)!);                             const propName = (uninitialized as PropertyDeclaration).name;                             if (                                 (uninitialized as PropertyDeclaration).exclamationToken                                 || !constructor                                 || !isIdentifier(propName)                                 || !strictNullChecks                                 || !isPropertyInitializedInConstructor(propName, type, constructor)                             ) {                                 const errorMessage = Diagnostics.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration;                                 error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType));                             }                         }                     }                      // correct case                     continue;                 }                 else if (isPrototypeProperty(base)) {                     if (isPrototypeProperty(derived) || derived.flags & SymbolFlags.Property) {                         // method is overridden with method or property -- correct case                         continue;                     }                     else {                         Debug.assert(!!(derived.flags & SymbolFlags.Accessor));                         errorMessage = Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;                     }                 }                 else if (base.flags & SymbolFlags.Accessor) {                     errorMessage = Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;                 }                 else {                     errorMessage = Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;                 }                  error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));             }         } */
        /* TODO(ForOfStatement): for (const [errorNode, memberInfo] of notImplementedInfo) {             if (length(memberInfo.missedProperties) === 1) {                 if (isClassExpression(errorNode)) {                     error(errorNode, Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1, first(memberInfo.missedProperties), memberInfo.baseTypeName);                 }                 else {                     error(errorNode, Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2, memberInfo.typeName, first(memberInfo.missedProperties), memberInfo.baseTypeName);                 }             }             else if (length(memberInfo.missedProperties) > 5) {                 const missedProperties = map(memberInfo.missedProperties.slice(0, 4), prop => `'${prop}'`).join(", ");                 const remainingMissedProperties = length(memberInfo.missedProperties) - 4;                 if (isClassExpression(errorNode)) {                     error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1_and_2_more, memberInfo.baseTypeName, missedProperties, remainingMissedProperties);                 }                 else {                     error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2_and_3_more, memberInfo.typeName, memberInfo.baseTypeName, missedProperties, remainingMissedProperties);                 }             }             else {                 const missedProperties = map(memberInfo.missedProperties, prop => `'${prop}'`).join(", ");                 if (isClassExpression(errorNode)) {                     error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1, memberInfo.baseTypeName, missedProperties);                 }                 else {                     error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2, memberInfo.typeName, memberInfo.baseTypeName, missedProperties);                 }             }         } */
    }
    isPropertyAbstractOrInterface := func(declaration Declaration, baseDeclarationFlags ModifierFlags) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): baseDeclarationFlags & ModifierFlags.Abstract && (!isPropertyDeclaration(declaration) || !declaration.initializer)             || isInterfaceDeclaration(declaration.parent) */ TODO
    }
    getNonInheritedProperties := func(type_ InterfaceType, baseTypes []BaseType, properties []Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
        if /* TODO(PrefixUnaryExpression): !length(baseTypes) */ TODO {
             properties
        }
        seen := /* TODO(NewExpression): new Map<__String, Symbol>() */ TODO
        /* TODO(ExpressionStatement): forEach(properties, p => {             seen.set(p.escapedName, p);         }); */
        /* TODO(ForOfStatement): for (const base of baseTypes) {             const properties = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));             for (const prop of properties) {                 const existing = seen.get(prop.escapedName);                 if (existing && prop.parent === existing.parent) {                     seen.delete(prop.escapedName);                 }             }         } */
         arrayFrom(/* TODO(PropertyAccessExpression): seen.values */ TODO())
    }
    checkInheritedPropertiesAreIdentical := func(type_ InterfaceType, typeNode Node) bool {
        baseTypes := getBaseTypes(type_)
        if /* TODO(BinaryExpression): baseTypes.length < 2 */ TODO {
             /* TODO(TrueKeyword): true */ TODO
        }
        type InheritanceInfoMap struct {
            prop Symbol
            containingType Type
        }
        seen := /* TODO(NewExpression): new Map<__String, InheritanceInfoMap>() */ TODO
        /* TODO(ExpressionStatement): forEach(resolveDeclaredMembers(type).declaredProperties, p => {             seen.set(p.escapedName, { prop: p, containingType: type });         }); */
        ok := /* TODO(TrueKeyword): true */ TODO
        /* TODO(ForOfStatement): for (const base of baseTypes) {             const properties = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));             for (const prop of properties) {                 const existing = seen.get(prop.escapedName);                 if (!existing) {                     seen.set(prop.escapedName, { prop, containingType: base });                 }                 else {                     const isInheritedProperty = existing.containingType !== type;                     if (isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)) {                         ok = false;                          const typeName1 = typeToString(existing.containingType);                         const typeName2 = typeToString(base);                          let errorInfo = chainDiagnosticMessages(/*details* / undefined, Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical, symbolToString(prop), typeName1, typeName2);                         errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type), typeName1, typeName2);                         diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(typeNode), typeNode, errorInfo));                     }                 }             }         } */
         ok
    }
    checkPropertyInitialization := func(node ClassLikeDeclaration) {
        if /* TODO(BinaryExpression): !strictNullChecks || !strictPropertyInitialization || node.flags & NodeFlags.Ambient */ TODO {

        }
        constructor := findConstructorDeclaration(node)
        /* TODO(ForOfStatement): for (const member of node.members) {             if (getEffectiveModifierFlags(member) & ModifierFlags.Ambient) {                 continue;             }             if (!isStatic(member) && isPropertyWithoutInitializer(member)) {                 const propName = (member as PropertyDeclaration).name;                 if (isIdentifier(propName) || isPrivateIdentifier(propName) || isComputedPropertyName(propName)) {                     const type = getTypeOfSymbol(getSymbolOfDeclaration(member));                     if (!(type.flags & TypeFlags.AnyOrUnknown || containsUndefinedType(type))) {                         if (!constructor || !isPropertyInitializedInConstructor(propName, type, constructor)) {                             error(member.name, Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor, declarationNameToString(propName));                         }                     }                 }             }         } */
    }
    isPropertyWithoutInitializer := func(node Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): node.kind === SyntaxKind.PropertyDeclaration &&             !hasAbstractModifier(node) &&             !(node as PropertyDeclaration).exclamationToken &&             !(node as PropertyDeclaration).initializer */ TODO
    }
    isPropertyInitializedInStaticBlocks := func(propName /* TODO(UnionType): Identifier | PrivateIdentifier */ any, propType Type, staticBlocks []ClassStaticBlockDeclaration, startPos number, endPos number) /* TODO(undefined): boolean */ TODO {
        /* TODO(ForOfStatement): for (const staticBlock of staticBlocks) {             // static block must be within the provided range as they are evaluated in document order (unlike constructors)             if (staticBlock.pos >= startPos && staticBlock.pos <= endPos) {                 const reference = factory.createPropertyAccessExpression(factory.createThis(), propName);                 setParent(reference.expression, reference);                 setParent(reference, staticBlock);                 reference.flowNode = staticBlock.returnFlowNode;                 const flowType = getFlowTypeOfReference(reference, propType, getOptionalType(propType));                 if (!containsUndefinedType(flowType)) {                     return true;                 }             }         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    isPropertyInitializedInConstructor := func(propName /* TODO(UnionType): Identifier | PrivateIdentifier | ComputedPropertyName */ any, propType Type, constructor ConstructorDeclaration) /* TODO(undefined): boolean */ TODO {
        reference := /* TODO(ConditionalExpression): isComputedPropertyName(propName)             ? factory.createElementAccessExpression(factory.createThis(), propName.expression)             : factory.createPropertyAccessExpression(factory.createThis(), propName) */ TODO
        /* TODO(ExpressionStatement): setParent(reference.expression, reference); */
        /* TODO(ExpressionStatement): setParent(reference, constructor); */
        /* TODO(ExpressionStatement): reference.flowNode = constructor.returnFlowNode; */
        flowType := getFlowTypeOfReference(reference, propType, getOptionalType(propType))
         /* TODO(PrefixUnaryExpression): !containsUndefinedType(flowType) */ TODO
    }
    checkInterfaceDeclaration := func(node InterfaceDeclaration) {
        if /* TODO(PrefixUnaryExpression): !checkGrammarModifiers(node) */ TODO {
            /* TODO(CallExpression): checkGrammarInterfaceDeclaration(node) */
        }
        /* TODO(ExpressionStatement): checkTypeParameters(node.typeParameters); */
        /* TODO(ExpressionStatement): addLazyDiagnostic(() => {             checkTypeNameIsReserved(node.name, Diagnostics.Interface_name_cannot_be_0);              checkExportsOnMergedDeclarations(node);             const symbol = getSymbolOfDeclaration(node);             checkTypeParameterListsIdentical(symbol);              // Only check this symbol once             const firstInterfaceDecl = getDeclarationOfKind<InterfaceDeclaration>(symbol, SyntaxKind.InterfaceDeclaration);             if (node === firstInterfaceDecl) {                 const type = getDeclaredTypeOfSymbol(symbol) as InterfaceType;                 const typeWithThis = getTypeWithThisArgument(type);                 // run subsequent checks only if first set succeeded                 if (checkInheritedPropertiesAreIdentical(type, node.name)) {                     for (const baseType of getBaseTypes(type)) {                         checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType, type.thisType), node.name, Diagnostics.Interface_0_incorrectly_extends_interface_1);                     }                     checkIndexConstraints(type, symbol);                 }             }             checkObjectTypeForDuplicateDeclarations(node);         }); */
        /* TODO(ExpressionStatement): forEach(getInterfaceBaseTypeNodes(node), heritageElement => {             if (!isEntityNameExpression(heritageElement.expression) || isOptionalChain(heritageElement.expression)) {                 error(heritageElement.expression, Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments);             }             checkTypeReferenceNode(heritageElement);         }); */
        /* TODO(ExpressionStatement): forEach(node.members, checkSourceElement); */
        /* TODO(ExpressionStatement): addLazyDiagnostic(() => {             checkTypeForDuplicateIndexSignatures(node);             registerForUnusedIdentifiersCheck(node);         }); */
    }
    checkTypeAliasDeclaration := func(node TypeAliasDeclaration) {
        /* TODO(ExpressionStatement): checkGrammarModifiers(node); */
        /* TODO(ExpressionStatement): checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0); */
        /* TODO(ExpressionStatement): checkExportsOnMergedDeclarations(node); */
        /* TODO(ExpressionStatement): checkTypeParameters(node.typeParameters); */
        if /* TODO(BinaryExpression): node.type.kind === SyntaxKind.IntrinsicKeyword */ TODO {
            typeParameterCount := length(/* TODO(PropertyAccessExpression): node.typeParameters */ TODO)
            valid := /* TODO(ConditionalExpression): typeParameterCount === 0 ? node.name.escapedText === "BuiltinIteratorReturn" :                 typeParameterCount === 1 && intrinsicTypeKinds.has(node.name.escapedText as string) */ TODO
            if /* TODO(PrefixUnaryExpression): !valid */ TODO {
                /* TODO(ExpressionStatement): error(node.type, Diagnostics.The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types); */
            }
        } else {
            /* TODO(ExpressionStatement): checkSourceElement(node.type); */
            /* TODO(ExpressionStatement): registerForUnusedIdentifiersCheck(node); */
        }
    }
    computeEnumMemberValues := func(node EnumDeclaration) {
        nodeLinks := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !(nodeLinks.flags & NodeCheckFlags.EnumValuesComputed) */ TODO {
            /* TODO(ExpressionStatement): nodeLinks.flags |= NodeCheckFlags.EnumValuesComputed; */
            var autoValue /* TODO(NumberKeyword): number */ any = 0
            var previous *EnumMember
            /* TODO(ForOfStatement): for (const member of node.members) {                 const result = computeEnumMemberValue(member, autoValue, previous);                 getNodeLinks(member).enumMemberValue = result;                 autoValue = typeof result.value === "number" ? result.value + 1 : undefined;                 previous = member;             } */
        }
    }
    computeEnumMemberValue := func(member EnumMember, autoValue /* TODO(NumberKeyword): number */ any, previous *EnumMember) EvaluatorResult {
        if isComputedNonLiteralName(/* TODO(PropertyAccessExpression): member.name */ TODO) {
            /* TODO(ExpressionStatement): error(member.name, Diagnostics.Computed_property_names_are_not_allowed_in_enums); */
        } else {
            text := getTextOfPropertyName(/* TODO(PropertyAccessExpression): member.name */ TODO)
            if /* TODO(BinaryExpression): isNumericLiteralName(text) && !isInfinityOrNaNString(text) */ TODO {
                /* TODO(ExpressionStatement): error(member.name, Diagnostics.An_enum_member_cannot_have_a_numeric_name); */
            }
        }
        if /* TODO(PropertyAccessExpression): member.initializer */ TODO {
             computeConstantEnumMemberValue(member)
        }
        if /* TODO(BinaryExpression): member.parent.flags & NodeFlags.Ambient && !isEnumConst(member.parent) */ TODO {
             evaluatorResult(undefined)
        }
        if /* TODO(BinaryExpression): autoValue === undefined */ TODO {
            /* TODO(ExpressionStatement): error(member.name, Diagnostics.Enum_member_must_have_initializer); */
             evaluatorResult(undefined)
        }
        if /* TODO(BinaryExpression): getIsolatedModules(compilerOptions) && previous?.initializer */ TODO {
            prevValue := getEnumMemberValue(previous)
            if /* TODO(PrefixUnaryExpression): !(typeof prevValue.value === "number" && !prevValue.resolvedOtherFiles) */ TODO {
                /* TODO(ExpressionStatement): error(                     member.name,                     Diagnostics.Enum_member_following_a_non_literal_numeric_member_must_have_an_initializer_when_isolatedModules_is_enabled,                 ); */
            }
        }
         evaluatorResult(autoValue)
    }
    computeConstantEnumMemberValue := func(member EnumMember) EvaluatorResult {
        isConstEnum := isEnumConst(/* TODO(PropertyAccessExpression): member.parent */ TODO)
        initializer := /* TODO(NonNullExpression): member.initializer! */ TODO
        result := evaluate(initializer, member)
        if /* TODO(BinaryExpression): result.value !== undefined */ TODO {
            if /* TODO(BinaryExpression): isConstEnum && typeof result.value === "number" && !isFinite(result.value) */ TODO {
                /* TODO(ExpressionStatement): error(                     initializer,                     isNaN(result.value) ?                         Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN :                         Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value,                 ); */
            } else if /* TODO(BinaryExpression): getIsolatedModules(compilerOptions) && typeof result.value === "string" && !result.isSyntacticallyString */ TODO {
                /* TODO(ExpressionStatement): error(                     initializer,                     Diagnostics._0_has_a_string_type_but_must_have_syntactically_recognizable_string_syntax_when_isolatedModules_is_enabled,                     `${idText(member.parent.name)}.${getTextOfPropertyName(member.name)}`,                 ); */
            }
        } else if isConstEnum {
            /* TODO(ExpressionStatement): error(initializer, Diagnostics.const_enum_member_initializers_must_be_constant_expressions); */
        } else if /* TODO(BinaryExpression): member.parent.flags & NodeFlags.Ambient */ TODO {
            /* TODO(ExpressionStatement): error(initializer, Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression); */
        } else {
            /* TODO(ExpressionStatement): checkTypeAssignableTo(checkExpression(initializer), numberType, initializer, Diagnostics.Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values); */
        }
         result
    }
    evaluateEntityNameExpression := func(expr EntityNameExpression, location Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ TODO {
        symbol := resolveEntityName(expr, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO, /* TODO(TrueKeyword): true */ TODO)
        if /* TODO(PrefixUnaryExpression): !symbol */ TODO {
            /* TODO(CallExpression): evaluatorResult(/*value* / undefined) */
        }
        if /* TODO(BinaryExpression): expr.kind === SyntaxKind.Identifier */ TODO {
            identifier := expr
            if /* TODO(BinaryExpression): isInfinityOrNaNString(identifier.escapedText) && (symbol === getGlobalSymbol(identifier.escapedText, SymbolFlags.Value, /*diagnostic* / undefined)) */ TODO {
                 evaluatorResult(/* TODO(PrefixUnaryExpression): +(identifier.escapedText) */ TODO, /* TODO(FalseKeyword): false */ TODO)
            }
        }
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.EnumMember */ TODO {
             /* TODO(ConditionalExpression): location ? evaluateEnumMember(expr, symbol, location) : getEnumMemberValue(symbol.valueDeclaration as EnumMember) */ TODO
        }
        if isConstantVariable(symbol) {
            declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
            if /* TODO(BinaryExpression): declaration && isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && (!location || declaration !== location && isBlockScopedNameDeclaredBeforeUse(declaration, location)) */ TODO {
                result := evaluate(/* TODO(PropertyAccessExpression): declaration.initializer */ TODO, declaration)
                if /* TODO(BinaryExpression): location && getSourceFileOfNode(location) !== getSourceFileOfNode(declaration) */ TODO {
                     evaluatorResult(/* TODO(PropertyAccessExpression): result.value */ TODO, /* TODO(FalseKeyword): false */ TODO, /* TODO(TrueKeyword): true */ TODO, /* TODO(TrueKeyword): true */ TODO)
                }
                 evaluatorResult(/* TODO(PropertyAccessExpression): result.value */ TODO, /* TODO(PropertyAccessExpression): result.isSyntacticallyString */ TODO, /* TODO(PropertyAccessExpression): result.resolvedOtherFiles */ TODO, /* TODO(TrueKeyword): true */ TODO)
            }
        }
         evaluatorResult(undefined)
    }
    evaluateElementAccessExpression := func(expr ElementAccessExpression, location Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ TODO {
        root := /* TODO(PropertyAccessExpression): expr.expression */ TODO
        if /* TODO(BinaryExpression): isEntityNameExpression(root) && isStringLiteralLike(expr.argumentExpression) */ TODO {
            rootSymbol := resolveEntityName(root, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO, /* TODO(TrueKeyword): true */ TODO)
            if /* TODO(BinaryExpression): rootSymbol && rootSymbol.flags & SymbolFlags.Enum */ TODO {
                name := escapeLeadingUnderscores(/* TODO(PropertyAccessExpression): expr.argumentExpression.text */ TODO)
                member := /* TODO(PropertyAccessExpression): rootSymbol.exports!.get */ TODO(name)
                if member {
                    /* TODO(ExpressionStatement): Debug.assert(getSourceFileOfNode(member.valueDeclaration) === getSourceFileOfNode(rootSymbol.valueDeclaration)); */
                     /* TODO(ConditionalExpression): location ? evaluateEnumMember(expr, member, location) : getEnumMemberValue(member.valueDeclaration as EnumMember) */ TODO
                }
            }
        }
         evaluatorResult(undefined)
    }
    evaluateEnumMember := func(expr Expression, symbol Symbol, location Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ TODO {
        declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
        if /* TODO(BinaryExpression): !declaration || declaration === location */ TODO {
            /* TODO(ExpressionStatement): error(expr, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(symbol)); */
             evaluatorResult(undefined)
        }
        if /* TODO(PrefixUnaryExpression): !isBlockScopedNameDeclaredBeforeUse(declaration, location) */ TODO {
            /* TODO(ExpressionStatement): error(expr, Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums); */
             evaluatorResult(0)
        }
        value := getEnumMemberValue(declaration /* as */ /* TODO(TypeReference): EnumMember */)
        if /* TODO(BinaryExpression): location.parent !== declaration.parent */ TODO {
             evaluatorResult(/* TODO(PropertyAccessExpression): value.value */ TODO, /* TODO(PropertyAccessExpression): value.isSyntacticallyString */ TODO, /* TODO(PropertyAccessExpression): value.resolvedOtherFiles */ TODO, /* TODO(TrueKeyword): true */ TODO)
        }
         value
    }
    checkEnumDeclaration := func(node EnumDeclaration) {
        /* TODO(ExpressionStatement): addLazyDiagnostic(() => checkEnumDeclarationWorker(node)); */
    }
    checkEnumDeclarationWorker := func(node EnumDeclaration) {
        /* TODO(ExpressionStatement): checkGrammarModifiers(node); */
        /* TODO(ExpressionStatement): checkCollisionsForDeclarationName(node, node.name); */
        /* TODO(ExpressionStatement): checkExportsOnMergedDeclarations(node); */
        /* TODO(ExpressionStatement): node.members.forEach(checkEnumMember); */
        /* TODO(ExpressionStatement): computeEnumMemberValues(node); */
        enumSymbol := getSymbolOfDeclaration(node)
        firstDeclaration := getDeclarationOfKind(enumSymbol, /* TODO(PropertyAccessExpression): node.kind */ TODO)
        if /* TODO(BinaryExpression): node === firstDeclaration */ TODO {
            if /* TODO(BinaryExpression): enumSymbol.declarations && enumSymbol.declarations.length > 1 */ TODO {
                enumIsConst := isEnumConst(node)
                /* TODO(ExpressionStatement): forEach(enumSymbol.declarations, decl => {                     if (isEnumDeclaration(decl) && isEnumConst(decl) !== enumIsConst) {                         error(getNameOfDeclaration(decl), Diagnostics.Enum_declarations_must_all_be_const_or_non_const);                     }                 }); */
            }
            seenEnumMissingInitialInitializer := /* TODO(FalseKeyword): false */ TODO
            /* TODO(ExpressionStatement): forEach(enumSymbol.declarations, declaration => {                 // return true if we hit a violation of the rule, false otherwise                 if (declaration.kind !== SyntaxKind.EnumDeclaration) {                     return false;                 }                  const enumDeclaration = declaration as EnumDeclaration;                 if (!enumDeclaration.members.length) {                     return false;                 }                  const firstEnumMember = enumDeclaration.members[0];                 if (!firstEnumMember.initializer) {                     if (seenEnumMissingInitialInitializer) {                         error(firstEnumMember.name, Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);                     }                     else {                         seenEnumMissingInitialInitializer = true;                     }                 }             }); */
        }
    }
    checkEnumMember := func(node EnumMember) {
        if isPrivateIdentifier(/* TODO(PropertyAccessExpression): node.name */ TODO) {
            /* TODO(ExpressionStatement): error(node, Diagnostics.An_enum_member_cannot_be_named_with_a_private_identifier); */
        }
        if /* TODO(PropertyAccessExpression): node.initializer */ TODO {
            /* TODO(ExpressionStatement): checkExpression(node.initializer); */
        }
    }
    getFirstNonAmbientClassOrFunctionDeclaration := func(symbol Symbol) Declaration {
        declarations := /* TODO(PropertyAccessExpression): symbol.declarations */ TODO
        if declarations {
            /* TODO(ForOfStatement): for (const declaration of declarations) {                 if (                     (declaration.kind === SyntaxKind.ClassDeclaration ||                         (declaration.kind === SyntaxKind.FunctionDeclaration && nodeIsPresent((declaration as FunctionLikeDeclaration).body))) &&                     !(declaration.flags & NodeFlags.Ambient)                 ) {                     return declaration;                 }             } */
        }
         undefined
    }
    inSameLexicalScope := func(node1 Node, node2 Node) /* TODO(undefined): boolean */ TODO {
        container1 := getEnclosingBlockScopeContainer(node1)
        container2 := getEnclosingBlockScopeContainer(node2)
        if isGlobalSourceFile(container1) {
             isGlobalSourceFile(container2)
        } else if isGlobalSourceFile(container2) {
             /* TODO(FalseKeyword): false */ TODO
        } else {
             /* TODO(BinaryExpression): container1 === container2 */ TODO
        }
    }
    checkModuleDeclaration := func(node ModuleDeclaration) {
        if /* TODO(PropertyAccessExpression): node.body */ TODO {
            /* TODO(ExpressionStatement): checkSourceElement(node.body); */
            if /* TODO(PrefixUnaryExpression): !isGlobalScopeAugmentation(node) */ TODO {
                /* TODO(ExpressionStatement): registerForUnusedIdentifiersCheck(node); */
            }
        }
        /* TODO(ExpressionStatement): addLazyDiagnostic(checkModuleDeclarationDiagnostics); */
        checkModuleDeclarationDiagnostics := func() {
            isGlobalAugmentation := isGlobalScopeAugmentation(node)
            inAmbientContext := /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO
            if /* TODO(BinaryExpression): isGlobalAugmentation && !inAmbientContext */ TODO {
                /* TODO(ExpressionStatement): error(node.name, Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context); */
            }
            var isAmbientExternalModule bool = isAmbientModule(node)
            contextErrorMessage := /* TODO(ConditionalExpression): isAmbientExternalModule                 ? Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file                 : Diagnostics.A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module */ TODO
            if checkGrammarModuleElementContext(node, contextErrorMessage) {

            }
            if /* TODO(PrefixUnaryExpression): !checkGrammarModifiers(node) */ TODO {
                if /* TODO(BinaryExpression): !inAmbientContext && node.name.kind === SyntaxKind.StringLiteral */ TODO {
                    /* TODO(ExpressionStatement): grammarErrorOnNode(node.name, Diagnostics.Only_ambient_modules_can_use_quoted_names); */
                }
            }
            if isIdentifier(/* TODO(PropertyAccessExpression): node.name */ TODO) {
                /* TODO(ExpressionStatement): checkCollisionsForDeclarationName(node, node.name); */
                if /* TODO(PrefixUnaryExpression): !(node.flags & (NodeFlags.Namespace | NodeFlags.GlobalAugmentation)) */ TODO {
                    sourceFile := getSourceFileOfNode(node)
                    pos := getNonModifierTokenPosOfNode(node)
                    span := getSpanOfTokenAtPosition(sourceFile, pos)
                    /* TODO(ExpressionStatement): suggestionDiagnostics.add(                         createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.A_namespace_declaration_should_not_be_declared_using_the_module_keyword_Please_use_the_namespace_keyword_instead),                     ); */
                }
            }
            /* TODO(ExpressionStatement): checkExportsOnMergedDeclarations(node); */
            symbol := getSymbolOfDeclaration(node)
            if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ValueModule                 && !inAmbientContext                 && isInstantiatedModule(node, shouldPreserveConstEnums(compilerOptions)) */ TODO {
                if /* TODO(BinaryExpression): getIsolatedModules(compilerOptions) && !getSourceFileOfNode(node).externalModuleIndicator */ TODO {
                    /* TODO(ExpressionStatement): error(node.name, Diagnostics.Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement, isolatedModulesLikeFlagName); */
                }
                if /* TODO(BinaryExpression): symbol.declarations?.length! > 1 */ TODO {
                    firstNonAmbientClassOrFunc := getFirstNonAmbientClassOrFunctionDeclaration(symbol)
                    if firstNonAmbientClassOrFunc {
                        if /* TODO(BinaryExpression): getSourceFileOfNode(node) !== getSourceFileOfNode(firstNonAmbientClassOrFunc) */ TODO {
                            /* TODO(ExpressionStatement): error(node.name, Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged); */
                        } else if /* TODO(BinaryExpression): node.pos < firstNonAmbientClassOrFunc.pos */ TODO {
                            /* TODO(ExpressionStatement): error(node.name, Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged); */
                        }
                    }
                    mergedClass := getDeclarationOfKind(symbol, /* TODO(PropertyAccessExpression): SyntaxKind.ClassDeclaration */ TODO)
                    if /* TODO(BinaryExpression): mergedClass &&                         inSameLexicalScope(node, mergedClass) */ TODO {
                        /* TODO(ExpressionStatement): getNodeLinks(node).flags |= NodeCheckFlags.LexicalModuleMergesWithClass; */
                    }
                }
                if /* TODO(BinaryExpression): compilerOptions.verbatimModuleSyntax &&                     node.parent.kind === SyntaxKind.SourceFile &&                     host.getEmitModuleFormatOfFile(node.parent) === ModuleKind.CommonJS */ TODO {
                    exportModifier := /* TODO(PropertyAccessExpression): node.modifiers?.find */ TODO(/* TODO(ArrowFunction): m => m.kind === SyntaxKind.ExportKeyword */ TODO)
                    if exportModifier {
                        /* TODO(ExpressionStatement): error(exportModifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled); */
                    }
                }
            }
            if isAmbientExternalModule {
                if isExternalModuleAugmentation(node) {
                    checkBody := /* TODO(BinaryExpression): isGlobalAugmentation || (getSymbolOfDeclaration(node).flags & SymbolFlags.Transient) */ TODO
                    if /* TODO(BinaryExpression): checkBody && node.body */ TODO {
                        /* TODO(ForOfStatement): for (const statement of node.body.statements) {                             checkModuleAugmentationElement(statement, isGlobalAugmentation);                         } */
                    }
                } else if isGlobalSourceFile(/* TODO(PropertyAccessExpression): node.parent */ TODO) {
                    if isGlobalAugmentation {
                        /* TODO(ExpressionStatement): error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations); */
                    } else if isExternalModuleNameRelative(getTextOfIdentifierOrLiteral(/* TODO(PropertyAccessExpression): node.name */ TODO)) {
                        /* TODO(ExpressionStatement): error(node.name, Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name); */
                    }
                } else {
                    if isGlobalAugmentation {
                        /* TODO(ExpressionStatement): error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations); */
                    } else {
                        /* TODO(ExpressionStatement): error(node.name, Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces); */
                    }
                }
            }
        }
    }
    checkModuleAugmentationElement := func(node Node, isGlobalAugmentation bool) {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.VariableStatement:                 // error each individual name in variable statement instead of marking the entire variable statement                 for (const decl of (node as VariableStatement).declarationList.declarations) {                     checkModuleAugmentationElement(decl, isGlobalAugmentation);                 }                 break;             case SyntaxKind.ExportAssignment:             case SyntaxKind.ExportDeclaration:                 grammarErrorOnFirstToken(node, Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations);                 break;             case SyntaxKind.ImportEqualsDeclaration:                 // import a = e.x; in module augmentation is ok, but not import a = require('fs)                 if (isInternalModuleImportEqualsDeclaration(node)) break;                 // falls through             case SyntaxKind.ImportDeclaration:                 grammarErrorOnFirstToken(node, Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module);                 break;             case SyntaxKind.BindingElement:             case SyntaxKind.VariableDeclaration:                 const name = (node as VariableDeclaration | BindingElement).name;                 if (isBindingPattern(name)) {                     for (const el of name.elements) {                         // mark individual names in binding pattern                         checkModuleAugmentationElement(el, isGlobalAugmentation);                     }                     break;                 }                 // falls through             case SyntaxKind.ClassDeclaration:             case SyntaxKind.EnumDeclaration:             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.InterfaceDeclaration:             case SyntaxKind.ModuleDeclaration:             case SyntaxKind.TypeAliasDeclaration:                 if (isGlobalAugmentation) {                     return;                 }                 break;         } */
    }
    getFirstNonModuleExportsIdentifier := func(node EntityNameOrEntityNameExpression) Identifier {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:                 return node;             case SyntaxKind.QualifiedName:                 do {                     node = node.left;                 }                 while (node.kind !== SyntaxKind.Identifier);                 return node;             case SyntaxKind.PropertyAccessExpression:                 do {                     if (isModuleExportsAccessExpression(node.expression) && !isPrivateIdentifier(node.name)) {                         return node.name;                     }                     node = node.expression;                 }                 while (node.kind !== SyntaxKind.Identifier);                 return node;         } */
    }
    checkExternalImportOrExportDeclaration := func(node /* TODO(UnionType): ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration */ any) bool {
        moduleName := getExternalModuleName(node)
        if /* TODO(BinaryExpression): !moduleName || nodeIsMissing(moduleName) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(PrefixUnaryExpression): !isStringLiteral(moduleName) */ TODO {
            /* TODO(ExpressionStatement): error(moduleName, Diagnostics.String_literal_expected); */
             /* TODO(FalseKeyword): false */ TODO
        }
        inAmbientExternalModule := /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.ModuleBlock && isAmbientModule(node.parent.parent) */ TODO
        if /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.SourceFile && !inAmbientExternalModule */ TODO {
            /* TODO(ExpressionStatement): error(                 moduleName,                 node.kind === SyntaxKind.ExportDeclaration ?                     Diagnostics.Export_declarations_are_not_permitted_in_a_namespace :                     Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module,             ); */
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): inAmbientExternalModule && isExternalModuleNameRelative(moduleName.text) */ TODO {
            if /* TODO(PrefixUnaryExpression): !isTopLevelInExternalModuleAugmentation(node) */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name); */
                 /* TODO(FalseKeyword): false */ TODO
            }
        }
        if /* TODO(BinaryExpression): !isImportEqualsDeclaration(node) && node.attributes */ TODO {
            diagnostic := /* TODO(ConditionalExpression): node.attributes.token === SyntaxKind.WithKeyword ? Diagnostics.Import_attribute_values_must_be_string_literal_expressions : Diagnostics.Import_assertion_values_must_be_string_literal_expressions */ TODO
            hasError := /* TODO(FalseKeyword): false */ TODO
            /* TODO(ForOfStatement): for (const attr of node.attributes.elements) {                 if (!isStringLiteral(attr.value)) {                     hasError = true;                     error(attr.value, diagnostic);                 }             } */
             /* TODO(PrefixUnaryExpression): !hasError */ TODO
        }
         /* TODO(TrueKeyword): true */ TODO
    }
    checkModuleExportName := func(name *ModuleExportName, allowStringLiteral /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) {
        if /* TODO(BinaryExpression): name === undefined || name.kind !== SyntaxKind.StringLiteral */ TODO {

        }
        if /* TODO(PrefixUnaryExpression): !allowStringLiteral */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnNode(name, Diagnostics.Identifier_expected); */
        } else if /* TODO(BinaryExpression): moduleKind === ModuleKind.ES2015 || moduleKind === ModuleKind.ES2020 */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnNode(name, Diagnostics.String_literal_import_and_export_names_are_not_supported_when_the_module_flag_is_set_to_es2015_or_es2020); */
        }
    }
    checkAliasSymbol := func(node AliasDeclarationNode) {
        symbol := getSymbolOfDeclaration(node)
        target := resolveAlias(symbol)
        if /* TODO(BinaryExpression): target !== unknownSymbol */ TODO {
            /* TODO(ExpressionStatement): symbol = getMergedSymbol(symbol.exportSymbol || symbol); */
            if /* TODO(BinaryExpression): isInJSFile(node) && !(target.flags & SymbolFlags.Value) && !isTypeOnlyImportOrExportDeclaration(node) */ TODO {
                errorNode := /* TODO(ConditionalExpression): isImportOrExportSpecifier(node) ? node.propertyName || node.name :                     isNamedDeclaration(node) ? node.name :                     node */ TODO
                /* TODO(ExpressionStatement): Debug.assert(node.kind !== SyntaxKind.NamespaceExport); */
                if /* TODO(BinaryExpression): node.kind === SyntaxKind.ExportSpecifier */ TODO {
                    diag := error(errorNode, /* TODO(PropertyAccessExpression): Diagnostics.Types_cannot_appear_in_export_declarations_in_JavaScript_files */ TODO)
                    alreadyExportedSymbol := /* TODO(PropertyAccessExpression): getSourceFileOfNode(node).symbol?.exports?.get */ TODO(moduleExportNameTextEscaped(/* TODO(BinaryExpression): node.propertyName || node.name */ TODO))
                    if /* TODO(BinaryExpression): alreadyExportedSymbol === target */ TODO {
                        exportingDeclaration := /* TODO(PropertyAccessExpression): alreadyExportedSymbol.declarations?.find */ TODO(isJSDocNode)
                        if exportingDeclaration {
                            /* TODO(ExpressionStatement): addRelatedInfo(                                 diag,                                 createDiagnosticForNode(                                     exportingDeclaration,                                     Diagnostics._0_is_automatically_exported_here,                                     unescapeLeadingUnderscores(alreadyExportedSymbol.escapedName),                                 ),                             ); */
                        }
                    }
                } else {
                    /* TODO(ExpressionStatement): Debug.assert(node.kind !== SyntaxKind.VariableDeclaration); */
                    importDeclaration := findAncestor(node, or(isImportDeclaration, isImportEqualsDeclaration))
                    moduleSpecifier := /* TODO(BinaryExpression): (importDeclaration && tryGetModuleSpecifierFromDeclaration(importDeclaration)?.text) ?? "..." */ TODO
                    importedIdentifier := unescapeLeadingUnderscores(/* TODO(ConditionalExpression): isIdentifier(errorNode) ? errorNode.escapedText : symbol.escapedName */ TODO)
                    /* TODO(ExpressionStatement): error(                         errorNode,                         Diagnostics._0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation,                         importedIdentifier,                         `import("${moduleSpecifier}").${importedIdentifier}`,                     ); */
                }

            }
            targetFlags := getSymbolFlags(target)
            excludedMeanings := /* TODO(BinaryExpression): (symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue) ? SymbolFlags.Value : 0) |                 (symbol.flags & SymbolFlags.Type ? SymbolFlags.Type : 0) |                 (symbol.flags & SymbolFlags.Namespace ? SymbolFlags.Namespace : 0) */ TODO
            if /* TODO(BinaryExpression): targetFlags & excludedMeanings */ TODO {
                message := /* TODO(ConditionalExpression): node.kind === SyntaxKind.ExportSpecifier ?                     Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0 :                     Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0 */ TODO
                /* TODO(ExpressionStatement): error(node, message, symbolToString(symbol)); */
            } else if /* TODO(BinaryExpression): node.kind !== SyntaxKind.ExportSpecifier */ TODO {
                appearsValueyToTranspiler := /* TODO(BinaryExpression): compilerOptions.isolatedModules && !findAncestor(node, isTypeOnlyImportOrExportDeclaration) */ TODO
                if /* TODO(BinaryExpression): appearsValueyToTranspiler && symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue) */ TODO {
                    /* TODO(ExpressionStatement): error(                         node,                         Diagnostics.Import_0_conflicts_with_local_value_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled,                         symbolToString(symbol),                         isolatedModulesLikeFlagName,                     ); */
                }
            }
            if /* TODO(BinaryExpression): getIsolatedModules(compilerOptions)                 && !isTypeOnlyImportOrExportDeclaration(node)                 && !(node.flags & NodeFlags.Ambient) */ TODO {
                typeOnlyAlias := getTypeOnlyAliasDeclaration(symbol)
                isType := /* TODO(PrefixUnaryExpression): !(targetFlags & SymbolFlags.Value) */ TODO
                if /* TODO(BinaryExpression): isType || typeOnlyAlias */ TODO {
                    /* TODO(SwitchStatement): switch (node.kind) {                         case SyntaxKind.ImportClause:                         case SyntaxKind.ImportSpecifier:                         case SyntaxKind.ImportEqualsDeclaration: {                             if (compilerOptions.verbatimModuleSyntax) {                                 Debug.assertIsDefined(node.name, "An ImportClause with a symbol should have a name");                                 const message = compilerOptions.verbatimModuleSyntax && isInternalModuleImportEqualsDeclaration(node)                                     ? Diagnostics.An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled                                     : isType                                     ? Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled                                     : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled;                                 const name = moduleExportNameTextUnescaped(node.kind === SyntaxKind.ImportSpecifier ? node.propertyName || node.name : node.name);                                 addTypeOnlyDeclarationRelatedInfo(                                     error(node, message, name),                                     isType ? undefined : typeOnlyAlias,                                     name,                                 );                             }                             if (isType && node.kind === SyntaxKind.ImportEqualsDeclaration && hasEffectiveModifier(node, ModifierFlags.Export)) {                                 error(node, Diagnostics.Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled, isolatedModulesLikeFlagName);                             }                             break;                         }                         case SyntaxKind.ExportSpecifier: {                             // Don't allow re-exporting an export that will be elided when `--isolatedModules` is set.                             // The exception is that `import type { A } from './a'; export { A }` is allowed                             // because single-file analysis can determine that the export should be dropped.                             if (compilerOptions.verbatimModuleSyntax || getSourceFileOfNode(typeOnlyAlias) !== getSourceFileOfNode(node)) {                                 const name = moduleExportNameTextUnescaped(node.propertyName || node.name);                                 const diagnostic = isType                                     ? error(node, Diagnostics.Re_exporting_a_type_when_0_is_enabled_requires_using_export_type, isolatedModulesLikeFlagName)                                     : error(node, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled, name, isolatedModulesLikeFlagName);                                 addTypeOnlyDeclarationRelatedInfo(diagnostic, isType ? undefined : typeOnlyAlias, name);                                 break;                             }                         }                     } */
                }
                if /* TODO(BinaryExpression): compilerOptions.verbatimModuleSyntax &&                     node.kind !== SyntaxKind.ImportEqualsDeclaration &&                     !isInJSFile(node) &&                     host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) === ModuleKind.CommonJS */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled); */
                } else if /* TODO(BinaryExpression): moduleKind === ModuleKind.Preserve &&                     node.kind !== SyntaxKind.ImportEqualsDeclaration &&                     node.kind !== SyntaxKind.VariableDeclaration &&                     host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) === ModuleKind.CommonJS */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_module_is_set_to_preserve); */
                }
                if /* TODO(BinaryExpression): compilerOptions.verbatimModuleSyntax &&                     !isTypeOnlyImportOrExportDeclaration(node) &&                     !(node.flags & NodeFlags.Ambient) &&                     targetFlags & SymbolFlags.ConstEnum */ TODO {
                    constEnumDeclaration := /* TODO(PropertyAccessExpression): target.valueDeclaration */ TODO /* as */ /* TODO(TypeReference): EnumDeclaration */
                    redirect := /* TODO(PropertyAccessExpression): host.getRedirectReferenceForResolutionFromSourceOfProject */ TODO(/* TODO(PropertyAccessExpression): getSourceFileOfNode(constEnumDeclaration).resolvedPath */ TODO)
                    if /* TODO(BinaryExpression): constEnumDeclaration.flags & NodeFlags.Ambient && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) */ TODO {
                        /* TODO(ExpressionStatement): error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName); */
                    }
                }
            }
            if isImportSpecifier(node) {
                targetSymbol := resolveAliasWithDeprecationCheck(symbol, node)
                if /* TODO(BinaryExpression): isDeprecatedSymbol(targetSymbol) && targetSymbol.declarations */ TODO {
                    /* TODO(ExpressionStatement): addDeprecatedSuggestion(node, targetSymbol.declarations, targetSymbol.escapedName as string); */
                }
            }
        }
    }
    resolveAliasWithDeprecationCheck := func(symbol Symbol, location Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
        if /* TODO(BinaryExpression): !(symbol.flags & SymbolFlags.Alias) || isDeprecatedSymbol(symbol) || !getDeclarationOfAliasSymbol(symbol) */ TODO {
             symbol
        }
        targetSymbol := resolveAlias(symbol)
        if /* TODO(BinaryExpression): targetSymbol === unknownSymbol */ TODO {
            /* TODO(Identifier): targetSymbol */
        }
        /* TODO(WhileStatement): while (symbol.flags & SymbolFlags.Alias) {             const target = getImmediateAliasedSymbol(symbol);             if (target) {                 if (target === targetSymbol) break;                 if (target.declarations && length(target.declarations)) {                     if (isDeprecatedSymbol(target)) {                         addDeprecatedSuggestion(location, target.declarations, target.escapedName as string);                         break;                     }                     else {                         if (symbol === targetSymbol) break;                         symbol = target;                     }                 }             }             else {                 break;             }         } */
         targetSymbol
    }
    checkImportBinding := func(node /* TODO(UnionType): ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportSpecifier */ any) {
        /* TODO(ExpressionStatement): checkCollisionsForDeclarationName(node, node.name); */
        /* TODO(ExpressionStatement): checkAliasSymbol(node); */
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.ImportSpecifier */ TODO {
            /* TODO(ExpressionStatement): checkModuleExportName(node.propertyName); */
            if /* TODO(BinaryExpression): moduleExportNameIsDefault(node.propertyName || node.name) &&                 getESModuleInterop(compilerOptions) &&                 host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKind.System */ TODO {
                /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.ImportDefault); */
            }
        }
    }
    checkImportAttributes := func(declaration /* TODO(UnionType): ImportDeclaration | ExportDeclaration | JSDocImportTag */ any) /* TODO(undefined): boolean | undefined */ TODO {
        node := /* TODO(PropertyAccessExpression): declaration.attributes */ TODO
        if node {
            importAttributesType := getGlobalImportAttributesType(/* TODO(TrueKeyword): true */ TODO)
            if /* TODO(BinaryExpression): importAttributesType !== emptyObjectType */ TODO {
                /* TODO(ExpressionStatement): checkTypeAssignableTo(getTypeFromImportAttributes(node), getNullableType(importAttributesType, TypeFlags.Undefined), node); */
            }
            validForTypeAttributes := isExclusivelyTypeOnlyImportOrExport(declaration)
            override := getResolutionModeOverride(node, /* TODO(ConditionalExpression): validForTypeAttributes ? grammarErrorOnNode : undefined */ TODO)
            isImportAttributes := /* TODO(BinaryExpression): declaration.attributes.token === SyntaxKind.WithKeyword */ TODO
            if /* TODO(BinaryExpression): validForTypeAttributes && override */ TODO {

            }
            mode := /* TODO(BinaryExpression): (moduleKind === ModuleKind.NodeNext) && declaration.moduleSpecifier && getEmitSyntaxForModuleSpecifierExpression(declaration.moduleSpecifier) */ TODO
            if /* TODO(BinaryExpression): mode !== ModuleKind.ESNext && moduleKind !== ModuleKind.ESNext && moduleKind !== ModuleKind.Preserve */ TODO {
                message := /* TODO(ConditionalExpression): isImportAttributes                     ? moduleKind === ModuleKind.NodeNext                         ? Diagnostics.Import_attributes_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls                         : Diagnostics.Import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve                     : moduleKind === ModuleKind.NodeNext                     ? Diagnostics.Import_assertions_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls                     : Diagnostics.Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve */ TODO
                 grammarErrorOnNode(node, message)
            }
            isTypeOnly := /* TODO(BinaryExpression): isJSDocImportTag(declaration) || (isImportDeclaration(declaration) ? declaration.importClause?.isTypeOnly : declaration.isTypeOnly) */ TODO
            if isTypeOnly {
                 grammarErrorOnNode(node, /* TODO(ConditionalExpression): isImportAttributes ? Diagnostics.Import_attributes_cannot_be_used_with_type_only_imports_or_exports : Diagnostics.Import_assertions_cannot_be_used_with_type_only_imports_or_exports */ TODO)
            }
            if override {
                 grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.resolution_mode_can_only_be_set_for_type_only_imports */ TODO)
            }
        }
    }
    checkImportAttribute := func(node ImportAttribute) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
         getRegularTypeOfLiteralType(checkExpressionCached(/* TODO(PropertyAccessExpression): node.value */ TODO))
    }
    checkImportDeclaration := func(node ImportDeclaration) {
        if checkGrammarModuleElementContext(node, /* TODO(ConditionalExpression): isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */ TODO) {

        }
        if /* TODO(BinaryExpression): !checkGrammarModifiers(node) && node.modifiers */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnFirstToken(node, Diagnostics.An_import_declaration_cannot_have_modifiers); */
        }
        if checkExternalImportOrExportDeclaration(node) {
            importClause := /* TODO(PropertyAccessExpression): node.importClause */ TODO
            if /* TODO(BinaryExpression): importClause && !checkGrammarImportClause(importClause) */ TODO {
                if /* TODO(PropertyAccessExpression): importClause.name */ TODO {
                    /* TODO(ExpressionStatement): checkImportBinding(importClause); */
                }
                if /* TODO(PropertyAccessExpression): importClause.namedBindings */ TODO {
                    if /* TODO(BinaryExpression): importClause.namedBindings.kind === SyntaxKind.NamespaceImport */ TODO {
                        /* TODO(ExpressionStatement): checkImportBinding(importClause.namedBindings); */
                        if /* TODO(BinaryExpression): host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKind.System && getESModuleInterop(compilerOptions) */ TODO {
                            /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.ImportStar); */
                        }
                    } else {
                        moduleExisted := resolveExternalModuleName(node, /* TODO(PropertyAccessExpression): node.moduleSpecifier */ TODO)
                        if moduleExisted {
                            /* TODO(ExpressionStatement): forEach(importClause.namedBindings.elements, checkImportBinding); */
                        }
                    }
                }
            } else if /* TODO(BinaryExpression): noUncheckedSideEffectImports && !importClause */ TODO {
                /* TODO(ExpressionStatement): void resolveExternalModuleName(node, node.moduleSpecifier); */
            }
        }
        /* TODO(ExpressionStatement): checkImportAttributes(node); */
    }
    checkImportEqualsDeclaration := func(node ImportEqualsDeclaration) {
        if checkGrammarModuleElementContext(node, /* TODO(ConditionalExpression): isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */ TODO) {

        }
        /* TODO(ExpressionStatement): checkGrammarModifiers(node); */
        if /* TODO(BinaryExpression): isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(node) */ TODO {
            /* TODO(ExpressionStatement): checkImportBinding(node); */
            /* TODO(ExpressionStatement): markLinkedReferences(node, ReferenceHint.ExportImportEquals); */
            if /* TODO(BinaryExpression): node.moduleReference.kind !== SyntaxKind.ExternalModuleReference */ TODO {
                target := resolveAlias(getSymbolOfDeclaration(node))
                if /* TODO(BinaryExpression): target !== unknownSymbol */ TODO {
                    targetFlags := getSymbolFlags(target)
                    if /* TODO(BinaryExpression): targetFlags & SymbolFlags.Value */ TODO {
                        moduleName := getFirstIdentifier(/* TODO(PropertyAccessExpression): node.moduleReference */ TODO)
                        if /* TODO(PrefixUnaryExpression): !(resolveEntityName(moduleName, SymbolFlags.Value | SymbolFlags.Namespace)!.flags & SymbolFlags.Namespace) */ TODO {
                            /* TODO(ExpressionStatement): error(moduleName, Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, declarationNameToString(moduleName)); */
                        }
                    }
                    if /* TODO(BinaryExpression): targetFlags & SymbolFlags.Type */ TODO {
                        /* TODO(ExpressionStatement): checkTypeNameIsReserved(node.name, Diagnostics.Import_name_cannot_be_0); */
                    }
                }
                if /* TODO(PropertyAccessExpression): node.isTypeOnly */ TODO {
                    /* TODO(ExpressionStatement): grammarErrorOnNode(node, Diagnostics.An_import_alias_cannot_use_import_type); */
                }
            } else {
                if /* TODO(BinaryExpression): ModuleKind.ES2015 <= moduleKind && moduleKind <= ModuleKind.ESNext && !node.isTypeOnly && !(node.flags & NodeFlags.Ambient) */ TODO {
                    /* TODO(ExpressionStatement): grammarErrorOnNode(node, Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead); */
                }
            }
        }
    }
    checkExportDeclaration := func(node ExportDeclaration) {
        if checkGrammarModuleElementContext(node, /* TODO(ConditionalExpression): isInJSFile(node) ? Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */ TODO) {

        }
        if /* TODO(BinaryExpression): !checkGrammarModifiers(node) && hasSyntacticModifiers(node) */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnFirstToken(node, Diagnostics.An_export_declaration_cannot_have_modifiers); */
        }
        /* TODO(ExpressionStatement): checkGrammarExportDeclaration(node); */
        if /* TODO(BinaryExpression): !node.moduleSpecifier || checkExternalImportOrExportDeclaration(node) */ TODO {
            if /* TODO(BinaryExpression): node.exportClause && !isNamespaceExport(node.exportClause) */ TODO {
                /* TODO(ExpressionStatement): forEach(node.exportClause.elements, checkExportSpecifier); */
                inAmbientExternalModule := /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.ModuleBlock && isAmbientModule(node.parent.parent) */ TODO
                inAmbientNamespaceDeclaration := /* TODO(BinaryExpression): !inAmbientExternalModule && node.parent.kind === SyntaxKind.ModuleBlock &&                     !node.moduleSpecifier && node.flags & NodeFlags.Ambient */ TODO
                if /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.SourceFile && !inAmbientExternalModule && !inAmbientNamespaceDeclaration */ TODO {
                    /* TODO(ExpressionStatement): error(node, Diagnostics.Export_declarations_are_not_permitted_in_a_namespace); */
                }
            } else {
                moduleSymbol := resolveExternalModuleName(node, /* TODO(NonNullExpression): node.moduleSpecifier! */ TODO)
                if /* TODO(BinaryExpression): moduleSymbol && hasExportAssignmentSymbol(moduleSymbol) */ TODO {
                    /* TODO(ExpressionStatement): error(node.moduleSpecifier, Diagnostics.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk, symbolToString(moduleSymbol)); */
                } else if /* TODO(PropertyAccessExpression): node.exportClause */ TODO {
                    /* TODO(ExpressionStatement): checkAliasSymbol(node.exportClause); */
                    /* TODO(ExpressionStatement): checkModuleExportName(node.exportClause.name); */
                }
                if /* TODO(BinaryExpression): host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKind.System */ TODO {
                    if /* TODO(PropertyAccessExpression): node.exportClause */ TODO {
                        if getESModuleInterop(compilerOptions) {
                            /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.ImportStar); */
                        }
                    } else {
                        /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.ExportStar); */
                    }
                }
            }
        }
        /* TODO(ExpressionStatement): checkImportAttributes(node); */
    }
    checkGrammarExportDeclaration := func(node ExportDeclaration) bool {
        if /* TODO(BinaryExpression): node.isTypeOnly && node.exportClause?.kind === SyntaxKind.NamedExports */ TODO {
             checkGrammarNamedImportsOrExports(/* TODO(PropertyAccessExpression): node.exportClause */ TODO)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarModuleElementContext := func(node Statement, errorMessage DiagnosticMessage) bool {
        isInAppropriateContext := /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.SourceFile || node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.ModuleDeclaration */ TODO
        if /* TODO(PrefixUnaryExpression): !isInAppropriateContext */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnFirstToken(node, errorMessage); */
        }
         /* TODO(PrefixUnaryExpression): !isInAppropriateContext */ TODO
    }
    checkExportSpecifier := func(node ExportSpecifier) {
        /* TODO(ExpressionStatement): checkAliasSymbol(node); */
        hasModuleSpecifier := /* TODO(BinaryExpression): node.parent.parent.moduleSpecifier !== undefined */ TODO
        /* TODO(ExpressionStatement): checkModuleExportName(node.propertyName, hasModuleSpecifier); */
        /* TODO(ExpressionStatement): checkModuleExportName(node.name); */
        if getEmitDeclarations(compilerOptions) {
            /* TODO(ExpressionStatement): collectLinkedAliases(node.propertyName || node.name, /*setVisibility* / true); */
        }
        if /* TODO(PrefixUnaryExpression): !hasModuleSpecifier */ TODO {
            exportedName := /* TODO(BinaryExpression): node.propertyName || node.name */ TODO
            if /* TODO(BinaryExpression): exportedName.kind === SyntaxKind.StringLiteral */ TODO {

            }
            symbol := resolveName(exportedName, /* TODO(PropertyAccessExpression): exportedName.escapedText */ TODO, /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias */ TODO, undefined, /* TODO(TrueKeyword): true */ TODO)
            if /* TODO(BinaryExpression): symbol && (symbol === undefinedSymbol || symbol === globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0]))) */ TODO {
                /* TODO(ExpressionStatement): error(exportedName, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, idText(exportedName)); */
            } else {
                /* TODO(ExpressionStatement): markLinkedReferences(node, ReferenceHint.ExportSpecifier); */
            }
        } else {
            if /* TODO(BinaryExpression): getESModuleInterop(compilerOptions) &&                 host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKind.System &&                 moduleExportNameIsDefault(node.propertyName || node.name) */ TODO {
                /* TODO(ExpressionStatement): checkExternalEmitHelpers(node, ExternalEmitHelpers.ImportDefault); */
            }
        }
    }
    checkExportAssignment := func(node ExportAssignment) {
        illegalContextMessage := /* TODO(ConditionalExpression): node.isExportEquals             ? Diagnostics.An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration             : Diagnostics.A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration */ TODO
        if checkGrammarModuleElementContext(node, illegalContextMessage) {

        }
        container := /* TODO(ConditionalExpression): node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent as ModuleDeclaration */ TODO
        if /* TODO(BinaryExpression): container.kind === SyntaxKind.ModuleDeclaration && !isAmbientModule(container) */ TODO {
            if /* TODO(PropertyAccessExpression): node.isExportEquals */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.An_export_assignment_cannot_be_used_in_a_namespace); */
            } else {
                /* TODO(ExpressionStatement): error(node, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module); */
            }

        }
        if /* TODO(BinaryExpression): !checkGrammarModifiers(node) && hasEffectiveModifiers(node) */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnFirstToken(node, Diagnostics.An_export_assignment_cannot_have_modifiers); */
        }
        typeAnnotationNode := getEffectiveTypeAnnotationNode(node)
        if typeAnnotationNode {
            /* TODO(ExpressionStatement): checkTypeAssignableTo(checkExpressionCached(node.expression), getTypeFromTypeNode(typeAnnotationNode), node.expression); */
        }
        isIllegalExportDefaultInCJS := /* TODO(BinaryExpression): !node.isExportEquals &&             !(node.flags & NodeFlags.Ambient) &&             compilerOptions.verbatimModuleSyntax &&             host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) === ModuleKind.CommonJS */ TODO
        if /* TODO(BinaryExpression): node.expression.kind === SyntaxKind.Identifier */ TODO {
            id := /* TODO(PropertyAccessExpression): node.expression */ TODO /* as */ /* TODO(TypeReference): Identifier */
            sym := getExportSymbolOfValueSymbolIfExported(resolveEntityName(id, /* TODO(PropertyAccessExpression): SymbolFlags.All */ TODO, /* TODO(TrueKeyword): true */ TODO, /* TODO(TrueKeyword): true */ TODO, node))
            if sym {
                /* TODO(ExpressionStatement): markLinkedReferences(node, ReferenceHint.ExportAssignment); */
                typeOnlyDeclaration := getTypeOnlyAliasDeclaration(sym, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO)
                if /* TODO(BinaryExpression): getSymbolFlags(sym) & SymbolFlags.Value */ TODO {
                    /* TODO(ExpressionStatement): checkExpressionCached(id); */
                    if /* TODO(BinaryExpression): !isIllegalExportDefaultInCJS && !(node.flags & NodeFlags.Ambient) && compilerOptions.verbatimModuleSyntax && typeOnlyDeclaration */ TODO {
                        /* TODO(ExpressionStatement): error(                             id,                             node.isExportEquals                                 ? Diagnostics.An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration                                 : Diagnostics.An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration,                             idText(id),                         ); */
                    }
                } else if /* TODO(BinaryExpression): !isIllegalExportDefaultInCJS && !(node.flags & NodeFlags.Ambient) && compilerOptions.verbatimModuleSyntax */ TODO {
                    /* TODO(ExpressionStatement): error(                         id,                         node.isExportEquals                             ? Diagnostics.An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type                             : Diagnostics.An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type,                         idText(id),                     ); */
                }
                if /* TODO(BinaryExpression): !isIllegalExportDefaultInCJS && !(node.flags & NodeFlags.Ambient) && getIsolatedModules(compilerOptions) && !(sym.flags & SymbolFlags.Value) */ TODO {
                    nonLocalMeanings := getSymbolFlags(sym, /* TODO(FalseKeyword): false */ TODO, /* TODO(TrueKeyword): true */ TODO)
                    if /* TODO(BinaryExpression): sym.flags & SymbolFlags.Alias                         && nonLocalMeanings & SymbolFlags.Type                         && !(nonLocalMeanings & SymbolFlags.Value)                         && (!typeOnlyDeclaration || getSourceFileOfNode(typeOnlyDeclaration) !== getSourceFileOfNode(node)) */ TODO {
                        /* TODO(ExpressionStatement): error(                             id,                             node.isExportEquals ?                                 Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported                                 : Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default,                             idText(id),                             isolatedModulesLikeFlagName,                         ); */
                    } else if /* TODO(BinaryExpression): typeOnlyDeclaration && getSourceFileOfNode(typeOnlyDeclaration) !== getSourceFileOfNode(node) */ TODO {
                        /* TODO(ExpressionStatement): addTypeOnlyDeclarationRelatedInfo(                             error(                                 id,                                 node.isExportEquals ?                                     Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported                                     : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default,                                 idText(id),                                 isolatedModulesLikeFlagName,                             ),                             typeOnlyDeclaration,                             idText(id),                         ); */
                    }
                }
            } else {
                /* TODO(ExpressionStatement): checkExpressionCached(id); */
            }
            if getEmitDeclarations(compilerOptions) {
                /* TODO(ExpressionStatement): collectLinkedAliases(id, /*setVisibility* / true); */
            }
        } else {
            /* TODO(ExpressionStatement): checkExpressionCached(node.expression); */
        }
        if isIllegalExportDefaultInCJS {
            /* TODO(ExpressionStatement): error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled); */
        }
        /* TODO(ExpressionStatement): checkExternalModuleExports(container); */
        if /* TODO(BinaryExpression): (node.flags & NodeFlags.Ambient) && !isEntityNameExpression(node.expression) */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnNode(node.expression, Diagnostics.The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context); */
        }
        if /* TODO(PropertyAccessExpression): node.isExportEquals */ TODO {
            if /* TODO(BinaryExpression): moduleKind >= ModuleKind.ES2015 &&                 moduleKind !== ModuleKind.Preserve &&                 ((node.flags & NodeFlags.Ambient && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) === ModuleKind.ESNext) ||                     (!(node.flags & NodeFlags.Ambient) && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) !== ModuleKind.CommonJS)) */ TODO {
                /* TODO(ExpressionStatement): grammarErrorOnNode(node, Diagnostics.Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead); */
            } else if /* TODO(BinaryExpression): moduleKind === ModuleKind.System && !(node.flags & NodeFlags.Ambient) */ TODO {
                /* TODO(ExpressionStatement): grammarErrorOnNode(node, Diagnostics.Export_assignment_is_not_supported_when_module_flag_is_system); */
            }
        }
    }
    hasExportedMembers := func(moduleSymbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
         forEachEntry(/* TODO(NonNullExpression): moduleSymbol.exports! */ TODO, /* TODO(ArrowFunction): (_, id) => id !== "export=" */ TODO)
    }
    checkExternalModuleExports := func(node /* TODO(UnionType): SourceFile | ModuleDeclaration */ any) {
        moduleSymbol := getSymbolOfDeclaration(node)
        links := getSymbolLinks(moduleSymbol)
        if /* TODO(PrefixUnaryExpression): !links.exportsChecked */ TODO {
            exportEqualsSymbol := /* TODO(PropertyAccessExpression): moduleSymbol.exports!.get */ TODO("export=" /* as */ /* TODO(TypeReference): __String */)
            if /* TODO(BinaryExpression): exportEqualsSymbol && hasExportedMembers(moduleSymbol) */ TODO {
                declaration := /* TODO(BinaryExpression): getDeclarationOfAliasSymbol(exportEqualsSymbol) || exportEqualsSymbol.valueDeclaration */ TODO
                if /* TODO(BinaryExpression): declaration && !isTopLevelInExternalModuleAugmentation(declaration) && !isInJSFile(declaration) */ TODO {
                    /* TODO(ExpressionStatement): error(declaration, Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements); */
                }
            }
            exports := getExportsOfModule(moduleSymbol)
            if exports {
                /* TODO(ExpressionStatement): exports.forEach(({ declarations, flags }, id) => {                     if (id === "__export") {                         return;                     }                     // ECMA262: 15.2.1.1 It is a Syntax Error if the ExportedNames of ModuleItemList contains any duplicate entries.                     // (TS Exceptions: namespaces, function overloads, enums, and interfaces)                     if (flags & (SymbolFlags.Namespace | SymbolFlags.Enum)) {                         return;                     }                     const exportedDeclarationsCount = countWhere(declarations, and(isNotOverloadAndNotAccessor, not(isInterfaceDeclaration)));                     if (flags & SymbolFlags.TypeAlias && exportedDeclarationsCount <= 2) {                         // it is legal to merge type alias with other values                         // so count should be either 1 (just type alias) or 2 (type alias + merged value)                         return;                     }                     if (exportedDeclarationsCount > 1) {                         if (!isDuplicatedCommonJSExport(declarations)) {                             for (const declaration of declarations!) {                                 if (isNotOverload(declaration)) {                                     diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Cannot_redeclare_exported_variable_0, unescapeLeadingUnderscores(id)));                                 }                             }                         }                     }                 }); */
            }
            /* TODO(ExpressionStatement): links.exportsChecked = true; */
        }
    }
    isDuplicatedCommonJSExport := func(declarations /* TODO(ArrayType): Declaration[] */ any) /* TODO(undefined): boolean | undefined */ TODO {
         /* TODO(BinaryExpression): declarations             && declarations.length > 1             && declarations.every(d => isInJSFile(d) && isAccessExpression(d) && (isExportsIdentifier(d.expression) || isModuleExportsAccessExpression(d.expression))) */ TODO
    }
    checkSourceElement := func(node Node) {
        if node {
            saveCurrentNode := currentNode
            /* TODO(ExpressionStatement): currentNode = node; */
            /* TODO(ExpressionStatement): instantiationCount = 0; */
            /* TODO(ExpressionStatement): checkSourceElementWorker(node); */
            /* TODO(ExpressionStatement): currentNode = saveCurrentNode; */
        }
    }
    checkSourceElementWorker := func(node Node) {
        if /* TODO(BinaryExpression): getNodeCheckFlags(node) & NodeCheckFlags.PartiallyTypeChecked */ TODO {

        }
        if canHaveJSDoc(node) {
            /* TODO(ExpressionStatement): forEach(node.jsDoc, ({ comment, tags }) => {                 checkJSDocCommentWorker(comment);                 forEach(tags, tag => {                     checkJSDocCommentWorker(tag.comment);                     if (isInJSFile(node)) {                         checkSourceElement(tag);                     }                 });             }); */
        }
        kind := /* TODO(PropertyAccessExpression): node.kind */ TODO
        if cancellationToken {
            /* TODO(SwitchStatement): switch (kind) {                 case SyntaxKind.ModuleDeclaration:                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.InterfaceDeclaration:                 case SyntaxKind.FunctionDeclaration:                     cancellationToken.throwIfCancellationRequested();             } */
        }
        if /* TODO(BinaryExpression): kind >= SyntaxKind.FirstStatement && kind <= SyntaxKind.LastStatement && canHaveFlowNode(node) && node.flowNode && !isReachableFlowNode(node.flowNode) */ TODO {
            /* TODO(ExpressionStatement): errorOrSuggestion(compilerOptions.allowUnreachableCode === false, node, Diagnostics.Unreachable_code_detected); */
        }
        /* TODO(SwitchStatement): switch (kind) {             case SyntaxKind.TypeParameter:                 return checkTypeParameter(node as TypeParameterDeclaration);             case SyntaxKind.Parameter:                 return checkParameter(node as ParameterDeclaration);             case SyntaxKind.PropertyDeclaration:                 return checkPropertyDeclaration(node as PropertyDeclaration);             case SyntaxKind.PropertySignature:                 return checkPropertySignature(node as PropertySignature);             case SyntaxKind.ConstructorType:             case SyntaxKind.FunctionType:             case SyntaxKind.CallSignature:             case SyntaxKind.ConstructSignature:             case SyntaxKind.IndexSignature:                 return checkSignatureDeclaration(node as SignatureDeclaration);             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:                 return checkMethodDeclaration(node as MethodDeclaration | MethodSignature);             case SyntaxKind.ClassStaticBlockDeclaration:                 return checkClassStaticBlockDeclaration(node as ClassStaticBlockDeclaration);             case SyntaxKind.Constructor:                 return checkConstructorDeclaration(node as ConstructorDeclaration);             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 return checkAccessorDeclaration(node as AccessorDeclaration);             case SyntaxKind.TypeReference:                 return checkTypeReferenceNode(node as TypeReferenceNode);             case SyntaxKind.TypePredicate:                 return checkTypePredicate(node as TypePredicateNode);             case SyntaxKind.TypeQuery:                 return checkTypeQuery(node as TypeQueryNode);             case SyntaxKind.TypeLiteral:                 return checkTypeLiteral(node as TypeLiteralNode);             case SyntaxKind.ArrayType:                 return checkArrayType(node as ArrayTypeNode);             case SyntaxKind.TupleType:                 return checkTupleType(node as TupleTypeNode);             case SyntaxKind.UnionType:             case SyntaxKind.IntersectionType:                 return checkUnionOrIntersectionType(node as UnionOrIntersectionTypeNode);             case SyntaxKind.ParenthesizedType:             case SyntaxKind.OptionalType:             case SyntaxKind.RestType:                 return checkSourceElement((node as ParenthesizedTypeNode | OptionalTypeNode | RestTypeNode).type);             case SyntaxKind.ThisType:                 return checkThisType(node as ThisTypeNode);             case SyntaxKind.TypeOperator:                 return checkTypeOperator(node as TypeOperatorNode);             case SyntaxKind.ConditionalType:                 return checkConditionalType(node as ConditionalTypeNode);             case SyntaxKind.InferType:                 return checkInferType(node as InferTypeNode);             case SyntaxKind.TemplateLiteralType:                 return checkTemplateLiteralType(node as TemplateLiteralTypeNode);             case SyntaxKind.ImportType:                 return checkImportType(node as ImportTypeNode);             case SyntaxKind.NamedTupleMember:                 return checkNamedTupleMember(node as NamedTupleMember);             case SyntaxKind.JSDocAugmentsTag:                 return checkJSDocAugmentsTag(node as JSDocAugmentsTag);             case SyntaxKind.JSDocImplementsTag:                 return checkJSDocImplementsTag(node as JSDocImplementsTag);             case SyntaxKind.JSDocTypedefTag:             case SyntaxKind.JSDocCallbackTag:             case SyntaxKind.JSDocEnumTag:                 return checkJSDocTypeAliasTag(node as JSDocTypedefTag);             case SyntaxKind.JSDocTemplateTag:                 return checkJSDocTemplateTag(node as JSDocTemplateTag);             case SyntaxKind.JSDocTypeTag:                 return checkJSDocTypeTag(node as JSDocTypeTag);             case SyntaxKind.JSDocLink:             case SyntaxKind.JSDocLinkCode:             case SyntaxKind.JSDocLinkPlain:                 return checkJSDocLinkLikeTag(node as JSDocLink | JSDocLinkCode | JSDocLinkPlain);             case SyntaxKind.JSDocParameterTag:                 return checkJSDocParameterTag(node as JSDocParameterTag);             case SyntaxKind.JSDocPropertyTag:                 return checkJSDocPropertyTag(node as JSDocPropertyTag);             case SyntaxKind.JSDocFunctionType:                 checkJSDocFunctionType(node as JSDocFunctionType);                 // falls through             case SyntaxKind.JSDocNonNullableType:             case SyntaxKind.JSDocNullableType:             case SyntaxKind.JSDocAllType:             case SyntaxKind.JSDocUnknownType:             case SyntaxKind.JSDocTypeLiteral:                 checkJSDocTypeIsInJsFile(node);                 forEachChild(node, checkSourceElement);                 return;             case SyntaxKind.JSDocVariadicType:                 checkJSDocVariadicType(node as JSDocVariadicType);                 return;             case SyntaxKind.JSDocTypeExpression:                 return checkSourceElement((node as JSDocTypeExpression).type);             case SyntaxKind.JSDocPublicTag:             case SyntaxKind.JSDocProtectedTag:             case SyntaxKind.JSDocPrivateTag:                 return checkJSDocAccessibilityModifiers(node as JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag);             case SyntaxKind.JSDocSatisfiesTag:                 return checkJSDocSatisfiesTag(node as JSDocSatisfiesTag);             case SyntaxKind.JSDocThisTag:                 return checkJSDocThisTag(node as JSDocThisTag);             case SyntaxKind.JSDocImportTag:                 return checkJSDocImportTag(node as JSDocImportTag);             case SyntaxKind.IndexedAccessType:                 return checkIndexedAccessType(node as IndexedAccessTypeNode);             case SyntaxKind.MappedType:                 return checkMappedType(node as MappedTypeNode);             case SyntaxKind.FunctionDeclaration:                 return checkFunctionDeclaration(node as FunctionDeclaration);             case SyntaxKind.Block:             case SyntaxKind.ModuleBlock:                 return checkBlock(node as Block);             case SyntaxKind.VariableStatement:                 return checkVariableStatement(node as VariableStatement);             case SyntaxKind.ExpressionStatement:                 return checkExpressionStatement(node as ExpressionStatement);             case SyntaxKind.IfStatement:                 return checkIfStatement(node as IfStatement);             case SyntaxKind.DoStatement:                 return checkDoStatement(node as DoStatement);             case SyntaxKind.WhileStatement:                 return checkWhileStatement(node as WhileStatement);             case SyntaxKind.ForStatement:                 return checkForStatement(node as ForStatement);             case SyntaxKind.ForInStatement:                 return checkForInStatement(node as ForInStatement);             case SyntaxKind.ForOfStatement:                 return checkForOfStatement(node as ForOfStatement);             case SyntaxKind.ContinueStatement:             case SyntaxKind.BreakStatement:                 return checkBreakOrContinueStatement(node as BreakOrContinueStatement);             case SyntaxKind.ReturnStatement:                 return checkReturnStatement(node as ReturnStatement);             case SyntaxKind.WithStatement:                 return checkWithStatement(node as WithStatement);             case SyntaxKind.SwitchStatement:                 return checkSwitchStatement(node as SwitchStatement);             case SyntaxKind.LabeledStatement:                 return checkLabeledStatement(node as LabeledStatement);             case SyntaxKind.ThrowStatement:                 return checkThrowStatement(node as ThrowStatement);             case SyntaxKind.TryStatement:                 return checkTryStatement(node as TryStatement);             case SyntaxKind.VariableDeclaration:                 return checkVariableDeclaration(node as VariableDeclaration);             case SyntaxKind.BindingElement:                 return checkBindingElement(node as BindingElement);             case SyntaxKind.ClassDeclaration:                 return checkClassDeclaration(node as ClassDeclaration);             case SyntaxKind.InterfaceDeclaration:                 return checkInterfaceDeclaration(node as InterfaceDeclaration);             case SyntaxKind.TypeAliasDeclaration:                 return checkTypeAliasDeclaration(node as TypeAliasDeclaration);             case SyntaxKind.EnumDeclaration:                 return checkEnumDeclaration(node as EnumDeclaration);             case SyntaxKind.ModuleDeclaration:                 return checkModuleDeclaration(node as ModuleDeclaration);             case SyntaxKind.ImportDeclaration:                 return checkImportDeclaration(node as ImportDeclaration);             case SyntaxKind.ImportEqualsDeclaration:                 return checkImportEqualsDeclaration(node as ImportEqualsDeclaration);             case SyntaxKind.ExportDeclaration:                 return checkExportDeclaration(node as ExportDeclaration);             case SyntaxKind.ExportAssignment:                 return checkExportAssignment(node as ExportAssignment);             case SyntaxKind.EmptyStatement:             case SyntaxKind.DebuggerStatement:                 checkGrammarStatementInAmbientContext(node);                 return;             case SyntaxKind.MissingDeclaration:                 return checkMissingDeclaration(node);         } */
    }
    checkJSDocCommentWorker := func(node /* TODO(UnionType): string | readonly JSDocComment[] | undefined */ any) {
        if isArray(node) {
            /* TODO(ExpressionStatement): forEach(node, tag => {                 if (isJSDocLinkLike(tag)) {                     checkSourceElement(tag);                 }             }); */
        }
    }
    checkJSDocTypeIsInJsFile := func(node Node) {
        if /* TODO(PrefixUnaryExpression): !isInJSFile(node) */ TODO {
            if /* TODO(BinaryExpression): isJSDocNonNullableType(node) || isJSDocNullableType(node) */ TODO {
                token := tokenToString(/* TODO(ConditionalExpression): isJSDocNonNullableType(node) ? SyntaxKind.ExclamationToken : SyntaxKind.QuestionToken */ TODO)
                diagnostic := /* TODO(ConditionalExpression): node.postfix                     ? Diagnostics._0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1                     : Diagnostics._0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1 */ TODO
                typeNode := /* TODO(PropertyAccessExpression): node.type */ TODO
                type_ := getTypeFromTypeNode(typeNode)
                /* TODO(ExpressionStatement): grammarErrorOnNode(                     node,                     diagnostic,                     token,                     typeToString(                         isJSDocNullableType(node) && !(type === neverType || type === voidType)                             ? getUnionType(append([type, undefinedType], node.postfix ? undefined : nullType)) : type,                     ),                 ); */
            } else {
                /* TODO(ExpressionStatement): grammarErrorOnNode(node, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments); */
            }
        }
    }
    checkJSDocVariadicType := func(node JSDocVariadicType) {
        /* TODO(ExpressionStatement): checkJSDocTypeIsInJsFile(node); */
        /* TODO(ExpressionStatement): checkSourceElement(node.type); */
        TODO_IDENTIFIER := node
        if /* TODO(BinaryExpression): isParameter(parent) && isJSDocFunctionType(parent.parent) */ TODO {
            if /* TODO(BinaryExpression): last(parent.parent.parameters) !== parent */ TODO {
                /* TODO(ExpressionStatement): error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list); */
            }

        }
        if /* TODO(PrefixUnaryExpression): !isJSDocTypeExpression(parent) */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature); */
        }
        paramTag := /* TODO(PropertyAccessExpression): node.parent.parent */ TODO
        if /* TODO(PrefixUnaryExpression): !isJSDocParameterTag(paramTag) */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature); */

        }
        param := getParameterSymbolFromJSDoc(paramTag)
        if /* TODO(PrefixUnaryExpression): !param */ TODO {

        }
        host := getHostSignatureFromJSDoc(paramTag)
        if /* TODO(BinaryExpression): !host || last(host.parameters).symbol !== param */ TODO {
            /* TODO(ExpressionStatement): error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list); */
        }
    }
    getTypeFromJSDocVariadicType := func(node JSDocVariadicType) Type {
        type_ := getTypeFromTypeNode(/* TODO(PropertyAccessExpression): node.type */ TODO)
        TODO_IDENTIFIER := node
        paramTag := /* TODO(PropertyAccessExpression): node.parent.parent */ TODO
        if /* TODO(BinaryExpression): isJSDocTypeExpression(node.parent) && isJSDocParameterTag(paramTag) */ TODO {
            host := getHostSignatureFromJSDoc(paramTag)
            isCallbackTag := isJSDocCallbackTag(/* TODO(PropertyAccessExpression): paramTag.parent.parent */ TODO)
            if /* TODO(BinaryExpression): host || isCallbackTag */ TODO {
                lastParamDeclaration := /* TODO(ConditionalExpression): isCallbackTag                     ? lastOrUndefined((paramTag.parent.parent as unknown as JSDocCallbackTag).typeExpression.parameters)                     : lastOrUndefined(host!.parameters) */ TODO
                symbol := getParameterSymbolFromJSDoc(paramTag)
                if /* TODO(BinaryExpression): !lastParamDeclaration ||                     symbol && lastParamDeclaration.symbol === symbol && isRestParameter(lastParamDeclaration) */ TODO {
                     createArrayType(type_)
                }
            }
        }
        if /* TODO(BinaryExpression): isParameter(parent) && isJSDocFunctionType(parent.parent) */ TODO {
             createArrayType(type_)
        }
         addOptionality(type_)
    }
    checkNodeDeferred := func(node Node) {
        enclosingFile := getSourceFileOfNode(node)
        links := getNodeLinks(enclosingFile)
        if /* TODO(PrefixUnaryExpression): !(links.flags & NodeCheckFlags.TypeChecked) */ TODO {
            /* TODO(ExpressionStatement): links.deferredNodes ||= new Set(); */
            /* TODO(ExpressionStatement): links.deferredNodes.add(node); */
        } else {
            /* TODO(ExpressionStatement): Debug.assert(!links.deferredNodes, "A type-checked file should have no deferred nodes."); */
        }
    }
    checkDeferredNodes := func(context SourceFile) {
        links := getNodeLinks(context)
        if /* TODO(PropertyAccessExpression): links.deferredNodes */ TODO {
            /* TODO(ExpressionStatement): links.deferredNodes.forEach(checkDeferredNode); */
        }
        /* TODO(ExpressionStatement): links.deferredNodes = undefined; */
    }
    checkDeferredNode := func(node Node) {
        /* TODO(ExpressionStatement): tracing?.push(tracing.Phase.Check, "checkDeferredNode", { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath }); */
        saveCurrentNode := currentNode
        /* TODO(ExpressionStatement): currentNode = node; */
        /* TODO(ExpressionStatement): instantiationCount = 0; */
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.CallExpression:             case SyntaxKind.NewExpression:             case SyntaxKind.TaggedTemplateExpression:             case SyntaxKind.Decorator:             case SyntaxKind.JsxOpeningElement:                 // These node kinds are deferred checked when overload resolution fails                 // To save on work, we ensure the arguments are checked just once, in                 // a deferred way                 resolveUntypedCall(node as CallLikeExpression);                 break;             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:                 checkFunctionExpressionOrObjectLiteralMethodDeferred(node as FunctionExpression);                 break;             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 checkAccessorDeclaration(node as AccessorDeclaration);                 break;             case SyntaxKind.ClassExpression:                 checkClassExpressionDeferred(node as ClassExpression);                 break;             case SyntaxKind.TypeParameter:                 checkTypeParameterDeferred(node as TypeParameterDeclaration);                 break;             case SyntaxKind.JsxSelfClosingElement:                 checkJsxSelfClosingElementDeferred(node as JsxSelfClosingElement);                 break;             case SyntaxKind.JsxElement:                 checkJsxElementDeferred(node as JsxElement);                 break;             case SyntaxKind.TypeAssertionExpression:             case SyntaxKind.AsExpression:             case SyntaxKind.ParenthesizedExpression:                 checkAssertionDeferred(node as AssertionExpression | JSDocTypeAssertion);                 break;             case SyntaxKind.VoidExpression:                 checkExpression((node as VoidExpression).expression);                 break;             case SyntaxKind.BinaryExpression:                 if (isInstanceOfExpression(node)) {                     resolveUntypedCall(node);                 }                 break;         } */
        /* TODO(ExpressionStatement): currentNode = saveCurrentNode; */
        /* TODO(ExpressionStatement): tracing?.pop(); */
    }
    checkSourceFile := func(node SourceFile, nodesToCheck /* TODO(ArrayType): Node[] */ any) {
        /* TODO(ExpressionStatement): tracing?.push(tracing.Phase.Check, nodesToCheck ? "checkSourceFileNodes" : "checkSourceFile", { path: node.path }, /*separateBeginAndEnd* / true); */
        beforeMark := /* TODO(ConditionalExpression): nodesToCheck ? "beforeCheckNodes" : "beforeCheck" */ TODO
        afterMark := /* TODO(ConditionalExpression): nodesToCheck ? "afterCheckNodes" : "afterCheck" */ TODO
        /* TODO(ExpressionStatement): performance.mark(beforeMark); */
        /* TODO(ExpressionStatement): nodesToCheck ? checkSourceFileNodesWorker(node, nodesToCheck) : checkSourceFileWorker(node); */
        /* TODO(ExpressionStatement): performance.mark(afterMark); */
        /* TODO(ExpressionStatement): performance.measure("Check", beforeMark, afterMark); */
        /* TODO(ExpressionStatement): tracing?.pop(); */
    }
    unusedIsError := func(kind UnusedKind, isAmbient bool) bool {
        if isAmbient {
             /* TODO(FalseKeyword): false */ TODO
        }
        /* TODO(SwitchStatement): switch (kind) {             case UnusedKind.Local:                 return !!compilerOptions.noUnusedLocals;             case UnusedKind.Parameter:                 return !!compilerOptions.noUnusedParameters;             default:                 return Debug.assertNever(kind);         } */
    }
    getPotentiallyUnusedIdentifiers := func(sourceFile SourceFile) []PotentiallyUnusedIdentifier {
         /* TODO(BinaryExpression): allPotentiallyUnusedIdentifiers.get(sourceFile.path) || emptyArray */ TODO
    }
    checkSourceFileWorker := func(node SourceFile) {
        links := getNodeLinks(node)
        if /* TODO(PrefixUnaryExpression): !(links.flags & NodeCheckFlags.TypeChecked) */ TODO {
            if skipTypeChecking(node, compilerOptions, host) {

            }
            /* TODO(ExpressionStatement): checkGrammarSourceFile(node); */
            /* TODO(ExpressionStatement): clear(potentialThisCollisions); */
            /* TODO(ExpressionStatement): clear(potentialNewTargetCollisions); */
            /* TODO(ExpressionStatement): clear(potentialWeakMapSetCollisions); */
            /* TODO(ExpressionStatement): clear(potentialReflectCollisions); */
            /* TODO(ExpressionStatement): clear(potentialUnusedRenamedBindingElementsInTypes); */
            if /* TODO(BinaryExpression): links.flags & NodeCheckFlags.PartiallyTypeChecked */ TODO {
                /* TODO(ExpressionStatement): potentialThisCollisions = links.potentialThisCollisions!; */
                /* TODO(ExpressionStatement): potentialNewTargetCollisions = links.potentialNewTargetCollisions!; */
                /* TODO(ExpressionStatement): potentialWeakMapSetCollisions = links.potentialWeakMapSetCollisions!; */
                /* TODO(ExpressionStatement): potentialReflectCollisions = links.potentialReflectCollisions!; */
                /* TODO(ExpressionStatement): potentialUnusedRenamedBindingElementsInTypes = links.potentialUnusedRenamedBindingElementsInTypes!; */
            }
            /* TODO(ExpressionStatement): forEach(node.statements, checkSourceElement); */
            /* TODO(ExpressionStatement): checkSourceElement(node.endOfFileToken); */
            /* TODO(ExpressionStatement): checkDeferredNodes(node); */
            if isExternalOrCommonJsModule(node) {
                /* TODO(ExpressionStatement): registerForUnusedIdentifiersCheck(node); */
            }
            /* TODO(ExpressionStatement): addLazyDiagnostic(() => {                 // This relies on the results of other lazy diagnostics, so must be computed after them                 if (!node.isDeclarationFile && (compilerOptions.noUnusedLocals || compilerOptions.noUnusedParameters)) {                     checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(node), (containingNode, kind, diag) => {                         if (!containsParseError(containingNode) && unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) {                             diagnostics.add(diag);                         }                     });                 }                 if (!node.isDeclarationFile) {                     checkPotentialUncheckedRenamedBindingElementsInTypes();                 }             }); */
            if isExternalOrCommonJsModule(node) {
                /* TODO(ExpressionStatement): checkExternalModuleExports(node); */
            }
            if /* TODO(PropertyAccessExpression): potentialThisCollisions.length */ TODO {
                /* TODO(ExpressionStatement): forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope); */
                /* TODO(ExpressionStatement): clear(potentialThisCollisions); */
            }
            if /* TODO(PropertyAccessExpression): potentialNewTargetCollisions.length */ TODO {
                /* TODO(ExpressionStatement): forEach(potentialNewTargetCollisions, checkIfNewTargetIsCapturedInEnclosingScope); */
                /* TODO(ExpressionStatement): clear(potentialNewTargetCollisions); */
            }
            if /* TODO(PropertyAccessExpression): potentialWeakMapSetCollisions.length */ TODO {
                /* TODO(ExpressionStatement): forEach(potentialWeakMapSetCollisions, checkWeakMapSetCollision); */
                /* TODO(ExpressionStatement): clear(potentialWeakMapSetCollisions); */
            }
            if /* TODO(PropertyAccessExpression): potentialReflectCollisions.length */ TODO {
                /* TODO(ExpressionStatement): forEach(potentialReflectCollisions, checkReflectCollision); */
                /* TODO(ExpressionStatement): clear(potentialReflectCollisions); */
            }
            /* TODO(ExpressionStatement): links.flags |= NodeCheckFlags.TypeChecked; */
        }
    }
    checkSourceFileNodesWorker := func(file SourceFile, nodes []Node) {
        links := getNodeLinks(file)
        if /* TODO(PrefixUnaryExpression): !(links.flags & NodeCheckFlags.TypeChecked) */ TODO {
            if skipTypeChecking(file, compilerOptions, host) {

            }
            /* TODO(ExpressionStatement): checkGrammarSourceFile(file); */
            /* TODO(ExpressionStatement): clear(potentialThisCollisions); */
            /* TODO(ExpressionStatement): clear(potentialNewTargetCollisions); */
            /* TODO(ExpressionStatement): clear(potentialWeakMapSetCollisions); */
            /* TODO(ExpressionStatement): clear(potentialReflectCollisions); */
            /* TODO(ExpressionStatement): clear(potentialUnusedRenamedBindingElementsInTypes); */
            /* TODO(ExpressionStatement): forEach(nodes, checkSourceElement); */
            /* TODO(ExpressionStatement): checkDeferredNodes(file); */
            /* TODO(ExpressionStatement): (links.potentialThisCollisions || (links.potentialThisCollisions = [])).push(...potentialThisCollisions); */
            /* TODO(ExpressionStatement): (links.potentialNewTargetCollisions || (links.potentialNewTargetCollisions = [])).push(...potentialNewTargetCollisions); */
            /* TODO(ExpressionStatement): (links.potentialWeakMapSetCollisions || (links.potentialWeakMapSetCollisions = [])).push(...potentialWeakMapSetCollisions); */
            /* TODO(ExpressionStatement): (links.potentialReflectCollisions || (links.potentialReflectCollisions = [])).push(...potentialReflectCollisions); */
            /* TODO(ExpressionStatement): (links.potentialUnusedRenamedBindingElementsInTypes || (links.potentialUnusedRenamedBindingElementsInTypes = [])).push(                 ...potentialUnusedRenamedBindingElementsInTypes,             ); */
            /* TODO(ExpressionStatement): links.flags |= NodeCheckFlags.PartiallyTypeChecked; */
            /* TODO(ForOfStatement): for (const node of nodes) {                 const nodeLinks = getNodeLinks(node);                 nodeLinks.flags |= NodeCheckFlags.PartiallyTypeChecked;             } */
        }
    }
    getDiagnostics := func(sourceFile SourceFile, ct CancellationToken, nodesToCheck []Node) []Diagnostic {
        /* TODO(TryStatement): try {             // Record the cancellation token so it can be checked later on during checkSourceElement.             // Do this in a finally block so we can ensure that it gets reset back to nothing after             // this call is done.             cancellationToken = ct;             return getDiagnosticsWorker(sourceFile, nodesToCheck);         }         finally {             cancellationToken = undefined;         } */
    }
    ensurePendingDiagnosticWorkComplete := func() {
        /* TODO(ForOfStatement): for (const cb of deferredDiagnosticsCallbacks) {             cb();         } */
        /* TODO(ExpressionStatement): deferredDiagnosticsCallbacks = []; */
    }
    checkSourceFileWithEagerDiagnostics := func(sourceFile SourceFile, nodesToCheck []Node) {
        /* TODO(ExpressionStatement): ensurePendingDiagnosticWorkComplete(); */
        oldAddLazyDiagnostics := addLazyDiagnostic
        /* TODO(ExpressionStatement): addLazyDiagnostic = cb => cb(); */
        /* TODO(ExpressionStatement): checkSourceFile(sourceFile, nodesToCheck); */
        /* TODO(ExpressionStatement): addLazyDiagnostic = oldAddLazyDiagnostics; */
    }
    getDiagnosticsWorker := func(sourceFile SourceFile, nodesToCheck /* TODO(ArrayType): Node[] */ any) []Diagnostic {
        if sourceFile {
            /* TODO(ExpressionStatement): ensurePendingDiagnosticWorkComplete(); */
            previousGlobalDiagnostics := /* TODO(PropertyAccessExpression): diagnostics.getGlobalDiagnostics */ TODO()
            previousGlobalDiagnosticsSize := /* TODO(PropertyAccessExpression): previousGlobalDiagnostics.length */ TODO
            /* TODO(ExpressionStatement): checkSourceFileWithEagerDiagnostics(sourceFile, nodesToCheck); */
            semanticDiagnostics := /* TODO(PropertyAccessExpression): diagnostics.getDiagnostics */ TODO(/* TODO(PropertyAccessExpression): sourceFile.fileName */ TODO)
            if nodesToCheck {
                 semanticDiagnostics
            }
            currentGlobalDiagnostics := /* TODO(PropertyAccessExpression): diagnostics.getGlobalDiagnostics */ TODO()
            if /* TODO(BinaryExpression): currentGlobalDiagnostics !== previousGlobalDiagnostics */ TODO {
                deferredGlobalDiagnostics := relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, compareDiagnostics)
                 concatenate(deferredGlobalDiagnostics, semanticDiagnostics)
            } else if /* TODO(BinaryExpression): previousGlobalDiagnosticsSize === 0 && currentGlobalDiagnostics.length > 0 */ TODO {
                 concatenate(currentGlobalDiagnostics, semanticDiagnostics)
            }
             semanticDiagnostics
        }
        /* TODO(ExpressionStatement): forEach(host.getSourceFiles(), file => checkSourceFileWithEagerDiagnostics(file)); */
         /* TODO(PropertyAccessExpression): diagnostics.getDiagnostics */ TODO()
    }
    getGlobalDiagnostics := func() []Diagnostic {
        /* TODO(ExpressionStatement): ensurePendingDiagnosticWorkComplete(); */
         /* TODO(PropertyAccessExpression): diagnostics.getGlobalDiagnostics */ TODO()
    }
    getSymbolsInScope := func(location Node, meaning SymbolFlags) []Symbol {
        if /* TODO(BinaryExpression): location.flags & NodeFlags.InWithStatement */ TODO {
             /* TODO(ArrayLiteralExpression): [] */ TODO
        }
        symbols := createSymbolTable()
        isStaticSymbol := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ExpressionStatement): populateSymbols(); */
        /* TODO(ExpressionStatement): symbols.delete(InternalSymbolName.This); */
         symbolsToArray(symbols)
        populateSymbols := func() {
            /* TODO(WhileStatement): while (location) {                 if (canHaveLocals(location) && location.locals && !isGlobalSourceFile(location)) {                     copySymbols(location.locals, meaning);                 }                  switch (location.kind) {                     case SyntaxKind.SourceFile:                         if (!isExternalModule(location as SourceFile)) break;                         // falls through                     case SyntaxKind.ModuleDeclaration:                         copyLocallyVisibleExportSymbols(getSymbolOfDeclaration(location as ModuleDeclaration | SourceFile).exports!, meaning & SymbolFlags.ModuleMember);                         break;                     case SyntaxKind.EnumDeclaration:                         copySymbols(getSymbolOfDeclaration(location as EnumDeclaration).exports!, meaning & SymbolFlags.EnumMember);                         break;                     case SyntaxKind.ClassExpression:                         const className = (location as ClassExpression).name;                         if (className) {                             copySymbol((location as ClassExpression).symbol, meaning);                         }                      // this fall-through is necessary because we would like to handle                     // type parameter inside class expression similar to how we handle it in classDeclaration and interface Declaration.                     // falls through                     case SyntaxKind.ClassDeclaration:                     case SyntaxKind.InterfaceDeclaration:                         // If we didn't come from static member of class or interface,                         // add the type parameters into the symbol table                         // (type parameters of classDeclaration/classExpression and interface are in member property of the symbol.                         // Note: that the memberFlags come from previous iteration.                         if (!isStaticSymbol) {                             copySymbols(getMembersOfSymbol(getSymbolOfDeclaration(location as ClassDeclaration | InterfaceDeclaration)), meaning & SymbolFlags.Type);                         }                         break;                     case SyntaxKind.FunctionExpression:                         const funcName = (location as FunctionExpression).name;                         if (funcName) {                             copySymbol((location as FunctionExpression).symbol, meaning);                         }                         break;                 }                  if (introducesArgumentsExoticObject(location)) {                     copySymbol(argumentsSymbol, meaning);                 }                  isStaticSymbol = isStatic(location);                 location = location.parent;             } */
            /* TODO(ExpressionStatement): copySymbols(globals, meaning); */
        }
        copySymbol := func(symbol Symbol, meaning SymbolFlags) {
            if /* TODO(BinaryExpression): getCombinedLocalAndExportSymbolFlags(symbol) & meaning */ TODO {
                id := /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO
                if /* TODO(PrefixUnaryExpression): !symbols.has(id) */ TODO {
                    /* TODO(ExpressionStatement): symbols.set(id, symbol); */
                }
            }
        }
        copySymbols := func(source SymbolTable, meaning SymbolFlags) {
            if meaning {
                /* TODO(ExpressionStatement): source.forEach(symbol => {                     copySymbol(symbol, meaning);                 }); */
            }
        }
        copyLocallyVisibleExportSymbols := func(source SymbolTable, meaning SymbolFlags) {
            if meaning {
                /* TODO(ExpressionStatement): source.forEach(symbol => {                     // Similar condition as in `resolveNameHelper`                     if (!getDeclarationOfKind(symbol, SyntaxKind.ExportSpecifier) && !getDeclarationOfKind(symbol, SyntaxKind.NamespaceExport) && symbol.escapedName !== InternalSymbolName.Default) {                         copySymbol(symbol, meaning);                     }                 }); */
            }
        }
    }
    isTypeDeclarationName := func(name Node) bool {
         /* TODO(BinaryExpression): name.kind === SyntaxKind.Identifier &&             isTypeDeclaration(name.parent) &&             getNameOfDeclaration(name.parent) === name */ TODO
    }
    isTypeReferenceIdentifier := func(node EntityName) bool {
        /* TODO(WhileStatement): while (node.parent.kind === SyntaxKind.QualifiedName) {             node = node.parent as QualifiedName;         } */
         /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.TypeReference */ TODO
    }
    isInNameOfExpressionWithTypeArguments := func(node Node) bool {
        /* TODO(WhileStatement): while (node.parent.kind === SyntaxKind.PropertyAccessExpression) {             node = node.parent;         } */
         /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.ExpressionWithTypeArguments */ TODO
    }
    forEachEnclosingClass := func(node Node, callback func(node ClassLikeDeclaration) *T) *T {
        var result *T
        containingClass := getContainingClass(node)
        /* TODO(WhileStatement): while (containingClass) {             if (result = callback(containingClass)) break;             containingClass = getContainingClass(containingClass);         } */
         result
    }
    isNodeUsedDuringClassInitialization := func(node Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!findAncestor(node, element => {             if (isConstructorDeclaration(element) && nodeIsPresent(element.body) || isPropertyDeclaration(element)) {                 return true;             }             else if (isClassLike(element) || isFunctionLikeDeclaration(element)) {                 return "quit";             }              return false;         }) */ TODO
    }
    isNodeWithinClass := func(node Node, classDeclaration ClassLikeDeclaration) /* TODO(undefined): boolean */ TODO {
         /* TODO(PrefixUnaryExpression): !!forEachEnclosingClass(node, n => n === classDeclaration) */ TODO
    }
    getLeftSideOfImportEqualsOrExportAssignment := func(nodeOnRightSide EntityName) /* TODO(UnionType): ImportEqualsDeclaration | ExportAssignment | undefined */ any {
        /* TODO(WhileStatement): while (nodeOnRightSide.parent.kind === SyntaxKind.QualifiedName) {             nodeOnRightSide = nodeOnRightSide.parent as QualifiedName;         } */
        if /* TODO(BinaryExpression): nodeOnRightSide.parent.kind === SyntaxKind.ImportEqualsDeclaration */ TODO {
             /* TODO(ConditionalExpression): (nodeOnRightSide.parent as ImportEqualsDeclaration).moduleReference === nodeOnRightSide ? nodeOnRightSide.parent as ImportEqualsDeclaration : undefined */ TODO
        }
        if /* TODO(BinaryExpression): nodeOnRightSide.parent.kind === SyntaxKind.ExportAssignment */ TODO {
             /* TODO(ConditionalExpression): (nodeOnRightSide.parent as ExportAssignment).expression === nodeOnRightSide as Node ? nodeOnRightSide.parent as ExportAssignment : undefined */ TODO
        }
         undefined
    }
    isInRightSideOfImportOrExportAssignment := func(node EntityName) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): getLeftSideOfImportEqualsOrExportAssignment(node) !== undefined */ TODO
    }
    getSpecialPropertyAssignmentSymbolFromEntityName := func(entityName /* TODO(UnionType): EntityName | PropertyAccessExpression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        specialPropertyAssignmentKind := getAssignmentDeclarationKind(/* TODO(PropertyAccessExpression): entityName.parent.parent */ TODO /* as */ /* TODO(TypeReference): BinaryExpression */)
        /* TODO(SwitchStatement): switch (specialPropertyAssignmentKind) {             case AssignmentDeclarationKind.ExportsProperty:             case AssignmentDeclarationKind.PrototypeProperty:                 return getSymbolOfNode(entityName.parent);             case AssignmentDeclarationKind.Property:                 if (isPropertyAccessExpression(entityName.parent) && getLeftmostAccessExpression(entityName.parent) === entityName) {                     return undefined;                 }                 // falls through             case AssignmentDeclarationKind.ThisProperty:             case AssignmentDeclarationKind.ModuleExports:                 return getSymbolOfDeclaration(entityName.parent.parent as BinaryExpression);         } */
    }
    isImportTypeQualifierPart := func(node EntityName) *ImportTypeNode {
        parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
        /* TODO(WhileStatement): while (isQualifiedName(parent)) {             node = parent;             parent = parent.parent;         } */
        if /* TODO(BinaryExpression): parent && parent.kind === SyntaxKind.ImportType && (parent as ImportTypeNode).qualifier === node */ TODO {
             parent /* as */ /* TODO(TypeReference): ImportTypeNode */
        }
         undefined
    }
    isThisPropertyAndThisTyped := func(node PropertyAccessExpression) /* TODO(undefined): boolean | undefined */ TODO {
        if /* TODO(BinaryExpression): node.expression.kind === SyntaxKind.ThisKeyword */ TODO {
            container := getThisContainer(node, /* TODO(FalseKeyword): false */ TODO, /* TODO(FalseKeyword): false */ TODO)
            if isFunctionLike(container) {
                containingLiteral := getContainingObjectLiteral(container)
                if containingLiteral {
                    contextualType := getApparentTypeOfContextualType(containingLiteral, undefined)
                    type_ := getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
                     /* TODO(BinaryExpression): type && !isTypeAny(type) */ TODO
                }
            }
        }
    }
    getSymbolOfNameOrPropertyAccessExpression := func(name /* TODO(UnionType): EntityName | PrivateIdentifier | PropertyAccessExpression | JSDocMemberName */ any) *Symbol {
        if isDeclarationName(name) {
             getSymbolOfNode(/* TODO(PropertyAccessExpression): name.parent */ TODO)
        }
        if /* TODO(BinaryExpression): isInJSFile(name) &&             name.parent.kind === SyntaxKind.PropertyAccessExpression &&             name.parent === (name.parent.parent as BinaryExpression).left */ TODO {
            if /* TODO(BinaryExpression): !isPrivateIdentifier(name) && !isJSDocMemberName(name) && !isThisPropertyAndThisTyped(name.parent as PropertyAccessExpression) */ TODO {
                specialPropertyAssignmentSymbol := getSpecialPropertyAssignmentSymbolFromEntityName(name)
                if specialPropertyAssignmentSymbol {
                     specialPropertyAssignmentSymbol
                }
            }
        }
        if /* TODO(BinaryExpression): name.parent.kind === SyntaxKind.ExportAssignment && isEntityNameExpression(name) */ TODO {
            success := resolveEntityName(name, /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias */ TODO, /* TODO(TrueKeyword): true */ TODO)
            if /* TODO(BinaryExpression): success && success !== unknownSymbol */ TODO {
                 success
            }
        } else if /* TODO(BinaryExpression): isEntityName(name) && isInRightSideOfImportOrExportAssignment(name) */ TODO {
            importEqualsDeclaration := getAncestor(name, /* TODO(PropertyAccessExpression): SyntaxKind.ImportEqualsDeclaration */ TODO)
            /* TODO(ExpressionStatement): Debug.assert(importEqualsDeclaration !== undefined); */
             getSymbolOfPartOfRightHandSideOfImportEquals(name, /* TODO(TrueKeyword): true */ TODO)
        }
        if isEntityName(name) {
            possibleImportNode := isImportTypeQualifierPart(name)
            if possibleImportNode {
                /* TODO(ExpressionStatement): getTypeFromTypeNode(possibleImportNode); */
                sym := /* TODO(PropertyAccessExpression): getNodeLinks(name).resolvedSymbol */ TODO
                 /* TODO(ConditionalExpression): sym === unknownSymbol ? undefined : sym */ TODO
            }
        }
        /* TODO(WhileStatement): while (isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(name)) {             name = name.parent as QualifiedName | PropertyAccessEntityNameExpression | JSDocMemberName;         } */
        if isInNameOfExpressionWithTypeArguments(name) {
            meaning := /* TODO(PropertyAccessExpression): SymbolFlags.None */ TODO
            if /* TODO(BinaryExpression): name.parent.kind === SyntaxKind.ExpressionWithTypeArguments */ TODO {
                /* TODO(ExpressionStatement): meaning = isPartOfTypeNode(name) ? SymbolFlags.Type : SymbolFlags.Value; */
                if isExpressionWithTypeArgumentsInClassExtendsClause(/* TODO(PropertyAccessExpression): name.parent */ TODO) {
                    /* TODO(ExpressionStatement): meaning |= SymbolFlags.Value; */
                }
            } else {
                /* TODO(ExpressionStatement): meaning = SymbolFlags.Namespace; */
            }
            /* TODO(ExpressionStatement): meaning |= SymbolFlags.Alias; */
            entityNameSymbol := /* TODO(ConditionalExpression): isEntityNameExpression(name) ? resolveEntityName(name, meaning, /*ignoreErrors* / true) : undefined */ TODO
            if entityNameSymbol {
                 entityNameSymbol
            }
        }
        if /* TODO(BinaryExpression): name.parent.kind === SyntaxKind.JSDocParameterTag */ TODO {
             getParameterSymbolFromJSDoc(/* TODO(PropertyAccessExpression): name.parent */ TODO /* as */ /* TODO(TypeReference): JSDocParameterTag */)
        }
        if /* TODO(BinaryExpression): name.parent.kind === SyntaxKind.TypeParameter && name.parent.parent.kind === SyntaxKind.JSDocTemplateTag */ TODO {
            /* TODO(ExpressionStatement): Debug.assert(!isInJSFile(name)); */
            typeParameter := getTypeParameterFromJsDoc(/* TODO(PropertyAccessExpression): name.parent */ TODO /* as */ /* TODO(IntersectionType): TypeParameterDeclaration & { parent: JSDocTemplateTag; } */)
             /* TODO(BinaryExpression): typeParameter && typeParameter.symbol */ TODO
        }
        if isExpressionNode(name) {
            if nodeIsMissing(name) {
                 undefined
            }
            isJSDoc := findAncestor(name, or(isJSDocLinkLike, isJSDocNameReference, isJSDocMemberName))
            meaning := /* TODO(ConditionalExpression): isJSDoc ? SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Value : SymbolFlags.Value */ TODO
            if /* TODO(BinaryExpression): name.kind === SyntaxKind.Identifier */ TODO {
                if /* TODO(BinaryExpression): isJSXTagName(name) && isJsxIntrinsicTagName(name) */ TODO {
                    symbol := getIntrinsicTagSymbol(/* TODO(PropertyAccessExpression): name.parent */ TODO /* as */ /* TODO(TypeReference): JsxOpeningLikeElement */)
                     /* TODO(ConditionalExpression): symbol === unknownSymbol ? undefined : symbol */ TODO
                }
                result := resolveEntityName(name, meaning, /* TODO(TrueKeyword): true */ TODO, /* TODO(TrueKeyword): true */ TODO, getHostSignatureFromJSDoc(name))
                if /* TODO(BinaryExpression): !result && isJSDoc */ TODO {
                    container := findAncestor(name, or(isClassLike, isInterfaceDeclaration))
                    if container {
                         resolveJSDocMemberName(name, /* TODO(TrueKeyword): true */ TODO, getSymbolOfDeclaration(container))
                    }
                }
                if /* TODO(BinaryExpression): result && isJSDoc */ TODO {
                    container := getJSDocHost(name)
                    if /* TODO(BinaryExpression): container && isEnumMember(container) && container === result.valueDeclaration */ TODO {
                         /* TODO(BinaryExpression): resolveEntityName(name, meaning, /*ignoreErrors* / true, /*dontResolveAlias* / true, getSourceFileOfNode(container)) || result */ TODO
                    }
                }
                 result
            } else if isPrivateIdentifier(name) {
                 getSymbolForPrivateIdentifierExpression(name)
            } else if /* TODO(BinaryExpression): name.kind === SyntaxKind.PropertyAccessExpression || name.kind === SyntaxKind.QualifiedName */ TODO {
                links := getNodeLinks(name)
                if /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO {
                     /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO
                }
                if /* TODO(BinaryExpression): name.kind === SyntaxKind.PropertyAccessExpression */ TODO {
                    /* TODO(ExpressionStatement): checkPropertyAccessExpression(name, CheckMode.Normal); */
                    if /* TODO(PrefixUnaryExpression): !links.resolvedSymbol */ TODO {
                        /* TODO(ExpressionStatement): links.resolvedSymbol = getApplicableIndexSymbol(checkExpressionCached(name.expression), getLiteralTypeFromPropertyName(name.name)); */
                    }
                } else {
                    /* TODO(ExpressionStatement): checkQualifiedName(name, CheckMode.Normal); */
                }
                if /* TODO(BinaryExpression): !links.resolvedSymbol && isJSDoc && isQualifiedName(name) */ TODO {
                     resolveJSDocMemberName(name)
                }
                 /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO
            } else if isJSDocMemberName(name) {
                 resolveJSDocMemberName(name)
            }
        } else if isTypeReferenceIdentifier(name /* as */ /* TODO(TypeReference): EntityName */) {
            meaning := /* TODO(ConditionalExpression): name.parent.kind === SyntaxKind.TypeReference ? SymbolFlags.Type : SymbolFlags.Namespace */ TODO
            symbol := resolveEntityName(name /* as */ /* TODO(TypeReference): EntityName */, meaning, /* TODO(FalseKeyword): false */ TODO, /* TODO(TrueKeyword): true */ TODO)
             /* TODO(ConditionalExpression): symbol && symbol !== unknownSymbol ? symbol : getUnresolvedSymbolForEntityName(name as EntityName) */ TODO
        }
        if /* TODO(BinaryExpression): name.parent.kind === SyntaxKind.TypePredicate */ TODO {
             resolveEntityName(name /* as */ /* TODO(TypeReference): Identifier */, /* TODO(PropertyAccessExpression): SymbolFlags.FunctionScopedVariable */ TODO)
        }
         undefined
    }
    getApplicableIndexSymbol := func(type_ Type, keyType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        infos := getApplicableIndexInfos(type_, keyType)
        if /* TODO(BinaryExpression): infos.length && (type as ObjectType).members */ TODO {
            symbol := getIndexSymbolFromSymbolTable(/* TODO(PropertyAccessExpression): resolveStructuredTypeMembers(type as ObjectType).members */ TODO)
            if /* TODO(BinaryExpression): infos === getIndexInfosOfType(type) */ TODO {
                 symbol
            } else if symbol {
                symbolLinks := getSymbolLinks(symbol)
                declarationList := mapDefined(infos, /* TODO(ArrowFunction): i => i.declaration */ TODO)
                nodeListId := /* TODO(PropertyAccessExpression): map(declarationList, getNodeId).join */ TODO(",")
                if /* TODO(PrefixUnaryExpression): !symbolLinks.filteredIndexSymbolCache */ TODO {
                    /* TODO(ExpressionStatement): symbolLinks.filteredIndexSymbolCache = new Map(); */
                }
                if /* TODO(PropertyAccessExpression): symbolLinks.filteredIndexSymbolCache.has */ TODO(nodeListId) {
                     /* TODO(NonNullExpression): symbolLinks.filteredIndexSymbolCache.get(nodeListId)! */ TODO
                } else {
                    copy := createSymbol(/* TODO(PropertyAccessExpression): SymbolFlags.Signature */ TODO, /* TODO(PropertyAccessExpression): InternalSymbolName.Index */ TODO)
                    /* TODO(ExpressionStatement): copy.declarations = mapDefined(infos, i => i.declaration); */
                    /* TODO(ExpressionStatement): copy.parent = type.aliasSymbol ? type.aliasSymbol : type.symbol ? type.symbol : getSymbolAtLocation(copy.declarations[0].parent); */
                    /* TODO(ExpressionStatement): symbolLinks.filteredIndexSymbolCache.set(nodeListId, copy); */
                     copy
                }
            }
        }
    }
    resolveJSDocMemberName := func(name /* TODO(UnionType): EntityName | JSDocMemberName */ any, ignoreErrors bool, container Symbol) *Symbol {
        if isEntityName(name) {
            meaning := /* TODO(BinaryExpression): SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Value */ TODO
            symbol := resolveEntityName(name, meaning, ignoreErrors, /* TODO(TrueKeyword): true */ TODO, getHostSignatureFromJSDoc(name))
            if /* TODO(BinaryExpression): !symbol && isIdentifier(name) && container */ TODO {
                /* TODO(ExpressionStatement): symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(container), name.escapedText, meaning)); */
            }
            if symbol {
                 symbol
            }
        }
        left := /* TODO(ConditionalExpression): isIdentifier(name) ? container : resolveJSDocMemberName(name.left, ignoreErrors, container) */ TODO
        right := /* TODO(ConditionalExpression): isIdentifier(name) ? name.escapedText : name.right.escapedText */ TODO
        if left {
            proto := /* TODO(BinaryExpression): left.flags & SymbolFlags.Value && getPropertyOfType(getTypeOfSymbol(left), "prototype" as __String) */ TODO
            t := /* TODO(ConditionalExpression): proto ? getTypeOfSymbol(proto) : getDeclaredTypeOfSymbol(left) */ TODO
             getPropertyOfType(t, right)
        }
    }
    getSymbolAtLocation := func(node Node, ignoreErrors bool) *Symbol {
        if isSourceFile(node) {
             /* TODO(ConditionalExpression): isExternalModule(node) ? getMergedSymbol(node.symbol) : undefined */ TODO
        }
        TODO_IDENTIFIER := node
        grandParent := /* TODO(PropertyAccessExpression): parent.parent */ TODO
        if /* TODO(BinaryExpression): node.flags & NodeFlags.InWithStatement */ TODO {
             undefined
        }
        if isDeclarationNameOrImportPropertyName(node) {
            parentSymbol := getSymbolOfDeclaration(parent /* as */ /* TODO(TypeReference): Declaration */)
             /* TODO(ConditionalExpression): isImportOrExportSpecifier(node.parent) && node.parent.propertyName === node                 ? getImmediateAliasedSymbol(parentSymbol)                 : parentSymbol */ TODO
        } else if isLiteralComputedPropertyDeclarationName(node) {
             getSymbolOfDeclaration(/* TODO(PropertyAccessExpression): parent.parent */ TODO /* as */ /* TODO(TypeReference): Declaration */)
        }
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.Identifier */ TODO {
            if isInRightSideOfImportOrExportAssignment(node /* as */ /* TODO(TypeReference): Identifier */) {
                 getSymbolOfNameOrPropertyAccessExpression(node /* as */ /* TODO(TypeReference): Identifier */)
            } else if /* TODO(BinaryExpression): parent.kind === SyntaxKind.BindingElement &&                 grandParent.kind === SyntaxKind.ObjectBindingPattern &&                 node === (parent as BindingElement).propertyName */ TODO {
                typeOfPattern := getTypeOfNode(grandParent)
                propertyDeclaration := getPropertyOfType(typeOfPattern, /* TODO(PropertyAccessExpression): (node as Identifier).escapedText */ TODO)
                if propertyDeclaration {
                     propertyDeclaration
                }
            } else if /* TODO(BinaryExpression): isMetaProperty(parent) && parent.name === node */ TODO {
                if /* TODO(BinaryExpression): parent.keywordToken === SyntaxKind.NewKeyword && idText(node as Identifier) === "target" */ TODO {
                     /* TODO(PropertyAccessExpression): checkNewTargetMetaProperty(parent).symbol */ TODO
                }
                if /* TODO(BinaryExpression): parent.keywordToken === SyntaxKind.ImportKeyword && idText(node as Identifier) === "meta" */ TODO {
                     /* TODO(PropertyAccessExpression): getGlobalImportMetaExpressionType().members!.get */ TODO("meta" /* as */ /* TODO(TypeReference): __String */)
                }
                 undefined
            }
        }
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:             case SyntaxKind.PrivateIdentifier:             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.QualifiedName:                 if (!isThisInTypeQuery(node)) {                     return getSymbolOfNameOrPropertyAccessExpression(node as EntityName | PrivateIdentifier | PropertyAccessExpression);                 }                 // falls through              case SyntaxKind.ThisKeyword:                 const container = getThisContainer(node, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false);                 if (isFunctionLike(container)) {                     const sig = getSignatureFromDeclaration(container);                     if (sig.thisParameter) {                         return sig.thisParameter;                     }                 }                 if (isInExpressionContext(node)) {                     return checkExpression(node as Expression).symbol;                 }                 // falls through              case SyntaxKind.ThisType:                 return getTypeFromThisTypeNode(node as ThisExpression | ThisTypeNode).symbol;              case SyntaxKind.SuperKeyword:                 return checkExpression(node as Expression).symbol;              case SyntaxKind.ConstructorKeyword:                 // constructor keyword for an overload, should take us to the definition if it exist                 const constructorDeclaration = node.parent;                 if (constructorDeclaration && constructorDeclaration.kind === SyntaxKind.Constructor) {                     return (constructorDeclaration.parent as ClassDeclaration).symbol;                 }                 return undefined;              case SyntaxKind.StringLiteral:             case SyntaxKind.NoSubstitutionTemplateLiteral:                 // 1). import x = require("./mo/*gotToDefinitionHere* /d")                 // 2). External module name in an import declaration                 // 3). Dynamic import call or require in javascript                 // 4). type A = import("./f/*gotToDefinitionHere* /oo")                 if (                     (isExternalModuleImportEqualsDeclaration(node.parent.parent) && getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node) ||                     ((node.parent.kind === SyntaxKind.ImportDeclaration || node.parent.kind === SyntaxKind.ExportDeclaration) && (node.parent as ImportDeclaration).moduleSpecifier === node) ||                     (isInJSFile(node) && isJSDocImportTag(node.parent) && node.parent.moduleSpecifier === node) ||                     ((isInJSFile(node) && isRequireCall(node.parent, /*requireStringLiteralLikeArgument* / false)) || isImportCall(node.parent)) ||                     (isLiteralTypeNode(node.parent) && isLiteralImportTypeNode(node.parent.parent) && node.parent.parent.argument === node.parent)                 ) {                     return resolveExternalModuleName(node, node as LiteralExpression, ignoreErrors);                 }                 if (isCallExpression(parent) && isBindableObjectDefinePropertyCall(parent) && parent.arguments[1] === node) {                     return getSymbolOfDeclaration(parent);                 }                 // falls through              case SyntaxKind.NumericLiteral:                 // index access                 const objectType = isElementAccessExpression(parent)                     ? parent.argumentExpression === node ? getTypeOfExpression(parent.expression) : undefined                     : isLiteralTypeNode(parent) && isIndexedAccessTypeNode(grandParent)                     ? getTypeFromTypeNode(grandParent.objectType)                     : undefined;                 return objectType && getPropertyOfType(objectType, escapeLeadingUnderscores((node as StringLiteral | NumericLiteral).text));              case SyntaxKind.DefaultKeyword:             case SyntaxKind.FunctionKeyword:             case SyntaxKind.EqualsGreaterThanToken:             case SyntaxKind.ClassKeyword:                 return getSymbolOfNode(node.parent);             case SyntaxKind.ImportType:                 return isLiteralImportTypeNode(node) ? getSymbolAtLocation(node.argument.literal, ignoreErrors) : undefined;              case SyntaxKind.ExportKeyword:                 return isExportAssignment(node.parent) ? Debug.checkDefined(node.parent.symbol) : undefined;              case SyntaxKind.ImportKeyword:             case SyntaxKind.NewKeyword:                 return isMetaProperty(node.parent) ? checkMetaPropertyKeyword(node.parent).symbol : undefined;             case SyntaxKind.InstanceOfKeyword:                 if (isBinaryExpression(node.parent)) {                     const type = getTypeOfExpression(node.parent.right);                     const hasInstanceMethodType = getSymbolHasInstanceMethodOfObjectType(type);                     return hasInstanceMethodType?.symbol ?? type.symbol;                 }                 return undefined;             case SyntaxKind.MetaProperty:                 return checkExpression(node as Expression).symbol;             case SyntaxKind.JsxNamespacedName:                 if (isJSXTagName(node) && isJsxIntrinsicTagName(node)) {                     const symbol = getIntrinsicTagSymbol(node.parent as JsxOpeningLikeElement);                     return symbol === unknownSymbol ? undefined : symbol;                 }                 // falls through              default:                 return undefined;         } */
    }
    getIndexInfosAtLocation := func(node Node) /* TODO(TypeOperator): readonly IndexInfo[] */ any {
        if /* TODO(BinaryExpression): isIdentifier(node) && isPropertyAccessExpression(node.parent) && node.parent.name === node */ TODO {
            keyType := getLiteralTypeFromPropertyName(node)
            objectType := getTypeOfExpression(/* TODO(PropertyAccessExpression): node.parent.expression */ TODO)
            objectTypes := /* TODO(ConditionalExpression): objectType.flags & TypeFlags.Union ? (objectType as UnionType).types : [objectType] */ TODO
             flatMap(objectTypes, /* TODO(ArrowFunction): t => filter(getIndexInfosOfType(t), info => isApplicableIndexType(keyType, info.keyType)) */ TODO)
        }
         undefined
    }
    getShorthandAssignmentValueSymbol := func(location Node) *Symbol {
        if /* TODO(BinaryExpression): location && location.kind === SyntaxKind.ShorthandPropertyAssignment */ TODO {
             resolveEntityName(/* TODO(PropertyAccessExpression): (location as ShorthandPropertyAssignment).name */ TODO, /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Alias */ TODO)
        }
         undefined
    }
    getExportSpecifierLocalTargetSymbol := func(node /* TODO(UnionType): ExportSpecifier | Identifier */ any) *Symbol {
        if isExportSpecifier(node) {
            name := /* TODO(BinaryExpression): node.propertyName || node.name */ TODO
             /* TODO(ConditionalExpression): node.parent.parent.moduleSpecifier ?                 getExternalModuleMember(node.parent.parent, node) :                 name.kind === SyntaxKind.StringLiteral ? undefined : // Skip for invalid syntax like this: export { "x" }                 resolveEntityName(name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias) */ TODO
        } else {
             resolveEntityName(node, /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias */ TODO)
        }
    }
    getTypeOfNode := func(node Node) Type {
        if /* TODO(BinaryExpression): isSourceFile(node) && !isExternalModule(node) */ TODO {
             errorType
        }
        if /* TODO(BinaryExpression): node.flags & NodeFlags.InWithStatement */ TODO {
             errorType
        }
        classDecl := tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node)
        classType := /* TODO(BinaryExpression): classDecl && getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(classDecl.class)) */ TODO
        if isPartOfTypeNode(node) {
            typeFromTypeNode := getTypeFromTypeNode(node /* as */ /* TODO(TypeReference): TypeNode */)
             /* TODO(ConditionalExpression): classType ? getTypeWithThisArgument(typeFromTypeNode, classType.thisType) : typeFromTypeNode */ TODO
        }
        if isExpressionNode(node) {
             getRegularTypeOfExpression(node /* as */ /* TODO(TypeReference): Expression */)
        }
        if /* TODO(BinaryExpression): classType && !classDecl.isImplements */ TODO {
            baseType := firstOrUndefined(getBaseTypes(classType))
             /* TODO(ConditionalExpression): baseType ? getTypeWithThisArgument(baseType, classType.thisType) : errorType */ TODO
        }
        if isTypeDeclaration(node) {
            symbol := getSymbolOfDeclaration(node)
             getDeclaredTypeOfSymbol(symbol)
        }
        if isTypeDeclarationName(node) {
            symbol := getSymbolAtLocation(node)
             /* TODO(ConditionalExpression): symbol ? getDeclaredTypeOfSymbol(symbol) : errorType */ TODO
        }
        if isBindingElement(node) {
             /* TODO(BinaryExpression): getTypeForVariableLikeDeclaration(node, /*includeOptionality* / true, CheckMode.Normal) || errorType */ TODO
        }
        if isDeclaration(node) {
            symbol := getSymbolOfDeclaration(node)
             /* TODO(ConditionalExpression): symbol ? getTypeOfSymbol(symbol) : errorType */ TODO
        }
        if isDeclarationNameOrImportPropertyName(node) {
            symbol := getSymbolAtLocation(node)
            if symbol {
                 getTypeOfSymbol(symbol)
            }
             errorType
        }
        if isBindingPattern(node) {
             /* TODO(BinaryExpression): getTypeForVariableLikeDeclaration(node.parent, /*includeOptionality* / true, CheckMode.Normal) || errorType */ TODO
        }
        if isInRightSideOfImportOrExportAssignment(node /* as */ /* TODO(TypeReference): Identifier */) {
            symbol := getSymbolAtLocation(node)
            if symbol {
                declaredType := getDeclaredTypeOfSymbol(symbol)
                 /* TODO(ConditionalExpression): !isErrorType(declaredType) ? declaredType : getTypeOfSymbol(symbol) */ TODO
            }
        }
        if /* TODO(BinaryExpression): isMetaProperty(node.parent) && node.parent.keywordToken === node.kind */ TODO {
             checkMetaPropertyKeyword(/* TODO(PropertyAccessExpression): node.parent */ TODO)
        }
        if isImportAttributes(node) {
             getGlobalImportAttributesType(/* TODO(FalseKeyword): false */ TODO)
        }
         errorType
    }
    getTypeOfAssignmentPattern := func(expr AssignmentPattern) *Type {
        /* TODO(ExpressionStatement): Debug.assert(expr.kind === SyntaxKind.ObjectLiteralExpression || expr.kind === SyntaxKind.ArrayLiteralExpression); */
        if /* TODO(BinaryExpression): expr.parent.kind === SyntaxKind.ForOfStatement */ TODO {
            iteratedType := checkRightHandSideOfForOf(/* TODO(PropertyAccessExpression): expr.parent */ TODO /* as */ /* TODO(TypeReference): ForOfStatement */)
             checkDestructuringAssignment(expr, /* TODO(BinaryExpression): iteratedType || errorType */ TODO)
        }
        if /* TODO(BinaryExpression): expr.parent.kind === SyntaxKind.BinaryExpression */ TODO {
            iteratedType := getTypeOfExpression(/* TODO(PropertyAccessExpression): (expr.parent as BinaryExpression).right */ TODO)
             checkDestructuringAssignment(expr, /* TODO(BinaryExpression): iteratedType || errorType */ TODO)
        }
        if /* TODO(BinaryExpression): expr.parent.kind === SyntaxKind.PropertyAssignment */ TODO {
            node := cast(/* TODO(PropertyAccessExpression): expr.parent.parent */ TODO, isObjectLiteralExpression)
            typeOfParentObjectLiteral := /* TODO(BinaryExpression): getTypeOfAssignmentPattern(node) || errorType */ TODO
            propertyIndex := indexOfNode(/* TODO(PropertyAccessExpression): node.properties */ TODO, /* TODO(PropertyAccessExpression): expr.parent */ TODO)
             checkObjectLiteralDestructuringPropertyAssignment(node, typeOfParentObjectLiteral, propertyIndex)
        }
        node := cast(/* TODO(PropertyAccessExpression): expr.parent */ TODO, isArrayLiteralExpression)
        typeOfArrayLiteral := /* TODO(BinaryExpression): getTypeOfAssignmentPattern(node) || errorType */ TODO
        elementType := /* TODO(BinaryExpression): checkIteratedTypeOrElementType(IterationUse.Destructuring, typeOfArrayLiteral, undefinedType, expr.parent) || errorType */ TODO
         checkArrayLiteralDestructuringElementAssignment(node, typeOfArrayLiteral, /* TODO(PropertyAccessExpression): node.elements.indexOf */ TODO(expr), elementType)
    }
    getPropertySymbolOfDestructuringAssignment := func(location Identifier) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
        typeOfObjectLiteral := getTypeOfAssignmentPattern(cast(/* TODO(PropertyAccessExpression): location.parent.parent */ TODO, isAssignmentPattern))
         /* TODO(BinaryExpression): typeOfObjectLiteral && getPropertyOfType(typeOfObjectLiteral, location.escapedText) */ TODO
    }
    getRegularTypeOfExpression := func(expr Expression) Type {
        if isRightSideOfQualifiedNameOrPropertyAccess(expr) {
            /* TODO(ExpressionStatement): expr = expr.parent as Expression; */
        }
         getRegularTypeOfLiteralType(getTypeOfExpression(expr))
    }
    getParentTypeOfClassElement := func(node ClassElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        classSymbol := /* TODO(NonNullExpression): getSymbolOfNode(node.parent)! */ TODO
         /* TODO(ConditionalExpression): isStatic(node)             ? getTypeOfSymbol(classSymbol)             : getDeclaredTypeOfSymbol(classSymbol) */ TODO
    }
    getClassElementPropertyKeyType := func(element ClassElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        name := /* TODO(NonNullExpression): element.name! */ TODO
        /* TODO(SwitchStatement): switch (name.kind) {             case SyntaxKind.Identifier:                 return getStringLiteralType(idText(name));             case SyntaxKind.NumericLiteral:             case SyntaxKind.StringLiteral:                 return getStringLiteralType(name.text);             case SyntaxKind.ComputedPropertyName:                 const nameType = checkComputedPropertyName(name);                 return isTypeAssignableToKind(nameType, TypeFlags.ESSymbolLike) ? nameType : stringType;             default:                 return Debug.fail("Unsupported property name.");         } */
    }
    getAugmentedPropertiesOfType := func(type_ Type) []Symbol {
        /* TODO(ExpressionStatement): type = getApparentType(type); */
        propsByName := createSymbolTable(getPropertiesOfType(type_))
        functionType := /* TODO(ConditionalExpression): getSignaturesOfType(type, SignatureKind.Call).length ? globalCallableFunctionType :             getSignaturesOfType(type, SignatureKind.Construct).length ? globalNewableFunctionType :             undefined */ TODO
        if functionType {
            /* TODO(ExpressionStatement): forEach(getPropertiesOfType(functionType), p => {                 if (!propsByName.has(p.escapedName)) {                     propsByName.set(p.escapedName, p);                 }             }); */
        }
         getNamedMembers(propsByName)
    }
    typeHasCallOrConstructSignatures := func(type_ Type) bool {
         /* TODO(BinaryExpression): getSignaturesOfType(type, SignatureKind.Call).length !== 0 || getSignaturesOfType(type, SignatureKind.Construct).length !== 0 */ TODO
    }
    getRootSymbols := func(symbol Symbol) []Symbol {
        roots := getImmediateRootSymbols(symbol)
         /* TODO(ConditionalExpression): roots ? flatMap(roots, getRootSymbols) : [symbol] */ TODO
    }
    getImmediateRootSymbols := func(symbol Symbol) /* TODO(TypeOperator): readonly Symbol[] */ any {
        if /* TODO(BinaryExpression): getCheckFlags(symbol) & CheckFlags.Synthetic */ TODO {
             mapDefined(/* TODO(PropertyAccessExpression): getSymbolLinks(symbol).containingType!.types */ TODO, /* TODO(ArrowFunction): type => getPropertyOfType(type, symbol.escapedName) */ TODO)
        } else if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Transient */ TODO {
            TODO_IDENTIFIER := symbol /* as */ /* TODO(TypeReference): TransientSymbol */
             /* TODO(ConditionalExpression): leftSpread ? [leftSpread, rightSpread!]                 : syntheticOrigin ? [syntheticOrigin]                 : singleElementArray(tryGetTarget(symbol)) */ TODO
        }
         undefined
    }
    tryGetTarget := func(symbol Symbol) *Symbol {
        var target *Symbol
        var next *Symbol = symbol
        /* TODO(WhileStatement): while (next = getSymbolLinks(next).target) {             target = next;         } */
         target
    }
    isArgumentsLocalBinding := func(nodeIn Identifier) bool {
        if isGeneratedIdentifier(nodeIn) {
            /* TODO(FalseKeyword): false */
        }
        node := getParseTreeNode(nodeIn, isIdentifier)
        if /* TODO(PrefixUnaryExpression): !node */ TODO {
            /* TODO(FalseKeyword): false */
        }
        parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
        if /* TODO(PrefixUnaryExpression): !parent */ TODO {
            /* TODO(FalseKeyword): false */
        }
        isPropertyName := /* TODO(BinaryExpression): (isPropertyAccessExpression(parent)             || isPropertyAssignment(parent))             && parent.name === node */ TODO
         /* TODO(BinaryExpression): !isPropertyName && getReferencedValueSymbol(node) === argumentsSymbol */ TODO
    }
    isNameOfModuleOrEnumDeclaration := func(node Identifier) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isModuleOrEnumDeclaration(node.parent) && node === node.parent.name */ TODO
    }
    getReferencedExportContainer := func(nodeIn Identifier, prefixLocals bool) /* TODO(UnionType): SourceFile | ModuleDeclaration | EnumDeclaration | undefined */ any {
        node := getParseTreeNode(nodeIn, isIdentifier)
        if node {
            symbol := getReferencedValueSymbol(node, isNameOfModuleOrEnumDeclaration(node))
            if symbol {
                if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ExportValue */ TODO {
                    exportSymbol := getMergedSymbol(/* TODO(NonNullExpression): symbol.exportSymbol! */ TODO)
                    if /* TODO(BinaryExpression): !prefixLocals && exportSymbol.flags & SymbolFlags.ExportHasLocal && !(exportSymbol.flags & SymbolFlags.Variable) */ TODO {
                         undefined
                    }
                    /* TODO(ExpressionStatement): symbol = exportSymbol; */
                }
                parentSymbol := getParentOfSymbol(symbol)
                if parentSymbol {
                    if /* TODO(BinaryExpression): parentSymbol.flags & SymbolFlags.ValueModule && parentSymbol.valueDeclaration?.kind === SyntaxKind.SourceFile */ TODO {
                        symbolFile := /* TODO(PropertyAccessExpression): parentSymbol.valueDeclaration */ TODO /* as */ /* TODO(TypeReference): SourceFile */
                        referenceFile := getSourceFileOfNode(node)
                        symbolIsUmdExport := /* TODO(BinaryExpression): symbolFile !== referenceFile */ TODO
                         /* TODO(ConditionalExpression): symbolIsUmdExport ? undefined : symbolFile */ TODO
                    }
                     findAncestor(/* TODO(PropertyAccessExpression): node.parent */ TODO, /* TODO(ArrowFunction): (n): n is ModuleDeclaration | EnumDeclaration => isModuleOrEnumDeclaration(n) && getSymbolOfDeclaration(n) === parentSymbol */ TODO)
                }
            }
        }
    }
    getReferencedImportDeclaration := func(nodeIn Identifier) Declaration {
        specifier := getIdentifierGeneratedImportReference(nodeIn)
        if specifier {
             specifier
        }
        node := getParseTreeNode(nodeIn, isIdentifier)
        if node {
            symbol := getReferencedValueOrAliasSymbol(node)
            if /* TODO(BinaryExpression): isNonLocalAlias(symbol, /*excludes* / SymbolFlags.Value) && !getTypeOnlyAliasDeclaration(symbol, SymbolFlags.Value) */ TODO {
                 getDeclarationOfAliasSymbol(symbol)
            }
        }
         undefined
    }
    isSymbolOfDestructuredElementOfCatchBinding := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
         /* TODO(BinaryExpression): symbol.valueDeclaration             && isBindingElement(symbol.valueDeclaration)             && walkUpBindingElementsAndPatterns(symbol.valueDeclaration).parent.kind === SyntaxKind.CatchClause */ TODO
    }
    isSymbolOfDeclarationWithCollidingName := func(symbol Symbol) bool {
        if /* TODO(BinaryExpression): symbol.flags & SymbolFlags.BlockScoped && symbol.valueDeclaration && !isSourceFile(symbol.valueDeclaration) */ TODO {
            links := getSymbolLinks(symbol)
            if /* TODO(BinaryExpression): links.isDeclarationWithCollidingName === undefined */ TODO {
                container := getEnclosingBlockScopeContainer(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
                if /* TODO(BinaryExpression): isStatementWithLocals(container) || isSymbolOfDestructuredElementOfCatchBinding(symbol) */ TODO {
                    if resolveName(/* TODO(PropertyAccessExpression): container.parent */ TODO, /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO, undefined, /* TODO(FalseKeyword): false */ TODO) {
                        /* TODO(ExpressionStatement): links.isDeclarationWithCollidingName = true; */
                    } else if hasNodeCheckFlag(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO, /* TODO(PropertyAccessExpression): NodeCheckFlags.CapturedBlockScopedBinding */ TODO) {
                        isDeclaredInLoop := hasNodeCheckFlag(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO, /* TODO(PropertyAccessExpression): NodeCheckFlags.BlockScopedBindingInLoop */ TODO)
                        inLoopInitializer := isIterationStatement(container, /* TODO(FalseKeyword): false */ TODO)
                        inLoopBodyBlock := /* TODO(BinaryExpression): container.kind === SyntaxKind.Block && isIterationStatement(container.parent, /*lookInLabeledStatements* / false) */ TODO
                        /* TODO(ExpressionStatement): links.isDeclarationWithCollidingName = !isBlockScopedContainerTopLevel(container) && (!isDeclaredInLoop || (!inLoopInitializer && !inLoopBodyBlock)); */
                    } else {
                        /* TODO(ExpressionStatement): links.isDeclarationWithCollidingName = false; */
                    }
                }
            }
             /* TODO(NonNullExpression): links.isDeclarationWithCollidingName! */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    getReferencedDeclarationWithCollidingName := func(nodeIn Identifier) Declaration {
        if /* TODO(PrefixUnaryExpression): !isGeneratedIdentifier(nodeIn) */ TODO {
            node := getParseTreeNode(nodeIn, isIdentifier)
            if node {
                symbol := getReferencedValueSymbol(node)
                if /* TODO(BinaryExpression): symbol && isSymbolOfDeclarationWithCollidingName(symbol) */ TODO {
                     /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
                }
            }
        }
         undefined
    }
    isDeclarationWithCollidingName := func(nodeIn Declaration) bool {
        node := getParseTreeNode(nodeIn, isDeclaration)
        if node {
            symbol := getSymbolOfDeclaration(node)
            if symbol {
                 isSymbolOfDeclarationWithCollidingName(symbol)
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isValueAliasDeclaration := func(node Node) bool {
        /* TODO(ExpressionStatement): Debug.assert(canCollectSymbolAliasAccessabilityData); */
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ImportEqualsDeclaration:                 return isAliasResolvedToValue(getSymbolOfDeclaration(node as ImportEqualsDeclaration));             case SyntaxKind.ImportClause:             case SyntaxKind.NamespaceImport:             case SyntaxKind.ImportSpecifier:             case SyntaxKind.ExportSpecifier:                 const symbol = getSymbolOfDeclaration(node as ImportClause | NamespaceImport | ImportSpecifier | ExportSpecifier);                 return !!symbol && isAliasResolvedToValue(symbol, /*excludeTypeOnlyValues* / true);             case SyntaxKind.ExportDeclaration:                 const exportClause = (node as ExportDeclaration).exportClause;                 return !!exportClause && (                     isNamespaceExport(exportClause) ||                     some(exportClause.elements, isValueAliasDeclaration)                 );             case SyntaxKind.ExportAssignment:                 return (node as ExportAssignment).expression && (node as ExportAssignment).expression.kind === SyntaxKind.Identifier ?                     isAliasResolvedToValue(getSymbolOfDeclaration(node as ExportAssignment), /*excludeTypeOnlyValues* / true) :                     true;         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    isTopLevelValueImportEqualsWithEntityName := func(nodeIn ImportEqualsDeclaration) bool {
        node := getParseTreeNode(nodeIn, isImportEqualsDeclaration)
        if /* TODO(BinaryExpression): node === undefined || node.parent.kind !== SyntaxKind.SourceFile || !isInternalModuleImportEqualsDeclaration(node) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        isValue := isAliasResolvedToValue(getSymbolOfDeclaration(node))
         /* TODO(BinaryExpression): isValue && node.moduleReference && !nodeIsMissing(node.moduleReference) */ TODO
    }
    isAliasResolvedToValue := func(symbol *Symbol, excludeTypeOnlyValues bool) bool {
        if /* TODO(PrefixUnaryExpression): !symbol */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        container := getSourceFileOfNode(/* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
        fileSymbol := /* TODO(BinaryExpression): container && getSymbolOfDeclaration(container) */ TODO
        /* TODO(ExpressionStatement): void resolveExternalModuleSymbol(fileSymbol); */
        target := getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol))
        if /* TODO(BinaryExpression): target === unknownSymbol */ TODO {
             /* TODO(BinaryExpression): !excludeTypeOnlyValues || !getTypeOnlyAliasDeclaration(symbol) */ TODO
        }
         /* TODO(BinaryExpression): !!(getSymbolFlags(symbol, excludeTypeOnlyValues, /*excludeLocalMeanings* / true) & SymbolFlags.Value) &&             (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target)) */ TODO
    }
    isConstEnumOrConstEnumOnlyModule := func(s Symbol) bool {
         /* TODO(BinaryExpression): isConstEnumSymbol(s) || !!s.constEnumOnlyModule */ TODO
    }
    isReferencedAliasDeclaration := func(node Node, checkChildren bool) bool {
        /* TODO(ExpressionStatement): Debug.assert(canCollectSymbolAliasAccessabilityData); */
        if isAliasSymbolDeclaration(node) {
            symbol := getSymbolOfDeclaration(node /* as */ /* TODO(TypeReference): Declaration */)
            links := /* TODO(BinaryExpression): symbol && getSymbolLinks(symbol) */ TODO
            if /* TODO(PropertyAccessExpression): links?.referenced */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
            target := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).aliasTarget */ TODO
            if /* TODO(BinaryExpression): target && getEffectiveModifierFlags(node) & ModifierFlags.Export &&                 getSymbolFlags(target) & SymbolFlags.Value &&                 (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target)) */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
        }
        if checkChildren {
             /* TODO(PrefixUnaryExpression): !!forEachChild(node, node => isReferencedAliasDeclaration(node, checkChildren)) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    isImplementationOfOverload := func(node SignatureDeclaration) /* TODO(undefined): boolean */ TODO {
        if nodeIsPresent(/* TODO(PropertyAccessExpression): (node as FunctionLikeDeclaration).body */ TODO) {
            if /* TODO(BinaryExpression): isGetAccessor(node) || isSetAccessor(node) */ TODO {
                /* TODO(FalseKeyword): false */
            }
            symbol := getSymbolOfDeclaration(node)
            signaturesOfSymbol := getSignaturesOfSymbol(symbol)
             /* TODO(BinaryExpression): signaturesOfSymbol.length > 1 ||                 // If there is single signature for the symbol, it is overload if that signature isn't coming from the node                 // e.g.: function foo(a: string): string;                 //       function foo(a: any) { // This is implementation of the overloads                 //           return a;                 //       }                 (signaturesOfSymbol.length === 1 && signaturesOfSymbol[0].declaration !== node) */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    declaredParameterTypeContainsUndefined := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any) /* TODO(undefined): boolean */ TODO {
        typeNode := getNonlocalEffectiveTypeAnnotationNode(parameter)
        if /* TODO(PrefixUnaryExpression): !typeNode */ TODO {
            /* TODO(FalseKeyword): false */
        }
        type_ := getTypeFromTypeNode(typeNode)
         containsUndefinedType(type_)
    }
    requiresAddingImplicitUndefined := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): (isRequiredInitializedParameter(parameter, enclosingDeclaration) || isOptionalUninitializedParameterProperty(parameter)) && !declaredParameterTypeContainsUndefined(parameter) */ TODO
    }
    isRequiredInitializedParameter := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) bool {
        if /* TODO(BinaryExpression): !strictNullChecks || isOptionalParameter(parameter) || isJSDocParameterTag(parameter) || !parameter.initializer */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if hasSyntacticModifier(parameter, /* TODO(PropertyAccessExpression): ModifierFlags.ParameterPropertyModifier */ TODO) {
             /* TODO(BinaryExpression): !!enclosingDeclaration && isFunctionLikeDeclaration(enclosingDeclaration) */ TODO
        }
         /* TODO(TrueKeyword): true */ TODO
    }
    isOptionalUninitializedParameterProperty := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): strictNullChecks &&             isOptionalParameter(parameter) &&             (isJSDocParameterTag(parameter) || !parameter.initializer) &&             hasSyntacticModifier(parameter, ModifierFlags.ParameterPropertyModifier) */ TODO
    }
    isExpandoFunctionDeclaration := func(node Declaration) bool {
        declaration := getParseTreeNode(node, /* TODO(ArrowFunction): (n): n is FunctionDeclaration | VariableDeclaration => isFunctionDeclaration(n) || isVariableDeclaration(n) */ TODO)
        if /* TODO(PrefixUnaryExpression): !declaration */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        var symbol *Symbol
        if isVariableDeclaration(declaration) {
            if /* TODO(BinaryExpression): declaration.type || (!isInJSFile(declaration) && !isVarConstLike(declaration)) */ TODO {
                 /* TODO(FalseKeyword): false */ TODO
            }
            initializer := getDeclaredExpandoInitializer(declaration)
            if /* TODO(BinaryExpression): !initializer || !canHaveSymbol(initializer) */ TODO {
                 /* TODO(FalseKeyword): false */ TODO
            }
            /* TODO(ExpressionStatement): symbol = getSymbolOfDeclaration(initializer); */
        } else {
            /* TODO(ExpressionStatement): symbol = getSymbolOfDeclaration(declaration); */
        }
        if /* TODO(BinaryExpression): !symbol || !(symbol.flags & SymbolFlags.Function | SymbolFlags.Variable) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
         /* TODO(PrefixUnaryExpression): !!forEachEntry(getExportsOfSymbol(symbol), p => p.flags & SymbolFlags.Value && isExpandoPropertyDeclaration(p.valueDeclaration)) */ TODO
    }
    getPropertiesOfContainerFunction := func(node Declaration) []Symbol {
        declaration := getParseTreeNode(node, isFunctionDeclaration)
        if /* TODO(PrefixUnaryExpression): !declaration */ TODO {
             emptyArray
        }
        symbol := getSymbolOfDeclaration(declaration)
         /* TODO(BinaryExpression): symbol && getPropertiesOfType(getTypeOfSymbol(symbol)) || emptyArray */ TODO
    }
    getNodeCheckFlags := func(node Node) NodeCheckFlags {
        nodeId := /* TODO(BinaryExpression): node.id || 0 */ TODO
        if /* TODO(BinaryExpression): nodeId < 0 || nodeId >= nodeLinks.length */ TODO {
            /* TODO(NumericLiteral): 0 */
        }
         /* TODO(BinaryExpression): nodeLinks[nodeId]?.flags || 0 */ TODO
    }
    hasNodeCheckFlag := func(node Node, flag LazyNodeCheckFlags) /* TODO(undefined): boolean */ TODO {
        /* TODO(ExpressionStatement): calculateNodeCheckFlagWorker(node, flag); */
         /* TODO(PrefixUnaryExpression): !!(getNodeCheckFlags(node) & flag) */ TODO
    }
    calculateNodeCheckFlagWorker := func(node Node, flag LazyNodeCheckFlags) {
        if /* TODO(BinaryExpression): !compilerOptions.noCheck && canIncludeBindAndCheckDiagnostics(getSourceFileOfNode(node), compilerOptions) */ TODO {

        }
        links := getNodeLinks(node)
        if /* TODO(BinaryExpression): links.calculatedFlags & flag */ TODO {

        }
        /* TODO(SwitchStatement): switch (flag) {             case NodeCheckFlags.SuperInstance:             case NodeCheckFlags.SuperStatic:                 return checkSingleSuperExpression(node);             case NodeCheckFlags.MethodWithSuperPropertyAccessInAsync:             case NodeCheckFlags.MethodWithSuperPropertyAssignmentInAsync:             case NodeCheckFlags.ContainsSuperPropertyInStaticInitializer:                 return checkChildSuperExpressions(node);             case NodeCheckFlags.CaptureArguments:             case NodeCheckFlags.ContainsCapturedBlockScopeBinding:             case NodeCheckFlags.NeedsLoopOutParameter:             case NodeCheckFlags.ContainsConstructorReference:                 return checkChildIdentifiers(node);             case NodeCheckFlags.ConstructorReference:                 return checkSingleIdentifier(node);             case NodeCheckFlags.LoopWithCapturedBlockScopedBinding:             case NodeCheckFlags.BlockScopedBindingInLoop:             case NodeCheckFlags.CapturedBlockScopedBinding:                 return checkContainingBlockScopeBindingUses(node);             default:                 return Debug.assertNever(flag, `Unhandled node check flag calculation: ${Debug.formatNodeCheckFlags(flag)}`);         } */
        forEachNodeRecursively := func(root Node, cb func(node Node, parent Node) /* TODO(UnionType): T | "skip" | undefined */ any) *T {
            rootResult := cb(root, /* TODO(PropertyAccessExpression): root.parent */ TODO)
            if /* TODO(BinaryExpression): rootResult === "skip" */ TODO {
                /* TODO(Identifier): undefined */
            }
            if rootResult {
                /* TODO(Identifier): rootResult */
            }
             forEachChildRecursively(root, cb)
        }
        checkSuperExpressions := func(node Node) /* TODO(undefined): "skip" | undefined */ TODO {
            links := getNodeLinks(node)
            if /* TODO(BinaryExpression): links.calculatedFlags & flag */ TODO {
                /* TODO(StringLiteral): "skip" */
            }
            /* TODO(ExpressionStatement): links.calculatedFlags |= NodeCheckFlags.MethodWithSuperPropertyAccessInAsync | NodeCheckFlags.MethodWithSuperPropertyAssignmentInAsync | NodeCheckFlags.ContainsSuperPropertyInStaticInitializer; */
            /* TODO(ExpressionStatement): checkSingleSuperExpression(node); */
             undefined
        }
        checkChildSuperExpressions := func(node Node) {
            /* TODO(ExpressionStatement): forEachNodeRecursively(node, checkSuperExpressions); */
        }
        checkSingleSuperExpression := func(node Node) {
            nodeLinks := getNodeLinks(node)
            /* TODO(ExpressionStatement): nodeLinks.calculatedFlags |= NodeCheckFlags.SuperInstance | NodeCheckFlags.SuperStatic; */
            if /* TODO(BinaryExpression): node.kind === SyntaxKind.SuperKeyword */ TODO {
                /* TODO(ExpressionStatement): checkSuperExpression(node); */
            }
        }
        checkIdentifiers := func(node Node) /* TODO(undefined): "skip" | undefined */ TODO {
            links := getNodeLinks(node)
            if /* TODO(BinaryExpression): links.calculatedFlags & flag */ TODO {
                /* TODO(StringLiteral): "skip" */
            }
            /* TODO(ExpressionStatement): links.calculatedFlags |= NodeCheckFlags.CaptureArguments | NodeCheckFlags.ContainsCapturedBlockScopeBinding | NodeCheckFlags.NeedsLoopOutParameter | NodeCheckFlags.ContainsConstructorReference; */
            /* TODO(ExpressionStatement): checkSingleIdentifier(node); */
             undefined
        }
        checkChildIdentifiers := func(node Node) {
            /* TODO(ExpressionStatement): forEachNodeRecursively(node, checkIdentifiers); */
        }
        isExpressionNodeOrShorthandPropertyAssignmentName := func(node Identifier) /* TODO(undefined): boolean */ TODO {
             /* TODO(BinaryExpression): isExpressionNode(node)                 || isShorthandPropertyAssignment(node.parent) && (node.parent.objectAssignmentInitializer ?? node.parent.name) === node */ TODO
        }
        checkSingleIdentifier := func(node Node) {
            nodeLinks := getNodeLinks(node)
            /* TODO(ExpressionStatement): nodeLinks.calculatedFlags |= NodeCheckFlags.ConstructorReference; */
            if isIdentifier(node) {
                /* TODO(ExpressionStatement): nodeLinks.calculatedFlags |= NodeCheckFlags.BlockScopedBindingInLoop | NodeCheckFlags.CapturedBlockScopedBinding; */
                if /* TODO(BinaryExpression): isExpressionNodeOrShorthandPropertyAssignmentName(node) && !(isPropertyAccessExpression(node.parent) && node.parent.name === node) */ TODO {
                    s := getResolvedSymbol(node)
                    if /* TODO(BinaryExpression): s && s !== unknownSymbol */ TODO {
                        /* TODO(ExpressionStatement): checkIdentifierCalculateNodeCheckFlags(node, s); */
                    }
                }
            }
        }
        checkBlockScopeBindings := func(node Node) /* TODO(undefined): "skip" | undefined */ TODO {
            links := getNodeLinks(node)
            if /* TODO(BinaryExpression): links.calculatedFlags & flag */ TODO {
                /* TODO(StringLiteral): "skip" */
            }
            /* TODO(ExpressionStatement): links.calculatedFlags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding | NodeCheckFlags.BlockScopedBindingInLoop | NodeCheckFlags.CapturedBlockScopedBinding; */
            /* TODO(ExpressionStatement): checkSingleBlockScopeBinding(node); */
             undefined
        }
        checkContainingBlockScopeBindingUses := func(node Node) {
            scope := getEnclosingBlockScopeContainer(/* TODO(ConditionalExpression): isDeclarationName(node) ? node.parent : node */ TODO)
            /* TODO(ExpressionStatement): forEachNodeRecursively(scope, checkBlockScopeBindings); */
        }
        checkSingleBlockScopeBinding := func(node Node) {
            /* TODO(ExpressionStatement): checkSingleIdentifier(node); */
            if isComputedPropertyName(node) {
                /* TODO(ExpressionStatement): checkComputedPropertyName(node); */
            }
            if /* TODO(BinaryExpression): isPrivateIdentifier(node) && isClassElement(node.parent) */ TODO {
                /* TODO(ExpressionStatement): setNodeLinksForPrivateIdentifierScope(node.parent as PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration); */
            }
        }
    }
    getEnumMemberValue := func(node EnumMember) EvaluatorResult {
        /* TODO(ExpressionStatement): computeEnumMemberValues(node.parent); */
         /* TODO(BinaryExpression): getNodeLinks(node).enumMemberValue ?? evaluatorResult(/*value* / undefined) */ TODO
    }
    canHaveConstantValue := func(node Node) /* TODO(TypePredicate): node is EnumMember | AccessExpression */ TODO {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.EnumMember:             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 return true;         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    getConstantValue := func(node /* TODO(UnionType): EnumMember | AccessExpression */ any) /* TODO(UnionType): string | number | undefined */ any {
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.EnumMember */ TODO {
             /* TODO(PropertyAccessExpression): getEnumMemberValue(node).value */ TODO
        }
        if /* TODO(PrefixUnaryExpression): !getNodeLinks(node).resolvedSymbol */ TODO {
            /* TODO(ExpressionStatement): void checkExpressionCached(node); */
        }
        symbol := /* TODO(BinaryExpression): getNodeLinks(node).resolvedSymbol || (isEntityNameExpression(node) ? resolveEntityName(node, SymbolFlags.Value, /*ignoreErrors* / true) : undefined) */ TODO
        if /* TODO(BinaryExpression): symbol && (symbol.flags & SymbolFlags.EnumMember) */ TODO {
            member := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO /* as */ /* TODO(TypeReference): EnumMember */
            if isEnumConst(/* TODO(PropertyAccessExpression): member.parent */ TODO) {
                 /* TODO(PropertyAccessExpression): getEnumMemberValue(member).value */ TODO
            }
        }
         undefined
    }
    isFunctionType := func(type_ Type) bool {
         /* TODO(BinaryExpression): !!(type.flags & TypeFlags.Object) && getSignaturesOfType(type, SignatureKind.Call).length > 0 */ TODO
    }
    getTypeReferenceSerializationKind := func(typeNameIn EntityName, location Node) TypeReferenceSerializationKind {
        typeName := getParseTreeNode(typeNameIn, isEntityName)
        if /* TODO(PrefixUnaryExpression): !typeName */ TODO {
            /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.Unknown */
        }
        if location {
            /* TODO(ExpressionStatement): location = getParseTreeNode(location); */
            if /* TODO(PrefixUnaryExpression): !location */ TODO {
                /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.Unknown */
            }
        }
        isTypeOnly := /* TODO(FalseKeyword): false */ TODO
        if isQualifiedName(typeName) {
            rootValueSymbol := resolveEntityName(getFirstIdentifier(typeName), /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO, /* TODO(TrueKeyword): true */ TODO, /* TODO(TrueKeyword): true */ TODO, location)
            /* TODO(ExpressionStatement): isTypeOnly = !!rootValueSymbol?.declarations?.every(isTypeOnlyImportOrExportDeclaration); */
        }
        valueSymbol := resolveEntityName(typeName, /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO, /* TODO(TrueKeyword): true */ TODO, /* TODO(TrueKeyword): true */ TODO, location)
        resolvedValueSymbol := /* TODO(ConditionalExpression): valueSymbol && valueSymbol.flags & SymbolFlags.Alias ? resolveAlias(valueSymbol) : valueSymbol */ TODO
        /* TODO(ExpressionStatement): isTypeOnly ||= !!(valueSymbol && getTypeOnlyAliasDeclaration(valueSymbol, SymbolFlags.Value)); */
        typeSymbol := resolveEntityName(typeName, /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO, /* TODO(TrueKeyword): true */ TODO, /* TODO(TrueKeyword): true */ TODO, location)
        resolvedTypeSymbol := /* TODO(ConditionalExpression): typeSymbol && typeSymbol.flags & SymbolFlags.Alias ? resolveAlias(typeSymbol) : typeSymbol */ TODO
        if /* TODO(PrefixUnaryExpression): !valueSymbol */ TODO {
            /* TODO(ExpressionStatement): isTypeOnly ||= !!(typeSymbol && getTypeOnlyAliasDeclaration(typeSymbol, SymbolFlags.Type)); */
        }
        if /* TODO(BinaryExpression): resolvedValueSymbol && resolvedValueSymbol === resolvedTypeSymbol */ TODO {
            globalPromiseSymbol := getGlobalPromiseConstructorSymbol(/* TODO(FalseKeyword): false */ TODO)
            if /* TODO(BinaryExpression): globalPromiseSymbol && resolvedValueSymbol === globalPromiseSymbol */ TODO {
                 /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.Promise */ TODO
            }
            constructorType := getTypeOfSymbol(resolvedValueSymbol)
            if /* TODO(BinaryExpression): constructorType && isConstructorType(constructorType) */ TODO {
                 /* TODO(ConditionalExpression): isTypeOnly ? TypeReferenceSerializationKind.TypeWithCallSignature : TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue */ TODO
            }
        }
        if /* TODO(PrefixUnaryExpression): !resolvedTypeSymbol */ TODO {
             /* TODO(ConditionalExpression): isTypeOnly ? TypeReferenceSerializationKind.ObjectType : TypeReferenceSerializationKind.Unknown */ TODO
        }
        type_ := getDeclaredTypeOfSymbol(resolvedTypeSymbol)
        if isErrorType(type_) {
             /* TODO(ConditionalExpression): isTypeOnly ? TypeReferenceSerializationKind.ObjectType : TypeReferenceSerializationKind.Unknown */ TODO
        } else if /* TODO(BinaryExpression): type.flags & TypeFlags.AnyOrUnknown */ TODO {
             /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.ObjectType */ TODO
        } else if isTypeAssignableToKind(type_, /* TODO(BinaryExpression): TypeFlags.Void | TypeFlags.Nullable | TypeFlags.Never */ TODO) {
             /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.VoidNullableOrNeverType */ TODO
        } else if isTypeAssignableToKind(type_, /* TODO(PropertyAccessExpression): TypeFlags.BooleanLike */ TODO) {
             /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.BooleanType */ TODO
        } else if isTypeAssignableToKind(type_, /* TODO(PropertyAccessExpression): TypeFlags.NumberLike */ TODO) {
             /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.NumberLikeType */ TODO
        } else if isTypeAssignableToKind(type_, /* TODO(PropertyAccessExpression): TypeFlags.BigIntLike */ TODO) {
             /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.BigIntLikeType */ TODO
        } else if isTypeAssignableToKind(type_, /* TODO(PropertyAccessExpression): TypeFlags.StringLike */ TODO) {
             /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.StringLikeType */ TODO
        } else if isTupleType(type_) {
             /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.ArrayLikeType */ TODO
        } else if isTypeAssignableToKind(type_, /* TODO(PropertyAccessExpression): TypeFlags.ESSymbolLike */ TODO) {
             /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.ESSymbolType */ TODO
        } else if isFunctionType(type_) {
             /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.TypeWithCallSignature */ TODO
        } else if isArrayType(type_) {
             /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.ArrayLikeType */ TODO
        } else {
             /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.ObjectType */ TODO
        }
    }
    createTypeOfDeclaration := func(declarationIn /* TODO(UnionType): AccessorDeclaration | VariableLikeDeclaration | PropertyAccessExpression */ any, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
        declaration := getParseTreeNode(declarationIn, isVariableLikeOrAccessor)
        if /* TODO(PrefixUnaryExpression): !declaration */ TODO {
             /* TODO(PropertyAccessExpression): factory.createToken */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO) /* as */ /* TODO(TypeReference): KeywordTypeNode */
        }
        symbol := getSymbolOfDeclaration(declaration)
        type_ := /* TODO(ConditionalExpression): symbol && !(symbol.flags & (SymbolFlags.TypeLiteral | SymbolFlags.Signature))             ? getWidenedLiteralType(getTypeOfSymbol(symbol))             : errorType */ TODO
         /* TODO(PropertyAccessExpression): nodeBuilder.serializeTypeForDeclaration */ TODO(declaration, type_, symbol, enclosingDeclaration, /* TODO(BinaryExpression): flags | NodeBuilderFlags.MultilineObjectLiterals */ TODO, internalFlags, tracker)
    }
    type DeclarationWithPotentialInnerNodeReuse /* TODO(UnionType): | SignatureDeclaration         | JSDocSignature         | AccessorDeclaration         | VariableLikeDeclaration         | PropertyAccessExpression         | ExportAssignment */ any
    isDeclarationWithPossibleInnerTypeNodeReuse := func(declaration Declaration) /* TODO(TypePredicate): declaration is DeclarationWithPotentialInnerNodeReuse */ TODO {
         /* TODO(BinaryExpression): isFunctionLike(declaration) || isExportAssignment(declaration) || isVariableLike(declaration) */ TODO
    }
    getAllAccessorDeclarationsForDeclaration := func(accessor AccessorDeclaration) AllAccessorDeclarations {
        /* TODO(ExpressionStatement): accessor = getParseTreeNode(accessor, isGetOrSetAccessorDeclaration)!; */
        otherKind := /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.SetAccessor ? SyntaxKind.GetAccessor : SyntaxKind.SetAccessor */ TODO
        otherAccessor := getDeclarationOfKind(getSymbolOfDeclaration(accessor), otherKind)
        firstAccessor := /* TODO(ConditionalExpression): otherAccessor && (otherAccessor.pos < accessor.pos) ? otherAccessor : accessor */ TODO
        secondAccessor := /* TODO(ConditionalExpression): otherAccessor && (otherAccessor.pos < accessor.pos) ? accessor : otherAccessor */ TODO
        setAccessor := /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.SetAccessor ? accessor : otherAccessor as SetAccessorDeclaration */ TODO
        getAccessor := /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ? accessor : otherAccessor as GetAccessorDeclaration */ TODO
         /* TODO(ObjectLiteralExpression): {             firstAccessor,             secondAccessor,             setAccessor,             getAccessor,         } */ TODO
    }
    getPossibleTypeNodeReuseExpression := func(declaration DeclarationWithPotentialInnerNodeReuse) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ TODO {
         /* TODO(ConditionalExpression): isFunctionLike(declaration) && !isSetAccessor(declaration)             ? getSingleReturnExpression(declaration)             : isExportAssignment(declaration)             ? declaration.expression             : !!(declaration as HasInitializer).initializer             ? (declaration as HasInitializer & typeof declaration).initializer             : isParameter(declaration) && isSetAccessor(declaration.parent)             ? getSingleReturnExpression(getAllAccessorDeclarationsForDeclaration(declaration.parent).getAccessor)             : undefined */ TODO
    }
    getSingleReturnExpression := func(declaration *SignatureDeclaration) *Expression {
        var candidateExpr *Expression
        if /* TODO(BinaryExpression): declaration && !nodeIsMissing((declaration as FunctionLikeDeclaration).body) */ TODO {
            if /* TODO(BinaryExpression): getFunctionFlags(declaration) & FunctionFlags.AsyncGenerator */ TODO {
                /* TODO(Identifier): undefined */
            }
            body := /* TODO(PropertyAccessExpression): (declaration as FunctionLikeDeclaration).body */ TODO
            if /* TODO(BinaryExpression): body && isBlock(body) */ TODO {
                /* TODO(ExpressionStatement): forEachReturnStatement(body, s => {                     if (!candidateExpr) {                         candidateExpr = s.expression;                     }                     else {                         candidateExpr = undefined;                         return true;                     }                 }); */
            } else {
                /* TODO(ExpressionStatement): candidateExpr = body; */
            }
        }
         candidateExpr
    }
    createReturnTypeOfSignatureDeclaration := func(signatureDeclarationIn SignatureDeclaration, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
        signatureDeclaration := getParseTreeNode(signatureDeclarationIn, isFunctionLike)
        if /* TODO(PrefixUnaryExpression): !signatureDeclaration */ TODO {
             /* TODO(PropertyAccessExpression): factory.createToken */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO) /* as */ /* TODO(TypeReference): KeywordTypeNode */
        }
         /* TODO(PropertyAccessExpression): nodeBuilder.serializeReturnTypeForSignature */ TODO(getSignatureFromDeclaration(signatureDeclaration), enclosingDeclaration, /* TODO(BinaryExpression): flags | NodeBuilderFlags.MultilineObjectLiterals */ TODO, internalFlags, tracker)
    }
    createTypeOfExpression := func(exprIn Expression, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
        expr := getParseTreeNode(exprIn, isExpression)
        if /* TODO(PrefixUnaryExpression): !expr */ TODO {
             /* TODO(PropertyAccessExpression): factory.createToken */ TODO(/* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO) /* as */ /* TODO(TypeReference): KeywordTypeNode */
        }
        type_ := getWidenedType(getRegularTypeOfExpression(expr))
         /* TODO(PropertyAccessExpression): nodeBuilder.expressionOrTypeToTypeNode */ TODO(expr, type_, undefined, enclosingDeclaration, /* TODO(BinaryExpression): flags | NodeBuilderFlags.MultilineObjectLiterals */ TODO, internalFlags, tracker)
    }
    hasGlobalName := func(name string) bool {
         /* TODO(PropertyAccessExpression): globals.has */ TODO(escapeLeadingUnderscores(name))
    }
    getReferencedValueSymbol := func(reference Identifier, startInDeclarationContainer bool) *Symbol {
        resolvedSymbol := /* TODO(PropertyAccessExpression): getNodeLinks(reference).resolvedSymbol */ TODO
        if resolvedSymbol {
             resolvedSymbol
        }
        var location Node = reference
        if startInDeclarationContainer {
            parent := /* TODO(PropertyAccessExpression): reference.parent */ TODO
            if /* TODO(BinaryExpression): isDeclaration(parent) && reference === parent.name */ TODO {
                /* TODO(ExpressionStatement): location = getDeclarationContainer(parent); */
            }
        }
         resolveName(location, /* TODO(PropertyAccessExpression): reference.escapedText */ TODO, /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.ExportValue | SymbolFlags.Alias */ TODO, undefined, /* TODO(TrueKeyword): true */ TODO)
    }
    getReferencedValueOrAliasSymbol := func(reference Identifier) *Symbol {
        resolvedSymbol := /* TODO(PropertyAccessExpression): getNodeLinks(reference).resolvedSymbol */ TODO
        if /* TODO(BinaryExpression): resolvedSymbol && resolvedSymbol !== unknownSymbol */ TODO {
             resolvedSymbol
        }
         resolveName(reference, /* TODO(PropertyAccessExpression): reference.escapedText */ TODO, /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.ExportValue | SymbolFlags.Alias */ TODO, undefined, /* TODO(TrueKeyword): true */ TODO, undefined)
    }
    getReferencedValueDeclaration := func(referenceIn Identifier) Declaration {
        if /* TODO(PrefixUnaryExpression): !isGeneratedIdentifier(referenceIn) */ TODO {
            reference := getParseTreeNode(referenceIn, isIdentifier)
            if reference {
                symbol := getReferencedValueSymbol(reference)
                if symbol {
                     /* TODO(PropertyAccessExpression): getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration */ TODO
                }
            }
        }
         undefined
    }
    getReferencedValueDeclarations := func(referenceIn Identifier) /* TODO(ArrayType): Declaration[] */ any {
        if /* TODO(PrefixUnaryExpression): !isGeneratedIdentifier(referenceIn) */ TODO {
            reference := getParseTreeNode(referenceIn, isIdentifier)
            if reference {
                symbol := getReferencedValueSymbol(reference)
                if symbol {
                     filter(/* TODO(PropertyAccessExpression): getExportSymbolOfValueSymbolIfExported(symbol).declarations */ TODO, /* TODO(ArrowFunction): declaration => {                         switch (declaration.kind) {                             case SyntaxKind.VariableDeclaration:                             case SyntaxKind.Parameter:                             case SyntaxKind.BindingElement:                             case SyntaxKind.PropertyDeclaration:                             case SyntaxKind.PropertyAssignment:                             case SyntaxKind.ShorthandPropertyAssignment:                             case SyntaxKind.EnumMember:                             case SyntaxKind.ObjectLiteralExpression:                             case SyntaxKind.FunctionDeclaration:                             case SyntaxKind.FunctionExpression:                             case SyntaxKind.ArrowFunction:                             case SyntaxKind.ClassDeclaration:                             case SyntaxKind.ClassExpression:                             case SyntaxKind.EnumDeclaration:                             case SyntaxKind.MethodDeclaration:                             case SyntaxKind.GetAccessor:                             case SyntaxKind.SetAccessor:                             case SyntaxKind.ModuleDeclaration:                                 return true;                         }                         return false;                     } */ TODO)
                }
            }
        }
         undefined
    }
    isLiteralConstDeclaration := func(node /* TODO(UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any) bool {
        if /* TODO(BinaryExpression): isDeclarationReadonly(node) || isVariableDeclaration(node) && isVarConstLike(node) */ TODO {
             isFreshLiteralType(getTypeOfSymbol(getSymbolOfDeclaration(node)))
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    literalTypeToNode := func(type_ FreshableType, enclosing Node, tracker SymbolTracker) Expression {
        enumResult := /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike ? nodeBuilder.symbolToExpression(type.symbol, SymbolFlags.Value, enclosing, /*flags* / undefined, /*internalFlags* / undefined, tracker)             : type === trueType ? factory.createTrue() : type === falseType && factory.createFalse() */ TODO
        if enumResult {
            /* TODO(Identifier): enumResult */
        }
        literalValue := /* TODO(PropertyAccessExpression): (type as LiteralType).value */ TODO
         /* TODO(ConditionalExpression): typeof literalValue === "object" ? factory.createBigIntLiteral(literalValue) :             typeof literalValue === "string" ? factory.createStringLiteral(literalValue) :             literalValue < 0 ? factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createNumericLiteral(-literalValue)) :             factory.createNumericLiteral(literalValue) */ TODO
    }
    createLiteralConstValue := func(node /* TODO(UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any, tracker SymbolTracker) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ TODO {
        type_ := getTypeOfSymbol(getSymbolOfDeclaration(node))
         literalTypeToNode(type_ /* as */ /* TODO(TypeReference): FreshableType */, node, tracker)
    }
    getJsxFactoryEntity := func(location Node) *EntityName {
         /* TODO(ConditionalExpression): location ? (getJsxNamespace(location), (getSourceFileOfNode(location).localJsxFactory || _jsxFactoryEntity)) : _jsxFactoryEntity */ TODO
    }
    getJsxFragmentFactoryEntity := func(location Node) *EntityName {
        if location {
            file := getSourceFileOfNode(location)
            if file {
                if /* TODO(PropertyAccessExpression): file.localJsxFragmentFactory */ TODO {
                     /* TODO(PropertyAccessExpression): file.localJsxFragmentFactory */ TODO
                }
                jsxFragPragmas := /* TODO(PropertyAccessExpression): file.pragmas.get */ TODO("jsxfrag")
                jsxFragPragma := /* TODO(ConditionalExpression): isArray(jsxFragPragmas) ? jsxFragPragmas[0] : jsxFragPragmas */ TODO
                if jsxFragPragma {
                    /* TODO(ExpressionStatement): file.localJsxFragmentFactory = parseIsolatedEntityName(jsxFragPragma.arguments.factory, languageVersion); */
                     /* TODO(PropertyAccessExpression): file.localJsxFragmentFactory */ TODO
                }
            }
        }
        if /* TODO(PropertyAccessExpression): compilerOptions.jsxFragmentFactory */ TODO {
             parseIsolatedEntityName(/* TODO(PropertyAccessExpression): compilerOptions.jsxFragmentFactory */ TODO, languageVersion)
        }
    }
    getNonlocalEffectiveTypeAnnotationNode := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
        direct := getEffectiveTypeAnnotationNode(node)
        if direct {
             direct
        }
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.Parameter && node.parent.kind === SyntaxKind.SetAccessor */ TODO {
            other := /* TODO(PropertyAccessExpression): getAllAccessorDeclarationsForDeclaration(node.parent as SetAccessorDeclaration).getAccessor */ TODO
            if other {
                 getEffectiveReturnTypeNode(other)
            }
        }
         undefined
    }
    getNonlocalEffectiveReturnTypeAnnotationNode := func(node /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
        direct := getEffectiveReturnTypeNode(node)
        if direct {
             direct
        }
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.GetAccessor */ TODO {
            other := /* TODO(PropertyAccessExpression): getAllAccessorDeclarationsForDeclaration(node).setAccessor */ TODO
            if other {
                param := getSetAccessorValueParameter(other)
                if param {
                     getEffectiveTypeAnnotationNode(param)
                }
            }
        }
         undefined
    }
    createResolver := func() EmitResolver {
         /* TODO(ObjectLiteralExpression): {             getReferencedExportContainer,             getReferencedImportDeclaration,             getReferencedDeclarationWithCollidingName,             isDeclarationWithCollidingName,             isValueAliasDeclaration: nodeIn => {                 const node = getParseTreeNode(nodeIn);                 // Synthesized nodes are always treated like values.                 return node && canCollectSymbolAliasAccessabilityData ? isValueAliasDeclaration(node) : true;             },             hasGlobalName,             isReferencedAliasDeclaration: (nodeIn, checkChildren?) => {                 const node = getParseTreeNode(nodeIn);                 // Synthesized nodes are always treated as referenced.                 return node && canCollectSymbolAliasAccessabilityData ? isReferencedAliasDeclaration(node, checkChildren) : true;             },             hasNodeCheckFlag: (nodeIn, flag) => {                 const node = getParseTreeNode(nodeIn);                 if (!node) return false;                 return hasNodeCheckFlag(node, flag);             },             isTopLevelValueImportEqualsWithEntityName,             isDeclarationVisible,             isImplementationOfOverload,             requiresAddingImplicitUndefined,             isExpandoFunctionDeclaration,             getPropertiesOfContainerFunction,             createTypeOfDeclaration,             createReturnTypeOfSignatureDeclaration,             createTypeOfExpression,             createLiteralConstValue,             isSymbolAccessible,             isEntityNameVisible,             getConstantValue: nodeIn => {                 const node = getParseTreeNode(nodeIn, canHaveConstantValue);                 return node ? getConstantValue(node) : undefined;             },             getEnumMemberValue: nodeIn => {                 const node = getParseTreeNode(nodeIn, isEnumMember);                 return node ? getEnumMemberValue(node) : undefined;             },             collectLinkedAliases,             markLinkedReferences: nodeIn => {                 const node = getParseTreeNode(nodeIn);                 return node && markLinkedReferences(node, ReferenceHint.Unspecified);             },             getReferencedValueDeclaration,             getReferencedValueDeclarations,             getTypeReferenceSerializationKind,             isOptionalParameter,             isArgumentsLocalBinding,             getExternalModuleFileFromDeclaration: nodeIn => {                 const node = getParseTreeNode(nodeIn, hasPossibleExternalModuleReference);                 return node && getExternalModuleFileFromDeclaration(node);             },             isLiteralConstDeclaration,             isLateBound: (nodeIn: Declaration): nodeIn is LateBoundDeclaration => {                 const node = getParseTreeNode(nodeIn, isDeclaration);                 const symbol = node && getSymbolOfDeclaration(node);                 return !!(symbol && getCheckFlags(symbol) & CheckFlags.Late);             },             getJsxFactoryEntity,             getJsxFragmentFactoryEntity,             isBindingCapturedByNode: (node, decl) => {                 const parseNode = getParseTreeNode(node);                 const parseDecl = getParseTreeNode(decl);                 return !!parseNode && !!parseDecl && (isVariableDeclaration(parseDecl) || isBindingElement(parseDecl)) && isBindingCapturedByNode(parseNode, parseDecl);             },             getDeclarationStatementsForSourceFile: (node, flags, internalFlags, tracker) => {                 const n = getParseTreeNode(node) as SourceFile;                 Debug.assert(n && n.kind === SyntaxKind.SourceFile, "Non-sourcefile node passed into getDeclarationsForSourceFile");                 const sym = getSymbolOfDeclaration(node);                 if (!sym) {                     return !node.locals ? [] : nodeBuilder.symbolTableToDeclarationStatements(node.locals, node, flags, internalFlags, tracker);                 }                 resolveExternalModuleSymbol(sym); // ensures cjs export assignment is setup                 return !sym.exports ? [] : nodeBuilder.symbolTableToDeclarationStatements(sym.exports, node, flags, internalFlags, tracker);             },             isImportRequiredByAugmentation,             isDefinitelyReferenceToGlobalSymbolObject,         } */ TODO
        isImportRequiredByAugmentation := func(node ImportDeclaration) /* TODO(undefined): boolean */ TODO {
            file := getSourceFileOfNode(node)
            if /* TODO(PrefixUnaryExpression): !file.symbol */ TODO {
                /* TODO(FalseKeyword): false */
            }
            importTarget := getExternalModuleFileFromDeclaration(node)
            if /* TODO(PrefixUnaryExpression): !importTarget */ TODO {
                /* TODO(FalseKeyword): false */
            }
            if /* TODO(BinaryExpression): importTarget === file */ TODO {
                /* TODO(FalseKeyword): false */
            }
            exports := getExportsOfModule(/* TODO(PropertyAccessExpression): file.symbol */ TODO)
            /* TODO(ForOfStatement): for (const s of arrayFrom(exports.values())) {                 if (s.mergeId) {                     const merged = getMergedSymbol(s);                     if (merged.declarations) {                         for (const d of merged.declarations) {                             const declFile = getSourceFileOfNode(d);                             if (declFile === importTarget) {                                 return true;                             }                         }                     }                 }             } */
             /* TODO(FalseKeyword): false */ TODO
        }
    }
    getExternalModuleFileFromDeclaration := func(declaration /* TODO(UnionType): AnyImportOrReExport | ModuleDeclaration | ImportTypeNode | ImportCall */ any) *SourceFile {
        specifier := /* TODO(ConditionalExpression): declaration.kind === SyntaxKind.ModuleDeclaration ? tryCast(declaration.name, isStringLiteral) : getExternalModuleName(declaration) */ TODO
        moduleSymbol := resolveExternalModuleNameWorker(/* TODO(NonNullExpression): specifier! */ TODO, /* TODO(NonNullExpression): specifier! */ TODO, undefined)
        if /* TODO(PrefixUnaryExpression): !moduleSymbol */ TODO {
             undefined
        }
         getDeclarationOfKind(moduleSymbol, /* TODO(PropertyAccessExpression): SyntaxKind.SourceFile */ TODO)
    }
    initializeTypeChecker := func() {
        /* TODO(ForOfStatement): for (const file of host.getSourceFiles()) {             bindSourceFile(file, compilerOptions);         } */
        /* TODO(ExpressionStatement): amalgamatedDuplicates = new Map(); */
        var augmentations /* TODO(ArrayType): (readonly (StringLiteral | Identifier)[])[] */ any
        /* TODO(ForOfStatement): for (const file of host.getSourceFiles()) {             if (file.redirectInfo) {                 continue;             }             if (!isExternalOrCommonJsModule(file)) {                 // It is an error for a non-external-module (i.e. script) to declare its own `globalThis`.                 const fileGlobalThisSymbol = file.locals!.get("globalThis" as __String);                 if (fileGlobalThisSymbol?.declarations) {                     for (const declaration of fileGlobalThisSymbol.declarations) {                         diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, "globalThis"));                     }                 }                 mergeSymbolTable(globals, file.locals!);             }             if (file.jsGlobalAugmentations) {                 mergeSymbolTable(globals, file.jsGlobalAugmentations);             }             if (file.patternAmbientModules && file.patternAmbientModules.length) {                 patternAmbientModules = concatenate(patternAmbientModules, file.patternAmbientModules);             }             if (file.moduleAugmentations.length) {                 (augmentations || (augmentations = [])).push(file.moduleAugmentations);             }             if (file.symbol && file.symbol.globalExports) {                 // Merge in UMD exports with first-in-wins semantics (see #9771)                 const source = file.symbol.globalExports;                 source.forEach((sourceSymbol, id) => {                     if (!globals.has(id)) {                         globals.set(id, sourceSymbol);                     }                 });             }         } */
        if augmentations {
            /* TODO(ForOfStatement): for (const list of augmentations) {                 for (const augmentation of list) {                     if (!isGlobalScopeAugmentation(augmentation.parent as ModuleDeclaration)) continue;                     mergeModuleAugmentation(augmentation);                 }             } */
        }
        /* TODO(ExpressionStatement): addUndefinedToGlobalsOrErrorOnRedeclaration(); */
        /* TODO(ExpressionStatement): getSymbolLinks(undefinedSymbol).type = undefinedWideningType; */
        /* TODO(ExpressionStatement): getSymbolLinks(argumentsSymbol).type = getGlobalType("IArguments" as __String, /*arity* / 0, /*reportErrors* / true); */
        /* TODO(ExpressionStatement): getSymbolLinks(unknownSymbol).type = errorType; */
        /* TODO(ExpressionStatement): getSymbolLinks(globalThisSymbol).type = createObjectType(ObjectFlags.Anonymous, globalThisSymbol); */
        /* TODO(ExpressionStatement): globalArrayType = getGlobalType("Array" as __String, /*arity* / 1, /*reportErrors* / true); */
        /* TODO(ExpressionStatement): globalObjectType = getGlobalType("Object" as __String, /*arity* / 0, /*reportErrors* / true); */
        /* TODO(ExpressionStatement): globalFunctionType = getGlobalType("Function" as __String, /*arity* / 0, /*reportErrors* / true); */
        /* TODO(ExpressionStatement): globalCallableFunctionType = strictBindCallApply && getGlobalType("CallableFunction" as __String, /*arity* / 0, /*reportErrors* / true) || globalFunctionType; */
        /* TODO(ExpressionStatement): globalNewableFunctionType = strictBindCallApply && getGlobalType("NewableFunction" as __String, /*arity* / 0, /*reportErrors* / true) || globalFunctionType; */
        /* TODO(ExpressionStatement): globalStringType = getGlobalType("String" as __String, /*arity* / 0, /*reportErrors* / true); */
        /* TODO(ExpressionStatement): globalNumberType = getGlobalType("Number" as __String, /*arity* / 0, /*reportErrors* / true); */
        /* TODO(ExpressionStatement): globalBooleanType = getGlobalType("Boolean" as __String, /*arity* / 0, /*reportErrors* / true); */
        /* TODO(ExpressionStatement): globalRegExpType = getGlobalType("RegExp" as __String, /*arity* / 0, /*reportErrors* / true); */
        /* TODO(ExpressionStatement): anyArrayType = createArrayType(anyType); */
        /* TODO(ExpressionStatement): autoArrayType = createArrayType(autoType); */
        if /* TODO(BinaryExpression): autoArrayType === emptyObjectType */ TODO {
            /* TODO(ExpressionStatement): autoArrayType = createAnonymousType(/*symbol* / undefined, emptySymbols, emptyArray, emptyArray, emptyArray); */
        }
        /* TODO(ExpressionStatement): globalReadonlyArrayType = getGlobalTypeOrUndefined("ReadonlyArray" as __String, /*arity* / 1) as GenericType || globalArrayType; */
        /* TODO(ExpressionStatement): anyReadonlyArrayType = globalReadonlyArrayType ? createTypeFromGenericGlobalType(globalReadonlyArrayType, [anyType]) : anyArrayType; */
        /* TODO(ExpressionStatement): globalThisType = getGlobalTypeOrUndefined("ThisType" as __String, /*arity* / 1) as GenericType; */
        if augmentations {
            /* TODO(ForOfStatement): for (const list of augmentations) {                 for (const augmentation of list) {                     if (isGlobalScopeAugmentation(augmentation.parent as ModuleDeclaration)) continue;                     mergeModuleAugmentation(augmentation);                 }             } */
        }
        /* TODO(ExpressionStatement): amalgamatedDuplicates.forEach(({ firstFile, secondFile, conflictingSymbols }) => {             // If not many things conflict, issue individual errors             if (conflictingSymbols.size < 8) {                 conflictingSymbols.forEach(({ isBlockScoped, firstFileLocations, secondFileLocations }, symbolName) => {                     const message = isBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0 : Diagnostics.Duplicate_identifier_0;                     for (const node of firstFileLocations) {                         addDuplicateDeclarationError(node, message, symbolName, secondFileLocations);                     }                     for (const node of secondFileLocations) {                         addDuplicateDeclarationError(node, message, symbolName, firstFileLocations);                     }                 });             }             else {                 // Otherwise issue top-level error since the files appear very identical in terms of what they contain                 const list = arrayFrom(conflictingSymbols.keys()).join(", ");                 diagnostics.add(addRelatedInfo(                     createDiagnosticForNode(firstFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list),                     createDiagnosticForNode(secondFile, Diagnostics.Conflicts_are_in_this_file),                 ));                 diagnostics.add(addRelatedInfo(                     createDiagnosticForNode(secondFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list),                     createDiagnosticForNode(firstFile, Diagnostics.Conflicts_are_in_this_file),                 ));             }         }); */
        /* TODO(ExpressionStatement): amalgamatedDuplicates = undefined; */
    }
    checkExternalEmitHelpers := func(location Node, helpers ExternalEmitHelpers) {
        if /* TODO(PropertyAccessExpression): compilerOptions.importHelpers */ TODO {
            sourceFile := getSourceFileOfNode(location)
            if /* TODO(BinaryExpression): isEffectiveExternalModule(sourceFile, compilerOptions) && !(location.flags & NodeFlags.Ambient) */ TODO {
                helpersModule := resolveHelpersModule(sourceFile, location)
                if /* TODO(BinaryExpression): helpersModule !== unknownSymbol */ TODO {
                    links := getSymbolLinks(helpersModule)
                    /* TODO(ExpressionStatement): links.requestedExternalEmitHelpers ??= 0 as ExternalEmitHelpers; */
                    if /* TODO(BinaryExpression): (links.requestedExternalEmitHelpers & helpers) !== helpers */ TODO {
                        uncheckedHelpers := /* TODO(BinaryExpression): helpers & ~links.requestedExternalEmitHelpers */ TODO
                        /* TODO(ForStatement): for (let helper = ExternalEmitHelpers.FirstEmitHelper; helper <= ExternalEmitHelpers.LastEmitHelper; helper <<= 1) {                             if (uncheckedHelpers & helper) {                                 for (const name of getHelperNames(helper)) {                                     const symbol = resolveSymbol(getSymbol(getExportsOfModule(helpersModule), escapeLeadingUnderscores(name), SymbolFlags.Value));                                     if (!symbol) {                                         error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name);                                     }                                     else if (helper & ExternalEmitHelpers.ClassPrivateFieldGet) {                                         if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 3)) {                                             error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 4);                                         }                                     }                                     else if (helper & ExternalEmitHelpers.ClassPrivateFieldSet) {                                         if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 4)) {                                             error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 5);                                         }                                     }                                     else if (helper & ExternalEmitHelpers.SpreadArray) {                                         if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 2)) {                                             error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 3);                                         }                                     }                                 }                             }                         } */
                    }
                    /* TODO(ExpressionStatement): links.requestedExternalEmitHelpers |= helpers; */
                }
            }
        }
    }
    getHelperNames := func(helper ExternalEmitHelpers) /* TODO(undefined): string[] */ TODO {
        /* TODO(SwitchStatement): switch (helper) {             case ExternalEmitHelpers.Extends:                 return ["__extends"];             case ExternalEmitHelpers.Assign:                 return ["__assign"];             case ExternalEmitHelpers.Rest:                 return ["__rest"];             case ExternalEmitHelpers.Decorate:                 return legacyDecorators ? ["__decorate"] : ["__esDecorate", "__runInitializers"];             case ExternalEmitHelpers.Metadata:                 return ["__metadata"];             case ExternalEmitHelpers.Param:                 return ["__param"];             case ExternalEmitHelpers.Awaiter:                 return ["__awaiter"];             case ExternalEmitHelpers.Generator:                 return ["__generator"];             case ExternalEmitHelpers.Values:                 return ["__values"];             case ExternalEmitHelpers.Read:                 return ["__read"];             case ExternalEmitHelpers.SpreadArray:                 return ["__spreadArray"];             case ExternalEmitHelpers.Await:                 return ["__await"];             case ExternalEmitHelpers.AsyncGenerator:                 return ["__asyncGenerator"];             case ExternalEmitHelpers.AsyncDelegator:                 return ["__asyncDelegator"];             case ExternalEmitHelpers.AsyncValues:                 return ["__asyncValues"];             case ExternalEmitHelpers.ExportStar:                 return ["__exportStar"];             case ExternalEmitHelpers.ImportStar:                 return ["__importStar"];             case ExternalEmitHelpers.ImportDefault:                 return ["__importDefault"];             case ExternalEmitHelpers.MakeTemplateObject:                 return ["__makeTemplateObject"];             case ExternalEmitHelpers.ClassPrivateFieldGet:                 return ["__classPrivateFieldGet"];             case ExternalEmitHelpers.ClassPrivateFieldSet:                 return ["__classPrivateFieldSet"];             case ExternalEmitHelpers.ClassPrivateFieldIn:                 return ["__classPrivateFieldIn"];             case ExternalEmitHelpers.SetFunctionName:                 return ["__setFunctionName"];             case ExternalEmitHelpers.PropKey:                 return ["__propKey"];             case ExternalEmitHelpers.AddDisposableResourceAndDisposeResources:                 return ["__addDisposableResource", "__disposeResources"];             default:                 return Debug.fail("Unrecognized helper");         } */
    }
    resolveHelpersModule := func(file SourceFile, errorNode Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
        links := getNodeLinks(file)
        if /* TODO(PrefixUnaryExpression): !links.externalHelpersModule */ TODO {
            /* TODO(ExpressionStatement): links.externalHelpersModule = resolveExternalModule(getImportHelpersImportSpecifier(file), externalHelpersModuleNameText, Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || unknownSymbol; */
        }
         /* TODO(PropertyAccessExpression): links.externalHelpersModule */ TODO
    }
    checkGrammarModifiers := func(node /* TODO(UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) bool {
        quickResult := /* TODO(BinaryExpression): reportObviousDecoratorErrors(node) || reportObviousModifierErrors(node) */ TODO
        if /* TODO(BinaryExpression): quickResult !== undefined */ TODO {
             quickResult
        }
        if /* TODO(BinaryExpression): isParameter(node) && parameterIsThisKeyword(node) */ TODO {
             grammarErrorOnFirstToken(node, /* TODO(PropertyAccessExpression): Diagnostics.Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters */ TODO)
        }
        blockScopeKind := /* TODO(ConditionalExpression): isVariableStatement(node) ? node.declarationList.flags & NodeFlags.BlockScoped : NodeFlags.None */ TODO
        var lastStatic Nodevar lastDeclare Nodevar lastAsync Nodevar lastOverride Nodevar firstDecorator *Decorator
        )
        flags := /* TODO(PropertyAccessExpression): ModifierFlags.None */ TODO
        sawExportBeforeDecorators := /* TODO(FalseKeyword): false */ TODO
        hasLeadingDecorators := /* TODO(FalseKeyword): false */ TODO
        /* TODO(ForOfStatement): for (const modifier of (node as HasModifiers).modifiers!) {             if (isDecorator(modifier)) {                 if (!nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent)) {                     if (node.kind === SyntaxKind.MethodDeclaration && !nodeIsPresent(node.body)) {                         return grammarErrorOnFirstToken(node, Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload);                     }                     else {                         return grammarErrorOnFirstToken(node, Diagnostics.Decorators_are_not_valid_here);                     }                 }                 else if (legacyDecorators && (node.kind === SyntaxKind.GetAccessor || node.kind === SyntaxKind.SetAccessor)) {                     const accessors = getAllAccessorDeclarationsForDeclaration(node as AccessorDeclaration);                     if (hasDecorators(accessors.firstAccessor) && node === accessors.secondAccessor) {                         return grammarErrorOnFirstToken(node, Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name);                     }                 }                  // if we've seen any modifiers aside from `export`, `default`, or another decorator, then this is an invalid position                 if (flags & ~(ModifierFlags.ExportDefault | ModifierFlags.Decorator)) {                     return grammarErrorOnNode(modifier, Diagnostics.Decorators_are_not_valid_here);                 }                  // if we've already seen leading decorators and leading modifiers, then trailing decorators are an invalid position                 if (hasLeadingDecorators && flags & ModifierFlags.Modifier) {                     Debug.assertIsDefined(firstDecorator);                     const sourceFile = getSourceFileOfNode(modifier);                     if (!hasParseDiagnostics(sourceFile)) {                         addRelatedInfo(                             error(modifier, Diagnostics.Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export),                             createDiagnosticForNode(firstDecorator, Diagnostics.Decorator_used_before_export_here),                         );                         return true;                     }                     return false;                 }                  flags |= ModifierFlags.Decorator;                  // if we have not yet seen a modifier, then these are leading decorators                 if (!(flags & ModifierFlags.Modifier)) {                     hasLeadingDecorators = true;                 }                 else if (flags & ModifierFlags.Export) {                     sawExportBeforeDecorators = true;                 }                  firstDecorator ??= modifier;             }             else {                 if (modifier.kind !== SyntaxKind.ReadonlyKeyword) {                     if (node.kind === SyntaxKind.PropertySignature || node.kind === SyntaxKind.MethodSignature) {                         return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_member, tokenToString(modifier.kind));                     }                     if (node.kind === SyntaxKind.IndexSignature && (modifier.kind !== SyntaxKind.StaticKeyword || !isClassLike(node.parent))) {                         return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_index_signature, tokenToString(modifier.kind));                     }                 }                 if (modifier.kind !== SyntaxKind.InKeyword && modifier.kind !== SyntaxKind.OutKeyword && modifier.kind !== SyntaxKind.ConstKeyword) {                     if (node.kind === SyntaxKind.TypeParameter) {                         return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_parameter, tokenToString(modifier.kind));                     }                 }                 switch (modifier.kind) {                     case SyntaxKind.ConstKeyword: {                         if (node.kind !== SyntaxKind.EnumDeclaration && node.kind !== SyntaxKind.TypeParameter) {                             return grammarErrorOnNode(node, Diagnostics.A_class_member_cannot_have_the_0_keyword, tokenToString(SyntaxKind.ConstKeyword));                         }                         const parent = (isJSDocTemplateTag(node.parent) && getEffectiveJSDocHost(node.parent)) || node.parent;                         if (                             node.kind === SyntaxKind.TypeParameter && !(isFunctionLikeDeclaration(parent) || isClassLike(parent) || isFunctionTypeNode(parent) ||                                 isConstructorTypeNode(parent) || isCallSignatureDeclaration(parent) || isConstructSignatureDeclaration(parent) || isMethodSignature(parent))                         ) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class, tokenToString(modifier.kind));                         }                         break;                     }                     case SyntaxKind.OverrideKeyword:                         // If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.                         if (flags & ModifierFlags.Override) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "override");                         }                         else if (flags & ModifierFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "override", "declare");                         }                         else if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "readonly");                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "accessor");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "async");                         }                         flags |= ModifierFlags.Override;                         lastOverride = modifier;                         break;                      case SyntaxKind.PublicKeyword:                     case SyntaxKind.ProtectedKeyword:                     case SyntaxKind.PrivateKeyword:                         const text = visibilityToString(modifierToFlag(modifier.kind));                          if (flags & ModifierFlags.AccessibilityModifier) {                             return grammarErrorOnNode(modifier, Diagnostics.Accessibility_modifier_already_seen);                         }                         else if (flags & ModifierFlags.Override) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "override");                         }                         else if (flags & ModifierFlags.Static) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "static");                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "accessor");                         }                         else if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "async");                         }                         else if (node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, text);                         }                         else if (flags & ModifierFlags.Abstract) {                             if (modifier.kind === SyntaxKind.PrivateKeyword) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, text, "abstract");                             }                             else {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "abstract");                             }                         }                         else if (isPrivateIdentifierClassElementDeclaration(node)) {                             return grammarErrorOnNode(modifier, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier);                         }                         flags |= modifierToFlag(modifier.kind);                         break;                      case SyntaxKind.StaticKeyword:                         if (flags & ModifierFlags.Static) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "static");                         }                         else if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "readonly");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "async");                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "accessor");                         }                         else if (node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, "static");                         }                         else if (node.kind === SyntaxKind.Parameter) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static");                         }                         else if (flags & ModifierFlags.Abstract) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");                         }                         else if (flags & ModifierFlags.Override) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "override");                         }                         flags |= ModifierFlags.Static;                         lastStatic = modifier;                         break;                      case SyntaxKind.AccessorKeyword:                         if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "accessor");                         }                         else if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "readonly");                         }                         else if (flags & ModifierFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "declare");                         }                         else if (node.kind !== SyntaxKind.PropertyDeclaration) {                             return grammarErrorOnNode(modifier, Diagnostics.accessor_modifier_can_only_appear_on_a_property_declaration);                         }                          flags |= ModifierFlags.Accessor;                         break;                      case SyntaxKind.ReadonlyKeyword:                         if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "readonly");                         }                         else if (node.kind !== SyntaxKind.PropertyDeclaration && node.kind !== SyntaxKind.PropertySignature && node.kind !== SyntaxKind.IndexSignature && node.kind !== SyntaxKind.Parameter) {                             // If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.                             return grammarErrorOnNode(modifier, Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature);                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "readonly", "accessor");                         }                         flags |= ModifierFlags.Readonly;                         break;                      case SyntaxKind.ExportKeyword:                         if (                             compilerOptions.verbatimModuleSyntax &&                             !(node.flags & NodeFlags.Ambient) &&                             node.kind !== SyntaxKind.TypeAliasDeclaration &&                             node.kind !== SyntaxKind.InterfaceDeclaration &&                             // ModuleDeclaration needs to be checked that it is uninstantiated later                             node.kind !== SyntaxKind.ModuleDeclaration &&                             node.parent.kind === SyntaxKind.SourceFile &&                             host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) === ModuleKind.CommonJS                         ) {                             return grammarErrorOnNode(modifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);                         }                         if (flags & ModifierFlags.Export) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "export");                         }                         else if (flags & ModifierFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare");                         }                         else if (flags & ModifierFlags.Abstract) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "abstract");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "async");                         }                         else if (isClassLike(node.parent)) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "export");                         }                         else if (node.kind === SyntaxKind.Parameter) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export");                         }                         else if (blockScopeKind === NodeFlags.Using) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "export");                         }                         else if (blockScopeKind === NodeFlags.AwaitUsing) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "export");                         }                         flags |= ModifierFlags.Export;                         break;                     case SyntaxKind.DefaultKeyword:                         const container = node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent;                         if (container.kind === SyntaxKind.ModuleDeclaration && !isAmbientModule(container)) {                             return grammarErrorOnNode(modifier, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);                         }                         else if (blockScopeKind === NodeFlags.Using) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "default");                         }                         else if (blockScopeKind === NodeFlags.AwaitUsing) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "default");                         }                         else if (!(flags & ModifierFlags.Export)) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "default");                         }                         else if (sawExportBeforeDecorators) {                             return grammarErrorOnNode(firstDecorator!, Diagnostics.Decorators_are_not_valid_here);                         }                          flags |= ModifierFlags.Default;                         break;                     case SyntaxKind.DeclareKeyword:                         if (flags & ModifierFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "declare");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");                         }                         else if (flags & ModifierFlags.Override) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "override");                         }                         else if (isClassLike(node.parent) && !isPropertyDeclaration(node)) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "declare");                         }                         else if (node.kind === SyntaxKind.Parameter) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare");                         }                         else if (blockScopeKind === NodeFlags.Using) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "declare");                         }                         else if (blockScopeKind === NodeFlags.AwaitUsing) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "declare");                         }                         else if ((node.parent.flags & NodeFlags.Ambient) && node.parent.kind === SyntaxKind.ModuleBlock) {                             return grammarErrorOnNode(modifier, Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);                         }                         else if (isPrivateIdentifierClassElementDeclaration(node)) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "declare");                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "declare", "accessor");                         }                         flags |= ModifierFlags.Ambient;                         lastDeclare = modifier;                         break;                      case SyntaxKind.AbstractKeyword:                         if (flags & ModifierFlags.Abstract) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "abstract");                         }                         if (                             node.kind !== SyntaxKind.ClassDeclaration &&                             node.kind !== SyntaxKind.ConstructorType                         ) {                             if (                                 node.kind !== SyntaxKind.MethodDeclaration &&                                 node.kind !== SyntaxKind.PropertyDeclaration &&                                 node.kind !== SyntaxKind.GetAccessor &&                                 node.kind !== SyntaxKind.SetAccessor                             ) {                                 return grammarErrorOnNode(modifier, Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration);                             }                             if (!(node.parent.kind === SyntaxKind.ClassDeclaration && hasSyntacticModifier(node.parent, ModifierFlags.Abstract))) {                                 const message = node.kind === SyntaxKind.PropertyDeclaration                                     ? Diagnostics.Abstract_properties_can_only_appear_within_an_abstract_class                                     : Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class;                                 return grammarErrorOnNode(modifier, message);                             }                             if (flags & ModifierFlags.Static) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");                             }                             if (flags & ModifierFlags.Private) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "private", "abstract");                             }                             if (flags & ModifierFlags.Async && lastAsync) {                                 return grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");                             }                             if (flags & ModifierFlags.Override) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "override");                             }                             if (flags & ModifierFlags.Accessor) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "accessor");                             }                         }                         if (isNamedDeclaration(node) && node.name.kind === SyntaxKind.PrivateIdentifier) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "abstract");                         }                          flags |= ModifierFlags.Abstract;                         break;                      case SyntaxKind.AsyncKeyword:                         if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "async");                         }                         else if (flags & ModifierFlags.Ambient || node.parent.flags & NodeFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");                         }                         else if (node.kind === SyntaxKind.Parameter) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async");                         }                         if (flags & ModifierFlags.Abstract) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");                         }                         flags |= ModifierFlags.Async;                         lastAsync = modifier;                         break;                      case SyntaxKind.InKeyword:                     case SyntaxKind.OutKeyword: {                         const inOutFlag = modifier.kind === SyntaxKind.InKeyword ? ModifierFlags.In : ModifierFlags.Out;                         const inOutText = modifier.kind === SyntaxKind.InKeyword ? "in" : "out";                         const parent = isJSDocTemplateTag(node.parent) && (getEffectiveJSDocHost(node.parent) || find(getJSDocRoot(node.parent)?.tags, isJSDocTypedefTag)) || node.parent;                         if (node.kind !== SyntaxKind.TypeParameter || parent && !(isInterfaceDeclaration(parent) || isClassLike(parent) || isTypeAliasDeclaration(parent) || isJSDocTypedefTag(parent))) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias, inOutText);                         }                         if (flags & inOutFlag) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, inOutText);                         }                         if (inOutFlag & ModifierFlags.In && flags & ModifierFlags.Out) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "in", "out");                         }                         flags |= inOutFlag;                         break;                     }                 }             }         } */
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.Constructor */ TODO {
            if /* TODO(BinaryExpression): flags & ModifierFlags.Static */ TODO {
                 grammarErrorOnNode(/* TODO(NonNullExpression): lastStatic! */ TODO, /* TODO(PropertyAccessExpression): Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration */ TODO, "static")
            }
            if /* TODO(BinaryExpression): flags & ModifierFlags.Override */ TODO {
                 grammarErrorOnNode(/* TODO(NonNullExpression): lastOverride! */ TODO, /* TODO(PropertyAccessExpression): Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration */ TODO, "override")
            }
            if /* TODO(BinaryExpression): flags & ModifierFlags.Async */ TODO {
                 grammarErrorOnNode(/* TODO(NonNullExpression): lastAsync! */ TODO, /* TODO(PropertyAccessExpression): Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration */ TODO, "async")
            }
             /* TODO(FalseKeyword): false */ TODO
        } else if /* TODO(BinaryExpression): (node.kind === SyntaxKind.ImportDeclaration || node.kind === SyntaxKind.ImportEqualsDeclaration) && flags & ModifierFlags.Ambient */ TODO {
             grammarErrorOnNode(/* TODO(NonNullExpression): lastDeclare! */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration */ TODO, "declare")
        } else if /* TODO(BinaryExpression): node.kind === SyntaxKind.Parameter && (flags & ModifierFlags.ParameterPropertyModifier) && isBindingPattern(node.name) */ TODO {
             grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern */ TODO)
        } else if /* TODO(BinaryExpression): node.kind === SyntaxKind.Parameter && (flags & ModifierFlags.ParameterPropertyModifier) && node.dotDotDotToken */ TODO {
             grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter */ TODO)
        }
        if /* TODO(BinaryExpression): flags & ModifierFlags.Async */ TODO {
             checkGrammarAsyncModifier(node, /* TODO(NonNullExpression): lastAsync! */ TODO)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    reportObviousModifierErrors := func(node /* TODO(UnionType): HasModifiers | HasIllegalModifiers */ any) /* TODO(BooleanKeyword): boolean */ any {
        if /* TODO(PrefixUnaryExpression): !node.modifiers */ TODO {
            /* TODO(FalseKeyword): false */
        }
        modifier := findFirstIllegalModifier(node)
         /* TODO(BinaryExpression): modifier && grammarErrorOnFirstToken(modifier, Diagnostics.Modifiers_cannot_appear_here) */ TODO
    }
    findFirstModifierExcept := func(node HasModifiers, allowedModifier SyntaxKind) *Modifier {
        modifier := find(/* TODO(PropertyAccessExpression): node.modifiers */ TODO, isModifier)
         /* TODO(ConditionalExpression): modifier && modifier.kind !== allowedModifier ? modifier : undefined */ TODO
    }
    findFirstIllegalModifier := func(node /* TODO(UnionType): HasModifiers | HasIllegalModifiers */ any) *Modifier {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:             case SyntaxKind.Constructor:             case SyntaxKind.PropertyDeclaration:             case SyntaxKind.PropertySignature:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:             case SyntaxKind.IndexSignature:             case SyntaxKind.ModuleDeclaration:             case SyntaxKind.ImportDeclaration:             case SyntaxKind.ImportEqualsDeclaration:             case SyntaxKind.ExportDeclaration:             case SyntaxKind.ExportAssignment:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.Parameter:             case SyntaxKind.TypeParameter:                 return undefined;             case SyntaxKind.ClassStaticBlockDeclaration:             case SyntaxKind.PropertyAssignment:             case SyntaxKind.ShorthandPropertyAssignment:             case SyntaxKind.NamespaceExportDeclaration:             case SyntaxKind.MissingDeclaration:                 return find(node.modifiers, isModifier);             default:                 if (node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile) {                     return undefined;                 }                 switch (node.kind) {                     case SyntaxKind.FunctionDeclaration:                         return findFirstModifierExcept(node, SyntaxKind.AsyncKeyword);                     case SyntaxKind.ClassDeclaration:                     case SyntaxKind.ConstructorType:                         return findFirstModifierExcept(node, SyntaxKind.AbstractKeyword);                     case SyntaxKind.ClassExpression:                     case SyntaxKind.InterfaceDeclaration:                     case SyntaxKind.TypeAliasDeclaration:                         return find(node.modifiers, isModifier);                     case SyntaxKind.VariableStatement:                         return node.declarationList.flags & NodeFlags.Using ?                             findFirstModifierExcept(node, SyntaxKind.AwaitKeyword) :                             find(node.modifiers, isModifier);                     case SyntaxKind.EnumDeclaration:                         return findFirstModifierExcept(node, SyntaxKind.ConstKeyword);                     default:                         Debug.assertNever(node);                 }         } */
    }
    reportObviousDecoratorErrors := func(node /* TODO(UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) /* TODO(undefined): boolean | undefined */ TODO {
        decorator := findFirstIllegalDecorator(node)
         /* TODO(BinaryExpression): decorator && grammarErrorOnFirstToken(decorator, Diagnostics.Decorators_are_not_valid_here) */ TODO
    }
    findFirstIllegalDecorator := func(node /* TODO(UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) *Decorator {
         /* TODO(ConditionalExpression): canHaveIllegalDecorators(node) ? find(node.modifiers, isDecorator) : undefined */ TODO
    }
    checkGrammarAsyncModifier := func(node Node, asyncModifier Node) bool {
        /* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.MethodDeclaration:             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:                 return false;         } */
         grammarErrorOnNode(asyncModifier, /* TODO(PropertyAccessExpression): Diagnostics._0_modifier_cannot_be_used_here */ TODO, "async")
    }
    checkGrammarForDisallowedTrailingComma := func(list *NodeArray[Node], diag /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO /* = */ /* TODO(PropertyAccessExpression): Diagnostics.Trailing_comma_not_allowed */) bool {
        if /* TODO(BinaryExpression): list && list.hasTrailingComma */ TODO {
             grammarErrorAtPos(/* TODO(ElementAccessExpression): list[0] */ TODO, /* TODO(BinaryExpression): list.end - ",".length */ TODO, /* TODO(PropertyAccessExpression): ",".length */ TODO, diag)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarTypeParameterList := func(typeParameters *NodeArray[TypeParameterDeclaration], file SourceFile) bool {
        if /* TODO(BinaryExpression): typeParameters && typeParameters.length === 0 */ TODO {
            start := /* TODO(BinaryExpression): typeParameters.pos - "<".length */ TODO
            end := /* TODO(BinaryExpression): skipTrivia(file.text, typeParameters.end) + ">".length */ TODO
             grammarErrorAtPos(file, start, /* TODO(BinaryExpression): end - start */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Type_parameter_list_cannot_be_empty */ TODO)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarParameterList := func(parameters NodeArray[ParameterDeclaration]) /* TODO(undefined): boolean | undefined */ TODO {
        seenOptionalParameter := /* TODO(FalseKeyword): false */ TODO
        parameterCount := /* TODO(PropertyAccessExpression): parameters.length */ TODO
        /* TODO(ForStatement): for (let i = 0; i < parameterCount; i++) {             const parameter = parameters[i];             if (parameter.dotDotDotToken) {                 if (i !== (parameterCount - 1)) {                     return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);                 }                 if (!(parameter.flags & NodeFlags.Ambient)) { // Allow `...foo,` in ambient declarations; see GH#23070                     checkGrammarForDisallowedTrailingComma(parameters, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);                 }                  if (parameter.questionToken) {                     return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_rest_parameter_cannot_be_optional);                 }                  if (parameter.initializer) {                     return grammarErrorOnNode(parameter.name, Diagnostics.A_rest_parameter_cannot_have_an_initializer);                 }             }             else if (hasEffectiveQuestionToken(parameter)) {                 seenOptionalParameter = true;                 if (parameter.questionToken && parameter.initializer) {                     return grammarErrorOnNode(parameter.name, Diagnostics.Parameter_cannot_have_question_mark_and_initializer);                 }             }             else if (seenOptionalParameter && !parameter.initializer) {                 return grammarErrorOnNode(parameter.name, Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);             }         } */
    }
    getNonSimpleParameters := func(parameters []ParameterDeclaration) []ParameterDeclaration {
         filter(parameters, /* TODO(ArrowFunction): parameter => !!parameter.initializer || isBindingPattern(parameter.name) || isRestParameter(parameter) */ TODO)
    }
    checkGrammarForUseStrictSimpleParameterList := func(node FunctionLikeDeclaration) bool {
        if /* TODO(BinaryExpression): languageVersion >= ScriptTarget.ES2016 */ TODO {
            useStrictDirective := /* TODO(BinaryExpression): node.body && isBlock(node.body) && findUseStrictPrologue(node.body.statements) */ TODO
            if useStrictDirective {
                nonSimpleParameters := getNonSimpleParameters(/* TODO(PropertyAccessExpression): node.parameters */ TODO)
                if length(nonSimpleParameters) {
                    /* TODO(ExpressionStatement): forEach(nonSimpleParameters, parameter => {                         addRelatedInfo(                             error(parameter, Diagnostics.This_parameter_is_not_allowed_with_use_strict_directive),                             createDiagnosticForNode(useStrictDirective, Diagnostics.use_strict_directive_used_here),                         );                     }); */
                    diagnostics := /* TODO(PropertyAccessExpression): nonSimpleParameters.map */ TODO(/* TODO(ArrowFunction): (parameter, index) => (                         index === 0 ? createDiagnosticForNode(parameter, Diagnostics.Non_simple_parameter_declared_here) : createDiagnosticForNode(parameter, Diagnostics.and_here)                     ) */ TODO) /* as */ /* TODO(TupleType): [DiagnosticWithLocation, ...DiagnosticWithLocation[]] */
                    /* TODO(ExpressionStatement): addRelatedInfo(error(useStrictDirective, Diagnostics.use_strict_directive_cannot_be_used_with_non_simple_parameter_list), ...diagnostics); */
                     /* TODO(TrueKeyword): true */ TODO
                }
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarFunctionLikeDeclaration := func(node /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any) bool {
        file := getSourceFileOfNode(node)
         /* TODO(BinaryExpression): checkGrammarModifiers(node) ||             checkGrammarTypeParameterList(node.typeParameters, file) ||             checkGrammarParameterList(node.parameters) ||             checkGrammarArrowFunction(node, file) ||             (isFunctionLikeDeclaration(node) && checkGrammarForUseStrictSimpleParameterList(node)) */ TODO
    }
    checkGrammarClassLikeDeclaration := func(node ClassLikeDeclaration) bool {
        file := getSourceFileOfNode(node)
         /* TODO(BinaryExpression): checkGrammarClassDeclarationHeritageClauses(node) ||             checkGrammarTypeParameterList(node.typeParameters, file) */ TODO
    }
    checkGrammarArrowFunction := func(node Node, file SourceFile) bool {
        if /* TODO(PrefixUnaryExpression): !isArrowFunction(node) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): node.typeParameters && !(length(node.typeParameters) > 1 || node.typeParameters.hasTrailingComma || node.typeParameters[0].constraint) */ TODO {
            if /* TODO(BinaryExpression): file && fileExtensionIsOneOf(file.fileName, [Extension.Mts, Extension.Cts]) */ TODO {
                /* TODO(ExpressionStatement): grammarErrorOnNode(node.typeParameters[0], Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint); */
            }
        }
        TODO_IDENTIFIER := node
        startLine := /* TODO(PropertyAccessExpression): getLineAndCharacterOfPosition(file, equalsGreaterThanToken.pos).line */ TODO
        endLine := /* TODO(PropertyAccessExpression): getLineAndCharacterOfPosition(file, equalsGreaterThanToken.end).line */ TODO
         /* TODO(BinaryExpression): startLine !== endLine && grammarErrorOnNode(equalsGreaterThanToken, Diagnostics.Line_terminator_not_permitted_before_arrow) */ TODO
    }
    checkGrammarIndexSignatureParameters := func(node SignatureDeclaration) bool {
        parameter := /* TODO(ElementAccessExpression): node.parameters[0] */ TODO
        if /* TODO(BinaryExpression): node.parameters.length !== 1 */ TODO {
            if parameter {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): parameter.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_must_have_exactly_one_parameter */ TODO)
            } else {
                 grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_must_have_exactly_one_parameter */ TODO)
            }
        }
        /* TODO(ExpressionStatement): checkGrammarForDisallowedTrailingComma(node.parameters, Diagnostics.An_index_signature_cannot_have_a_trailing_comma); */
        if /* TODO(PropertyAccessExpression): parameter.dotDotDotToken */ TODO {
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): parameter.dotDotDotToken */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_cannot_have_a_rest_parameter */ TODO)
        }
        if hasEffectiveModifiers(parameter) {
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): parameter.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier */ TODO)
        }
        if /* TODO(PropertyAccessExpression): parameter.questionToken */ TODO {
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): parameter.questionToken */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark */ TODO)
        }
        if /* TODO(PropertyAccessExpression): parameter.initializer */ TODO {
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): parameter.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_parameter_cannot_have_an_initializer */ TODO)
        }
        if /* TODO(PrefixUnaryExpression): !parameter.type */ TODO {
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): parameter.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_parameter_must_have_a_type_annotation */ TODO)
        }
        type_ := getTypeFromTypeNode(/* TODO(PropertyAccessExpression): parameter.type */ TODO)
        if /* TODO(BinaryExpression): someType(type, t => !!(t.flags & TypeFlags.StringOrNumberLiteralOrUnique)) || isGenericType(type) */ TODO {
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): parameter.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead */ TODO)
        }
        if /* TODO(PrefixUnaryExpression): !everyType(type, isValidIndexKeyType) */ TODO {
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): parameter.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type */ TODO)
        }
        if /* TODO(PrefixUnaryExpression): !node.type */ TODO {
             grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_must_have_a_type_annotation */ TODO)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarIndexSignature := func(node IndexSignatureDeclaration) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): checkGrammarModifiers(node) || checkGrammarIndexSignatureParameters(node) */ TODO
    }
    checkGrammarForAtLeastOneTypeArgument := func(node Node, typeArguments *NodeArray[TypeNode]) bool {
        if /* TODO(BinaryExpression): typeArguments && typeArguments.length === 0 */ TODO {
            sourceFile := getSourceFileOfNode(node)
            start := /* TODO(BinaryExpression): typeArguments.pos - "<".length */ TODO
            end := /* TODO(BinaryExpression): skipTrivia(sourceFile.text, typeArguments.end) + ">".length */ TODO
             grammarErrorAtPos(sourceFile, start, /* TODO(BinaryExpression): end - start */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Type_argument_list_cannot_be_empty */ TODO)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarTypeArguments := func(node Node, typeArguments *NodeArray[TypeNode]) bool {
         /* TODO(BinaryExpression): checkGrammarForDisallowedTrailingComma(typeArguments) ||             checkGrammarForAtLeastOneTypeArgument(node, typeArguments) */ TODO
    }
    checkGrammarTaggedTemplateChain := func(node TaggedTemplateExpression) bool {
        if /* TODO(BinaryExpression): node.questionDotToken || node.flags & NodeFlags.OptionalChain */ TODO {
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.template */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain */ TODO)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarHeritageClause := func(node HeritageClause) bool {
        types := /* TODO(PropertyAccessExpression): node.types */ TODO
        if checkGrammarForDisallowedTrailingComma(types) {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): types && types.length === 0 */ TODO {
            listType := tokenToString(/* TODO(PropertyAccessExpression): node.token */ TODO)
             grammarErrorAtPos(node, /* TODO(PropertyAccessExpression): types.pos */ TODO, 0, /* TODO(PropertyAccessExpression): Diagnostics._0_list_cannot_be_empty */ TODO, listType)
        }
         some(types, checkGrammarExpressionWithTypeArguments)
    }
    checkGrammarExpressionWithTypeArguments := func(node /* TODO(UnionType): ExpressionWithTypeArguments | TypeQueryNode */ any) /* TODO(undefined): boolean */ TODO {
        if /* TODO(BinaryExpression): isExpressionWithTypeArguments(node) && isImportKeyword(node.expression) && node.typeArguments */ TODO {
             grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments */ TODO)
        }
         checkGrammarTypeArguments(node, /* TODO(PropertyAccessExpression): node.typeArguments */ TODO)
    }
    checkGrammarClassDeclarationHeritageClauses := func(node ClassLikeDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
        seenExtendsClause := /* TODO(FalseKeyword): false */ TODO
        seenImplementsClause := /* TODO(FalseKeyword): false */ TODO
        if /* TODO(BinaryExpression): !checkGrammarModifiers(node) && node.heritageClauses */ TODO {
            /* TODO(ForOfStatement): for (const heritageClause of node.heritageClauses) {                 if (heritageClause.token === SyntaxKind.ExtendsKeyword) {                     if (seenExtendsClause) {                         return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen);                     }                      if (seenImplementsClause) {                         return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_must_precede_implements_clause);                     }                      if (heritageClause.types.length > 1) {                         return grammarErrorOnFirstToken(heritageClause.types[1], Diagnostics.Classes_can_only_extend_a_single_class);                     }                      seenExtendsClause = true;                 }                 else {                     Debug.assert(heritageClause.token === SyntaxKind.ImplementsKeyword);                     if (seenImplementsClause) {                         return grammarErrorOnFirstToken(heritageClause, Diagnostics.implements_clause_already_seen);                     }                      seenImplementsClause = true;                 }                  // Grammar checking heritageClause inside class declaration                 checkGrammarHeritageClause(heritageClause);             } */
        }
    }
    checkGrammarInterfaceDeclaration := func(node InterfaceDeclaration) /* TODO(undefined): boolean */ TODO {
        seenExtendsClause := /* TODO(FalseKeyword): false */ TODO
        if /* TODO(PropertyAccessExpression): node.heritageClauses */ TODO {
            /* TODO(ForOfStatement): for (const heritageClause of node.heritageClauses) {                 if (heritageClause.token === SyntaxKind.ExtendsKeyword) {                     if (seenExtendsClause) {                         return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen);                     }                      seenExtendsClause = true;                 }                 else {                     Debug.assert(heritageClause.token === SyntaxKind.ImplementsKeyword);                     return grammarErrorOnFirstToken(heritageClause, Diagnostics.Interface_declaration_cannot_have_implements_clause);                 }                  // Grammar checking heritageClause inside class declaration                 checkGrammarHeritageClause(heritageClause);             } */
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarComputedPropertyName := func(node Node) bool {
        if /* TODO(BinaryExpression): node.kind !== SyntaxKind.ComputedPropertyName */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
        computedPropertyName := node /* as */ /* TODO(TypeReference): ComputedPropertyName */
        if /* TODO(BinaryExpression): computedPropertyName.expression.kind === SyntaxKind.BinaryExpression && (computedPropertyName.expression as BinaryExpression).operatorToken.kind === SyntaxKind.CommaToken */ TODO {
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): computedPropertyName.expression */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name */ TODO)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarForGenerator := func(node FunctionLikeDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
        if /* TODO(PropertyAccessExpression): node.asteriskToken */ TODO {
            /* TODO(ExpressionStatement): Debug.assert(                 node.kind === SyntaxKind.FunctionDeclaration ||                     node.kind === SyntaxKind.FunctionExpression ||                     node.kind === SyntaxKind.MethodDeclaration,             ); */
            if /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.asteriskToken */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Generators_are_not_allowed_in_an_ambient_context */ TODO)
            }
            if /* TODO(PrefixUnaryExpression): !node.body */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.asteriskToken */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator */ TODO)
            }
        }
    }
    checkGrammarForInvalidQuestionMark := func(questionToken *QuestionToken, message DiagnosticMessage) bool {
         /* TODO(BinaryExpression): !!questionToken && grammarErrorOnNode(questionToken, message) */ TODO
    }
    checkGrammarForInvalidExclamationToken := func(exclamationToken *ExclamationToken, message DiagnosticMessage) bool {
         /* TODO(BinaryExpression): !!exclamationToken && grammarErrorOnNode(exclamationToken, message) */ TODO
    }
    checkGrammarObjectLiteralExpression := func(node ObjectLiteralExpression, inDestructuring bool) /* TODO(undefined): boolean | undefined */ TODO {
        seen := /* TODO(NewExpression): new Map<__String, DeclarationMeaning>() */ TODO
        /* TODO(ForOfStatement): for (const prop of node.properties) {             if (prop.kind === SyntaxKind.SpreadAssignment) {                 if (inDestructuring) {                     // a rest property cannot be destructured any further                     const expression = skipParentheses(prop.expression);                     if (isArrayLiteralExpression(expression) || isObjectLiteralExpression(expression)) {                         return grammarErrorOnNode(prop.expression, Diagnostics.A_rest_element_cannot_contain_a_binding_pattern);                     }                 }                 continue;             }             const name = prop.name;             if (name.kind === SyntaxKind.ComputedPropertyName) {                 // If the name is not a ComputedPropertyName, the grammar checking will skip it                 checkGrammarComputedPropertyName(name);             }              if (prop.kind === SyntaxKind.ShorthandPropertyAssignment && !inDestructuring && prop.objectAssignmentInitializer) {                 // having objectAssignmentInitializer is only valid in ObjectAssignmentPattern                 // outside of destructuring it is a syntax error                 grammarErrorOnNode(prop.equalsToken!, Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern);             }              if (name.kind === SyntaxKind.PrivateIdentifier) {                 grammarErrorOnNode(name, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);             }              // Modifiers are never allowed on properties except for 'async' on a method declaration             if (canHaveModifiers(prop) && prop.modifiers) {                 for (const mod of prop.modifiers) {                     if (isModifier(mod) && (mod.kind !== SyntaxKind.AsyncKeyword || prop.kind !== SyntaxKind.MethodDeclaration)) {                         grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod));                     }                 }             }             else if (canHaveIllegalModifiers(prop) && prop.modifiers) {                 for (const mod of prop.modifiers) {                     if (isModifier(mod)) {                         grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod));                     }                 }             }              // ECMA-262 11.1.5 Object Initializer             // If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true             // a.This production is contained in strict code and IsDataDescriptor(previous) is true and             // IsDataDescriptor(propId.descriptor) is true.             //    b.IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true.             //    c.IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true.             //    d.IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true             // and either both previous and propId.descriptor have[[Get]] fields or both previous and propId.descriptor have[[Set]] fields             let currentKind: DeclarationMeaning;             switch (prop.kind) {                 case SyntaxKind.ShorthandPropertyAssignment:                 case SyntaxKind.PropertyAssignment:                     // Grammar checking for computedPropertyName and shorthandPropertyAssignment                     checkGrammarForInvalidExclamationToken(prop.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context);                     checkGrammarForInvalidQuestionMark(prop.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional);                     if (name.kind === SyntaxKind.NumericLiteral) {                         checkGrammarNumericLiteral(name);                     }                     if (name.kind === SyntaxKind.BigIntLiteral) {                         addErrorOrSuggestion(/*isError* / true, createDiagnosticForNode(name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name));                     }                     currentKind = DeclarationMeaning.PropertyAssignment;                     break;                 case SyntaxKind.MethodDeclaration:                     currentKind = DeclarationMeaning.Method;                     break;                 case SyntaxKind.GetAccessor:                     currentKind = DeclarationMeaning.GetAccessor;                     break;                 case SyntaxKind.SetAccessor:                     currentKind = DeclarationMeaning.SetAccessor;                     break;                 default:                     Debug.assertNever(prop, "Unexpected syntax kind:" + (prop as Node).kind);             }              if (!inDestructuring) {                 const effectiveName = getEffectivePropertyNameForPropertyNameNode(name);                 if (effectiveName === undefined) {                     continue;                 }                  const existingKind = seen.get(effectiveName);                 if (!existingKind) {                     seen.set(effectiveName, currentKind);                 }                 else {                     if ((currentKind & DeclarationMeaning.Method) && (existingKind & DeclarationMeaning.Method)) {                         grammarErrorOnNode(name, Diagnostics.Duplicate_identifier_0, getTextOfNode(name));                     }                     else if ((currentKind & DeclarationMeaning.PropertyAssignment) && (existingKind & DeclarationMeaning.PropertyAssignment)) {                         grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name, getTextOfNode(name));                     }                     else if ((currentKind & DeclarationMeaning.GetOrSetAccessor) && (existingKind & DeclarationMeaning.GetOrSetAccessor)) {                         if (existingKind !== DeclarationMeaning.GetOrSetAccessor && currentKind !== existingKind) {                             seen.set(effectiveName, currentKind | existingKind);                         }                         else {                             return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);                         }                     }                     else {                         return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);                     }                 }             }         } */
    }
    checkGrammarJsxElement := func(node JsxOpeningLikeElement) /* TODO(undefined): boolean | undefined */ TODO {
        /* TODO(ExpressionStatement): checkGrammarJsxName(node.tagName); */
        /* TODO(ExpressionStatement): checkGrammarTypeArguments(node, node.typeArguments); */
        seen := /* TODO(NewExpression): new Map<__String, boolean>() */ TODO
        /* TODO(ForOfStatement): for (const attr of node.attributes.properties) {             if (attr.kind === SyntaxKind.JsxSpreadAttribute) {                 continue;             }              const { name, initializer } = attr;             const escapedText = getEscapedTextOfJsxAttributeName(name);             if (!seen.get(escapedText)) {                 seen.set(escapedText, true);             }             else {                 return grammarErrorOnNode(name, Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name);             }              if (initializer && initializer.kind === SyntaxKind.JsxExpression && !initializer.expression) {                 return grammarErrorOnNode(initializer, Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression);             }         } */
    }
    checkGrammarJsxName := func(node JsxTagNameExpression) /* TODO(undefined): boolean | undefined */ TODO {
        if /* TODO(BinaryExpression): isPropertyAccessExpression(node) && isJsxNamespacedName(node.expression) */ TODO {
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.expression */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names */ TODO)
        }
        if /* TODO(BinaryExpression): isJsxNamespacedName(node) && getJSXTransformEnabled(compilerOptions) && !isIntrinsicJsxName(node.namespace.escapedText) */ TODO {
             grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.React_components_cannot_include_JSX_namespace_names */ TODO)
        }
    }
    checkGrammarJsxExpression := func(node JsxExpression) /* TODO(undefined): boolean | undefined */ TODO {
        if /* TODO(BinaryExpression): node.expression && isCommaSequence(node.expression) */ TODO {
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.expression */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array */ TODO)
        }
    }
    checkGrammarForInOrForOfStatement := func(forInOrOfStatement ForInOrOfStatement) bool {
        if checkGrammarStatementInAmbientContext(forInOrOfStatement) {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): forInOrOfStatement.kind === SyntaxKind.ForOfStatement && forInOrOfStatement.awaitModifier */ TODO {
            if /* TODO(PrefixUnaryExpression): !(forInOrOfStatement.flags & NodeFlags.AwaitContext) */ TODO {
                sourceFile := getSourceFileOfNode(forInOrOfStatement)
                if isInTopLevelContext(forInOrOfStatement) {
                    if /* TODO(PrefixUnaryExpression): !hasParseDiagnostics(sourceFile) */ TODO {
                        if /* TODO(PrefixUnaryExpression): !isEffectiveExternalModule(sourceFile, compilerOptions) */ TODO {
                            /* TODO(ExpressionStatement): diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module)); */
                        }
                        /* TODO(SwitchStatement): switch (moduleKind) {                             case ModuleKind.Node16:                             case ModuleKind.NodeNext:                                 if (sourceFile.impliedNodeFormat === ModuleKind.CommonJS) {                                     diagnostics.add(                                         createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level),                                     );                                     break;                                 }                                 // fallthrough                             case ModuleKind.ES2022:                             case ModuleKind.ESNext:                             case ModuleKind.Preserve:                             case ModuleKind.System:                                 if (languageVersion >= ScriptTarget.ES2017) {                                     break;                                 }                                 // fallthrough                             default:                                 diagnostics.add(                                     createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher),                                 );                                 break;                         } */
                    }
                } else {
                    if /* TODO(PrefixUnaryExpression): !hasParseDiagnostics(sourceFile) */ TODO {
                        diagnostic := createDiagnosticForNode(/* TODO(PropertyAccessExpression): forInOrOfStatement.awaitModifier */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules */ TODO)
                        func_ := getContainingFunction(forInOrOfStatement)
                        if /* TODO(BinaryExpression): func && func.kind !== SyntaxKind.Constructor */ TODO {
                            /* TODO(ExpressionStatement): Debug.assert((getFunctionFlags(func) & FunctionFlags.Async) === 0, "Enclosing function should never be an async function."); */
                            relatedInfo := createDiagnosticForNode(func_, /* TODO(PropertyAccessExpression): Diagnostics.Did_you_mean_to_mark_this_function_as_async */ TODO)
                            /* TODO(ExpressionStatement): addRelatedInfo(diagnostic, relatedInfo); */
                        }
                        /* TODO(ExpressionStatement): diagnostics.add(diagnostic); */
                         /* TODO(TrueKeyword): true */ TODO
                    }
                }
            }
        }
        if /* TODO(BinaryExpression): isForOfStatement(forInOrOfStatement) && !(forInOrOfStatement.flags & NodeFlags.AwaitContext) &&             isIdentifier(forInOrOfStatement.initializer) && forInOrOfStatement.initializer.escapedText === "async" */ TODO {
            /* TODO(ExpressionStatement): grammarErrorOnNode(forInOrOfStatement.initializer, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async); */
             /* TODO(FalseKeyword): false */ TODO
        }
        if /* TODO(BinaryExpression): forInOrOfStatement.initializer.kind === SyntaxKind.VariableDeclarationList */ TODO {
            variableList := /* TODO(PropertyAccessExpression): forInOrOfStatement.initializer */ TODO /* as */ /* TODO(TypeReference): VariableDeclarationList */
            if /* TODO(PrefixUnaryExpression): !checkGrammarVariableDeclarationList(variableList) */ TODO {
                declarations := /* TODO(PropertyAccessExpression): variableList.declarations */ TODO
                if /* TODO(PrefixUnaryExpression): !declarations.length */ TODO {
                     /* TODO(FalseKeyword): false */ TODO
                }
                if /* TODO(BinaryExpression): declarations.length > 1 */ TODO {
                    diagnostic := /* TODO(ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement                         ? Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement                         : Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement */ TODO
                     grammarErrorOnFirstToken(/* TODO(ElementAccessExpression): variableList.declarations[1] */ TODO, diagnostic)
                }
                firstDeclaration := /* TODO(ElementAccessExpression): declarations[0] */ TODO
                if /* TODO(PropertyAccessExpression): firstDeclaration.initializer */ TODO {
                    diagnostic := /* TODO(ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement                         ? Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer                         : Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer */ TODO
                     grammarErrorOnNode(/* TODO(PropertyAccessExpression): firstDeclaration.name */ TODO, diagnostic)
                }
                if /* TODO(PropertyAccessExpression): firstDeclaration.type */ TODO {
                    diagnostic := /* TODO(ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement                         ? Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation                         : Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation */ TODO
                     grammarErrorOnNode(firstDeclaration, diagnostic)
                }
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarAccessor := func(accessor AccessorDeclaration) bool {
        if /* TODO(BinaryExpression): !(accessor.flags & NodeFlags.Ambient) && (accessor.parent.kind !== SyntaxKind.TypeLiteral) && (accessor.parent.kind !== SyntaxKind.InterfaceDeclaration) */ TODO {
            if /* TODO(BinaryExpression): languageVersion < ScriptTarget.ES2015 && isPrivateIdentifier(accessor.name) */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): accessor.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher */ TODO)
            }
            if /* TODO(BinaryExpression): accessor.body === undefined && !hasSyntacticModifier(accessor, ModifierFlags.Abstract) */ TODO {
                 grammarErrorAtPos(accessor, /* TODO(BinaryExpression): accessor.end - 1 */ TODO, /* TODO(PropertyAccessExpression): ";".length */ TODO, /* TODO(PropertyAccessExpression): Diagnostics._0_expected */ TODO, "{")
            }
        }
        if /* TODO(PropertyAccessExpression): accessor.body */ TODO {
            if hasSyntacticModifier(accessor, /* TODO(PropertyAccessExpression): ModifierFlags.Abstract */ TODO) {
                 grammarErrorOnNode(accessor, /* TODO(PropertyAccessExpression): Diagnostics.An_abstract_accessor_cannot_have_an_implementation */ TODO)
            }
            if /* TODO(BinaryExpression): accessor.parent.kind === SyntaxKind.TypeLiteral || accessor.parent.kind === SyntaxKind.InterfaceDeclaration */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): accessor.body */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts */ TODO)
            }
        }
        if /* TODO(PropertyAccessExpression): accessor.typeParameters */ TODO {
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): accessor.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.An_accessor_cannot_have_type_parameters */ TODO)
        }
        if /* TODO(PrefixUnaryExpression): !doesAccessorHaveCorrectParameterCount(accessor) */ TODO {
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): accessor.name */ TODO, /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ?                     Diagnostics.A_get_accessor_cannot_have_parameters :                     Diagnostics.A_set_accessor_must_have_exactly_one_parameter */ TODO)
        }
        if /* TODO(BinaryExpression): accessor.kind === SyntaxKind.SetAccessor */ TODO {
            if /* TODO(PropertyAccessExpression): accessor.type */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): accessor.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation */ TODO)
            }
            parameter := /* TODO(PropertyAccessExpression): Debug.checkDefined */ TODO(getSetAccessorValueParameter(accessor), "Return value does not match parameter count assertion.")
            if /* TODO(PropertyAccessExpression): parameter.dotDotDotToken */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): parameter.dotDotDotToken */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_set_accessor_cannot_have_rest_parameter */ TODO)
            }
            if /* TODO(PropertyAccessExpression): parameter.questionToken */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): parameter.questionToken */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_set_accessor_cannot_have_an_optional_parameter */ TODO)
            }
            if /* TODO(PropertyAccessExpression): parameter.initializer */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): accessor.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer */ TODO)
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    doesAccessorHaveCorrectParameterCount := func(accessor AccessorDeclaration) /* TODO(undefined): boolean | import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO {
         /* TODO(BinaryExpression): getAccessorThisParameter(accessor) || accessor.parameters.length === (accessor.kind === SyntaxKind.GetAccessor ? 0 : 1) */ TODO
    }
    getAccessorThisParameter := func(accessor AccessorDeclaration) *ParameterDeclaration {
        if /* TODO(BinaryExpression): accessor.parameters.length === (accessor.kind === SyntaxKind.GetAccessor ? 1 : 2) */ TODO {
             getThisParameter(accessor)
        }
    }
    checkGrammarTypeOperatorNode := func(node TypeOperatorNode) /* TODO(undefined): boolean | undefined */ TODO {
        if /* TODO(BinaryExpression): node.operator === SyntaxKind.UniqueKeyword */ TODO {
            if /* TODO(BinaryExpression): node.type.kind !== SyntaxKind.SymbolKeyword */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.type */ TODO, /* TODO(PropertyAccessExpression): Diagnostics._0_expected */ TODO, tokenToString(/* TODO(PropertyAccessExpression): SyntaxKind.SymbolKeyword */ TODO))
            }
            parent := walkUpParenthesizedTypes(/* TODO(PropertyAccessExpression): node.parent */ TODO)
            if /* TODO(BinaryExpression): isInJSFile(parent) && isJSDocTypeExpression(parent) */ TODO {
                host := getJSDocHost(parent)
                if host {
                    /* TODO(ExpressionStatement): parent = getSingleVariableOfVariableStatement(host) || host; */
                }
            }
            /* TODO(SwitchStatement): switch (parent.kind) {                 case SyntaxKind.VariableDeclaration:                     const decl = parent as VariableDeclaration;                     if (decl.name.kind !== SyntaxKind.Identifier) {                         return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name);                     }                     if (!isVariableDeclarationInVariableStatement(decl)) {                         return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement);                     }                     if (!(decl.parent.flags & NodeFlags.Const)) {                         return grammarErrorOnNode((parent as VariableDeclaration).name, Diagnostics.A_variable_whose_type_is_a_unique_symbol_type_must_be_const);                     }                     break;                  case SyntaxKind.PropertyDeclaration:                     if (                         !isStatic(parent) ||                         !hasEffectiveReadonlyModifier(parent)                     ) {                         return grammarErrorOnNode((parent as PropertyDeclaration).name, Diagnostics.A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly);                     }                     break;                  case SyntaxKind.PropertySignature:                     if (!hasSyntacticModifier(parent, ModifierFlags.Readonly)) {                         return grammarErrorOnNode((parent as PropertySignature).name, Diagnostics.A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly);                     }                     break;                  default:                     return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_not_allowed_here);             } */
        } else if /* TODO(BinaryExpression): node.operator === SyntaxKind.ReadonlyKeyword */ TODO {
            if /* TODO(BinaryExpression): node.type.kind !== SyntaxKind.ArrayType && node.type.kind !== SyntaxKind.TupleType */ TODO {
                 grammarErrorOnFirstToken(node, /* TODO(PropertyAccessExpression): Diagnostics.readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types */ TODO, tokenToString(/* TODO(PropertyAccessExpression): SyntaxKind.SymbolKeyword */ TODO))
            }
        }
    }
    checkGrammarForInvalidDynamicName := func(node DeclarationName, message DiagnosticMessage) /* TODO(undefined): boolean | undefined */ TODO {
        if isNonBindableDynamicName(node) {
             grammarErrorOnNode(node, message)
        }
    }
    checkGrammarMethod := func(node /* TODO(UnionType): MethodDeclaration | MethodSignature */ any) /* TODO(undefined): boolean | undefined */ TODO {
        if checkGrammarFunctionLikeDeclaration(node) {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.MethodDeclaration */ TODO {
            if /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.ObjectLiteralExpression */ TODO {
                if /* TODO(BinaryExpression): node.modifiers && !(node.modifiers.length === 1 && first(node.modifiers).kind === SyntaxKind.AsyncKeyword) */ TODO {
                     grammarErrorOnFirstToken(node, /* TODO(PropertyAccessExpression): Diagnostics.Modifiers_cannot_appear_here */ TODO)
                } else if checkGrammarForInvalidQuestionMark(/* TODO(PropertyAccessExpression): node.questionToken */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.An_object_member_cannot_be_declared_optional */ TODO) {
                     /* TODO(TrueKeyword): true */ TODO
                } else if checkGrammarForInvalidExclamationToken(/* TODO(PropertyAccessExpression): node.exclamationToken */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context */ TODO) {
                     /* TODO(TrueKeyword): true */ TODO
                } else if /* TODO(BinaryExpression): node.body === undefined */ TODO {
                     grammarErrorAtPos(node, /* TODO(BinaryExpression): node.end - 1 */ TODO, /* TODO(PropertyAccessExpression): ";".length */ TODO, /* TODO(PropertyAccessExpression): Diagnostics._0_expected */ TODO, "{")
                }
            }
            if checkGrammarForGenerator(node) {
                 /* TODO(TrueKeyword): true */ TODO
            }
        }
        if isClassLike(/* TODO(PropertyAccessExpression): node.parent */ TODO) {
            if /* TODO(BinaryExpression): languageVersion < ScriptTarget.ES2015 && isPrivateIdentifier(node.name) */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher */ TODO)
            }
            if /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO {
                 checkGrammarForInvalidDynamicName(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type */ TODO)
            } else if /* TODO(BinaryExpression): node.kind === SyntaxKind.MethodDeclaration && !node.body */ TODO {
                 checkGrammarForInvalidDynamicName(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type */ TODO)
            }
        } else if /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.InterfaceDeclaration */ TODO {
             checkGrammarForInvalidDynamicName(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type */ TODO)
        } else if /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.TypeLiteral */ TODO {
             checkGrammarForInvalidDynamicName(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type */ TODO)
        }
    }
    checkGrammarBreakOrContinueStatement := func(node BreakOrContinueStatement) bool {
        var current Node = node
        /* TODO(WhileStatement): while (current) {             if (isFunctionLikeOrClassStaticBlockDeclaration(current)) {                 return grammarErrorOnNode(node, Diagnostics.Jump_target_cannot_cross_function_boundary);             }              switch (current.kind) {                 case SyntaxKind.LabeledStatement:                     if (node.label && (current as LabeledStatement).label.escapedText === node.label.escapedText) {                         // found matching label - verify that label usage is correct                         // continue can only target labels that are on iteration statements                         const isMisplacedContinueLabel = node.kind === SyntaxKind.ContinueStatement                             && !isIterationStatement((current as LabeledStatement).statement, /*lookInLabeledStatements* / true);                          if (isMisplacedContinueLabel) {                             return grammarErrorOnNode(node, Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);                         }                          return false;                     }                     break;                 case SyntaxKind.SwitchStatement:                     if (node.kind === SyntaxKind.BreakStatement && !node.label) {                         // unlabeled break within switch statement - ok                         return false;                     }                     break;                 default:                     if (isIterationStatement(current, /*lookInLabeledStatements* / false) && !node.label) {                         // unlabeled break or continue within iteration statement - ok                         return false;                     }                     break;             }              current = current.parent;         } */
        if /* TODO(PropertyAccessExpression): node.label */ TODO {
            message := /* TODO(ConditionalExpression): node.kind === SyntaxKind.BreakStatement                 ? Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement                 : Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement */ TODO
             grammarErrorOnNode(node, message)
        } else {
            message := /* TODO(ConditionalExpression): node.kind === SyntaxKind.BreakStatement                 ? Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement                 : Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement */ TODO
             grammarErrorOnNode(node, message)
        }
    }
    checkGrammarBindingElement := func(node BindingElement) /* TODO(undefined): boolean | undefined */ TODO {
        if /* TODO(PropertyAccessExpression): node.dotDotDotToken */ TODO {
            elements := /* TODO(PropertyAccessExpression): node.parent.elements */ TODO
            if /* TODO(BinaryExpression): node !== last(elements) */ TODO {
                 grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern */ TODO)
            }
            /* TODO(ExpressionStatement): checkGrammarForDisallowedTrailingComma(elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma); */
            if /* TODO(PropertyAccessExpression): node.propertyName */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_rest_element_cannot_have_a_property_name */ TODO)
            }
        }
        if /* TODO(BinaryExpression): node.dotDotDotToken && node.initializer */ TODO {
             grammarErrorAtPos(node, /* TODO(BinaryExpression): node.initializer.pos - 1 */ TODO, 1, /* TODO(PropertyAccessExpression): Diagnostics.A_rest_element_cannot_have_an_initializer */ TODO)
        }
    }
    isStringOrNumberLiteralExpression := func(expr Expression) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): isStringOrNumericLiteralLike(expr) ||             expr.kind === SyntaxKind.PrefixUnaryExpression && (expr as PrefixUnaryExpression).operator === SyntaxKind.MinusToken &&                 (expr as PrefixUnaryExpression).operand.kind === SyntaxKind.NumericLiteral */ TODO
    }
    isBigIntLiteralExpression := func(expr Expression) /* TODO(undefined): boolean */ TODO {
         /* TODO(BinaryExpression): expr.kind === SyntaxKind.BigIntLiteral ||             expr.kind === SyntaxKind.PrefixUnaryExpression && (expr as PrefixUnaryExpression).operator === SyntaxKind.MinusToken &&                 (expr as PrefixUnaryExpression).operand.kind === SyntaxKind.BigIntLiteral */ TODO
    }
    isSimpleLiteralEnumReference := func(expr Expression) /* TODO(undefined): boolean | undefined */ TODO {
        if /* TODO(BinaryExpression): (isPropertyAccessExpression(expr) || (isElementAccessExpression(expr) && isStringOrNumberLiteralExpression(expr.argumentExpression))) &&             isEntityNameExpression(expr.expression) */ TODO {
             /* TODO(PrefixUnaryExpression): !!(checkExpressionCached(expr).flags & TypeFlags.EnumLike) */ TODO
        }
    }
    checkAmbientInitializer := func(node /* TODO(UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature */ any) /* TODO(undefined): boolean | undefined */ TODO {
        initializer := /* TODO(PropertyAccessExpression): node.initializer */ TODO
        if initializer {
            isInvalidInitializer := /* TODO(PrefixUnaryExpression): !(                 isStringOrNumberLiteralExpression(initializer) ||                 isSimpleLiteralEnumReference(initializer) ||                 initializer.kind === SyntaxKind.TrueKeyword || initializer.kind === SyntaxKind.FalseKeyword ||                 isBigIntLiteralExpression(initializer)             ) */ TODO
            isConstOrReadonly := /* TODO(BinaryExpression): isDeclarationReadonly(node) || isVariableDeclaration(node) && (isVarConstLike(node)) */ TODO
            if /* TODO(BinaryExpression): isConstOrReadonly && !node.type */ TODO {
                if isInvalidInitializer {
                     grammarErrorOnNode(initializer, /* TODO(PropertyAccessExpression): Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference */ TODO)
                }
            } else {
                 grammarErrorOnNode(initializer, /* TODO(PropertyAccessExpression): Diagnostics.Initializers_are_not_allowed_in_ambient_contexts */ TODO)
            }
        }
    }
    checkGrammarVariableDeclaration := func(node VariableDeclaration) /* TODO(undefined): boolean */ TODO {
        nodeFlags := getCombinedNodeFlagsCached(node)
        blockScopeKind := /* TODO(BinaryExpression): nodeFlags & NodeFlags.BlockScoped */ TODO
        if isBindingPattern(/* TODO(PropertyAccessExpression): node.name */ TODO) {
            /* TODO(SwitchStatement): switch (blockScopeKind) {                 case NodeFlags.AwaitUsing:                     return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "await using");                 case NodeFlags.Using:                     return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "using");             } */
        }
        if /* TODO(BinaryExpression): node.parent.parent.kind !== SyntaxKind.ForInStatement && node.parent.parent.kind !== SyntaxKind.ForOfStatement */ TODO {
            if /* TODO(BinaryExpression): nodeFlags & NodeFlags.Ambient */ TODO {
                /* TODO(ExpressionStatement): checkAmbientInitializer(node); */
            } else if /* TODO(PrefixUnaryExpression): !node.initializer */ TODO {
                if /* TODO(BinaryExpression): isBindingPattern(node.name) && !isBindingPattern(node.parent) */ TODO {
                     grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.A_destructuring_declaration_must_have_an_initializer */ TODO)
                }
                /* TODO(SwitchStatement): switch (blockScopeKind) {                     case NodeFlags.AwaitUsing:                         return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "await using");                     case NodeFlags.Using:                         return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "using");                     case NodeFlags.Const:                         return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "const");                 } */
            }
        }
        if /* TODO(BinaryExpression): node.exclamationToken && (node.parent.parent.kind !== SyntaxKind.VariableStatement || !node.type || node.initializer || nodeFlags & NodeFlags.Ambient) */ TODO {
            message := /* TODO(ConditionalExpression): node.initializer                 ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions                 : !node.type                 ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations                 : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context */ TODO
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.exclamationToken */ TODO, message)
        }
        if /* TODO(BinaryExpression): host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKind.System &&             !(node.parent.parent.flags & NodeFlags.Ambient) && hasSyntacticModifier(node.parent.parent, ModifierFlags.Export) */ TODO {
            /* TODO(ExpressionStatement): checkESModuleMarker(node.name); */
        }
         /* TODO(BinaryExpression): !!blockScopeKind && checkGrammarNameInLetOrConstDeclarations(node.name) */ TODO
    }
    checkESModuleMarker := func(name /* TODO(UnionType): Identifier | BindingPattern */ any) bool {
        if /* TODO(BinaryExpression): name.kind === SyntaxKind.Identifier */ TODO {
            if /* TODO(BinaryExpression): idText(name) === "__esModule" */ TODO {
                 grammarErrorOnNodeSkippedOn("noEmit", name, /* TODO(PropertyAccessExpression): Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules */ TODO)
            }
        } else {
            elements := /* TODO(PropertyAccessExpression): name.elements */ TODO
            /* TODO(ForOfStatement): for (const element of elements) {                 if (!isOmittedExpression(element)) {                     return checkESModuleMarker(element.name);                 }             } */
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarNameInLetOrConstDeclarations := func(name /* TODO(UnionType): Identifier | BindingPattern */ any) bool {
        if /* TODO(BinaryExpression): name.kind === SyntaxKind.Identifier */ TODO {
            if /* TODO(BinaryExpression): name.escapedText === "let" */ TODO {
                 grammarErrorOnNode(name, /* TODO(PropertyAccessExpression): Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations */ TODO)
            }
        } else {
            elements := /* TODO(PropertyAccessExpression): name.elements */ TODO
            /* TODO(ForOfStatement): for (const element of elements) {                 if (!isOmittedExpression(element)) {                     checkGrammarNameInLetOrConstDeclarations(element.name);                 }             } */
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarVariableDeclarationList := func(declarationList VariableDeclarationList) bool {
        declarations := /* TODO(PropertyAccessExpression): declarationList.declarations */ TODO
        if checkGrammarForDisallowedTrailingComma(/* TODO(PropertyAccessExpression): declarationList.declarations */ TODO) {
             /* TODO(TrueKeyword): true */ TODO
        }
        if /* TODO(PrefixUnaryExpression): !declarationList.declarations.length */ TODO {
             grammarErrorAtPos(declarationList, /* TODO(PropertyAccessExpression): declarations.pos */ TODO, /* TODO(BinaryExpression): declarations.end - declarations.pos */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Variable_declaration_list_cannot_be_empty */ TODO)
        }
        blockScopeFlags := /* TODO(BinaryExpression): declarationList.flags & NodeFlags.BlockScoped */ TODO
        if /* TODO(BinaryExpression): (blockScopeFlags === NodeFlags.Using || blockScopeFlags === NodeFlags.AwaitUsing) && isForInStatement(declarationList.parent) */ TODO {
             grammarErrorOnNode(declarationList, /* TODO(ConditionalExpression): blockScopeFlags === NodeFlags.Using ?                     Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration :                     Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration */ TODO)
        }
        if /* TODO(BinaryExpression): blockScopeFlags === NodeFlags.AwaitUsing */ TODO {
             checkAwaitGrammar(declarationList)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    allowLetAndConstDeclarations := func(parent Node) bool {
        /* TODO(SwitchStatement): switch (parent.kind) {             case SyntaxKind.IfStatement:             case SyntaxKind.DoStatement:             case SyntaxKind.WhileStatement:             case SyntaxKind.WithStatement:             case SyntaxKind.ForStatement:             case SyntaxKind.ForInStatement:             case SyntaxKind.ForOfStatement:                 return false;             case SyntaxKind.LabeledStatement:                 return allowLetAndConstDeclarations(parent.parent);         } */
         /* TODO(TrueKeyword): true */ TODO
    }
    checkGrammarForDisallowedBlockScopedVariableStatement := func(node VariableStatement) /* TODO(undefined): boolean | undefined */ TODO {
        if /* TODO(PrefixUnaryExpression): !allowLetAndConstDeclarations(node.parent) */ TODO {
            blockScopeKind := /* TODO(BinaryExpression): getCombinedNodeFlagsCached(node.declarationList) & NodeFlags.BlockScoped */ TODO
            if blockScopeKind {
                keyword := /* TODO(ConditionalExpression): blockScopeKind === NodeFlags.Let ? "let" :                     blockScopeKind === NodeFlags.Const ? "const" :                     blockScopeKind === NodeFlags.Using ? "using" :                     blockScopeKind === NodeFlags.AwaitUsing ? "await using" :                     Debug.fail("Unknown BlockScope flag") */ TODO
                 grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics._0_declarations_can_only_be_declared_inside_a_block */ TODO, keyword)
            }
        }
    }
    checkGrammarMetaProperty := func(node MetaProperty) /* TODO(undefined): boolean | undefined */ TODO {
        escapedText := /* TODO(PropertyAccessExpression): node.name.escapedText */ TODO
        /* TODO(SwitchStatement): switch (node.keywordToken) {             case SyntaxKind.NewKeyword:                 if (escapedText !== "target") {                     return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "target");                 }                 break;             case SyntaxKind.ImportKeyword:                 if (escapedText !== "meta") {                     return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "meta");                 }                 break;         } */
    }
    hasParseDiagnostics := func(sourceFile SourceFile) bool {
         /* TODO(BinaryExpression): sourceFile.parseDiagnostics.length > 0 */ TODO
    }
    grammarErrorOnFirstToken := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
        sourceFile := getSourceFileOfNode(node)
        if /* TODO(PrefixUnaryExpression): !hasParseDiagnostics(sourceFile) */ TODO {
            span := getSpanOfTokenAtPosition(sourceFile, /* TODO(PropertyAccessExpression): node.pos */ TODO)
            /* TODO(ExpressionStatement): diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message, ...args)); */
             /* TODO(TrueKeyword): true */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    grammarErrorAtPos := func(nodeForSourceFile Node, start number, length number, message DiagnosticMessage, args DiagnosticArguments) bool {
        sourceFile := getSourceFileOfNode(nodeForSourceFile)
        if /* TODO(PrefixUnaryExpression): !hasParseDiagnostics(sourceFile) */ TODO {
            /* TODO(ExpressionStatement): diagnostics.add(createFileDiagnostic(sourceFile, start, length, message, ...args)); */
             /* TODO(TrueKeyword): true */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    grammarErrorOnNodeSkippedOn := func(key CompilerOptions, node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
        sourceFile := getSourceFileOfNode(node)
        if /* TODO(PrefixUnaryExpression): !hasParseDiagnostics(sourceFile) */ TODO {
            /* TODO(ExpressionStatement): errorSkippedOn(key, node, message, ...args); */
             /* TODO(TrueKeyword): true */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    grammarErrorOnNode := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
        sourceFile := getSourceFileOfNode(node)
        if /* TODO(PrefixUnaryExpression): !hasParseDiagnostics(sourceFile) */ TODO {
            /* TODO(ExpressionStatement): diagnostics.add(createDiagnosticForNode(node, message, ...args)); */
             /* TODO(TrueKeyword): true */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarConstructorTypeParameters := func(node ConstructorDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
        jsdocTypeParameters := /* TODO(ConditionalExpression): isInJSFile(node) ? getJSDocTypeParameterDeclarations(node) : undefined */ TODO
        range_ := /* TODO(BinaryExpression): node.typeParameters || jsdocTypeParameters && firstOrUndefined(jsdocTypeParameters) */ TODO
        if range_ {
            pos := /* TODO(ConditionalExpression): range.pos === range.end ? range.pos : skipTrivia(getSourceFileOfNode(node).text, range.pos) */ TODO
             grammarErrorAtPos(node, pos, /* TODO(BinaryExpression): range.end - pos */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration */ TODO)
        }
    }
    checkGrammarConstructorTypeAnnotation := func(node ConstructorDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
        type_ := /* TODO(BinaryExpression): node.type || getEffectiveReturnTypeNode(node) */ TODO
        if type_ {
             grammarErrorOnNode(type_, /* TODO(PropertyAccessExpression): Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration */ TODO)
        }
    }
    checkGrammarProperty := func(node /* TODO(UnionType): PropertyDeclaration | PropertySignature */ any) /* TODO(undefined): boolean | undefined */ TODO {
        if /* TODO(BinaryExpression): isComputedPropertyName(node.name) && isBinaryExpression(node.name.expression) && node.name.expression.operatorToken.kind === SyntaxKind.InKeyword */ TODO {
             grammarErrorOnNode(/* TODO(ElementAccessExpression): node.parent.members[0] */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_mapped_type_may_not_declare_properties_or_methods */ TODO)
        }
        if isClassLike(/* TODO(PropertyAccessExpression): node.parent */ TODO) {
            if /* TODO(BinaryExpression): isStringLiteral(node.name) && node.name.text === "constructor" */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Classes_may_not_have_a_field_named_constructor */ TODO)
            }
            if checkGrammarForInvalidDynamicName(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type */ TODO) {
                 /* TODO(TrueKeyword): true */ TODO
            }
            if /* TODO(BinaryExpression): languageVersion < ScriptTarget.ES2015 && isPrivateIdentifier(node.name) */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher */ TODO)
            }
            if /* TODO(BinaryExpression): languageVersion < ScriptTarget.ES2015 && isAutoAccessorPropertyDeclaration(node) */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher */ TODO)
            }
            if /* TODO(BinaryExpression): isAutoAccessorPropertyDeclaration(node) && checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_accessor_property_cannot_be_declared_optional) */ TODO {
                 /* TODO(TrueKeyword): true */ TODO
            }
        } else if /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.InterfaceDeclaration */ TODO {
            if checkGrammarForInvalidDynamicName(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type */ TODO) {
                 /* TODO(TrueKeyword): true */ TODO
            }
            /* TODO(ExpressionStatement): Debug.assertNode(node, isPropertySignature); */
            if /* TODO(PropertyAccessExpression): node.initializer */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.initializer */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.An_interface_property_cannot_have_an_initializer */ TODO)
            }
        } else if isTypeLiteralNode(/* TODO(PropertyAccessExpression): node.parent */ TODO) {
            if checkGrammarForInvalidDynamicName(/* TODO(PropertyAccessExpression): node.name */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type */ TODO) {
                 /* TODO(TrueKeyword): true */ TODO
            }
            /* TODO(ExpressionStatement): Debug.assertNode(node, isPropertySignature); */
            if /* TODO(PropertyAccessExpression): node.initializer */ TODO {
                 grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.initializer */ TODO, /* TODO(PropertyAccessExpression): Diagnostics.A_type_literal_property_cannot_have_an_initializer */ TODO)
            }
        }
        if /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO {
            /* TODO(ExpressionStatement): checkAmbientInitializer(node); */
        }
        if /* TODO(BinaryExpression): isPropertyDeclaration(node) && node.exclamationToken && (!isClassLike(node.parent) || !node.type || node.initializer ||                 node.flags & NodeFlags.Ambient || isStatic(node) || hasAbstractModifier(node)) */ TODO {
            message := /* TODO(ConditionalExpression): node.initializer                 ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions                 : !node.type                 ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations                 : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context */ TODO
             grammarErrorOnNode(/* TODO(PropertyAccessExpression): node.exclamationToken */ TODO, message)
        }
    }
    checkGrammarTopLevelElementForRequiredDeclareModifier := func(node Node) bool {
        if /* TODO(BinaryExpression): node.kind === SyntaxKind.InterfaceDeclaration ||             node.kind === SyntaxKind.TypeAliasDeclaration ||             node.kind === SyntaxKind.ImportDeclaration ||             node.kind === SyntaxKind.ImportEqualsDeclaration ||             node.kind === SyntaxKind.ExportDeclaration ||             node.kind === SyntaxKind.ExportAssignment ||             node.kind === SyntaxKind.NamespaceExportDeclaration ||             hasSyntacticModifier(node, ModifierFlags.Ambient | ModifierFlags.Export | ModifierFlags.Default) */ TODO {
             /* TODO(FalseKeyword): false */ TODO
        }
         grammarErrorOnFirstToken(node, /* TODO(PropertyAccessExpression): Diagnostics.Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier */ TODO)
    }
    checkGrammarTopLevelElementsForRequiredDeclareModifier := func(file SourceFile) bool {
        /* TODO(ForOfStatement): for (const decl of file.statements) {             if (isDeclaration(decl) || decl.kind === SyntaxKind.VariableStatement) {                 if (checkGrammarTopLevelElementForRequiredDeclareModifier(decl)) {                     return true;                 }             }         } */
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarSourceFile := func(node SourceFile) bool {
         /* TODO(BinaryExpression): !!(node.flags & NodeFlags.Ambient) && checkGrammarTopLevelElementsForRequiredDeclareModifier(node) */ TODO
    }
    checkGrammarStatementInAmbientContext := func(node Node) bool {
        if /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO {
            links := getNodeLinks(node)
            if /* TODO(BinaryExpression): !links.hasReportedStatementInAmbientContext && (isFunctionLike(node.parent) || isAccessor(node.parent)) */ TODO {
                 /* TODO(BinaryExpression): getNodeLinks(node).hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts) */ TODO
            }
            if /* TODO(BinaryExpression): node.parent.kind === SyntaxKind.Block || node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile */ TODO {
                links := getNodeLinks(/* TODO(PropertyAccessExpression): node.parent */ TODO)
                if /* TODO(PrefixUnaryExpression): !links.hasReportedStatementInAmbientContext */ TODO {
                     /* TODO(BinaryExpression): links.hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.Statements_are_not_allowed_in_ambient_contexts) */ TODO
                }
            } else {
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarNumericLiteral := func(node NumericLiteral) {
        isFractional := /* TODO(PropertyAccessExpression): getTextOfNode(node).includes */ TODO(".")
        isScientific := /* TODO(BinaryExpression): node.numericLiteralFlags & TokenFlags.Scientific */ TODO
        if /* TODO(BinaryExpression): isFractional || isScientific */ TODO {

        }
        value := /* TODO(PrefixUnaryExpression): +node.text */ TODO
        if /* TODO(BinaryExpression): value <= 2 ** 53 - 1 */ TODO {

        }
        /* TODO(ExpressionStatement): addErrorOrSuggestion(/*isError* / false, createDiagnosticForNode(node, Diagnostics.Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers)); */
    }
    checkGrammarBigIntLiteral := func(node BigIntLiteral) bool {
        literalType := /* TODO(BinaryExpression): isLiteralTypeNode(node.parent) ||             isPrefixUnaryExpression(node.parent) && isLiteralTypeNode(node.parent.parent) */ TODO
        if /* TODO(PrefixUnaryExpression): !literalType */ TODO {
            if /* TODO(BinaryExpression): languageVersion < ScriptTarget.ES2020 */ TODO {
                if grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.BigInt_literals_are_not_available_when_targeting_lower_than_ES2020 */ TODO) {
                     /* TODO(TrueKeyword): true */ TODO
                }
            }
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    grammarErrorAfterFirstToken := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
        sourceFile := getSourceFileOfNode(node)
        if /* TODO(PrefixUnaryExpression): !hasParseDiagnostics(sourceFile) */ TODO {
            span := getSpanOfTokenAtPosition(sourceFile, /* TODO(PropertyAccessExpression): node.pos */ TODO)
            /* TODO(ExpressionStatement): diagnostics.add(createFileDiagnostic(sourceFile, textSpanEnd(span), /*length* / 0, message, ...args)); */
             /* TODO(TrueKeyword): true */ TODO
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    getAmbientModules := func() []Symbol {
        if /* TODO(PrefixUnaryExpression): !ambientModulesCache */ TODO {
            /* TODO(ExpressionStatement): ambientModulesCache = []; */
            /* TODO(ExpressionStatement): globals.forEach((global, sym) => {                 // No need to `unescapeLeadingUnderscores`, an escaped symbol is never an ambient module.                 if (ambientModuleSymbolRegex.test(sym as string)) {                     ambientModulesCache!.push(global);                 }             }); */
        }
         ambientModulesCache
    }
    checkGrammarImportClause := func(node ImportClause) bool {
        if /* TODO(BinaryExpression): node.isTypeOnly && node.name && node.namedBindings */ TODO {
             grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both */ TODO)
        }
        if /* TODO(BinaryExpression): node.isTypeOnly && node.namedBindings?.kind === SyntaxKind.NamedImports */ TODO {
             checkGrammarNamedImportsOrExports(/* TODO(PropertyAccessExpression): node.namedBindings */ TODO)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    checkGrammarNamedImportsOrExports := func(namedBindings NamedImportsOrExports) bool {
         /* TODO(PrefixUnaryExpression): !!forEach<ImportSpecifier | ExportSpecifier, boolean>(namedBindings.elements, specifier => {             if (specifier.isTypeOnly) {                 return grammarErrorOnFirstToken(                     specifier,                     specifier.kind === SyntaxKind.ImportSpecifier                         ? Diagnostics.The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement                         : Diagnostics.The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement,                 );             }         }) */ TODO
    }
    checkGrammarImportCallExpression := func(node ImportCall) bool {
        if /* TODO(BinaryExpression): compilerOptions.verbatimModuleSyntax && moduleKind === ModuleKind.CommonJS */ TODO {
             grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled */ TODO)
        }
        if /* TODO(BinaryExpression): moduleKind === ModuleKind.ES2015 */ TODO {
             grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext */ TODO)
        }
        if /* TODO(PropertyAccessExpression): node.typeArguments */ TODO {
             grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments */ TODO)
        }
        nodeArguments := /* TODO(PropertyAccessExpression): node.arguments */ TODO
        if /* TODO(BinaryExpression): moduleKind !== ModuleKind.ESNext && moduleKind !== ModuleKind.NodeNext && moduleKind !== ModuleKind.Node16 && moduleKind !== ModuleKind.Preserve */ TODO {
            /* TODO(ExpressionStatement): checkGrammarForDisallowedTrailingComma(nodeArguments); */
            if /* TODO(BinaryExpression): nodeArguments.length > 1 */ TODO {
                importAttributesArgument := /* TODO(ElementAccessExpression): nodeArguments[1] */ TODO
                 grammarErrorOnNode(importAttributesArgument, /* TODO(PropertyAccessExpression): Diagnostics.Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_nodenext_or_preserve */ TODO)
            }
        }
        if /* TODO(BinaryExpression): nodeArguments.length === 0 || nodeArguments.length > 2 */ TODO {
             grammarErrorOnNode(node, /* TODO(PropertyAccessExpression): Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments */ TODO)
        }
        spreadElement := find(nodeArguments, isSpreadElement)
        if spreadElement {
             grammarErrorOnNode(spreadElement, /* TODO(PropertyAccessExpression): Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element */ TODO)
        }
         /* TODO(FalseKeyword): false */ TODO
    }
    findMatchingTypeReferenceOrTypeAliasReference := func(source Type, unionTarget UnionOrIntersectionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        sourceObjectFlags := getObjectFlags(source)
        if /* TODO(BinaryExpression): sourceObjectFlags & (ObjectFlags.Reference | ObjectFlags.Anonymous) && unionTarget.flags & TypeFlags.Union */ TODO {
             find(/* TODO(PropertyAccessExpression): unionTarget.types */ TODO, /* TODO(ArrowFunction): target => {                 if (target.flags & TypeFlags.Object) {                     const overlapObjFlags = sourceObjectFlags & getObjectFlags(target);                     if (overlapObjFlags & ObjectFlags.Reference) {                         return (source as TypeReference).target === (target as TypeReference).target;                     }                     if (overlapObjFlags & ObjectFlags.Anonymous) {                         return !!(source as AnonymousType).aliasSymbol && (source as AnonymousType).aliasSymbol === (target as AnonymousType).aliasSymbol;                     }                 }                 return false;             } */ TODO)
        }
    }
    findBestTypeForObjectLiteral := func(source Type, unionTarget UnionOrIntersectionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.ObjectLiteral && someType(unionTarget, isArrayLikeType) */ TODO {
             find(/* TODO(PropertyAccessExpression): unionTarget.types */ TODO, /* TODO(ArrowFunction): t => !isArrayLikeType(t) */ TODO)
        }
    }
    findBestTypeForInvokable := func(source Type, unionTarget UnionOrIntersectionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        signatureKind := /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO
        hasSignatures := /* TODO(BinaryExpression): getSignaturesOfType(source, signatureKind).length > 0 ||             (signatureKind = SignatureKind.Construct, getSignaturesOfType(source, signatureKind).length > 0) */ TODO
        if hasSignatures {
             find(/* TODO(PropertyAccessExpression): unionTarget.types */ TODO, /* TODO(ArrowFunction): t => getSignaturesOfType(t, signatureKind).length > 0 */ TODO)
        }
    }
    findMostOverlappyType := func(source Type, unionTarget UnionOrIntersectionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        var bestMatch *Type
        if /* TODO(PrefixUnaryExpression): !(source.flags & (TypeFlags.Primitive | TypeFlags.InstantiablePrimitive)) */ TODO {
            matchingCount := 0
            /* TODO(ForOfStatement): for (const target of unionTarget.types) {                 if (!(target.flags & (TypeFlags.Primitive | TypeFlags.InstantiablePrimitive))) {                     const overlap = getIntersectionType([getIndexType(source), getIndexType(target)]);                     if (overlap.flags & TypeFlags.Index) {                         // perfect overlap of keys                         return target;                     }                     else if (isUnitType(overlap) || overlap.flags & TypeFlags.Union) {                         // We only want to account for literal types otherwise.                         // If we have a union of index types, it seems likely that we                         // needed to elaborate between two generic mapped types anyway.                         const len = overlap.flags & TypeFlags.Union ? countWhere((overlap as UnionType).types, isUnitType) : 1;                         if (len >= matchingCount) {                             bestMatch = target;                             matchingCount = len;                         }                     }                 }             } */
        }
         bestMatch
    }
    filterPrimitivesIfContainsNonPrimitive := func(type_ UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
        if maybeTypeOfKind(type_, /* TODO(PropertyAccessExpression): TypeFlags.NonPrimitive */ TODO) {
            result := filterType(type_, /* TODO(ArrowFunction): t => !(t.flags & TypeFlags.Primitive) */ TODO)
            if /* TODO(PrefixUnaryExpression): !(result.flags & TypeFlags.Never) */ TODO {
                 result
            }
        }
         type_
    }
    findMatchingDiscriminantType := func(source Type, target Type, isRelatedTo func(source Type, target Type) Ternary) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
        if /* TODO(BinaryExpression): target.flags & TypeFlags.Union && source.flags & (TypeFlags.Intersection | TypeFlags.Object) */ TODO {
            match := getMatchingUnionConstituentForType(target /* as */ /* TODO(TypeReference): UnionType */, source)
            if match {
                 match
            }
            sourceProperties := getPropertiesOfType(source)
            if sourceProperties {
                sourcePropertiesFiltered := findDiscriminantProperties(sourceProperties, target)
                if sourcePropertiesFiltered {
                    discriminated := discriminateTypeByDiscriminableItems(target /* as */ /* TODO(TypeReference): UnionType */, map_(sourcePropertiesFiltered, /* TODO(ArrowFunction): p => ([() => getTypeOfSymbol(p), p.escapedName] as [() => Type, __String]) */ TODO), isRelatedTo)
                    if /* TODO(BinaryExpression): discriminated !== target */ TODO {
                         discriminated
                    }
                }
            }
        }
         undefined
    }
    getEffectivePropertyNameForPropertyNameNode := func(node PropertyName) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
        name := getPropertyNameForPropertyNameNode(node)
         /* TODO(ConditionalExpression): name ? name :             isComputedPropertyName(node) ? tryGetNameFromType(getTypeOfExpression(node.expression)) : undefined */ TODO
    }
    getCombinedModifierFlagsCached := func(node Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ModifierFlags */ TODO {
        if /* TODO(BinaryExpression): lastGetCombinedModifierFlagsNode === node */ TODO {
             lastGetCombinedModifierFlagsResult
        }
        /* TODO(ExpressionStatement): lastGetCombinedModifierFlagsNode = node; */
        /* TODO(ExpressionStatement): lastGetCombinedModifierFlagsResult = getCombinedModifierFlags(node); */
         lastGetCombinedModifierFlagsResult
    }
    getCombinedNodeFlagsCached := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").NodeFlags */ TODO {
        if /* TODO(BinaryExpression): lastGetCombinedNodeFlagsNode === node */ TODO {
             lastGetCombinedNodeFlagsResult
        }
        /* TODO(ExpressionStatement): lastGetCombinedNodeFlagsNode = node; */
        /* TODO(ExpressionStatement): lastGetCombinedNodeFlagsResult = getCombinedNodeFlags(node); */
         lastGetCombinedNodeFlagsResult
    }
    isVarConstLike := func(node /* TODO(UnionType): VariableDeclaration | VariableDeclarationList */ any) /* TODO(undefined): boolean */ TODO {
        blockScopeKind := /* TODO(BinaryExpression): getCombinedNodeFlagsCached(node) & NodeFlags.BlockScoped */ TODO
         /* TODO(BinaryExpression): blockScopeKind === NodeFlags.Const ||             blockScopeKind === NodeFlags.Using ||             blockScopeKind === NodeFlags.AwaitUsing */ TODO
    }
    getJSXRuntimeImportSpecifier := func(file *SourceFile, specifierText string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralLike | undefined */ TODO {
        jsxImportIndex := /* TODO(ConditionalExpression): compilerOptions.importHelpers ? 1 : 0 */ TODO
        specifier := /* TODO(ElementAccessExpression): file?.imports[jsxImportIndex] */ TODO
        if specifier {
            /* TODO(ExpressionStatement): Debug.assert(nodeIsSynthesized(specifier) && specifier.text === specifierText, `Expected sourceFile.imports[${jsxImportIndex}] to be the synthesized JSX runtime import`); */
        }
         specifier
    }
    getImportHelpersImportSpecifier := func(file SourceFile) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralLike */ TODO {
        /* TODO(ExpressionStatement): Debug.assert(compilerOptions.importHelpers, "Expected importHelpers to be enabled"); */
        specifier := /* TODO(ElementAccessExpression): file.imports[0] */ TODO
        /* TODO(ExpressionStatement): Debug.assert(specifier && nodeIsSynthesized(specifier) && specifier.text === "tslib", `Expected sourceFile.imports[0] to be the synthesized tslib import`); */
         specifier
    }
}
func isNotAccessor(declaration Declaration) bool {
     /* TODO(PrefixUnaryExpression): !isAccessor(declaration) */ TODO
}
func isNotOverload(declaration Declaration) bool {
     /* TODO(BinaryExpression): (declaration.kind !== SyntaxKind.FunctionDeclaration && declaration.kind !== SyntaxKind.MethodDeclaration) ||         !!(declaration as FunctionDeclaration).body */ TODO
}
func isDeclarationNameOrImportPropertyName(name Node) bool {
    /* TODO(SwitchStatement): switch (name.parent.kind) {         case SyntaxKind.ImportSpecifier:         case SyntaxKind.ExportSpecifier:             return isIdentifier(name) || name.kind === SyntaxKind.StringLiteral;         default:             return isDeclarationName(name);     } */
}
/* TODO(ModuleDeclaration): namespace JsxNames {     export const JSX = "JSX" as __String;     export const IntrinsicElements = "IntrinsicElements" as __String;     export const ElementClass = "ElementClass" as __String;     export const ElementAttributesPropertyNameContainer = "ElementAttributesProperty" as __String; // TODO: Deprecate and remove support     export const ElementChildrenAttributeNameContainer = "ElementChildrenAttribute" as __String;     export const Element = "Element" as __String;     export const ElementType = "ElementType" as __String;     export const IntrinsicAttributes = "IntrinsicAttributes" as __String;     export const IntrinsicClassAttributes = "IntrinsicClassAttributes" as __String;     export const LibraryManagedAttributes = "LibraryManagedAttributes" as __String; } */
func getIterationTypesKeyFromIterationTypeKind(typeKind IterationTypeKind) /* TODO(undefined): "yieldType" | "returnType" | "nextType" */ TODO {
    /* TODO(SwitchStatement): switch (typeKind) {         case IterationTypeKind.Yield:             return "yieldType";         case IterationTypeKind.Return:             return "returnType";         case IterationTypeKind.Next:             return "nextType";     } */
}
func signatureHasRestParameter(s Signature) /* TODO(undefined): boolean */ TODO {
     /* TODO(PrefixUnaryExpression): !!(s.flags & SignatureFlags.HasRestParameter) */ TODO
}
func signatureHasLiteralTypes(s Signature) /* TODO(undefined): boolean */ TODO {
     /* TODO(PrefixUnaryExpression): !!(s.flags & SignatureFlags.HasLiteralTypes) */ TODO
}
func createBasicNodeBuilderModuleSpecifierResolutionHost(host TypeCheckerHost) ModuleSpecifierResolutionHost {
     /* TODO(ObjectLiteralExpression): {         getCommonSourceDirectory: !!(host as Program).getCommonSourceDirectory ? () => (host as Program).getCommonSourceDirectory() : () => "",         getCurrentDirectory: () => host.getCurrentDirectory(),         getSymlinkCache: maybeBind(host, host.getSymlinkCache),         getPackageJsonInfoCache: () => host.getPackageJsonInfoCache?.(),         useCaseSensitiveFileNames: maybeBind(host, host.useCaseSensitiveFileNames),         redirectTargetsMap: host.redirectTargetsMap,         getProjectReferenceRedirect: fileName => host.getProjectReferenceRedirect(fileName),         isSourceOfProjectReferenceRedirect: fileName => host.isSourceOfProjectReferenceRedirect(fileName),         fileExists: fileName => host.fileExists(fileName),         getFileIncludeReasons: () => host.getFileIncludeReasons(),         readFile: host.readFile ? (fileName => host.readFile!(fileName)) : undefined,         getDefaultResolutionModeForFile: file => host.getDefaultResolutionModeForFile(file),         getModeForResolutionAtIndex: (file, index) => host.getModeForResolutionAtIndex(file, index),     } */ TODO
}
type NodeBuilderContext struct {
    enclosingDeclaration Node
    enclosingFile *SourceFile
    flags NodeBuilderFlags
    internalFlags InternalNodeBuilderFlags
    tracker SymbolTrackerImpl
    encounteredError bool
    reportedDiagnostic bool
    trackedSymbols /* TODO(ArrayType): TrackedSymbol[] */ any
    visitedTypes *Set[number]
    symbolDepth *Map[string, number]
    inferTypeParameters /* TODO(ArrayType): TypeParameter[] */ any
    approximateLength number
    truncating bool
    mustCreateTypeParameterSymbolList bool
    typeParameterSymbolList *Set[number]
    mustCreateTypeParametersNamesLookups bool
    typeParameterNames *Map[TypeId, Identifier]
    typeParameterNamesByText *Set[string]
    typeParameterNamesByTextNextNameCount *Map[string, number]
    usedSymbolNames *Set[string]
    remappedSymbolNames *Map[SymbolId, string]
    remappedSymbolReferences *Map[SymbolId, Symbol]
    reverseMappedStack /* TODO(ArrayType): ReverseMappedSymbol[] */ any
    bundled bool
    mapper *TypeMapper
}
type SymbolTrackerImpl struct {
    /* TODO(ClassDeclaration): class SymbolTrackerImpl implements SymbolTracker {     moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined = undefined;     context: NodeBuilderContext;      readonly inner: SymbolTracker | undefined = undefined;     readonly canTrackSymbol: boolean;     disableTrackSymbol = false;      constructor(context: NodeBuilderContext, tracker: SymbolTracker | undefined, moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined) {         while (tracker instanceof SymbolTrackerImpl) {             tracker = tracker.inner;         }          this.inner = tracker;         this.moduleResolverHost = moduleResolverHost;         this.context = context;         this.canTrackSymbol = !!this.inner?.trackSymbol;     }      trackSymbol(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): boolean {         if (this.inner?.trackSymbol && !this.disableTrackSymbol) {             if (this.inner.trackSymbol(symbol, enclosingDeclaration, meaning)) {                 this.onDiagnosticReported();                 return true;             }             // Skip recording type parameters as they dont contribute to late painted statements             if (!(symbol.flags & SymbolFlags.TypeParameter)) (this.context.trackedSymbols ??= []).push([symbol, enclosingDeclaration, meaning]);         }         return false;     }      reportInaccessibleThisError(): void {         if (this.inner?.reportInaccessibleThisError) {             this.onDiagnosticReported();             this.inner.reportInaccessibleThisError();         }     }      reportPrivateInBaseOfClassExpression(propertyName: string): void {         if (this.inner?.reportPrivateInBaseOfClassExpression) {             this.onDiagnosticReported();             this.inner.reportPrivateInBaseOfClassExpression(propertyName);         }     }      reportInaccessibleUniqueSymbolError(): void {         if (this.inner?.reportInaccessibleUniqueSymbolError) {             this.onDiagnosticReported();             this.inner.reportInaccessibleUniqueSymbolError();         }     }      reportCyclicStructureError(): void {         if (this.inner?.reportCyclicStructureError) {             this.onDiagnosticReported();             this.inner.reportCyclicStructureError();         }     }      reportLikelyUnsafeImportRequiredError(specifier: string): void {         if (this.inner?.reportLikelyUnsafeImportRequiredError) {             this.onDiagnosticReported();             this.inner.reportLikelyUnsafeImportRequiredError(specifier);         }     }      reportTruncationError(): void {         if (this.inner?.reportTruncationError) {             this.onDiagnosticReported();             this.inner.reportTruncationError();         }     }      reportNonlocalAugmentation(containingFile: SourceFile, parentSymbol: Symbol, augmentingSymbol: Symbol): void {         if (this.inner?.reportNonlocalAugmentation) {             this.onDiagnosticReported();             this.inner.reportNonlocalAugmentation(containingFile, parentSymbol, augmentingSymbol);         }     }      reportNonSerializableProperty(propertyName: string): void {         if (this.inner?.reportNonSerializableProperty) {             this.onDiagnosticReported();             this.inner.reportNonSerializableProperty(propertyName);         }     }      private onDiagnosticReported() {         this.context.reportedDiagnostic = true;     }      reportInferenceFallback(node: Node): void {         if (this.inner?.reportInferenceFallback) {             this.inner.reportInferenceFallback(node);         }     } } */
}
