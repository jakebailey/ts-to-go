package output

var ambientModuleSymbolRegex = regexp.MustParse(`^".+"$`)
var anon = "(anonymous)"

type ReferenceHint int32

const (
	ReferenceHintUnspecified ReferenceHint = iota
	ReferenceHintIdentifier
	ReferenceHintProperty
	ReferenceHintExportAssignment
	ReferenceHintJsx
	ReferenceHintAsyncFunction
	ReferenceHintExportImportEquals
	ReferenceHintExportSpecifier
	ReferenceHintDecorator
)

var nextSymbolId = 1
var nextNodeId = 1
var nextMergeId = 1
var nextFlowId = 1

type IterationUse int32

const (
	IterationUseAllowsSyncIterablesFlag  IterationUse = 1 << 0
	IterationUseAllowsAsyncIterablesFlag IterationUse = 1 << 1
	IterationUseAllowsStringInputFlag    IterationUse = 1 << 2
	IterationUseForOfFlag                IterationUse = 1 << 3
	IterationUseYieldStarFlag            IterationUse = 1 << 4
	IterationUseSpreadFlag               IterationUse = 1 << 5
	IterationUseDestructuringFlag        IterationUse = 1 << 6
	IterationUsePossiblyOutOfBounds      IterationUse = 1 << 7
	IterationUseElement                  IterationUse = IterationUseAllowsSyncIterablesFlag
	IterationUseSpread                   IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseSpreadFlag
	IterationUseDestructuring            IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseDestructuringFlag
	IterationUseForOf                    IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
	IterationUseForAwaitOf               IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
	IterationUseYieldStar                IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseYieldStarFlag
	IterationUseAsyncYieldStar           IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseIterationUseYieldStarFlag
	IterationUseGeneratorReturnType      IterationUse = IterationUseAllowsSyncIterablesFlag
	IterationUseAsyncGeneratorReturnType IterationUse = IterationUseAllowsAsyncIterablesFlag
)

type IterationTypeKind int32

const (
	IterationTypeKindYield IterationTypeKind = iota
	IterationTypeKindReturn
	IterationTypeKindNext
)

type IterationTypesResolver struct {
	iterableCacheKey/* TODO(UnionType): "iterationTypesOfAsyncIterable" | "iterationTypesOfIterable" */ any
	iteratorCacheKey/* TODO(UnionType): "iterationTypesOfAsyncIterator" | "iterationTypesOfIterator" */ any
	iteratorSymbolName/* TODO(UnionType): "asyncIterator" | "iterator" */ any
	getGlobalIteratorType         func(reportErrors bool) GenericType
	getGlobalIterableType         func(reportErrors bool) GenericType
	getGlobalIterableIteratorType func(reportErrors bool) GenericType
	getGlobalIteratorObjectType   func(reportErrors bool) GenericType
	getGlobalGeneratorType        func(reportErrors bool) GenericType
	getGlobalBuiltinIteratorTypes func() []GenericType
	resolveIterationType          func(type_ Type, errorNode Node) *Type
	mustHaveANextMethodDiagnostic DiagnosticMessage
	mustBeAMethodDiagnostic       DiagnosticMessage
	mustHaveAValueDiagnostic      DiagnosticMessage
}
type WideningKind int32

const (
	WideningKindNormal WideningKind = iota
	WideningKindFunctionReturn
	WideningKindGeneratorNext
	WideningKindGeneratorYield
)

type TypeFacts int32

const (
	TypeFactsNone                      TypeFacts = 0
	TypeFactsTypeofEQString            TypeFacts = 1 << 0
	TypeFactsTypeofEQNumber            TypeFacts = 1 << 1
	TypeFactsTypeofEQBigInt            TypeFacts = 1 << 2
	TypeFactsTypeofEQBoolean           TypeFacts = 1 << 3
	TypeFactsTypeofEQSymbol            TypeFacts = 1 << 4
	TypeFactsTypeofEQObject            TypeFacts = 1 << 5
	TypeFactsTypeofEQFunction          TypeFacts = 1 << 6
	TypeFactsTypeofEQHostObject        TypeFacts = 1 << 7
	TypeFactsTypeofNEString            TypeFacts = 1 << 8
	TypeFactsTypeofNENumber            TypeFacts = 1 << 9
	TypeFactsTypeofNEBigInt            TypeFacts = 1 << 10
	TypeFactsTypeofNEBoolean           TypeFacts = 1 << 11
	TypeFactsTypeofNESymbol            TypeFacts = 1 << 12
	TypeFactsTypeofNEObject            TypeFacts = 1 << 13
	TypeFactsTypeofNEFunction          TypeFacts = 1 << 14
	TypeFactsTypeofNEHostObject        TypeFacts = 1 << 15
	TypeFactsEQUndefined               TypeFacts = 1 << 16
	TypeFactsEQNull                    TypeFacts = 1 << 17
	TypeFactsEQUndefinedOrNull         TypeFacts = 1 << 18
	TypeFactsNEUndefined               TypeFacts = 1 << 19
	TypeFactsNENull                    TypeFacts = 1 << 20
	TypeFactsNEUndefinedOrNull         TypeFacts = 1 << 21
	TypeFactsTruthy                    TypeFacts = 1 << 22
	TypeFactsFalsy                     TypeFacts = 1 << 23
	TypeFactsIsUndefined               TypeFacts = 1 << 24
	TypeFactsIsNull                    TypeFacts = 1 << 25
	TypeFactsIsUndefinedOrNull         TypeFacts = TypeFactsIsUndefined | TypeFactsIsNull
	TypeFactsAll                       TypeFacts = (1 << 27) - 1
	TypeFactsBaseStringStrictFacts     TypeFacts = TypeFactsTypeofEQString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseStringFacts           TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsStringStrictFacts         TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsStringFacts               TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
	TypeFactsEmptyStringStrictFacts    TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsFalsy
	TypeFactsEmptyStringFacts          TypeFacts = TypeFactsBaseTypeFactsStringFacts
	TypeFactsNonEmptyStringStrictFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy
	TypeFactsNonEmptyStringFacts       TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
	TypeFactsBaseNumberStrictFacts     TypeFacts = TypeFactsTypeofEQNumber | TypeFactsTypeofNEString | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseNumberFacts           TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsNumberStrictFacts         TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsNumberFacts               TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
	TypeFactsZeroNumberStrictFacts     TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsFalsy
	TypeFactsZeroNumberFacts           TypeFacts = TypeFactsBaseTypeFactsNumberFacts
	TypeFactsNonZeroNumberStrictFacts  TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy
	TypeFactsNonZeroNumberFacts        TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
	TypeFactsBaseBigIntStrictFacts     TypeFacts = TypeFactsTypeofEQBigInt | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseBigIntFacts           TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsBigIntStrictFacts         TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsBigIntFacts               TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
	TypeFactsZeroBigIntStrictFacts     TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsFalsy
	TypeFactsZeroBigIntFacts           TypeFacts = TypeFactsBaseTypeFactsBigIntFacts
	TypeFactsNonZeroBigIntStrictFacts  TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy
	TypeFactsNonZeroBigIntFacts        TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
	TypeFactsBaseBooleanStrictFacts    TypeFacts = TypeFactsTypeofEQBoolean | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseBooleanFacts          TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsBooleanStrictFacts        TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsBooleanFacts              TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
	TypeFactsFalseStrictFacts          TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsFalsy
	TypeFactsFalseFacts                TypeFacts = TypeFactsBaseTypeFactsBooleanFacts
	TypeFactsTrueStrictFacts           TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy
	TypeFactsTrueFacts                 TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
	TypeFactsSymbolStrictFacts         TypeFacts = TypeFactsTypeofEQSymbol | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsSymbolFacts               TypeFacts = TypeFactsSymbolStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsObjectStrictFacts         TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsObjectFacts               TypeFacts = TypeFactsObjectStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsFunctionStrictFacts       TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsFunctionFacts             TypeFacts = TypeFactsFunctionStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsVoidFacts                 TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy
	TypeFactsUndefinedFacts            TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy | TypeFactsIsUndefined
	TypeFactsNullFacts                 TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNEUndefined | TypeFactsFalsy | TypeFactsIsNull
	TypeFactsEmptyObjectStrictFacts    TypeFacts = TypeFactsAll & ~(TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsTypeFactsIsUndefinedOrNull)
	TypeFactsEmptyObjectFacts          TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
	TypeFactsUnknownFacts              TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
	TypeFactsAllTypeofNE               TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsNEUndefined
	TypeFactsOrFactsMask               TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofNEObject
	TypeFactsAndFactsMask              TypeFacts = TypeFactsAll & ~TypeFactsOrFactsMask
)

var typeofNEFacts ReadonlyMap[string, TypeFacts] = /* TODO(NewExpression): new Map(Object.entries({     string: TypeFacts.TypeofNEString,     number: TypeFacts.TypeofNENumber,     bigint: TypeFacts.TypeofNEBigInt,     boolean: TypeFacts.TypeofNEBoolean,     symbol: TypeFacts.TypeofNESymbol,     undefined: TypeFacts.NEUndefined,     object: TypeFacts.TypeofNEObject,     function: TypeFacts.TypeofNEFunction, })) */ TODO

type TypeSystemEntity /* TODO(UnionType): Node | Symbol | Type | Signature */ any
type TypeSystemPropertyName int32

const (
	TypeSystemPropertyNameType TypeSystemPropertyName = iota
	TypeSystemPropertyNameResolvedBaseConstructorType
	TypeSystemPropertyNameDeclaredType
	TypeSystemPropertyNameResolvedReturnType
	TypeSystemPropertyNameImmediateBaseConstraint
	TypeSystemPropertyNameResolvedTypeArguments
	TypeSystemPropertyNameResolvedBaseTypes
	TypeSystemPropertyNameWriteType
	TypeSystemPropertyNameParameterInitializerContainsUndefined
)

type CheckMode int32

const (
	CheckModeNormal               CheckMode = 0
	CheckModeContextual           CheckMode = 1 << 0
	CheckModeInferential          CheckMode = 1 << 1
	CheckModeSkipContextSensitive CheckMode = 1 << 2
	CheckModeSkipGenericFunctions CheckMode = 1 << 3
	CheckModeIsForSignatureHelp   CheckMode = 1 << 4
	CheckModeRestBindingElement   CheckMode = 1 << 5
	CheckModeTypeOnly             CheckMode = 1 << 6
)

type SignatureCheckMode int32

const (
	SignatureCheckModeNone               SignatureCheckMode = 0
	SignatureCheckModeBivariantCallback  SignatureCheckMode = 1 << 0
	SignatureCheckModeStrictCallback     SignatureCheckMode = 1 << 1
	SignatureCheckModeIgnoreReturnTypes  SignatureCheckMode = 1 << 2
	SignatureCheckModeStrictArity        SignatureCheckMode = 1 << 3
	SignatureCheckModeStrictTopSignature SignatureCheckMode = 1 << 4
	SignatureCheckModeCallback           SignatureCheckMode = SignatureCheckModeBivariantSignatureCheckModeCallback | SignatureCheckModeStrictSignatureCheckModeCallback
)

type IntersectionState int32

const (
	IntersectionStateNone   IntersectionState = 0
	IntersectionStateSource IntersectionState = 1 << 0
	IntersectionStateTarget IntersectionState = 1 << 1
)

type RecursionFlags int32

const (
	RecursionFlagsNone   RecursionFlags = 0
	RecursionFlagsSource RecursionFlags = 1 << 0
	RecursionFlagsTarget RecursionFlags = 1 << 1
	RecursionFlagsBoth   RecursionFlags = RecursionFlagsSource | RecursionFlagsTarget
)

type MappedTypeModifiers int32

const (
	MappedTypeModifiersIncludeReadonly MappedTypeModifiers = 1 << 0
	MappedTypeModifiersExcludeReadonly MappedTypeModifiers = 1 << 1
	MappedTypeModifiersIncludeOptional MappedTypeModifiers = 1 << 2
	MappedTypeModifiersExcludeOptional MappedTypeModifiers = 1 << 3
)

type MappedTypeNameTypeKind int32

const (
	MappedTypeNameTypeKindNone MappedTypeNameTypeKind = iota
	MappedTypeNameTypeKindFiltering
	MappedTypeNameTypeKindRemapping
)

type ExpandingFlags int32

const (
	ExpandingFlagsNone   ExpandingFlags = 0
	ExpandingFlagsSource ExpandingFlags = 1
	ExpandingFlagsTarget ExpandingFlags = 1 << 1
	ExpandingFlagsBoth   ExpandingFlags = ExpandingFlagsSource | ExpandingFlagsTarget
)

type MembersOrExportsResolutionKind string

const (
	MembersOrExportsResolutionKindresolvedExports MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedExports"
	MembersOrExportsResolutionKindresolvedMembers MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedMembers"
)

type UnusedKind int32

const (
	UnusedKindLocal UnusedKind = iota
	UnusedKindParameter
)

type AddUnusedDiagnostic func(containingNode Node, type_ UnusedKind, diagnostic DiagnosticWithLocation)

var isNotOverloadAndNotAccessor = and(isNotOverload, isNotAccessor)

type DeclarationMeaning int32

const (
	DeclarationMeaningGetAccessor                DeclarationMeaning = 1
	DeclarationMeaningSetAccessor                DeclarationMeaning = 2
	DeclarationMeaningPropertyAssignment         DeclarationMeaning = 4
	DeclarationMeaningMethod                     DeclarationMeaning = 8
	DeclarationMeaningPrivateStatic              DeclarationMeaning = 16
	DeclarationMeaningGetOrSetAccessor           DeclarationMeaning = DeclarationMeaningGetAccessor | DeclarationMeaningSetAccessor
	DeclarationMeaningPropertyAssignmentOrMethod DeclarationMeaning = DeclarationMeaningPropertyAssignment | DeclarationMeaningMethod
)

type DeclarationSpaces int32

const (
	DeclarationSpacesNone            DeclarationSpaces = 0
	DeclarationSpacesExportValue     DeclarationSpaces = 1 << 0
	DeclarationSpacesExportType      DeclarationSpaces = 1 << 1
	DeclarationSpacesExportNamespace DeclarationSpaces = 1 << 2
)

type MinArgumentCountFlags int32

const (
	MinArgumentCountFlagsNone                    MinArgumentCountFlags = 0
	MinArgumentCountFlagsStrongArityForUntypedJS MinArgumentCountFlags = 1 << 0
	MinArgumentCountFlagsVoidIsNonOptional       MinArgumentCountFlags = 1 << 1
)

type IntrinsicTypeKind int32

const (
	IntrinsicTypeKindUppercase IntrinsicTypeKind = iota
	IntrinsicTypeKindLowercase
	IntrinsicTypeKindCapitalize
	IntrinsicTypeKindUncapitalize
	IntrinsicTypeKindNoInfer
)

var intrinsicTypeKinds ReadonlyMap[string, IntrinsicTypeKind] = /* TODO(NewExpression): new Map(Object.entries({     Uppercase: IntrinsicTypeKind.Uppercase,     Lowercase: IntrinsicTypeKind.Lowercase,     Capitalize: IntrinsicTypeKind.Capitalize,     Uncapitalize: IntrinsicTypeKind.Uncapitalize,     NoInfer: IntrinsicTypeKind.NoInfer, })) */ TODO
var SymbolLinks = /* TODO(ClassExpression): class implements SymbolLinks {     declare _symbolLinksBrand: any; } */ TODO

func NodeLinks(this NodeLinks) {
	this.flags = NodeCheckFlagsNone
}
func getNodeId(node Node) number {
	if !node.id {
		node.id = nextNodeId
		nextNodeId++
	}
	return node.id
}
func getSymbolId(symbol Symbol) SymbolId {
	if !symbol.id {
		symbol.id = nextSymbolId
		nextSymbolId++
	}
	return symbol.id
}
func isInstantiatedModule(node ModuleDeclaration, preserveConstEnums bool) /* TODO inferred type boolean */ TODO {
	moduleState := getModuleInstanceState(node)
	return moduleState == ModuleInstanceStateInstantiated || (preserveConstEnums && moduleState == ModuleInstanceStateConstEnumOnly)
}
func createTypeChecker(host TypeCheckerHost) TypeChecker {
	var deferredDiagnosticsCallbacks []func() = /* TODO(ArrayLiteralExpression): [] */ TODO
	addLazyDiagnostic := func(arg func()) {
		deferredDiagnosticsCallbacks.push(arg)
	}
	var cancellationToken *CancellationToken
	var scanner *Scanner
	Symbol := objectAllocator.getSymbolConstructor()
	Type := objectAllocator.getTypeConstructor()
	Signature := objectAllocator.getSignatureConstructor()
	typeCount := 0
	symbolCount := 0
	totalInstantiationCount := 0
	instantiationCount := 0
	instantiationDepth := 0
	inlineLevel := 0
	var currentNode Node
	var varianceTypeParameter *TypeParameter
	isInferencePartiallyBlocked := false
	emptySymbols := createSymbolTable()
	arrayVariances := /* TODO(ArrayLiteralExpression): [VarianceFlags.Covariant] */ TODO
	compilerOptions := host.getCompilerOptions()
	languageVersion := getEmitScriptTarget(compilerOptions)
	moduleKind := getEmitModuleKind(compilerOptions)
	legacyDecorators := !!compilerOptions.experimentalDecorators
	useDefineForClassFields := getUseDefineForClassFields(compilerOptions)
	emitStandardClassFields := getEmitStandardClassFields(compilerOptions)
	allowSyntheticDefaultImports := getAllowSyntheticDefaultImports(compilerOptions)
	strictNullChecks := getStrictOptionValue(compilerOptions, "strictNullChecks")
	strictFunctionTypes := getStrictOptionValue(compilerOptions, "strictFunctionTypes")
	strictBindCallApply := getStrictOptionValue(compilerOptions, "strictBindCallApply")
	strictPropertyInitialization := getStrictOptionValue(compilerOptions, "strictPropertyInitialization")
	strictBuiltinIteratorReturn := getStrictOptionValue(compilerOptions, "strictBuiltinIteratorReturn")
	noImplicitAny := getStrictOptionValue(compilerOptions, "noImplicitAny")
	noImplicitThis := getStrictOptionValue(compilerOptions, "noImplicitThis")
	useUnknownInCatchVariables := getStrictOptionValue(compilerOptions, "useUnknownInCatchVariables")
	exactOptionalPropertyTypes := compilerOptions.exactOptionalPropertyTypes
	noUncheckedSideEffectImports := !!compilerOptions.noUncheckedSideEffectImports
	checkBinaryExpression := createCheckBinaryExpression()
	emitResolver := createResolver()
	nodeBuilder := createNodeBuilder()
	syntacticNodeBuilder := createSyntacticTypeNodeBuilder(compilerOptions /* TODO(ObjectLiteralExpression): {         isEntityNameVisible,         isExpandoFunctionDeclaration,         getAllAccessorDeclarations: getAllAccessorDeclarationsForDeclaration,         requiresAddingImplicitUndefined,         isUndefinedIdentifierExpression(node: Identifier) {             Debug.assert(isExpressionNode(node));             return getSymbolAtLocation(node) === undefinedSymbol;         },         isDefinitelyReferenceToGlobalSymbolObject,     } */, TODO)
	evaluate := createEvaluator( /* TODO(ObjectLiteralExpression): {         evaluateElementAccessExpression,         evaluateEntityNameExpression,     } */ TODO)
	globals := createSymbolTable()
	undefinedSymbol := createSymbol(SymbolFlagsProperty, "undefined")
	undefinedSymbol.declarations = /* TODO(ArrayLiteralExpression): [] */ TODO
	globalThisSymbol := createSymbol(SymbolFlagsModule, "globalThis", CheckFlagsReadonly)
	globalThisSymbol.exports = globals
	globalThisSymbol.declarations = /* TODO(ArrayLiteralExpression): [] */ TODO
	globals.set(globalThisSymbol.escapedName, globalThisSymbol)
	argumentsSymbol := createSymbol(SymbolFlagsProperty, "arguments")
	requireSymbol := createSymbol(SymbolFlagsProperty, "require")
	isolatedModulesLikeFlagName := /* TODO(ConditionalExpression): compilerOptions.verbatimModuleSyntax ? "verbatimModuleSyntax" : "isolatedModules" */ TODO
	canCollectSymbolAliasAccessabilityData := !compilerOptions.verbatimModuleSyntax
	var apparentArgumentCount /* TODO(NumberKeyword): number */ any
	var lastGetCombinedNodeFlagsNode Node
	lastGetCombinedNodeFlagsResult := NodeFlagsNone
	var lastGetCombinedModifierFlagsNode Declaration
	lastGetCombinedModifierFlagsResult := ModifierFlagsNone
	resolveName := createNameResolver( /* TODO(ObjectLiteralExpression): {         compilerOptions,         requireSymbol,         argumentsSymbol,         globals,         getSymbolOfDeclaration,         error,         getRequiresScopeChangeCache,         setRequiresScopeChangeCache,         lookup: getSymbol,         onPropertyWithInvalidInitializer: checkAndReportErrorForInvalidInitializer,         onFailedToResolveSymbol,         onSuccessfullyResolvedSymbol,     } */ TODO)
	resolveNameForSymbolSuggestion := createNameResolver( /* TODO(ObjectLiteralExpression): {         compilerOptions,         requireSymbol,         argumentsSymbol,         globals,         getSymbolOfDeclaration,         error,         getRequiresScopeChangeCache,         setRequiresScopeChangeCache,         lookup: getSuggestionForSymbolNameLookup,     } */ TODO)
	var checker TypeChecker = /* TODO(ObjectLiteralExpression): {         getNodeCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.nodeCount, 0),         getIdentifierCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.identifierCount, 0),         getSymbolCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.symbolCount, symbolCount),         getTypeCount: () => typeCount,         getInstantiationCount: () => totalInstantiationCount,         getRelationCacheSizes: () => ({             assignable: assignableRelation.size,             identity: identityRelation.size,             subtype: subtypeRelation.size,             strictSubtype: strictSubtypeRelation.size,         }),         isUndefinedSymbol: symbol => symbol === undefinedSymbol,         isArgumentsSymbol: symbol => symbol === argumentsSymbol,         isUnknownSymbol: symbol => symbol === unknownSymbol,         getMergedSymbol,         symbolIsValue,         getDiagnostics,         getGlobalDiagnostics,         getRecursionIdentity,         getUnmatchedProperties,         getTypeOfSymbolAtLocation: (symbol, locationIn) => {             const location = getParseTreeNode(locationIn);             return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType;         },         getTypeOfSymbol,         getSymbolsOfParameterPropertyDeclaration: (parameterIn, parameterName) => {             const parameter = getParseTreeNode(parameterIn, isParameter);             if (parameter === undefined) return Debug.fail("Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.");             Debug.assert(isParameterPropertyDeclaration(parameter, parameter.parent));             return getSymbolsOfParameterPropertyDeclaration(parameter, escapeLeadingUnderscores(parameterName));         },         getDeclaredTypeOfSymbol,         getPropertiesOfType,         getPropertyOfType: (type, name) => getPropertyOfType(type, escapeLeadingUnderscores(name)),         getPrivateIdentifierPropertyOfType: (leftType: Type, name: string, location: Node) => {             const node = getParseTreeNode(location);             if (!node) {                 return undefined;             }             const propName = escapeLeadingUnderscores(name);             const lexicallyScopedIdentifier = lookupSymbolForPrivateIdentifierDeclaration(propName, node);             return lexicallyScopedIdentifier ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) : undefined;         },         getTypeOfPropertyOfType: (type, name) => getTypeOfPropertyOfType(type, escapeLeadingUnderscores(name)),         getIndexInfoOfType: (type, kind) => getIndexInfoOfType(type, kind === IndexKind.String ? stringType : numberType),         getIndexInfosOfType,         getIndexInfosOfIndexSymbol,         getSignaturesOfType,         getIndexTypeOfType: (type, kind) => getIndexTypeOfType(type, kind === IndexKind.String ? stringType : numberType),         getIndexType: type => getIndexType(type),         getBaseTypes,         getBaseTypeOfLiteralType,         getWidenedType,         getWidenedLiteralType,         getTypeFromTypeNode: nodeIn => {             const node = getParseTreeNode(nodeIn, isTypeNode);             return node ? getTypeFromTypeNode(node) : errorType;         },         getParameterType: getTypeAtPosition,         getParameterIdentifierInfoAtPosition,         getPromisedTypeOfPromise,         getAwaitedType: type => getAwaitedType(type),         getReturnTypeOfSignature,         isNullableType,         getNullableType,         getNonNullableType,         getNonOptionalType: removeOptionalTypeMarker,         getTypeArguments,         typeToTypeNode: nodeBuilder.typeToTypeNode,         typePredicateToTypePredicateNode: nodeBuilder.typePredicateToTypePredicateNode,         indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration,         signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration,         symbolToEntityName: nodeBuilder.symbolToEntityName,         symbolToExpression: nodeBuilder.symbolToExpression,         symbolToNode: nodeBuilder.symbolToNode,         symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations,         symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration,         typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration,         getSymbolsInScope: (locationIn, meaning) => {             const location = getParseTreeNode(locationIn);             return location ? getSymbolsInScope(location, meaning) : [];         },         getSymbolAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             // set ignoreErrors: true because any lookups invoked by the API shouldn't cause any new errors             return node ? getSymbolAtLocation(node, /*ignoreErrors* / true) : undefined;         },         getIndexInfosAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getIndexInfosAtLocation(node) : undefined;         },         getShorthandAssignmentValueSymbol: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getShorthandAssignmentValueSymbol(node) : undefined;         },         getExportSpecifierLocalTargetSymbol: nodeIn => {             const node = getParseTreeNode(nodeIn, isExportSpecifier);             return node ? getExportSpecifierLocalTargetSymbol(node) : undefined;         },         getExportSymbolOfSymbol(symbol) {             return getMergedSymbol(symbol.exportSymbol || symbol);         },         getTypeAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getTypeOfNode(node) : errorType;         },         getTypeOfAssignmentPattern: nodeIn => {             const node = getParseTreeNode(nodeIn, isAssignmentPattern);             return node && getTypeOfAssignmentPattern(node) || errorType;         },         getPropertySymbolOfDestructuringAssignment: locationIn => {             const location = getParseTreeNode(locationIn, isIdentifier);             return location ? getPropertySymbolOfDestructuringAssignment(location) : undefined;         },         signatureToString: (signature, enclosingDeclaration, flags, kind) => {             return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind);         },         typeToString: (type, enclosingDeclaration, flags) => {             return typeToString(type, getParseTreeNode(enclosingDeclaration), flags);         },         symbolToString: (symbol, enclosingDeclaration, meaning, flags) => {             return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags);         },         typePredicateToString: (predicate, enclosingDeclaration, flags) => {             return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags);         },         writeSignature: (signature, enclosingDeclaration, flags, kind, writer) => {             return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind, writer);         },         writeType: (type, enclosingDeclaration, flags, writer) => {             return typeToString(type, getParseTreeNode(enclosingDeclaration), flags, writer);         },         writeSymbol: (symbol, enclosingDeclaration, meaning, flags, writer) => {             return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags, writer);         },         writeTypePredicate: (predicate, enclosingDeclaration, flags, writer) => {             return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags, writer);         },         getAugmentedPropertiesOfType,         getRootSymbols,         getSymbolOfExpando,         getContextualType: (nodeIn: Expression, contextFlags?: ContextFlags) => {             const node = getParseTreeNode(nodeIn, isExpression);             if (!node) {                 return undefined;             }             if (contextFlags! & ContextFlags.Completions) {                 return runWithInferenceBlockedFromSourceNode(node, () => getContextualType(node, contextFlags));             }             return getContextualType(node, contextFlags);         },         getContextualTypeForObjectLiteralElement: nodeIn => {             const node = getParseTreeNode(nodeIn, isObjectLiteralElementLike);             return node ? getContextualTypeForObjectLiteralElement(node, /*contextFlags* / undefined) : undefined;         },         getContextualTypeForArgumentAtIndex: (nodeIn, argIndex) => {             const node = getParseTreeNode(nodeIn, isCallLikeExpression);             return node && getContextualTypeForArgumentAtIndex(node, argIndex);         },         getContextualTypeForJsxAttribute: nodeIn => {             const node = getParseTreeNode(nodeIn, isJsxAttributeLike);             return node && getContextualTypeForJsxAttribute(node, /*contextFlags* / undefined);         },         isContextSensitive,         getTypeOfPropertyOfContextualType,         getFullyQualifiedName,         getResolvedSignature: (node, candidatesOutArray, argumentCount) => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.Normal),         getCandidateSignaturesForStringLiteralCompletions,         getResolvedSignatureForSignatureHelp: (node, candidatesOutArray, argumentCount) => runWithoutResolvedSignatureCaching(node, () => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.IsForSignatureHelp)),         getExpandedParameters,         hasEffectiveRestParameter,         containsArgumentsReference,         getConstantValue: nodeIn => {             const node = getParseTreeNode(nodeIn, canHaveConstantValue);             return node ? getConstantValue(node) : undefined;         },         isValidPropertyAccess: (nodeIn, propertyName) => {             const node = getParseTreeNode(nodeIn, isPropertyAccessOrQualifiedNameOrImportTypeNode);             return !!node && isValidPropertyAccess(node, escapeLeadingUnderscores(propertyName));         },         isValidPropertyAccessForCompletions: (nodeIn, type, property) => {             const node = getParseTreeNode(nodeIn, isPropertyAccessExpression);             return !!node && isValidPropertyAccessForCompletions(node, type, property);         },         getSignatureFromDeclaration: declarationIn => {             const declaration = getParseTreeNode(declarationIn, isFunctionLike);             return declaration ? getSignatureFromDeclaration(declaration) : undefined;         },         isImplementationOfOverload: nodeIn => {             const node = getParseTreeNode(nodeIn, isFunctionLike);             return node ? isImplementationOfOverload(node) : undefined;         },         getImmediateAliasedSymbol,         getAliasedSymbol: resolveAlias,         getEmitResolver,         requiresAddingImplicitUndefined,         getExportsOfModule: getExportsOfModuleAsArray,         getExportsAndPropertiesOfModule,         forEachExportAndPropertyOfModule,         getSymbolWalker: createGetSymbolWalker(             getRestTypeOfSignature,             getTypePredicateOfSignature,             getReturnTypeOfSignature,             getBaseTypes,             resolveStructuredTypeMembers,             getTypeOfSymbol,             getResolvedSymbol,             getConstraintOfTypeParameter,             getFirstIdentifier,             getTypeArguments,         ),         getAmbientModules,         getJsxIntrinsicTagNamesAt,         isOptionalParameter: nodeIn => {             const node = getParseTreeNode(nodeIn, isParameter);             return node ? isOptionalParameter(node) : false;         },         tryGetMemberInModuleExports: (name, symbol) => tryGetMemberInModuleExports(escapeLeadingUnderscores(name), symbol),         tryGetMemberInModuleExportsAndProperties: (name, symbol) => tryGetMemberInModuleExportsAndProperties(escapeLeadingUnderscores(name), symbol),         tryFindAmbientModule: moduleName => tryFindAmbientModule(moduleName, /*withAugmentations* / true),         getApparentType,         getUnionType,         isTypeAssignableTo,         createAnonymousType,         createSignature,         createSymbol,         createIndexInfo,         getAnyType: () => anyType,         getStringType: () => stringType,         getStringLiteralType,         getNumberType: () => numberType,         getNumberLiteralType,         getBigIntType: () => bigintType,         getBigIntLiteralType,         createPromiseType,         createArrayType,         getElementTypeOfArrayType,         getBooleanType: () => booleanType,         getFalseType: (fresh?) => fresh ? falseType : regularFalseType,         getTrueType: (fresh?) => fresh ? trueType : regularTrueType,         getVoidType: () => voidType,         getUndefinedType: () => undefinedType,         getNullType: () => nullType,         getESSymbolType: () => esSymbolType,         getNeverType: () => neverType,         getOptionalType: () => optionalType,         getPromiseType: () => getGlobalPromiseType(/*reportErrors* / false),         getPromiseLikeType: () => getGlobalPromiseLikeType(/*reportErrors* / false),         getAnyAsyncIterableType: () => {             const type = getGlobalAsyncIterableType(/*reportErrors* / false);             if (type === emptyGenericType) return undefined;             return createTypeReference(type, [anyType, anyType, anyType]);         },         isSymbolAccessible,         isArrayType,         isTupleType,         isArrayLikeType,         isEmptyAnonymousObjectType,         isTypeInvalidDueToUnionDiscriminant,         getExactOptionalProperties,         getAllPossiblePropertiesOfTypes,         getSuggestedSymbolForNonexistentProperty,         getSuggestedSymbolForNonexistentJSXAttribute,         getSuggestedSymbolForNonexistentSymbol: (location, name, meaning) => getSuggestedSymbolForNonexistentSymbol(location, escapeLeadingUnderscores(name), meaning),         getSuggestedSymbolForNonexistentModule,         getSuggestedSymbolForNonexistentClassMember,         getBaseConstraintOfType,         getDefaultFromTypeParameter: type => type && type.flags & TypeFlags.TypeParameter ? getDefaultFromTypeParameter(type as TypeParameter) : undefined,         resolveName(name, location, meaning, excludeGlobals) {             return resolveName(location, escapeLeadingUnderscores(name), meaning, /*nameNotFoundMessage* / undefined, /*isUse* / false, excludeGlobals);         },         getJsxNamespace: n => unescapeLeadingUnderscores(getJsxNamespace(n)),         getJsxFragmentFactory: n => {             const jsxFragmentFactory = getJsxFragmentFactoryEntity(n);             return jsxFragmentFactory && unescapeLeadingUnderscores(getFirstIdentifier(jsxFragmentFactory).escapedText);         },         getAccessibleSymbolChain,         getTypePredicateOfSignature,         resolveExternalModuleName: moduleSpecifierIn => {             const moduleSpecifier = getParseTreeNode(moduleSpecifierIn, isExpression);             return moduleSpecifier && resolveExternalModuleName(moduleSpecifier, moduleSpecifier, /*ignoreErrors* / true);         },         resolveExternalModuleSymbol,         tryGetThisTypeAt: (nodeIn, includeGlobalThis, container) => {             const node = getParseTreeNode(nodeIn);             return node && tryGetThisTypeAt(node, includeGlobalThis, container);         },         getTypeArgumentConstraint: nodeIn => {             const node = getParseTreeNode(nodeIn, isTypeNode);             return node && getTypeArgumentConstraint(node);         },         getSuggestionDiagnostics: (fileIn, ct) => {             const file = getParseTreeNode(fileIn, isSourceFile) || Debug.fail("Could not determine parsed source file.");             if (skipTypeChecking(file, compilerOptions, host)) {                 return emptyArray;             }              let diagnostics: DiagnosticWithLocation[] | undefined;             try {                 // Record the cancellation token so it can be checked later on during checkSourceElement.                 // Do this in a finally block so we can ensure that it gets reset back to nothing after                 // this call is done.                 cancellationToken = ct;                  // Ensure file is type checked, with _eager_ diagnostic production, so identifiers are registered as potentially unused                 checkSourceFileWithEagerDiagnostics(file);                 Debug.assert(!!(getNodeLinks(file).flags & NodeCheckFlags.TypeChecked));                  diagnostics = addRange(diagnostics, suggestionDiagnostics.getDiagnostics(file.fileName));                 checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), (containingNode, kind, diag) => {                     if (!containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) {                         (diagnostics || (diagnostics = [])).push({ ...diag, category: DiagnosticCategory.Suggestion });                     }                 });                  return diagnostics || emptyArray;             }             finally {                 cancellationToken = undefined;             }         },          runWithCancellationToken: (token, callback) => {             try {                 cancellationToken = token;                 return callback(checker);             }             finally {                 cancellationToken = undefined;             }         },          getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,         isDeclarationVisible,         isPropertyAccessible,         getTypeOnlyAliasDeclaration,         getMemberOverrideModifierStatus,         isTypeParameterPossiblyReferenced,         typeHasCallOrConstructSignatures,         getSymbolFlags,     } */ TODO
	getCandidateSignaturesForStringLiteralCompletions := func(call CallLikeExpression, editingArgument Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
		candidatesSet := make(map[Signature]struct{})
		var candidates []Signature = /* TODO(ArrayLiteralExpression): [] */ TODO
		runWithInferenceBlockedFromSourceNode(editingArgument, func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
			return getResolvedSignatureWorker(call, candidates, nil, CheckModeNormal)
		})
		for _, candidate := range candidates {
			candidatesSet.add(candidate)
		}
		candidates.length = 0
		runWithoutResolvedSignatureCaching(editingArgument, func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
			return getResolvedSignatureWorker(call, candidates, nil, CheckModeNormal)
		})
		for _, candidate := range candidates {
			candidatesSet.add(candidate)
		}
		return arrayFrom(candidatesSet)
	}
	runWithoutResolvedSignatureCaching := func(node Node, fn func() T) T {
		node = findAncestor(node, isCallLikeOrFunctionLikeExpression)
		if node {
			cachedResolvedSignatures := /* TODO(ArrayLiteralExpression): [] */ TODO
			cachedTypes := /* TODO(ArrayLiteralExpression): [] */ TODO
			for node {
				nodeLinks := getNodeLinks(node)
				cachedResolvedSignatures.push( /* TODO(ArrayLiteralExpression): [nodeLinks, nodeLinks.resolvedSignature] */ TODO)
				nodeLinks.resolvedSignature = nil
				if isFunctionExpressionOrArrowFunction(node) {
					symbolLinks := getSymbolLinks(getSymbolOfDeclaration(node))
					type_ := symbolLinks.type_
					cachedTypes.push( /* TODO(ArrayLiteralExpression): [symbolLinks, type] */ TODO)
					symbolLinks.type_ = nil
				}
				node = findAncestor(node.parent, isCallLikeOrFunctionLikeExpression)
			}
			result := fn()
			for _, TODO_IDENTIFIER := range cachedResolvedSignatures {
				nodeLinks.resolvedSignature = resolvedSignature
			}
			for _, TODO_IDENTIFIER := range cachedTypes {
				symbolLinks.type_ = type_
			}
			return result
		}
		return fn()
	}
	runWithInferenceBlockedFromSourceNode := func(node Node, fn func() T) T {
		containingCall := findAncestor(node, isCallLikeExpression)
		if containingCall {
			toMarkSkip := node
			// TODO: refactor do-while loop approximation
			for ok := true; ok; ok = toMarkSkip && toMarkSkip != containingCall {
				getNodeLinks(toMarkSkip).skipDirectInference = true
				toMarkSkip = toMarkSkip.parent
			}
		}
		isInferencePartiallyBlocked = true
		result := runWithoutResolvedSignatureCaching(node, fn)
		isInferencePartiallyBlocked = false
		if containingCall {
			toMarkSkip := node
			// TODO: refactor do-while loop approximation
			for ok := true; ok; ok = toMarkSkip && toMarkSkip != containingCall {
				getNodeLinks(toMarkSkip).skipDirectInference = nil
				toMarkSkip = toMarkSkip.parent
			}
		}
		return result
	}
	getResolvedSignatureWorker := func(nodeIn CallLikeExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, argumentCount /* TODO(NumberKeyword): number */ any, checkMode CheckMode) *Signature {
		node := getParseTreeNode(nodeIn, isCallLikeExpression)
		apparentArgumentCount = argumentCount
		res := /* TODO(ConditionalExpression): !node ? undefined : getResolvedSignature(node, candidatesOutArray, checkMode) */ TODO
		apparentArgumentCount = nil
		return res
	}
	tupleTypes := make(map[string]GenericType)
	unionTypes := make(map[string]UnionType)
	unionOfUnionTypes := make(map[string]Type)
	intersectionTypes := make(map[string]Type)
	stringLiteralTypes := make(map[string]StringLiteralType)
	numberLiteralTypes := make(map[number]NumberLiteralType)
	bigIntLiteralTypes := make(map[string]BigIntLiteralType)
	enumLiteralTypes := make(map[string]LiteralType)
	indexedAccessTypes := make(map[string]IndexedAccessType)
	templateLiteralTypes := make(map[string]TemplateLiteralType)
	stringMappingTypes := make(map[string]StringMappingType)
	substitutionTypes := make(map[string]SubstitutionType)
	subtypeReductionCache := make(map[string][]Type)
	decoratorContextOverrideTypeCache := make(map[string]Type)
	cachedTypes := make(map[string]Type)
	var evolvingArrayTypes []EvolvingArrayType = /* TODO(ArrayLiteralExpression): [] */ TODO
	var undefinedProperties SymbolTable = /* TODO(NewExpression): new Map() */ make(map[any]any)
	markerTypes := make(map[number]struct{})
	unknownSymbol := createSymbol(SymbolFlagsProperty, "unknown")
	resolvingSymbol := createSymbol(0, InternalSymbolNameResolving)
	unresolvedSymbols := make(map[string]TransientSymbol)
	errorTypes := make(map[string]Type)
	seenIntrinsicNames := make(map[string]struct{})
	anyType := createIntrinsicType(TypeFlagsAny, "any")
	autoType := createIntrinsicType(TypeFlagsAny, "any", ObjectFlagsNonInferrableType, "auto")
	wildcardType := createIntrinsicType(TypeFlagsAny, "any", nil, "wildcard")
	blockedStringType := createIntrinsicType(TypeFlagsAny, "any", nil, "blocked string")
	errorType := createIntrinsicType(TypeFlagsAny, "error")
	unresolvedType := createIntrinsicType(TypeFlagsAny, "unresolved")
	nonInferrableAnyType := createIntrinsicType(TypeFlagsAny, "any", ObjectFlagsContainsWideningType, "non-inferrable")
	intrinsicMarkerType := createIntrinsicType(TypeFlagsAny, "intrinsic")
	unknownType := createIntrinsicType(TypeFlagsUnknown, "unknown")
	undefinedType := createIntrinsicType(TypeFlagsUndefined, "undefined")
	undefinedWideningType := /* TODO(ConditionalExpression): strictNullChecks ? undefinedType : createIntrinsicType(TypeFlags.Undefined, "undefined", ObjectFlags.ContainsWideningType, "widening") */ TODO
	missingType := createIntrinsicType(TypeFlagsUndefined, "undefined", nil, "missing")
	undefinedOrMissingType := /* TODO(ConditionalExpression): exactOptionalPropertyTypes ? missingType : undefinedType */ TODO
	optionalType := createIntrinsicType(TypeFlagsUndefined, "undefined", nil, "optional")
	nullType := createIntrinsicType(TypeFlagsNull, "null")
	nullWideningType := /* TODO(ConditionalExpression): strictNullChecks ? nullType : createIntrinsicType(TypeFlags.Null, "null", ObjectFlags.ContainsWideningType, "widening") */ TODO
	stringType := createIntrinsicType(TypeFlagsString, "string")
	numberType := createIntrinsicType(TypeFlagsNumber, "number")
	bigintType := createIntrinsicType(TypeFlagsBigInt, "bigint")
	falseType := createIntrinsicType(TypeFlagsBooleanLiteral, "false", nil, "fresh")
	regularFalseType := createIntrinsicType(TypeFlagsBooleanLiteral, "false")
	trueType := createIntrinsicType(TypeFlagsBooleanLiteral, "true", nil, "fresh")
	regularTrueType := createIntrinsicType(TypeFlagsBooleanLiteral, "true")
	trueType.regularType = regularTrueType
	trueType.freshType = trueType
	regularTrueType.regularType = regularTrueType
	regularTrueType.freshType = trueType
	falseType.regularType = regularFalseType
	falseType.freshType = falseType
	regularFalseType.regularType = regularFalseType
	regularFalseType.freshType = falseType
	booleanType := getUnionType( /* TODO(ArrayLiteralExpression): [regularFalseType, regularTrueType] */ TODO)
	esSymbolType := createIntrinsicType(TypeFlagsESSymbol, "symbol")
	voidType := createIntrinsicType(TypeFlagsVoid, "void")
	neverType := createIntrinsicType(TypeFlagsNever, "never")
	silentNeverType := createIntrinsicType(TypeFlagsNever, "never", ObjectFlagsNonInferrableType, "silent")
	implicitNeverType := createIntrinsicType(TypeFlagsNever, "never", nil, "implicit")
	unreachableNeverType := createIntrinsicType(TypeFlagsNever, "never", nil, "unreachable")
	nonPrimitiveType := createIntrinsicType(TypeFlagsNonPrimitive, "object")
	stringOrNumberType := getUnionType( /* TODO(ArrayLiteralExpression): [stringType, numberType] */ TODO)
	stringNumberSymbolType := getUnionType( /* TODO(ArrayLiteralExpression): [stringType, numberType, esSymbolType] */ TODO)
	numberOrBigIntType := getUnionType( /* TODO(ArrayLiteralExpression): [numberType, bigintType] */ TODO)
	templateConstraintType := getUnionType( /* TODO(ArrayLiteralExpression): [stringType, numberType, booleanType, bigintType, nullType, undefinedType] */ TODO)
	numericStringType := getTemplateLiteralType( /* TODO(ArrayLiteralExpression): ["", ""] */ TODO /* TODO(ArrayLiteralExpression): [numberType] */, TODO)
	var restrictiveMapper TypeMapper = makeFunctionTypeMapper(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): t.flags & TypeFlags.TypeParameter ? getRestrictiveTypeParameter(t as TypeParameter) : t */ TODO
	}, func() /* TODO inferred type string */ TODO {
		return "(restrictive mapper)"
	})
	var permissiveMapper TypeMapper = makeFunctionTypeMapper(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): t.flags & TypeFlags.TypeParameter ? wildcardType : t */ TODO
	}, func() /* TODO inferred type string */ TODO {
		return "(permissive mapper)"
	})
	uniqueLiteralType := createIntrinsicType(TypeFlagsNever, "never", nil, "unique literal")
	var uniqueLiteralMapper TypeMapper = makeFunctionTypeMapper(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): t.flags & TypeFlags.TypeParameter ? uniqueLiteralType : t */ TODO
	}, func() /* TODO inferred type string */ TODO {
		return "(unique literal mapper)"
	})
	var outofbandVarianceMarkerHandler /* TODO(ParenthesizedType): ((onlyUnreliable: boolean) => void) */ any
	reportUnreliableMapper := makeFunctionTypeMapper(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if outofbandVarianceMarkerHandler && (t == markerSuperType || t == markerSubType || t == markerOtherType) {
			outofbandVarianceMarkerHandler(true)
		}
		return t
	}, func() /* TODO inferred type string */ TODO {
		return "(unmeasurable reporter)"
	})
	reportUnmeasurableMapper := makeFunctionTypeMapper(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if outofbandVarianceMarkerHandler && (t == markerSuperType || t == markerSubType || t == markerOtherType) {
			outofbandVarianceMarkerHandler(false)
		}
		return t
	}, func() /* TODO inferred type string */ TODO {
		return "(unreliable reporter)"
	})
	emptyObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	emptyJsxObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	emptyJsxObjectType.objectFlags |= ObjectFlagsJsxAttributes
	emptyTypeLiteralSymbol := createSymbol(SymbolFlagsTypeLiteral, InternalSymbolNameType)
	emptyTypeLiteralSymbol.members = createSymbolTable()
	emptyTypeLiteralType := createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, emptyArray, emptyArray, emptyArray)
	unknownEmptyObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	unknownUnionType := /* TODO(ConditionalExpression): strictNullChecks ? getUnionType([undefinedType, nullType, unknownEmptyObjectType]) : unknownType */ TODO
	emptyGenericType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	emptyGenericType.instantiations = make(map[string]TypeReference)
	anyFunctionType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	anyFunctionType.objectFlags |= ObjectFlagsNonInferrableType
	noConstraintType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	circularConstraintType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	resolvingDefaultType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	markerSuperType := createTypeParameter()
	markerSubType := createTypeParameter()
	markerSubType.constraint = markerSuperType
	markerOtherType := createTypeParameter()
	markerSuperTypeForCheck := createTypeParameter()
	markerSubTypeForCheck := createTypeParameter()
	markerSubTypeForCheck.constraint = markerSuperTypeForCheck
	noTypePredicate := createTypePredicate(TypePredicateKindIdentifier, "<<unresolved>>", 0, anyType)
	anySignature := createSignature(nil, nil, nil, emptyArray, anyType, nil, 0, SignatureFlagsNone)
	unknownSignature := createSignature(nil, nil, nil, emptyArray, errorType, nil, 0, SignatureFlagsNone)
	resolvingSignature := createSignature(nil, nil, nil, emptyArray, anyType, nil, 0, SignatureFlagsNone)
	silentNeverSignature := createSignature(nil, nil, nil, emptyArray, silentNeverType, nil, 0, SignatureFlagsNone)
	enumNumberIndexInfo := createIndexInfo(numberType, stringType, true)
	iterationTypesCache := make(map[string]IterationTypes)
	var noIterationTypes IterationTypes = /* TODO(ObjectLiteralExpression): {         get yieldType(): Type {             return Debug.fail("Not supported");         },         get returnType(): Type {             return Debug.fail("Not supported");         },         get nextType(): Type {             return Debug.fail("Not supported");         },     } */ TODO
	anyIterationTypes := createIterationTypes(anyType, anyType, anyType)
	var asyncIterationTypesResolver IterationTypesResolver = /* TODO(ObjectLiteralExpression): {         iterableCacheKey: "iterationTypesOfAsyncIterable",         iteratorCacheKey: "iterationTypesOfAsyncIterator",         iteratorSymbolName: "asyncIterator",         getGlobalIteratorType: getGlobalAsyncIteratorType,         getGlobalIterableType: getGlobalAsyncIterableType,         getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,         getGlobalIteratorObjectType: getGlobalAsyncIteratorObjectType,         getGlobalGeneratorType: getGlobalAsyncGeneratorType,         getGlobalBuiltinIteratorTypes: getGlobalBuiltinAsyncIteratorTypes,         resolveIterationType: (type, errorNode) => getAwaitedType(type, errorNode, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member),         mustHaveANextMethodDiagnostic: Diagnostics.An_async_iterator_must_have_a_next_method,         mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,         mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,     } */ TODO
	var syncIterationTypesResolver IterationTypesResolver = /* TODO(ObjectLiteralExpression): {         iterableCacheKey: "iterationTypesOfIterable",         iteratorCacheKey: "iterationTypesOfIterator",         iteratorSymbolName: "iterator",         getGlobalIteratorType,         getGlobalIterableType,         getGlobalIterableIteratorType,         getGlobalIteratorObjectType,         getGlobalGeneratorType,         getGlobalBuiltinIteratorTypes,         resolveIterationType: (type, _errorNode) => type,         mustHaveANextMethodDiagnostic: Diagnostics.An_iterator_must_have_a_next_method,         mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_iterator_must_be_a_method,         mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,     } */ TODO
	type DuplicateInfoForSymbol struct {
		firstFileLocations  []Declaration
		secondFileLocations []Declaration
		isBlockScoped       bool
	}
	type DuplicateInfoForFiles struct {
		firstFile          SourceFile
		secondFile         SourceFile
		conflictingSymbols Map[string, DuplicateInfoForSymbol]
	}
	var amalgamatedDuplicates *Map[string, DuplicateInfoForFiles]
	reverseMappedCache := make(map[string]*Type)
	reverseHomomorphicMappedCache := make(map[string]*Type)
	var ambientModulesCache /* TODO(ArrayType): Symbol[] */ any
	var patternAmbientModules []PatternAmbientModule
	var patternAmbientModuleAugmentations *Map[string, Symbol]
	var globalObjectType ObjectType
	var globalFunctionType ObjectType
	var globalCallableFunctionType ObjectType
	var globalNewableFunctionType ObjectType
	var globalArrayType GenericType
	var globalReadonlyArrayType GenericType
	var globalStringType ObjectType
	var globalNumberType ObjectType
	var globalBooleanType ObjectType
	var globalRegExpType ObjectType
	var globalThisType GenericType
	var anyArrayType Type
	var autoArrayType Type
	var anyReadonlyArrayType Type
	var deferredGlobalNonNullableTypeAlias Symbol
	var deferredGlobalESSymbolConstructorSymbol *Symbol
	var deferredGlobalESSymbolConstructorTypeSymbol *Symbol
	var deferredGlobalESSymbolType *ObjectType
	var deferredGlobalTypedPropertyDescriptorType GenericType
	var deferredGlobalPromiseType *GenericType
	var deferredGlobalPromiseLikeType *GenericType
	var deferredGlobalPromiseConstructorSymbol *Symbol
	var deferredGlobalPromiseConstructorLikeType *ObjectType
	var deferredGlobalIterableType *GenericType
	var deferredGlobalIteratorType *GenericType
	var deferredGlobalIterableIteratorType *GenericType
	var deferredGlobalIteratorObjectType *GenericType
	var deferredGlobalGeneratorType *GenericType
	var deferredGlobalIteratorYieldResultType *GenericType
	var deferredGlobalIteratorReturnResultType *GenericType
	var deferredGlobalAsyncIterableType *GenericType
	var deferredGlobalAsyncIteratorType *GenericType
	var deferredGlobalAsyncIterableIteratorType *GenericType
	var deferredGlobalBuiltinIteratorTypes /* TODO(TypeOperator): readonly GenericType[] */ any
	var deferredGlobalBuiltinAsyncIteratorTypes /* TODO(TypeOperator): readonly GenericType[] */ any
	var deferredGlobalAsyncIteratorObjectType *GenericType
	var deferredGlobalAsyncGeneratorType *GenericType
	var deferredGlobalTemplateStringsArrayType *ObjectType
	var deferredGlobalImportMetaType ObjectType
	var deferredGlobalImportMetaExpressionType ObjectType
	var deferredGlobalImportCallOptionsType *ObjectType
	var deferredGlobalImportAttributesType *ObjectType
	var deferredGlobalDisposableType *ObjectType
	var deferredGlobalAsyncDisposableType *ObjectType
	var deferredGlobalExtractSymbol *Symbol
	var deferredGlobalOmitSymbol *Symbol
	var deferredGlobalAwaitedSymbol *Symbol
	var deferredGlobalBigIntType *ObjectType
	var deferredGlobalNaNSymbol *Symbol
	var deferredGlobalRecordSymbol *Symbol
	var deferredGlobalClassDecoratorContextType *GenericType
	var deferredGlobalClassMethodDecoratorContextType *GenericType
	var deferredGlobalClassGetterDecoratorContextType *GenericType
	var deferredGlobalClassSetterDecoratorContextType *GenericType
	var deferredGlobalClassAccessorDecoratorContextType *GenericType
	var deferredGlobalClassAccessorDecoratorTargetType *GenericType
	var deferredGlobalClassAccessorDecoratorResultType *GenericType
	var deferredGlobalClassFieldDecoratorContextType *GenericType
	allPotentiallyUnusedIdentifiers := make(map[Path][]PotentiallyUnusedIdentifier)
	flowLoopStart := 0
	flowLoopCount := 0
	sharedFlowCount := 0
	flowAnalysisDisabled := false
	flowInvocationCount := 0
	var lastFlowNode *FlowNode
	var lastFlowNodeReachable bool
	var flowTypeCache /* TODO(ArrayType): Type[] */ any
	var contextualTypeNodes []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var contextualTypes []*Type = /* TODO(ArrayLiteralExpression): [] */ TODO
	var contextualIsCache []bool = /* TODO(ArrayLiteralExpression): [] */ TODO
	contextualTypeCount := 0
	var contextualBindingPatterns []BindingPattern = /* TODO(ArrayLiteralExpression): [] */ TODO
	var inferenceContextNodes []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var inferenceContexts []*InferenceContext = /* TODO(ArrayLiteralExpression): [] */ TODO
	inferenceContextCount := 0
	emptyStringType := getStringLiteralType("")
	zeroType := getNumberLiteralType(0)
	zeroBigIntType := getBigIntLiteralType( /* TODO(ObjectLiteralExpression): { negative: false, base10Value: "0" } */ TODO)
	var resolutionTargets []TypeSystemEntity = /* TODO(ArrayLiteralExpression): [] */ TODO
	var resolutionResults []bool = /* TODO(ArrayLiteralExpression): [] */ TODO
	var resolutionPropertyNames []TypeSystemPropertyName = /* TODO(ArrayLiteralExpression): [] */ TODO
	resolutionStart := 0
	inVarianceComputation := false
	suggestionCount := 0
	maximumSuggestionCount := 10
	var mergedSymbols []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
	var symbolLinks []SymbolLinks = /* TODO(ArrayLiteralExpression): [] */ TODO
	var nodeLinks []NodeLinks = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowLoopCaches []Map[string, Type] = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowLoopNodes []FlowNode = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowLoopKeys []string = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowLoopTypes [][]Type = /* TODO(ArrayLiteralExpression): [] */ TODO
	var sharedFlowNodes []FlowNode = /* TODO(ArrayLiteralExpression): [] */ TODO
	var sharedFlowTypes []FlowType = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowNodeReachable [] /* TODO(BooleanKeyword): boolean */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowNodePostSuper [] /* TODO(BooleanKeyword): boolean */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialThisCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialNewTargetCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialWeakMapSetCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialReflectCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialUnusedRenamedBindingElementsInTypes []BindingElement = /* TODO(ArrayLiteralExpression): [] */ TODO
	var awaitedTypeStack []number = /* TODO(ArrayLiteralExpression): [] */ TODO
	var reverseMappedSourceStack []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
	var reverseMappedTargetStack []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
	reverseExpandingFlags := ExpandingFlagsNone
	diagnostics := createDiagnosticCollection()
	suggestionDiagnostics := createDiagnosticCollection()
	typeofType := createTypeofType()
	var _jsxNamespace __String
	var _jsxFactoryEntity *EntityName
	subtypeRelation := make(map[string]RelationComparisonResult)
	strictSubtypeRelation := make(map[string]RelationComparisonResult)
	assignableRelation := make(map[string]RelationComparisonResult)
	comparableRelation := make(map[string]RelationComparisonResult)
	identityRelation := make(map[string]RelationComparisonResult)
	enumRelation := make(map[string]RelationComparisonResult)
	var suggestedExtensions [] /* TODO(TupleType): [string, string] */ any = /* TODO(ArrayLiteralExpression): [         [".mts", ".mjs"],         [".ts", ".js"],         [".cts", ".cjs"],         [".mjs", ".mjs"],         [".js", ".js"],         [".cjs", ".cjs"],         [".tsx", compilerOptions.jsx === JsxEmit.Preserve ? ".jsx" : ".js"],         [".jsx", ".jsx"],         [".json", ".json"],     ] */ TODO
	initializeTypeChecker()
	return checker
	isDefinitelyReferenceToGlobalSymbolObject := func(node Node) bool {
		if !isPropertyAccessExpression(node) {
			return false
		}
		if !isIdentifier(node.name) {
			return false
		}
		if !isPropertyAccessExpression(node.expression) && !isIdentifier(node.expression) {
			return false
		}
		if isIdentifier(node.expression) {
			return idText(node.expression) == "Symbol" && getResolvedSymbol(node.expression) == (getGlobalSymbol("Symbol", SymbolFlagsValue|SymbolFlagsExportValue, nil) || unknownSymbol)
		}
		if !isIdentifier(node.expression.expression) {
			return false
		}
		return idText(node.expression.name) == "Symbol" && idText(node.expression.expression) == "globalThis" && getResolvedSymbol(node.expression.expression) == globalThisSymbol
	}
	getCachedType := func(key /* TODO(StringKeyword): string */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): key ? cachedTypes.get(key) : undefined */ TODO
	}
	setCachedType := func(key /* TODO(StringKeyword): string */ any, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if key {
			cachedTypes.set(key, type_)
		}
		return type_
	}
	getJsxNamespace := func(location Node) __String {
		if location {
			file := getSourceFileOfNode(location)
			if file {
				if isJsxOpeningFragment(location) {
					if file.localJsxFragmentNamespace {
						return file.localJsxFragmentNamespace
					}
					jsxFragmentPragma := file.pragmas.get("jsxfrag")
					if jsxFragmentPragma {
						chosenPragma := /* TODO(ConditionalExpression): isArray(jsxFragmentPragma) ? jsxFragmentPragma[0] : jsxFragmentPragma */ TODO
						file.localJsxFragmentFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion)
						visitNode(file.localJsxFragmentFactory, markAsSynthetic, isEntityName)
						if file.localJsxFragmentFactory {
							return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): file.localJsxFragmentNamespace = getFirstIdentifier(file.localJsxFragmentFactory).escapedText */ TODO
						}
					}
					entity := getJsxFragmentFactoryEntity(location)
					if entity {
						file.localJsxFragmentFactory = entity
						return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): file.localJsxFragmentNamespace = getFirstIdentifier(entity).escapedText */ TODO
					}
				} else {
					localJsxNamespace := getLocalJsxNamespace(file)
					if localJsxNamespace {
						return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): file.localJsxNamespace = localJsxNamespace */ TODO
					}
				}
			}
		}
		if !_jsxNamespace {
			_jsxNamespace = "React"
			if compilerOptions.jsxFactory {
				_jsxFactoryEntity = parseIsolatedEntityName(compilerOptions.jsxFactory, languageVersion)
				visitNode(_jsxFactoryEntity, markAsSynthetic)
				if _jsxFactoryEntity {
					_jsxNamespace = getFirstIdentifier(_jsxFactoryEntity).escapedText
				}
			} else if compilerOptions.reactNamespace {
				_jsxNamespace = escapeLeadingUnderscores(compilerOptions.reactNamespace)
			}
		}
		if !_jsxFactoryEntity {
			_jsxFactoryEntity = factory.createQualifiedName(factory.createIdentifier(unescapeLeadingUnderscores(_jsxNamespace)), "createElement")
		}
		return _jsxNamespace
	}
	getLocalJsxNamespace := func(file SourceFile) *__String {
		if file.localJsxNamespace {
			return file.localJsxNamespace
		}
		jsxPragma := file.pragmas.get("jsx")
		if jsxPragma {
			chosenPragma := /* TODO(ConditionalExpression): isArray(jsxPragma) ? jsxPragma[0] : jsxPragma */ TODO
			file.localJsxFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion)
			visitNode(file.localJsxFactory, markAsSynthetic, isEntityName)
			if file.localJsxFactory {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): file.localJsxNamespace = getFirstIdentifier(file.localJsxFactory).escapedText */ TODO
			}
		}
	}
	markAsSynthetic := func(node T) VisitResult[T] {
		setTextRangePosEnd(node, -1, -1)
		return visitEachChildWorker(node, markAsSynthetic, nil)
	}
	getEmitResolver := func(sourceFile SourceFile, cancellationToken CancellationToken, skipDiagnostics bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EmitResolver */ TODO {
		if !skipDiagnostics {
			getDiagnostics(sourceFile, cancellationToken)
		}
		return emitResolver
	}
	lookupOrIssueError := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := /* TODO(ConditionalExpression): location             ? createDiagnosticForNode(location, message, ...args)             : createCompilerDiagnostic(message, ...args) */ TODO
		existing := diagnostics.lookup(diagnostic)
		if existing {
			return existing
		} else {
			diagnostics.add(diagnostic)
			return diagnostic
		}
	}
	errorSkippedOn := func(key CompilerOptions, location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := error(location, message /* TODO(SpreadElement): ...args */, TODO)
		diagnostic.skippedOn = key
		return diagnostic
	}
	createError := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		return /* TODO(ConditionalExpression): location             ? createDiagnosticForNode(location, message, ...args)             : createCompilerDiagnostic(message, ...args) */ TODO
	}
	error := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := createError(location, message /* TODO(SpreadElement): ...args */, TODO)
		diagnostics.add(diagnostic)
		return diagnostic
	}
	addErrorOrSuggestion := func(isError bool, diagnostic Diagnostic) {
		if isError {
			diagnostics.add(diagnostic)
		} else {
			suggestionDiagnostics.add( /* TODO(ObjectLiteralExpression): { ...diagnostic, category: DiagnosticCategory.Suggestion } */ TODO)
		}
	}
	errorOrSuggestion := func(isError bool, location Node, message /* TODO(UnionType): DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) {
		if location.pos < 0 || location.end < 0 {
			if !isError {
				return
			}
			file := getSourceFileOfNode(location)
			addErrorOrSuggestion(isError /* TODO(ConditionalExpression): "message" in message ? createFileDiagnostic(file, 0, 0, message, ...args) : createDiagnosticForFileFromMessageChain(file, message) */, TODO)
			return
		}
		addErrorOrSuggestion(isError /* TODO(ConditionalExpression): "message" in message ? createDiagnosticForNode(location, message, ...args) : createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(location), location, message) */, TODO)
	}
	errorAndMaybeSuggestAwait := func(location Node, maybeMissingAwait bool, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := error(location, message /* TODO(SpreadElement): ...args */, TODO)
		if maybeMissingAwait {
			related := createDiagnosticForNode(location, Diagnostics.Did_you_forget_to_use_await)
			addRelatedInfo(diagnostic, related)
		}
		return diagnostic
	}
	addDeprecatedSuggestionWorker := func(declarations /* TODO(UnionType): Node | Node[] */ any, diagnostic DiagnosticWithLocation) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
		deprecatedTag := /* TODO(ConditionalExpression): Array.isArray(declarations) ? forEach(declarations, getJSDocDeprecatedTag) : getJSDocDeprecatedTag(declarations) */ TODO
		if deprecatedTag {
			addRelatedInfo(diagnostic, createDiagnosticForNode(deprecatedTag, Diagnostics.The_declaration_was_marked_as_deprecated_here))
		}
		suggestionDiagnostics.add(diagnostic)
		return diagnostic
	}
	isDeprecatedSymbol := func(symbol Symbol) /* TODO inferred type boolean | 0 */ TODO {
		parentSymbol := getParentOfSymbol(symbol)
		if parentSymbol && length(symbol.declarations) > 1 {
			return /* TODO(ConditionalExpression): parentSymbol.flags & SymbolFlags.Interface ? some(symbol.declarations, isDeprecatedDeclaration) : every(symbol.declarations, isDeprecatedDeclaration) */ TODO
		}
		return !!symbol.valueDeclaration && isDeprecatedDeclaration(symbol.valueDeclaration) || length(symbol.declarations) && every(symbol.declarations, isDeprecatedDeclaration)
	}
	isDeprecatedDeclaration := func(declaration Declaration) /* TODO inferred type boolean */ TODO {
		return !!(getCombinedNodeFlagsCached(declaration) & NodeFlagsDeprecated)
	}
	addDeprecatedSuggestion := func(location Node, declarations []Node, deprecatedEntity string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
		diagnostic := createDiagnosticForNode(location, Diagnostics._0_is_deprecated, deprecatedEntity)
		return addDeprecatedSuggestionWorker(declarations, diagnostic)
	}
	addDeprecatedSuggestionWithSignature := func(location Node, declaration Node, deprecatedEntity /* TODO(StringKeyword): string */ any, signatureString string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
		diagnostic := /* TODO(ConditionalExpression): deprecatedEntity             ? createDiagnosticForNode(location, Diagnostics.The_signature_0_of_1_is_deprecated, signatureString, deprecatedEntity)             : createDiagnosticForNode(location, Diagnostics._0_is_deprecated, signatureString) */ TODO
		return addDeprecatedSuggestionWorker(declaration, diagnostic)
	}
	createSymbol := func(flags SymbolFlags, name __String, checkFlags CheckFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		symbolCount++
		symbol := /* TODO(NewExpression): new Symbol(flags | SymbolFlags.Transient, name) */ TODO
		symbol.links = /* TODO(NewExpression): new SymbolLinks() */ TODO
		symbol.links.checkFlags = checkFlags || CheckFlagsNone
		return symbol
	}
	createParameter := func(name __String, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		symbol := createSymbol(SymbolFlagsFunctionScopedVariable, name)
		symbol.links.type_ = type_
		return symbol
	}
	createProperty := func(name __String, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		symbol := createSymbol(SymbolFlagsProperty, name)
		symbol.links.type_ = type_
		return symbol
	}
	getExcludedSymbolFlags := func(flags SymbolFlags) SymbolFlags {
		var result SymbolFlags = 0
		if flags & SymbolFlagsBlockScopedVariable {
			result |= SymbolFlagsBlockScopedVariableExcludes
		}
		if flags & SymbolFlagsFunctionScopedVariable {
			result |= SymbolFlagsFunctionScopedVariableExcludes
		}
		if flags & SymbolFlagsProperty {
			result |= SymbolFlagsPropertyExcludes
		}
		if flags & SymbolFlagsEnumMember {
			result |= SymbolFlagsEnumMemberExcludes
		}
		if flags & SymbolFlagsFunction {
			result |= SymbolFlagsFunctionExcludes
		}
		if flags & SymbolFlagsClass {
			result |= SymbolFlagsClassExcludes
		}
		if flags & SymbolFlagsInterface {
			result |= SymbolFlagsInterfaceExcludes
		}
		if flags & SymbolFlagsRegularEnum {
			result |= SymbolFlagsRegularEnumExcludes
		}
		if flags & SymbolFlagsConstEnum {
			result |= SymbolFlagsConstEnumExcludes
		}
		if flags & SymbolFlagsValueModule {
			result |= SymbolFlagsValueModuleExcludes
		}
		if flags & SymbolFlagsMethod {
			result |= SymbolFlagsMethodExcludes
		}
		if flags & SymbolFlagsGetAccessor {
			result |= SymbolFlagsGetAccessorExcludes
		}
		if flags & SymbolFlagsSetAccessor {
			result |= SymbolFlagsSetAccessorExcludes
		}
		if flags & SymbolFlagsTypeParameter {
			result |= SymbolFlagsTypeParameterExcludes
		}
		if flags & SymbolFlagsTypeAlias {
			result |= SymbolFlagsTypeAliasExcludes
		}
		if flags & SymbolFlagsAlias {
			result |= SymbolFlagsAliasExcludes
		}
		return result
	}
	recordMergedSymbol := func(target Symbol, source Symbol) {
		if !source.mergeId {
			source.mergeId = nextMergeId
			nextMergeId++
		}
		/* TODO(ElementAccessExpression): mergedSymbols[source.mergeId] */ TODO = target
	}
	cloneSymbol := func(symbol Symbol) TransientSymbol {
		result := createSymbol(symbol.flags, symbol.escapedName)
		result.declarations = /* TODO(ConditionalExpression): symbol.declarations ? symbol.declarations.slice() : [] */ TODO
		result.parent = symbol.parent
		if symbol.valueDeclaration {
			result.valueDeclaration = symbol.valueDeclaration
		}
		if symbol.constEnumOnlyModule {
			result.constEnumOnlyModule = true
		}
		if symbol.members {
			result.members = /* TODO(NewExpression): new Map(symbol.members) */ TODO
		}
		if symbol.exports {
			result.exports = /* TODO(NewExpression): new Map(symbol.exports) */ TODO
		}
		recordMergedSymbol(result, symbol)
		return result
	}
	mergeSymbol := func(target Symbol, source Symbol, unidirectional /* TODO inferred type boolean */ TODO /*  = false */) Symbol {
		if !(target.flags & getExcludedSymbolFlags(source.flags)) || (source.flags|target.flags)&SymbolFlagsAssignment {
			if source == target {
				return target
			}
			if !(target.flags & SymbolFlagsTransient) {
				resolvedTarget := resolveSymbol(target)
				if resolvedTarget == unknownSymbol {
					return source
				}
				if !(resolvedTarget.flags & getExcludedSymbolFlags(source.flags)) || (source.flags|resolvedTarget.flags)&SymbolFlagsAssignment {
					target = cloneSymbol(resolvedTarget)
				} else {
					reportMergeSymbolError(target, source)
					return source
				}
			}
			if source.flags&SymbolFlagsValueModule && target.flags&SymbolFlagsValueModule && target.constEnumOnlyModule && !source.constEnumOnlyModule {
				target.constEnumOnlyModule = false
			}
			target.flags |= source.flags
			if source.valueDeclaration {
				setValueDeclaration(target, source.valueDeclaration)
			}
			addRange(target.declarations, source.declarations)
			if source.members {
				if !target.members {
					target.members = createSymbolTable()
				}
				mergeSymbolTable(target.members, source.members, unidirectional)
			}
			if source.exports {
				if !target.exports {
					target.exports = createSymbolTable()
				}
				mergeSymbolTable(target.exports, source.exports, unidirectional, target)
			}
			if !unidirectional {
				recordMergedSymbol(target, source)
			}
		} else if target.flags & SymbolFlagsNamespaceModule {
			if target != globalThisSymbol {
				error(source.declarations && getNameOfDeclaration( /* TODO(ElementAccessExpression): source.declarations[0] */ TODO), Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity, symbolToString(target))
			}
		} else {
			reportMergeSymbolError(target, source)
		}
		return target
		reportMergeSymbolError := func(target Symbol, source Symbol) {
			isEitherEnum := !!(target.flags&SymbolFlagsEnum || source.flags&SymbolFlagsEnum)
			isEitherBlockScoped := !!(target.flags&SymbolFlagsBlockScopedVariable || source.flags&SymbolFlagsBlockScopedVariable)
			message := /* TODO(ConditionalExpression): isEitherEnum ? Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations                 : isEitherBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0                 : Diagnostics.Duplicate_identifier_0 */ TODO
			sourceSymbolFile := source.declarations && getSourceFileOfNode( /* TODO(ElementAccessExpression): source.declarations[0] */ TODO)
			targetSymbolFile := target.declarations && getSourceFileOfNode( /* TODO(ElementAccessExpression): target.declarations[0] */ TODO)
			isSourcePlainJs := isPlainJsFile(sourceSymbolFile, compilerOptions.checkJs)
			isTargetPlainJs := isPlainJsFile(targetSymbolFile, compilerOptions.checkJs)
			symbolName := symbolToString(source)
			if sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && sourceSymbolFile != targetSymbolFile {
				firstFile := /* TODO(ConditionalExpression): comparePaths(sourceSymbolFile.path, targetSymbolFile.path) === Comparison.LessThan ? sourceSymbolFile : targetSymbolFile */ TODO
				secondFile := /* TODO(ConditionalExpression): firstFile === sourceSymbolFile ? targetSymbolFile : sourceSymbolFile */ TODO
				filesDuplicates := getOrUpdate(amalgamatedDuplicates /* TODO(TemplateExpression): `${firstFile.path}|${secondFile.path}` */, TODO, func() DuplicateInfoForFiles {
					return ( /* TODO(ObjectLiteralExpression): { firstFile, secondFile, conflictingSymbols: new Map() } */ TODO)
				})
				conflictingSymbolInfo := getOrUpdate(filesDuplicates.conflictingSymbols, symbolName, func() DuplicateInfoForSymbol {
					return ( /* TODO(ObjectLiteralExpression): { isBlockScoped: isEitherBlockScoped, firstFileLocations: [], secondFileLocations: [] } */ TODO)
				})
				if !isSourcePlainJs {
					addDuplicateLocations(conflictingSymbolInfo.firstFileLocations, source)
				}
				if !isTargetPlainJs {
					addDuplicateLocations(conflictingSymbolInfo.secondFileLocations, target)
				}
			} else {
				if !isSourcePlainJs {
					addDuplicateDeclarationErrorsForSymbols(source, message, symbolName, target)
				}
				if !isTargetPlainJs {
					addDuplicateDeclarationErrorsForSymbols(target, message, symbolName, source)
				}
			}
		}
		addDuplicateLocations := func(locs []Declaration, symbol Symbol) {
			if symbol.declarations {
				for _, decl := range symbol.declarations {
					pushIfUnique(locs, decl)
				}
			}
		}
	}
	addDuplicateDeclarationErrorsForSymbols := func(target Symbol, message DiagnosticMessage, symbolName string, source Symbol) {
		forEach(target.declarations, func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
			addDuplicateDeclarationError(node, message, symbolName, source.declarations)
		})
	}
	addDuplicateDeclarationError := func(node Declaration, message DiagnosticMessage, symbolName string, relatedNodes /* TODO(TypeOperator): readonly Declaration[] */ any) {
		errorNode := ( /* TODO(ConditionalExpression): getExpandoInitializer(node, /*isPrototypeAssignment* / false) ? getNameOfExpando(node) : getNameOfDeclaration(node) */ TODO) || node
		err := lookupOrIssueError(errorNode, message, symbolName)
		for _, relatedNode := range relatedNodes || emptyArray {
			adjustedNode := ( /* TODO(ConditionalExpression): getExpandoInitializer(relatedNode, /*isPrototypeAssignment* / false) ? getNameOfExpando(relatedNode) : getNameOfDeclaration(relatedNode) */ TODO) || relatedNode
			if adjustedNode == errorNode {
				continue
			}
			err.relatedInformation = err.relatedInformation || /* TODO(ArrayLiteralExpression): [] */ TODO
			leadingMessage := createDiagnosticForNode(adjustedNode, Diagnostics._0_was_also_declared_here, symbolName)
			followOnMessage := createDiagnosticForNode(adjustedNode, Diagnostics.and_here)
			if length(err.relatedInformation) >= 5 || some(err.relatedInformation, func(r /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticRelatedInformation */ TODO) /* TODO inferred type boolean */ TODO {
				return compareDiagnostics(r, followOnMessage) == ComparisonEqualTo || compareDiagnostics(r, leadingMessage) == ComparisonEqualTo
			}) {
				continue
			}
			addRelatedInfo(err /* TODO(ConditionalExpression): !length(err.relatedInformation) ? leadingMessage : followOnMessage */, TODO)
		}
	}
	combineSymbolTables := func(first *SymbolTable, second *SymbolTable) *SymbolTable {
		if !first.size {
			return second
		}
		if !second.size {
			return first
		}
		combined := createSymbolTable()
		mergeSymbolTable(combined, first)
		mergeSymbolTable(combined, second)
		return combined
	}
	mergeSymbolTable := func(target SymbolTable, source SymbolTable, unidirectional /* TODO inferred type boolean */ TODO /*  = false */, mergedParent Symbol) {
		source.forEach(func(sourceSymbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
			targetSymbol := target.get(id)
			merged := /* TODO(ConditionalExpression): targetSymbol ? mergeSymbol(targetSymbol, sourceSymbol, unidirectional) : getMergedSymbol(sourceSymbol) */ TODO
			if mergedParent && targetSymbol {
				merged.parent = mergedParent
			}
			target.set(id, merged)
		})
	}
	mergeModuleAugmentation := func(moduleName /* TODO(UnionType): StringLiteral | Identifier */ any) {
		moduleAugmentation := moduleName.parent
		if /* TODO(ElementAccessExpression): moduleAugmentation.symbol.declarations?.[0] */ TODO != moduleAugmentation {
			Debug.assert(moduleAugmentation.symbol.declarations.length > 1)
			return
		}
		if isGlobalScopeAugmentation(moduleAugmentation) {
			mergeSymbolTable(globals, moduleAugmentation.symbol.exports)
		} else {
			moduleNotFoundError := /* TODO(ConditionalExpression): !(moduleName.parent.parent.flags & NodeFlags.Ambient)                 ? Diagnostics.Invalid_module_name_in_augmentation_module_0_cannot_be_found                 : undefined */ TODO
			mainModule := resolveExternalModuleNameWorker(moduleName, moduleName, moduleNotFoundError, false, true)
			if !mainModule {
				return
			}
			mainModule = resolveExternalModuleSymbol(mainModule)
			if mainModule.flags & SymbolFlagsNamespace {
				if some(patternAmbientModules, func(module /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").PatternAmbientModule */ TODO) /* TODO inferred type boolean */ TODO {
					return mainModule == module.symbol
				}) {
					merged := mergeSymbol(moduleAugmentation.symbol, mainModule, true)
					if !patternAmbientModuleAugmentations {
						patternAmbientModuleAugmentations = /* TODO(NewExpression): new Map() */ make(map[any]any)
					}
					patternAmbientModuleAugmentations.set((moduleName).text, merged)
				} else {
					if mainModule.exports.get(InternalSymbolNameExportStar) && moduleAugmentation.symbol.exports.size {
						resolvedExports := getResolvedMembersOrExportsOfSymbol(mainModule, MembersOrExportsResolutionKindresolvedExports)
						for _, TODO_IDENTIFIER := range arrayFrom(moduleAugmentation.symbol.exports.entries()) {
							if resolvedExports.has(key) && !mainModule.exports.has(key) {
								mergeSymbol(resolvedExports.get(key), value)
							}
						}
					}
					mergeSymbol(mainModule, moduleAugmentation.symbol)
				}
			} else {
				error(moduleName, Diagnostics.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity, (moduleName).text)
			}
		}
	}
	addUndefinedToGlobalsOrErrorOnRedeclaration := func() {
		name := undefinedSymbol.escapedName
		targetSymbol := globals.get(name)
		if targetSymbol {
			forEach(targetSymbol.declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
				if !isTypeDeclaration(declaration) {
					diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, unescapeLeadingUnderscores(name)))
				}
			})
		} else {
			globals.set(name, undefinedSymbol)
		}
	}
	getSymbolLinks := func(symbol Symbol) SymbolLinks {
		if symbol.flags & SymbolFlagsTransient {
			return (symbol).links
		}
		id := getSymbolId(symbol)
		return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): symbolLinks[id] ??= new SymbolLinks() */ TODO
	}
	getNodeLinks := func(node Node) NodeLinks {
		nodeId := getNodeId(node)
		return /* TODO(ElementAccessExpression): nodeLinks[nodeId] */ TODO || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): nodeLinks[nodeId] = new (NodeLinks as any)() */ TODO)
	}
	getSymbol := func(symbols SymbolTable, name __String, meaning SymbolFlags) *Symbol {
		if meaning {
			symbol := getMergedSymbol(symbols.get(name))
			if symbol {
				if symbol.flags & meaning {
					return symbol
				}
				if symbol.flags & SymbolFlagsAlias {
					targetFlags := getSymbolFlags(symbol)
					if targetFlags & meaning {
						return symbol
					}
				}
			}
		}
	}
	getSymbolsOfParameterPropertyDeclaration := func(parameter ParameterPropertyDeclaration, parameterName __String) /* TODO(TupleType): [Symbol, Symbol] */ any {
		constructorDeclaration := parameter.parent
		classDeclaration := parameter.parent.parent
		parameterSymbol := getSymbol(constructorDeclaration.locals, parameterName, SymbolFlagsValue)
		propertySymbol := getSymbol(getMembersOfSymbol(classDeclaration.symbol), parameterName, SymbolFlagsValue)
		if parameterSymbol && propertySymbol {
			return /* TODO(ArrayLiteralExpression): [parameterSymbol, propertySymbol] */ TODO
		}
		return Debug.fail("There should exist two symbols, one as property declaration and one as parameter declaration")
	}
	isBlockScopedNameDeclaredBeforeUse := func(declaration Declaration, usage Node) bool {
		declarationFile := getSourceFileOfNode(declaration)
		useFile := getSourceFileOfNode(usage)
		declContainer := getEnclosingBlockScopeContainer(declaration)
		if declarationFile != useFile {
			if (moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) || (!compilerOptions.outFile) || isInTypeQuery(usage) || declaration.flags&NodeFlagsAmbient {
				return true
			}
			if isUsedInFunctionOrInstanceProperty(usage, declaration) {
				return true
			}
			sourceFiles := host.getSourceFiles()
			return sourceFiles.indexOf(declarationFile) <= sourceFiles.indexOf(useFile)
		}
		if !!(usage.flags & NodeFlagsJSDoc) || isInTypeQuery(usage) || isInAmbientOrTypeNode(usage) {
			return true
		}
		if declaration.pos <= usage.pos && !(isPropertyDeclaration(declaration) && isThisProperty(usage.parent) && !declaration.initializer && !declaration.exclamationToken) {
			if declaration.kind == SyntaxKindBindingElement {
				errorBindingElement := getAncestor(usage, SyntaxKindBindingElement)
				if errorBindingElement {
					return findAncestor(errorBindingElement, isBindingElement) != findAncestor(declaration, isBindingElement) || declaration.pos < errorBindingElement.pos
				}
				return isBlockScopedNameDeclaredBeforeUse(getAncestor(declaration, SyntaxKindVariableDeclaration), usage)
			} else if declaration.kind == SyntaxKindVariableDeclaration {
				return !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration, usage)
			} else if isClassLike(declaration) {
				container := findAncestor(usage, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
					return /* TODO(ConditionalExpression): n === declaration ? "quit" :                         isComputedPropertyName(n) ? n.parent.parent === declaration :                         !legacyDecorators && isDecorator(n) && (n.parent === declaration ||                             isMethodDeclaration(n.parent) && n.parent.parent === declaration ||                             isGetOrSetAccessorDeclaration(n.parent) && n.parent.parent === declaration ||                             isPropertyDeclaration(n.parent) && n.parent.parent === declaration ||                             isParameter(n.parent) && n.parent.parent.parent === declaration) */ TODO
				})
				if !container {
					return true
				}
				if !legacyDecorators && isDecorator(container) {
					return !!findAncestor(usage, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
						return /* TODO(ConditionalExpression): n === container ? "quit" : isFunctionLike(n) && !getImmediatelyInvokedFunctionExpression(n) */ TODO
					})
				}
				return false
			} else if isPropertyDeclaration(declaration) {
				return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, false)
			} else if isParameterPropertyDeclaration(declaration, declaration.parent) {
				return !(emitStandardClassFields && getContainingClass(declaration) == getContainingClass(usage) && isUsedInFunctionOrInstanceProperty(usage, declaration))
			}
			return true
		}
		if usage.parent.kind == SyntaxKindExportSpecifier || (usage.parent.kind == SyntaxKindExportAssignment && (usage.parent).isExportEquals) {
			return true
		}
		if usage.kind == SyntaxKindExportAssignment && (usage).isExportEquals {
			return true
		}
		if isUsedInFunctionOrInstanceProperty(usage, declaration) {
			if emitStandardClassFields && getContainingClass(declaration) && (isPropertyDeclaration(declaration) || isParameterPropertyDeclaration(declaration, declaration.parent)) {
				return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, true)
			} else {
				return true
			}
		}
		return false
		isImmediatelyUsedInInitializerOfBlockScopedVariable := func(declaration VariableDeclaration, usage Node) bool {
			switch declaration.parent.parent.kind {
			case SyntaxKindVariableStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForOfStatement:
				if isSameScopeDescendentOf(usage, declaration, declContainer) {
					return true
				}
				break
			}
			grandparent := declaration.parent.parent
			return isForInOrOfStatement(grandparent) && isSameScopeDescendentOf(usage, grandparent.expression, declContainer)
		}
		isUsedInFunctionOrInstanceProperty := func(usage Node, declaration Node) bool {
			return !!findAncestor(usage, func(current /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
				if current == declContainer {
					return "quit"
				}
				if isFunctionLike(current) {
					return true
				}
				if isClassStaticBlockDeclaration(current) {
					return declaration.pos < usage.pos
				}
				propertyDeclaration := tryCast(current.parent, isPropertyDeclaration)
				if propertyDeclaration {
					initializerOfProperty := propertyDeclaration.initializer == current
					if initializerOfProperty {
						if isStatic(current.parent) {
							if declaration.kind == SyntaxKindMethodDeclaration {
								return true
							}
							if isPropertyDeclaration(declaration) && getContainingClass(usage) == getContainingClass(declaration) {
								propName := declaration.name
								if isIdentifier(propName) || isPrivateIdentifier(propName) {
									type_ := getTypeOfSymbol(getSymbolOfDeclaration(declaration))
									staticBlocks := filter(declaration.parent.members, isClassStaticBlockDeclaration)
									if isPropertyInitializedInStaticBlocks(propName, type_, staticBlocks, declaration.parent.pos, current.pos) {
										return true
									}
								}
							}
						} else {
							isDeclarationInstanceProperty := declaration.kind == SyntaxKindPropertyDeclaration && !isStatic(declaration)
							if !isDeclarationInstanceProperty || getContainingClass(usage) != getContainingClass(declaration) {
								return true
							}
						}
					}
				}
				return false
			})
		}
		isPropertyImmediatelyReferencedWithinDeclaration := func(declaration /* TODO(UnionType): PropertyDeclaration | ParameterPropertyDeclaration */ any, usage Node, stopAtAnyPropertyDeclaration bool) /* TODO inferred type boolean */ TODO {
			if usage.end > declaration.end {
				return false
			}
			ancestorChangingReferenceScope := findAncestor(usage, func(node Node) /* TODO inferred type boolean | "quit" */ TODO {
				if node == declaration {
					return "quit"
				}
				switch node.kind {
				case SyntaxKindArrowFunction:
					return true
				case SyntaxKindPropertyDeclaration:
					return /* TODO(ConditionalExpression): stopAtAnyPropertyDeclaration &&                                 (isPropertyDeclaration(declaration) && node.parent === declaration.parent                                     || isParameterPropertyDeclaration(declaration, declaration.parent) && node.parent === declaration.parent.parent)                             ? "quit" : true */ TODO
				case SyntaxKindBlock:
					switch node.parent.kind {
					case SyntaxKindGetAccessor:
						fallthrough // TODO: merge cases
					case SyntaxKindMethodDeclaration:
						fallthrough // TODO: merge cases
					case SyntaxKindSetAccessor:
						return true
					default:
						return false
					}
					fallthrough
				default:
					return false
				}
			})
			return ancestorChangingReferenceScope == nil
		}
	}
	getRequiresScopeChangeCache := func(node FunctionLikeDeclaration) /* TODO inferred type boolean | undefined */ TODO {
		return getNodeLinks(node).declarationRequiresScopeChange
	}
	setRequiresScopeChangeCache := func(node FunctionLikeDeclaration, value bool) {
		getNodeLinks(node).declarationRequiresScopeChange = value
	}
	checkAndReportErrorForInvalidInitializer := func(errorLocation Node, name __String, propertyWithInvalidInitializer PropertyDeclaration, result *Symbol) /* TODO inferred type boolean */ TODO {
		if !emitStandardClassFields {
			if errorLocation && !result && checkAndReportErrorForMissingPrefix(errorLocation, name, name) {
				return true
			}
			error(errorLocation /* TODO(ConditionalExpression): errorLocation && propertyWithInvalidInitializer.type && textRangeContainsPositionInclusive(propertyWithInvalidInitializer.type, errorLocation.pos)                     ? Diagnostics.Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor                     : Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor */, TODO, declarationNameToString(propertyWithInvalidInitializer.name), diagnosticName(name))
			return true
		}
		return false
	}
	onFailedToResolveSymbol := func(errorLocation Node, nameArg /* TODO(UnionType): __String | Identifier */ any, meaning SymbolFlags, nameNotFoundMessage DiagnosticMessage) {
		name := /* TODO(ConditionalExpression): isString(nameArg) ? nameArg : (nameArg as Identifier).escapedText */ TODO
		addLazyDiagnostic(func() {
			if !errorLocation || errorLocation.parent.kind != SyntaxKindJSDocLink && !checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) && !checkAndReportErrorForExtendingInterface(errorLocation) && !checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) && !checkAndReportErrorForExportingPrimitiveType(errorLocation, name) && !checkAndReportErrorForUsingNamespaceAsTypeOrValue(errorLocation, name, meaning) && !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) && !checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning) {
				var suggestion *Symbol
				var suggestedLib /* TODO(StringKeyword): string */ any
				if nameArg {
					suggestedLib = getSuggestedLibForNonExistentName(nameArg)
					if suggestedLib {
						error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg), suggestedLib)
					}
				}
				if !suggestedLib && suggestionCount < maximumSuggestionCount {
					suggestion = getSuggestedSymbolForNonexistentSymbol(errorLocation, name, meaning)
					isGlobalScopeAugmentationDeclaration := suggestion.valueDeclaration && isAmbientModule(suggestion.valueDeclaration) && isGlobalScopeAugmentation(suggestion.valueDeclaration)
					if isGlobalScopeAugmentationDeclaration {
						suggestion = nil
					}
					if suggestion {
						suggestionName := symbolToString(suggestion)
						isUncheckedJS := isUncheckedJSSuggestion(errorLocation, suggestion, false)
						message := /* TODO(ConditionalExpression): meaning === SymbolFlags.Namespace ||                                 nameArg && typeof nameArg !== "string" && nodeIsSynthesized(nameArg) ?                             Diagnostics.Cannot_find_namespace_0_Did_you_mean_1                             : isUncheckedJS ? Diagnostics.Could_not_find_name_0_Did_you_mean_1                             : Diagnostics.Cannot_find_name_0_Did_you_mean_1 */ TODO
						diagnostic := createError(errorLocation, message, diagnosticName(nameArg), suggestionName)
						diagnostic.canonicalHead = getCanonicalDiagnostic(nameNotFoundMessage, diagnosticName(nameArg))
						addErrorOrSuggestion(!isUncheckedJS, diagnostic)
						if suggestion.valueDeclaration {
							addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName))
						}
					}
				}
				if !suggestion && !suggestedLib && nameArg {
					error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg))
				}
				suggestionCount++
			}
		})
	}
	onSuccessfullyResolvedSymbol := func(errorLocation Node, result Symbol, meaning SymbolFlags, lastLocation Node, associatedDeclarationForContainingInitializerOrBindingName /* TODO(UnionType): ParameterDeclaration | BindingElement | undefined */ any, withinDeferredContext bool) {
		addLazyDiagnostic(func() {
			name := result.escapedName
			isInExternalModule := lastLocation && isSourceFile(lastLocation) && isExternalOrCommonJsModule(lastLocation)
			if errorLocation && (meaning&SymbolFlagsBlockScopedVariable || ((meaning&SymbolFlagsClass || meaning&SymbolFlagsEnum) && (meaning&SymbolFlagsValue) == SymbolFlagsValue)) {
				exportOrLocalSymbol := getExportSymbolOfValueSymbolIfExported(result)
				if exportOrLocalSymbol.flags&SymbolFlagsBlockScopedVariable || exportOrLocalSymbol.flags&SymbolFlagsClass || exportOrLocalSymbol.flags&SymbolFlagsEnum {
					checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation)
				}
			}
			if isInExternalModule && (meaning&SymbolFlagsValue) == SymbolFlagsValue && !(errorLocation.flags & NodeFlagsJSDoc) {
				merged := getMergedSymbol(result)
				if length(merged.declarations) && every(merged.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
					return isNamespaceExportDeclaration(d) || isSourceFile(d) && !!d.symbol.globalExports
				}) {
					errorOrSuggestion(!compilerOptions.allowUmdGlobalAccess, errorLocation, Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead, unescapeLeadingUnderscores(name))
				}
			}
			if associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning&SymbolFlagsValue) == SymbolFlagsValue {
				candidate := getMergedSymbol(getLateBoundSymbol(result))
				root := getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName)
				if candidate == getSymbolOfDeclaration(associatedDeclarationForContainingInitializerOrBindingName) {
					error(errorLocation, Diagnostics.Parameter_0_cannot_reference_itself, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name))
				} else if candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && getSymbol(root.parent.locals, candidate.escapedName, meaning) == candidate {
					error(errorLocation, Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name), declarationNameToString(errorLocation))
				}
			}
			if errorLocation && meaning&SymbolFlagsValue && result.flags&SymbolFlagsAlias && !(result.flags & SymbolFlagsValue) && !isValidTypeOnlyAliasUseSite(errorLocation) {
				typeOnlyDeclaration := getTypeOnlyAliasDeclaration(result, SymbolFlagsValue)
				if typeOnlyDeclaration {
					message := /* TODO(ConditionalExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration || typeOnlyDeclaration.kind === SyntaxKind.NamespaceExport                         ? Diagnostics._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type                         : Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type */ TODO
					unescapedName := unescapeLeadingUnderscores(name)
					addTypeOnlyDeclarationRelatedInfo(error(errorLocation, message, unescapedName), typeOnlyDeclaration, unescapedName)
				}
			}
			if compilerOptions.isolatedModules && result && isInExternalModule && (meaning&SymbolFlagsValue) == SymbolFlagsValue {
				isGlobal := getSymbol(globals, name, meaning) == result
				nonValueSymbol := isGlobal && isSourceFile(lastLocation) && lastLocation.locals && getSymbol(lastLocation.locals, name, ~SymbolFlagsValue)
				if nonValueSymbol {
					importDecl := nonValueSymbol.declarations.find(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
						return d.kind == SyntaxKindImportSpecifier || d.kind == SyntaxKindImportClause || d.kind == SyntaxKindNamespaceImport || d.kind == SyntaxKindImportEqualsDeclaration
					})
					if importDecl && !isTypeOnlyImportDeclaration(importDecl) {
						error(importDecl, Diagnostics.Import_0_conflicts_with_global_value_used_in_this_file_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, unescapeLeadingUnderscores(name))
					}
				}
			}
		})
	}
	addTypeOnlyDeclarationRelatedInfo := func(diagnostic Diagnostic, typeOnlyDeclaration *TypeOnlyCompatibleAliasDeclaration, unescapedName string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic */ TODO {
		if !typeOnlyDeclaration {
			return diagnostic
		}
		return addRelatedInfo(diagnostic, createDiagnosticForNode(typeOnlyDeclaration /* TODO(ConditionalExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration || typeOnlyDeclaration.kind === SyntaxKind.NamespaceExport                     ? Diagnostics._0_was_exported_here                     : Diagnostics._0_was_imported_here */, TODO, unescapedName))
	}
	diagnosticName := func(nameArg /* TODO(UnionType): __String | Identifier | PrivateIdentifier */ any) /* TODO inferred type string */ TODO {
		return /* TODO(ConditionalExpression): isString(nameArg) ? unescapeLeadingUnderscores(nameArg as __String) : declarationNameToString(nameArg as Identifier) */ TODO
	}
	checkAndReportErrorForMissingPrefix := func(errorLocation Node, name __String, nameArg /* TODO(UnionType): __String | Identifier */ any) bool {
		if !isIdentifier(errorLocation) || errorLocation.escapedText != name || isTypeReferenceIdentifier(errorLocation) || isInTypeQuery(errorLocation) {
			return false
		}
		container := getThisContainer(errorLocation, false, false)
		var location Node = container
		for location {
			if isClassLike(location.parent) {
				classSymbol := getSymbolOfDeclaration(location.parent)
				if !classSymbol {
					break
				}
				constructorType := getTypeOfSymbol(classSymbol)
				if getPropertyOfType(constructorType, name) {
					error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0, diagnosticName(nameArg), symbolToString(classSymbol))
					return true
				}
				if location == container && !isStatic(location) {
					instanceType := (getDeclaredTypeOfSymbol(classSymbol)).thisType
					if getPropertyOfType(instanceType, name) {
						error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0, diagnosticName(nameArg))
						return true
					}
				}
			}
			location = location.parent
		}
		return false
	}
	checkAndReportErrorForExtendingInterface := func(errorLocation Node) bool {
		expression := getEntityNameForExtendingInterface(errorLocation)
		if expression && resolveEntityName(expression, SymbolFlagsInterface, true) {
			error(errorLocation, Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements, getTextOfNode(expression))
			return true
		}
		return false
	}
	getEntityNameForExtendingInterface := func(node Node) *EntityNameExpression {
		switch node.kind {
		case SyntaxKindIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAccessExpression:
			return /* TODO(ConditionalExpression): node.parent ? getEntityNameForExtendingInterface(node.parent) : undefined */ TODO
		case SyntaxKindExpressionWithTypeArguments:
			if isEntityNameExpression((node).expression) {
				return (node).expression
			}
			fallthrough
		default:
			return nil
		}
	}
	checkAndReportErrorForUsingTypeAsNamespace := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		namespaceMeaning := SymbolFlagsNamespace | ( /* TODO(ConditionalExpression): isInJSFile(errorLocation) ? SymbolFlags.Value : 0 */ TODO)
		if meaning == namespaceMeaning {
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsType&~namespaceMeaning, nil, false))
			parent := errorLocation.parent
			if symbol {
				if isQualifiedName(parent) {
					Debug.assert(parent.left == errorLocation, "Should only be resolving left side of qualified name as a namespace")
					propName := parent.right.escapedText
					propType := getPropertyOfType(getDeclaredTypeOfSymbol(symbol), propName)
					if propType {
						error(parent, Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, unescapeLeadingUnderscores(name), unescapeLeadingUnderscores(propName))
						return true
					}
				}
				error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here, unescapeLeadingUnderscores(name))
				return true
			}
		}
		return false
	}
	checkAndReportErrorForUsingValueAsType := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if meaning & (SymbolFlagsType & ~SymbolFlagsNamespace) {
			symbol := resolveSymbol(resolveName(errorLocation, name, ~SymbolFlagsType&SymbolFlagsValue, nil, false))
			if symbol && !(symbol.flags & SymbolFlagsNamespace) {
				error(errorLocation, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, unescapeLeadingUnderscores(name))
				return true
			}
		}
		return false
	}
	isPrimitiveTypeName := func(name __String) /* TODO inferred type boolean */ TODO {
		return name == "any" || name == "string" || name == "number" || name == "boolean" || name == "never" || name == "unknown"
	}
	checkAndReportErrorForExportingPrimitiveType := func(errorLocation Node, name __String) bool {
		if isPrimitiveTypeName(name) && errorLocation.parent.kind == SyntaxKindExportSpecifier {
			error(errorLocation, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, name)
			return true
		}
		return false
	}
	checkAndReportErrorForUsingTypeAsValue := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if meaning & SymbolFlagsValue {
			if isPrimitiveTypeName(name) {
				grandparent := errorLocation.parent.parent
				if grandparent && grandparent.parent && isHeritageClause(grandparent) {
					heritageKind := grandparent.token
					containerKind := grandparent.parent.kind
					if containerKind == SyntaxKindInterfaceDeclaration && heritageKind == SyntaxKindExtendsKeyword {
						error(errorLocation, Diagnostics.An_interface_cannot_extend_a_primitive_type_like_0_It_can_only_extend_other_named_object_types, unescapeLeadingUnderscores(name))
					} else if containerKind == SyntaxKindClassDeclaration && heritageKind == SyntaxKindExtendsKeyword {
						error(errorLocation, Diagnostics.A_class_cannot_extend_a_primitive_type_like_0_Classes_can_only_extend_constructable_values, unescapeLeadingUnderscores(name))
					} else if containerKind == SyntaxKindClassDeclaration && heritageKind == SyntaxKindImplementsKeyword {
						error(errorLocation, Diagnostics.A_class_cannot_implement_a_primitive_type_like_0_It_can_only_implement_other_named_object_types, unescapeLeadingUnderscores(name))
					}
				} else {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, unescapeLeadingUnderscores(name))
				}
				return true
			}
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsType&~SymbolFlagsValue, nil, false))
			allFlags := symbol && getSymbolFlags(symbol)
			if symbol && allFlags != nil && !(allFlags & SymbolFlagsValue) {
				rawName := unescapeLeadingUnderscores(name)
				if isES2015OrLaterConstructorName(name) {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later, rawName)
				} else if maybeMappedType(errorLocation, symbol) {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0, rawName /* TODO(ConditionalExpression): rawName === "K" ? "P" : "K" */, TODO)
				} else {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, rawName)
				}
				return true
			}
		}
		return false
	}
	maybeMappedType := func(node Node, symbol Symbol) /* TODO inferred type boolean */ TODO {
		container := findAncestor(node.parent, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
			return /* TODO(ConditionalExpression): isComputedPropertyName(n) || isPropertySignature(n) ? false : isTypeLiteralNode(n) || "quit" */ TODO
		})
		if container && container.members.length == 1 {
			type_ := getDeclaredTypeOfSymbol(symbol)
			return !!(type_.flags & TypeFlagsUnion) && allTypesAssignableToKind(type_, TypeFlagsStringOrNumberLiteral, true)
		}
		return false
	}
	isES2015OrLaterConstructorName := func(n __String) /* TODO inferred type boolean */ TODO {
		switch n {
		case "Promise":
			fallthrough // TODO: merge cases
		case "Symbol":
			fallthrough // TODO: merge cases
		case "Map":
			fallthrough // TODO: merge cases
		case "WeakMap":
			fallthrough // TODO: merge cases
		case "Set":
			fallthrough // TODO: merge cases
		case "WeakSet":
			return true
		}
		return false
	}
	checkAndReportErrorForUsingNamespaceAsTypeOrValue := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if meaning & (SymbolFlagsValue & ~SymbolFlagsType) {
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsNamespaceModule, nil, false))
			if symbol {
				error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_value, unescapeLeadingUnderscores(name))
				return true
			}
		} else if meaning & (SymbolFlagsType & ~SymbolFlagsValue) {
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsModule, nil, false))
			if symbol {
				error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_type, unescapeLeadingUnderscores(name))
				return true
			}
		}
		return false
	}
	checkResolvedBlockScopedVariable := func(result Symbol, errorLocation Node) {
		Debug.assert(!!(result.flags&SymbolFlagsBlockScopedVariable || result.flags&SymbolFlagsClass || result.flags&SymbolFlagsEnum))
		if result.flags&(SymbolFlagsFunction|SymbolFlagsFunctionScopedVariable|SymbolFlagsAssignment) && result.flags&SymbolFlagsClass {
			return
		}
		declaration := result.declarations.find(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
			return isBlockOrCatchScoped(d) || isClassLike(d) || (d.kind == SyntaxKindEnumDeclaration)
		})
		if declaration == nil {
			return Debug.fail("checkResolvedBlockScopedVariable could not find block-scoped declaration")
		}
		if !(declaration.flags & NodeFlagsAmbient) && !isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation) {
			var diagnosticMessage TODO
			declarationName := declarationNameToString(getNameOfDeclaration(declaration))
			if result.flags & SymbolFlagsBlockScopedVariable {
				diagnosticMessage = error(errorLocation, Diagnostics.Block_scoped_variable_0_used_before_its_declaration, declarationName)
			} else if result.flags & SymbolFlagsClass {
				diagnosticMessage = error(errorLocation, Diagnostics.Class_0_used_before_its_declaration, declarationName)
			} else if result.flags & SymbolFlagsRegularEnum {
				diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName)
			} else {
				Debug.assert(!!(result.flags & SymbolFlagsConstEnum))
				if getIsolatedModules(compilerOptions) {
					diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName)
				}
			}
			if diagnosticMessage {
				addRelatedInfo(diagnosticMessage, createDiagnosticForNode(declaration, Diagnostics._0_is_declared_here, declarationName))
			}
		}
	}
	isSameScopeDescendentOf := func(initial Node, parent Node, stopAt Node) bool {
		return !!parent && !!findAncestor(initial, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
			return n == parent || ( /* TODO(ConditionalExpression): n === stopAt || isFunctionLike(n) && (!getImmediatelyInvokedFunctionExpression(n) || (getFunctionFlags(n) & FunctionFlags.AsyncGenerator)) ? "quit" : false */ TODO)
		})
	}
	getAnyImportSyntax := func(node Node) *AnyImportOrJsDocImport {
		switch node.kind {
		case SyntaxKindImportEqualsDeclaration:
			return node
		case SyntaxKindImportClause:
			return (node).parent
		case SyntaxKindNamespaceImport:
			return (node).parent.parent
		case SyntaxKindImportSpecifier:
			return (node).parent.parent.parent
		default:
			return nil
		}
	}
	getDeclarationOfAliasSymbol := func(symbol Symbol) Declaration {
		return symbol.declarations && findLast(symbol.declarations, isAliasSymbolDeclaration)
	}
	isAliasSymbolDeclaration := func(node Node) bool {
		return node.kind == SyntaxKindImportEqualsDeclaration || node.kind == SyntaxKindNamespaceExportDeclaration || node.kind == SyntaxKindImportClause && !!(node).name || node.kind == SyntaxKindNamespaceImport || node.kind == SyntaxKindNamespaceExport || node.kind == SyntaxKindImportSpecifier || node.kind == SyntaxKindExportSpecifier || node.kind == SyntaxKindExportAssignment && exportAssignmentIsAlias(node) || isBinaryExpression(node) && getAssignmentDeclarationKind(node) == AssignmentDeclarationKindModuleExports && exportAssignmentIsAlias(node) || isAccessExpression(node) && isBinaryExpression(node.parent) && node.parent.left == node && node.parent.operatorToken.kind == SyntaxKindEqualsToken && isAliasableOrJsExpression(node.parent.right) || node.kind == SyntaxKindShorthandPropertyAssignment || node.kind == SyntaxKindPropertyAssignment && isAliasableOrJsExpression((node).initializer) || node.kind == SyntaxKindVariableDeclaration && isVariableDeclarationInitializedToBareOrAccessedRequire(node) || node.kind == SyntaxKindBindingElement && isVariableDeclarationInitializedToBareOrAccessedRequire(node.parent.parent)
	}
	isAliasableOrJsExpression := func(e Expression) /* TODO inferred type boolean */ TODO {
		return isAliasableExpression(e) || isFunctionExpression(e) && isJSConstructor(e)
	}
	getTargetOfImportEqualsDeclaration := func(node /* TODO(UnionType): ImportEqualsDeclaration | VariableDeclaration */ any, dontResolveAlias bool) *Symbol {
		commonJSPropertyAccess := getCommonJSPropertyAccess(node)
		if commonJSPropertyAccess {
			name := /* TODO(ElementAccessExpression): (getLeftmostAccessExpression(commonJSPropertyAccess.expression) as CallExpression).arguments[0] */ TODO
			return /* TODO(ConditionalExpression): isIdentifier(commonJSPropertyAccess.name)                 ? resolveSymbol(getPropertyOfType(resolveExternalModuleTypeByLiteral(name), commonJSPropertyAccess.name.escapedText))                 : undefined */ TODO
		}
		if isVariableDeclaration(node) || node.moduleReference.kind == SyntaxKindExternalModuleReference {
			immediate := resolveExternalModuleName(node, getExternalModuleRequireArgument(node) || getExternalModuleImportEqualsDeclarationExpression(node))
			resolved := resolveExternalModuleSymbol(immediate)
			markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false)
			return resolved
		}
		resolved := getSymbolOfPartOfRightHandSideOfImportEquals(node.moduleReference, dontResolveAlias)
		checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved)
		return resolved
	}
	checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol := func(node ImportEqualsDeclaration, resolved *Symbol) {
		if markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false) && !node.isTypeOnly {
			typeOnlyDeclaration := getTypeOnlyAliasDeclaration(getSymbolOfDeclaration(node))
			isExport := typeOnlyDeclaration.kind == SyntaxKindExportSpecifier || typeOnlyDeclaration.kind == SyntaxKindExportDeclaration
			message := /* TODO(ConditionalExpression): isExport                 ? Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type                 : Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type */ TODO
			relatedMessage := /* TODO(ConditionalExpression): isExport                 ? Diagnostics._0_was_exported_here                 : Diagnostics._0_was_imported_here */ TODO
			name := /* TODO(ConditionalExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration ? "*" : moduleExportNameTextUnescaped(typeOnlyDeclaration.name) */ TODO
			addRelatedInfo(error(node.moduleReference, message), createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, name))
		}
	}
	resolveExportByName := func(moduleSymbol Symbol, name __String, sourceNode *TypeOnlyCompatibleAliasDeclaration, dontResolveAlias bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		exportValue := moduleSymbol.exports.get(InternalSymbolNameExportEquals)
		exportSymbol := /* TODO(ConditionalExpression): exportValue             ? getPropertyOfType(getTypeOfSymbol(exportValue), name, /*skipObjectFunctionPropertyAugment* / true)             : moduleSymbol.exports!.get(name) */ TODO
		resolved := resolveSymbol(exportSymbol, dontResolveAlias)
		markSymbolOfAliasDeclarationIfTypeOnly(sourceNode, exportSymbol, resolved, false)
		return resolved
	}
	isSyntacticDefault := func(node Node) /* TODO inferred type boolean */ TODO {
		return ((isExportAssignment(node) && !node.isExportEquals) || hasSyntacticModifier(node, ModifierFlagsDefault) || isExportSpecifier(node) || isNamespaceExport(node))
	}
	getEmitSyntaxForModuleSpecifierExpression := func(usage Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ResolutionMode */ TODO {
		return /* TODO(ConditionalExpression): isStringLiteralLike(usage) ? host.getEmitSyntaxForUsageLocation(getSourceFileOfNode(usage), usage) : undefined */ TODO
	}
	isESMFormatImportImportingCommonjsFormatFile := func(usageMode ResolutionMode, targetMode ResolutionMode) /* TODO inferred type boolean */ TODO {
		return usageMode == ModuleKindESNext && targetMode == ModuleKindCommonJS
	}
	isOnlyImportableAsDefault := func(usage Expression) /* TODO inferred type boolean */ TODO {
		if ModuleKindNode16 <= moduleKind && moduleKind <= ModuleKindNodeNext {
			usageMode := getEmitSyntaxForModuleSpecifierExpression(usage)
			return usageMode == ModuleKindESNext && endsWith((usage).text, ExtensionJson)
		}
		return false
	}
	canHaveSyntheticDefault := func(file *SourceFile, moduleSymbol Symbol, dontResolveAlias bool, usage Expression) /* TODO inferred type boolean */ TODO {
		usageMode := file && getEmitSyntaxForModuleSpecifierExpression(usage)
		if file && usageMode != nil {
			targetMode := host.getImpliedNodeFormatForEmit(file)
			if usageMode == ModuleKindESNext && targetMode == ModuleKindCommonJS && ModuleKindNode16 <= moduleKind && moduleKind <= ModuleKindNodeNext {
				return true
			}
			if usageMode == ModuleKindESNext && targetMode == ModuleKindESNext {
				return false
			}
		}
		if !allowSyntheticDefaultImports {
			return false
		}
		if !file || file.isDeclarationFile {
			defaultExportSymbol := resolveExportByName(moduleSymbol, InternalSymbolNameDefault, nil, true)
			if defaultExportSymbol && some(defaultExportSymbol.declarations, isSyntacticDefault) {
				return false
			}
			if resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), nil, dontResolveAlias) {
				return false
			}
			return true
		}
		if !isSourceFileJS(file) {
			return hasExportAssignmentSymbol(moduleSymbol)
		}
		return /* TODO(TypeOfExpression): typeof file.externalModuleIndicator */ TODO != "object" && !resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), nil, dontResolveAlias)
	}
	getTargetOfImportClause := func(node ImportClause, dontResolveAlias bool) *Symbol {
		moduleSymbol := resolveExternalModuleName(node, node.parent.moduleSpecifier)
		if moduleSymbol {
			return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
		}
	}
	getTargetofModuleDefault := func(moduleSymbol Symbol, node /* TODO(UnionType): ImportClause | ImportOrExportSpecifier */ any, dontResolveAlias bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		var exportDefaultSymbol *Symbol
		if isShorthandAmbientModuleSymbol(moduleSymbol) {
			exportDefaultSymbol = moduleSymbol
		} else {
			exportDefaultSymbol = resolveExportByName(moduleSymbol, InternalSymbolNameDefault, node, dontResolveAlias)
		}
		file := moduleSymbol.declarations.find(isSourceFile)
		specifier := getModuleSpecifierForImportOrExport(node)
		if !specifier {
			return exportDefaultSymbol
		}
		hasDefaultOnly := isOnlyImportableAsDefault(specifier)
		hasSyntheticDefault := canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, specifier)
		if !exportDefaultSymbol && !hasSyntheticDefault && !hasDefaultOnly {
			if hasExportAssignmentSymbol(moduleSymbol) && !allowSyntheticDefaultImports {
				compilerOptionName := /* TODO(ConditionalExpression): moduleKind >= ModuleKind.ES2015 ? "allowSyntheticDefaultImports" : "esModuleInterop" */ TODO
				exportEqualsSymbol := moduleSymbol.exports.get(InternalSymbolNameExportEquals)
				exportAssignment := exportEqualsSymbol.valueDeclaration
				err := error(node.name, Diagnostics.Module_0_can_only_be_default_imported_using_the_1_flag, symbolToString(moduleSymbol), compilerOptionName)
				if exportAssignment {
					addRelatedInfo(err, createDiagnosticForNode(exportAssignment, Diagnostics.This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag, compilerOptionName))
				}
			} else if isImportClause(node) {
				reportNonDefaultExport(moduleSymbol, node)
			} else {
				errorNoModuleMemberSymbol(moduleSymbol, moduleSymbol, node, isImportOrExportSpecifier(node) && node.propertyName || node.name)
			}
		} else if hasSyntheticDefault || hasDefaultOnly {
			resolved := resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias)
			markSymbolOfAliasDeclarationIfTypeOnly(node, moduleSymbol, resolved, false)
			return resolved
		}
		markSymbolOfAliasDeclarationIfTypeOnly(node, exportDefaultSymbol, nil, false)
		return exportDefaultSymbol
	}
	getModuleSpecifierForImportOrExport := func(node /* TODO(UnionType): ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportOrExportSpecifier */ any) *Expression {
		switch node.kind {
		case SyntaxKindImportClause:
			return node.parent.moduleSpecifier
		case SyntaxKindImportEqualsDeclaration:
			return /* TODO(ConditionalExpression): isExternalModuleReference(node.moduleReference) ? node.moduleReference.expression : undefined */ TODO
		case SyntaxKindNamespaceImport:
			return node.parent.parent.moduleSpecifier
		case SyntaxKindImportSpecifier:
			return node.parent.parent.parent.moduleSpecifier
		case SyntaxKindExportSpecifier:
			return node.parent.parent.moduleSpecifier
		default:
			return Debug.assertNever(node)
		}
	}
	reportNonDefaultExport := func(moduleSymbol Symbol, node ImportClause) {
		if moduleSymbol.exports.has(node.symbol.escapedName) {
			error(node.name, Diagnostics.Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead, symbolToString(moduleSymbol), symbolToString(node.symbol))
		} else {
			diagnostic := error(node.name, Diagnostics.Module_0_has_no_default_export, symbolToString(moduleSymbol))
			exportStar := moduleSymbol.exports.get(InternalSymbolNameExportStar)
			if exportStar {
				defaultExport := exportStar.declarations.find(func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
					return !!(isExportDeclaration(decl) && decl.moduleSpecifier && resolveExternalModuleName(decl, decl.moduleSpecifier).exports.has(InternalSymbolNameDefault))
				})
				if defaultExport {
					addRelatedInfo(diagnostic, createDiagnosticForNode(defaultExport, Diagnostics.export_Asterisk_does_not_re_export_a_default))
				}
			}
		}
	}
	getTargetOfNamespaceImport := func(node NamespaceImport, dontResolveAlias bool) *Symbol {
		moduleSpecifier := node.parent.parent.moduleSpecifier
		immediate := resolveExternalModuleName(node, moduleSpecifier)
		resolved := resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false)
		markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false)
		return resolved
	}
	getTargetOfNamespaceExport := func(node NamespaceExport, dontResolveAlias bool) *Symbol {
		moduleSpecifier := node.parent.moduleSpecifier
		immediate := moduleSpecifier && resolveExternalModuleName(node, moduleSpecifier)
		resolved := moduleSpecifier && resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false)
		markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false)
		return resolved
	}
	combineValueAndTypeSymbols := func(valueSymbol Symbol, typeSymbol Symbol) Symbol {
		if valueSymbol == unknownSymbol && typeSymbol == unknownSymbol {
			return unknownSymbol
		}
		if valueSymbol.flags & (SymbolFlagsType | SymbolFlagsNamespace) {
			return valueSymbol
		}
		result := createSymbol(valueSymbol.flags|typeSymbol.flags, valueSymbol.escapedName)
		Debug.assert(valueSymbol.declarations || typeSymbol.declarations)
		result.declarations = deduplicate(concatenate(valueSymbol.declarations, typeSymbol.declarations), equateValues)
		result.parent = valueSymbol.parent || typeSymbol.parent
		if valueSymbol.valueDeclaration {
			result.valueDeclaration = valueSymbol.valueDeclaration
		}
		if typeSymbol.members {
			result.members = /* TODO(NewExpression): new Map(typeSymbol.members) */ TODO
		}
		if valueSymbol.exports {
			result.exports = /* TODO(NewExpression): new Map(valueSymbol.exports) */ TODO
		}
		return result
	}
	getExportOfModule := func(symbol Symbol, nameText __String, specifier Declaration, dontResolveAlias bool) *Symbol {
		if symbol.flags & SymbolFlagsModule {
			exportSymbol := getExportsOfSymbol(symbol).get(nameText)
			resolved := resolveSymbol(exportSymbol, dontResolveAlias)
			exportStarDeclaration := getSymbolLinks(symbol).typeOnlyExportStarMap.get(nameText)
			markSymbolOfAliasDeclarationIfTypeOnly(specifier, exportSymbol, resolved, false, exportStarDeclaration, nameText)
			return resolved
		}
	}
	getPropertyOfVariable := func(symbol Symbol, name __String) *Symbol {
		if symbol.flags & SymbolFlagsVariable {
			typeAnnotation := (symbol.valueDeclaration).type_
			if typeAnnotation {
				return resolveSymbol(getPropertyOfType(getTypeFromTypeNode(typeAnnotation), name))
			}
		}
	}
	getExternalModuleMember := func(node /* TODO(UnionType): ImportDeclaration | ExportDeclaration | VariableDeclaration | JSDocImportTag */ any, specifier /* TODO(UnionType): ImportOrExportSpecifier | BindingElement | PropertyAccessExpression */ any, dontResolveAlias /* TODO inferred type boolean */ TODO /*  = false */) *Symbol {
		moduleSpecifier := getExternalModuleRequireArgument(node) || (node).moduleSpecifier
		moduleSymbol := resolveExternalModuleName(node, moduleSpecifier)
		name := !isPropertyAccessExpression(specifier) && specifier.propertyName || specifier.name
		if !isIdentifier(name) && name.kind != SyntaxKindStringLiteral {
			return nil
		}
		nameText := moduleExportNameTextEscaped(name)
		suppressInteropError := nameText == InternalSymbolNameDefault && allowSyntheticDefaultImports
		targetSymbol := resolveESModuleSymbol(moduleSymbol, moduleSpecifier, false, suppressInteropError)
		if targetSymbol {
			if nameText || name.kind == SyntaxKindStringLiteral {
				if isShorthandAmbientModuleSymbol(moduleSymbol) {
					return moduleSymbol
				}
				var symbolFromVariable *Symbol
				if moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get(InternalSymbolNameExportEquals) {
					symbolFromVariable = getPropertyOfType(getTypeOfSymbol(targetSymbol), nameText, true)
				} else {
					symbolFromVariable = getPropertyOfVariable(targetSymbol, nameText)
				}
				symbolFromVariable = resolveSymbol(symbolFromVariable, dontResolveAlias)
				symbolFromModule := getExportOfModule(targetSymbol, nameText, specifier, dontResolveAlias)
				if symbolFromModule == nil && nameText == InternalSymbolNameDefault {
					file := moduleSymbol.declarations.find(isSourceFile)
					if isOnlyImportableAsDefault(moduleSpecifier) || canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, moduleSpecifier) {
						symbolFromModule = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias)
					}
				}
				symbol := /* TODO(ConditionalExpression): symbolFromModule && symbolFromVariable && symbolFromModule !== symbolFromVariable ?                     combineValueAndTypeSymbols(symbolFromVariable, symbolFromModule) :                     symbolFromModule || symbolFromVariable */ TODO
				if !symbol {
					errorNoModuleMemberSymbol(moduleSymbol, targetSymbol, node, name)
				}
				return symbol
			}
		}
	}
	errorNoModuleMemberSymbol := func(moduleSymbol Symbol, targetSymbol Symbol, node Node, name ModuleExportName) {
		moduleName := getFullyQualifiedName(moduleSymbol, node)
		declarationName := declarationNameToString(name)
		suggestion := /* TODO(ConditionalExpression): isIdentifier(name) ? getSuggestedSymbolForNonexistentModule(name, targetSymbol) : undefined */ TODO
		if suggestion != nil {
			suggestionName := symbolToString(suggestion)
			diagnostic := error(name, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, moduleName, declarationName, suggestionName)
			if suggestion.valueDeclaration {
				addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName))
			}
		} else {
			if moduleSymbol.exports.has(InternalSymbolNameDefault) {
				error(name, Diagnostics.Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead, moduleName, declarationName)
			} else {
				reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName)
			}
		}
	}
	reportNonExportedMember := func(node Node, name ModuleExportName, declarationName string, moduleSymbol Symbol, moduleName string) {
		localSymbol := tryCast(moduleSymbol.valueDeclaration, canHaveLocals).locals.get(moduleExportNameTextEscaped(name))
		exports := moduleSymbol.exports
		if localSymbol {
			exportedEqualsSymbol := exports.get(InternalSymbolNameExportEquals)
			if exportedEqualsSymbol {
				/* TODO(ExpressionStatement): getSymbolIfSameReference(exportedEqualsSymbol, localSymbol) ? reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName) :                     error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName); */
			} else {
				exportedSymbol := /* TODO(ConditionalExpression): exports ? find(symbolsToArray(exports), symbol => !!getSymbolIfSameReference(symbol, localSymbol)) : undefined */ TODO
				diagnostic := /* TODO(ConditionalExpression): exportedSymbol ? error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_exported_as_2, moduleName, declarationName, symbolToString(exportedSymbol)) :                     error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_not_exported, moduleName, declarationName) */ TODO
				if localSymbol.declarations {
					addRelatedInfo(diagnostic /* TODO(SpreadElement): ...map(localSymbol.declarations, (decl, index) => createDiagnosticForNode(decl, index === 0 ? Diagnostics._0_is_declared_here : Diagnostics.and_here, declarationName)) */, TODO)
				}
			}
		} else {
			error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName)
		}
	}
	reportInvalidImportEqualsExportMember := func(node Node, name ModuleExportName, declarationName string, moduleName string) {
		if moduleKind >= ModuleKindES2015 {
			message := /* TODO(ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_default_import :                 Diagnostics._0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
			error(name, message, declarationName)
		} else {
			if isInJSFile(node) {
				message := /* TODO(ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import :                     Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
				error(name, message, declarationName)
			} else {
				message := /* TODO(ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import :                     Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
				error(name, message, declarationName, declarationName, moduleName)
			}
		}
	}
	getTargetOfImportSpecifier := func(node /* TODO(UnionType): ImportSpecifier | BindingElement */ any, dontResolveAlias bool) *Symbol {
		if isImportSpecifier(node) && moduleExportNameIsDefault(node.propertyName || node.name) {
			specifier := getModuleSpecifierForImportOrExport(node)
			moduleSymbol := specifier && resolveExternalModuleName(node, specifier)
			if moduleSymbol {
				return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
			}
		}
		root := /* TODO(ConditionalExpression): isBindingElement(node) ? getRootDeclaration(node) as VariableDeclaration : node.parent.parent.parent */ TODO
		commonJSPropertyAccess := getCommonJSPropertyAccess(root)
		resolved := getExternalModuleMember(root, commonJSPropertyAccess || node, dontResolveAlias)
		name := node.propertyName || node.name
		if commonJSPropertyAccess && resolved && isIdentifier(name) {
			return resolveSymbol(getPropertyOfType(getTypeOfSymbol(resolved), name.escapedText), dontResolveAlias)
		}
		markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false)
		return resolved
	}
	getCommonJSPropertyAccess := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyAccessExpression | undefined */ TODO {
		if isVariableDeclaration(node) && node.initializer && isPropertyAccessExpression(node.initializer) {
			return node.initializer
		}
	}
	getTargetOfNamespaceExportDeclaration := func(node NamespaceExportDeclaration, dontResolveAlias bool) *Symbol {
		if canHaveSymbol(node.parent) {
			resolved := resolveExternalModuleSymbol(node.parent.symbol, dontResolveAlias)
			markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false)
			return resolved
		}
	}
	getTargetOfExportSpecifier := func(node ExportSpecifier, meaning SymbolFlags, dontResolveAlias bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		name := node.propertyName || node.name
		if moduleExportNameIsDefault(name) {
			specifier := getModuleSpecifierForImportOrExport(node)
			moduleSymbol := specifier && resolveExternalModuleName(node, specifier)
			if moduleSymbol {
				return getTargetofModuleDefault(moduleSymbol, node, !!dontResolveAlias)
			}
		}
		resolved := /* TODO(ConditionalExpression): node.parent.parent.moduleSpecifier ?             getExternalModuleMember(node.parent.parent, node, dontResolveAlias) :             name.kind === SyntaxKind.StringLiteral ? undefined : // Skip for invalid syntax like this: export { "x" }             resolveEntityName(name, meaning, /*ignoreErrors* / false, dontResolveAlias) */ TODO
		markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false)
		return resolved
	}
	getTargetOfExportAssignment := func(node /* TODO(UnionType): ExportAssignment | BinaryExpression */ any, dontResolveAlias bool) *Symbol {
		expression := /* TODO(ConditionalExpression): isExportAssignment(node) ? node.expression : node.right */ TODO
		resolved := getTargetOfAliasLikeExpression(expression, dontResolveAlias)
		markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false)
		return resolved
	}
	getTargetOfAliasLikeExpression := func(expression Expression, dontResolveAlias bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if isClassExpression(expression) {
			return checkExpressionCached(expression).symbol
		}
		if !isEntityName(expression) && !isEntityNameExpression(expression) {
			return nil
		}
		aliasLike := resolveEntityName(expression, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, true, dontResolveAlias)
		if aliasLike {
			return aliasLike
		}
		checkExpressionCached(expression)
		return getNodeLinks(expression).resolvedSymbol
	}
	getTargetOfAccessExpression := func(node AccessExpression, dontRecursivelyResolve bool) *Symbol {
		if !(isBinaryExpression(node.parent) && node.parent.left == node && node.parent.operatorToken.kind == SyntaxKindEqualsToken) {
			return nil
		}
		return getTargetOfAliasLikeExpression(node.parent.right, dontRecursivelyResolve)
	}
	getTargetOfAliasDeclaration := func(node Declaration, dontRecursivelyResolve /* TODO inferred type boolean */ TODO /*  = false */) *Symbol {
		switch node.kind {
		case SyntaxKindImportEqualsDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindVariableDeclaration:
			return getTargetOfImportEqualsDeclaration(node, dontRecursivelyResolve)
		case SyntaxKindImportClause:
			return getTargetOfImportClause(node, dontRecursivelyResolve)
		case SyntaxKindNamespaceImport:
			return getTargetOfNamespaceImport(node, dontRecursivelyResolve)
		case SyntaxKindNamespaceExport:
			return getTargetOfNamespaceExport(node, dontRecursivelyResolve)
		case SyntaxKindImportSpecifier:
			fallthrough // TODO: merge cases
		case SyntaxKindBindingElement:
			return getTargetOfImportSpecifier(node, dontRecursivelyResolve)
		case SyntaxKindExportSpecifier:
			return getTargetOfExportSpecifier(node, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, dontRecursivelyResolve)
		case SyntaxKindExportAssignment:
			fallthrough // TODO: merge cases
		case SyntaxKindBinaryExpression:
			return getTargetOfExportAssignment(node, dontRecursivelyResolve)
		case SyntaxKindNamespaceExportDeclaration:
			return getTargetOfNamespaceExportDeclaration(node, dontRecursivelyResolve)
		case SyntaxKindShorthandPropertyAssignment:
			return resolveEntityName((node).name, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, true, dontRecursivelyResolve)
		case SyntaxKindPropertyAssignment:
			return getTargetOfAliasLikeExpression((node).initializer, dontRecursivelyResolve)
		case SyntaxKindElementAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAccessExpression:
			return getTargetOfAccessExpression(node, dontRecursivelyResolve)
		default:
			return Debug.fail()
		}
	}
	isNonLocalAlias := func(symbol *Symbol, excludes /* TODO inferred type number */ TODO /*  = SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace */) /* TODO(TypePredicate): symbol is Symbol */ any {
		if !symbol {
			return false
		}
		return (symbol.flags&(SymbolFlagsAlias|excludes)) == SymbolFlagsAlias || !!(symbol.flags&SymbolFlagsAlias && symbol.flags&SymbolFlagsAssignment)
	}
	// OVERLOAD: resolveSymbol := func(symbol Symbol, dontResolveAlias bool) Symbol
	// OVERLOAD: resolveSymbol := func(symbol *Symbol, dontResolveAlias bool) *Symbol
	resolveSymbol := func(symbol *Symbol, dontResolveAlias bool) *Symbol {
		return /* TODO(ConditionalExpression): !dontResolveAlias && isNonLocalAlias(symbol) ? resolveAlias(symbol) : symbol */ TODO
	}
	resolveAlias := func(symbol Symbol) Symbol {
		Debug.assert((symbol.flags&SymbolFlagsAlias) != 0, "Should only get Alias here.")
		links := getSymbolLinks(symbol)
		if !links.aliasTarget {
			links.aliasTarget = resolvingSymbol
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				return Debug.fail()
			}
			target := getTargetOfAliasDeclaration(node)
			if links.aliasTarget == resolvingSymbol {
				links.aliasTarget = target || unknownSymbol
			} else {
				error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol))
			}
		} else if links.aliasTarget == resolvingSymbol {
			links.aliasTarget = unknownSymbol
		}
		return links.aliasTarget
	}
	tryResolveAlias := func(symbol Symbol) *Symbol {
		links := getSymbolLinks(symbol)
		if links.aliasTarget != resolvingSymbol {
			return resolveAlias(symbol)
		}
		return nil
	}
	getSymbolFlags := func(symbol Symbol, excludeTypeOnlyMeanings bool, excludeLocalMeanings bool) SymbolFlags {
		typeOnlyDeclaration := excludeTypeOnlyMeanings && getTypeOnlyAliasDeclaration(symbol)
		typeOnlyDeclarationIsExportStar := typeOnlyDeclaration && isExportDeclaration(typeOnlyDeclaration)
		typeOnlyResolution := typeOnlyDeclaration && ( /* TODO(ConditionalExpression): typeOnlyDeclarationIsExportStar                 ? resolveExternalModuleName(typeOnlyDeclaration.moduleSpecifier, typeOnlyDeclaration.moduleSpecifier, /*ignoreErrors* / true)                 : resolveAlias(typeOnlyDeclaration.symbol) */ TODO)
		typeOnlyExportStarTargets := /* TODO(ConditionalExpression): typeOnlyDeclarationIsExportStar && typeOnlyResolution ? getExportsOfModule(typeOnlyResolution) : undefined */ TODO
		flags := /* TODO(ConditionalExpression): excludeLocalMeanings ? SymbolFlags.None : symbol.flags */ TODO
		var seenSymbols TODO
		for symbol.flags & SymbolFlagsAlias {
			target := getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol))
			if !typeOnlyDeclarationIsExportStar && target == typeOnlyResolution || typeOnlyExportStarTargets.get(target.escapedName) == target {
				break
			}
			if target == unknownSymbol {
				return SymbolFlagsAll
			}
			if target == symbol || seenSymbols.has(target) {
				break
			}
			if target.flags & SymbolFlagsAlias {
				if seenSymbols {
					seenSymbols.add(target)
				} else {
					seenSymbols = /* TODO(NewExpression): new Set([symbol, target]) */ TODO
				}
			}
			flags |= target.flags
			symbol = target
		}
		return flags
	}
	markSymbolOfAliasDeclarationIfTypeOnly := func(aliasDeclaration Declaration, immediateTarget *Symbol, finalTarget *Symbol, overwriteEmpty bool, exportStarDeclaration /* TODO(IntersectionType): ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */ any, exportStarName __String) bool {
		if !aliasDeclaration || isPropertyAccessExpression(aliasDeclaration) {
			return false
		}
		sourceSymbol := getSymbolOfDeclaration(aliasDeclaration)
		if isTypeOnlyImportOrExportDeclaration(aliasDeclaration) {
			links := getSymbolLinks(sourceSymbol)
			links.typeOnlyDeclaration = aliasDeclaration
			return true
		}
		if exportStarDeclaration {
			links := getSymbolLinks(sourceSymbol)
			links.typeOnlyDeclaration = exportStarDeclaration
			if sourceSymbol.escapedName != exportStarName {
				links.typeOnlyExportStarName = exportStarName
			}
			return true
		}
		links := getSymbolLinks(sourceSymbol)
		return markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, immediateTarget, overwriteEmpty) || markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, finalTarget, overwriteEmpty)
	}
	markSymbolOfAliasDeclarationIfTypeOnlyWorker := func(aliasDeclarationLinks SymbolLinks, target *Symbol, overwriteEmpty bool) bool {
		if target && (aliasDeclarationLinks.typeOnlyDeclaration == nil || overwriteEmpty && aliasDeclarationLinks.typeOnlyDeclaration == false) {
			exportSymbol := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): target.exports?.get(InternalSymbolName.ExportEquals) ?? target */ TODO
			typeOnly := exportSymbol.declarations && find(exportSymbol.declarations, isTypeOnlyImportOrExportDeclaration)
			aliasDeclarationLinks.typeOnlyDeclaration = /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): typeOnly ?? getSymbolLinks(exportSymbol).typeOnlyDeclaration ?? false */ TODO
		}
		return !!aliasDeclarationLinks.typeOnlyDeclaration
	}
	getTypeOnlyAliasDeclaration := func(symbol Symbol, include SymbolFlags) *TypeOnlyAliasDeclaration {
		if !(symbol.flags & SymbolFlagsAlias) {
			return nil
		}
		links := getSymbolLinks(symbol)
		if links.typeOnlyDeclaration == nil {
			links.typeOnlyDeclaration = false
			resolved := resolveSymbol(symbol)
			markSymbolOfAliasDeclarationIfTypeOnly( /* TODO(ElementAccessExpression): symbol.declarations?.[0] */ TODO, getDeclarationOfAliasSymbol(symbol) && getImmediateAliasedSymbol(symbol), resolved, true)
		}
		if include == nil {
			return links.typeOnlyDeclaration || nil
		}
		if links.typeOnlyDeclaration {
			resolved := /* TODO(ConditionalExpression): links.typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration                 ? resolveSymbol(getExportsOfModule(links.typeOnlyDeclaration.symbol.parent!).get(links.typeOnlyExportStarName || symbol.escapedName))!                 : resolveAlias(links.typeOnlyDeclaration.symbol) */ TODO
			return /* TODO(ConditionalExpression): getSymbolFlags(resolved) & include ? links.typeOnlyDeclaration : undefined */ TODO
		}
		return nil
	}
	getSymbolOfPartOfRightHandSideOfImportEquals := func(entityName EntityName, dontResolveAlias bool) *Symbol {
		if entityName.kind == SyntaxKindIdentifier && isRightSideOfQualifiedNameOrPropertyAccess(entityName) {
			entityName = entityName.parent
		}
		if entityName.kind == SyntaxKindIdentifier || entityName.parent.kind == SyntaxKindQualifiedName {
			return resolveEntityName(entityName, SymbolFlagsNamespace, false, dontResolveAlias)
		} else {
			Debug.assert(entityName.parent.kind == SyntaxKindImportEqualsDeclaration)
			return resolveEntityName(entityName, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, false, dontResolveAlias)
		}
	}
	getFullyQualifiedName := func(symbol Symbol, containingLocation Node) string {
		return /* TODO(ConditionalExpression): symbol.parent ? getFullyQualifiedName(symbol.parent, containingLocation) + "." + symbolToString(symbol) : symbolToString(symbol, containingLocation, /*meaning* / undefined, SymbolFormatFlags.DoNotIncludeSymbolChain | SymbolFormatFlags.AllowAnyNodeKind) */ TODO
	}
	getContainingQualifiedNameNode := func(node QualifiedName) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").QualifiedName */ TODO {
		for isQualifiedName(node.parent) {
			node = node.parent
		}
		return node
	}
	tryGetQualifiedNameAsValue := func(node QualifiedName) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		var left /* TODO(UnionType): Identifier | QualifiedName */ any = getFirstIdentifier(node)
		symbol := resolveName(left, left, SymbolFlagsValue, nil, true)
		if !symbol {
			return nil
		}
		for isQualifiedName(left.parent) {
			type_ := getTypeOfSymbol(symbol)
			symbol = getPropertyOfType(type_, left.parent.right.escapedText)
			if !symbol {
				return nil
			}
			left = left.parent
		}
		return symbol
	}
	resolveEntityName := func(name EntityNameOrEntityNameExpression, meaning SymbolFlags, ignoreErrors bool, dontResolveAlias bool, location Node) *Symbol {
		if nodeIsMissing(name) {
			return nil
		}
		namespaceMeaning := SymbolFlagsNamespace | ( /* TODO(ConditionalExpression): isInJSFile(name) ? meaning & SymbolFlags.Value : 0 */ TODO)
		var symbol *Symbol
		if name.kind == SyntaxKindIdentifier {
			message := /* TODO(ConditionalExpression): meaning === namespaceMeaning || nodeIsSynthesized(name) ? Diagnostics.Cannot_find_namespace_0 : getCannotFindNameDiagnosticForName(getFirstIdentifier(name)) */ TODO
			symbolFromJSPrototype := /* TODO(ConditionalExpression): isInJSFile(name) && !nodeIsSynthesized(name) ? resolveEntityNameFromAssignmentDeclaration(name, meaning) : undefined */ TODO
			symbol = getMergedSymbol(resolveName(location || name, name, meaning /* TODO(ConditionalExpression): ignoreErrors || symbolFromJSPrototype ? undefined : message */, TODO, true, false))
			if !symbol {
				return getMergedSymbol(symbolFromJSPrototype)
			}
		} else if name.kind == SyntaxKindQualifiedName || name.kind == SyntaxKindPropertyAccessExpression {
			left := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.left : name.expression */ TODO
			right := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.right : name.name */ TODO
			namespace := resolveEntityName(left, namespaceMeaning, ignoreErrors, false, location)
			if !namespace || nodeIsMissing(right) {
				return nil
			} else if namespace == unknownSymbol {
				return namespace
			}
			if namespace.valueDeclaration && isInJSFile(namespace.valueDeclaration) && getEmitModuleResolutionKind(compilerOptions) != ModuleResolutionKindBundler && isVariableDeclaration(namespace.valueDeclaration) && namespace.valueDeclaration.initializer && isCommonJsRequire(namespace.valueDeclaration.initializer) {
				moduleName := /* TODO(ElementAccessExpression): (namespace.valueDeclaration.initializer as CallExpression).arguments[0] */ TODO
				moduleSym := resolveExternalModuleName(moduleName, moduleName)
				if moduleSym {
					resolvedModuleSymbol := resolveExternalModuleSymbol(moduleSym)
					if resolvedModuleSymbol {
						namespace = resolvedModuleSymbol
					}
				}
			}
			symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, meaning))
			if !symbol && (namespace.flags & SymbolFlagsAlias) {
				symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(resolveAlias(namespace)), right.escapedText, meaning))
			}
			if !symbol {
				if !ignoreErrors {
					namespaceName := getFullyQualifiedName(namespace)
					declarationName := declarationNameToString(right)
					suggestionForNonexistentModule := getSuggestedSymbolForNonexistentModule(right, namespace)
					if suggestionForNonexistentModule {
						error(right, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, namespaceName, declarationName, symbolToString(suggestionForNonexistentModule))
						return nil
					}
					containingQualifiedName := isQualifiedName(name) && getContainingQualifiedNameNode(name)
					canSuggestTypeof := globalObjectType && (meaning & SymbolFlagsType) && containingQualifiedName && !isTypeOfExpression(containingQualifiedName.parent) && tryGetQualifiedNameAsValue(containingQualifiedName)
					if canSuggestTypeof {
						error(containingQualifiedName, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, entityNameToString(containingQualifiedName))
						return nil
					}
					if meaning&SymbolFlagsNamespace && isQualifiedName(name.parent) {
						exportedTypeSymbol := getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, SymbolFlagsType))
						if exportedTypeSymbol {
							error(name.parent.right, Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, symbolToString(exportedTypeSymbol), unescapeLeadingUnderscores(name.parent.right.escapedText))
							return nil
						}
					}
					error(right, Diagnostics.Namespace_0_has_no_exported_member_1, namespaceName, declarationName)
				}
				return nil
			}
		} else {
			Debug.assertNever(name, "Unknown entity name kind.")
		}
		if !nodeIsSynthesized(name) && isEntityName(name) && (symbol.flags&SymbolFlagsAlias || name.parent.kind == SyntaxKindExportAssignment) {
			markSymbolOfAliasDeclarationIfTypeOnly(getAliasDeclarationFromName(name), symbol, nil, true)
		}
		return /* TODO(ConditionalExpression): (symbol.flags & meaning) || dontResolveAlias ? symbol : resolveAlias(symbol) */ TODO
	}
	resolveEntityNameFromAssignmentDeclaration := func(name Identifier, meaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if isJSDocTypeReference(name.parent) {
			secondaryLocation := getAssignmentDeclarationLocation(name.parent)
			if secondaryLocation {
				return resolveName(secondaryLocation, name, meaning, nil, true)
			}
		}
	}
	getAssignmentDeclarationLocation := func(node TypeReferenceNode) Node {
		typeAlias := findAncestor(node, func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
			return /* TODO(ConditionalExpression): !(isJSDocNode(node) || node.flags & NodeFlags.JSDoc) ? "quit" : isJSDocTypeAlias(node) */ TODO
		})
		if typeAlias {
			return
		}
		host := getJSDocHost(node)
		if host && isExpressionStatement(host) && isPrototypePropertyAssignment(host.expression) {
			symbol := getSymbolOfDeclaration(host.expression.left)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		if host && isFunctionExpression(host) && isPrototypePropertyAssignment(host.parent) && isExpressionStatement(host.parent.parent) {
			symbol := getSymbolOfDeclaration(host.parent.left)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		if host && (isObjectLiteralMethod(host) || isPropertyAssignment(host)) && isBinaryExpression(host.parent.parent) && getAssignmentDeclarationKind(host.parent.parent) == AssignmentDeclarationKindPrototype {
			symbol := getSymbolOfDeclaration(host.parent.parent.left)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		sig := getEffectiveJSDocHost(node)
		if sig && isFunctionLike(sig) {
			symbol := getSymbolOfDeclaration(sig)
			return symbol && symbol.valueDeclaration
		}
	}
	getDeclarationOfJSPrototypeContainer := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration | undefined */ TODO {
		decl := symbol.parent.valueDeclaration
		if !decl {
			return nil
		}
		initializer := /* TODO(ConditionalExpression): isAssignmentDeclaration(decl) ? getAssignedExpandoInitializer(decl) :             hasOnlyExpressionInitializer(decl) ? getDeclaredExpandoInitializer(decl) :             undefined */ TODO
		return initializer || decl
	}
	getExpandoSymbol := func(symbol Symbol) *Symbol {
		decl := symbol.valueDeclaration
		if !decl || !isInJSFile(decl) || symbol.flags&SymbolFlagsTypeAlias || getExpandoInitializer(decl, false) {
			return nil
		}
		init := /* TODO(ConditionalExpression): isVariableDeclaration(decl) ? getDeclaredExpandoInitializer(decl) : getAssignedExpandoInitializer(decl) */ TODO
		if init {
			initSymbol := getSymbolOfNode(init)
			if initSymbol {
				return mergeJSSymbols(initSymbol, symbol)
			}
		}
	}
	resolveExternalModuleName := func(location Node, moduleReferenceExpression Expression, ignoreErrors bool) *Symbol {
		isClassic := getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindClassic
		errorMessage := /* TODO(ConditionalExpression): isClassic ?             Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option             : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations */ TODO
		return resolveExternalModuleNameWorker(location, moduleReferenceExpression /* TODO(ConditionalExpression): ignoreErrors ? undefined : errorMessage */, TODO, ignoreErrors)
	}
	resolveExternalModuleNameWorker := func(location Node, moduleReferenceExpression Expression, moduleNotFoundError *DiagnosticMessage, ignoreErrors /* TODO inferred type boolean */ TODO /*  = false */, isForAugmentation /* TODO inferred type boolean */ TODO /*  = false */) *Symbol {
		return /* TODO(ConditionalExpression): isStringLiteralLike(moduleReferenceExpression)             ? resolveExternalModule(location, moduleReferenceExpression.text, moduleNotFoundError, !ignoreErrors ? moduleReferenceExpression : undefined, isForAugmentation)             : undefined */ TODO
	}
	resolveExternalModule := func(location Node, moduleReference string, moduleNotFoundError *DiagnosticMessage, errorNode Node, isForAugmentation /* TODO inferred type boolean */ TODO /*  = false */) *Symbol {
		if errorNode && startsWith(moduleReference, "@types/") {
			diag := Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1
			withoutAtTypePrefix := removePrefix(moduleReference, "@types/")
			error(errorNode, diag, withoutAtTypePrefix, moduleReference)
		}
		ambientModule := tryFindAmbientModule(moduleReference, true)
		if ambientModule {
			return ambientModule
		}
		currentSourceFile := getSourceFileOfNode(location)
		contextSpecifier := /* TODO(ConditionalExpression): isStringLiteralLike(location)             ? location             : (isModuleDeclaration(location) ? location : location.parent && isModuleDeclaration(location.parent) && location.parent.name === location ? location.parent : undefined)?.name ||                 (isLiteralImportTypeNode(location) ? location : undefined)?.argument.literal ||                 (isInJSFile(location) && isJSDocImportTag(location) ? location.moduleSpecifier : undefined) ||                 (isVariableDeclaration(location) && location.initializer && isRequireCall(location.initializer, /*requireStringLiteralLikeArgument* / true) ? location.initializer.arguments[0] : undefined) ||                 findAncestor(location, isImportCall)?.arguments[0] ||                 findAncestor(location, isImportDeclaration)?.moduleSpecifier ||                 findAncestor(location, isExternalModuleImportEqualsDeclaration)?.moduleReference.expression ||                 findAncestor(location, isExportDeclaration)?.moduleSpecifier */ TODO
		mode := /* TODO(ConditionalExpression): contextSpecifier && isStringLiteralLike(contextSpecifier)             ? host.getModeForUsageLocation(currentSourceFile, contextSpecifier)             : host.getDefaultResolutionModeForFile(currentSourceFile) */ TODO
		moduleResolutionKind := getEmitModuleResolutionKind(compilerOptions)
		resolvedModule := host.getResolvedModule(currentSourceFile, moduleReference, mode).resolvedModule
		resolutionDiagnostic := errorNode && resolvedModule && getResolutionDiagnostic(compilerOptions, resolvedModule, currentSourceFile)
		sourceFile := resolvedModule && (!resolutionDiagnostic || resolutionDiagnostic == Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set) && host.getSourceFile(resolvedModule.resolvedFileName)
		if sourceFile {
			if resolutionDiagnostic {
				error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName)
			}
			if resolvedModule.resolvedUsingTsExtension && isDeclarationFileName(moduleReference) {
				importOrExport := findAncestor(location, isImportDeclaration).importClause || findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration))
				if errorNode && importOrExport && !importOrExport.isTypeOnly || findAncestor(location, isImportCall) {
					error(errorNode, Diagnostics.A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_file_0_instead, getSuggestedImportSource(Debug.checkDefined(tryExtractTSExtension(moduleReference))))
				}
			} else if resolvedModule.resolvedUsingTsExtension && !shouldAllowImportingTsExtension(compilerOptions, currentSourceFile.fileName) {
				importOrExport := findAncestor(location, isImportDeclaration).importClause || findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration))
				if errorNode && !(importOrExport.isTypeOnly || findAncestor(location, isImportTypeNode)) {
					tsExtension := Debug.checkDefined(tryExtractTSExtension(moduleReference))
					error(errorNode, Diagnostics.An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled, tsExtension)
				}
			}
			if sourceFile.symbol {
				if errorNode && resolvedModule.isExternalLibraryImport && !resolutionExtensionIsTSOrJson(resolvedModule.extension) {
					errorOnImplicitAnyModule(false, errorNode, currentSourceFile, mode, resolvedModule, moduleReference)
				}
				if errorNode && (moduleResolutionKind == ModuleResolutionKindNode16 || moduleResolutionKind == ModuleResolutionKindNodeNext) {
					isSyncImport := (currentSourceFile.impliedNodeFormat == ModuleKindCommonJS && !findAncestor(location, isImportCall)) || !!findAncestor(location, isImportEqualsDeclaration)
					overrideHost := findAncestor(location, func(l /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
						return isImportTypeNode(l) || isExportDeclaration(l) || isImportDeclaration(l) || isJSDocImportTag(l)
					})
					if isSyncImport && sourceFile.impliedNodeFormat == ModuleKindESNext && !hasResolutionModeOverride(overrideHost) {
						if findAncestor(location, isImportEqualsDeclaration) {
							error(errorNode, Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead, moduleReference)
						} else {
							var diagnosticDetails TODO
							ext := tryGetExtensionFromPath(currentSourceFile.fileName)
							if ext == ExtensionTs || ext == ExtensionJs || ext == ExtensionTsx || ext == ExtensionJsx {
								diagnosticDetails = createModeMismatchDetails(currentSourceFile)
							}
							diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chainDiagnosticMessages(diagnosticDetails, Diagnostics.The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead, moduleReference)))
						}
					}
				}
				return getMergedSymbol(sourceFile.symbol)
			}
			if errorNode && moduleNotFoundError && !isSideEffectImport(errorNode) {
				error(errorNode, Diagnostics.File_0_is_not_a_module, sourceFile.fileName)
			}
			return nil
		}
		if patternAmbientModules {
			pattern := findBestPatternMatch(patternAmbientModules, func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").PatternAmbientModule */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/core").Pattern */ TODO {
				return _.pattern
			}, moduleReference)
			if pattern {
				augmentation := patternAmbientModuleAugmentations && patternAmbientModuleAugmentations.get(moduleReference)
				if augmentation {
					return getMergedSymbol(augmentation)
				}
				return getMergedSymbol(pattern.symbol)
			}
		}
		if !errorNode {
			return nil
		}
		if resolvedModule && !resolutionExtensionIsTSOrJson(resolvedModule.extension) && resolutionDiagnostic == nil || resolutionDiagnostic == Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type {
			if isForAugmentation {
				diag := Diagnostics.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented
				error(errorNode, diag, moduleReference, resolvedModule.resolvedFileName)
			} else {
				errorOnImplicitAnyModule(noImplicitAny && !!moduleNotFoundError, errorNode, currentSourceFile, mode, resolvedModule, moduleReference)
			}
			return nil
		}
		if moduleNotFoundError {
			if resolvedModule {
				redirect := host.getProjectReferenceRedirect(resolvedModule.resolvedFileName)
				if redirect {
					error(errorNode, Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect, resolvedModule.resolvedFileName)
					return nil
				}
			}
			if resolutionDiagnostic {
				error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName)
			} else {
				isExtensionlessRelativePathImport := pathIsRelative(moduleReference) && !hasExtension(moduleReference)
				resolutionIsNode16OrNext := moduleResolutionKind == ModuleResolutionKindNode16 || moduleResolutionKind == ModuleResolutionKindNodeNext
				if !getResolveJsonModule(compilerOptions) && fileExtensionIs(moduleReference, ExtensionJson) && moduleResolutionKind != ModuleResolutionKindClassic && hasJsonModuleEmitEnabled(compilerOptions) {
					error(errorNode, Diagnostics.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension, moduleReference)
				} else if mode == ModuleKindESNext && resolutionIsNode16OrNext && isExtensionlessRelativePathImport {
					absoluteRef := getNormalizedAbsolutePath(moduleReference, getDirectoryPath(currentSourceFile.path))
					suggestedExt := /* TODO(ElementAccessExpression): suggestedExtensions.find(([actualExt, _importExt]) => host.fileExists(absoluteRef + actualExt))?.[1] */ TODO
					if suggestedExt {
						error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0 /* TODO(PlusToken): + */ /* TODO(BinaryExpression): moduleReference + suggestedExt */, TODO)
					} else {
						error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path)
					}
				} else {
					if host.getResolvedModule(currentSourceFile, moduleReference, mode).alternateResult {
						errorInfo := createModuleNotFoundChain(currentSourceFile, host, moduleReference, mode, moduleReference)
						errorOrSuggestion(true, errorNode, chainDiagnosticMessages(errorInfo, moduleNotFoundError, moduleReference))
					} else {
						error(errorNode, moduleNotFoundError, moduleReference)
					}
				}
			}
		}
		return nil
		getSuggestedImportSource := func(tsExtension string) /* TODO inferred type string */ TODO {
			importSourceWithoutExtension := removeExtension(moduleReference, tsExtension)
			if emitModuleKindIsNonNodeESM(moduleKind) || mode == ModuleKindESNext {
				preferTs := isDeclarationFileName(moduleReference) && shouldAllowImportingTsExtension(compilerOptions)
				ext := /* TODO(ConditionalExpression): tsExtension === Extension.Mts || tsExtension === Extension.Dmts ? preferTs ? ".mts" : ".mjs" :                     tsExtension === Extension.Cts || tsExtension === Extension.Dmts ? preferTs ? ".cts" : ".cjs" :                     preferTs ? ".ts" : ".js" */ TODO
				return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): importSourceWithoutExtension + ext */ TODO
			}
			return importSourceWithoutExtension
		}
	}
	errorOnImplicitAnyModule := func(isError bool, errorNode Node, sourceFile SourceFile, mode ResolutionMode, TODO_IDENTIFIER ResolvedModuleFull, moduleReference string) {
		if isSideEffectImport(errorNode) {
			return
		}
		var errorInfo *DiagnosticMessageChain
		if !isExternalModuleNameRelative(moduleReference) && packageId {
			errorInfo = createModuleNotFoundChain(sourceFile, host, moduleReference, mode, packageId.name)
		}
		errorOrSuggestion(isError, errorNode, chainDiagnosticMessages(errorInfo, Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type, moduleReference, resolvedFileName))
	}
	// OVERLOAD: resolveExternalModuleSymbol := func(moduleSymbol Symbol, dontResolveAlias bool) Symbol
	// OVERLOAD: resolveExternalModuleSymbol := func(moduleSymbol *Symbol, dontResolveAlias bool) *Symbol
	resolveExternalModuleSymbol := func(moduleSymbol *Symbol, dontResolveAlias bool) *Symbol {
		if moduleSymbol.exports {
			exportEquals := resolveSymbol(moduleSymbol.exports.get(InternalSymbolNameExportEquals), dontResolveAlias)
			exported := getCommonJsExportEquals(getMergedSymbol(exportEquals), getMergedSymbol(moduleSymbol))
			return getMergedSymbol(exported) || moduleSymbol
		}
		return nil
	}
	getCommonJsExportEquals := func(exported *Symbol, moduleSymbol Symbol) *Symbol {
		if !exported || exported == unknownSymbol || exported == moduleSymbol || moduleSymbol.exports.size == 1 || exported.flags&SymbolFlagsAlias {
			return exported
		}
		links := getSymbolLinks(exported)
		if links.cjsExportMerged {
			return links.cjsExportMerged
		}
		merged := /* TODO(ConditionalExpression): exported.flags & SymbolFlags.Transient ? exported : cloneSymbol(exported) */ TODO
		merged.flags = merged.flags | SymbolFlagsValueModule
		if merged.exports == nil {
			merged.exports = createSymbolTable()
		}
		moduleSymbol.exports.forEach(func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
			if name == InternalSymbolNameExportEquals {
				return
			}
			merged.exports.set(name /* TODO(ConditionalExpression): merged.exports!.has(name) ? mergeSymbol(merged.exports!.get(name)!, s) : s */, TODO)
		})
		if merged == exported {
			getSymbolLinks(merged).resolvedExports = nil
			getSymbolLinks(merged).resolvedMembers = nil
		}
		getSymbolLinks(merged).cjsExportMerged = merged
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.cjsExportMerged = merged */ TODO
	}
	resolveESModuleSymbol := func(moduleSymbol *Symbol, referencingLocation Node, dontResolveAlias bool, suppressInteropError bool) *Symbol {
		symbol := resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias)
		if !dontResolveAlias && symbol {
			if !suppressInteropError && !(symbol.flags & (SymbolFlagsModule | SymbolFlagsVariable)) && !getDeclarationOfKind(symbol, SyntaxKindSourceFile) {
				compilerOptionName := /* TODO(ConditionalExpression): moduleKind >= ModuleKind.ES2015                     ? "allowSyntheticDefaultImports"                     : "esModuleInterop" */ TODO
				error(referencingLocation, Diagnostics.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export, compilerOptionName)
				return symbol
			}
			referenceParent := referencingLocation.parent
			if (isImportDeclaration(referenceParent) && getNamespaceDeclarationNode(referenceParent)) || isImportCall(referenceParent) {
				reference := /* TODO(ConditionalExpression): isImportCall(referenceParent) ? referenceParent.arguments[0] : referenceParent.moduleSpecifier */ TODO
				type_ := getTypeOfSymbol(symbol)
				defaultOnlyType := getTypeWithSyntheticDefaultOnly(type_, symbol, moduleSymbol, reference)
				if defaultOnlyType {
					return cloneTypeAsModuleType(symbol, defaultOnlyType, referenceParent)
				}
				targetFile := moduleSymbol.declarations.find(isSourceFile)
				isEsmCjsRef := targetFile && isESMFormatImportImportingCommonjsFormatFile(getEmitSyntaxForModuleSpecifierExpression(reference), host.getImpliedNodeFormatForEmit(targetFile))
				if getESModuleInterop(compilerOptions) || isEsmCjsRef {
					sigs := getSignaturesOfStructuredType(type_, SignatureKindCall)
					if !sigs || !sigs.length {
						sigs = getSignaturesOfStructuredType(type_, SignatureKindConstruct)
					}
					if (sigs && sigs.length) || getPropertyOfType(type_, InternalSymbolNameDefault, true) || isEsmCjsRef {
						moduleType := /* TODO(ConditionalExpression): type.flags & TypeFlags.StructuredType                             ? getTypeWithSyntheticDefaultImportType(type, symbol, moduleSymbol!, reference)                             : createDefaultPropertyWrapperForModule(symbol, symbol.parent) */ TODO
						return cloneTypeAsModuleType(symbol, moduleType, referenceParent)
					}
				}
			}
		}
		return symbol
	}
	cloneTypeAsModuleType := func(symbol Symbol, moduleType Type, referenceParent /* TODO(UnionType): ImportDeclaration | ImportCall */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		result := createSymbol(symbol.flags, symbol.escapedName)
		result.declarations = /* TODO(ConditionalExpression): symbol.declarations ? symbol.declarations.slice() : [] */ TODO
		result.parent = symbol.parent
		result.links.target = symbol
		result.links.originatingImport = referenceParent
		if symbol.valueDeclaration {
			result.valueDeclaration = symbol.valueDeclaration
		}
		if symbol.constEnumOnlyModule {
			result.constEnumOnlyModule = true
		}
		if symbol.members {
			result.members = /* TODO(NewExpression): new Map(symbol.members) */ TODO
		}
		if symbol.exports {
			result.exports = /* TODO(NewExpression): new Map(symbol.exports) */ TODO
		}
		resolvedModuleType := resolveStructuredTypeMembers(moduleType)
		result.links.type_ = createAnonymousType(result, resolvedModuleType.members, emptyArray, emptyArray, resolvedModuleType.indexInfos)
		return result
	}
	hasExportAssignmentSymbol := func(moduleSymbol Symbol) bool {
		return moduleSymbol.exports.get(InternalSymbolNameExportEquals) != nil
	}
	getExportsOfModuleAsArray := func(moduleSymbol Symbol) []Symbol {
		return symbolsToArray(getExportsOfModule(moduleSymbol))
	}
	getExportsAndPropertiesOfModule := func(moduleSymbol Symbol) []Symbol {
		exports := getExportsOfModuleAsArray(moduleSymbol)
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if exportEquals != moduleSymbol {
			type_ := getTypeOfSymbol(exportEquals)
			if shouldTreatPropertiesOfExternalModuleAsExports(type_) {
				addRange(exports, getPropertiesOfType(type_))
			}
		}
		return exports
	}
	forEachExportAndPropertyOfModule := func(moduleSymbol Symbol, cb func(symbol Symbol, key __String)) {
		exports := getExportsOfModule(moduleSymbol)
		exports.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, key /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
			if !isReservedMemberName(key) {
				cb(symbol, key)
			}
		})
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if exportEquals != moduleSymbol {
			type_ := getTypeOfSymbol(exportEquals)
			if shouldTreatPropertiesOfExternalModuleAsExports(type_) {
				forEachPropertyOfType(type_, func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, escapedName /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
					cb(symbol, escapedName)
				})
			}
		}
	}
	tryGetMemberInModuleExports := func(memberName __String, moduleSymbol Symbol) *Symbol {
		symbolTable := getExportsOfModule(moduleSymbol)
		if symbolTable {
			return symbolTable.get(memberName)
		}
	}
	tryGetMemberInModuleExportsAndProperties := func(memberName __String, moduleSymbol Symbol) *Symbol {
		symbol := tryGetMemberInModuleExports(memberName, moduleSymbol)
		if symbol {
			return symbol
		}
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if exportEquals == moduleSymbol {
			return nil
		}
		type_ := getTypeOfSymbol(exportEquals)
		return /* TODO(ConditionalExpression): shouldTreatPropertiesOfExternalModuleAsExports(type) ? getPropertyOfType(type, memberName) : undefined */ TODO
	}
	shouldTreatPropertiesOfExternalModuleAsExports := func(resolvedExternalModuleType Type) /* TODO inferred type boolean */ TODO {
		return !(resolvedExternalModuleType.flags&TypeFlagsPrimitive || getObjectFlags(resolvedExternalModuleType)&ObjectFlagsClass || isArrayType(resolvedExternalModuleType) || isTupleType(resolvedExternalModuleType))
	}
	getExportsOfSymbol := func(symbol Symbol) SymbolTable {
		return /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.LateBindingContainer ? getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKind.resolvedExports) :             symbol.flags & SymbolFlags.Module ? getExportsOfModule(symbol) :             symbol.exports || emptySymbols */ TODO
	}
	getExportsOfModule := func(moduleSymbol Symbol) SymbolTable {
		links := getSymbolLinks(moduleSymbol)
		if !links.resolvedExports {
			TODO_IDENTIFIER := getExportsOfModuleWorker(moduleSymbol)
			links.resolvedExports = exports
			links.typeOnlyExportStarMap = typeOnlyExportStarMap
		}
		return links.resolvedExports
	}
	type ExportCollisionTracker struct {
		specifierText        string
		exportsWithDuplicate []ExportDeclaration
	}
	type ExportCollisionTrackerTable Map[__String, ExportCollisionTracker]
	extendExportSymbols := func(target SymbolTable, source *SymbolTable, lookupTable ExportCollisionTrackerTable, exportNode ExportDeclaration) {
		if !source {
			return
		}
		source.forEach(func(sourceSymbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
			if id == InternalSymbolNameDefault {
				return
			}
			targetSymbol := target.get(id)
			if !targetSymbol {
				target.set(id, sourceSymbol)
				if lookupTable && exportNode {
					lookupTable.set(id /* TODO(ObjectLiteralExpression): {                         specifierText: getTextOfNode(exportNode.moduleSpecifier!),                     } */, TODO)
				}
			} else if lookupTable && exportNode && targetSymbol && resolveSymbol(targetSymbol) != resolveSymbol(sourceSymbol) {
				collisionTracker := lookupTable.get(id)
				if !collisionTracker.exportsWithDuplicate {
					collisionTracker.exportsWithDuplicate = /* TODO(ArrayLiteralExpression): [exportNode] */ TODO
				} else {
					collisionTracker.exportsWithDuplicate.push(exportNode)
				}
			}
		})
	}
	getExportsOfModuleWorker := func(moduleSymbol Symbol) /* TODO inferred type { exports: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable; typeOnlyExportStarMap: Map<import("/home/jabaile/work/TypeScript/src/compiler/types").__String, import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; }> | undefined; } */ TODO {
		var visitedSymbols []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		var typeOnlyExportStarMap *Map[__String /* TODO(IntersectionType): ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */, any]
		nonTypeOnlyNames := make(map[__String]struct{})
		moduleSymbol = resolveExternalModuleSymbol(moduleSymbol)
		exports := visit(moduleSymbol) || emptySymbols
		if typeOnlyExportStarMap {
			nonTypeOnlyNames.forEach(func(name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) /* TODO inferred type boolean */ TODO {
				return typeOnlyExportStarMap.delete(name)
			})
		}
		return /* TODO(ObjectLiteralExpression): {             exports,             typeOnlyExportStarMap,         } */ TODO
		visit := func(symbol *Symbol, exportStar ExportDeclaration, isTypeOnly bool) *SymbolTable {
			if !isTypeOnly && symbol.exports {
				symbol.exports.forEach(func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) /* TODO inferred type Set<import("/home/jabaile/work/TypeScript/src/compiler/types").__String> */ TODO {
					return nonTypeOnlyNames.add(name)
				})
			}
			if !(symbol && symbol.exports && pushIfUnique(visitedSymbols, symbol)) {
				return
			}
			symbols := /* TODO(NewExpression): new Map(symbol.exports) */ TODO
			exportStars := symbol.exports.get(InternalSymbolNameExportStar)
			if exportStars {
				nestedSymbols := createSymbolTable()
				var lookupTable ExportCollisionTrackerTable = /* TODO(NewExpression): new Map() */ make(map[any]any)
				if exportStars.declarations {
					for _, node := range exportStars.declarations {
						resolvedModule := resolveExternalModuleName(node, (node).moduleSpecifier)
						exportedSymbols := visit(resolvedModule, node, isTypeOnly || (node).isTypeOnly)
						extendExportSymbols(nestedSymbols, exportedSymbols, lookupTable, node)
					}
				}
				lookupTable.forEach(func(TODO_IDENTIFIER /* TODO inferred type ExportCollisionTracker */ TODO, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
					if id == "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id) {
						return
					}
					for _, node := range exportsWithDuplicate {
						diagnostics.add(createDiagnosticForNode(node, Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity, lookupTable.get(id).specifierText, unescapeLeadingUnderscores(id)))
					}
				})
				extendExportSymbols(symbols, nestedSymbols)
			}
			if exportStar.isTypeOnly {
				/* TODO(ExpressionStatement): typeOnlyExportStarMap ??= new Map(); */
				symbols.forEach(func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, escapedName /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) /* TODO inferred type Map<import("/home/jabaile/work/TypeScript/src/compiler/types").__String, import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; }> */ TODO {
					return typeOnlyExportStarMap.set(escapedName, exportStar)
				})
			}
			return symbols
		}
	}
	// OVERLOAD: getMergedSymbol := func(symbol Symbol) Symbol
	// OVERLOAD: getMergedSymbol := func(symbol *Symbol) *Symbol
	getMergedSymbol := func(symbol *Symbol) *Symbol {
		var merged Symbol
		return /* TODO(ConditionalExpression): symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol */ TODO
	}
	getSymbolOfDeclaration := func(node Declaration) Symbol {
		return getMergedSymbol(node.symbol && getLateBoundSymbol(node.symbol))
	}
	getSymbolOfNode := func(node Node) *Symbol {
		return /* TODO(ConditionalExpression): canHaveSymbol(node) ? getSymbolOfDeclaration(node) : undefined */ TODO
	}
	getParentOfSymbol := func(symbol Symbol) *Symbol {
		return getMergedSymbol(symbol.parent && getLateBoundSymbol(symbol.parent))
	}
	getFunctionExpressionParentSymbolOrSymbol := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		return /* TODO(ConditionalExpression): symbol.valueDeclaration?.kind === SyntaxKind.ArrowFunction || symbol.valueDeclaration?.kind === SyntaxKind.FunctionExpression             ? getSymbolOfNode(symbol.valueDeclaration.parent) || symbol             : symbol */ TODO
	}
	getAlternativeContainingModules := func(symbol Symbol, enclosingDeclaration Node) []Symbol {
		containingFile := getSourceFileOfNode(enclosingDeclaration)
		id := getNodeId(containingFile)
		links := getSymbolLinks(symbol)
		var results /* TODO(ArrayType): Symbol[] */ any
		if links.extendedContainersByFile && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): results = links.extendedContainersByFile.get(id) */ TODO) {
			return results
		}
		if containingFile && containingFile.imports {
			for _, importRef := range containingFile.imports {
				if nodeIsSynthesized(importRef) {
					continue
				}
				resolvedModule := resolveExternalModuleName(enclosingDeclaration, importRef, true)
				if !resolvedModule {
					continue
				}
				ref := getAliasForSymbolInContainer(resolvedModule, symbol)
				if !ref {
					continue
				}
				results = append(results, resolvedModule)
			}
			if length(results) {
				(links.extendedContainersByFile || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.extendedContainersByFile = new Map() */ TODO)).set(id, results)
				return results
			}
		}
		if links.extendedContainers {
			return links.extendedContainers
		}
		otherFiles := host.getSourceFiles()
		for _, file := range otherFiles {
			if !isExternalModule(file) {
				continue
			}
			sym := getSymbolOfDeclaration(file)
			ref := getAliasForSymbolInContainer(sym, symbol)
			if !ref {
				continue
			}
			results = append(results, sym)
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.extendedContainers = results || emptyArray */ TODO
	}
	getContainersOfSymbol := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) /* TODO(ArrayType): Symbol[] */ any {
		container := getParentOfSymbol(symbol)
		if container && !(symbol.flags & SymbolFlagsTypeParameter) {
			return getWithAlternativeContainers(container)
		}
		candidates := mapDefined(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			if !isAmbientModule(d) && d.parent {
				if hasNonGlobalAugmentationExternalModuleSymbol(d.parent) {
					return getSymbolOfDeclaration(d.parent)
				}
				if isModuleBlock(d.parent) && d.parent.parent && resolveExternalModuleSymbol(getSymbolOfDeclaration(d.parent.parent)) == symbol {
					return getSymbolOfDeclaration(d.parent.parent)
				}
			}
			if isClassExpression(d) && isBinaryExpression(d.parent) && d.parent.operatorToken.kind == SyntaxKindEqualsToken && isAccessExpression(d.parent.left) && isEntityNameExpression(d.parent.left.expression) {
				if isModuleExportsAccessExpression(d.parent.left) || isExportsIdentifier(d.parent.left.expression) {
					return getSymbolOfDeclaration(getSourceFileOfNode(d))
				}
				checkExpressionCached(d.parent.left.expression)
				return getNodeLinks(d.parent.left.expression).resolvedSymbol
			}
		})
		if !length(candidates) {
			return nil
		}
		containers := mapDefined(candidates, func(candidate /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			return /* TODO(ConditionalExpression): getAliasForSymbolInContainer(candidate, symbol) ? candidate : undefined */ TODO
		})
		var bestContainers []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		var alternativeContainers []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, container := range containers {
			TODO_IDENTIFIER := getWithAlternativeContainers(container)
			bestContainers = append(bestContainers, bestMatch)
			alternativeContainers = addRange(alternativeContainers, rest)
		}
		return concatenate(bestContainers, alternativeContainers)
		getWithAlternativeContainers := func(container Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			additionalContainers := mapDefined(container.declarations, fileSymbolIfFileSymbolExportEqualsContainer)
			reexportContainers := enclosingDeclaration && getAlternativeContainingModules(symbol, enclosingDeclaration)
			objectLiteralContainer := getVariableDeclarationOfObjectLiteral(container, meaning)
			if enclosingDeclaration && container.flags&getQualifiedLeftMeaning(meaning) && getAccessibleSymbolChain(container, enclosingDeclaration, SymbolFlagsNamespace, false) {
				return append(concatenate(concatenate( /* TODO(ArrayLiteralExpression): [container] */ TODO, additionalContainers), reexportContainers), objectLiteralContainer)
			}
			firstVariableMatch := /* TODO(ConditionalExpression): !(container.flags & getQualifiedLeftMeaning(meaning))                     && container.flags & SymbolFlags.Type                     && getDeclaredTypeOfSymbol(container).flags & TypeFlags.Object                     && meaning === SymbolFlags.Value                 ? forEachSymbolTableInScope(enclosingDeclaration, t => {                     return forEachEntry(t, s => {                         if (s.flags & getQualifiedLeftMeaning(meaning) && getTypeOfSymbol(s) === getDeclaredTypeOfSymbol(container)) {                             return s;                         }                     });                 }) : undefined */ TODO
			res := /* TODO(ConditionalExpression): firstVariableMatch ? [firstVariableMatch, ...additionalContainers, container] : [...additionalContainers, container] */ TODO
			res = append(res, objectLiteralContainer)
			res = addRange(res, reexportContainers)
			return res
		}
		fileSymbolIfFileSymbolExportEqualsContainer := func(d Declaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			return container && getFileSymbolIfFileSymbolExportEqualsContainer(d, container)
		}
	}
	getVariableDeclarationOfObjectLiteral := func(symbol Symbol, meaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		var firstDecl /* TODO(UnionType): Node | false */ any = !!length(symbol.declarations) && first(symbol.declarations)
		if meaning&SymbolFlagsValue && firstDecl && firstDecl.parent && isVariableDeclaration(firstDecl.parent) {
			if isObjectLiteralExpression(firstDecl) && firstDecl == firstDecl.parent.initializer || isTypeLiteralNode(firstDecl) && firstDecl == firstDecl.parent.type_ {
				return getSymbolOfDeclaration(firstDecl.parent)
			}
		}
	}
	getFileSymbolIfFileSymbolExportEqualsContainer := func(d Declaration, container Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		fileSymbol := getExternalModuleContainer(d)
		exported := fileSymbol && fileSymbol.exports && fileSymbol.exports.get(InternalSymbolNameExportEquals)
		return /* TODO(ConditionalExpression): exported && getSymbolIfSameReference(exported, container) ? fileSymbol : undefined */ TODO
	}
	getAliasForSymbolInContainer := func(container Symbol, symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if container == getParentOfSymbol(symbol) {
			return symbol
		}
		exportEquals := container.exports && container.exports.get(InternalSymbolNameExportEquals)
		if exportEquals && getSymbolIfSameReference(exportEquals, symbol) {
			return container
		}
		exports := getExportsOfSymbol(container)
		quick := exports.get(symbol.escapedName)
		if quick && getSymbolIfSameReference(quick, symbol) {
			return quick
		}
		return forEachEntry(exports, func(exported /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			if getSymbolIfSameReference(exported, symbol) {
				return exported
			}
		})
	}
	getSymbolIfSameReference := func(s1 Symbol, s2 Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if getMergedSymbol(resolveSymbol(getMergedSymbol(s1))) == getMergedSymbol(resolveSymbol(getMergedSymbol(s2))) {
			return s1
		}
	}
	// OVERLOAD: getExportSymbolOfValueSymbolIfExported := func(symbol Symbol) Symbol
	// OVERLOAD: getExportSymbolOfValueSymbolIfExported := func(symbol *Symbol) *Symbol
	getExportSymbolOfValueSymbolIfExported := func(symbol *Symbol) *Symbol {
		return getMergedSymbol(symbol && (symbol.flags&SymbolFlagsExportValue) != 0 && symbol.exportSymbol || symbol)
	}
	symbolIsValue := func(symbol Symbol, includeTypeOnlyMembers bool) bool {
		return !!(symbol.flags&SymbolFlagsValue || symbol.flags&SymbolFlagsAlias && getSymbolFlags(symbol, !includeTypeOnlyMembers)&SymbolFlagsValue)
	}
	createType := func(flags TypeFlags) Type {
		result := /* TODO(NewExpression): new Type(checker, flags) */ TODO
		typeCount++
		result.id = typeCount
		tracing.recordType(result)
		return result
	}
	createTypeWithSymbol := func(flags TypeFlags, symbol Symbol) Type {
		result := createType(flags)
		result.symbol = symbol
		return result
	}
	createOriginType := func(flags TypeFlags) Type {
		return /* TODO(NewExpression): new Type(checker, flags) */ TODO
	}
	createIntrinsicType := func(kind TypeFlags, intrinsicName string, objectFlags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectFlags */ TODO /*  = ObjectFlags.None */, debugIntrinsicName string) IntrinsicType {
		checkIntrinsicName(intrinsicName, debugIntrinsicName)
		type_ := createType(kind)
		type_.intrinsicName = intrinsicName
		type_.debugIntrinsicName = debugIntrinsicName
		type_.objectFlags = objectFlags | ObjectFlagsCouldContainTypeVariablesComputed | ObjectFlagsIsGenericTypeComputed | ObjectFlagsIsUnknownLikeUnionComputed | ObjectFlagsIsNeverIntersectionComputed
		return type_
	}
	checkIntrinsicName := func(name string, debug /* TODO(StringKeyword): string */ any) {
		key := /* TODO(TemplateExpression): `${name},${debug ?? ""}` */ TODO
		if seenIntrinsicNames.has(key) {
			Debug.fail( /* TODO(TemplateExpression): `Duplicate intrinsic type name ${name}${debug ? ` (${debug})` : ""}; you may need to pass a name to createIntrinsicType.` */ TODO)
		}
		seenIntrinsicNames.add(key)
	}
	createObjectType := func(objectFlags ObjectFlags, symbol Symbol) ObjectType {
		type_ := createTypeWithSymbol(TypeFlagsObject, symbol)
		type_.objectFlags = objectFlags
		type_.members = nil
		type_.properties = nil
		type_.callSignatures = nil
		type_.constructSignatures = nil
		type_.indexInfos = nil
		return type_
	}
	createTypeofType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getUnionType(arrayFrom(typeofNEFacts.keys(), getStringLiteralType))
	}
	createTypeParameter := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
		return createTypeWithSymbol(TypeFlagsTypeParameter, symbol)
	}
	isReservedMemberName := func(name __String) /* TODO inferred type boolean */ TODO {
		return (name).charCodeAt(0) == CharacterCodes_ && (name).charCodeAt(1) == CharacterCodes_ && (name).charCodeAt(2) != CharacterCodes_ && (name).charCodeAt(2) != CharacterCodesat && (name).charCodeAt(2) != CharacterCodeshash
	}
	getNamedMembers := func(members SymbolTable) []Symbol {
		var result /* TODO(ArrayType): Symbol[] */ any
		members.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
			if isNamedMember(symbol, id) {
				(result || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = [] */ TODO)).push(symbol)
			}
		})
		return result || emptyArray
	}
	isNamedMember := func(member Symbol, escapedName __String) /* TODO inferred type boolean */ TODO {
		return !isReservedMemberName(escapedName) && symbolIsValue(member)
	}
	getNamedOrIndexSignatureMembers := func(members SymbolTable) []Symbol {
		result := getNamedMembers(members)
		index := getIndexSymbolFromSymbolTable(members)
		return /* TODO(ConditionalExpression): index ? concatenate(result, [index]) : result */ TODO
	}
	setStructuredTypeMembers := func(type_ StructuredType, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
		resolved := type_
		resolved.members = members
		resolved.properties = emptyArray
		resolved.callSignatures = callSignatures
		resolved.constructSignatures = constructSignatures
		resolved.indexInfos = indexInfos
		if members != emptySymbols {
			resolved.properties = getNamedMembers(members)
		}
		return resolved
	}
	createAnonymousType := func(symbol *Symbol, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
		return setStructuredTypeMembers(createObjectType(ObjectFlagsAnonymous, symbol), members, callSignatures, constructSignatures, indexInfos)
	}
	getResolvedTypeWithoutAbstractConstructSignatures := func(type_ ResolvedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		if type_.constructSignatures.length == 0 {
			return type_
		}
		if type_.objectTypeWithoutAbstractConstructSignatures {
			return type_.objectTypeWithoutAbstractConstructSignatures
		}
		constructSignatures := filter(type_.constructSignatures, func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
			return !(signature.flags & SignatureFlagsAbstract)
		})
		if type_.constructSignatures == constructSignatures {
			return type_
		}
		typeCopy := createAnonymousType(type_.symbol, type_.members, type_.callSignatures /* TODO(ConditionalExpression): some(constructSignatures) ? constructSignatures : emptyArray */, TODO, type_.indexInfos)
		type_.objectTypeWithoutAbstractConstructSignatures = typeCopy
		typeCopy.objectTypeWithoutAbstractConstructSignatures = typeCopy
		return typeCopy
	}
	forEachSymbolTableInScope := func(enclosingDeclaration Node, callback func(symbolTable SymbolTable, ignoreQualification bool, isLocalNameLookup bool, scopeNode Node) T) T {
		var result T
		/* TODO(ForStatement): for (let location = enclosingDeclaration; location; location = location.parent) {             // Locals of a source file are not in scope (because they get merged into the global symbol table)             if (canHaveLocals(location) && location.locals && !isGlobalSourceFile(location)) {                 if (result = callback(location.locals, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location)) {                     return result;                 }             }             switch (location.kind) {                 case SyntaxKind.SourceFile:                     if (!isExternalOrCommonJsModule(location as SourceFile)) {                         break;                     }                     // falls through                 case SyntaxKind.ModuleDeclaration:                     const sym = getSymbolOfDeclaration(location as ModuleDeclaration);                     // `sym` may not have exports if this module declaration is backed by the symbol for a `const` that's being rewritten                     // into a namespace - in such cases, it's best to just let the namespace appear empty (the const members couldn't have referred                     // to one another anyway)                     if (result = callback(sym?.exports || emptySymbols, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location)) {                         return result;                     }                     break;                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression:                 case SyntaxKind.InterfaceDeclaration:                     // Type parameters are bound into `members` lists so they can merge across declarations                     // This is troublesome, since in all other respects, they behave like locals :cries:                     // TODO: the below is shared with similar code in `resolveName` - in fact, rephrasing all this symbol                     // lookup logic in terms of `resolveName` would be nice                     // The below is used to lookup type parameters within a class or interface, as they are added to the class/interface locals                     // These can never be latebound, so the symbol's raw members are sufficient. `getMembersOfNode` cannot be used, as it would                     // trigger resolving late-bound names, which we may already be in the process of doing while we're here!                     let table: Map<__String, Symbol> | undefined;                     // TODO: Should this filtered table be cached in some way?                     (getSymbolOfDeclaration(location as ClassLikeDeclaration | InterfaceDeclaration).members || emptySymbols).forEach((memberSymbol, key) => {                         if (memberSymbol.flags & (SymbolFlags.Type & ~SymbolFlags.Assignment)) {                             (table || (table = createSymbolTable())).set(key, memberSymbol);                         }                     });                     if (table && (result = callback(table, /*ignoreQualification* / undefined, /*isLocalNameLookup* / false, location))) {                         return result;                     }                     break;             }         } */
		return callback(globals, nil, true)
	}
	getQualifiedLeftMeaning := func(rightMeaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags.Value | import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags.Namespace */ TODO {
		return /* TODO(ConditionalExpression): rightMeaning === SymbolFlags.Value ? SymbolFlags.Value : SymbolFlags.Namespace */ TODO
	}
	getAccessibleSymbolChain := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, useOnlyExternalAliasing bool, visitedSymbolTablesMap /* TODO inferred type Map<number, import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable[]> */ TODO /*  = new Map<SymbolId, SymbolTable[]>() */) /* TODO(ArrayType): Symbol[] */ any {
		if !(symbol && !isPropertyOrMethodDeclarationSymbol(symbol)) {
			return nil
		}
		links := getSymbolLinks(symbol)
		cache := ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): links.accessibleChainCache ||= new Map() */ TODO)
		firstRelevantLocation := forEachSymbolTableInScope(enclosingDeclaration, func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ TODO, __ /* TODO inferred type boolean | undefined */ TODO, ___ /* TODO inferred type boolean | undefined */ TODO, node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO {
			return node
		})
		key := /* TODO(TemplateExpression): `${useOnlyExternalAliasing ? 0 : 1}|${firstRelevantLocation && getNodeId(firstRelevantLocation)}|${meaning}` */ TODO
		if cache.has(key) {
			return cache.get(key)
		}
		id := getSymbolId(symbol)
		visitedSymbolTables := visitedSymbolTablesMap.get(id)
		if !visitedSymbolTables {
			visitedSymbolTablesMap.set(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): visitedSymbolTables = [] */, TODO)
		}
		result := forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable)
		cache.set(key, result)
		return result
		getAccessibleSymbolChainFromSymbolTable := func(symbols SymbolTable, ignoreQualification bool, isLocalNameLookup bool) /* TODO(ArrayType): Symbol[] */ any {
			if !pushIfUnique(visitedSymbolTables, symbols) {
				return nil
			}
			result := trySymbolTable(symbols, ignoreQualification, isLocalNameLookup)
			visitedSymbolTables.pop()
			return result
		}
		canQualifySymbol := func(symbolFromSymbolTable Symbol, meaning SymbolFlags) /* TODO inferred type boolean */ TODO {
			return !needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning) || !!getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing, visitedSymbolTablesMap)
		}
		isAccessible := func(symbolFromSymbolTable Symbol, resolvedAliasSymbol Symbol, ignoreQualification bool) /* TODO inferred type boolean */ TODO {
			return (symbol == (resolvedAliasSymbol || symbolFromSymbolTable) || getMergedSymbol(symbol) == getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) && !some(symbolFromSymbolTable.declarations, hasNonGlobalAugmentationExternalModuleSymbol) && (ignoreQualification || canQualifySymbol(getMergedSymbol(symbolFromSymbolTable), meaning))
		}
		trySymbolTable := func(symbols SymbolTable, ignoreQualification /* TODO(BooleanKeyword): boolean */ any, isLocalNameLookup /* TODO(BooleanKeyword): boolean */ any) /* TODO(ArrayType): Symbol[] */ any {
			if isAccessible(symbols.get(symbol.escapedName), nil, ignoreQualification) {
				return /* TODO(ArrayLiteralExpression): [symbol!] */ TODO
			}
			result := forEachEntry(symbols, func(symbolFromSymbolTable /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] | undefined */ TODO {
				if symbolFromSymbolTable.flags&SymbolFlagsAlias && symbolFromSymbolTable.escapedName != InternalSymbolNameExportEquals && symbolFromSymbolTable.escapedName != InternalSymbolNameDefault && !(isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && isExternalModule(getSourceFileOfNode(enclosingDeclaration))) && (!useOnlyExternalAliasing || some(symbolFromSymbolTable.declarations, isExternalModuleImportEqualsDeclaration)) && ( /* TODO(ConditionalExpression): isLocalNameLookup ? !some(symbolFromSymbolTable.declarations, isNamespaceReexportDeclaration) : true */ TODO) && (ignoreQualification || !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKindExportSpecifier)) {
					resolvedImportedSymbol := resolveAlias(symbolFromSymbolTable)
					candidate := getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification)
					if candidate {
						return candidate
					}
				}
				if symbolFromSymbolTable.escapedName == symbol.escapedName && symbolFromSymbolTable.exportSymbol {
					if isAccessible(getMergedSymbol(symbolFromSymbolTable.exportSymbol), nil, ignoreQualification) {
						return /* TODO(ArrayLiteralExpression): [symbol!] */ TODO
					}
				}
			})
			return result || ( /* TODO(ConditionalExpression): symbols === globals ? getCandidateListForSymbol(globalThisSymbol, globalThisSymbol, ignoreQualification) : undefined */ TODO)
		}
		getCandidateListForSymbol := func(symbolFromSymbolTable Symbol, resolvedImportedSymbol Symbol, ignoreQualification /* TODO(BooleanKeyword): boolean */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] | undefined */ TODO {
			if isAccessible(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification) {
				return /* TODO(ArrayLiteralExpression): [symbolFromSymbolTable] */ TODO
			}
			candidateTable := getExportsOfSymbol(resolvedImportedSymbol)
			accessibleSymbolsFromExports := candidateTable && getAccessibleSymbolChainFromSymbolTable(candidateTable, true)
			if accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning)) {
				return /* TODO(ArrayLiteralExpression): [symbolFromSymbolTable] */ TODO.concat(accessibleSymbolsFromExports)
			}
		}
	}
	needsQualification := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) /* TODO inferred type boolean */ TODO {
		qualify := false
		forEachSymbolTableInScope(enclosingDeclaration, func(symbolTable /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ TODO) /* TODO inferred type boolean */ TODO {
			symbolFromSymbolTable := getMergedSymbol(symbolTable.get(symbol.escapedName))
			if !symbolFromSymbolTable {
				return false
			}
			if symbolFromSymbolTable == symbol {
				return true
			}
			shouldResolveAlias := symbolFromSymbolTable.flags&SymbolFlagsAlias && !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKindExportSpecifier)
			symbolFromSymbolTable = /* TODO(ConditionalExpression): shouldResolveAlias ? resolveAlias(symbolFromSymbolTable) : symbolFromSymbolTable */ TODO
			flags := /* TODO(ConditionalExpression): shouldResolveAlias ? getSymbolFlags(symbolFromSymbolTable) : symbolFromSymbolTable.flags */ TODO
			if flags & meaning {
				qualify = true
				return true
			}
			return false
		})
		return qualify
	}
	isPropertyOrMethodDeclarationSymbol := func(symbol Symbol) /* TODO inferred type boolean */ TODO {
		if symbol.declarations && symbol.declarations.length {
			for _, declaration := range symbol.declarations {
				switch declaration.kind {
				case SyntaxKindPropertyDeclaration:
					fallthrough // TODO: merge cases
				case SyntaxKindMethodDeclaration:
					fallthrough // TODO: merge cases
				case SyntaxKindGetAccessor:
					fallthrough // TODO: merge cases
				case SyntaxKindSetAccessor:
					continue
					fallthrough
				default:
					return false
				}
			}
			return true
		}
		return false
	}
	isTypeSymbolAccessible := func(typeSymbol Symbol, enclosingDeclaration Node) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlagsType, false, true)
		return access.accessibility == SymbolAccessibilityAccessible
	}
	isValueSymbolAccessible := func(typeSymbol Symbol, enclosingDeclaration Node) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlagsValue, false, true)
		return access.accessibility == SymbolAccessibilityAccessible
	}
	isSymbolAccessibleByFlags := func(typeSymbol Symbol, enclosingDeclaration Node, flags SymbolFlags) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, flags, false, false)
		return access.accessibility == SymbolAccessibilityAccessible
	}
	isAnySymbolAccessible := func(symbols /* TODO(ArrayType): Symbol[] */ any, enclosingDeclaration Node, initialSymbol Symbol, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) *SymbolAccessibilityResult {
		if !length(symbols) {
			return
		}
		var hadAccessibleChain *Symbol
		earlyModuleBail := false
		for _, symbol := range symbols {
			accessibleSymbolChain := getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, false)
			if accessibleSymbolChain {
				hadAccessibleChain = symbol
				hasAccessibleDeclarations := hasVisibleDeclarations( /* TODO(ElementAccessExpression): accessibleSymbolChain[0] */ TODO, shouldComputeAliasesToMakeVisible)
				if hasAccessibleDeclarations {
					return hasAccessibleDeclarations
				}
			}
			if allowModules {
				if some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
					if shouldComputeAliasesToMakeVisible {
						earlyModuleBail = true
						continue
					}
					return /* TODO(ObjectLiteralExpression): {                         accessibility: SymbolAccessibility.Accessible,                     } */ TODO
				}
			}
			containers := getContainersOfSymbol(symbol, enclosingDeclaration, meaning)
			parentResult := isAnySymbolAccessible(containers, enclosingDeclaration, initialSymbol /* TODO(ConditionalExpression): initialSymbol === symbol ? getQualifiedLeftMeaning(meaning) : meaning */, TODO, shouldComputeAliasesToMakeVisible, allowModules)
			if parentResult {
				return parentResult
			}
		}
		if earlyModuleBail {
			return /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.Accessible,             } */ TODO
		}
		if hadAccessibleChain {
			return /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.NotAccessible,                 errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),                 errorModuleName: hadAccessibleChain !== initialSymbol ? symbolToString(hadAccessibleChain, enclosingDeclaration, SymbolFlags.Namespace) : undefined,             } */ TODO
		}
	}
	isSymbolAccessible := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool) SymbolAccessibilityResult {
		return isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible, true)
	}
	isSymbolAccessibleWorker := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) SymbolAccessibilityResult {
		if symbol && enclosingDeclaration {
			result := isAnySymbolAccessible( /* TODO(ArrayLiteralExpression): [symbol] */ TODO, enclosingDeclaration, symbol, meaning, shouldComputeAliasesToMakeVisible, allowModules)
			if result {
				return result
			}
			symbolExternalModule := forEach(symbol.declarations, getExternalModuleContainer)
			if symbolExternalModule {
				enclosingExternalModule := getExternalModuleContainer(enclosingDeclaration)
				if symbolExternalModule != enclosingExternalModule {
					return /* TODO(ObjectLiteralExpression): {                         accessibility: SymbolAccessibility.CannotBeNamed,                         errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),                         errorModuleName: symbolToString(symbolExternalModule),                         errorNode: isInJSFile(enclosingDeclaration) ? enclosingDeclaration : undefined,                     } */ TODO
				}
			}
			return /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.NotAccessible,                 errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),             } */ TODO
		}
		return /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
	}
	getExternalModuleContainer := func(declaration Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		node := findAncestor(declaration, hasExternalModuleSymbol)
		return node && getSymbolOfDeclaration(node)
	}
	hasExternalModuleSymbol := func(declaration Node) /* TODO inferred type boolean */ TODO {
		return isAmbientModule(declaration) || (declaration.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(declaration))
	}
	hasNonGlobalAugmentationExternalModuleSymbol := func(declaration Node) /* TODO inferred type boolean */ TODO {
		return isModuleWithStringLiteralName(declaration) || (declaration.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(declaration))
	}
	hasVisibleDeclarations := func(symbol Symbol, shouldComputeAliasToMakeVisible bool) *SymbolVisibilityResult {
		var aliasesToMakeVisible /* TODO(ArrayType): LateVisibilityPaintedStatement[] */ any
		if !every(filter(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
			return d.kind != SyntaxKindIdentifier
		}), getIsDeclarationVisible) {
			return nil
		}
		return /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible, aliasesToMakeVisible } */ TODO
		getIsDeclarationVisible := func(declaration Declaration) /* TODO inferred type boolean */ TODO {
			if !isDeclarationVisible(declaration) {
				anyImportSyntax := getAnyImportSyntax(declaration)
				if anyImportSyntax && !hasSyntacticModifier(anyImportSyntax, ModifierFlagsExport) && isDeclarationVisible(anyImportSyntax.parent) {
					return addVisibleAlias(declaration, anyImportSyntax)
				} else if isVariableDeclaration(declaration) && isVariableStatement(declaration.parent.parent) && !hasSyntacticModifier(declaration.parent.parent, ModifierFlagsExport) && isDeclarationVisible(declaration.parent.parent.parent) {
					return addVisibleAlias(declaration, declaration.parent.parent)
				} else if isLateVisibilityPaintedStatement(declaration) && !hasSyntacticModifier(declaration, ModifierFlagsExport) && isDeclarationVisible(declaration.parent) {
					return addVisibleAlias(declaration, declaration)
				} else if isBindingElement(declaration) {
					if symbol.flags&SymbolFlagsAlias && isInJSFile(declaration) && declaration.parent.parent && isVariableDeclaration(declaration.parent.parent) && declaration.parent.parent.parent.parent && isVariableStatement(declaration.parent.parent.parent.parent) && !hasSyntacticModifier(declaration.parent.parent.parent.parent, ModifierFlagsExport) && declaration.parent.parent.parent.parent.parent && isDeclarationVisible(declaration.parent.parent.parent.parent.parent) {
						return addVisibleAlias(declaration, declaration.parent.parent.parent.parent)
					} else if symbol.flags & SymbolFlagsBlockScopedVariable {
						variableStatement := findAncestor(declaration, isVariableStatement)
						if hasSyntacticModifier(variableStatement, ModifierFlagsExport) {
							return true
						}
						if !isDeclarationVisible(variableStatement.parent) {
							return false
						}
						return addVisibleAlias(declaration, variableStatement)
					}
				}
				return false
			}
			return true
		}
		addVisibleAlias := func(declaration Declaration, aliasingStatement LateVisibilityPaintedStatement) /* TODO inferred type boolean */ TODO {
			if shouldComputeAliasToMakeVisible {
				getNodeLinks(declaration).isVisible = true
				aliasesToMakeVisible = appendIfUnique(aliasesToMakeVisible, aliasingStatement)
			}
			return true
		}
	}
	getMeaningOfEntityNameReference := func(entityName EntityNameOrEntityNameExpression) SymbolFlags {
		var meaning SymbolFlags
		if entityName.parent.kind == SyntaxKindTypeQuery || entityName.parent.kind == SyntaxKindExpressionWithTypeArguments && !isPartOfTypeNode(entityName.parent) || entityName.parent.kind == SyntaxKindComputedPropertyName || entityName.parent.kind == SyntaxKindTypePredicate && (entityName.parent).parameterName == entityName {
			meaning = SymbolFlagsValue | SymbolFlagsExportValue
		} else if entityName.kind == SyntaxKindQualifiedName || entityName.kind == SyntaxKindPropertyAccessExpression || entityName.parent.kind == SyntaxKindImportEqualsDeclaration || (entityName.parent.kind == SyntaxKindQualifiedName && (entityName.parent).left == entityName) || (entityName.parent.kind == SyntaxKindPropertyAccessExpression && (entityName.parent).expression == entityName) || (entityName.parent.kind == SyntaxKindElementAccessExpression && (entityName.parent).expression == entityName) {
			meaning = SymbolFlagsNamespace
		} else {
			meaning = SymbolFlagsType
		}
		return meaning
	}
	isEntityNameVisible := func(entityName EntityNameOrEntityNameExpression, enclosingDeclaration Node, shouldComputeAliasToMakeVisible /* TODO inferred type boolean */ TODO /*  = true */) SymbolVisibilityResult {
		meaning := getMeaningOfEntityNameReference(entityName)
		firstIdentifier := getFirstIdentifier(entityName)
		symbol := resolveName(enclosingDeclaration, firstIdentifier.escapedText, meaning, nil, false)
		if symbol && symbol.flags&SymbolFlagsTypeParameter && meaning&SymbolFlagsType {
			return /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
		}
		if !symbol && isThisIdentifier(firstIdentifier) && isSymbolAccessible(getSymbolOfDeclaration(getThisContainer(firstIdentifier, false, false)), firstIdentifier, meaning, false).accessibility == SymbolAccessibilityAccessible {
			return /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
		}
		if !symbol {
			return /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.NotResolved,                 errorSymbolName: getTextOfNode(firstIdentifier),                 errorNode: firstIdentifier,             } */ TODO
		}
		return hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) || /* TODO(ObjectLiteralExpression): {             accessibility: SymbolAccessibility.NotAccessible,             errorSymbolName: getTextOfNode(firstIdentifier),             errorNode: firstIdentifier,         } */ TODO
	}
	symbolToString := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags, flags SymbolFormatFlags /*  = SymbolFormatFlags.AllowAnyNodeKind */, writer EmitTextWriter) string {
		nodeFlags := NodeBuilderFlagsIgnoreErrors
		internalNodeFlags := InternalNodeBuilderFlagsNone
		if flags & SymbolFormatFlagsUseOnlyExternalAliasing {
			nodeFlags |= NodeBuilderFlagsUseOnlyExternalAliasing
		}
		if flags & SymbolFormatFlagsWriteTypeParametersOrArguments {
			nodeFlags |= NodeBuilderFlagsWriteTypeParametersInQualifiedName
		}
		if flags & SymbolFormatFlagsUseAliasDefinedOutsideCurrentScope {
			nodeFlags |= NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope
		}
		if flags & SymbolFormatFlagsDoNotIncludeSymbolChain {
			internalNodeFlags |= InternalNodeBuilderFlagsDoNotIncludeSymbolChain
		}
		if flags & SymbolFormatFlagsWriteComputedProps {
			internalNodeFlags |= InternalNodeBuilderFlagsWriteComputedProps
		}
		builder := /* TODO(ConditionalExpression): flags & SymbolFormatFlags.AllowAnyNodeKind ? nodeBuilder.symbolToNode : nodeBuilder.symbolToEntityName */ TODO
		return /* TODO(ConditionalExpression): writer ? symbolToStringWorker(writer).getText() : usingSingleLineStringWriter(symbolToStringWorker) */ TODO
		symbolToStringWorker := func(writer EmitTextWriter) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ TODO {
			entity := builder(symbol, meaning, enclosingDeclaration, nodeFlags, internalNodeFlags)
			printer := /* TODO(ConditionalExpression): enclosingDeclaration?.kind === SyntaxKind.SourceFile                 ? createPrinterWithRemoveCommentsNeverAsciiEscape()                 : createPrinterWithRemoveComments() */ TODO
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			printer.writeNode(EmitHintUnspecified, entity, sourceFile, writer)
			return writer
		}
	}
	signatureToString := func(signature Signature, enclosingDeclaration Node, flags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFormatFlags */ TODO /*  = TypeFormatFlags.None */, kind SignatureKind, writer EmitTextWriter) string {
		return /* TODO(ConditionalExpression): writer ? signatureToStringWorker(writer).getText() : usingSingleLineStringWriter(signatureToStringWorker) */ TODO
		signatureToStringWorker := func(writer EmitTextWriter) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ TODO {
			var sigOutput SyntaxKind
			if flags & TypeFormatFlagsWriteArrowStyleSignature {
				sigOutput = /* TODO(ConditionalExpression): kind === SignatureKind.Construct ? SyntaxKind.ConstructorType : SyntaxKind.FunctionType */ TODO
			} else {
				sigOutput = /* TODO(ConditionalExpression): kind === SignatureKind.Construct ? SyntaxKind.ConstructSignature : SyntaxKind.CallSignature */ TODO
			}
			sig := nodeBuilder.signatureToSignatureDeclaration(signature, sigOutput, enclosingDeclaration, toNodeBuilderFlags(flags)|NodeBuilderFlagsIgnoreErrors|NodeBuilderFlagsWriteTypeParametersInQualifiedName)
			printer := createPrinterWithRemoveCommentsOmitTrailingSemicolon()
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			printer.writeNode(EmitHintUnspecified, sig, sourceFile, getTrailingSemicolonDeferringWriter(writer))
			return writer
		}
	}
	typeToString := func(type_ Type, enclosingDeclaration Node, flags TypeFormatFlags /*  = TypeFormatFlags.AllowUniqueESSymbolType | TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter /*  = createTextWriter("") */) string {
		noTruncation := compilerOptions.noErrorTruncation || flags&TypeFormatFlagsNoTruncation
		typeNode := nodeBuilder.typeToTypeNode(type_, enclosingDeclaration, toNodeBuilderFlags(flags)|NodeBuilderFlagsIgnoreErrors|( /* TODO(ConditionalExpression): noTruncation ? NodeBuilderFlags.NoTruncation : NodeBuilderFlags.None */ TODO), nil)
		if typeNode == nil {
			return Debug.fail("should always get typenode")
		}
		printer := /* TODO(ConditionalExpression): type !== unresolvedType ? createPrinterWithRemoveComments() : createPrinterWithDefaults() */ TODO
		sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
		printer.writeNode(EmitHintUnspecified, typeNode, sourceFile, writer)
		result := writer.getText()
		maxLength := /* TODO(ConditionalExpression): noTruncation ? noTruncationMaximumTruncationLength * 2 : defaultMaximumTruncationLength * 2 */ TODO
		if maxLength && result && result.length >= maxLength {
			return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): result.substr(0, maxLength - "...".length) + "..." */ TODO
		}
		return result
	}
	getTypeNamesForErrorDisplay := func(left Type, right Type) /* TODO(TupleType): [string, string] */ any {
		leftStr := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(left.symbol) ? typeToString(left, left.symbol.valueDeclaration) : typeToString(left) */ TODO
		rightStr := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(right.symbol) ? typeToString(right, right.symbol.valueDeclaration) : typeToString(right) */ TODO
		if leftStr == rightStr {
			leftStr = getTypeNameForErrorDisplay(left)
			rightStr = getTypeNameForErrorDisplay(right)
		}
		return /* TODO(ArrayLiteralExpression): [leftStr, rightStr] */ TODO
	}
	getTypeNameForErrorDisplay := func(type_ Type) /* TODO inferred type string */ TODO {
		return typeToString(type_, nil, TypeFormatFlagsUseFullyQualifiedType)
	}
	symbolValueDeclarationIsContextSensitive := func(symbol Symbol) bool {
		return symbol && !!symbol.valueDeclaration && isExpression(symbol.valueDeclaration) && !isContextSensitive(symbol.valueDeclaration)
	}
	toNodeBuilderFlags := func(flags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFormatFlags */ TODO /*  = TypeFormatFlags.None */) NodeBuilderFlags {
		return flags & TypeFormatFlagsNodeBuilderFlagsMask
	}
	isClassInstanceSide := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!type_.symbol && !!(type_.symbol.flags & SymbolFlagsClass) && (type_ == getDeclaredTypeOfClassOrInterface(type_.symbol) || (!!(type_.flags & TypeFlagsObject) && !!(getObjectFlags(type_) & ObjectFlagsIsClassInstanceClone)))
	}
	getTypeFromTypeNodeWithoutContext := func(node TypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getTypeFromTypeNode(node)
	}
	createNodeBuilder := func() /* TODO inferred type { typeToTypeNode: (type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; typePredicateToTypePredicateNode: (typePredicate: import("/home/jabaile/work/TypeScript/src/compiler/types").TypePredicate, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypePredicateNode | undefined; expressionOrTypeToTypeNode: (expr: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttributeValue | undefined, type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, addUndefined?: boolean | undefined, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; serializeTypeForDeclaration: (declaration: import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration, type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; serializeReturnTypeForSignature: (signature: import("/home/jabaile/work/TypeScript/src/compiler/types").Signature, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; indexInfoToIndexSignatureDeclaration: (indexInfo: import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | undefined; signatureToSignatureDeclaration: (signature: import("/home/jabaile/work/TypeScript/src/compiler/types").Signature, kind: import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.MethodSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.MethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.Constructor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.GetAccessor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.SetAccessor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.CallSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ConstructSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.IndexSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionType | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ConstructorType | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ArrowFunction | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.JSDocFunctionType, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").SignatureDeclaration | undefined; symbolToEntityName: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").EntityName | undefined; symbolToExpression: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined; symbolToTypeParameterDeclarations: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").NodeArray<import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration> | undefined; symbolToParameterDeclaration: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined; typeParameterToDeclaration: (parameter: import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration | undefined; symbolTableToDeclarationStatements: (symbolTable: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] | undefined; symbolToNode: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName | undefined; } */ TODO {
		return /* TODO(ObjectLiteralExpression): {             typeToTypeNode: (type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeToTypeNodeHelper(type, context)),             typePredicateToTypePredicateNode: (typePredicate: TypePredicate, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typePredicateToTypePredicateNodeHelper(typePredicate, context)),             expressionOrTypeToTypeNode: (expr: Expression | JsxAttributeValue | undefined, type: Type, addUndefined?: boolean, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => expressionOrTypeToTypeNode(context, expr, type, addUndefined)),             serializeTypeForDeclaration: (declaration: Declaration, type: Type, symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => serializeTypeForDeclaration(context, declaration, type, symbol)),             serializeReturnTypeForSignature: (signature: Signature, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => serializeReturnTypeForSignature(context, signature)),             indexInfoToIndexSignatureDeclaration: (indexInfo: IndexInfo, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => indexInfoToIndexSignatureDeclarationHelper(indexInfo, context, /*typeNode* / undefined)),             signatureToSignatureDeclaration: (signature: Signature, kind: SignatureDeclaration["kind"], enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => signatureToSignatureDeclarationHelper(signature, kind, context)),             symbolToEntityName: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToName(symbol, context, meaning, /*expectsIdentifier* / false)),             symbolToExpression: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToExpression(symbol, context, meaning)),             symbolToTypeParameterDeclarations: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeParametersToTypeParameterDeclarations(symbol, context)),             symbolToParameterDeclaration: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToParameterDeclaration(symbol, context)),             typeParameterToDeclaration: (parameter: TypeParameter, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeParameterToDeclaration(parameter, context)),             symbolTableToDeclarationStatements: (symbolTable: SymbolTable, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolTableToDeclarationStatements(symbolTable, context)),             symbolToNode: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToNode(symbol, context, meaning)),         } */ TODO
		// OVERLOAD: getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes /* TODO(LiteralType): false */ any) Type
		// OVERLOAD: getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes /* TODO(LiteralType): true */ any) *Type
		getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes bool) *Type {
			type_ := getTypeFromTypeNodeWithoutContext(node)
			if !context.mapper {
				return type_
			}
			mappedType := instantiateType(type_, context.mapper)
			return /* TODO(ConditionalExpression): noMappedTypes && mappedType !== type ? undefined : mappedType */ TODO
		}
		setTextRange := func(context NodeBuilderContext, range_ T, location Node) T {
			if !nodeIsSynthesized(range_) || !(range_.flags & NodeFlagsSynthesized) || !context.enclosingFile || context.enclosingFile != getSourceFileOfNode(getOriginalNode(range_)) {
				range_ = factory.cloneNode(range_)
			}
			if range_ == location {
				return range_
			}
			if !location {
				return range_
			}
			original := range_.original
			for original && original != location {
				original = original.original
			}
			if !original {
				setOriginalNode(range_, location)
			}
			if context.enclosingFile && context.enclosingFile == getSourceFileOfNode(getOriginalNode(location)) {
				return setTextRangeWorker(range_, location)
			}
			return range_
		}
		expressionOrTypeToTypeNode := func(context NodeBuilderContext, expr /* TODO(UnionType): Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			restoreFlags := saveRestoreFlags(context)
			if expr && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
				syntacticNodeBuilder.serializeTypeOfExpression(expr, context, addUndefined)
			}
			context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
			result := expressionOrTypeToTypeNodeHelper(context, expr, type_, addUndefined)
			restoreFlags()
			return result
		}
		expressionOrTypeToTypeNodeHelper := func(context NodeBuilderContext, expr /* TODO(UnionType): Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			if expr {
				typeNode := /* TODO(ConditionalExpression): isAssertionExpression(expr) ? expr.type                     : isJSDocTypeAssertion(expr) ? getJSDocTypeAssertionType(expr)                     : undefined */ TODO
				if typeNode && !isConstTypeReference(typeNode) {
					result := tryReuseExistingTypeNode(context, typeNode, type_, expr.parent, addUndefined)
					if result {
						return result
					}
				}
			}
			if addUndefined {
				type_ = getOptionalType(type_)
			}
			return typeToTypeNodeHelper(type_, context)
		}
		tryReuseExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode, type_ Type, host Node, addUndefined bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			originalType := type_
			if addUndefined {
				type_ = getOptionalType(type_, !isParameter(host))
			}
			clone := tryReuseExistingNonParameterTypeNode(context, typeNode, type_, host)
			if clone {
				if addUndefined && containsNonMissingUndefinedType(type_) && !someType(getTypeFromTypeNode(context, typeNode), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !!(t.flags & TypeFlagsUndefined)
				}) {
					return factory.createUnionTypeNode( /* TODO(ArrayLiteralExpression): [clone, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)] */ TODO)
				}
				return clone
			}
			if addUndefined && originalType != type_ {
				cloneMissingUndefined := tryReuseExistingNonParameterTypeNode(context, typeNode, originalType, host)
				if cloneMissingUndefined {
					return factory.createUnionTypeNode( /* TODO(ArrayLiteralExpression): [cloneMissingUndefined, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)] */ TODO)
				}
			}
			return nil
		}
		tryReuseExistingNonParameterTypeNode := func(context NodeBuilderContext, existing TypeNode, type_ Type, host /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO /*  = context.enclosingDeclaration */, annotationType /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO /*  = getTypeFromTypeNode(context, existing, /*noMappedTypes* / true) */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			if annotationType && typeNodeIsEquivalentToType(host, type_, annotationType) && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type_) {
				result := tryReuseExistingTypeNodeHelper(context, existing)
				if result {
					return result
				}
			}
			return nil
		}
		symbolToNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName */ TODO {
			if context.internalFlags & InternalNodeBuilderFlagsWriteComputedProps {
				if symbol.valueDeclaration {
					name := getNameOfDeclaration(symbol.valueDeclaration)
					if name && isComputedPropertyName(name) {
						return name
					}
				}
				nameType := getSymbolLinks(symbol).nameType
				if nameType && nameType.flags&(TypeFlagsEnumLiteral|TypeFlagsUniqueESSymbol) {
					context.enclosingDeclaration = nameType.symbol.valueDeclaration
					return factory.createComputedPropertyName(symbolToExpression(nameType.symbol, context, meaning))
				}
			}
			return symbolToExpression(symbol, context, meaning)
		}
		withContext := func(enclosingDeclaration Node, flags *NodeBuilderFlags, internalFlags *InternalNodeBuilderFlags, tracker *SymbolTracker, cb func(context NodeBuilderContext) T) *T {
			moduleResolverHost := /* TODO(ConditionalExpression): tracker?.trackSymbol ? tracker.moduleResolverHost :                 (internalFlags || InternalNodeBuilderFlags.None) & InternalNodeBuilderFlags.DoNotIncludeSymbolChain ? createBasicNodeBuilderModuleSpecifierResolutionHost(host) :                 undefined */ TODO
			var context NodeBuilderContext = /* TODO(ObjectLiteralExpression): {                 enclosingDeclaration,                 enclosingFile: enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration),                 flags: flags || NodeBuilderFlags.None,                 internalFlags: internalFlags || InternalNodeBuilderFlags.None,                 tracker: undefined!,                 encounteredError: false,                 reportedDiagnostic: false,                 visitedTypes: undefined,                 symbolDepth: undefined,                 inferTypeParameters: undefined,                 approximateLength: 0,                 trackedSymbols: undefined,                 bundled: !!compilerOptions.outFile && !!enclosingDeclaration && isExternalOrCommonJsModule(getSourceFileOfNode(enclosingDeclaration)),                 truncating: false,                 usedSymbolNames: undefined,                 remappedSymbolNames: undefined,                 remappedSymbolReferences: undefined,                 reverseMappedStack: undefined,                 mustCreateTypeParameterSymbolList: true,                 typeParameterSymbolList: undefined,                 mustCreateTypeParametersNamesLookups: true,                 typeParameterNames: undefined,                 typeParameterNamesByText: undefined,                 typeParameterNamesByTextNextNameCount: undefined,                 mapper: undefined,             } */ TODO
			context.tracker = /* TODO(NewExpression): new SymbolTrackerImpl(context, tracker, moduleResolverHost) */ TODO
			resultingNode := cb(context)
			if context.truncating && context.flags&NodeBuilderFlagsNoTruncation {
				context.tracker.reportTruncationError()
			}
			return /* TODO(ConditionalExpression): context.encounteredError ? undefined : resultingNode */ TODO
		}
		saveRestoreFlags := func(context NodeBuilderContext) /* TODO inferred type () => void */ TODO {
			flags := context.flags
			internalFlags := context.internalFlags
			return restore
			restore := func() {
				context.flags = flags
				context.internalFlags = internalFlags
			}
		}
		checkTruncationLength := func(context NodeBuilderContext) bool {
			if context.truncating {
				return context.truncating
			}
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): context.truncating = context.approximateLength > ((context.flags & NodeBuilderFlags.NoTruncation) ? noTruncationMaximumTruncationLength : defaultMaximumTruncationLength) */ TODO
		}
		typeToTypeNodeHelper := func(type_ Type, context NodeBuilderContext) TypeNode {
			restoreFlags := saveRestoreFlags(context)
			typeNode := typeToTypeNodeWorker(type_, context)
			restoreFlags()
			return typeNode
		}
		typeToTypeNodeWorker := func(type_ Type, context NodeBuilderContext) TypeNode {
			if cancellationToken && cancellationToken.throwIfCancellationRequested {
				cancellationToken.throwIfCancellationRequested()
			}
			inTypeAlias := context.flags & NodeBuilderFlagsInTypeAlias
			context.flags &= ~NodeBuilderFlagsInTypeAlias
			if !type_ {
				if !(context.flags & NodeBuilderFlagsAllowEmptyUnionOrIntersection) {
					context.encounteredError = true
					return nil
				}
				context.approximateLength += 3
				return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
			}
			if !(context.flags & NodeBuilderFlagsNoTypeReduction) {
				type_ = getReducedType(type_)
			}
			if type_.flags & TypeFlagsAny {
				if type_.aliasSymbol {
					return factory.createTypeReferenceNode(symbolToEntityNameNode(type_.aliasSymbol), mapToTypeNodes(type_.aliasTypeArguments, context))
				}
				if type_ == unresolvedType {
					return addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), SyntaxKindMultiLineCommentTrivia, "unresolved")
				}
				context.approximateLength += 3
				return factory.createKeywordTypeNode( /* TODO(ConditionalExpression): type === intrinsicMarkerType ? SyntaxKind.IntrinsicKeyword : SyntaxKind.AnyKeyword */ TODO)
			}
			if type_.flags & TypeFlagsUnknown {
				return factory.createKeywordTypeNode(SyntaxKindUnknownKeyword)
			}
			if type_.flags & TypeFlagsString {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindStringKeyword)
			}
			if type_.flags & TypeFlagsNumber {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindNumberKeyword)
			}
			if type_.flags & TypeFlagsBigInt {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindBigIntKeyword)
			}
			if type_.flags&TypeFlagsBoolean && !type_.aliasSymbol {
				context.approximateLength += 7
				return factory.createKeywordTypeNode(SyntaxKindBooleanKeyword)
			}
			if type_.flags & TypeFlagsEnumLike {
				if type_.symbol.flags & SymbolFlagsEnumMember {
					parentSymbol := getParentOfSymbol(type_.symbol)
					parentName := symbolToTypeNode(parentSymbol, context, SymbolFlagsType)
					if getDeclaredTypeOfSymbol(parentSymbol) == type_ {
						return parentName
					}
					memberName := symbolName(type_.symbol)
					if isIdentifierText(memberName, ScriptTargetES5) {
						return appendReferenceToType(parentName, factory.createTypeReferenceNode(memberName, nil))
					}
					if isImportTypeNode(parentName) {
						(parentName).isTypeOf = true
						return factory.createIndexedAccessTypeNode(parentName, factory.createLiteralTypeNode(factory.createStringLiteral(memberName)))
					} else if isTypeReferenceNode(parentName) {
						return factory.createIndexedAccessTypeNode(factory.createTypeQueryNode(parentName.typeName), factory.createLiteralTypeNode(factory.createStringLiteral(memberName)))
					} else {
						return Debug.fail("Unhandled type node kind returned from `symbolToTypeNode`.")
					}
				}
				return symbolToTypeNode(type_.symbol, context, SymbolFlagsType)
			}
			if type_.flags & TypeFlagsStringLiteral {
				context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (type as StringLiteralType).value.length + 2 */ TODO
				return factory.createLiteralTypeNode(setEmitFlags(factory.createStringLiteral((type_).value, !!(context.flags&NodeBuilderFlagsUseSingleQuotesForStringLiteralType)), EmitFlagsNoAsciiEscaping))
			}
			if type_.flags & TypeFlagsNumberLiteral {
				value := (type_).value
				context.approximateLength += ( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + value */ TODO).length
				return factory.createLiteralTypeNode( /* TODO(ConditionalExpression): value < 0 ? factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createNumericLiteral(-value)) : factory.createNumericLiteral(value) */ TODO)
			}
			if type_.flags & TypeFlagsBigIntLiteral {
				context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (pseudoBigIntToString((type as BigIntLiteralType).value).length) + 1 */ TODO
				return factory.createLiteralTypeNode(factory.createBigIntLiteral((type_).value))
			}
			if type_.flags & TypeFlagsBooleanLiteral {
				context.approximateLength += (type_).intrinsicName.length
				return factory.createLiteralTypeNode( /* TODO(ConditionalExpression): (type as IntrinsicType).intrinsicName === "true" ? factory.createTrue() : factory.createFalse() */ TODO)
			}
			if type_.flags & TypeFlagsUniqueESSymbol {
				if !(context.flags & NodeBuilderFlagsAllowUniqueESSymbolType) {
					if isValueSymbolAccessible(type_.symbol, context.enclosingDeclaration) {
						context.approximateLength += 6
						return symbolToTypeNode(type_.symbol, context, SymbolFlagsValue)
					}
					if context.tracker.reportInaccessibleUniqueSymbolError {
						context.tracker.reportInaccessibleUniqueSymbolError()
					}
				}
				context.approximateLength += 13
				return factory.createTypeOperatorNode(SyntaxKindUniqueKeyword, factory.createKeywordTypeNode(SyntaxKindSymbolKeyword))
			}
			if type_.flags & TypeFlagsVoid {
				context.approximateLength += 4
				return factory.createKeywordTypeNode(SyntaxKindVoidKeyword)
			}
			if type_.flags & TypeFlagsUndefined {
				context.approximateLength += 9
				return factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)
			}
			if type_.flags & TypeFlagsNull {
				context.approximateLength += 4
				return factory.createLiteralTypeNode(factory.createNull())
			}
			if type_.flags & TypeFlagsNever {
				context.approximateLength += 5
				return factory.createKeywordTypeNode(SyntaxKindNeverKeyword)
			}
			if type_.flags & TypeFlagsESSymbol {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindSymbolKeyword)
			}
			if type_.flags & TypeFlagsNonPrimitive {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindObjectKeyword)
			}
			if isThisTypeParameter(type_) {
				if context.flags & NodeBuilderFlagsInObjectTypeLiteral {
					if !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowThisInObjectLiteral) {
						context.encounteredError = true
					}
					context.tracker.reportInaccessibleThisError()
				}
				context.approximateLength += 4
				return factory.createThisTypeNode()
			}
			if !inTypeAlias && type_.aliasSymbol && (context.flags&NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope || isTypeSymbolAccessible(type_.aliasSymbol, context.enclosingDeclaration)) {
				typeArgumentNodes := mapToTypeNodes(type_.aliasTypeArguments, context)
				if isReservedMemberName(type_.aliasSymbol.escapedName) && !(type_.aliasSymbol.flags & SymbolFlagsClass) {
					return factory.createTypeReferenceNode(factory.createIdentifier(""), typeArgumentNodes)
				}
				if length(typeArgumentNodes) == 1 && type_.aliasSymbol == globalArrayType.symbol {
					return factory.createArrayTypeNode( /* TODO(ElementAccessExpression): typeArgumentNodes![0] */ TODO)
				}
				return symbolToTypeNode(type_.aliasSymbol, context, SymbolFlagsType, typeArgumentNodes)
			}
			objectFlags := getObjectFlags(type_)
			if objectFlags & ObjectFlagsReference {
				Debug.assert(!!(type_.flags & TypeFlagsObject))
				return /* TODO(ConditionalExpression): (type as TypeReference).node ? visitAndTransformType(type as TypeReference, typeReferenceToTypeNode) : typeReferenceToTypeNode(type as TypeReference) */ TODO
			}
			if type_.flags&TypeFlagsTypeParameter || objectFlags&ObjectFlagsClassOrInterface {
				if type_.flags&TypeFlagsTypeParameter && contains(context.inferTypeParameters, type_) {
					context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): symbolName(type.symbol).length + 6 */ TODO
					var constraintNode *TypeNode
					constraint := getConstraintOfTypeParameter(type_)
					if constraint {
						inferredConstraint := getInferredTypeParameterConstraint(type_, true)
						if !(inferredConstraint && isTypeIdenticalTo(constraint, inferredConstraint)) {
							context.approximateLength += 9
							constraintNode = constraint && typeToTypeNodeHelper(constraint, context)
						}
					}
					return factory.createInferTypeNode(typeParameterToDeclarationWithConstraint(type_, context, constraintNode))
				}
				if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && type_.flags&TypeFlagsTypeParameter {
					name := typeParameterToName(type_, context)
					context.approximateLength += idText(name).length
					return factory.createTypeReferenceNode(factory.createIdentifier(idText(name)), nil)
				}
				if type_.symbol {
					return symbolToTypeNode(type_.symbol, context, SymbolFlagsType)
				}
				name := /* TODO(ConditionalExpression): (type === markerSuperTypeForCheck || type === markerSubTypeForCheck) && varianceTypeParameter && varianceTypeParameter.symbol ?                     (type === markerSubTypeForCheck ? "sub-" : "super-") + symbolName(varianceTypeParameter.symbol) : "?" */ TODO
				return factory.createTypeReferenceNode(factory.createIdentifier(name), nil)
			}
			if type_.flags&TypeFlagsUnion && (type_).origin {
				type_ = (type_).origin
			}
			if type_.flags & (TypeFlagsUnion | TypeFlagsIntersection) {
				types := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? formatUnionTypes((type as UnionType).types) : (type as IntersectionType).types */ TODO
				if length(types) == 1 {
					return typeToTypeNodeHelper( /* TODO(ElementAccessExpression): types[0] */ TODO, context)
				}
				typeNodes := mapToTypeNodes(types, context, true)
				if typeNodes && typeNodes.length > 0 {
					return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? factory.createUnionTypeNode(typeNodes) : factory.createIntersectionTypeNode(typeNodes) */ TODO
				} else {
					if !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowEmptyUnionOrIntersection) {
						context.encounteredError = true
					}
					return nil
				}
			}
			if objectFlags & (ObjectFlagsAnonymous | ObjectFlagsMapped) {
				Debug.assert(!!(type_.flags & TypeFlagsObject))
				return createAnonymousTypeNode(type_)
			}
			if type_.flags & TypeFlagsIndex {
				indexedType := (type_).type_
				context.approximateLength += 6
				indexTypeNode := typeToTypeNodeHelper(indexedType, context)
				return factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, indexTypeNode)
			}
			if type_.flags & TypeFlagsTemplateLiteral {
				texts := (type_).texts
				types := (type_).types
				templateHead := factory.createTemplateHead( /* TODO(ElementAccessExpression): texts[0] */ TODO)
				templateSpans := factory.createNodeArray(map_(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralTypeSpan */ TODO {
					return factory.createTemplateLiteralTypeSpan(typeToTypeNodeHelper(t, context), ( /* TODO(ConditionalExpression): i < types.length - 1 ? factory.createTemplateMiddle : factory.createTemplateTail */ TODO)( /* TODO(ElementAccessExpression): texts[i + 1] */ TODO))
				}))
				context.approximateLength += 2
				return factory.createTemplateLiteralType(templateHead, templateSpans)
			}
			if type_.flags & TypeFlagsStringMapping {
				typeNode := typeToTypeNodeHelper((type_).type_, context)
				return symbolToTypeNode((type_).symbol, context, SymbolFlagsType /* TODO(ArrayLiteralExpression): [typeNode] */, TODO)
			}
			if type_.flags & TypeFlagsIndexedAccess {
				objectTypeNode := typeToTypeNodeHelper((type_).objectType, context)
				indexTypeNode := typeToTypeNodeHelper((type_).indexType, context)
				context.approximateLength += 2
				return factory.createIndexedAccessTypeNode(objectTypeNode, indexTypeNode)
			}
			if type_.flags & TypeFlagsConditional {
				return visitAndTransformType(type_, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ConditionalTypeNode */ TODO {
					return conditionalTypeToTypeNode(type_)
				})
			}
			if type_.flags & TypeFlagsSubstitution {
				typeNode := typeToTypeNodeHelper((type_).baseType, context)
				noInferSymbol := isNoInferType(type_) && getGlobalTypeSymbol("NoInfer", false)
				return /* TODO(ConditionalExpression): noInferSymbol ? symbolToTypeNode(noInferSymbol, context, SymbolFlags.Type, [typeNode]) : typeNode */ TODO
			}
			return Debug.fail("Should be unreachable.")
			conditionalTypeToTypeNode := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ConditionalTypeNode */ TODO {
				checkTypeNode := typeToTypeNodeHelper(type_.checkType, context)
				context.approximateLength += 15
				if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && type_.root.isDistributive && !(type_.checkType.flags & TypeFlagsTypeParameter) {
					newParam := createTypeParameter(createSymbol(SymbolFlagsTypeParameter, "T"))
					name := typeParameterToName(newParam, context)
					newTypeVariable := factory.createTypeReferenceNode(name)
					context.approximateLength += 37
					newMapper := prependTypeMapping(type_.root.checkType, newParam, type_.mapper)
					saveInferTypeParameters := context.inferTypeParameters
					context.inferTypeParameters = type_.root.inferTypeParameters
					extendsTypeNode := typeToTypeNodeHelper(instantiateType(type_.root.extendsType, newMapper), context)
					context.inferTypeParameters = saveInferTypeParameters
					trueTypeNode := typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, type_.root.node.trueType), newMapper))
					falseTypeNode := typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, type_.root.node.falseType), newMapper))
					return factory.createConditionalTypeNode(checkTypeNode, factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode(newTypeVariable.typeName))), factory.createConditionalTypeNode(factory.createTypeReferenceNode(factory.cloneNode(name)), typeToTypeNodeHelper(type_.checkType, context), factory.createConditionalTypeNode(newTypeVariable, extendsTypeNode, trueTypeNode, falseTypeNode), factory.createKeywordTypeNode(SyntaxKindNeverKeyword)), factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
				}
				saveInferTypeParameters := context.inferTypeParameters
				context.inferTypeParameters = type_.root.inferTypeParameters
				extendsTypeNode := typeToTypeNodeHelper(type_.extendsType, context)
				context.inferTypeParameters = saveInferTypeParameters
				trueTypeNode := typeToTypeNodeOrCircularityElision(getTrueTypeFromConditionalType(type_))
				falseTypeNode := typeToTypeNodeOrCircularityElision(getFalseTypeFromConditionalType(type_))
				return factory.createConditionalTypeNode(checkTypeNode, extendsTypeNode, trueTypeNode, falseTypeNode)
			}
			typeToTypeNodeOrCircularityElision := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
				if type_.flags & TypeFlagsUnion {
					if context.visitedTypes.has(getTypeId(type_)) {
						if !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) {
							context.encounteredError = true
							context.tracker.reportCyclicStructureError()
						}
						return createElidedInformationPlaceholder(context)
					}
					return visitAndTransformType(type_, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
						return typeToTypeNodeHelper(type_, context)
					})
				}
				return typeToTypeNodeHelper(type_, context)
			}
			isMappedTypeHomomorphic := func(type_ MappedType) /* TODO inferred type boolean */ TODO {
				return !!getHomomorphicTypeVariable(type_)
			}
			isHomomorphicMappedTypeWithNonHomomorphicInstantiation := func(type_ MappedType) /* TODO inferred type boolean */ TODO {
				return !!type_.target && isMappedTypeHomomorphic(type_.target) && !isMappedTypeHomomorphic(type_)
			}
			createMappedTypeNodeFromType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ConditionalTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").MappedTypeNode */ TODO {
				Debug.assert(!!(type_.flags & TypeFlagsObject))
				readonlyToken := /* TODO(ConditionalExpression): type.declaration.readonlyToken ? factory.createToken(type.declaration.readonlyToken.kind) as ReadonlyKeyword | PlusToken | MinusToken : undefined */ TODO
				questionToken := /* TODO(ConditionalExpression): type.declaration.questionToken ? factory.createToken(type.declaration.questionToken.kind) as QuestionToken | PlusToken | MinusToken : undefined */ TODO
				var appropriateConstraintTypeNode TypeNode
				var newTypeVariable *TypeReferenceNode
				needsModifierPreservingWrapper := !isMappedTypeWithKeyofConstraintDeclaration(type_) && !(getModifiersTypeFromMappedType(type_).flags & TypeFlagsUnknown) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && !(getConstraintTypeFromMappedType(type_).flags&TypeFlagsTypeParameter && getConstraintOfTypeParameter(getConstraintTypeFromMappedType(type_)).flags&TypeFlagsIndex)
				if isMappedTypeWithKeyofConstraintDeclaration(type_) {
					if isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type_) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
						newParam := createTypeParameter(createSymbol(SymbolFlagsTypeParameter, "T"))
						name := typeParameterToName(newParam, context)
						newTypeVariable = factory.createTypeReferenceNode(name)
					}
					appropriateConstraintTypeNode = factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, newTypeVariable || typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context))
				} else if needsModifierPreservingWrapper {
					newParam := createTypeParameter(createSymbol(SymbolFlagsTypeParameter, "T"))
					name := typeParameterToName(newParam, context)
					newTypeVariable = factory.createTypeReferenceNode(name)
					appropriateConstraintTypeNode = newTypeVariable
				} else {
					appropriateConstraintTypeNode = typeToTypeNodeHelper(getConstraintTypeFromMappedType(type_), context)
				}
				typeParameterNode := typeParameterToDeclarationWithConstraint(getTypeParameterFromMappedType(type_), context, appropriateConstraintTypeNode)
				nameTypeNode := /* TODO(ConditionalExpression): type.declaration.nameType ? typeToTypeNodeHelper(getNameTypeFromMappedType(type)!, context) : undefined */ TODO
				templateTypeNode := typeToTypeNodeHelper(removeMissingType(getTemplateTypeFromMappedType(type_), !!(getMappedTypeModifiers(type_)&MappedTypeModifiersIncludeOptional)), context)
				mappedTypeNode := factory.createMappedTypeNode(readonlyToken, typeParameterNode, nameTypeNode, questionToken, templateTypeNode, nil)
				context.approximateLength += 10
				result := setEmitFlags(mappedTypeNode, EmitFlagsSingleLine)
				if isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type_) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
					originalConstraint := instantiateType(getConstraintOfTypeParameter(getTypeFromTypeNode(context, (type_.declaration.typeParameter.constraint).type_)) || unknownType, type_.mapper)
					return factory.createConditionalTypeNode(typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context), factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode(newTypeVariable.typeName) /* TODO(ConditionalExpression): originalConstraint.flags & TypeFlags.Unknown ? undefined : typeToTypeNodeHelper(originalConstraint, context) */, TODO)), result, factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
				} else if needsModifierPreservingWrapper {
					return factory.createConditionalTypeNode(typeToTypeNodeHelper(getConstraintTypeFromMappedType(type_), context), factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode(newTypeVariable.typeName), factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context)))), result, factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
				}
				return result
			}
			createAnonymousTypeNode := func(type_ ObjectType) TypeNode {
				typeId := type_.id
				symbol := type_.symbol
				if symbol {
					isInstantiationExpressionType := !!(getObjectFlags(type_) & ObjectFlagsInstantiationExpressionType)
					if isInstantiationExpressionType {
						instantiationExpressionType := type_
						existing := instantiationExpressionType.node
						if isTypeQueryNode(existing) {
							typeNode := tryReuseExistingNonParameterTypeNode(context, existing, type_)
							if typeNode {
								return typeNode
							}
						}
						if context.visitedTypes.has(typeId) {
							return createElidedInformationPlaceholder(context)
						}
						return visitAndTransformType(type_, createTypeNodeFromObjectType)
					}
					isInstanceType := /* TODO(ConditionalExpression): isClassInstanceSide(type) ? SymbolFlags.Type : SymbolFlags.Value */ TODO
					if isJSConstructor(symbol.valueDeclaration) {
						return symbolToTypeNode(symbol, context, isInstanceType)
					} else if symbol.flags&SymbolFlagsClass && !getBaseTypeVariableOfClass(symbol) && !(symbol.valueDeclaration && isClassLike(symbol.valueDeclaration) && context.flags&NodeBuilderFlagsWriteClassExpressionAsTypeLiteral && (!isClassDeclaration(symbol.valueDeclaration) || isSymbolAccessible(symbol, context.enclosingDeclaration, isInstanceType, false).accessibility != SymbolAccessibilityAccessible)) || symbol.flags&(SymbolFlagsEnum|SymbolFlagsValueModule) || shouldWriteTypeOfFunctionSymbol() {
						return symbolToTypeNode(symbol, context, isInstanceType)
					} else if context.visitedTypes.has(typeId) {
						typeAlias := getTypeAliasForTypeLiteral(type_)
						if typeAlias {
							return symbolToTypeNode(typeAlias, context, SymbolFlagsType)
						} else {
							return createElidedInformationPlaceholder(context)
						}
					} else {
						return visitAndTransformType(type_, createTypeNodeFromObjectType)
					}
				} else {
					return createTypeNodeFromObjectType(type_)
				}
				shouldWriteTypeOfFunctionSymbol := func() /* TODO inferred type boolean | undefined */ TODO {
					isStaticMethodSymbol := !!(symbol.flags & SymbolFlagsMethod) && some(symbol.declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
						return isStatic(declaration)
					})
					isNonLocalFunctionSymbol := !!(symbol.flags & SymbolFlagsFunction) && (symbol.parent || forEach(symbol.declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
						return declaration.parent.kind == SyntaxKindSourceFile || declaration.parent.kind == SyntaxKindModuleBlock
					}))
					if isStaticMethodSymbol || isNonLocalFunctionSymbol {
						return (!!(context.flags & NodeBuilderFlagsUseTypeOfFunction) || (context.visitedTypes.has(typeId))) && (!(context.flags & NodeBuilderFlagsUseStructuralFallback) || isValueSymbolAccessible(symbol, context.enclosingDeclaration))
					}
				}
			}
			visitAndTransformType := func(type_ T, transform func(type_ T) TypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
				typeId := type_.id
				isConstructorObject := getObjectFlags(type_)&ObjectFlagsAnonymous && type_.symbol && type_.symbol.flags&SymbolFlagsClass
				id := /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference & T).node ? "N" + getNodeId((type as TypeReference & T).node!) :                     type.flags & TypeFlags.Conditional ? "N" + getNodeId((type as ConditionalType & T).root.node) :                     type.symbol ? (isConstructorObject ? "+" : "") + getSymbolId(type.symbol) :                     undefined */ TODO
				if !context.visitedTypes {
					context.visitedTypes = /* TODO(NewExpression): new Set() */ make(map[any]struct{})
				}
				if id && !context.symbolDepth {
					context.symbolDepth = /* TODO(NewExpression): new Map() */ make(map[any]any)
				}
				links := context.enclosingDeclaration && getNodeLinks(context.enclosingDeclaration)
				key := /* TODO(TemplateExpression): `${getTypeId(type)}|${context.flags}|${context.internalFlags}` */ TODO
				if links {
					/* TODO(ExpressionStatement): links.serializedTypes ||= new Map(); */
				}
				cachedResult := links.serializedTypes.get(key)
				if cachedResult {
					cachedResult.trackedSymbols.forEach(func(TODO_IDENTIFIER /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TrackedSymbol */ TODO) /* TODO inferred type boolean */ TODO {
						return context.tracker.trackSymbol(symbol, enclosingDeclaration, meaning)
					})
					if cachedResult.truncating {
						context.truncating = true
					}
					context.approximateLength += cachedResult.addedLength
					return deepCloneOrReuseNode(cachedResult.node)
				}
				var depth /* TODO(NumberKeyword): number */ any
				if id {
					depth = context.symbolDepth.get(id) || 0
					if depth > 10 {
						return createElidedInformationPlaceholder(context)
					}
					context.symbolDepth.set(id /* TODO(PlusToken): + */ /* TODO(BinaryExpression): depth + 1 */, TODO)
				}
				context.visitedTypes.add(typeId)
				prevTrackedSymbols := context.trackedSymbols
				context.trackedSymbols = nil
				startLength := context.approximateLength
				result := transform(type_)
				addedLength := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): context.approximateLength - startLength */ TODO
				if !context.reportedDiagnostic && !context.encounteredError {
					links.serializedTypes.set(key /* TODO(ObjectLiteralExpression): {                         node: result,                         truncating: context.truncating,                         addedLength,                         trackedSymbols: context.trackedSymbols,                     } */, TODO)
				}
				context.visitedTypes.delete(typeId)
				if id {
					context.symbolDepth.set(id, depth)
				}
				context.trackedSymbols = prevTrackedSymbols
				return result
				deepCloneOrReuseNode := func(node T) T {
					if !nodeIsSynthesized(node) && getParseTreeNode(node) == node {
						return node
					}
					return setTextRange(context, factory.cloneNode(visitEachChildWorker(node, deepCloneOrReuseNode, nil, deepCloneOrReuseNodes, deepCloneOrReuseNode)), node)
				}
				deepCloneOrReuseNodes := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
					if nodes && nodes.length == 0 {
						return setTextRangeWorker(factory.createNodeArray(nil, nodes.hasTrailingComma), nodes)
					}
					return visitNodes(nodes, visitor, test, start, count)
				}
			}
			createTypeNodeFromObjectType := func(type_ ObjectType) TypeNode {
				if isGenericMappedType(type_) || (type_).containsError {
					return createMappedTypeNodeFromType(type_)
				}
				resolved := resolveStructuredTypeMembers(type_)
				if !resolved.properties.length && !resolved.indexInfos.length {
					if !resolved.callSignatures.length && !resolved.constructSignatures.length {
						context.approximateLength += 2
						return setEmitFlags(factory.createTypeLiteralNode(nil), EmitFlagsSingleLine)
					}
					if resolved.callSignatures.length == 1 && !resolved.constructSignatures.length {
						signature := /* TODO(ElementAccessExpression): resolved.callSignatures[0] */ TODO
						signatureNode := signatureToSignatureDeclarationHelper(signature, SyntaxKindFunctionType, context)
						return signatureNode
					}
					if resolved.constructSignatures.length == 1 && !resolved.callSignatures.length {
						signature := /* TODO(ElementAccessExpression): resolved.constructSignatures[0] */ TODO
						signatureNode := signatureToSignatureDeclarationHelper(signature, SyntaxKindConstructorType, context)
						return signatureNode
					}
				}
				abstractSignatures := filter(resolved.constructSignatures, func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
					return !!(signature.flags & SignatureFlagsAbstract)
				})
				if some(abstractSignatures) {
					types := map_(abstractSignatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
						return getOrCreateTypeFromSignature(s)
					})
					typeElementCount := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): resolved.callSignatures.length +                         (resolved.constructSignatures.length - abstractSignatures.length) +                         resolved.indexInfos.length +                         // exclude `prototype` when writing a class expression as a type literal, as per                         // the logic in `createTypeNodesFromResolvedType`.                         (context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral ?                             countWhere(resolved.properties, p => !(p.flags & SymbolFlags.Prototype)) :                             length(resolved.properties)) */ TODO
					if typeElementCount {
						types.push(getResolvedTypeWithoutAbstractConstructSignatures(resolved))
					}
					return typeToTypeNodeHelper(getIntersectionType(types), context)
				}
				restoreFlags := saveRestoreFlags(context)
				context.flags |= NodeBuilderFlagsInObjectTypeLiteral
				members := createTypeNodesFromResolvedType(resolved)
				restoreFlags()
				typeLiteralNode := factory.createTypeLiteralNode(members)
				context.approximateLength += 2
				setEmitFlags(typeLiteralNode /* TODO(ConditionalExpression): (context.flags & NodeBuilderFlags.MultilineObjectLiterals) ? 0 : EmitFlags.SingleLine */, TODO)
				return typeLiteralNode
			}
			typeReferenceToTypeNode := func(type_ TypeReference) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
				var typeArguments []Type = getTypeArguments(type_)
				if type_.target == globalArrayType || type_.target == globalReadonlyArrayType {
					if context.flags & NodeBuilderFlagsWriteArrayAsGenericType {
						typeArgumentNode := typeToTypeNodeHelper( /* TODO(ElementAccessExpression): typeArguments[0] */ TODO, context)
						return factory.createTypeReferenceNode( /* TODO(ConditionalExpression): type.target === globalArrayType ? "Array" : "ReadonlyArray" */ TODO /* TODO(ArrayLiteralExpression): [typeArgumentNode] */, TODO)
					}
					elementType := typeToTypeNodeHelper( /* TODO(ElementAccessExpression): typeArguments[0] */ TODO, context)
					arrayType := factory.createArrayTypeNode(elementType)
					return /* TODO(ConditionalExpression): type.target === globalArrayType ? arrayType : factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, arrayType) */ TODO
				} else if type_.target.objectFlags & ObjectFlagsTuple {
					typeArguments = sameMap(typeArguments, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
						return removeMissingType(t, !!( /* TODO(ElementAccessExpression): (type.target as TupleType).elementFlags[i] */ TODO & ElementFlagsOptional))
					})
					if typeArguments.length > 0 {
						arity := getTypeReferenceArity(type_)
						tupleConstituentNodes := mapToTypeNodes(typeArguments.slice(0, arity), context)
						if tupleConstituentNodes {
							TODO_IDENTIFIER := type_.target
							/* TODO(ForStatement): for (let i = 0; i < tupleConstituentNodes.length; i++) {                                 const flags = (type.target as TupleType).elementFlags[i];                                 const labeledElementDeclaration = labeledElementDeclarations?.[i];                                  if (labeledElementDeclaration) {                                     tupleConstituentNodes[i] = factory.createNamedTupleMember(                                         flags & ElementFlags.Variable ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined,                                         factory.createIdentifier(unescapeLeadingUnderscores(getTupleElementLabel(labeledElementDeclaration))),                                         flags & ElementFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                         flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) :                                             tupleConstituentNodes[i],                                     );                                 }                                 else {                                     tupleConstituentNodes[i] = flags & ElementFlags.Variable ? factory.createRestTypeNode(flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i]) :                                         flags & ElementFlags.Optional ? factory.createOptionalTypeNode(tupleConstituentNodes[i]) :                                         tupleConstituentNodes[i];                                 }                             } */
							tupleTypeNode := setEmitFlags(factory.createTupleTypeNode(tupleConstituentNodes), EmitFlagsSingleLine)
							return /* TODO(ConditionalExpression): (type.target as TupleType).readonly ? factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, tupleTypeNode) : tupleTypeNode */ TODO
						}
					}
					if context.encounteredError || (context.flags & NodeBuilderFlagsAllowEmptyTuple) {
						tupleTypeNode := setEmitFlags(factory.createTupleTypeNode( /* TODO(ArrayLiteralExpression): [] */ TODO), EmitFlagsSingleLine)
						return /* TODO(ConditionalExpression): (type.target as TupleType).readonly ? factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, tupleTypeNode) : tupleTypeNode */ TODO
					}
					context.encounteredError = true
					return nil
				} else if context.flags&NodeBuilderFlagsWriteClassExpressionAsTypeLiteral && type_.symbol.valueDeclaration && isClassLike(type_.symbol.valueDeclaration) && !isValueSymbolAccessible(type_.symbol, context.enclosingDeclaration) {
					return createAnonymousTypeNode(type_)
				} else {
					outerTypeParameters := type_.target.outerTypeParameters
					i := 0
					var resultType /* TODO(UnionType): TypeReferenceNode | ImportTypeNode | undefined */ any
					if outerTypeParameters {
						length := outerTypeParameters.length
						for i < length {
							start := i
							parent := getParentSymbolOfTypeParameter( /* TODO(ElementAccessExpression): outerTypeParameters[i] */ TODO)
							// TODO: refactor do-while loop approximation
							for ok := true; ok; ok = i < length && getParentSymbolOfTypeParameter( /* TODO(ElementAccessExpression): outerTypeParameters[i] */ TODO) == parent {
								i++
							}
							if !rangeEquals(outerTypeParameters, typeArguments, start, i) {
								typeArgumentSlice := mapToTypeNodes(typeArguments.slice(start, i), context)
								restoreFlags := saveRestoreFlags(context)
								context.flags |= NodeBuilderFlagsForbidIndexedAccessSymbolReferences
								ref := symbolToTypeNode(parent, context, SymbolFlagsType, typeArgumentSlice)
								restoreFlags()
								resultType = /* TODO(ConditionalExpression): !resultType ? ref : appendReferenceToType(resultType, ref as TypeReferenceNode) */ TODO
							}
						}
					}
					var typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any
					if typeArguments.length > 0 {
						typeParameterCount := 0
						if type_.target.typeParameters {
							typeParameterCount = Math.min(type_.target.typeParameters.length, typeArguments.length)
							if isReferenceToType(type_, getGlobalIterableType(false)) || isReferenceToType(type_, getGlobalIterableIteratorType(false)) || isReferenceToType(type_, getGlobalAsyncIterableType(false)) || isReferenceToType(type_, getGlobalAsyncIterableIteratorType(false)) {
								if !type_.node || !isTypeReferenceNode(type_.node) || !type_.node.typeArguments || type_.node.typeArguments.length < typeParameterCount {
									for typeParameterCount > 0 {
										typeArgument := /* TODO(ElementAccessExpression): typeArguments[typeParameterCount - 1] */ TODO
										typeParameter := /* TODO(ElementAccessExpression): type.target.typeParameters[typeParameterCount - 1] */ TODO
										defaultType := getDefaultFromTypeParameter(typeParameter)
										if !defaultType || !isTypeIdenticalTo(typeArgument, defaultType) {
											break
										}
										typeParameterCount--
									}
								}
							}
						}
						typeArgumentNodes = mapToTypeNodes(typeArguments.slice(i, typeParameterCount), context)
					}
					restoreFlags := saveRestoreFlags(context)
					context.flags |= NodeBuilderFlagsForbidIndexedAccessSymbolReferences
					finalRef := symbolToTypeNode(type_.symbol, context, SymbolFlagsType, typeArgumentNodes)
					restoreFlags()
					return /* TODO(ConditionalExpression): !resultType ? finalRef : appendReferenceToType(resultType, finalRef as TypeReferenceNode) */ TODO
				}
			}
			appendReferenceToType := func(root /* TODO(UnionType): TypeReferenceNode | ImportTypeNode */ any, ref TypeReferenceNode) /* TODO(UnionType): TypeReferenceNode | ImportTypeNode */ any {
				if isImportTypeNode(root) {
					typeArguments := root.typeArguments
					qualifier := root.qualifier
					if qualifier {
						if isIdentifier(qualifier) {
							if typeArguments != getIdentifierTypeArguments(qualifier) {
								qualifier = setIdentifierTypeArguments(factory.cloneNode(qualifier), typeArguments)
							}
						} else {
							if typeArguments != getIdentifierTypeArguments(qualifier.right) {
								qualifier = factory.updateQualifiedName(qualifier, qualifier.left, setIdentifierTypeArguments(factory.cloneNode(qualifier.right), typeArguments))
							}
						}
					}
					typeArguments = ref.typeArguments
					ids := getAccessStack(ref)
					for _, id := range ids {
						qualifier = /* TODO(ConditionalExpression): qualifier ? factory.createQualifiedName(qualifier, id) : id */ TODO
					}
					return factory.updateImportTypeNode(root, root.argument, root.attributes, qualifier, typeArguments, root.isTypeOf)
				} else {
					typeArguments := root.typeArguments
					typeName := root.typeName
					if isIdentifier(typeName) {
						if typeArguments != getIdentifierTypeArguments(typeName) {
							typeName = setIdentifierTypeArguments(factory.cloneNode(typeName), typeArguments)
						}
					} else {
						if typeArguments != getIdentifierTypeArguments(typeName.right) {
							typeName = factory.updateQualifiedName(typeName, typeName.left, setIdentifierTypeArguments(factory.cloneNode(typeName.right), typeArguments))
						}
					}
					typeArguments = ref.typeArguments
					ids := getAccessStack(ref)
					for _, id := range ids {
						typeName = factory.createQualifiedName(typeName, id)
					}
					return factory.updateTypeReferenceNode(root, typeName, typeArguments)
				}
			}
			getAccessStack := func(ref TypeReferenceNode) []Identifier {
				state := ref.typeName
				ids := /* TODO(ArrayLiteralExpression): [] */ TODO
				for !isIdentifier(state) {
					ids.unshift(state.right)
					state = state.left
				}
				ids.unshift(state)
				return ids
			}
			createTypeNodesFromResolvedType := func(resolvedType ResolvedType) /* TODO(ArrayType): TypeElement[] */ any {
				if checkTruncationLength(context) {
					return /* TODO(ArrayLiteralExpression): [factory.createPropertySignature(/*modifiers* / undefined, "...", /*questionToken* / undefined, /*type* / undefined)] */ TODO
				}
				var typeElements []TypeElement = /* TODO(ArrayLiteralExpression): [] */ TODO
				for _, signature := range resolvedType.callSignatures {
					typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKindCallSignature, context))
				}
				for _, signature := range resolvedType.constructSignatures {
					if signature.flags & SignatureFlagsAbstract {
						continue
					}
					typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKindConstructSignature, context))
				}
				for _, info := range resolvedType.indexInfos {
					typeElements.push(indexInfoToIndexSignatureDeclarationHelper(info, context /* TODO(ConditionalExpression): resolvedType.objectFlags & ObjectFlags.ReverseMapped ? createElidedInformationPlaceholder(context) : undefined */, TODO))
				}
				properties := resolvedType.properties
				if !properties {
					return typeElements
				}
				i := 0
				for _, propertySymbol := range properties {
					i++
					if context.flags & NodeBuilderFlagsWriteClassExpressionAsTypeLiteral {
						if propertySymbol.flags & SymbolFlagsPrototype {
							continue
						}
						if getDeclarationModifierFlagsFromSymbol(propertySymbol)&(ModifierFlagsPrivate|ModifierFlagsProtected) && context.tracker.reportPrivateInBaseOfClassExpression {
							context.tracker.reportPrivateInBaseOfClassExpression(unescapeLeadingUnderscores(propertySymbol.escapedName))
						}
					}
					if checkTruncationLength(context) && ( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): i + 2 */ TODO < /* TODO(MinusToken): - */ /* TODO(BinaryExpression): properties.length - 1 */ TODO) {
						typeElements.push(factory.createPropertySignature(nil /* TODO(TemplateExpression): `... ${properties.length - i} more ...` */, TODO, nil, nil))
						addPropertyToElementList( /* TODO(ElementAccessExpression): properties[properties.length - 1] */ TODO, context, typeElements)
						break
					}
					addPropertyToElementList(propertySymbol, context, typeElements)
				}
				return /* TODO(ConditionalExpression): typeElements.length ? typeElements : undefined */ TODO
			}
		}
		createElidedInformationPlaceholder := func(context NodeBuilderContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeReferenceNode | import("/home/jabaile/work/TypeScript/src/compiler/types").KeywordTypeNode<import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.AnyKeyword> */ TODO {
			context.approximateLength += 3
			if !(context.flags & NodeBuilderFlagsNoTruncation) {
				return factory.createTypeReferenceNode(factory.createIdentifier("..."), nil)
			}
			return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
		}
		shouldUsePlaceholderForProperty := func(propertySymbol Symbol, context NodeBuilderContext) /* TODO inferred type boolean */ TODO {
			depth := 3
			return !!(getCheckFlags(propertySymbol) & CheckFlagsReverseMapped) && (contains(context.reverseMappedStack, propertySymbol) || ( /* TODO(ElementAccessExpression): context.reverseMappedStack?.[0] */ TODO && !(getObjectFlags(last(context.reverseMappedStack).links.propertyType) & ObjectFlagsAnonymous)) || isDeeplyNestedReverseMappedTypeProperty())
			isDeeplyNestedReverseMappedTypeProperty := func() /* TODO inferred type boolean */ TODO {
				if ( /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): context.reverseMappedStack?.length ?? 0 */ TODO) < depth {
					return false
				}
				/* TODO(ForStatement): for (let i = 0; i < depth; i++) {                     const prop = context.reverseMappedStack![context.reverseMappedStack!.length - 1 - i];                     if (prop.links.mappedType.symbol !== (propertySymbol as ReverseMappedSymbol).links.mappedType.symbol) {                         return false;                     }                 } */
				return true
			}
		}
		addPropertyToElementList := func(propertySymbol Symbol, context NodeBuilderContext, typeElements []TypeElement) {
			propertyIsReverseMapped := !!(getCheckFlags(propertySymbol) & CheckFlagsReverseMapped)
			propertyType := /* TODO(ConditionalExpression): shouldUsePlaceholderForProperty(propertySymbol, context) ?                 anyType : getNonMissingTypeOfSymbol(propertySymbol) */ TODO
			saveEnclosingDeclaration := context.enclosingDeclaration
			context.enclosingDeclaration = nil
			if context.tracker.canTrackSymbol && isLateBoundName(propertySymbol.escapedName) {
				if propertySymbol.declarations {
					decl := first(propertySymbol.declarations)
					if hasLateBindableName(decl) {
						if isBinaryExpression(decl) {
							name := getNameOfDeclaration(decl)
							if name && isElementAccessExpression(name) && isPropertyAccessEntityNameExpression(name.argumentExpression) {
								trackComputedName(name.argumentExpression, saveEnclosingDeclaration, context)
							}
						} else {
							trackComputedName(decl.name.expression, saveEnclosingDeclaration, context)
						}
					}
				} else {
					context.tracker.reportNonSerializableProperty(symbolToString(propertySymbol))
				}
			}
			context.enclosingDeclaration = propertySymbol.valueDeclaration || /* TODO(ElementAccessExpression): propertySymbol.declarations?.[0] */ TODO || saveEnclosingDeclaration
			propertyName := getPropertyNameNodeForSymbol(propertySymbol, context)
			context.enclosingDeclaration = saveEnclosingDeclaration
			context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): symbolName(propertySymbol).length + 1 */ TODO
			if propertySymbol.flags & SymbolFlagsAccessor {
				writeType := getWriteTypeOfSymbol(propertySymbol)
				if propertyType != writeType && !isErrorType(propertyType) && !isErrorType(writeType) {
					getterDeclaration := getDeclarationOfKind(propertySymbol, SyntaxKindGetAccessor)
					getterSignature := getSignatureFromDeclaration(getterDeclaration)
					typeElements.push(setCommentRange(context, signatureToSignatureDeclarationHelper(getterSignature, SyntaxKindGetAccessor, context /* TODO(ObjectLiteralExpression): { name: propertyName } */, TODO), getterDeclaration))
					setterDeclaration := getDeclarationOfKind(propertySymbol, SyntaxKindSetAccessor)
					setterSignature := getSignatureFromDeclaration(setterDeclaration)
					typeElements.push(setCommentRange(context, signatureToSignatureDeclarationHelper(setterSignature, SyntaxKindSetAccessor, context /* TODO(ObjectLiteralExpression): { name: propertyName } */, TODO), setterDeclaration))
					return
				}
			}
			optionalToken := /* TODO(ConditionalExpression): propertySymbol.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined */ TODO
			if propertySymbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod) && !getPropertiesOfObjectType(propertyType).length && !isReadonlySymbol(propertySymbol) {
				signatures := getSignaturesOfType(filterType(propertyType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !(t.flags & TypeFlagsUndefined)
				}), SignatureKindCall)
				for _, signature := range signatures {
					methodDeclaration := signatureToSignatureDeclarationHelper(signature, SyntaxKindMethodSignature, context /* TODO(ObjectLiteralExpression): { name: propertyName, questionToken: optionalToken } */, TODO)
					typeElements.push(preserveCommentsOn(methodDeclaration))
				}
				if signatures.length || !optionalToken {
					return
				}
			}
			var propertyTypeNode TypeNode
			if shouldUsePlaceholderForProperty(propertySymbol, context) {
				propertyTypeNode = createElidedInformationPlaceholder(context)
			} else {
				if propertyIsReverseMapped {
					/* TODO(ExpressionStatement): context.reverseMappedStack ||= []; */
					context.reverseMappedStack.push(propertySymbol)
				}
				propertyTypeNode = /* TODO(ConditionalExpression): propertyType ? serializeTypeForDeclaration(context, /*declaration* / undefined, propertyType, propertySymbol) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword) */ TODO
				if propertyIsReverseMapped {
					context.reverseMappedStack.pop()
				}
			}
			modifiers := /* TODO(ConditionalExpression): isReadonlySymbol(propertySymbol) ? [factory.createToken(SyntaxKind.ReadonlyKeyword)] : undefined */ TODO
			if modifiers {
				context.approximateLength += 9
			}
			propertySignature := factory.createPropertySignature(modifiers, propertyName, optionalToken, propertyTypeNode)
			typeElements.push(preserveCommentsOn(propertySignature))
			preserveCommentsOn := func(node T) /* TODO inferred type T */ TODO {
				jsdocPropertyTag := propertySymbol.declarations.find(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(TypePredicate): d is JSDocPropertyTag */ any {
					return d.kind == SyntaxKindJSDocPropertyTag
				})
				if jsdocPropertyTag {
					commentText := getTextOfJSDocComment(jsdocPropertyTag.comment)
					if commentText {
						setSyntheticLeadingComments(node /* TODO(ArrayLiteralExpression): [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }] */, TODO)
					}
				} else if propertySymbol.valueDeclaration {
					setCommentRange(context, node, propertySymbol.valueDeclaration)
				}
				return node
			}
		}
		setCommentRange := func(context NodeBuilderContext, node T, range_ Node) T {
			if context.enclosingFile && context.enclosingFile == getSourceFileOfNode(range_) {
				return setCommentRangeWorker(node, range_)
			}
			return node
		}
		mapToTypeNodes := func(types /* TODO(TypeOperator): readonly Type[] */ any, context NodeBuilderContext, isBareList bool) /* TODO(ArrayType): TypeNode[] */ any {
			if some(types) {
				if checkTruncationLength(context) {
					if !isBareList {
						return /* TODO(ArrayLiteralExpression): [factory.createTypeReferenceNode("...", /*typeArguments* / undefined)] */ TODO
					} else if types.length > 2 {
						return /* TODO(ArrayLiteralExpression): [                             typeToTypeNodeHelper(types[0], context),                             factory.createTypeReferenceNode(`... ${types.length - 2} more ...`, /*typeArguments* / undefined),                             typeToTypeNodeHelper(types[types.length - 1], context),                         ] */ TODO
					}
				}
				mayHaveNameCollisions := !(context.flags & NodeBuilderFlagsUseFullyQualifiedType)
				seenNames := /* TODO(ConditionalExpression): mayHaveNameCollisions ? createMultiMap<__String, [Type, number]>() : undefined */ TODO
				var result []TypeNode = /* TODO(ArrayLiteralExpression): [] */ TODO
				i := 0
				for _, type_ := range types {
					i++
					if checkTruncationLength(context) && ( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): i + 2 */ TODO < /* TODO(MinusToken): - */ /* TODO(BinaryExpression): types.length - 1 */ TODO) {
						result.push(factory.createTypeReferenceNode( /* TODO(TemplateExpression): `... ${types.length - i} more ...` */ TODO, nil))
						typeNode := typeToTypeNodeHelper( /* TODO(ElementAccessExpression): types[types.length - 1] */ TODO, context)
						if typeNode {
							result.push(typeNode)
						}
						break
					}
					context.approximateLength += 2
					typeNode := typeToTypeNodeHelper(type_, context)
					if typeNode {
						result.push(typeNode)
						if seenNames && isIdentifierTypeReference(typeNode) {
							seenNames.add(typeNode.typeName.escapedText /* TODO(ArrayLiteralExpression): [type, result.length - 1] */, TODO)
						}
					}
				}
				if seenNames {
					restoreFlags := saveRestoreFlags(context)
					context.flags |= NodeBuilderFlagsUseFullyQualifiedType
					seenNames.forEach(func(types /* TODO inferred type [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, number][] */ TODO) {
						if !arrayIsHomogeneous(types, func(TODO_IDENTIFIER /* TODO inferred type [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, number] */ TODO, TODO_IDENTIFIER /* TODO inferred type [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, number] */ TODO) /* TODO inferred type boolean */ TODO {
							return typesAreSameReference(a, b)
						}) {
							for _, TODO_IDENTIFIER := range types {
								/* TODO(ElementAccessExpression): result[resultIndex] */ TODO = typeToTypeNodeHelper(type_, context)
							}
						}
					})
					restoreFlags()
				}
				return result
			}
		}
		typesAreSameReference := func(a Type, b Type) bool {
			return a == b || !!a.symbol && a.symbol == b.symbol || !!a.aliasSymbol && a.aliasSymbol == b.aliasSymbol
		}
		indexInfoToIndexSignatureDeclarationHelper := func(indexInfo IndexInfo, context NodeBuilderContext, typeNode *TypeNode) IndexSignatureDeclaration {
			name := getNameFromIndexInfo(indexInfo) || "x"
			indexerTypeNode := typeToTypeNodeHelper(indexInfo.keyType, context)
			indexingParameter := factory.createParameterDeclaration(nil, nil, name, nil, indexerTypeNode, nil)
			if !typeNode {
				typeNode = typeToTypeNodeHelper(indexInfo.type_ || anyType, context)
			}
			if !indexInfo.type_ && !(context.flags & NodeBuilderFlagsAllowEmptyIndexInfoType) {
				context.encounteredError = true
			}
			context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): name.length + 4 */ TODO
			return factory.createIndexSignature( /* TODO(ConditionalExpression): indexInfo.isReadonly ? [factory.createToken(SyntaxKind.ReadonlyKeyword)] : undefined */ TODO /* TODO(ArrayLiteralExpression): [indexingParameter] */, TODO, typeNode)
		}
		type SignatureToSignatureDeclarationOptions struct {
			modifiers     []Modifier
			name          PropertyName
			questionToken QuestionToken
		}
		signatureToSignatureDeclarationHelper := func(signature Signature, kind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ any, context NodeBuilderContext, options SignatureToSignatureDeclarationOptions) SignatureDeclaration {
			var typeParameters /* TODO(ArrayType): TypeParameterDeclaration[] */ any
			var typeArguments /* TODO(ArrayType): TypeNode[] */ any
			expandedParams := /* TODO(ElementAccessExpression): getExpandedParameters(signature, /*skipUnionExpanding* / true)[0] */ TODO
			cleanup := enterNewScope(context, signature.declaration, expandedParams, signature.typeParameters, signature.parameters, signature.mapper)
			context.approximateLength += 3
			if context.flags&NodeBuilderFlagsWriteTypeArgumentsOfSignature && signature.target && signature.mapper && signature.target.typeParameters {
				typeArguments = signature.target.typeParameters.map_(func(parameter /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
					return typeToTypeNodeHelper(instantiateType(parameter, signature.mapper), context)
				})
			} else {
				typeParameters = signature.typeParameters && signature.typeParameters.map_(func(parameter /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ TODO {
					return typeParameterToDeclaration(parameter, context)
				})
			}
			restoreFlags := saveRestoreFlags(context)
			context.flags &= ~NodeBuilderFlagsSuppressAnyReturnType
			parameters := ( /* TODO(ConditionalExpression): some(expandedParams, p => p !== expandedParams[expandedParams.length - 1] && !!(getCheckFlags(p) & CheckFlags.RestParameter)) ? signature.parameters : expandedParams */ TODO).map_(func(parameter /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO {
				return symbolToParameterDeclaration(parameter, context, kind == SyntaxKindConstructor)
			})
			thisParameter := /* TODO(ConditionalExpression): context.flags & NodeBuilderFlags.OmitThisParameter ? undefined : tryGetThisParameterDeclaration(signature, context) */ TODO
			if thisParameter {
				parameters.unshift(thisParameter)
			}
			restoreFlags()
			returnTypeNode := serializeReturnTypeForSignature(context, signature)
			modifiers := options.modifiers
			if (kind == SyntaxKindConstructorType) && signature.flags&SignatureFlagsAbstract {
				flags := modifiersToFlags(modifiers)
				modifiers = factory.createModifiersFromModifierFlags(flags | ModifierFlagsAbstract)
			}
			node := /* TODO(ConditionalExpression): kind === SyntaxKind.CallSignature ? factory.createCallSignature(typeParameters, parameters, returnTypeNode) :                 kind === SyntaxKind.ConstructSignature ? factory.createConstructSignature(typeParameters, parameters, returnTypeNode) :                 kind === SyntaxKind.MethodSignature ? factory.createMethodSignature(modifiers, options?.name ?? factory.createIdentifier(""), options?.questionToken, typeParameters, parameters, returnTypeNode) :                 kind === SyntaxKind.MethodDeclaration ? factory.createMethodDeclaration(modifiers, /*asteriskToken* / undefined, options?.name ?? factory.createIdentifier(""), /*questionToken* / undefined, typeParameters, parameters, returnTypeNode, /*body* / undefined) :                 kind === SyntaxKind.Constructor ? factory.createConstructorDeclaration(modifiers, parameters, /*body* / undefined) :                 kind === SyntaxKind.GetAccessor ? factory.createGetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, returnTypeNode, /*body* / undefined) :                 kind === SyntaxKind.SetAccessor ? factory.createSetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, /*body* / undefined) :                 kind === SyntaxKind.IndexSignature ? factory.createIndexSignature(modifiers, parameters, returnTypeNode) :                 kind === SyntaxKind.JSDocFunctionType ? factory.createJSDocFunctionType(parameters, returnTypeNode) :                 kind === SyntaxKind.FunctionType ? factory.createFunctionTypeNode(typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) :                 kind === SyntaxKind.ConstructorType ? factory.createConstructorTypeNode(modifiers, typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) :                 kind === SyntaxKind.FunctionDeclaration ? factory.createFunctionDeclaration(modifiers, /*asteriskToken* / undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, /*body* / undefined) :                 kind === SyntaxKind.FunctionExpression ? factory.createFunctionExpression(modifiers, /*asteriskToken* / undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, factory.createBlock([])) :                 kind === SyntaxKind.ArrowFunction ? factory.createArrowFunction(modifiers, typeParameters, parameters, returnTypeNode, /*equalsGreaterThanToken* / undefined, factory.createBlock([])) :                 Debug.assertNever(kind) */ TODO
			if typeArguments {
				node.typeArguments = factory.createNodeArray(typeArguments)
			}
			if signature.declaration.kind == SyntaxKindJSDocSignature && signature.declaration.parent.kind == SyntaxKindJSDocOverloadTag {
				comment := getTextOfNode(signature.declaration.parent.parent, true).slice(2, -2).split(regexp.MustParse(`\r\n|\n|\r`)).map_(func(line /* TODO inferred type string */ TODO) /* TODO inferred type string */ TODO {
					return line.replace(regexp.MustParse(`^\s+`), " ")
				}).join("\n")
				addSyntheticLeadingComment(node, SyntaxKindMultiLineCommentTrivia, comment, true)
			}
			cleanup()
			return node
		}
		type IntroducesNewScopeNode /* TODO(UnionType): SignatureDeclaration | JSDocSignature | MappedTypeNode */ any
		isNewScopeNode := func(node Node) /* TODO(TypePredicate): node is IntroducesNewScopeNode */ any {
			return isFunctionLike(node) || isJSDocSignature(node) || isMappedTypeNode(node)
		}
		getTypeParametersInScope := func(node /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
			return /* TODO(ConditionalExpression): isFunctionLike(node) || isJSDocSignature(node) ? getSignatureFromDeclaration(node).typeParameters :                 isConditionalTypeNode(node) ? getInferTypeParameters(node) :                 [getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter))] */ TODO
		}
		getParametersInScope := func(node /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] | undefined */ TODO {
			return /* TODO(ConditionalExpression): isFunctionLike(node) || isJSDocSignature(node) ? getSignatureFromDeclaration(node).parameters : undefined */ TODO
		}
		enterNewScope := func(context NodeBuilderContext, declaration /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode | undefined */ any, expandedParams /* TODO(TypeOperator): readonly Symbol[] */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, originalParameters /* TODO(TypeOperator): readonly Symbol[] */ any, mapper TypeMapper) /* TODO inferred type () => void */ TODO {
			cleanupContext := cloneNodeBuilderContext(context)
			var cleanupParams /* TODO(ParenthesizedType): (() => void) */ any
			var cleanupTypeParams /* TODO(ParenthesizedType): (() => void) */ any
			oldEnclosingDecl := context.enclosingDeclaration
			oldMapper := context.mapper
			if mapper {
				context.mapper = mapper
			}
			if context.enclosingDeclaration && declaration {
				cleanupParams = /* TODO(ConditionalExpression): !some(expandedParams) ? undefined : pushFakeScope(                     "params",                     add => {                         if (!expandedParams) return;                         for (let pIndex = 0; pIndex < expandedParams.length; pIndex++) {                             const param = expandedParams[pIndex];                             const originalParam = originalParameters?.[pIndex];                             if (originalParameters && originalParam !== param) {                                 // Can't reference parameters that come from an expansion                                 add(param.escapedName, unknownSymbol);                                 // Can't reference the original expanded parameter either                                 if (originalParam) {                                     add(originalParam.escapedName, unknownSymbol);                                 }                             }                             else if (                                 !forEach(param.declarations, d => {                                     if (isParameter(d) && isBindingPattern(d.name)) {                                         bindPattern(d.name);                                         return true;                                     }                                     return undefined;                                     function bindPattern(p: BindingPattern): void {                                         forEach(p.elements, e => {                                             switch (e.kind) {                                                 case SyntaxKind.OmittedExpression:                                                     return;                                                 case SyntaxKind.BindingElement:                                                     return bindElement(e);                                                 default:                                                     return Debug.assertNever(e);                                             }                                         });                                     }                                     function bindElement(e: BindingElement): void {                                         if (isBindingPattern(e.name)) {                                             return bindPattern(e.name);                                         }                                         const symbol = getSymbolOfDeclaration(e);                                         add(symbol.escapedName, symbol);                                     }                                 })                             ) {                                 add(param.escapedName, param);                             }                         }                     },                 ) */ TODO
				if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && some(typeParameters) {
					cleanupTypeParams = pushFakeScope("typeParams", func(add /* TODO inferred type (name: import("/home/jabaile/work/TypeScript/src/compiler/types").__String, symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol) => void */ TODO) {
						for _, typeParam := range /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): typeParameters ?? emptyArray */ TODO {
							typeParamName := typeParameterToName(typeParam, context).escapedText
							add(typeParamName, typeParam.symbol)
						}
					})
				}
				pushFakeScope := func(kind /* TODO(UnionType): "params" | "typeParams" */ any, addAll func(addSymbol func(name __String, symbol Symbol))) /* TODO inferred type (() => void) | undefined */ TODO {
					Debug.assert(context.enclosingDeclaration)
					var existingFakeScope Node
					if getNodeLinks(context.enclosingDeclaration).fakeScopeForSignatureDeclaration == kind {
						existingFakeScope = context.enclosingDeclaration
					} else if context.enclosingDeclaration.parent && getNodeLinks(context.enclosingDeclaration.parent).fakeScopeForSignatureDeclaration == kind {
						existingFakeScope = context.enclosingDeclaration.parent
					}
					Debug.assertOptionalNode(existingFakeScope, isBlock)
					locals := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): existingFakeScope?.locals ?? createSymbolTable() */ TODO
					var newLocals /* TODO(ArrayType): __String[] */ any
					var oldLocals /* TODO(ArrayType): { name: __String; oldSymbol: Symbol; }[] */ any
					addAll(func(name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO, symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
						if existingFakeScope {
							oldSymbol := locals.get(name)
							if !oldSymbol {
								newLocals = append(newLocals, name)
							} else {
								oldLocals = append(oldLocals /* TODO(ObjectLiteralExpression): { name, oldSymbol } */, TODO)
							}
						}
						locals.set(name, symbol)
					})
					if !existingFakeScope {
						fakeScope := factory.createBlock(emptyArray)
						getNodeLinks(fakeScope).fakeScopeForSignatureDeclaration = kind
						fakeScope.locals = locals
						setParent(fakeScope, context.enclosingDeclaration)
						context.enclosingDeclaration = fakeScope
					} else {
						return /* TODO(FunctionExpression): function undo() {                             forEach(newLocals, s => locals.delete(s));                             forEach(oldLocals, s => locals.set(s.name, s.oldSymbol));                         } */ TODO
					}
				}
			}
			return func() {
				cleanupParams()
				cleanupTypeParams()
				cleanupContext()
				context.enclosingDeclaration = oldEnclosingDecl
				context.mapper = oldMapper
			}
		}
		tryGetThisParameterDeclaration := func(signature Signature, context NodeBuilderContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined */ TODO {
			if signature.thisParameter {
				return symbolToParameterDeclaration(signature.thisParameter, context)
			}
			if signature.declaration && isInJSFile(signature.declaration) {
				thisTag := getJSDocThisTag(signature.declaration)
				if thisTag && thisTag.typeExpression {
					return factory.createParameterDeclaration(nil, nil, "this", nil, typeToTypeNodeHelper(getTypeFromTypeNode(context, thisTag.typeExpression), context))
				}
			}
		}
		typeParameterToDeclarationWithConstraint := func(type_ TypeParameter, context NodeBuilderContext, constraintNode *TypeNode) TypeParameterDeclaration {
			restoreFlags := saveRestoreFlags(context)
			context.flags &= ~NodeBuilderFlagsWriteTypeParametersInQualifiedName
			modifiers := factory.createModifiersFromModifierFlags(getTypeParameterModifiers(type_))
			name := typeParameterToName(type_, context)
			defaultParameter := getDefaultFromTypeParameter(type_)
			defaultParameterNode := defaultParameter && typeToTypeNodeHelper(defaultParameter, context)
			restoreFlags()
			return factory.createTypeParameterDeclaration(modifiers, name, constraintNode, defaultParameterNode)
		}
		typeToTypeNodeHelperWithPossibleReusableTypeNode := func(type_ Type, typeNode *TypeNode, context NodeBuilderContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			return typeNode && tryReuseExistingNonParameterTypeNode(context, typeNode, type_) || typeToTypeNodeHelper(type_, context)
		}
		typeParameterToDeclaration := func(type_ TypeParameter, context NodeBuilderContext, constraint /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO /*  = getConstraintOfTypeParameter(type) */) TypeParameterDeclaration {
			constraintNode := constraint && typeToTypeNodeHelperWithPossibleReusableTypeNode(constraint, getConstraintDeclaration(type_), context)
			return typeParameterToDeclarationWithConstraint(type_, context, constraintNode)
		}
		typePredicateToTypePredicateNodeHelper := func(typePredicate TypePredicate, context NodeBuilderContext) TypePredicateNode {
			assertsModifier := /* TODO(ConditionalExpression): typePredicate.kind === TypePredicateKind.AssertsThis || typePredicate.kind === TypePredicateKind.AssertsIdentifier ?                 factory.createToken(SyntaxKind.AssertsKeyword) :                 undefined */ TODO
			parameterName := /* TODO(ConditionalExpression): typePredicate.kind === TypePredicateKind.Identifier || typePredicate.kind === TypePredicateKind.AssertsIdentifier ?                 setEmitFlags(factory.createIdentifier(typePredicate.parameterName), EmitFlags.NoAsciiEscaping) :                 factory.createThisTypeNode() */ TODO
			typeNode := typePredicate.type_ && typeToTypeNodeHelper(typePredicate.type_, context)
			return factory.createTypePredicateNode(assertsModifier, parameterName, typeNode)
		}
		getEffectiveParameterDeclaration := func(parameterSymbol Symbol) /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any {
			var parameterDeclaration /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any = getDeclarationOfKind(parameterSymbol, SyntaxKindParameter)
			if parameterDeclaration {
				return parameterDeclaration
			}
			if !isTransientSymbol(parameterSymbol) {
				return getDeclarationOfKind(parameterSymbol, SyntaxKindJSDocParameterTag)
			}
		}
		symbolToParameterDeclaration := func(parameterSymbol Symbol, context NodeBuilderContext, preserveModifierFlags bool) ParameterDeclaration {
			parameterDeclaration := getEffectiveParameterDeclaration(parameterSymbol)
			parameterType := getTypeOfSymbol(parameterSymbol)
			parameterTypeNode := serializeTypeForDeclaration(context, parameterDeclaration, parameterType, parameterSymbol)
			modifiers := /* TODO(ConditionalExpression): !(context.flags & NodeBuilderFlags.OmitParameterModifiers) && preserveModifierFlags && parameterDeclaration && canHaveModifiers(parameterDeclaration) ? map(getModifiers(parameterDeclaration), factory.cloneNode) : undefined */ TODO
			isRest := parameterDeclaration && isRestParameter(parameterDeclaration) || getCheckFlags(parameterSymbol)&CheckFlagsRestParameter
			dotDotDotToken := /* TODO(ConditionalExpression): isRest ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined */ TODO
			name := parameterToParameterDeclarationName(parameterSymbol, parameterDeclaration, context)
			isOptional := parameterDeclaration && isOptionalParameter(parameterDeclaration) || getCheckFlags(parameterSymbol)&CheckFlagsOptionalParameter
			questionToken := /* TODO(ConditionalExpression): isOptional ? factory.createToken(SyntaxKind.QuestionToken) : undefined */ TODO
			parameterNode := factory.createParameterDeclaration(modifiers, dotDotDotToken, name, questionToken, parameterTypeNode, nil)
			context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): symbolName(parameterSymbol).length + 3 */ TODO
			return parameterNode
		}
		parameterToParameterDeclarationName := func(parameterSymbol Symbol, parameterDeclaration /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any, context NodeBuilderContext) /* TODO inferred type string | import("/home/jabaile/work/TypeScript/src/compiler/types").BindingName */ TODO {
			return /* TODO(ConditionalExpression): parameterDeclaration ? parameterDeclaration.name ?                 parameterDeclaration.name.kind === SyntaxKind.Identifier ? setEmitFlags(factory.cloneNode(parameterDeclaration.name), EmitFlags.NoAsciiEscaping) :                     parameterDeclaration.name.kind === SyntaxKind.QualifiedName ? setEmitFlags(factory.cloneNode(parameterDeclaration.name.right), EmitFlags.NoAsciiEscaping) :                     cloneBindingName(parameterDeclaration.name) :                 symbolName(parameterSymbol) :                 symbolName(parameterSymbol) */ TODO
			cloneBindingName := func(node BindingName) BindingName {
				return elideInitializerAndSetEmitFlags(node)
				elideInitializerAndSetEmitFlags := func(node Node) Node {
					if context.tracker.canTrackSymbol && isComputedPropertyName(node) && isLateBindableName(node) {
						trackComputedName(node.expression, context.enclosingDeclaration, context)
					}
					visited := visitEachChildWorker(node, elideInitializerAndSetEmitFlags, nil, nil, elideInitializerAndSetEmitFlags)
					if isBindingElement(visited) {
						visited = factory.updateBindingElement(visited, visited.dotDotDotToken, visited.propertyName, visited.name, nil)
					}
					if !nodeIsSynthesized(visited) {
						visited = factory.cloneNode(visited)
					}
					return setEmitFlags(visited, EmitFlagsSingleLine|EmitFlagsNoAsciiEscaping)
				}
			}
		}
		trackComputedName := func(accessExpression EntityNameOrEntityNameExpression, enclosingDeclaration Node, context NodeBuilderContext) {
			if !context.tracker.canTrackSymbol {
				return
			}
			firstIdentifier := getFirstIdentifier(accessExpression)
			name := resolveName(firstIdentifier, firstIdentifier.escapedText, SymbolFlagsValue|SymbolFlagsExportValue, nil, true)
			if name {
				context.tracker.trackSymbol(name, enclosingDeclaration, SymbolFlagsValue)
			}
		}
		lookupSymbolChain := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			context.tracker.trackSymbol(symbol, context.enclosingDeclaration, meaning)
			return lookupSymbolChainWorker(symbol, context, meaning, yieldModuleSymbol)
		}
		lookupSymbolChainWorker := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			var chain []Symbol
			isTypeParameter := symbol.flags & SymbolFlagsTypeParameter
			if !isTypeParameter && (context.enclosingDeclaration || context.flags&NodeBuilderFlagsUseFullyQualifiedType) && !(context.internalFlags & InternalNodeBuilderFlagsDoNotIncludeSymbolChain) {
				chain = Debug.checkDefined(getSymbolChain(symbol, meaning, true))
				Debug.assert(chain && chain.length > 0)
			} else {
				chain = /* TODO(ArrayLiteralExpression): [symbol] */ TODO
			}
			return chain
			getSymbolChain := func(symbol Symbol, meaning SymbolFlags, endOfChain bool) /* TODO(ArrayType): Symbol[] */ any {
				accessibleSymbolChain := getAccessibleSymbolChain(symbol, context.enclosingDeclaration, meaning, !!(context.flags & NodeBuilderFlagsUseOnlyExternalAliasing))
				var parentSpecifiers [] /* TODO(StringKeyword): string */ any
				if !accessibleSymbolChain || needsQualification( /* TODO(ElementAccessExpression): accessibleSymbolChain[0] */ TODO, context.enclosingDeclaration /* TODO(ConditionalExpression): accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning) */, TODO) {
					parents := getContainersOfSymbol( /* TODO(ConditionalExpression): accessibleSymbolChain ? accessibleSymbolChain[0] : symbol */ TODO, context.enclosingDeclaration, meaning)
					if length(parents) {
						parentSpecifiers = parents.map_(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type string | undefined */ TODO {
							return /* TODO(ConditionalExpression): some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)                                 ? getSpecifierForModuleSymbol(symbol, context)                                 : undefined */ TODO
						})
						indices := parents.map_(func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type number */ TODO {
							return i
						})
						indices.sort(sortByBestName)
						sortedParents := indices.map_(func(i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
							return /* TODO(ElementAccessExpression): parents![i] */ TODO
						})
						for _, parent := range sortedParents {
							parentChain := getSymbolChain(parent, getQualifiedLeftMeaning(meaning), false)
							if parentChain {
								if parent.exports && parent.exports.get(InternalSymbolNameExportEquals) && getSymbolIfSameReference(parent.exports.get(InternalSymbolNameExportEquals), symbol) {
									accessibleSymbolChain = parentChain
									break
								}
								accessibleSymbolChain = parentChain.concat(accessibleSymbolChain || /* TODO(ArrayLiteralExpression): [getAliasForSymbolInContainer(parent, symbol) || symbol] */ TODO)
								break
							}
						}
					}
				}
				if accessibleSymbolChain {
					return accessibleSymbolChain
				}
				if endOfChain || !(symbol.flags & (SymbolFlagsTypeLiteral | SymbolFlagsObjectLiteral)) {
					if !endOfChain && !yieldModuleSymbol && !!forEach(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
						return
					}
					return /* TODO(ArrayLiteralExpression): [symbol] */ TODO
				}
				sortByBestName := func(a number, b number) /* TODO inferred type number */ TODO {
					specifierA := /* TODO(ElementAccessExpression): parentSpecifiers[a] */ TODO
					specifierB := /* TODO(ElementAccessExpression): parentSpecifiers[b] */ TODO
					if specifierA && specifierB {
						isBRelative := pathIsRelative(specifierB)
						if pathIsRelative(specifierA) == isBRelative {
							return /* TODO(MinusToken): - */ /* TODO(BinaryExpression): moduleSpecifiers.countPathComponents(specifierA) - moduleSpecifiers.countPathComponents(specifierB) */ TODO
						}
						if isBRelative {
							return -1
						}
						return 1
					}
					return 0
				}
			}
		}
		typeParametersToTypeParameterDeclarations := func(symbol Symbol, context NodeBuilderContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").NodeArray<import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration> | undefined */ TODO {
			var typeParameterNodes *NodeArray[TypeParameterDeclaration]
			targetSymbol := getTargetSymbol(symbol)
			if targetSymbol.flags & (SymbolFlagsClass | SymbolFlagsInterface | SymbolFlagsTypeAlias) {
				typeParameterNodes = factory.createNodeArray(map_(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol), func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ TODO {
					return typeParameterToDeclaration(tp, context)
				}))
			}
			return typeParameterNodes
		}
		lookupTypeParameterNodes := func(chain []Symbol, index number, context NodeBuilderContext) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode[] | readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration[] | undefined */ TODO {
			Debug.assert(chain && 0 <= index && index < chain.length)
			symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
			symbolId := getSymbolId(symbol)
			if context.typeParameterSymbolList.has(symbolId) {
				return nil
			}
			if context.mustCreateTypeParameterSymbolList {
				context.mustCreateTypeParameterSymbolList = false
				context.typeParameterSymbolList = /* TODO(NewExpression): new Set(context.typeParameterSymbolList) */ TODO
			}
			context.typeParameterSymbolList.add(symbolId)
			var typeParameterNodes /* TODO(UnionType): readonly TypeNode[] | readonly TypeParameterDeclaration[] | undefined */ any
			if context.flags&NodeBuilderFlagsWriteTypeParametersInQualifiedName && index < ( /* TODO(MinusToken): - */ /* TODO(BinaryExpression): chain.length - 1 */ TODO) {
				parentSymbol := symbol
				nextSymbol := /* TODO(ElementAccessExpression): chain[index + 1] */ TODO
				if getCheckFlags(nextSymbol) & CheckFlagsInstantiated {
					params := getTypeParametersOfClassOrInterface( /* TODO(ConditionalExpression): parentSymbol.flags & SymbolFlags.Alias ? resolveAlias(parentSymbol) : parentSymbol */ TODO)
					typeParameterNodes = mapToTypeNodes(map_(params, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
						return getMappedType(t, (nextSymbol).links.mapper)
					}), context)
				} else {
					typeParameterNodes = typeParametersToTypeParameterDeclarations(symbol, context)
				}
			}
			return typeParameterNodes
		}
		getTopmostIndexedAccessType := func(top IndexedAccessTypeNode) IndexedAccessTypeNode {
			if isIndexedAccessTypeNode(top.objectType) {
				return getTopmostIndexedAccessType(top.objectType)
			}
			return top
		}
		getSpecifierForModuleSymbol := func(symbol Symbol, context NodeBuilderContext, overrideImportMode ResolutionMode) /* TODO inferred type string */ TODO {
			file := getDeclarationOfKind(symbol, SyntaxKindSourceFile)
			if !file {
				equivalentFileSymbol := firstDefined(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
					return getFileSymbolIfFileSymbolExportEqualsContainer(d, symbol)
				})
				if equivalentFileSymbol {
					file = getDeclarationOfKind(equivalentFileSymbol, SyntaxKindSourceFile)
				}
			}
			if file && file.moduleName != nil {
				return file.moduleName
			}
			if !file {
				if ambientModuleSymbolRegex.test(symbol.escapedName) {
					return (symbol.escapedName).substring(1 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): (symbol.escapedName as string).length - 1 */, TODO)
				}
			}
			if !context.enclosingFile || !context.tracker.moduleResolverHost {
				if ambientModuleSymbolRegex.test(symbol.escapedName) {
					return (symbol.escapedName).substring(1 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): (symbol.escapedName as string).length - 1 */, TODO)
				}
				return getSourceFileOfNode(getNonAugmentationDeclaration(symbol)).fileName
			}
			enclosingDeclaration := getOriginalNode(context.enclosingDeclaration)
			originalModuleSpecifier := /* TODO(ConditionalExpression): canHaveModuleSpecifier(enclosingDeclaration) ? tryGetModuleSpecifierFromDeclaration(enclosingDeclaration) : undefined */ TODO
			contextFile := context.enclosingFile
			resolutionMode := overrideImportMode || originalModuleSpecifier && host.getModeForUsageLocation(contextFile, originalModuleSpecifier) || contextFile && host.getDefaultResolutionModeForFile(contextFile)
			cacheKey := createModeAwareCacheKey(contextFile.path, resolutionMode)
			links := getSymbolLinks(symbol)
			specifier := links.specifierCache && links.specifierCache.get(cacheKey)
			if !specifier {
				isBundle := !!compilerOptions.outFile
				TODO_IDENTIFIER := context.tracker
				specifierCompilerOptions := /* TODO(ConditionalExpression): isBundle ? { ...compilerOptions, baseUrl: moduleResolverHost.getCommonSourceDirectory() } : compilerOptions */ TODO
				specifier = first(moduleSpecifiers.getModuleSpecifiers(symbol, checker, specifierCompilerOptions, contextFile, moduleResolverHost /* TODO(ObjectLiteralExpression): {                         importModuleSpecifierPreference: isBundle ? "non-relative" : "project-relative",                         importModuleSpecifierEnding: isBundle ? "minimal"                             : resolutionMode === ModuleKind.ESNext ? "js"                             : undefined,                     } */, TODO /* TODO(ObjectLiteralExpression): { overrideImportMode } */, TODO))
				/* TODO(ExpressionStatement): links.specifierCache ??= new Map(); */
				links.specifierCache.set(cacheKey, specifier)
			}
			return specifier
		}
		symbolToEntityNameNode := func(symbol Symbol) EntityName {
			identifier := factory.createIdentifier(unescapeLeadingUnderscores(symbol.escapedName))
			return /* TODO(ConditionalExpression): symbol.parent ? factory.createQualifiedName(symbolToEntityNameNode(symbol.parent), identifier) : identifier */ TODO
		}
		symbolToTypeNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, overrideTypeArguments []TypeNode) TypeNode {
			chain := lookupSymbolChain(symbol, context, meaning, !(context.flags & NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope))
			isTypeOf := meaning == SymbolFlagsValue
			if some( /* TODO(ElementAccessExpression): chain[0] */ TODO.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
				nonRootParts := /* TODO(ConditionalExpression): chain.length > 1 ? createAccessFromSymbolChain(chain, chain.length - 1, 1) : undefined */ TODO
				typeParameterNodes := overrideTypeArguments || lookupTypeParameterNodes(chain, 0, context)
				contextFile := getSourceFileOfNode(getOriginalNode(context.enclosingDeclaration))
				targetFile := getSourceFileOfModule( /* TODO(ElementAccessExpression): chain[0] */ TODO)
				var specifier /* TODO(StringKeyword): string */ any
				var attributes *ImportAttributes
				if getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNode16 || getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNodeNext {
					if targetFile.impliedNodeFormat == ModuleKindESNext && targetFile.impliedNodeFormat != contextFile.impliedNodeFormat {
						specifier = getSpecifierForModuleSymbol( /* TODO(ElementAccessExpression): chain[0] */ TODO, context, ModuleKindESNext)
						attributes = factory.createImportAttributes(factory.createNodeArray( /* TODO(ArrayLiteralExpression): [                                 factory.createImportAttribute(                                     factory.createStringLiteral("resolution-mode"),                                     factory.createStringLiteral("import"),                                 ),                             ] */ TODO))
					}
				}
				if !specifier {
					specifier = getSpecifierForModuleSymbol( /* TODO(ElementAccessExpression): chain[0] */ TODO, context)
				}
				if !(context.flags & NodeBuilderFlagsAllowNodeModulesRelativePaths) && getEmitModuleResolutionKind(compilerOptions) != ModuleResolutionKindClassic && specifier.includes("/node_modules/") {
					oldSpecifier := specifier
					if getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNode16 || getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNodeNext {
						swappedMode := /* TODO(ConditionalExpression): contextFile?.impliedNodeFormat === ModuleKind.ESNext ? ModuleKind.CommonJS : ModuleKind.ESNext */ TODO
						specifier = getSpecifierForModuleSymbol( /* TODO(ElementAccessExpression): chain[0] */ TODO, context, swappedMode)
						if specifier.includes("/node_modules/") {
							specifier = oldSpecifier
						} else {
							attributes = factory.createImportAttributes(factory.createNodeArray( /* TODO(ArrayLiteralExpression): [                                     factory.createImportAttribute(                                         factory.createStringLiteral("resolution-mode"),                                         factory.createStringLiteral(swappedMode === ModuleKind.ESNext ? "import" : "require"),                                     ),                                 ] */ TODO))
						}
					}
					if !attributes {
						context.encounteredError = true
						if context.tracker.reportLikelyUnsafeImportRequiredError {
							context.tracker.reportLikelyUnsafeImportRequiredError(oldSpecifier)
						}
					}
				}
				lit := factory.createLiteralTypeNode(factory.createStringLiteral(specifier))
				context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): specifier.length + 10 */ TODO
				if !nonRootParts || isEntityName(nonRootParts) {
					if nonRootParts {
						lastId := /* TODO(ConditionalExpression): isIdentifier(nonRootParts) ? nonRootParts : nonRootParts.right */ TODO
						setIdentifierTypeArguments(lastId, nil)
					}
					return factory.createImportTypeNode(lit, attributes, nonRootParts, typeParameterNodes, isTypeOf)
				} else {
					splitNode := getTopmostIndexedAccessType(nonRootParts)
					qualifier := (splitNode.objectType).typeName
					return factory.createIndexedAccessTypeNode(factory.createImportTypeNode(lit, attributes, qualifier, typeParameterNodes, isTypeOf), splitNode.indexType)
				}
			}
			entityName := createAccessFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): chain.length - 1 */, TODO, 0)
			if isIndexedAccessTypeNode(entityName) {
				return entityName
			}
			if isTypeOf {
				return factory.createTypeQueryNode(entityName)
			} else {
				lastId := /* TODO(ConditionalExpression): isIdentifier(entityName) ? entityName : entityName.right */ TODO
				lastTypeArgs := getIdentifierTypeArguments(lastId)
				setIdentifierTypeArguments(lastId, nil)
				return factory.createTypeReferenceNode(entityName, lastTypeArgs)
			}
			createAccessFromSymbolChain := func(chain []Symbol, index number, stopper number) /* TODO(UnionType): EntityName | IndexedAccessTypeNode */ any {
				typeParameterNodes := /* TODO(ConditionalExpression): index === (chain.length - 1) ? overrideTypeArguments : lookupTypeParameterNodes(chain, index, context) */ TODO
				symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
				parent := /* TODO(ElementAccessExpression): chain[index - 1] */ TODO
				var symbolName /* TODO(StringKeyword): string */ any
				if index == 0 {
					context.flags |= NodeBuilderFlagsInInitialEntityName
					symbolName = getNameOfSymbolAsWritten(symbol, context)
					context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (symbolName ? symbolName.length : 0) + 1 */ TODO
					context.flags ^= NodeBuilderFlagsInInitialEntityName
				} else {
					if parent && getExportsOfSymbol(parent) {
						exports := getExportsOfSymbol(parent)
						forEachEntry(exports, func(ex /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) /* TODO inferred type true | undefined */ TODO {
							if getSymbolIfSameReference(ex, symbol) && !isLateBoundName(name) && name != InternalSymbolNameExportEquals {
								symbolName = unescapeLeadingUnderscores(name)
								return true
							}
						})
					}
				}
				if symbolName == nil {
					name := firstDefined(symbol.declarations, getNameOfDeclaration)
					if name && isComputedPropertyName(name) && isEntityName(name.expression) {
						LHS := createAccessFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): index - 1 */, TODO, stopper)
						if isEntityName(LHS) {
							return factory.createIndexedAccessTypeNode(factory.createParenthesizedType(factory.createTypeQueryNode(LHS)), factory.createTypeQueryNode(name.expression))
						}
						return LHS
					}
					symbolName = getNameOfSymbolAsWritten(symbol, context)
				}
				context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): symbolName.length + 1 */ TODO
				if !(context.flags & NodeBuilderFlagsForbidIndexedAccessSymbolReferences) && parent && getMembersOfSymbol(parent) && getMembersOfSymbol(parent).get(symbol.escapedName) && getSymbolIfSameReference(getMembersOfSymbol(parent).get(symbol.escapedName), symbol) {
					LHS := createAccessFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): index - 1 */, TODO, stopper)
					if isIndexedAccessTypeNode(LHS) {
						return factory.createIndexedAccessTypeNode(LHS, factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)))
					} else {
						return factory.createIndexedAccessTypeNode(factory.createTypeReferenceNode(LHS, typeParameterNodes), factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)))
					}
				}
				identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
				if typeParameterNodes {
					setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
				}
				identifier.symbol = symbol
				if index > stopper {
					LHS := createAccessFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): index - 1 */, TODO, stopper)
					if !isEntityName(LHS) {
						return Debug.fail("Impossible construct - an export of an indexed access cannot be reachable")
					}
					return factory.createQualifiedName(LHS, identifier)
				}
				return identifier
			}
		}
		typeParameterShadowsOtherTypeParameterInScope := func(escapedName __String, context NodeBuilderContext, type_ TypeParameter) /* TODO inferred type boolean */ TODO {
			result := resolveName(context.enclosingDeclaration, escapedName, SymbolFlagsType, nil, false)
			if result && result.flags&SymbolFlagsTypeParameter {
				return result != type_.symbol
			}
			return false
		}
		typeParameterToName := func(type_ TypeParameter, context NodeBuilderContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier */ TODO {
			if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && context.typeParameterNames {
				cached := context.typeParameterNames.get(getTypeId(type_))
				if cached {
					return cached
				}
			}
			result := symbolToName(type_.symbol, context, SymbolFlagsType, true)
			if !(result.kind & SyntaxKindIdentifier) {
				return factory.createIdentifier("(Missing type parameter)")
			}
			decl := /* TODO(ElementAccessExpression): type.symbol?.declarations?.[0] */ TODO
			if decl && isTypeParameterDeclaration(decl) {
				result = setTextRange(context, result, decl.name)
			}
			if context.flags & NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
				rawtext := result.escapedText
				i := context.typeParameterNamesByTextNextNameCount.get(rawtext) || 0
				text := rawtext
				for context.typeParameterNamesByText.has(text) || typeParameterShadowsOtherTypeParameterInScope(text, context, type_) {
					i++
					text = /* TODO(TemplateExpression): `${rawtext}_${i}` */ TODO
				}
				if text != rawtext {
					typeArguments := getIdentifierTypeArguments(result)
					result = factory.createIdentifier(text)
					setIdentifierTypeArguments(result, typeArguments)
				}
				if context.mustCreateTypeParametersNamesLookups {
					context.mustCreateTypeParametersNamesLookups = false
					context.typeParameterNames = /* TODO(NewExpression): new Map(context.typeParameterNames) */ TODO
					context.typeParameterNamesByTextNextNameCount = /* TODO(NewExpression): new Map(context.typeParameterNamesByTextNextNameCount) */ TODO
					context.typeParameterNamesByText = /* TODO(NewExpression): new Set(context.typeParameterNamesByText) */ TODO
				}
				context.typeParameterNamesByTextNextNameCount.set(rawtext, i)
				context.typeParameterNames.set(getTypeId(type_), result)
				context.typeParameterNamesByText.add(text)
			}
			return result
		}
		// OVERLOAD: symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier /* TODO(LiteralType): true */ any) Identifier
		// OVERLOAD: symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier /* TODO(LiteralType): false */ any) EntityName
		symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier bool) EntityName {
			chain := lookupSymbolChain(symbol, context, meaning)
			if expectsIdentifier && chain.length != 1 && !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowQualifiedNameInPlaceOfIdentifier) {
				context.encounteredError = true
			}
			return createEntityNameFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): chain.length - 1 */, TODO)
			createEntityNameFromSymbolChain := func(chain []Symbol, index number) EntityName {
				typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
				symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
				if index == 0 {
					context.flags |= NodeBuilderFlagsInInitialEntityName
				}
				symbolName := getNameOfSymbolAsWritten(symbol, context)
				if index == 0 {
					context.flags ^= NodeBuilderFlagsInInitialEntityName
				}
				identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
				if typeParameterNodes {
					setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
				}
				identifier.symbol = symbol
				return /* TODO(ConditionalExpression): index > 0 ? factory.createQualifiedName(createEntityNameFromSymbolChain(chain, index - 1), identifier) : identifier */ TODO
			}
		}
		symbolToExpression := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ TODO {
			chain := lookupSymbolChain(symbol, context, meaning)
			return createExpressionFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): chain.length - 1 */, TODO)
			createExpressionFromSymbolChain := func(chain []Symbol, index number) Expression {
				typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
				symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
				if index == 0 {
					context.flags |= NodeBuilderFlagsInInitialEntityName
				}
				symbolName := getNameOfSymbolAsWritten(symbol, context)
				if index == 0 {
					context.flags ^= NodeBuilderFlagsInInitialEntityName
				}
				firstChar := symbolName.charCodeAt(0)
				if isSingleOrDoubleQuote(firstChar) && some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
					return factory.createStringLiteral(getSpecifierForModuleSymbol(symbol, context))
				}
				if index == 0 || canUsePropertyAccess(symbolName, languageVersion) {
					identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
					if typeParameterNodes {
						setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
					}
					identifier.symbol = symbol
					return /* TODO(ConditionalExpression): index > 0 ? factory.createPropertyAccessExpression(createExpressionFromSymbolChain(chain, index - 1), identifier) : identifier */ TODO
				} else {
					if firstChar == CharacterCodesopenBracket {
						symbolName = symbolName.substring(1 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): symbolName.length - 1 */, TODO)
						firstChar = symbolName.charCodeAt(0)
					}
					var expression *Expression
					if isSingleOrDoubleQuote(firstChar) && !(symbol.flags & SymbolFlagsEnumMember) {
						expression = factory.createStringLiteral(stripQuotes(symbolName).replace( /* TODO(RegularExpressionLiteral): /\\./g */ TODO, func(s /* TODO inferred type string */ TODO) /* TODO inferred type string */ TODO {
							return s.substring(1)
						}), firstChar == CharacterCodessingleQuote)
					} else if ( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + +symbolName */ TODO) == symbolName {
						expression = factory.createNumericLiteral(+symbolName)
					}
					if !expression {
						identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
						if typeParameterNodes {
							setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
						}
						identifier.symbol = symbol
						expression = identifier
					}
					return factory.createElementAccessExpression(createExpressionFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): index - 1 */, TODO), expression)
				}
			}
		}
		isStringNamed := func(d Declaration) /* TODO inferred type boolean */ TODO {
			name := getNameOfDeclaration(d)
			if !name {
				return false
			}
			if isComputedPropertyName(name) {
				type_ := checkExpression(name.expression)
				return !!(type_.flags & TypeFlagsStringLike)
			}
			if isElementAccessExpression(name) {
				type_ := checkExpression(name.argumentExpression)
				return !!(type_.flags & TypeFlagsStringLike)
			}
			return isStringLiteral(name)
		}
		isSingleQuotedStringNamed := func(d Declaration) /* TODO inferred type boolean */ TODO {
			name := getNameOfDeclaration(d)
			return !!(name && isStringLiteral(name) && (name.singleQuote || !nodeIsSynthesized(name) && startsWith(getTextOfNode(name, false), "'")))
		}
		getPropertyNameNodeForSymbol := func(symbol Symbol, context NodeBuilderContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | import("/home/jabaile/work/TypeScript/src/compiler/types").NumericLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName */ TODO {
			stringNamed := !!length(symbol.declarations) && every(symbol.declarations, isStringNamed)
			singleQuote := !!length(symbol.declarations) && every(symbol.declarations, isSingleQuotedStringNamed)
			isMethod := !!(symbol.flags & SymbolFlagsMethod)
			fromNameType := getPropertyNameNodeForSymbolFromNameType(symbol, context, singleQuote, stringNamed, isMethod)
			if fromNameType {
				return fromNameType
			}
			rawName := unescapeLeadingUnderscores(symbol.escapedName)
			return createPropertyNameNodeForIdentifierOrLiteral(rawName, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod)
		}
		getPropertyNameNodeForSymbolFromNameType := func(symbol Symbol, context NodeBuilderContext, singleQuote bool, stringNamed bool, isMethod bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | import("/home/jabaile/work/TypeScript/src/compiler/types").NumericLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName | undefined */ TODO {
			nameType := getSymbolLinks(symbol).nameType
			if nameType {
				if nameType.flags & TypeFlagsStringOrNumberLiteral {
					name := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + (nameType as StringLiteralType | NumberLiteralType).value */ TODO
					if !isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && (stringNamed || !isNumericLiteralName(name)) {
						return factory.createStringLiteral(name, !!singleQuote)
					}
					if isNumericLiteralName(name) && startsWith(name, "-") {
						return factory.createComputedPropertyName(factory.createPrefixUnaryExpression(SyntaxKindMinusToken, factory.createNumericLiteral(-name)))
					}
					return createPropertyNameNodeForIdentifierOrLiteral(name, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod)
				}
				if nameType.flags & TypeFlagsUniqueESSymbol {
					return factory.createComputedPropertyName(symbolToExpression((nameType).symbol, context, SymbolFlagsValue))
				}
			}
		}
		cloneNodeBuilderContext := func(context NodeBuilderContext) /* TODO inferred type () => void */ TODO {
			oldMustCreateTypeParameterSymbolList := context.mustCreateTypeParameterSymbolList
			oldMustCreateTypeParametersNamesLookups := context.mustCreateTypeParametersNamesLookups
			context.mustCreateTypeParameterSymbolList = true
			context.mustCreateTypeParametersNamesLookups = true
			oldTypeParameterNames := context.typeParameterNames
			oldTypeParameterNamesByText := context.typeParameterNamesByText
			oldTypeParameterNamesByTextNextNameCount := context.typeParameterNamesByTextNextNameCount
			oldTypeParameterSymbolList := context.typeParameterSymbolList
			return func() {
				context.typeParameterNames = oldTypeParameterNames
				context.typeParameterNamesByText = oldTypeParameterNamesByText
				context.typeParameterNamesByTextNextNameCount = oldTypeParameterNamesByTextNextNameCount
				context.typeParameterSymbolList = oldTypeParameterSymbolList
				context.mustCreateTypeParameterSymbolList = oldMustCreateTypeParameterSymbolList
				context.mustCreateTypeParametersNamesLookups = oldMustCreateTypeParametersNamesLookups
			}
		}
		getDeclarationWithTypeAnnotation := func(symbol Symbol, enclosingDeclaration Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration | undefined */ TODO {
			return symbol.declarations && find(symbol.declarations, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
				return !!getNonlocalEffectiveTypeAnnotationNode(s) && (!enclosingDeclaration || !!findAncestor(s, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
					return n == enclosingDeclaration
				}))
			})
		}
		existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount := func(existing TypeNode, type_ Type) /* TODO inferred type boolean */ TODO {
			if !(getObjectFlags(type_) & ObjectFlagsReference) {
				return true
			}
			if !isTypeReferenceNode(existing) {
				return true
			}
			/* TODO(ExpressionStatement): void getTypeFromTypeReference(existing); */
			symbol := getNodeLinks(existing).resolvedSymbol
			existingTarget := symbol && getDeclaredTypeOfSymbol(symbol)
			if !existingTarget || existingTarget != (type_).target {
				return true
			}
			return length(existing.typeArguments) >= getMinTypeArgumentCount((type_).target.typeParameters)
		}
		getEnclosingDeclarationIgnoringFakeScope := func(enclosingDeclaration Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO {
			for getNodeLinks(enclosingDeclaration).fakeScopeForSignatureDeclaration {
				enclosingDeclaration = enclosingDeclaration.parent
			}
			return enclosingDeclaration
		}
		serializeTypeForDeclaration := func(context NodeBuilderContext, declaration Declaration, type_ Type, symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			addUndefinedForParameter := declaration && (isParameter(declaration) || isJSDocParameterTag(declaration)) && requiresAddingImplicitUndefined(declaration, context.enclosingDeclaration)
			enclosingDeclaration := context.enclosingDeclaration
			restoreFlags := saveRestoreFlags(context)
			if declaration && hasInferredType(declaration) && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
				syntacticNodeBuilder.serializeTypeOfDeclaration(declaration, context)
			}
			context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
			if enclosingDeclaration && (!isErrorType(type_) || (context.internalFlags & InternalNodeBuilderFlagsAllowUnresolvedNames)) {
				declWithExistingAnnotation := /* TODO(ConditionalExpression): declaration && getNonlocalEffectiveTypeAnnotationNode(declaration)                     ? declaration                     : getDeclarationWithTypeAnnotation(symbol) */ TODO
				if declWithExistingAnnotation && !isFunctionLikeDeclaration(declWithExistingAnnotation) && !isGetAccessorDeclaration(declWithExistingAnnotation) {
					existing := getNonlocalEffectiveTypeAnnotationNode(declWithExistingAnnotation)
					addUndefined := addUndefinedForParameter || !!(symbol.flags&SymbolFlagsProperty && symbol.flags&SymbolFlagsOptional && isOptionalDeclaration(declWithExistingAnnotation) && (symbol).links.mappedType && containsNonMissingUndefinedType(type_))
					result := !isTypePredicateNode(existing) && tryReuseExistingTypeNode(context, existing, type_, declWithExistingAnnotation, addUndefined)
					if result {
						restoreFlags()
						return result
					}
				}
			}
			if type_.flags&TypeFlagsUniqueESSymbol && type_.symbol == symbol && (!context.enclosingDeclaration || some(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
				return getSourceFileOfNode(d) == getSourceFileOfNode(context.enclosingDeclaration)
			})) {
				context.flags |= NodeBuilderFlagsAllowUniqueESSymbolType
			}
			decl := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): declaration ?? symbol.valueDeclaration ?? symbol.declarations?.[0] */ TODO
			expr := /* TODO(ConditionalExpression): decl && isDeclarationWithPossibleInnerTypeNodeReuse(decl) ? getPossibleTypeNodeReuseExpression(decl) : undefined */ TODO
			result := expressionOrTypeToTypeNode(context, expr, type_, addUndefinedForParameter)
			restoreFlags()
			return result
		}
		typeNodeIsEquivalentToType := func(annotatedDeclaration Node, type_ Type, typeFromTypeNode Type) /* TODO inferred type boolean */ TODO {
			if typeFromTypeNode == type_ {
				return true
			}
			if annotatedDeclaration && (isParameter(annotatedDeclaration) || isPropertySignature(annotatedDeclaration) || isPropertyDeclaration(annotatedDeclaration)) && annotatedDeclaration.questionToken {
				return getTypeWithFacts(type_, TypeFactsNEUndefined) == typeFromTypeNode
			}
			return false
		}
		serializeReturnTypeForSignature := func(context NodeBuilderContext, signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			suppressAny := context.flags & NodeBuilderFlagsSuppressAnyReturnType
			restoreFlags := saveRestoreFlags(context)
			if suppressAny {
				context.flags &= ~NodeBuilderFlagsSuppressAnyReturnType
			}
			var returnTypeNode *TypeNode
			returnType := getReturnTypeOfSignature(signature)
			if returnType && !(suppressAny && isTypeAny(returnType)) {
				if signature.declaration && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
					syntacticNodeBuilder.serializeReturnTypeForSignature(signature.declaration, context)
				}
				context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
				returnTypeNode = serializeReturnTypeForSignatureWorker(context, signature)
			} else if !suppressAny {
				returnTypeNode = factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
			}
			restoreFlags()
			return returnTypeNode
		}
		serializeReturnTypeForSignatureWorker := func(context NodeBuilderContext, signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			typePredicate := getTypePredicateOfSignature(signature)
			type_ := getReturnTypeOfSignature(signature)
			if context.enclosingDeclaration && (!isErrorType(type_) || (context.internalFlags & InternalNodeBuilderFlagsAllowUnresolvedNames)) && signature.declaration && !nodeIsSynthesized(signature.declaration) {
				annotation := getNonlocalEffectiveReturnTypeAnnotationNode(signature.declaration)
				if annotation {
					result := tryReuseExistingTypeNode(context, annotation, type_, context.enclosingDeclaration)
					if result {
						return result
					}
				}
			}
			if typePredicate {
				return typePredicateToTypePredicateNodeHelper(typePredicate, context)
			}
			expr := signature.declaration && getPossibleTypeNodeReuseExpression(signature.declaration)
			return expressionOrTypeToTypeNode(context, expr, type_)
		}
		trackExistingEntityName := func(node T, context NodeBuilderContext) /* TODO inferred type { introducesError: boolean; node: T; sym?: undefined; } | { introducesError: boolean; node: T; sym: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined; } */ TODO {
			introducesError := false
			leftmost := getFirstIdentifier(node)
			if isInJSFile(node) && (isExportsIdentifier(leftmost) || isModuleExportsAccessExpression(leftmost.parent) || (isQualifiedName(leftmost.parent) && isModuleIdentifier(leftmost.parent.left) && isExportsIdentifier(leftmost.parent.right))) {
				introducesError = true
				return /* TODO(ObjectLiteralExpression): { introducesError, node } */ TODO
			}
			meaning := getMeaningOfEntityNameReference(node)
			var sym *Symbol
			if isThisIdentifier(leftmost) {
				sym = getSymbolOfDeclaration(getThisContainer(leftmost, false, false))
				if isSymbolAccessible(sym, leftmost, meaning, false).accessibility != SymbolAccessibilityAccessible {
					introducesError = true
					context.tracker.reportInaccessibleThisError()
				}
				return /* TODO(ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
			}
			sym = resolveEntityName(leftmost, meaning, true, true)
			if context.enclosingDeclaration && !(sym && sym.flags&SymbolFlagsTypeParameter) {
				sym = getExportSymbolOfValueSymbolIfExported(sym)
				symAtLocation := resolveEntityName(leftmost, meaning, true, true, context.enclosingDeclaration)
				if symAtLocation == unknownSymbol || (symAtLocation == nil && sym != nil) || (symAtLocation && sym && !getSymbolIfSameReference(getExportSymbolOfValueSymbolIfExported(symAtLocation), sym)) {
					if symAtLocation != unknownSymbol {
						context.tracker.reportInferenceFallback(node)
					}
					introducesError = true
					return /* TODO(ObjectLiteralExpression): { introducesError, node, sym } */ TODO
				} else {
					sym = symAtLocation
				}
			}
			if sym {
				if sym.flags&SymbolFlagsFunctionScopedVariable && sym.valueDeclaration {
					if isPartOfParameterDeclaration(sym.valueDeclaration) || isJSDocParameterTag(sym.valueDeclaration) {
						return /* TODO(ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
					}
				}
				if !(sym.flags & SymbolFlagsTypeParameter) && !isDeclarationName(node) && isSymbolAccessible(sym, context.enclosingDeclaration, meaning, false).accessibility != SymbolAccessibilityAccessible {
					context.tracker.reportInferenceFallback(node)
					introducesError = true
				} else {
					context.tracker.trackSymbol(sym, context.enclosingDeclaration, meaning)
				}
				return /* TODO(ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
			}
			return /* TODO(ObjectLiteralExpression): { introducesError, node } */ TODO
			attachSymbolToLeftmostIdentifier := func(node Node) Node {
				if node == leftmost {
					type_ := getDeclaredTypeOfSymbol(sym)
					name := /* TODO(ConditionalExpression): sym!.flags & SymbolFlags.TypeParameter ? typeParameterToName(type, context) : factory.cloneNode(node as Identifier) */ TODO
					name.symbol = sym
					return setTextRange(context, setEmitFlags(name, EmitFlagsNoAsciiEscaping), node)
				}
				updated := visitEachChildWorker(node, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO {
					return attachSymbolToLeftmostIdentifier(c)
				}, nil)
				if updated != node {
					setTextRange(context, updated, node)
				}
				return updated
			}
		}
		serializeTypeName := func(context NodeBuilderContext, node EntityName, isTypeOf bool, typeArguments []TypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			meaning := /* TODO(ConditionalExpression): isTypeOf ? SymbolFlags.Value : SymbolFlags.Type */ TODO
			symbol := resolveEntityName(node, meaning, true)
			if !symbol {
				return nil
			}
			resolvedSymbol := /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol */ TODO
			if isSymbolAccessible(symbol, context.enclosingDeclaration, meaning, false).accessibility != SymbolAccessibilityAccessible {
				return nil
			}
			return symbolToTypeNode(resolvedSymbol, context, meaning, typeArguments)
		}
		canReuseTypeNode := func(context NodeBuilderContext, existing TypeNode) /* TODO inferred type number | boolean */ TODO {
			if isInJSFile(existing) {
				if isLiteralImportTypeNode(existing) {
					/* TODO(ExpressionStatement): void getTypeFromImportTypeNode(existing); */
					nodeSymbol := getNodeLinks(existing).resolvedSymbol
					return (!nodeSymbol || !((!existing.isTypeOf && !(nodeSymbol.flags & SymbolFlagsType)) || !(length(existing.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))))
				}
			}
			if isThisTypeNode(existing) {
				if context.mapper == nil {
					return true
				}
				type_ := getTypeFromTypeNode(context, existing, true)
				return !!type_
			}
			if isTypeReferenceNode(existing) {
				if isConstTypeReference(existing) {
					return false
				}
				type_ := getTypeFromTypeReference(existing)
				symbol := getNodeLinks(existing).resolvedSymbol
				if !symbol {
					return false
				}
				if symbol.flags & SymbolFlagsTypeParameter {
					type_ := getDeclaredTypeOfSymbol(symbol)
					if context.mapper && getMappedType(type_, context.mapper) != type_ {
						return false
					}
				}
				if isInJSDoc(existing) {
					return existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type_) && !getIntendedTypeFromJSDocTypeReference(existing) && (symbol.flags & SymbolFlagsType)
				}
			}
			if isTypeOperatorNode(existing) && existing.operator == SyntaxKindUniqueKeyword && existing.type_.kind == SyntaxKindSymbolKeyword {
				effectiveEnclosingContext := context.enclosingDeclaration && getEnclosingDeclarationIgnoringFakeScope(context.enclosingDeclaration)
				return !!findAncestor(existing, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
					return n == effectiveEnclosingContext
				})
			}
			return true
		}
		serializeExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			type_ := getTypeFromTypeNode(context, typeNode)
			return typeToTypeNodeHelper(type_, context)
		}
		tryReuseExistingTypeNodeHelper := func(context NodeBuilderContext, existing TypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			if cancellationToken && cancellationToken.throwIfCancellationRequested {
				cancellationToken.throwIfCancellationRequested()
			}
			hadError := false
			TODO_IDENTIFIER := createRecoveryBoundary()
			transformed := visitNode(existing, visitExistingNodeTreeSymbols, isTypeNode)
			if !finalizeBoundary() {
				return nil
			}
			context.approximateLength += /* TODO(MinusToken): - */ /* TODO(BinaryExpression): existing.end - existing.pos */ TODO
			return transformed
			visitExistingNodeTreeSymbols := func(node Node) Node {
				if hadError {
					return node
				}
				recover := startRecoveryScope()
				onExitNewScope := /* TODO(ConditionalExpression): isNewScopeNode(node) ? onEnterNewScope(node) : undefined */ TODO
				result := visitExistingNodeTreeSymbolsWorker(node)
				onExitNewScope()
				if hadError {
					if isTypeNode(node) && !isTypePredicateNode(node) {
						recover()
						return serializeExistingTypeNode(context, node)
					}
					return node
				}
				return /* TODO(ConditionalExpression): result ? setTextRange(context, result, node) : undefined */ TODO
			}
			createRecoveryBoundary := func() /* TODO inferred type { startRecoveryScope: () => () => void; finalizeBoundary: () => boolean; } */ TODO {
				var trackedSymbols []TrackedSymbol
				var unreportedErrors []func()
				oldTracker := context.tracker
				oldTrackedSymbols := context.trackedSymbols
				context.trackedSymbols = nil
				oldEncounteredError := context.encounteredError
				context.tracker = /* TODO(NewExpression): new SymbolTrackerImpl(context, {                     ...oldTracker.inner,                     reportCyclicStructureError() {                         markError(() => oldTracker.reportCyclicStructureError());                     },                     reportInaccessibleThisError() {                         markError(() => oldTracker.reportInaccessibleThisError());                     },                     reportInaccessibleUniqueSymbolError() {                         markError(() => oldTracker.reportInaccessibleUniqueSymbolError());                     },                     reportLikelyUnsafeImportRequiredError(specifier) {                         markError(() => oldTracker.reportLikelyUnsafeImportRequiredError(specifier));                     },                     reportNonSerializableProperty(name) {                         markError(() => oldTracker.reportNonSerializableProperty(name));                     },                     trackSymbol(sym, decl, meaning) {                         (trackedSymbols ??= []).push([sym, decl, meaning]);                         return false;                     },                     moduleResolverHost: context.tracker.moduleResolverHost,                 }, context.tracker.moduleResolverHost) */ TODO
				return /* TODO(ObjectLiteralExpression): {                     startRecoveryScope,                     finalizeBoundary,                 } */ TODO
				markError := func(unreportedError func()) {
					hadError = true
					( /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): unreportedErrors ??= [] */ TODO).push(unreportedError)
				}
				startRecoveryScope := func() /* TODO inferred type () => void */ TODO {
					trackedSymbolsTop := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): trackedSymbols?.length ?? 0 */ TODO
					unreportedErrorsTop := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): unreportedErrors?.length ?? 0 */ TODO
					return func() {
						hadError = false
						if trackedSymbols {
							trackedSymbols.length = trackedSymbolsTop
						}
						if unreportedErrors {
							unreportedErrors.length = unreportedErrorsTop
						}
					}
				}
				finalizeBoundary := func() /* TODO inferred type boolean */ TODO {
					context.tracker = oldTracker
					context.trackedSymbols = oldTrackedSymbols
					context.encounteredError = oldEncounteredError
					unreportedErrors.forEach(func(fn /* TODO inferred type () => void */ TODO) {
						return fn()
					})
					if hadError {
						return false
					}
					trackedSymbols.forEach(func(TODO_IDENTIFIER /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TrackedSymbol */ TODO) /* TODO inferred type boolean */ TODO {
						return context.tracker.trackSymbol(symbol, enclosingDeclaration, meaning)
					})
					return true
				}
			}
			onEnterNewScope := func(node /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO inferred type () => void */ TODO {
				return enterNewScope(context, node, getParametersInScope(node), getTypeParametersInScope(node))
			}
			tryVisitSimpleTypeNode := func(node TypeNode) *TypeNode {
				innerNode := skipTypeParentheses(node)
				switch innerNode.kind {
				case SyntaxKindTypeReference:
					return tryVisitTypeReference(innerNode)
				case SyntaxKindTypeQuery:
					return tryVisitTypeQuery(innerNode)
				case SyntaxKindIndexedAccessType:
					return tryVisitIndexedAccess(innerNode)
				case SyntaxKindTypeOperator:
					typeOperatorNode := innerNode
					if typeOperatorNode.operator == SyntaxKindKeyOfKeyword {
						return tryVisitKeyOf(typeOperatorNode)
					}
				}
				return visitNode(node, visitExistingNodeTreeSymbols, isTypeNode)
			}
			tryVisitIndexedAccess := func(node IndexedAccessTypeNode) *TypeNode {
				resultObjectType := tryVisitSimpleTypeNode(node.objectType)
				if resultObjectType == nil {
					return nil
				}
				return factory.updateIndexedAccessTypeNode(node, resultObjectType, visitNode(node.indexType, visitExistingNodeTreeSymbols, isTypeNode))
			}
			tryVisitKeyOf := func(node TypeOperatorNode) *TypeNode {
				Debug.assertEqual(node.operator, SyntaxKindKeyOfKeyword)
				type_ := tryVisitSimpleTypeNode(node.type_)
				if type_ == nil {
					return nil
				}
				return factory.updateTypeOperatorNode(node, type_)
			}
			tryVisitTypeQuery := func(node TypeQueryNode) *TypeNode {
				TODO_IDENTIFIER := trackExistingEntityName(node.exprName, context)
				if !introducesError {
					return factory.updateTypeQueryNode(node, exprName, visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode))
				}
				serializedName := serializeTypeName(context, node.exprName, true)
				if serializedName {
					return setTextRange(context, serializedName, node.exprName)
				}
			}
			tryVisitTypeReference := func(node TypeReferenceNode) *TypeNode {
				if canReuseTypeNode(context, node) {
					TODO_IDENTIFIER := trackExistingEntityName(node.typeName, context)
					typeArguments := visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode)
					if !introducesError {
						updated := factory.updateTypeReferenceNode(node, newName, typeArguments)
						return setTextRange(context, updated, node)
					} else {
						serializedName := serializeTypeName(context, node.typeName, false, typeArguments)
						if serializedName {
							return setTextRange(context, serializedName, node.typeName)
						}
					}
				}
			}
			visitExistingNodeTreeSymbolsWorker := func(node Node) Node {
				if isJSDocTypeExpression(node) {
					return visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode)
				}
				if isJSDocAllType(node) || node.kind == SyntaxKindJSDocNamepathType {
					return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
				}
				if isJSDocUnknownType(node) {
					return factory.createKeywordTypeNode(SyntaxKindUnknownKeyword)
				}
				if isJSDocNullableType(node) {
					return factory.createUnionTypeNode( /* TODO(ArrayLiteralExpression): [visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)!, factory.createLiteralTypeNode(factory.createNull())] */ TODO)
				}
				if isJSDocOptionalType(node) {
					return factory.createUnionTypeNode( /* TODO(ArrayLiteralExpression): [visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)!, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)] */ TODO)
				}
				if isJSDocNonNullableType(node) {
					return visitNode(node.type_, visitExistingNodeTreeSymbols)
				}
				if isJSDocVariadicType(node) {
					return factory.createArrayTypeNode(visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode))
				}
				if isJSDocTypeLiteral(node) {
					return factory.createTypeLiteralNode(map_(node.jsDocPropertyTags, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocPropertyLikeTag */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").PropertySignature */ TODO {
						name := visitNode( /* TODO(ConditionalExpression): isIdentifier(t.name) ? t.name : t.name.right */ TODO, visitExistingNodeTreeSymbols, isIdentifier)
						typeViaParent := getTypeOfPropertyOfType(getTypeFromTypeNode(context, node), name.escapedText)
						overrideTypeNode := /* TODO(ConditionalExpression): typeViaParent && t.typeExpression && getTypeFromTypeNode(context, t.typeExpression.type) !== typeViaParent ? typeToTypeNodeHelper(typeViaParent, context) : undefined */ TODO
						return factory.createPropertySignature(nil, name /* TODO(ConditionalExpression): t.isBracketed || t.typeExpression && isJSDocOptionalType(t.typeExpression.type) ? factory.createToken(SyntaxKind.QuestionToken) : undefined */, TODO, overrideTypeNode || (t.typeExpression && visitNode(t.typeExpression.type_, visitExistingNodeTreeSymbols, isTypeNode)) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
					}))
				}
				if isTypeReferenceNode(node) && isIdentifier(node.typeName) && node.typeName.escapedText == "" {
					return setOriginalNode(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), node)
				}
				if (isExpressionWithTypeArguments(node) || isTypeReferenceNode(node)) && isJSDocIndexSignature(node) {
					return factory.createTypeLiteralNode( /* TODO(ArrayLiteralExpression): [factory.createIndexSignature(                         /*modifiers* / undefined,                         [factory.createParameterDeclaration(                             /*modifiers* / undefined,                             /*dotDotDotToken* / undefined,                             "x",                             /*questionToken* / undefined,                             visitNode(node.typeArguments![0], visitExistingNodeTreeSymbols, isTypeNode),                         )],                         visitNode(node.typeArguments![1], visitExistingNodeTreeSymbols, isTypeNode),                     )] */ TODO)
				}
				if isJSDocFunctionType(node) {
					if isJSDocConstructSignature(node) {
						var newTypeNode *TypeNode
						return factory.createConstructorTypeNode(nil, visitNodes(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), mapDefined(node.parameters, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined */ TODO {
							return /* TODO(ConditionalExpression): p.name && isIdentifier(p.name) && p.name.escapedText === "new" ? (newTypeNode = p.type, undefined) : factory.createParameterDeclaration(                                     /*modifiers* / undefined,                                     getEffectiveDotDotDotForParameter(p),                                     setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p),                                     factory.cloneNode(p.questionToken),                                     visitNode(p.type, visitExistingNodeTreeSymbols, isTypeNode),                                     /*initializer* / undefined,                                 ) */ TODO
						}), visitNode(newTypeNode || node.type_, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
					} else {
						return factory.createFunctionTypeNode(visitNodes(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), map_(node.parameters, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO {
							return factory.createParameterDeclaration(nil, getEffectiveDotDotDotForParameter(p), setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p), factory.cloneNode(p.questionToken), visitNode(p.type_, visitExistingNodeTreeSymbols, isTypeNode), nil)
						}), visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
					}
				}
				if isThisTypeNode(node) {
					if canReuseTypeNode(context, node) {
						return node
					}
					hadError = true
					return node
				}
				if isTypeParameterDeclaration(node) {
					return factory.updateTypeParameterDeclaration(node, visitNodes(node.modifiers, visitExistingNodeTreeSymbols, isModifier), setTextRange(context, typeParameterToName(getDeclaredTypeOfSymbol(getSymbolOfDeclaration(node)), context), node), visitNode(node.constraint, visitExistingNodeTreeSymbols, isTypeNode), visitNode(node.default_, visitExistingNodeTreeSymbols, isTypeNode))
				}
				if isIndexedAccessTypeNode(node) {
					result := tryVisitIndexedAccess(node)
					if !result {
						hadError = true
						return node
					}
					return result
				}
				if isTypeReferenceNode(node) {
					result := tryVisitTypeReference(node)
					if result {
						return result
					}
					hadError = true
					return node
				}
				if isLiteralImportTypeNode(node) {
					nodeSymbol := getNodeLinks(node).resolvedSymbol
					if isInJSDoc(node) && nodeSymbol && ((!node.isTypeOf && !(nodeSymbol.flags & SymbolFlagsType)) || !(length(node.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))) {
						return setTextRange(context, typeToTypeNodeHelper(getTypeFromTypeNode(context, node), context), node)
					}
					return factory.updateImportTypeNode(node, factory.updateLiteralTypeNode(node.argument, rewriteModuleSpecifier(node, node.argument.literal)), visitNode(node.attributes, visitExistingNodeTreeSymbols, isImportAttributes), visitNode(node.qualifier, visitExistingNodeTreeSymbols, isEntityName), visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode), node.isTypeOf)
				}
				if isNamedDeclaration(node) && node.name.kind == SyntaxKindComputedPropertyName && !isLateBindableName(node.name) {
					if !hasDynamicName(node) {
						return visitEachChild(node, visitExistingNodeTreeSymbols)
					}
					if !(context.internalFlags&InternalNodeBuilderFlagsAllowUnresolvedNames && isEntityNameExpression(node.name.expression) && checkComputedPropertyName(node.name).flags&TypeFlagsAny) {
						return nil
					}
				}
				if (isFunctionLike(node) && !node.type_) || (isPropertyDeclaration(node) && !node.type_ && !node.initializer) || (isPropertySignature(node) && !node.type_ && !node.initializer) || (isParameter(node) && !node.type_ && !node.initializer) {
					visited := visitEachChild(node, visitExistingNodeTreeSymbols)
					if visited == node {
						visited = setTextRange(context, factory.cloneNode(node), node)
					}
					(visited).type_ = factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
					if isParameter(node) {
						(visited).modifiers = nil
					}
					return visited
				}
				if isTypeQueryNode(node) {
					result := tryVisitTypeQuery(node)
					if !result {
						hadError = true
						return node
					}
					return result
				}
				if isComputedPropertyName(node) && isEntityNameExpression(node.expression) {
					TODO_IDENTIFIER := trackExistingEntityName(node.expression, context)
					if !introducesError {
						return factory.updateComputedPropertyName(node, result)
					} else {
						type_ := getWidenedType(getRegularTypeOfExpression(node.expression))
						computedPropertyNameType := typeToTypeNodeHelper(type_, context)
						var literal TODO
						if isLiteralTypeNode(computedPropertyNameType) {
							literal = computedPropertyNameType.literal
						} else {
							evaluated := evaluateEntityNameExpression(node.expression)
							literalNode := /* TODO(ConditionalExpression): typeof evaluated.value === "string" ? factory.createStringLiteral(evaluated.value, /*isSingleQuote* / undefined) :                                 typeof evaluated.value === "number" ? factory.createNumericLiteral(evaluated.value, /*numericLiteralFlags* / 0) :                                 undefined */ TODO
							if !literalNode {
								if isImportTypeNode(computedPropertyNameType) {
									trackComputedName(node.expression, context.enclosingDeclaration, context)
								}
								return node
							}
							literal = literalNode
						}
						if literal.kind == SyntaxKindStringLiteral && isIdentifierText(literal.text, getEmitScriptTarget(compilerOptions)) {
							return factory.createIdentifier(literal.text)
						}
						if literal.kind == SyntaxKindNumericLiteral && !literal.text.startsWith("-") {
							return literal
						}
						return factory.updateComputedPropertyName(node, literal)
					}
				}
				if isTypePredicateNode(node) {
					var parameterName TODO
					if isIdentifier(node.parameterName) {
						TODO_IDENTIFIER := trackExistingEntityName(node.parameterName, context)
						hadError = hadError || introducesError
						parameterName = result
					} else {
						parameterName = factory.cloneNode(node.parameterName)
					}
					return factory.updateTypePredicateNode(node, factory.cloneNode(node.assertsModifier), parameterName, visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode))
				}
				if isTupleTypeNode(node) || isTypeLiteralNode(node) || isMappedTypeNode(node) {
					visited := visitEachChild(node, visitExistingNodeTreeSymbols)
					clone := setTextRange(context /* TODO(ConditionalExpression): visited === node ? factory.cloneNode(node) : visited */, TODO, node)
					flags := getEmitFlags(clone)
					setEmitFlags(clone, flags|( /* TODO(ConditionalExpression): context.flags & NodeBuilderFlags.MultilineObjectLiterals && isTypeLiteralNode(node) ? 0 : EmitFlags.SingleLine */ TODO))
					return clone
				}
				if isStringLiteral(node) && !!(context.flags & NodeBuilderFlagsUseSingleQuotesForStringLiteralType) && !node.singleQuote {
					clone := factory.cloneNode(node)
					(clone).singleQuote = true
					return clone
				}
				if isConditionalTypeNode(node) {
					checkType := visitNode(node.checkType, visitExistingNodeTreeSymbols, isTypeNode)
					disposeScope := onEnterNewScope(node)
					extendType := visitNode(node.extendsType, visitExistingNodeTreeSymbols, isTypeNode)
					trueType := visitNode(node.trueType, visitExistingNodeTreeSymbols, isTypeNode)
					disposeScope()
					falseType := visitNode(node.falseType, visitExistingNodeTreeSymbols, isTypeNode)
					return factory.updateConditionalTypeNode(node, checkType, extendType, trueType, falseType)
				}
				if isTypeOperatorNode(node) {
					if node.operator == SyntaxKindUniqueKeyword && node.type_.kind == SyntaxKindSymbolKeyword {
						if !canReuseTypeNode(context, node) {
							hadError = true
							return node
						}
					} else if node.operator == SyntaxKindKeyOfKeyword {
						result := tryVisitKeyOf(node)
						if !result {
							hadError = true
							return node
						}
						return result
					}
				}
				return visitEachChild(node, visitExistingNodeTreeSymbols)
				// OVERLOAD: visitEachChild := func(node T, visitor Visitor) T
				// OVERLOAD: visitEachChild := func(node *T, visitor Visitor) *T
				visitEachChild := func(node *T, visitor Visitor) *T {
					nonlocalNode := !context.enclosingFile || context.enclosingFile != getSourceFileOfNode(node)
					return visitEachChildWorker(node, visitor, nil /* TODO(ConditionalExpression): nonlocalNode ? visitNodesWithoutCopyingPositions : undefined */, TODO)
				}
				visitNodesWithoutCopyingPositions := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
					result := visitNodes(nodes, visitor, test, start, count)
					if result {
						if result.pos != -1 || result.end != -1 {
							if result == nodes {
								result = factory.createNodeArray(nodes.slice(), nodes.hasTrailingComma)
							}
							setTextRangePosEnd(result, -1, -1)
						}
					}
					return result
				}
				getEffectiveDotDotDotForParameter := func(p ParameterDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DotDotDotToken | undefined */ TODO {
					return p.dotDotDotToken || ( /* TODO(ConditionalExpression): p.type && isJSDocVariadicType(p.type) ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined */ TODO)
				}
				getNameForJSDocFunctionParameter := func(p ParameterDeclaration, index number) /* TODO inferred type string */ TODO {
					return /* TODO(ConditionalExpression): p.name && isIdentifier(p.name) && p.name.escapedText === "this" ? "this"                         : getEffectiveDotDotDotForParameter(p) ? `args`                         : `arg${index}` */ TODO
				}
				rewriteModuleSpecifier := func(parent ImportTypeNode, lit StringLiteral) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral */ TODO {
					if context.bundled || context.enclosingFile != getSourceFileOfNode(lit) {
						name := lit.text
						nodeSymbol := getNodeLinks(node).resolvedSymbol
						meaning := /* TODO(ConditionalExpression): parent.isTypeOf ? SymbolFlags.Value : SymbolFlags.Type */ TODO
						parentSymbol := nodeSymbol && isSymbolAccessible(nodeSymbol, context.enclosingDeclaration, meaning, false).accessibility == SymbolAccessibilityAccessible && /* TODO(ElementAccessExpression): lookupSymbolChain(nodeSymbol, context, meaning, /*yieldModuleSymbol* / true)[0] */ TODO
						if parentSymbol && isExternalModuleSymbol(parentSymbol) {
							name = getSpecifierForModuleSymbol(parentSymbol, context)
						} else {
							targetFile := getExternalModuleFileFromDeclaration(parent)
							if targetFile {
								name = getSpecifierForModuleSymbol(targetFile.symbol, context)
							}
						}
						if name.includes("/node_modules/") {
							context.encounteredError = true
							if context.tracker.reportLikelyUnsafeImportRequiredError {
								context.tracker.reportLikelyUnsafeImportRequiredError(name)
							}
						}
						if name != lit.text {
							return setOriginalNode(factory.createStringLiteral(name), lit)
						}
					}
					return visitNode(lit, visitExistingNodeTreeSymbols, isStringLiteral)
				}
			}
		}
		symbolTableToDeclarationStatements := func(symbolTable SymbolTable, context NodeBuilderContext) []Statement {
			serializePropertySymbolForClass := makeSerializePropertySymbol(factory.createPropertyDeclaration, SyntaxKindMethodDeclaration, true)
			serializePropertySymbolForInterfaceWorker := makeSerializePropertySymbol(func(mods /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Modifier[] | undefined */ TODO, name /* TODO inferred type string | import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyName */ TODO, question /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").QuestionToken | undefined */ TODO, type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").PropertySignature */ TODO {
				return factory.createPropertySignature(mods, name, question, type_)
			}, SyntaxKindMethodSignature, false)
			enclosingDeclaration := context.enclosingDeclaration
			var results []Statement = /* TODO(ArrayLiteralExpression): [] */ TODO
			visitedSymbols := make(map[number]struct{})
			var deferredPrivatesStack []Map[SymbolId, Symbol] = /* TODO(ArrayLiteralExpression): [] */ TODO
			oldcontext := context
			context = /* TODO(ObjectLiteralExpression): {                 ...oldcontext,                 usedSymbolNames: new Set(oldcontext.usedSymbolNames),                 remappedSymbolNames: new Map(),                 remappedSymbolReferences: new Map(oldcontext.remappedSymbolReferences?.entries()),                 tracker: undefined!,             } */ TODO
			var tracker SymbolTracker = /* TODO(ObjectLiteralExpression): {                 ...oldcontext.tracker.inner,                 trackSymbol: (sym, decl, meaning) => {                     if (context.remappedSymbolNames?.has(getSymbolId(sym))) return false; // If the context has a remapped name for the symbol, it *should* mean it's been made visible                     const accessibleResult = isSymbolAccessible(sym, decl, meaning, /*shouldComputeAliasesToMakeVisible* / false);                     if (accessibleResult.accessibility === SymbolAccessibility.Accessible) {                         // Lookup the root symbol of the chain of refs we'll use to access it and serialize it                         const chain = lookupSymbolChainWorker(sym, context, meaning);                         if (!(sym.flags & SymbolFlags.Property)) {                             // Only include referenced privates in the same file. Weird JS aliases may expose privates                             // from other files - assume JS transforms will make those available via expected means                             const root = chain[0];                             const contextFile = getSourceFileOfNode(oldcontext.enclosingDeclaration);                             if (some(root.declarations, d => getSourceFileOfNode(d) === contextFile)) {                                 includePrivateSymbol(root);                             }                         }                     }                     else if (oldcontext.tracker.inner?.trackSymbol) {                         return oldcontext.tracker.inner.trackSymbol(sym, decl, meaning);                     }                     return false;                 },             } */ TODO
			context.tracker = /* TODO(NewExpression): new SymbolTrackerImpl(context, tracker, oldcontext.tracker.moduleResolverHost) */ TODO
			forEachEntry(symbolTable, func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
				baseName := unescapeLeadingUnderscores(name)
				/* TODO(ExpressionStatement): void getInternalSymbolName(symbol, baseName); */
			})
			addingDeclare := !context.bundled
			exportEquals := symbolTable.get(InternalSymbolNameExportEquals)
			if exportEquals && symbolTable.size > 1 && exportEquals.flags&(SymbolFlagsAlias|SymbolFlagsModule) {
				symbolTable = createSymbolTable()
				symbolTable.set(InternalSymbolNameExportEquals, exportEquals)
			}
			visitSymbolTable(symbolTable)
			return mergeRedundantStatements(results)
			isIdentifierAndNotUndefined := func(node Node) /* TODO(TypePredicate): node is Identifier */ any {
				return !!node && node.kind == SyntaxKindIdentifier
			}
			getNamesOfDeclaration := func(statement Statement) []Identifier {
				if isVariableStatement(statement) {
					return filter(map_(statement.declarationList.declarations, getNameOfDeclaration), isIdentifierAndNotUndefined)
				}
				return filter( /* TODO(ArrayLiteralExpression): [getNameOfDeclaration(statement as DeclarationStatement)] */ TODO, isIdentifierAndNotUndefined)
			}
			flattenExportAssignedNamespace := func(statements []Statement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
				exportAssignment := find(statements, isExportAssignment)
				nsIndex := findIndex(statements, isModuleDeclaration)
				ns := /* TODO(ConditionalExpression): nsIndex !== -1 ? statements[nsIndex] as ModuleDeclaration : undefined */ TODO
				if ns && exportAssignment && exportAssignment.isExportEquals && isIdentifier(exportAssignment.expression) && isIdentifier(ns.name) && idText(ns.name) == idText(exportAssignment.expression) && ns.body && isModuleBlock(ns.body) {
					excessExports := filter(statements, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO inferred type boolean */ TODO {
						return !!(getEffectiveModifierFlags(s) & ModifierFlagsExport)
					})
					name := ns.name
					body := ns.body
					if length(excessExports) {
						ns = factory.updateModuleDeclaration(ns, ns.modifiers, ns.name /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): body = factory.updateModuleBlock(                                 body,                                 factory.createNodeArray([                                     ...ns.body.statements,                                     factory.createExportDeclaration(                                         /*modifiers* / undefined,                                         /*isTypeOnly* / false,                                         factory.createNamedExports(map(flatMap(excessExports, e => getNamesOfDeclaration(e)), id => factory.createExportSpecifier(/*isTypeOnly* / false, /*propertyName* / undefined, id))),                                         /*moduleSpecifier* / undefined,                                     ),                                 ]),                             ) */, TODO)
						statements = /* TODO(ArrayLiteralExpression): [...statements.slice(0, nsIndex), ns, ...statements.slice(nsIndex + 1)] */ TODO
					}
					if !find(statements, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO inferred type boolean */ TODO {
						return s != ns && nodeHasName(s, name)
					}) {
						results = /* TODO(ArrayLiteralExpression): [] */ TODO
						mixinExportFlag := !some(body.statements, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO inferred type boolean */ TODO {
							return hasSyntacticModifier(s, ModifierFlagsExport) || isExportAssignment(s) || isExportDeclaration(s)
						})
						forEach(body.statements, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) {
							addResult(s /* TODO(ConditionalExpression): mixinExportFlag ? ModifierFlags.Export : ModifierFlags.None */, TODO)
						})
						statements = /* TODO(ArrayLiteralExpression): [...filter(statements, s => s !== ns && s !== exportAssignment), ...results] */ TODO
					}
				}
				return statements
			}
			mergeExportDeclarations := func(statements []Statement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
				exports := filter(statements, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO inferred type boolean */ TODO {
					return isExportDeclaration(d) && !d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause)
				})
				if length(exports) > 1 {
					nonExports := filter(statements, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO inferred type boolean */ TODO {
						return !isExportDeclaration(d) || !!d.moduleSpecifier || !d.exportClause
					})
					statements = /* TODO(ArrayLiteralExpression): [                         ...nonExports,                         factory.createExportDeclaration(                             /*modifiers* / undefined,                             /*isTypeOnly* / false,                             factory.createNamedExports(flatMap(exports, e => cast(e.exportClause, isNamedExports).elements)),                             /*moduleSpecifier* / undefined,                         ),                     ] */ TODO
				}
				reexports := filter(statements, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO inferred type boolean */ TODO {
					return isExportDeclaration(d) && !!d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause)
				})
				if length(reexports) > 1 {
					groups := group(reexports, func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration */ TODO) /* TODO inferred type string */ TODO {
						return /* TODO(ConditionalExpression): isStringLiteral(decl.moduleSpecifier!) ? ">" + decl.moduleSpecifier.text : ">" */ TODO
					})
					if groups.length != reexports.length {
						for _, group := range groups {
							if group.length > 1 {
								statements = /* TODO(ArrayLiteralExpression): [                                     ...filter(statements, s => !group.includes(s as ExportDeclaration)),                                     factory.createExportDeclaration(                                         /*modifiers* / undefined,                                         /*isTypeOnly* / false,                                         factory.createNamedExports(flatMap(group, e => cast(e.exportClause, isNamedExports).elements)),                                         group[0].moduleSpecifier,                                     ),                                 ] */ TODO
							}
						}
					}
				}
				return statements
			}
			inlineExportModifiers := func(statements []Statement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
				index := findIndex(statements, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO inferred type boolean */ TODO {
					return isExportDeclaration(d) && !d.moduleSpecifier && !d.attributes && !!d.exportClause && isNamedExports(d.exportClause)
				})
				if index >= 0 {
					exportDecl := /* TODO(ElementAccessExpression): statements[index] */ TODO
					replacements := mapDefined(exportDecl.exportClause.elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier | undefined */ TODO {
						if !e.propertyName && e.name.kind != SyntaxKindStringLiteral {
							name := e.name
							indices := indicesOf(statements)
							associatedIndices := filter(indices, func(i /* TODO inferred type number */ TODO) /* TODO inferred type boolean */ TODO {
								return nodeHasName( /* TODO(ElementAccessExpression): statements[i] */ TODO, name)
							})
							if length(associatedIndices) && every(associatedIndices, func(i /* TODO inferred type number */ TODO) /* TODO inferred type boolean */ TODO {
								return canHaveExportModifier( /* TODO(ElementAccessExpression): statements[i] */ TODO)
							}) {
								for _, index := range associatedIndices {
									/* TODO(ElementAccessExpression): statements[index] */ TODO = addExportModifier( /* TODO(ElementAccessExpression): statements[index] */ TODO)
								}
								return nil
							}
						}
						return e
					})
					if !length(replacements) {
						orderedRemoveItemAt(statements, index)
					} else {
						/* TODO(ElementAccessExpression): statements[index] */ TODO = factory.updateExportDeclaration(exportDecl, exportDecl.modifiers, exportDecl.isTypeOnly, factory.updateNamedExports(exportDecl.exportClause, replacements), exportDecl.moduleSpecifier, exportDecl.attributes)
					}
				}
				return statements
			}
			mergeRedundantStatements := func(statements []Statement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
				statements = flattenExportAssignedNamespace(statements)
				statements = mergeExportDeclarations(statements)
				statements = inlineExportModifiers(statements)
				if enclosingDeclaration && ((isSourceFile(enclosingDeclaration) && isExternalOrCommonJsModule(enclosingDeclaration)) || isModuleDeclaration(enclosingDeclaration)) && (!some(statements, isExternalModuleIndicator) || (!hasScopeMarker(statements) && some(statements, needsScopeMarker))) {
					statements.push(createEmptyExports(factory))
				}
				return statements
			}
			addExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ModuleDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableStatement | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportEqualsDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").EnumDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeAliasDeclaration */ TODO {
				flags := (getEffectiveModifierFlags(node) | ModifierFlagsExport) & ~ModifierFlagsAmbient
				return factory.replaceModifiers(node, flags)
			}
			removeExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ModuleDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableStatement | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportEqualsDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").EnumDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeAliasDeclaration */ TODO {
				flags := getEffectiveModifierFlags(node) & ~ModifierFlagsExport
				return factory.replaceModifiers(node, flags)
			}
			visitSymbolTable := func(symbolTable SymbolTable, suppressNewPrivateContext bool, propertyAsAlias bool) {
				if !suppressNewPrivateContext {
					deferredPrivatesStack.push( /* TODO(NewExpression): new Map() */ make(map[any]any))
				}
				symbolTable.forEach(func(symbol Symbol) {
					serializeSymbol(symbol, false, !!propertyAsAlias)
				})
				if !suppressNewPrivateContext {
					/* TODO(ElementAccessExpression): deferredPrivatesStack[deferredPrivatesStack.length - 1] */ TODO.forEach(func(symbol Symbol) {
						serializeSymbol(symbol, true, !!propertyAsAlias)
					})
					deferredPrivatesStack.pop()
				}
			}
			serializeSymbol := func(symbol Symbol, isPrivate bool, propertyAsAlias bool) {
				/* TODO(ExpressionStatement): void getPropertiesOfType(getTypeOfSymbol(symbol)); */
				visitedSym := getMergedSymbol(symbol)
				if visitedSymbols.has(getSymbolId(visitedSym)) {
					return
				}
				visitedSymbols.add(getSymbolId(visitedSym))
				skipMembershipCheck := !isPrivate
				if skipMembershipCheck || (!!length(symbol.declarations) && some(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
					return !!findAncestor(d, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
						return n == enclosingDeclaration
					})
				})) {
					scopeCleanup := cloneNodeBuilderContext(context)
					serializeSymbolWorker(symbol, isPrivate, propertyAsAlias)
					scopeCleanup()
				}
			}
			serializeSymbolWorker := func(symbol Symbol, isPrivate bool, propertyAsAlias bool, escapedSymbolName /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO /*  = symbol.escapedName */) {
				symbolName := unescapeLeadingUnderscores(escapedSymbolName)
				isDefault := escapedSymbolName == InternalSymbolNameDefault
				if isPrivate && !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) && isStringANonContextualKeyword(symbolName) && !isDefault {
					context.encounteredError = true
					return
				}
				needsPostExportDefault := isDefault && !!(symbol.flags&SymbolFlagsExportDoesNotSupportDefaultModifier || (symbol.flags&SymbolFlagsFunction && length(getPropertiesOfType(getTypeOfSymbol(symbol))))) && !(symbol.flags & SymbolFlagsAlias)
				needsExportDeclaration := !needsPostExportDefault && !isPrivate && isStringANonContextualKeyword(symbolName) && !isDefault
				if needsPostExportDefault || needsExportDeclaration {
					isPrivate = true
				}
				modifierFlags := ( /* TODO(ConditionalExpression): !isPrivate ? ModifierFlags.Export : 0 */ TODO) | ( /* TODO(ConditionalExpression): isDefault && !needsPostExportDefault ? ModifierFlags.Default : 0 */ TODO)
				isConstMergedWithNS := symbol.flags&SymbolFlagsModule && symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsFunctionScopedVariable|SymbolFlagsProperty) && escapedSymbolName != InternalSymbolNameExportEquals
				isConstMergedWithNSPrintableAsSignatureMerge := isConstMergedWithNS && isTypeRepresentableAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol)
				if symbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod) || isConstMergedWithNSPrintableAsSignatureMerge {
					serializeAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
				}
				if symbol.flags & SymbolFlagsTypeAlias {
					serializeTypeAlias(symbol, symbolName, modifierFlags)
				}
				if symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsFunctionScopedVariable|SymbolFlagsProperty|SymbolFlagsAccessor) && escapedSymbolName != InternalSymbolNameExportEquals && !(symbol.flags & SymbolFlagsPrototype) && !(symbol.flags & SymbolFlagsClass) && !(symbol.flags & SymbolFlagsMethod) && !isConstMergedWithNSPrintableAsSignatureMerge {
					if propertyAsAlias {
						createdExport := serializeMaybeAliasAssignment(symbol)
						if createdExport {
							needsExportDeclaration = false
							needsPostExportDefault = false
						}
					} else {
						type_ := getTypeOfSymbol(symbol)
						localName := getInternalSymbolName(symbol, symbolName)
						if type_.symbol && type_.symbol != symbol && type_.symbol.flags&SymbolFlagsFunction && some(type_.symbol.declarations, isFunctionExpressionOrArrowFunction) && (type_.symbol.members.size || type_.symbol.exports.size) {
							if !context.remappedSymbolReferences {
								context.remappedSymbolReferences = /* TODO(NewExpression): new Map() */ make(map[any]any)
							}
							context.remappedSymbolReferences.set(getSymbolId(type_.symbol), symbol)
							serializeSymbolWorker(type_.symbol, isPrivate, propertyAsAlias, escapedSymbolName)
							context.remappedSymbolReferences.delete(getSymbolId(type_.symbol))
						} else if !(symbol.flags & SymbolFlagsFunction) && isTypeRepresentableAsFunctionNamespaceMerge(type_, symbol) {
							serializeAsFunctionNamespaceMerge(type_, symbol, localName, modifierFlags)
						} else {
							flags := /* TODO(ConditionalExpression): !(symbol.flags & SymbolFlags.BlockScopedVariable)                                 ? symbol.parent?.valueDeclaration && isSourceFile(symbol.parent?.valueDeclaration)                                     ? NodeFlags.Const // exports are immutable in es6, which is what we emulate and check; so it's safe to mark all exports as `const` (there's no difference to consumers, but it allows unique symbol type declarations)                                     : undefined                                 : isConstantVariable(symbol)                                 ? NodeFlags.Const                                 : NodeFlags.Let */ TODO
							name := /* TODO(ConditionalExpression): (needsPostExportDefault || !(symbol.flags & SymbolFlags.Property)) ? localName : getUnusedName(localName, symbol) */ TODO
							var textRange Node = symbol.declarations && find(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
								return isVariableDeclaration(d)
							})
							if textRange && isVariableDeclarationList(textRange.parent) && textRange.parent.declarations.length == 1 {
								textRange = textRange.parent.parent
							}
							propertyAccessRequire := symbol.declarations.find(isPropertyAccessExpression)
							if propertyAccessRequire && isBinaryExpression(propertyAccessRequire.parent) && isIdentifier(propertyAccessRequire.parent.right) && type_.symbol.valueDeclaration && isSourceFile(type_.symbol.valueDeclaration) {
								alias := /* TODO(ConditionalExpression): localName === propertyAccessRequire.parent.right.escapedText ? undefined : propertyAccessRequire.parent.right */ TODO
								addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports( /* TODO(ArrayLiteralExpression): [factory.createExportSpecifier(/*isTypeOnly* / false, alias, localName)] */ TODO)), ModifierFlagsNone)
								context.tracker.trackSymbol(type_.symbol, context.enclosingDeclaration, SymbolFlagsValue)
							} else {
								statement := setTextRange(context, factory.createVariableStatement(nil, factory.createVariableDeclarationList( /* TODO(ArrayLiteralExpression): [                                             factory.createVariableDeclaration(name, /*exclamationToken* / undefined, serializeTypeForDeclaration(context, /*declaration* / undefined, type, symbol)),                                         ] */ TODO, flags)), textRange)
								addResult(statement /* TODO(ConditionalExpression): name !== localName ? modifierFlags & ~ModifierFlags.Export : modifierFlags */, TODO)
								if name != localName && !isPrivate {
									addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports( /* TODO(ArrayLiteralExpression): [factory.createExportSpecifier(/*isTypeOnly* / false, name, localName)] */ TODO)), ModifierFlagsNone)
									needsExportDeclaration = false
									needsPostExportDefault = false
								}
							}
						}
					}
				}
				if symbol.flags & SymbolFlagsEnum {
					serializeEnum(symbol, symbolName, modifierFlags)
				}
				if symbol.flags & SymbolFlagsClass {
					if symbol.flags&SymbolFlagsProperty && symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration.parent) && isClassExpression(symbol.valueDeclaration.parent.right) {
						serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
					} else {
						serializeAsClass(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
					}
				}
				if (symbol.flags&(SymbolFlagsValueModule|SymbolFlagsNamespaceModule) && (!isConstMergedWithNS || isTypeOnlyNamespace(symbol))) || isConstMergedWithNSPrintableAsSignatureMerge {
					serializeModule(symbol, symbolName, modifierFlags)
				}
				if symbol.flags&SymbolFlagsInterface && !(symbol.flags & SymbolFlagsClass) {
					serializeInterface(symbol, symbolName, modifierFlags)
				}
				if symbol.flags & SymbolFlagsAlias {
					serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
				}
				if symbol.flags&SymbolFlagsProperty && symbol.escapedName == InternalSymbolNameExportEquals {
					serializeMaybeAliasAssignment(symbol)
				}
				if symbol.flags & SymbolFlagsExportStar {
					if symbol.declarations {
						for _, node := range symbol.declarations {
							resolvedModule := resolveExternalModuleName(node, (node).moduleSpecifier)
							if !resolvedModule {
								continue
							}
							addResult(factory.createExportDeclaration(nil, (node).isTypeOnly, nil, factory.createStringLiteral(getSpecifierForModuleSymbol(resolvedModule, context))), ModifierFlagsNone)
						}
					}
				}
				if needsPostExportDefault {
					addResult(factory.createExportAssignment(nil, false, factory.createIdentifier(getInternalSymbolName(symbol, symbolName))), ModifierFlagsNone)
				} else if needsExportDeclaration {
					addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports( /* TODO(ArrayLiteralExpression): [factory.createExportSpecifier(/*isTypeOnly* / false, getInternalSymbolName(symbol, symbolName), symbolName)] */ TODO)), ModifierFlagsNone)
				}
			}
			includePrivateSymbol := func(symbol Symbol) {
				if some(symbol.declarations, isPartOfParameterDeclaration) {
					return
				}
				Debug.assertIsDefined( /* TODO(ElementAccessExpression): deferredPrivatesStack[deferredPrivatesStack.length - 1] */ TODO)
				getUnusedName(unescapeLeadingUnderscores(symbol.escapedName), symbol)
				isExternalImportAlias := !!(symbol.flags & SymbolFlagsAlias) && !some(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
					return !!findAncestor(d, isExportDeclaration) || isNamespaceExport(d) || (isImportEqualsDeclaration(d) && !isExternalModuleReference(d.moduleReference))
				})
				/* TODO(ElementAccessExpression): deferredPrivatesStack[isExternalImportAlias ? 0 : (deferredPrivatesStack.length - 1)] */ TODO.set(getSymbolId(symbol), symbol)
			}
			isExportingScope := func(enclosingDeclaration Node) /* TODO inferred type boolean */ TODO {
				return ((isSourceFile(enclosingDeclaration) && (isExternalOrCommonJsModule(enclosingDeclaration) || isJsonSourceFile(enclosingDeclaration))) || (isAmbientModule(enclosingDeclaration) && !isGlobalScopeAugmentation(enclosingDeclaration)))
			}
			addResult := func(node Statement, additionalModifierFlags ModifierFlags) {
				if canHaveModifiers(node) {
					var newModifierFlags ModifierFlags = ModifierFlagsNone
					enclosingDeclaration := context.enclosingDeclaration && ( /* TODO(ConditionalExpression): isJSDocTypeAlias(context.enclosingDeclaration) ? getSourceFileOfNode(context.enclosingDeclaration) : context.enclosingDeclaration */ TODO)
					if additionalModifierFlags&ModifierFlagsExport && enclosingDeclaration && (isExportingScope(enclosingDeclaration) || isModuleDeclaration(enclosingDeclaration)) && canHaveExportModifier(node) {
						newModifierFlags |= ModifierFlagsExport
					}
					if addingDeclare && !(newModifierFlags & ModifierFlagsExport) && (!enclosingDeclaration || !(enclosingDeclaration.flags & NodeFlagsAmbient)) && (isEnumDeclaration(node) || isVariableStatement(node) || isFunctionDeclaration(node) || isClassDeclaration(node) || isModuleDeclaration(node)) {
						newModifierFlags |= ModifierFlagsAmbient
					}
					if (additionalModifierFlags & ModifierFlagsDefault) && (isClassDeclaration(node) || isInterfaceDeclaration(node) || isFunctionDeclaration(node)) {
						newModifierFlags |= ModifierFlagsDefault
					}
					if newModifierFlags {
						node = factory.replaceModifiers(node, newModifierFlags|getEffectiveModifierFlags(node))
					}
				}
				results.push(node)
			}
			serializeTypeAlias := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				aliasType := getDeclaredTypeOfTypeAlias(symbol)
				typeParams := getSymbolLinks(symbol).typeParameters
				typeParamDecls := map_(typeParams, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ TODO {
					return typeParameterToDeclaration(p, context)
				})
				jsdocAliasDecl := symbol.declarations.find(isJSDocTypeAlias)
				commentText := getTextOfJSDocComment( /* TODO(ConditionalExpression): jsdocAliasDecl ? jsdocAliasDecl.comment || jsdocAliasDecl.parent.comment : undefined */ TODO)
				restoreFlags := saveRestoreFlags(context)
				context.flags |= NodeBuilderFlagsInTypeAlias
				oldEnclosingDecl := context.enclosingDeclaration
				context.enclosingDeclaration = jsdocAliasDecl
				typeNode := jsdocAliasDecl && jsdocAliasDecl.typeExpression && isJSDocTypeExpression(jsdocAliasDecl.typeExpression) && tryReuseExistingNonParameterTypeNode(context, jsdocAliasDecl.typeExpression.type_, aliasType, nil) || typeToTypeNodeHelper(aliasType, context)
				addResult(setSyntheticLeadingComments(factory.createTypeAliasDeclaration(nil, getInternalSymbolName(symbol, symbolName), typeParamDecls, typeNode) /* TODO(ConditionalExpression): !commentText ? [] : [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }] */, TODO), modifierFlags)
				restoreFlags()
				context.enclosingDeclaration = oldEnclosingDecl
			}
			serializeInterface := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				interfaceType := getDeclaredTypeOfClassOrInterface(symbol)
				localParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				typeParamDecls := map_(localParams, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ TODO {
					return typeParameterToDeclaration(p, context)
				})
				baseTypes := getBaseTypes(interfaceType)
				baseType := /* TODO(ConditionalExpression): length(baseTypes) ? getIntersectionType(baseTypes) : undefined */ TODO
				members := flatMap(getPropertiesOfType(interfaceType), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement[] */ TODO {
					return serializePropertySymbolForInterface(p, baseType)
				})
				callSignatures := serializeSignatures(SignatureKindCall, interfaceType, baseType, SyntaxKindCallSignature)
				constructSignatures := serializeSignatures(SignatureKindConstruct, interfaceType, baseType, SyntaxKindConstructSignature)
				indexSignatures := serializeIndexSignatures(interfaceType, baseType)
				heritageClauses := /* TODO(ConditionalExpression): !length(baseTypes) ? undefined : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, mapDefined(baseTypes, b => trySerializeAsTypeReference(b, SymbolFlags.Value)))] */ TODO
				addResult(factory.createInterfaceDeclaration(nil, getInternalSymbolName(symbol, symbolName), typeParamDecls, heritageClauses /* TODO(ArrayLiteralExpression): [...indexSignatures, ...constructSignatures, ...callSignatures, ...members] */, TODO), modifierFlags)
			}
			getNamespaceMembersForSerialization := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
				exports := arrayFrom(getExportsOfSymbol(symbol).values())
				merged := getMergedSymbol(symbol)
				if merged != symbol {
					membersSet := /* TODO(NewExpression): new Set(exports) */ TODO
					for _, exported := range getExportsOfSymbol(merged).values() {
						if !(getSymbolFlags(resolveSymbol(exported)) & SymbolFlagsValue) {
							membersSet.add(exported)
						}
					}
					exports = arrayFrom(membersSet)
				}
				return filter(exports, func(m /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
					return isNamespaceMember(m) && isIdentifierText(m.escapedName, ScriptTargetESNext)
				})
			}
			isTypeOnlyNamespace := func(symbol Symbol) /* TODO inferred type boolean */ TODO {
				return every(getNamespaceMembersForSerialization(symbol), func(m /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
					return !(getSymbolFlags(resolveSymbol(m)) & SymbolFlagsValue)
				})
			}
			serializeModule := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				members := getNamespaceMembersForSerialization(symbol)
				locationMap := arrayToMultiMap(members, func(m /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type "real" | "merged" */ TODO {
					return /* TODO(ConditionalExpression): m.parent && m.parent === symbol ? "real" : "merged" */ TODO
				})
				realMembers := locationMap.get("real") || emptyArray
				mergedMembers := locationMap.get("merged") || emptyArray
				if length(realMembers) {
					localName := getInternalSymbolName(symbol, symbolName)
					serializeAsNamespaceDeclaration(realMembers, localName, modifierFlags, !!(symbol.flags & (SymbolFlagsFunction | SymbolFlagsAssignment)))
				}
				if length(mergedMembers) {
					containingFile := getSourceFileOfNode(context.enclosingDeclaration)
					localName := getInternalSymbolName(symbol, symbolName)
					nsBody := factory.createModuleBlock( /* TODO(ArrayLiteralExpression): [factory.createExportDeclaration(                         /*modifiers* / undefined,                         /*isTypeOnly* / false,                         factory.createNamedExports(mapDefined(filter(mergedMembers, n => n.escapedName !== InternalSymbolName.ExportEquals), s => {                             const name = unescapeLeadingUnderscores(s.escapedName);                             const localName = getInternalSymbolName(s, name);                             const aliasDecl = s.declarations && getDeclarationOfAliasSymbol(s);                             if (containingFile && (aliasDecl ? containingFile !== getSourceFileOfNode(aliasDecl) : !some(s.declarations, d => getSourceFileOfNode(d) === containingFile))) {                                 context.tracker?.reportNonlocalAugmentation?.(containingFile, symbol, s);                                 return undefined;                             }                             const target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, /*dontRecursivelyResolve* / true);                             includePrivateSymbol(target || s);                             const targetName = target ? getInternalSymbolName(target, unescapeLeadingUnderscores(target.escapedName)) : localName;                             return factory.createExportSpecifier(/*isTypeOnly* / false, name === targetName ? undefined : targetName, name);                         })),                     )] */ TODO)
					addResult(factory.createModuleDeclaration(nil, factory.createIdentifier(localName), nsBody, NodeFlagsNamespace), ModifierFlagsNone)
				}
			}
			serializeEnum := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				addResult(factory.createEnumDeclaration(factory.createModifiersFromModifierFlags( /* TODO(ConditionalExpression): isConstEnumSymbol(symbol) ? ModifierFlags.Const : 0 */ TODO), getInternalSymbolName(symbol, symbolName), map_(filter(getPropertiesOfType(getTypeOfSymbol(symbol)), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
					return !!(p.flags & SymbolFlagsEnumMember)
				}), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EnumMember */ TODO {
					initializedValue := /* TODO(ConditionalExpression): p.declarations && p.declarations[0] && isEnumMember(p.declarations[0]) ? getConstantValue(p.declarations[0]) : undefined */ TODO
					return factory.createEnumMember(unescapeLeadingUnderscores(p.escapedName) /* TODO(ConditionalExpression): initializedValue === undefined ? undefined :                                     typeof initializedValue === "string" ? factory.createStringLiteral(initializedValue) :                                     factory.createNumericLiteral(initializedValue) */, TODO)
				})), modifierFlags)
			}
			serializeAsFunctionNamespaceMerge := func(type_ Type, symbol Symbol, localName string, modifierFlags ModifierFlags) {
				signatures := getSignaturesOfType(type_, SignatureKindCall)
				for _, sig := range signatures {
					decl := signatureToSignatureDeclarationHelper(sig, SyntaxKindFunctionDeclaration, context /* TODO(ObjectLiteralExpression): { name: factory.createIdentifier(localName) } */, TODO)
					addResult(setTextRange(context, decl, getSignatureTextRangeLocation(sig)), modifierFlags)
				}
				if !(symbol.flags&(SymbolFlagsValueModule|SymbolFlagsNamespaceModule) && !!symbol.exports && !!symbol.exports.size) {
					props := filter(getPropertiesOfType(type_), isNamespaceMember)
					serializeAsNamespaceDeclaration(props, localName, modifierFlags, true)
				}
			}
			getSignatureTextRangeLocation := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").SignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclarationList | import("/home/jabaile/work/TypeScript/src/compiler/types").CatchClause | import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocSignature | undefined */ TODO {
				if signature.declaration && signature.declaration.parent {
					if isBinaryExpression(signature.declaration.parent) && getAssignmentDeclarationKind(signature.declaration.parent) == AssignmentDeclarationKindProperty {
						return signature.declaration.parent
					}
					if isVariableDeclaration(signature.declaration.parent) && signature.declaration.parent.parent {
						return signature.declaration.parent.parent
					}
				}
				return signature.declaration
			}
			serializeAsNamespaceDeclaration := func(props []Symbol, localName string, modifierFlags ModifierFlags, suppressNewPrivateContext bool) {
				if length(props) {
					localVsRemoteMap := arrayToMultiMap(props, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type "local" | "remote" */ TODO {
						return /* TODO(ConditionalExpression): !length(p.declarations) || some(p.declarations, d => getSourceFileOfNode(d) === getSourceFileOfNode(context.enclosingDeclaration!)) ? "local" : "remote" */ TODO
					})
					localProps := localVsRemoteMap.get("local") || emptyArray
					fakespace := parseNodeFactory.createModuleDeclaration(nil, factory.createIdentifier(localName), factory.createModuleBlock( /* TODO(ArrayLiteralExpression): [] */ TODO), NodeFlagsNamespace)
					setParent(fakespace, enclosingDeclaration)
					fakespace.locals = createSymbolTable(props)
					fakespace.symbol = /* TODO(ElementAccessExpression): props[0] */ TODO.parent
					oldResults := results
					results = /* TODO(ArrayLiteralExpression): [] */ TODO
					oldAddingDeclare := addingDeclare
					addingDeclare = false
					subcontext := /* TODO(ObjectLiteralExpression): { ...context, enclosingDeclaration: fakespace } */ TODO
					oldContext := context
					context = subcontext
					visitSymbolTable(createSymbolTable(localProps), suppressNewPrivateContext, true)
					context = oldContext
					addingDeclare = oldAddingDeclare
					declarations := results
					results = oldResults
					defaultReplaced := map_(declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO {
						return /* TODO(ConditionalExpression): isExportAssignment(d) && !d.isExportEquals && isIdentifier(d.expression) ? factory.createExportDeclaration(                             /*modifiers* / undefined,                             /*isTypeOnly* / false,                             factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly* / false, d.expression, factory.createIdentifier(InternalSymbolName.Default))]),                         ) : d */ TODO
					})
					exportModifierStripped := /* TODO(ConditionalExpression): every(defaultReplaced, d => hasSyntacticModifier(d, ModifierFlags.Export)) ? map(defaultReplaced as Extract<HasModifiers, Statement>[], removeExportModifier) : defaultReplaced */ TODO
					fakespace = factory.updateModuleDeclaration(fakespace, fakespace.modifiers, fakespace.name, factory.createModuleBlock(exportModifierStripped))
					addResult(fakespace, modifierFlags)
				}
			}
			isNamespaceMember := func(p Symbol) /* TODO inferred type boolean */ TODO {
				return !!(p.flags & (SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsAlias)) || !(p.flags&SymbolFlagsPrototype || p.escapedName == "prototype" || p.valueDeclaration && isStatic(p.valueDeclaration) && isClassLike(p.valueDeclaration.parent))
			}
			sanitizeJSDocImplements := func(clauses []ExpressionWithTypeArguments) /* TODO(ArrayType): ExpressionWithTypeArguments[] */ any {
				result := mapDefined(clauses, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments | undefined */ TODO {
					oldEnclosing := context.enclosingDeclaration
					context.enclosingDeclaration = e
					expr := e.expression
					if isEntityNameExpression(expr) {
						if isIdentifier(expr) && idText(expr) == "" {
							return cleanup(nil)
						}
						var introducesError bool
						/* TODO(ExpressionStatement): ({ introducesError, node: expr } = trackExistingEntityName(expr, context)); */
						if introducesError {
							return cleanup(nil)
						}
					}
					return cleanup(factory.createExpressionWithTypeArguments(expr, map_(e.typeArguments, func(a /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
						return tryReuseExistingNonParameterTypeNode(context, a, getTypeFromTypeNode(context, a)) || typeToTypeNodeHelper(getTypeFromTypeNode(context, a), context)
					})))
					cleanup := func(result T) T {
						context.enclosingDeclaration = oldEnclosing
						return result
					}
				})
				if result.length == clauses.length {
					return result
				}
				return nil
			}
			serializeAsClass := func(symbol Symbol, localName string, modifierFlags ModifierFlags) {
				originalDecl := symbol.declarations.find(isClassLike)
				oldEnclosing := context.enclosingDeclaration
				context.enclosingDeclaration = originalDecl || oldEnclosing
				localParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				typeParamDecls := map_(localParams, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ TODO {
					return typeParameterToDeclaration(p, context)
				})
				classType := getTypeWithThisArgument(getDeclaredTypeOfClassOrInterface(symbol))
				baseTypes := getBaseTypes(classType)
				originalImplements := originalDecl && getEffectiveImplementsTypeNodes(originalDecl)
				implementsExpressions := originalImplements && sanitizeJSDocImplements(originalImplements) || mapDefined(getImplementsTypes(classType), serializeImplementedType)
				staticType := getTypeOfSymbol(symbol)
				isClass := !!staticType.symbol.valueDeclaration && isClassLike(staticType.symbol.valueDeclaration)
				staticBaseType := /* TODO(ConditionalExpression): isClass                     ? getBaseConstructorTypeOfClass(staticType as InterfaceType)                     : anyType */ TODO
				heritageClauses := /* TODO(ArrayLiteralExpression): [                     ...!length(baseTypes) ? [] : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, map(baseTypes, b => serializeBaseType(b, staticBaseType, localName)))],                     ...!length(implementsExpressions) ? [] : [factory.createHeritageClause(SyntaxKind.ImplementsKeyword, implementsExpressions)],                 ] */ TODO
				symbolProps := getNonInheritedProperties(classType, baseTypes, getPropertiesOfType(classType))
				publicSymbolProps := filter(symbolProps, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
					valueDecl := s.valueDeclaration
					return !!valueDecl && !(isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name))
				})
				hasPrivateIdentifier := some(symbolProps, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
					valueDecl := s.valueDeclaration
					return !!valueDecl && isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name)
				})
				privateProperties := /* TODO(ConditionalExpression): hasPrivateIdentifier ?                     [factory.createPropertyDeclaration(                         /*modifiers* / undefined,                         factory.createPrivateIdentifier("#private"),                         /*questionOrExclamationToken* / undefined,                         /*type* / undefined,                         /*initializer* / undefined,                     )] :                     emptyArray */ TODO
				publicProperties := flatMap(publicSymbolProps, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessorDeclaration | (import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessorDeclaration)[] */ TODO {
					return serializePropertySymbolForClass(p, false /* TODO(ElementAccessExpression): baseTypes[0] */, TODO)
				})
				staticMembers := flatMap(filter(getPropertiesOfType(staticType), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
					return !(p.flags & SymbolFlagsPrototype) && p.escapedName != "prototype" && !isNamespaceMember(p)
				}), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessorDeclaration | (import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessorDeclaration)[] */ TODO {
					return serializePropertySymbolForClass(p, true, staticBaseType)
				})
				isNonConstructableClassLikeInJsFile := !isClass && !!symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && !some(getSignaturesOfType(staticType, SignatureKindConstruct))
				constructors := /* TODO(ConditionalExpression): isNonConstructableClassLikeInJsFile ?                     [factory.createConstructorDeclaration(factory.createModifiersFromModifierFlags(ModifierFlags.Private), [], /*body* / undefined)] :                     serializeSignatures(SignatureKind.Construct, staticType, staticBaseType, SyntaxKind.Constructor) as ConstructorDeclaration[] */ TODO
				indexSignatures := serializeIndexSignatures(classType /* TODO(ElementAccessExpression): baseTypes[0] */, TODO)
				context.enclosingDeclaration = oldEnclosing
				addResult(setTextRange(context, factory.createClassDeclaration(nil, localName, typeParamDecls, heritageClauses /* TODO(ArrayLiteralExpression): [...indexSignatures, ...staticMembers, ...constructors, ...publicProperties, ...privateProperties] */, TODO), symbol.declarations && /* TODO(ElementAccessExpression): filter(symbol.declarations, d => isClassDeclaration(d) || isClassExpression(d))[0] */ TODO), modifierFlags)
			}
			getSomeTargetNameFromDeclarations := func(declarations /* TODO(ArrayType): Declaration[] */ any) /* TODO inferred type string | undefined */ TODO {
				return firstDefined(declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type string | undefined */ TODO {
					if isImportSpecifier(d) || isExportSpecifier(d) {
						return moduleExportNameTextUnescaped(d.propertyName || d.name)
					}
					if isBinaryExpression(d) || isExportAssignment(d) {
						expression := /* TODO(ConditionalExpression): isExportAssignment(d) ? d.expression : d.right */ TODO
						if isPropertyAccessExpression(expression) {
							return idText(expression.name)
						}
					}
					if isAliasSymbolDeclaration(d) {
						name := getNameOfDeclaration(d)
						if name && isIdentifier(name) {
							return idText(name)
						}
					}
					return nil
				})
			}
			serializeAsAlias := func(symbol Symbol, localName string, modifierFlags ModifierFlags) /* TODO inferred type undefined */ TODO {
				node := getDeclarationOfAliasSymbol(symbol)
				if !node {
					return Debug.fail()
				}
				target := getMergedSymbol(getTargetOfAliasDeclaration(node, true))
				if !target {
					return
				}
				verbatimTargetName := isShorthandAmbientModuleSymbol(target) && getSomeTargetNameFromDeclarations(symbol.declarations) || unescapeLeadingUnderscores(target.escapedName)
				if verbatimTargetName == InternalSymbolNameExportEquals && allowSyntheticDefaultImports {
					verbatimTargetName = InternalSymbolNameDefault
				}
				targetName := getInternalSymbolName(target, verbatimTargetName)
				includePrivateSymbol(target)
				switch node.kind {
				case SyntaxKindBindingElement:
					if node.parent.parent.kind == SyntaxKindVariableDeclaration {
						specifier := getSpecifierForModuleSymbol(target.parent || target, context)
						TODO_IDENTIFIER := node
						addResult(factory.createImportDeclaration(nil, factory.createImportClause(false, nil, factory.createNamedImports( /* TODO(ArrayLiteralExpression): [factory.createImportSpecifier(                                             /*isTypeOnly* / false,                                             propertyName && isIdentifier(propertyName) ? factory.createIdentifier(idText(propertyName)) : undefined,                                             factory.createIdentifier(localName),                                         )] */ TODO)), factory.createStringLiteral(specifier), nil), ModifierFlagsNone)
						break
					}
					Debug.failBadSyntaxKind(node.parent.parent || node, "Unhandled binding element grandparent kind in declaration serialization")
					break
				case SyntaxKindShorthandPropertyAssignment:
					if node.parent.parent.kind == SyntaxKindBinaryExpression {
						serializeExportSpecifier(unescapeLeadingUnderscores(symbol.escapedName), targetName)
					}
					break
				case SyntaxKindVariableDeclaration:
					if isPropertyAccessExpression((node).initializer) {
						initializer := (node).initializer
						uniqueName := factory.createUniqueName(localName)
						specifier := getSpecifierForModuleSymbol(target.parent || target, context)
						addResult(factory.createImportEqualsDeclaration(nil, false, uniqueName, factory.createExternalModuleReference(factory.createStringLiteral(specifier))), ModifierFlagsNone)
						addResult(factory.createImportEqualsDeclaration(nil, false, factory.createIdentifier(localName), factory.createQualifiedName(uniqueName, initializer.name)), modifierFlags)
						break
					}
					fallthrough
				case SyntaxKindImportEqualsDeclaration:
					if target.escapedName == InternalSymbolNameExportEquals && some(target.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
						return isSourceFile(d) && isJsonSourceFile(d)
					}) {
						serializeMaybeAliasAssignment(symbol)
						break
					}
					isLocalImport := !(target.flags & SymbolFlagsValueModule) && !isVariableDeclaration(node)
					addResult(factory.createImportEqualsDeclaration(nil, false, factory.createIdentifier(localName) /* TODO(ConditionalExpression): isLocalImport                                     ? symbolToName(target, context, SymbolFlags.All, /*expectsIdentifier* / false)                                     : factory.createExternalModuleReference(factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))) */, TODO) /* TODO(ConditionalExpression): isLocalImport ? modifierFlags : ModifierFlags.None */, TODO)
					break
				case SyntaxKindNamespaceExportDeclaration:
					addResult(factory.createNamespaceExportDeclaration(idText((node).name)), ModifierFlagsNone)
					break
				case SyntaxKindImportClause:
					generatedSpecifier := getSpecifierForModuleSymbol(target.parent || target, context)
					specifier := /* TODO(ConditionalExpression): context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as ImportClause).parent.moduleSpecifier */ TODO
					attributes := /* TODO(ConditionalExpression): isImportDeclaration(node.parent) ? node.parent.attributes : undefined */ TODO
					isTypeOnly := isJSDocImportTag((node).parent)
					addResult(factory.createImportDeclaration(nil, factory.createImportClause(isTypeOnly, factory.createIdentifier(localName), nil), specifier, attributes), ModifierFlagsNone)
					break
					fallthrough
				case SyntaxKindNamespaceImport:
					generatedSpecifier := getSpecifierForModuleSymbol(target.parent || target, context)
					specifier := /* TODO(ConditionalExpression): context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as NamespaceImport).parent.parent.moduleSpecifier */ TODO
					isTypeOnly := isJSDocImportTag((node).parent.parent)
					addResult(factory.createImportDeclaration(nil, factory.createImportClause(isTypeOnly, nil, factory.createNamespaceImport(factory.createIdentifier(localName))), specifier, (node).parent.attributes), ModifierFlagsNone)
					break
					fallthrough
				case SyntaxKindNamespaceExport:
					addResult(factory.createExportDeclaration(nil, false, factory.createNamespaceExport(factory.createIdentifier(localName)), factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))), ModifierFlagsNone)
					break
				case SyntaxKindImportSpecifier:
					generatedSpecifier := getSpecifierForModuleSymbol(target.parent || target, context)
					specifier := /* TODO(ConditionalExpression): context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as ImportSpecifier).parent.parent.parent.moduleSpecifier */ TODO
					isTypeOnly := isJSDocImportTag((node).parent.parent.parent)
					addResult(factory.createImportDeclaration(nil, factory.createImportClause(isTypeOnly, nil, factory.createNamedImports( /* TODO(ArrayLiteralExpression): [                                         factory.createImportSpecifier(                                             /*isTypeOnly* / false,                                             localName !== verbatimTargetName ? factory.createIdentifier(verbatimTargetName) : undefined,                                             factory.createIdentifier(localName),                                         ),                                     ] */ TODO)), specifier, (node).parent.parent.parent.attributes), ModifierFlagsNone)
					break
					fallthrough
				case SyntaxKindExportSpecifier:
					specifier := (node.parent.parent).moduleSpecifier
					if specifier {
						propertyName := (node).propertyName
						if propertyName && moduleExportNameIsDefault(propertyName) {
							verbatimTargetName = InternalSymbolNameDefault
						}
					}
					serializeExportSpecifier(unescapeLeadingUnderscores(symbol.escapedName) /* TODO(ConditionalExpression): specifier ? verbatimTargetName : targetName */, TODO /* TODO(ConditionalExpression): specifier && isStringLiteralLike(specifier) ? factory.createStringLiteral(specifier.text) : undefined */, TODO)
					break
				case SyntaxKindExportAssignment:
					serializeMaybeAliasAssignment(symbol)
					break
				case SyntaxKindBinaryExpression:
					fallthrough // TODO: merge cases
				case SyntaxKindPropertyAccessExpression:
					fallthrough // TODO: merge cases
				case SyntaxKindElementAccessExpression:
					if symbol.escapedName == InternalSymbolNameDefault || symbol.escapedName == InternalSymbolNameExportEquals {
						serializeMaybeAliasAssignment(symbol)
					} else {
						serializeExportSpecifier(localName, targetName)
					}
					break
				default:
					return Debug.failBadSyntaxKind(node, "Unhandled alias declaration kind in symbol serializer!")
				}
			}
			serializeExportSpecifier := func(localName string, targetName string, specifier Expression) {
				addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports( /* TODO(ArrayLiteralExpression): [factory.createExportSpecifier(/*isTypeOnly* / false, localName !== targetName ? targetName : undefined, localName)] */ TODO), specifier), ModifierFlagsNone)
			}
			serializeMaybeAliasAssignment := func(symbol Symbol) bool {
				if symbol.flags & SymbolFlagsPrototype {
					return false
				}
				name := unescapeLeadingUnderscores(symbol.escapedName)
				isExportEquals := name == InternalSymbolNameExportEquals
				isDefault := name == InternalSymbolNameDefault
				isExportAssignmentCompatibleSymbolName := isExportEquals || isDefault
				aliasDecl := symbol.declarations && getDeclarationOfAliasSymbol(symbol)
				target := aliasDecl && getTargetOfAliasDeclaration(aliasDecl, true)
				if target && length(target.declarations) && some(target.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
					return getSourceFileOfNode(d) == getSourceFileOfNode(enclosingDeclaration)
				}) {
					expr := aliasDecl && ( /* TODO(ConditionalExpression): (isExportAssignment(aliasDecl) || isBinaryExpression(aliasDecl)) ? getExportAssignmentExpression(aliasDecl) : getPropertyAssignmentAliasLikeExpression(aliasDecl as ShorthandPropertyAssignment | PropertyAssignment | PropertyAccessExpression) */ TODO)
					first := /* TODO(ConditionalExpression): expr && isEntityNameExpression(expr) ? getFirstNonModuleExportsIdentifier(expr) : undefined */ TODO
					referenced := first && resolveEntityName(first, SymbolFlagsAll, true, true, enclosingDeclaration)
					if referenced || target {
						includePrivateSymbol(referenced || target)
					}
					prevDisableTrackSymbol := context.tracker.disableTrackSymbol
					context.tracker.disableTrackSymbol = true
					if isExportAssignmentCompatibleSymbolName {
						results.push(factory.createExportAssignment(nil, isExportEquals, symbolToExpression(target, context, SymbolFlagsAll)))
					} else {
						if first == expr && first {
							serializeExportSpecifier(name, idText(first))
						} else if expr && isClassExpression(expr) {
							serializeExportSpecifier(name, getInternalSymbolName(target, symbolName(target)))
						} else {
							varName := getUnusedName(name, symbol)
							addResult(factory.createImportEqualsDeclaration(nil, false, factory.createIdentifier(varName), symbolToName(target, context, SymbolFlagsAll, false)), ModifierFlagsNone)
							serializeExportSpecifier(name, varName)
						}
					}
					context.tracker.disableTrackSymbol = prevDisableTrackSymbol
					return true
				} else {
					varName := getUnusedName(name, symbol)
					typeToSerialize := getWidenedType(getTypeOfSymbol(getMergedSymbol(symbol)))
					if isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, symbol) {
						serializeAsFunctionNamespaceMerge(typeToSerialize, symbol, varName /* TODO(ConditionalExpression): isExportAssignmentCompatibleSymbolName ? ModifierFlags.None : ModifierFlags.Export */, TODO)
					} else {
						flags := /* TODO(ConditionalExpression): context.enclosingDeclaration?.kind === SyntaxKind.ModuleDeclaration && (!(symbol.flags & SymbolFlags.Accessor) || symbol.flags & SymbolFlags.SetAccessor) ? NodeFlags.Let : NodeFlags.Const */ TODO
						statement := factory.createVariableStatement(nil, factory.createVariableDeclarationList( /* TODO(ArrayLiteralExpression): [                                 factory.createVariableDeclaration(varName, /*exclamationToken* / undefined, serializeTypeForDeclaration(context, /*declaration* / undefined, typeToSerialize, symbol)),                             ] */ TODO, flags))
						addResult(statement /* TODO(ConditionalExpression): target && target.flags & SymbolFlags.Property && target.escapedName === InternalSymbolName.ExportEquals ? ModifierFlags.Ambient                                 : name === varName ? ModifierFlags.Export                                 : ModifierFlags.None */, TODO)
					}
					if isExportAssignmentCompatibleSymbolName {
						results.push(factory.createExportAssignment(nil, isExportEquals, factory.createIdentifier(varName)))
						return true
					} else if name != varName {
						serializeExportSpecifier(name, varName)
						return true
					}
					return false
				}
			}
			isTypeRepresentableAsFunctionNamespaceMerge := func(typeToSerialize Type, hostSymbol Symbol) /* TODO inferred type boolean | 0 */ TODO {
				ctxSrc := getSourceFileOfNode(context.enclosingDeclaration)
				return getObjectFlags(typeToSerialize)&(ObjectFlagsAnonymous|ObjectFlagsMapped) && !some(typeToSerialize.symbol.declarations, isTypeNode) && !length(getIndexInfosOfType(typeToSerialize)) && !isClassInstanceSide(typeToSerialize) && !!(length(filter(getPropertiesOfType(typeToSerialize), isNamespaceMember)) || length(getSignaturesOfType(typeToSerialize, SignatureKindCall))) && !length(getSignaturesOfType(typeToSerialize, SignatureKindConstruct)) && !getDeclarationWithTypeAnnotation(hostSymbol, enclosingDeclaration) && !(typeToSerialize.symbol && some(typeToSerialize.symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
					return getSourceFileOfNode(d) != ctxSrc
				})) && !some(getPropertiesOfType(typeToSerialize), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
					return isLateBoundName(p.escapedName)
				}) && !some(getPropertiesOfType(typeToSerialize), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
					return some(p.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
						return getSourceFileOfNode(d) != ctxSrc
					})
				}) && every(getPropertiesOfType(typeToSerialize), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
					if !isIdentifierText(symbolName(p), languageVersion) {
						return false
					}
					if !(p.flags & SymbolFlagsAccessor) {
						return true
					}
					return getNonMissingTypeOfSymbol(p) == getWriteTypeOfSymbol(p)
				})
			}
			// OVERLOAD: makeSerializePropertySymbol := func(createProperty func(modifiers /* TODO(TypeOperator): readonly Modifier[] */ any, name /* TODO(UnionType): string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer *Expression) T, methodKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ any, useAccessors /* TODO(LiteralType): true */ any) func(p Symbol, isStatic bool, baseType *Type) /* TODO(UnionType): T | AccessorDeclaration | (T | AccessorDeclaration)[] */ any
			// OVERLOAD: makeSerializePropertySymbol := func(createProperty func(modifiers /* TODO(TypeOperator): readonly Modifier[] */ any, name /* TODO(UnionType): string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer *Expression) T, methodKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ any, useAccessors /* TODO(LiteralType): false */ any) func(p Symbol, isStatic bool, baseType *Type) /* TODO(UnionType): T | T[] */ any
			makeSerializePropertySymbol := func(createProperty func(modifiers /* TODO(TypeOperator): readonly Modifier[] */ any, name /* TODO(UnionType): string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer *Expression) T, methodKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ any, useAccessors bool) func(p Symbol, isStatic bool, baseType *Type) /* TODO(UnionType): T | AccessorDeclaration | (T | AccessorDeclaration)[] */ any {
				return /* TODO(FunctionExpression): function serializePropertySymbol(p: Symbol, isStatic: boolean, baseType: Type | undefined): T | AccessorDeclaration | (T | AccessorDeclaration)[] {                     const modifierFlags = getDeclarationModifierFlagsFromSymbol(p);                     const isPrivate = !!(modifierFlags & ModifierFlags.Private);                     if (isStatic && (p.flags & (SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias))) {                         // Only value-only-meaning symbols can be correctly encoded as class statics, type/namespace/alias meaning symbols                         // need to be merged namespace members                         return [];                     }                     if (                         p.flags & SymbolFlags.Prototype || p.escapedName === "constructor" ||                         (baseType && getPropertyOfType(baseType, p.escapedName)                             && isReadonlySymbol(getPropertyOfType(baseType, p.escapedName)!) === isReadonlySymbol(p)                             && (p.flags & SymbolFlags.Optional) === (getPropertyOfType(baseType, p.escapedName)!.flags & SymbolFlags.Optional)                             && isTypeIdenticalTo(getTypeOfSymbol(p), getTypeOfPropertyOfType(baseType, p.escapedName)!))                     ) {                         return [];                     }                     const flag = (modifierFlags & ~ModifierFlags.Async) | (isStatic ? ModifierFlags.Static : 0);                     const name = getPropertyNameNodeForSymbol(p, context);                     const firstPropertyLikeDecl = p.declarations?.find(or(isPropertyDeclaration, isAccessor, isVariableDeclaration, isPropertySignature, isBinaryExpression, isPropertyAccessExpression));                     if (p.flags & SymbolFlags.Accessor && useAccessors) {                         const result: AccessorDeclaration[] = [];                         if (p.flags & SymbolFlags.SetAccessor) {                             const setter = p.declarations && forEach(p.declarations, d => {                                 if (d.kind === SyntaxKind.SetAccessor) {                                     return d as SetAccessorDeclaration;                                 }                                 if (isCallExpression(d) && isBindableObjectDefinePropertyCall(d)) {                                     return forEach(d.arguments[2].properties, propDecl => {                                         const id = getNameOfDeclaration(propDecl);                                         if (!!id && isIdentifier(id) && idText(id) === "set") {                                             return propDecl;                                         }                                     });                                 }                             });                              Debug.assert(!!setter);                             const paramSymbol = isFunctionLikeDeclaration(setter) ? getSignatureFromDeclaration(setter).parameters[0] : undefined;                              result.push(setTextRange(                                 context,                                 factory.createSetAccessorDeclaration(                                     factory.createModifiersFromModifierFlags(flag),                                     name,                                     [factory.createParameterDeclaration(                                         /*modifiers* / undefined,                                         /*dotDotDotToken* / undefined,                                         paramSymbol ? parameterToParameterDeclarationName(paramSymbol, getEffectiveParameterDeclaration(paramSymbol), context) : "value",                                         /*questionToken* / undefined,                                         isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getWriteTypeOfSymbol(p), p),                                     )],                                     /*body* / undefined,                                 ),                                 p.declarations?.find(isSetAccessor) || firstPropertyLikeDecl,                             ));                         }                         if (p.flags & SymbolFlags.GetAccessor) {                             const isPrivate = modifierFlags & ModifierFlags.Private;                             result.push(setTextRange(                                 context,                                 factory.createGetAccessorDeclaration(                                     factory.createModifiersFromModifierFlags(flag),                                     name,                                     [],                                     isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getTypeOfSymbol(p), p),                                     /*body* / undefined,                                 ),                                 p.declarations?.find(isGetAccessor) || firstPropertyLikeDecl,                             ));                         }                         return result;                     }                     // This is an else/if as accessors and properties can't merge in TS, but might in JS                     // If this happens, we assume the accessor takes priority, as it imposes more constraints                     else if (p.flags & (SymbolFlags.Property | SymbolFlags.Variable | SymbolFlags.Accessor)) {                         return setTextRange(                             context,                             createProperty(                                 factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag),                                 name,                                 p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                 isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getWriteTypeOfSymbol(p), p),                                 // TODO: https://github.com/microsoft/TypeScript/pull/32372#discussion_r328386357                                 // interface members can't have initializers, however class members _can_                                 /*initializer* / undefined,                             ),                             p.declarations?.find(or(isPropertyDeclaration, isVariableDeclaration)) || firstPropertyLikeDecl,                         );                     }                     if (p.flags & (SymbolFlags.Method | SymbolFlags.Function)) {                         const type = getTypeOfSymbol(p);                         const signatures = getSignaturesOfType(type, SignatureKind.Call);                         if (flag & ModifierFlags.Private) {                             return setTextRange(                                 context,                                 createProperty(                                     factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag),                                     name,                                     p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                     /*type* / undefined,                                     /*initializer* / undefined,                                 ),                                 p.declarations?.find(isFunctionLikeDeclaration) || signatures[0] && signatures[0].declaration || p.declarations && p.declarations[0],                             );                         }                          const results = [];                         for (const sig of signatures) {                             // Each overload becomes a separate method declaration, in order                             const decl = signatureToSignatureDeclarationHelper(                                 sig,                                 methodKind,                                 context,                                 {                                     name,                                     questionToken: p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                     modifiers: flag ? factory.createModifiersFromModifierFlags(flag) : undefined,                                 },                             );                             const location = sig.declaration && isPrototypePropertyAssignment(sig.declaration.parent) ? sig.declaration.parent : sig.declaration;                             results.push(setTextRange(context, decl, location));                         }                         return results as unknown as T[];                     }                     // The `Constructor`'s symbol isn't in the class's properties lists, obviously, since it's a signature on the static                     return Debug.fail(`Unhandled class member kind! ${(p as any).__debugFlags || p.flags}`);                 } */ TODO
			}
			serializePropertySymbolForInterface := func(p Symbol, baseType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement[] */ TODO {
				return serializePropertySymbolForInterfaceWorker(p, false, baseType)
			}
			serializeSignatures := func(kind SignatureKind, input Type, baseType *Type, outputKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ any) /* TODO inferred type (import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").ArrowFunction | import("/home/jabaile/work/TypeScript/src/compiler/types").CallSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").MethodSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocFunctionType | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").MethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").GetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SetAccessorDeclaration)[] */ TODO {
				signatures := getSignaturesOfType(input, kind)
				if kind == SignatureKindConstruct {
					if !baseType && every(signatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
						return length(s.parameters) == 0
					}) {
						return /* TODO(ArrayLiteralExpression): [] */ TODO
					}
					if baseType {
						baseSigs := getSignaturesOfType(baseType, SignatureKindConstruct)
						if !length(baseSigs) && every(signatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
							return length(s.parameters) == 0
						}) {
							return /* TODO(ArrayLiteralExpression): [] */ TODO
						}
						if baseSigs.length == signatures.length {
							failed := false
							/* TODO(ForStatement): for (let i = 0; i < baseSigs.length; i++) {                                 if (!compareSignaturesIdentical(signatures[i], baseSigs[i], /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true, compareTypesIdentical)) {                                     failed = true;                                     break;                                 }                             } */
							if !failed {
								return /* TODO(ArrayLiteralExpression): [] */ TODO
							}
						}
					}
					var privateProtected ModifierFlags = 0
					for _, s := range signatures {
						if s.declaration {
							privateProtected |= getSelectedEffectiveModifierFlags(s.declaration, ModifierFlagsPrivate|ModifierFlagsProtected)
						}
					}
					if privateProtected {
						return /* TODO(ArrayLiteralExpression): [setTextRange(                             context,                             factory.createConstructorDeclaration(                                 factory.createModifiersFromModifierFlags(privateProtected),                                 /*parameters* / [],                                 /*body* / undefined,                             ),                             signatures[0].declaration,                         )] */ TODO
					}
				}
				results := /* TODO(ArrayLiteralExpression): [] */ TODO
				for _, sig := range signatures {
					decl := signatureToSignatureDeclarationHelper(sig, outputKind, context)
					results.push(setTextRange(context, decl, sig.declaration))
				}
				return results
			}
			serializeIndexSignatures := func(input Type, baseType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration[] */ TODO {
				var results []IndexSignatureDeclaration = /* TODO(ArrayLiteralExpression): [] */ TODO
				for _, info := range getIndexInfosOfType(input) {
					if baseType {
						baseInfo := getIndexInfoOfType(baseType, info.keyType)
						if baseInfo {
							if isTypeIdenticalTo(info.type_, baseInfo.type_) {
								continue
							}
						}
					}
					results.push(indexInfoToIndexSignatureDeclarationHelper(info, context, nil))
				}
				return results
			}
			serializeBaseType := func(t Type, staticType Type, rootName string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments */ TODO {
				ref := trySerializeAsTypeReference(t, SymbolFlagsValue)
				if ref {
					return ref
				}
				tempName := getUnusedName( /* TODO(TemplateExpression): `${rootName}_base` */ TODO)
				statement := factory.createVariableStatement(nil, factory.createVariableDeclarationList( /* TODO(ArrayLiteralExpression): [                         factory.createVariableDeclaration(tempName, /*exclamationToken* / undefined, typeToTypeNodeHelper(staticType, context)),                     ] */ TODO, NodeFlagsConst))
				addResult(statement, ModifierFlagsNone)
				return factory.createExpressionWithTypeArguments(factory.createIdentifier(tempName), nil)
			}
			trySerializeAsTypeReference := func(t Type, flags SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments | undefined */ TODO {
				var typeArgs /* TODO(ArrayType): TypeNode[] */ any
				var reference *Expression
				if (t).target && isSymbolAccessibleByFlags((t).target.symbol, enclosingDeclaration, flags) {
					typeArgs = map_(getTypeArguments(t), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
						return typeToTypeNodeHelper(t, context)
					})
					reference = symbolToExpression((t).target.symbol, context, SymbolFlagsType)
				} else if t.symbol && isSymbolAccessibleByFlags(t.symbol, enclosingDeclaration, flags) {
					reference = symbolToExpression(t.symbol, context, SymbolFlagsType)
				}
				if reference {
					return factory.createExpressionWithTypeArguments(reference, typeArgs)
				}
			}
			serializeImplementedType := func(t Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments | undefined */ TODO {
				ref := trySerializeAsTypeReference(t, SymbolFlagsType)
				if ref {
					return ref
				}
				if t.symbol {
					return factory.createExpressionWithTypeArguments(symbolToExpression(t.symbol, context, SymbolFlagsType), nil)
				}
			}
			getUnusedName := func(input string, symbol Symbol) string {
				id := /* TODO(ConditionalExpression): symbol ? getSymbolId(symbol) : undefined */ TODO
				if id {
					if context.remappedSymbolNames.has(id) {
						return context.remappedSymbolNames.get(id)
					}
				}
				if symbol {
					input = getNameCandidateWorker(symbol, input)
				}
				i := 0
				original := input
				for context.usedSymbolNames.has(input) {
					i++
					input = /* TODO(TemplateExpression): `${original}_${i}` */ TODO
				}
				context.usedSymbolNames.add(input)
				if id {
					context.remappedSymbolNames.set(id, input)
				}
				return input
			}
			getNameCandidateWorker := func(symbol Symbol, localName string) /* TODO inferred type string */ TODO {
				if localName == InternalSymbolNameDefault || localName == InternalSymbolNameClass || localName == InternalSymbolNameFunction {
					restoreFlags := saveRestoreFlags(context)
					context.flags |= NodeBuilderFlagsInInitialEntityName
					nameCandidate := getNameOfSymbolAsWritten(symbol, context)
					restoreFlags()
					localName = /* TODO(ConditionalExpression): nameCandidate.length > 0 && isSingleOrDoubleQuote(nameCandidate.charCodeAt(0)) ? stripQuotes(nameCandidate) : nameCandidate */ TODO
				}
				if localName == InternalSymbolNameDefault {
					localName = "_default"
				} else if localName == InternalSymbolNameExportEquals {
					localName = "_exports"
				}
				localName = /* TODO(ConditionalExpression): isIdentifierText(localName, languageVersion) && !isStringANonContextualKeyword(localName) ? localName : "_" + localName.replace(/[^a-z0-9]/gi, "_") */ TODO
				return localName
			}
			getInternalSymbolName := func(symbol Symbol, localName string) /* TODO inferred type string */ TODO {
				id := getSymbolId(symbol)
				if context.remappedSymbolNames.has(id) {
					return context.remappedSymbolNames.get(id)
				}
				localName = getNameCandidateWorker(symbol, localName)
				context.remappedSymbolNames.set(id, localName)
				return localName
			}
		}
	}
	typePredicateToString := func(typePredicate TypePredicate, enclosingDeclaration Node, flags TypeFormatFlags /*  = TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter) string {
		return /* TODO(ConditionalExpression): writer ? typePredicateToStringWorker(writer).getText() : usingSingleLineStringWriter(typePredicateToStringWorker) */ TODO
		typePredicateToStringWorker := func(writer EmitTextWriter) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ TODO {
			nodeBuilderFlags := toNodeBuilderFlags(flags) | NodeBuilderFlagsIgnoreErrors | NodeBuilderFlagsWriteTypeParametersInQualifiedName
			predicate := nodeBuilder.typePredicateToTypePredicateNode(typePredicate, enclosingDeclaration, nodeBuilderFlags)
			printer := createPrinterWithRemoveComments()
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			printer.writeNode(EmitHintUnspecified, predicate, sourceFile, writer)
			return writer
		}
	}
	formatUnionTypes := func(types []Type) []Type {
		var result []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		flags := 0
		/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             const t = types[i];             flags |= t.flags;             if (!(t.flags & TypeFlags.Nullable)) {                 if (t.flags & (TypeFlags.BooleanLiteral | TypeFlags.EnumLike)) {                     const baseType = t.flags & TypeFlags.BooleanLiteral ? booleanType : getBaseTypeOfEnumLikeType(t as LiteralType);                     if (baseType.flags & TypeFlags.Union) {                         const count = (baseType as UnionType).types.length;                         if (i + count <= types.length && getRegularTypeOfLiteralType(types[i + count - 1]) === getRegularTypeOfLiteralType((baseType as UnionType).types[count - 1])) {                             result.push(baseType);                             i += count - 1;                             continue;                         }                     }                 }                 result.push(t);             }         } */
		if flags & TypeFlagsNull {
			result.push(nullType)
		}
		if flags & TypeFlagsUndefined {
			result.push(undefinedType)
		}
		return result || types
	}
	visibilityToString := func(flags ModifierFlags) string {
		if flags == ModifierFlagsPrivate {
			return "private"
		}
		if flags == ModifierFlagsProtected {
			return "protected"
		}
		return "public"
	}
	getTypeAliasForTypeLiteral := func(type_ Type) *Symbol {
		if type_.symbol && type_.symbol.flags&SymbolFlagsTypeLiteral && type_.symbol.declarations {
			node := walkUpParenthesizedTypes( /* TODO(ElementAccessExpression): type.symbol.declarations[0] */ TODO.parent)
			if isTypeAliasDeclaration(node) {
				return getSymbolOfDeclaration(node)
			}
		}
		return nil
	}
	isTopLevelInExternalModuleAugmentation := func(node Node) bool {
		return node && node.parent && node.parent.kind == SyntaxKindModuleBlock && isExternalModuleAugmentation(node.parent.parent)
	}
	isDefaultBindingContext := func(location Node) /* TODO inferred type boolean */ TODO {
		return location.kind == SyntaxKindSourceFile || isAmbientModule(location)
	}
	getNameOfSymbolFromNameType := func(symbol Symbol, context NodeBuilderContext) /* TODO inferred type string | undefined */ TODO {
		nameType := getSymbolLinks(symbol).nameType
		if nameType {
			if nameType.flags & TypeFlagsStringOrNumberLiteral {
				name := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + (nameType as StringLiteralType | NumberLiteralType).value */ TODO
				if !isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && !isNumericLiteralName(name) {
					return /* TODO(TemplateExpression): `"${escapeString(name, CharacterCodes.doubleQuote)}"` */ TODO
				}
				if isNumericLiteralName(name) && startsWith(name, "-") {
					return /* TODO(TemplateExpression): `[${name}]` */ TODO
				}
				return name
			}
			if nameType.flags & TypeFlagsUniqueESSymbol {
				return /* TODO(TemplateExpression): `[${getNameOfSymbolAsWritten((nameType as UniqueESSymbolType).symbol, context)}]` */ TODO
			}
		}
	}
	getNameOfSymbolAsWritten := func(symbol Symbol, context NodeBuilderContext) string {
		if context.remappedSymbolReferences.has(getSymbolId(symbol)) {
			symbol = context.remappedSymbolReferences.get(getSymbolId(symbol))
		}
		if context && symbol.escapedName == InternalSymbolNameDefault && !(context.flags & NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope) && (!(context.flags & NodeBuilderFlagsInInitialEntityName) || !symbol.declarations || (context.enclosingDeclaration && findAncestor( /* TODO(ElementAccessExpression): symbol.declarations[0] */ TODO, isDefaultBindingContext) != findAncestor(context.enclosingDeclaration, isDefaultBindingContext))) {
			return "default"
		}
		if symbol.declarations && symbol.declarations.length {
			declaration := firstDefined(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration | undefined */ TODO {
				return /* TODO(ConditionalExpression): getNameOfDeclaration(d) ? d : undefined */ TODO
			})
			name := declaration && getNameOfDeclaration(declaration)
			if declaration && name {
				if isCallExpression(declaration) && isBindableObjectDefinePropertyCall(declaration) {
					return symbolName(symbol)
				}
				if isComputedPropertyName(name) && !(getCheckFlags(symbol) & CheckFlagsLate) {
					nameType := getSymbolLinks(symbol).nameType
					if nameType && nameType.flags&TypeFlagsStringOrNumberLiteral {
						result := getNameOfSymbolFromNameType(symbol, context)
						if result != nil {
							return result
						}
					}
				}
				return declarationNameToString(name)
			}
			if !declaration {
				declaration = /* TODO(ElementAccessExpression): symbol.declarations[0] */ TODO
			}
			if declaration.parent && declaration.parent.kind == SyntaxKindVariableDeclaration {
				return declarationNameToString((declaration.parent).name)
			}
			switch declaration.kind {
			case SyntaxKindClassExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindArrowFunction:
				if context && !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) {
					context.encounteredError = true
				}
				return /* TODO(ConditionalExpression): declaration.kind === SyntaxKind.ClassExpression ? "(Anonymous class)" : "(Anonymous function)" */ TODO
			}
		}
		name := getNameOfSymbolFromNameType(symbol, context)
		return /* TODO(ConditionalExpression): name !== undefined ? name : symbolName(symbol) */ TODO
	}
	isDeclarationVisible := func(node Node) bool {
		if node {
			links := getNodeLinks(node)
			if links.isVisible == nil {
				links.isVisible = !!determineIfDeclarationIsVisible()
			}
			return links.isVisible
		}
		return false
		determineIfDeclarationIsVisible := func() /* TODO inferred type boolean */ TODO {
			switch node.kind {
			case SyntaxKindJSDocCallbackTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocTypedefTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocEnumTag:
				return !!(node.parent && node.parent.parent && node.parent.parent.parent && isSourceFile(node.parent.parent.parent))
			case SyntaxKindBindingElement:
				return isDeclarationVisible(node.parent.parent)
			case SyntaxKindVariableDeclaration:
				if isBindingPattern((node).name) && !((node).name).elements.length {
					return false
				}
				fallthrough
			case SyntaxKindModuleDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeAliasDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindEnumDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindImportEqualsDeclaration:
				if isExternalModuleAugmentation(node) {
					return true
				}
				parent := getDeclarationContainer(node)
				if !(getCombinedModifierFlagsCached(node) & ModifierFlagsExport) && !(node.kind != SyntaxKindImportEqualsDeclaration && parent.kind != SyntaxKindSourceFile && parent.flags&NodeFlagsAmbient) {
					return isGlobalSourceFile(parent)
				}
				return isDeclarationVisible(parent)
			case SyntaxKindPropertyDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindPropertySignature:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodSignature:
				if hasEffectiveModifier(node, ModifierFlagsPrivate|ModifierFlagsProtected) {
					return false
				}
				fallthrough
			case SyntaxKindConstructor:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindCallSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindIndexSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindParameter:
				fallthrough // TODO: merge cases
			case SyntaxKindModuleBlock:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionType:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructorType:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeLiteral:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeReference:
				fallthrough // TODO: merge cases
			case SyntaxKindArrayType:
				fallthrough // TODO: merge cases
			case SyntaxKindTupleType:
				fallthrough // TODO: merge cases
			case SyntaxKindUnionType:
				fallthrough // TODO: merge cases
			case SyntaxKindIntersectionType:
				fallthrough // TODO: merge cases
			case SyntaxKindParenthesizedType:
				fallthrough // TODO: merge cases
			case SyntaxKindNamedTupleMember:
				return isDeclarationVisible(node.parent)
			case SyntaxKindImportClause:
				fallthrough // TODO: merge cases
			case SyntaxKindNamespaceImport:
				fallthrough // TODO: merge cases
			case SyntaxKindImportSpecifier:
				return false
			case SyntaxKindTypeParameter:
				fallthrough // TODO: merge cases
			case SyntaxKindSourceFile:
				fallthrough // TODO: merge cases
			case SyntaxKindNamespaceExportDeclaration:
				return true
			case SyntaxKindExportAssignment:
				return false
			default:
				return false
			}
		}
	}
	collectLinkedAliases := func(node ModuleExportName, setVisibility bool) /* TODO(ArrayType): Node[] */ any {
		var exportSymbol *Symbol
		if node.kind != SyntaxKindStringLiteral && node.parent && node.parent.kind == SyntaxKindExportAssignment {
			exportSymbol = resolveName(node, node, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias, nil, false)
		} else if node.parent.kind == SyntaxKindExportSpecifier {
			exportSymbol = getTargetOfExportSpecifier(node.parent, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias)
		}
		var result /* TODO(ArrayType): Node[] */ any
		var visited *Set[number]
		if exportSymbol {
			visited = /* TODO(NewExpression): new Set() */ make(map[any]struct{})
			visited.add(getSymbolId(exportSymbol))
			buildVisibleNodeList(exportSymbol.declarations)
		}
		return result
		buildVisibleNodeList := func(declarations /* TODO(ArrayType): Declaration[] */ any) {
			forEach(declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
				resultNode := getAnyImportSyntax(declaration) || declaration
				if setVisibility {
					getNodeLinks(declaration).isVisible = true
				} else {
					result = result || /* TODO(ArrayLiteralExpression): [] */ TODO
					pushIfUnique(result, resultNode)
				}
				if isInternalModuleImportEqualsDeclaration(declaration) {
					internalModuleReference := declaration.moduleReference
					firstIdentifier := getFirstIdentifier(internalModuleReference)
					importSymbol := resolveName(declaration, firstIdentifier.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, nil, false)
					if importSymbol && visited {
						if tryAddToSet(visited, getSymbolId(importSymbol)) {
							buildVisibleNodeList(importSymbol.declarations)
						}
					}
				}
			})
		}
	}
	pushTypeResolution := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
		resolutionCycleStartIndex := findResolutionCycleStartIndex(target, propertyName)
		if resolutionCycleStartIndex >= 0 {
			TODO_IDENTIFIER := resolutionTargets
			/* TODO(ForStatement): for (let i = resolutionCycleStartIndex; i < length; i++) {                 resolutionResults[i] = false;             } */
			return false
		}
		resolutionTargets.push(target)
		resolutionResults.push(true)
		resolutionPropertyNames.push(propertyName)
		return true
	}
	findResolutionCycleStartIndex := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) number {
		/* TODO(ForStatement): for (let i = resolutionTargets.length - 1; i >= resolutionStart; i--) {             if (resolutionTargetHasProperty(resolutionTargets[i], resolutionPropertyNames[i])) {                 return -1;             }             if (resolutionTargets[i] === target && resolutionPropertyNames[i] === propertyName) {                 return i;             }         } */
		return -1
	}
	resolutionTargetHasProperty := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
		switch propertyName {
		case TypeSystemPropertyNameType:
			return !!getSymbolLinks(target).type_
		case TypeSystemPropertyNameDeclaredType:
			return !!getSymbolLinks(target).declaredType
		case TypeSystemPropertyNameResolvedBaseConstructorType:
			return !!(target).resolvedBaseConstructorType
		case TypeSystemPropertyNameResolvedReturnType:
			return !!(target).resolvedReturnType
		case TypeSystemPropertyNameImmediateBaseConstraint:
			return !!(target).immediateBaseConstraint
		case TypeSystemPropertyNameResolvedTypeArguments:
			return !!(target).resolvedTypeArguments
		case TypeSystemPropertyNameResolvedBaseTypes:
			return !!(target).baseTypesResolved
		case TypeSystemPropertyNameWriteType:
			return !!getSymbolLinks(target).writeType
		case TypeSystemPropertyNameParameterInitializerContainsUndefined:
			return getNodeLinks(target).parameterInitializerContainsUndefined != nil
		}
		return Debug.assertNever(propertyName)
	}
	popTypeResolution := func() bool {
		resolutionTargets.pop()
		resolutionPropertyNames.pop()
		return resolutionResults.pop()
	}
	getDeclarationContainer := func(node Node) Node {
		return findAncestor(getRootDeclaration(node), func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
			switch node.kind {
			case SyntaxKindVariableDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindVariableDeclarationList:
				fallthrough // TODO: merge cases
			case SyntaxKindImportSpecifier:
				fallthrough // TODO: merge cases
			case SyntaxKindNamedImports:
				fallthrough // TODO: merge cases
			case SyntaxKindNamespaceImport:
				fallthrough // TODO: merge cases
			case SyntaxKindImportClause:
				return false
			default:
				return true
			}
		}).parent
	}
	getTypeOfPrototypeProperty := func(prototype Symbol) Type {
		classType := getDeclaredTypeOfSymbol(getParentOfSymbol(prototype))
		return /* TODO(ConditionalExpression): classType.typeParameters ? createTypeReference(classType as GenericType, map(classType.typeParameters, _ => anyType)) : classType */ TODO
	}
	getTypeOfPropertyOfType := func(type_ Type, name __String) *Type {
		prop := getPropertyOfType(type_, name)
		return /* TODO(ConditionalExpression): prop ? getTypeOfSymbol(prop) : undefined */ TODO
	}
	getTypeOfPropertyOrIndexSignatureOfType := func(type_ Type, name __String) *Type {
		var propType TODO
		return getTypeOfPropertyOfType(type_, name) || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): propType = getApplicableIndexInfoForName(type, name)?.type */ TODO) && addOptionality(propType, true, true)
	}
	isTypeAny := func(type_ *Type) /* TODO inferred type boolean | undefined */ TODO {
		return type_ && (type_.flags&TypeFlagsAny) != 0
	}
	isErrorType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return type_ == errorType || !!(type_.flags&TypeFlagsAny && type_.aliasSymbol)
	}
	getTypeForBindingElementParent := func(node BindingElementGrandparent, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if checkMode != CheckModeNormal {
			return getTypeForVariableLikeDeclaration(node, false, checkMode)
		}
		symbol := getSymbolOfDeclaration(node)
		return symbol && getSymbolLinks(symbol).type_ || getTypeForVariableLikeDeclaration(node, false, checkMode)
	}
	getRestType := func(source Type, properties []PropertyName, symbol *Symbol) Type {
		source = filterType(source, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return !(t.flags & TypeFlagsNullable)
		})
		if source.flags & TypeFlagsNever {
			return emptyObjectType
		}
		if source.flags & TypeFlagsUnion {
			return mapType(source, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return getRestType(t, properties, symbol)
			})
		}
		omitKeyType := getUnionType(map_(properties, getLiteralTypeFromPropertyName))
		var spreadableProperties []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		var unspreadableToRestKeys []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, prop := range getPropertiesOfType(source) {
			literalTypeFromProperty := getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique)
			if !isTypeAssignableTo(literalTypeFromProperty, omitKeyType) && !(getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlagsPrivate | ModifierFlagsProtected)) && isSpreadableProperty(prop) {
				spreadableProperties.push(prop)
			} else {
				unspreadableToRestKeys.push(literalTypeFromProperty)
			}
		}
		if isGenericObjectType(source) || isGenericIndexType(omitKeyType) {
			if unspreadableToRestKeys.length {
				omitKeyType = getUnionType( /* TODO(ArrayLiteralExpression): [omitKeyType, ...unspreadableToRestKeys] */ TODO)
			}
			if omitKeyType.flags & TypeFlagsNever {
				return source
			}
			omitTypeAlias := getGlobalOmitSymbol()
			if !omitTypeAlias {
				return errorType
			}
			return getTypeAliasInstantiation(omitTypeAlias /* TODO(ArrayLiteralExpression): [source, omitKeyType] */, TODO)
		}
		members := createSymbolTable()
		for _, prop := range spreadableProperties {
			members.set(prop.escapedName, getSpreadSymbol(prop, false))
		}
		result := createAnonymousType(symbol, members, emptyArray, emptyArray, getIndexInfosOfType(source))
		result.objectFlags |= ObjectFlagsObjectRestType
		return result
	}
	isGenericTypeWithUndefinedConstraint := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(type_.flags & TypeFlagsInstantiable) && maybeTypeOfKind(getBaseConstraintOfType(type_) || unknownType, TypeFlagsUndefined)
	}
	getNonUndefinedType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		typeOrConstraint := /* TODO(ConditionalExpression): someType(type, isGenericTypeWithUndefinedConstraint) ? mapType(type, t => t.flags & TypeFlags.Instantiable ? getBaseConstraintOrType(t) : t) : type */ TODO
		return getTypeWithFacts(typeOrConstraint, TypeFactsNEUndefined)
	}
	getFlowTypeOfDestructuring := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any, declaredType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		reference := getSyntheticElementAccess(node)
		return /* TODO(ConditionalExpression): reference ? getFlowTypeOfReference(reference, declaredType) : declaredType */ TODO
	}
	getSyntheticElementAccess := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) *ElementAccessExpression {
		parentAccess := getParentElementAccess(node)
		if parentAccess && canHaveFlowNode(parentAccess) && parentAccess.flowNode {
			propName := getDestructuringPropertyName(node)
			if propName {
				literal := setTextRangeWorker(parseNodeFactory.createStringLiteral(propName), node)
				lhsExpr := /* TODO(ConditionalExpression): isLeftHandSideExpression(parentAccess) ? parentAccess : parseNodeFactory.createParenthesizedExpression(parentAccess) */ TODO
				result := setTextRangeWorker(parseNodeFactory.createElementAccessExpression(lhsExpr, literal), node)
				setParent(literal, result)
				setParent(result, node)
				if lhsExpr != parentAccess {
					setParent(lhsExpr, result)
				}
				result.flowNode = parentAccess.flowNode
				return result
			}
		}
	}
	getParentElementAccess := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ TODO {
		ancestor := node.parent.parent
		switch ancestor.kind {
		case SyntaxKindBindingElement:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAssignment:
			return getSyntheticElementAccess(ancestor)
		case SyntaxKindArrayLiteralExpression:
			return getSyntheticElementAccess(node.parent)
		case SyntaxKindVariableDeclaration:
			return (ancestor).initializer
		case SyntaxKindBinaryExpression:
			return (ancestor).right
		}
	}
	getDestructuringPropertyName := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) /* TODO inferred type string | undefined */ TODO {
		parent := node.parent
		if node.kind == SyntaxKindBindingElement && parent.kind == SyntaxKindObjectBindingPattern {
			return getLiteralPropertyNameText((node).propertyName || (node).name)
		}
		if node.kind == SyntaxKindPropertyAssignment || node.kind == SyntaxKindShorthandPropertyAssignment {
			return getLiteralPropertyNameText((node).name)
		}
		return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + ((parent as BindingPattern | ArrayLiteralExpression).elements as NodeArray<Node>).indexOf(node) */ TODO
	}
	getLiteralPropertyNameText := func(name PropertyName) /* TODO inferred type string | undefined */ TODO {
		type_ := getLiteralTypeFromPropertyName(name)
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral) ? "" + (type as StringLiteralType | NumberLiteralType).value : undefined */ TODO
	}
	getTypeForBindingElement := func(declaration BindingElement) *Type {
		checkMode := /* TODO(ConditionalExpression): declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */ TODO
		parentType := getTypeForBindingElementParent(declaration.parent.parent, checkMode)
		return parentType && getBindingElementTypeFromParentType(declaration, parentType, false)
	}
	getBindingElementTypeFromParentType := func(declaration BindingElement, parentType Type, noTupleBoundsCheck bool) Type {
		if isTypeAny(parentType) {
			return parentType
		}
		pattern := declaration.parent
		if strictNullChecks && declaration.flags&NodeFlagsAmbient && isPartOfParameterDeclaration(declaration) {
			parentType = getNonNullableType(parentType)
		} else if strictNullChecks && pattern.parent.initializer && !(hasTypeFacts(getTypeOfInitializer(pattern.parent.initializer), TypeFactsEQUndefined)) {
			parentType = getTypeWithFacts(parentType, TypeFactsNEUndefined)
		}
		accessFlags := AccessFlagsExpressionPosition | ( /* TODO(ConditionalExpression): noTupleBoundsCheck || hasDefaultValue(declaration) ? AccessFlags.AllowMissing : 0 */ TODO)
		var type_ *Type
		if pattern.kind == SyntaxKindObjectBindingPattern {
			if declaration.dotDotDotToken {
				parentType = getReducedType(parentType)
				if parentType.flags&TypeFlagsUnknown || !isValidSpreadType(parentType) {
					error(declaration, Diagnostics.Rest_types_may_only_be_created_from_object_types)
					return errorType
				}
				var literalMembers []PropertyName = /* TODO(ArrayLiteralExpression): [] */ TODO
				for _, element := range pattern.elements {
					if !element.dotDotDotToken {
						literalMembers.push(element.propertyName || element.name)
					}
				}
				type_ = getRestType(parentType, literalMembers, declaration.symbol)
			} else {
				name := declaration.propertyName || declaration.name
				indexType := getLiteralTypeFromPropertyName(name)
				declaredType := getIndexedAccessType(parentType, indexType, accessFlags, name)
				type_ = getFlowTypeOfDestructuring(declaration, declaredType)
			}
		} else {
			elementType := checkIteratedTypeOrElementType(IterationUseDestructuring|( /* TODO(ConditionalExpression): declaration.dotDotDotToken ? 0 : IterationUse.PossiblyOutOfBounds */ TODO), parentType, undefinedType, pattern)
			index := pattern.elements.indexOf(declaration)
			if declaration.dotDotDotToken {
				baseConstraint := mapType(parentType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					return /* TODO(ConditionalExpression): t.flags & TypeFlags.InstantiableNonPrimitive ? getBaseConstraintOrType(t) : t */ TODO
				})
				type_ = /* TODO(ConditionalExpression): everyType(baseConstraint, isTupleType) ?                     mapType(baseConstraint, t => sliceTupleType(t as TupleTypeReference, index)) :                     createArrayType(elementType) */ TODO
			} else if isArrayLikeType(parentType) {
				indexType := getNumberLiteralType(index)
				declaredType := getIndexedAccessTypeOrUndefined(parentType, indexType, accessFlags, declaration.name) || errorType
				type_ = getFlowTypeOfDestructuring(declaration, declaredType)
			} else {
				type_ = elementType
			}
		}
		if !declaration.initializer {
			return type_
		}
		if getEffectiveTypeAnnotationNode(walkUpBindingElementsAndPatterns(declaration)) {
			return /* TODO(ConditionalExpression): strictNullChecks && !(hasTypeFacts(checkDeclarationInitializer(declaration, CheckMode.Normal), TypeFacts.IsUndefined)) ? getNonUndefinedType(type) : type */ TODO
		}
		return widenTypeInferredFromInitializer(declaration, getUnionType( /* TODO(ArrayLiteralExpression): [getNonUndefinedType(type), checkDeclarationInitializer(declaration, CheckMode.Normal)] */ TODO, UnionReductionSubtype))
	}
	getTypeForDeclarationFromJSDocComment := func(declaration Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		jsdocType := getJSDocType(declaration)
		if jsdocType {
			return getTypeFromTypeNode(jsdocType)
		}
		return nil
	}
	isNullOrUndefined := func(node Expression) /* TODO inferred type boolean */ TODO {
		expr := skipParentheses(node, true)
		return expr.kind == SyntaxKindNullKeyword || expr.kind == SyntaxKindIdentifier && getResolvedSymbol(expr) == undefinedSymbol
	}
	isEmptyArrayLiteral := func(node Expression) /* TODO inferred type boolean */ TODO {
		expr := skipParentheses(node, true)
		return expr.kind == SyntaxKindArrayLiteralExpression && (expr).elements.length == 0
	}
	addOptionality := func(type_ Type, isProperty /* TODO inferred type boolean */ TODO /*  = false */, isOptional /* TODO inferred type boolean */ TODO /*  = true */) Type {
		return /* TODO(ConditionalExpression): strictNullChecks && isOptional ? getOptionalType(type, isProperty) : type */ TODO
	}
	getTypeForVariableLikeDeclaration := func(declaration /* TODO(UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, includeOptionality bool, checkMode CheckMode) *Type {
		if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForInStatement {
			indexType := getIndexType(getNonNullableTypeIfNeeded(checkExpression(declaration.parent.parent.expression, checkMode)))
			return /* TODO(ConditionalExpression): indexType.flags & (TypeFlags.TypeParameter | TypeFlags.Index) ? getExtractStringType(indexType) : stringType */ TODO
		}
		if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForOfStatement {
			forOfStatement := declaration.parent.parent
			return checkRightHandSideOfForOf(forOfStatement) || anyType
		}
		if isBindingPattern(declaration.parent) {
			return getTypeForBindingElement(declaration)
		}
		isProperty := (isPropertyDeclaration(declaration) && !hasAccessorModifier(declaration)) || isPropertySignature(declaration) || isJSDocPropertyTag(declaration)
		isOptional := includeOptionality && isOptionalDeclaration(declaration)
		declaredType := tryGetTypeFromEffectiveTypeNode(declaration)
		if isCatchClauseVariableDeclarationOrBindingElement(declaration) {
			if declaredType {
				return /* TODO(ConditionalExpression): isTypeAny(declaredType) || declaredType === unknownType ? declaredType : errorType */ TODO
			}
			return /* TODO(ConditionalExpression): useUnknownInCatchVariables ? unknownType : anyType */ TODO
		}
		if declaredType {
			return addOptionality(declaredType, isProperty, isOptional)
		}
		if (noImplicitAny || isInJSFile(declaration)) && isVariableDeclaration(declaration) && !isBindingPattern(declaration.name) && !(getCombinedModifierFlagsCached(declaration) & ModifierFlagsExport) && !(declaration.flags & NodeFlagsAmbient) {
			if !(getCombinedNodeFlagsCached(declaration) & NodeFlagsConstant) && (!declaration.initializer || isNullOrUndefined(declaration.initializer)) {
				return autoType
			}
			if declaration.initializer && isEmptyArrayLiteral(declaration.initializer) {
				return autoArrayType
			}
		}
		if isParameter(declaration) {
			if !declaration.symbol {
				return
			}
			func_ := declaration.parent
			if func_.kind == SyntaxKindSetAccessor && hasBindableName(func_) {
				getter := getDeclarationOfKind(getSymbolOfDeclaration(declaration.parent), SyntaxKindGetAccessor)
				if getter {
					getterSignature := getSignatureFromDeclaration(getter)
					thisParameter := getAccessorThisParameter(func_)
					if thisParameter && declaration == thisParameter {
						Debug.assert(!thisParameter.type_)
						return getTypeOfSymbol(getterSignature.thisParameter)
					}
					return getReturnTypeOfSignature(getterSignature)
				}
			}
			parameterTypeOfTypeTag := getParameterTypeOfTypeTag(func_, declaration)
			if parameterTypeOfTypeTag {
				return parameterTypeOfTypeTag
			}
			type_ := /* TODO(ConditionalExpression): declaration.symbol.escapedName === InternalSymbolName.This ? getContextualThisParameterType(func) : getContextuallyTypedParameterType(declaration) */ TODO
			if type_ {
				return addOptionality(type_, false, isOptional)
			}
		}
		if hasOnlyExpressionInitializer(declaration) && !!declaration.initializer {
			if isInJSFile(declaration) && !isParameter(declaration) {
				containerObjectType := getJSContainerObjectType(declaration, getSymbolOfDeclaration(declaration), getDeclaredExpandoInitializer(declaration))
				if containerObjectType {
					return containerObjectType
				}
			}
			type_ := widenTypeInferredFromInitializer(declaration, checkDeclarationInitializer(declaration, checkMode))
			return addOptionality(type_, isProperty, isOptional)
		}
		if isPropertyDeclaration(declaration) && (noImplicitAny || isInJSFile(declaration)) {
			if !hasStaticModifier(declaration) {
				constructor := findConstructorDeclaration(declaration.parent)
				type_ := /* TODO(ConditionalExpression): constructor ? getFlowTypeInConstructor(declaration.symbol, constructor) :                     getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :                     undefined */ TODO
				return type_ && addOptionality(type_, true, isOptional)
			} else {
				staticBlocks := filter(declaration.parent.members, isClassStaticBlockDeclaration)
				type_ := /* TODO(ConditionalExpression): staticBlocks.length ? getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks) :                     getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :                     undefined */ TODO
				return type_ && addOptionality(type_, true, isOptional)
			}
		}
		if isJsxAttribute(declaration) {
			return trueType
		}
		if isBindingPattern(declaration.name) {
			return getTypeFromBindingPattern(declaration.name, false, true)
		}
		return nil
	}
	isConstructorDeclaredProperty := func(symbol Symbol) /* TODO inferred type boolean */ TODO {
		if symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration) {
			links := getSymbolLinks(symbol)
			if links.isConstructorDeclaredProperty == nil {
				links.isConstructorDeclaredProperty = false
				links.isConstructorDeclaredProperty = !!getDeclaringConstructor(symbol) && every(symbol.declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
					return isBinaryExpression(declaration) && isPossiblyAliasedThisProperty(declaration) && (declaration.left.kind != SyntaxKindElementAccessExpression || isStringOrNumericLiteralLike((declaration.left).argumentExpression)) && !getAnnotatedTypeForAssignmentDeclaration(nil, declaration, symbol, declaration)
				})
			}
			return links.isConstructorDeclaredProperty
		}
		return false
	}
	isAutoTypedProperty := func(symbol Symbol) /* TODO inferred type boolean | undefined */ TODO {
		declaration := symbol.valueDeclaration
		return declaration && isPropertyDeclaration(declaration) && !getEffectiveTypeAnnotationNode(declaration) && !declaration.initializer && (noImplicitAny || isInJSFile(declaration))
	}
	getDeclaringConstructor := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorDeclaration | undefined */ TODO {
		if !symbol.declarations {
			return
		}
		for _, declaration := range symbol.declarations {
			container := getThisContainer(declaration, false, false)
			if container && (container.kind == SyntaxKindConstructor || isJSConstructor(container)) {
				return container
			}
		}
	}
	getFlowTypeFromCommonJSExport := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		file := getSourceFileOfNode( /* TODO(ElementAccessExpression): symbol.declarations![0] */ TODO)
		accessName := unescapeLeadingUnderscores(symbol.escapedName)
		areAllModuleExports := symbol.declarations.every(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
			return isInJSFile(d) && isAccessExpression(d) && isModuleExportsAccessExpression(d.expression)
		})
		reference := /* TODO(ConditionalExpression): areAllModuleExports             ? factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(factory.createIdentifier("module"), factory.createIdentifier("exports")), accessName)             : factory.createPropertyAccessExpression(factory.createIdentifier("exports"), accessName) */ TODO
		if areAllModuleExports {
			setParent((reference.expression).expression, reference.expression)
		}
		setParent(reference.expression, reference)
		setParent(reference, file)
		reference.flowNode = file.endFlowNode
		return getFlowTypeOfReference(reference, autoType, undefinedType)
	}
	getFlowTypeInStaticBlocks := func(symbol Symbol, staticBlocks []ClassStaticBlockDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		accessName := /* TODO(ConditionalExpression): startsWith(symbol.escapedName as string, "__#")             ? factory.createPrivateIdentifier((symbol.escapedName as string).split("@")[1])             : unescapeLeadingUnderscores(symbol.escapedName) */ TODO
		for _, staticBlock := range staticBlocks {
			reference := factory.createPropertyAccessExpression(factory.createThis(), accessName)
			setParent(reference.expression, reference)
			setParent(reference, staticBlock)
			reference.flowNode = staticBlock.returnFlowNode
			flowType := getFlowTypeOfProperty(reference, symbol)
			if noImplicitAny && (flowType == autoType || flowType == autoArrayType) {
				error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType))
			}
			if everyType(flowType, isNullableType) {
				continue
			}
			return convertAutoToAny(flowType)
		}
	}
	getFlowTypeInConstructor := func(symbol Symbol, constructor ConstructorDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		accessName := /* TODO(ConditionalExpression): startsWith(symbol.escapedName as string, "__#")             ? factory.createPrivateIdentifier((symbol.escapedName as string).split("@")[1])             : unescapeLeadingUnderscores(symbol.escapedName) */ TODO
		reference := factory.createPropertyAccessExpression(factory.createThis(), accessName)
		setParent(reference.expression, reference)
		setParent(reference, constructor)
		reference.flowNode = constructor.returnFlowNode
		flowType := getFlowTypeOfProperty(reference, symbol)
		if noImplicitAny && (flowType == autoType || flowType == autoArrayType) {
			error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType))
		}
		return /* TODO(ConditionalExpression): everyType(flowType, isNullableType) ? undefined : convertAutoToAny(flowType) */ TODO
	}
	getFlowTypeOfProperty := func(reference Node, prop *Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		initialType := prop.valueDeclaration && (!isAutoTypedProperty(prop) || getEffectiveModifierFlags(prop.valueDeclaration)&ModifierFlagsAmbient) && getTypeOfPropertyInBaseClass(prop) || undefinedType
		return getFlowTypeOfReference(reference, autoType, initialType)
	}
	getWidenedTypeForAssignmentDeclaration := func(symbol Symbol, resolvedSymbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		container := getAssignedExpandoInitializer(symbol.valueDeclaration)
		if container {
			tag := /* TODO(ConditionalExpression): isInJSFile(container) ? getJSDocTypeTag(container) : undefined */ TODO
			if tag && tag.typeExpression {
				return getTypeFromTypeNode(tag.typeExpression)
			}
			containerObjectType := symbol.valueDeclaration && getJSContainerObjectType(symbol.valueDeclaration, symbol, container)
			return containerObjectType || getWidenedLiteralType(checkExpressionCached(container))
		}
		var type_ TODO
		definedInConstructor := false
		definedInMethod := false
		if isConstructorDeclaredProperty(symbol) {
			type_ = getFlowTypeInConstructor(symbol, getDeclaringConstructor(symbol))
		}
		if !type_ {
			var types /* TODO(ArrayType): Type[] */ any
			if symbol.declarations {
				var jsdocType *Type
				for _, declaration := range symbol.declarations {
					expression := /* TODO(ConditionalExpression): (isBinaryExpression(declaration) || isCallExpression(declaration)) ? declaration :                         isAccessExpression(declaration) ? isBinaryExpression(declaration.parent) ? declaration.parent : declaration :                         undefined */ TODO
					if !expression {
						continue
					}
					kind := /* TODO(ConditionalExpression): isAccessExpression(expression)                         ? getAssignmentDeclarationPropertyAccessKind(expression)                         : getAssignmentDeclarationKind(expression) */ TODO
					if kind == AssignmentDeclarationKindThisProperty || isBinaryExpression(expression) && isPossiblyAliasedThisProperty(expression, kind) {
						if isDeclarationInConstructor(expression) {
							definedInConstructor = true
						} else {
							definedInMethod = true
						}
					}
					if !isCallExpression(expression) {
						jsdocType = getAnnotatedTypeForAssignmentDeclaration(jsdocType, expression, symbol, declaration)
					}
					if !jsdocType {
						(types || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): types = [] */ TODO)).push( /* TODO(ConditionalExpression): (isBinaryExpression(expression) || isCallExpression(expression)) ? getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) : neverType */ TODO)
					}
				}
				type_ = jsdocType
			}
			if !type_ {
				if !length(types) {
					return errorType
				}
				constructorTypes := /* TODO(ConditionalExpression): definedInConstructor && symbol.declarations ? getConstructorDefinedThisAssignmentTypes(types!, symbol.declarations) : undefined */ TODO
				if definedInMethod {
					propType := getTypeOfPropertyInBaseClass(symbol)
					if propType {
						(constructorTypes || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): constructorTypes = [] */ TODO)).push(propType)
						definedInConstructor = true
					}
				}
				sourceTypes := /* TODO(ConditionalExpression): some(constructorTypes, t => !!(t.flags & ~TypeFlags.Nullable)) ? constructorTypes : types */ TODO
				type_ = getUnionType(sourceTypes)
			}
		}
		widened := getWidenedType(addOptionality(type_, false, definedInMethod && !definedInConstructor))
		if symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && filterType(widened, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return !!(t.flags & ~TypeFlagsNullable)
		}) == neverType {
			reportImplicitAny(symbol.valueDeclaration, anyType)
			return anyType
		}
		return widened
	}
	getJSContainerObjectType := func(decl Node, symbol Symbol, init *Expression) *Type {
		if !isInJSFile(decl) || !init || !isObjectLiteralExpression(init) || init.properties.length {
			return nil
		}
		exports := createSymbolTable()
		for isBinaryExpression(decl) || isPropertyAccessExpression(decl) {
			s := getSymbolOfNode(decl)
			if s.exports.size {
				mergeSymbolTable(exports, s.exports)
			}
			decl = /* TODO(ConditionalExpression): isBinaryExpression(decl) ? decl.parent : decl.parent.parent */ TODO
		}
		s := getSymbolOfNode(decl)
		if s.exports.size {
			mergeSymbolTable(exports, s.exports)
		}
		type_ := createAnonymousType(symbol, exports, emptyArray, emptyArray, emptyArray)
		type_.objectFlags |= ObjectFlagsJSLiteral
		return type_
	}
	getAnnotatedTypeForAssignmentDeclaration := func(declaredType *Type, expression Expression, symbol Symbol, declaration Declaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		typeNode := getEffectiveTypeAnnotationNode(expression.parent)
		if typeNode {
			type_ := getWidenedType(getTypeFromTypeNode(typeNode))
			if !declaredType {
				return type_
			} else if !isErrorType(declaredType) && !isErrorType(type_) && !isTypeIdenticalTo(declaredType, type_) {
				errorNextVariableOrPropertyDeclarationMustHaveSameType(nil, declaredType, declaration, type_)
			}
		}
		if symbol.parent.valueDeclaration {
			possiblyAnnotatedSymbol := getFunctionExpressionParentSymbolOrSymbol(symbol.parent)
			if possiblyAnnotatedSymbol.valueDeclaration {
				typeNode := getEffectiveTypeAnnotationNode(possiblyAnnotatedSymbol.valueDeclaration)
				if typeNode {
					annotationSymbol := getPropertyOfType(getTypeFromTypeNode(typeNode), symbol.escapedName)
					if annotationSymbol {
						return getNonMissingTypeOfSymbol(annotationSymbol)
					}
				}
			}
		}
		return declaredType
	}
	getInitializerTypeFromAssignmentDeclaration := func(symbol Symbol, resolvedSymbol *Symbol, expression /* TODO(UnionType): BinaryExpression | CallExpression */ any, kind AssignmentDeclarationKind) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isCallExpression(expression) {
			if resolvedSymbol {
				return getTypeOfSymbol(resolvedSymbol)
			}
			objectLitType := checkExpressionCached( /* TODO(ElementAccessExpression): (expression as BindableObjectDefinePropertyCall).arguments[2] */ TODO)
			valueType := getTypeOfPropertyOfType(objectLitType, "value")
			if valueType {
				return valueType
			}
			getFunc := getTypeOfPropertyOfType(objectLitType, "get")
			if getFunc {
				getSig := getSingleCallSignature(getFunc)
				if getSig {
					return getReturnTypeOfSignature(getSig)
				}
			}
			setFunc := getTypeOfPropertyOfType(objectLitType, "set")
			if setFunc {
				setSig := getSingleCallSignature(setFunc)
				if setSig {
					return getTypeOfFirstParameterOfSignature(setSig)
				}
			}
			return anyType
		}
		if containsSameNamedThisProperty(expression.left, expression.right) {
			return anyType
		}
		isDirectExport := kind == AssignmentDeclarationKindExportsProperty && (isPropertyAccessExpression(expression.left) || isElementAccessExpression(expression.left)) && (isModuleExportsAccessExpression(expression.left.expression) || (isIdentifier(expression.left.expression) && isExportsIdentifier(expression.left.expression)))
		type_ := /* TODO(ConditionalExpression): resolvedSymbol ? getTypeOfSymbol(resolvedSymbol)             : isDirectExport ? getRegularTypeOfLiteralType(checkExpressionCached(expression.right))             : getWidenedLiteralType(checkExpressionCached(expression.right)) */ TODO
		if type_.flags&TypeFlagsObject && kind == AssignmentDeclarationKindModuleExports && symbol.escapedName == InternalSymbolNameExportEquals {
			exportedType := resolveStructuredTypeMembers(type_)
			members := createSymbolTable()
			copyEntries(exportedType.members, members)
			initialSize := members.size
			if resolvedSymbol && !resolvedSymbol.exports {
				resolvedSymbol.exports = createSymbolTable()
			}
			(resolvedSymbol || symbol).exports.forEach(func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
				exportedMember := members.get(name)
				if exportedMember && exportedMember != s && !(s.flags & SymbolFlagsAlias) {
					if s.flags&SymbolFlagsValue && exportedMember.flags&SymbolFlagsValue {
						if s.valueDeclaration && exportedMember.valueDeclaration && getSourceFileOfNode(s.valueDeclaration) != getSourceFileOfNode(exportedMember.valueDeclaration) {
							unescapedName := unescapeLeadingUnderscores(s.escapedName)
							exportedMemberName := tryCast(exportedMember.valueDeclaration, isNamedDeclaration).name || exportedMember.valueDeclaration
							addRelatedInfo(error(s.valueDeclaration, Diagnostics.Duplicate_identifier_0, unescapedName), createDiagnosticForNode(exportedMemberName, Diagnostics._0_was_also_declared_here, unescapedName))
							addRelatedInfo(error(exportedMemberName, Diagnostics.Duplicate_identifier_0, unescapedName), createDiagnosticForNode(s.valueDeclaration, Diagnostics._0_was_also_declared_here, unescapedName))
						}
						union := createSymbol(s.flags|exportedMember.flags, name)
						union.links.type_ = getUnionType( /* TODO(ArrayLiteralExpression): [getTypeOfSymbol(s), getTypeOfSymbol(exportedMember)] */ TODO)
						union.valueDeclaration = exportedMember.valueDeclaration
						union.declarations = concatenate(exportedMember.declarations, s.declarations)
						members.set(name, union)
					} else {
						members.set(name, mergeSymbol(s, exportedMember))
					}
				} else {
					members.set(name, s)
				}
			})
			result := createAnonymousType( /* TODO(ConditionalExpression): initialSize !== members.size ? undefined : exportedType.symbol */ TODO, members, exportedType.callSignatures, exportedType.constructSignatures, exportedType.indexInfos)
			if initialSize == members.size {
				if type_.aliasSymbol {
					result.aliasSymbol = type_.aliasSymbol
					result.aliasTypeArguments = type_.aliasTypeArguments
				}
				if getObjectFlags(type_) & ObjectFlagsReference {
					result.aliasSymbol = (type_).symbol
					args := getTypeArguments(type_)
					result.aliasTypeArguments = /* TODO(ConditionalExpression): length(args) ? args : undefined */ TODO
				}
			}
			result.objectFlags |= getPropagatingFlagsOfTypes( /* TODO(ArrayLiteralExpression): [type] */ TODO) | getObjectFlags(type_)&(ObjectFlagsJSLiteral|ObjectFlagsArrayLiteral|ObjectFlagsObjectLiteral)
			if result.symbol && result.symbol.flags&SymbolFlagsClass && type_ == getDeclaredTypeOfClassOrInterface(result.symbol) {
				result.objectFlags |= ObjectFlagsIsClassInstanceClone
			}
			return result
		}
		if isEmptyArrayLiteralType(type_) {
			reportImplicitAny(expression, anyArrayType)
			return anyArrayType
		}
		return type_
	}
	containsSameNamedThisProperty := func(thisProperty Expression, expression Expression) /* TODO inferred type boolean | undefined */ TODO {
		return isPropertyAccessExpression(thisProperty) && thisProperty.expression.kind == SyntaxKindThisKeyword && forEachChildRecursively(expression, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
			return isMatchingReference(thisProperty, n)
		})
	}
	isDeclarationInConstructor := func(expression Expression) /* TODO inferred type boolean */ TODO {
		thisContainer := getThisContainer(expression, false, false)
		return thisContainer.kind == SyntaxKindConstructor || thisContainer.kind == SyntaxKindFunctionDeclaration || (thisContainer.kind == SyntaxKindFunctionExpression && !isPrototypePropertyAssignment(thisContainer.parent))
	}
	getConstructorDefinedThisAssignmentTypes := func(types []Type, declarations []Declaration) /* TODO(ArrayType): Type[] */ any {
		Debug.assert(types.length == declarations.length)
		return types.filter(func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type boolean | undefined */ TODO {
			declaration := /* TODO(ElementAccessExpression): declarations[i] */ TODO
			expression := /* TODO(ConditionalExpression): isBinaryExpression(declaration) ? declaration :                 isBinaryExpression(declaration.parent) ? declaration.parent : undefined */ TODO
			return expression && isDeclarationInConstructor(expression)
		})
	}
	getTypeFromBindingElement := func(element BindingElement, includePatternInType bool, reportErrors bool) Type {
		if element.initializer {
			contextualType := /* TODO(ConditionalExpression): isBindingPattern(element.name) ? getTypeFromBindingPattern(element.name, /*includePatternInType* / true, /*reportErrors* / false) : unknownType */ TODO
			return addOptionality(widenTypeInferredFromInitializer(element, checkDeclarationInitializer(element, CheckModeNormal, contextualType)))
		}
		if isBindingPattern(element.name) {
			return getTypeFromBindingPattern(element.name, includePatternInType, reportErrors)
		}
		if reportErrors && !declarationBelongsToPrivateAmbientMember(element) {
			reportImplicitAny(element, anyType)
		}
		return /* TODO(ConditionalExpression): includePatternInType ? nonInferrableAnyType : anyType */ TODO
	}
	getTypeFromObjectBindingPattern := func(pattern ObjectBindingPattern, includePatternInType bool, reportErrors bool) Type {
		members := createSymbolTable()
		var stringIndexInfo *IndexInfo
		objectFlags := ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
		forEach(pattern.elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement */ TODO) {
			name := e.propertyName || e.name
			if e.dotDotDotToken {
				stringIndexInfo = createIndexInfo(stringType, anyType, false)
				return
			}
			exprType := getLiteralTypeFromPropertyName(name)
			if !isTypeUsableAsPropertyName(exprType) {
				objectFlags |= ObjectFlagsObjectLiteralPatternWithComputedProperties
				return
			}
			text := getPropertyNameFromType(exprType)
			flags := SymbolFlagsProperty | ( /* TODO(ConditionalExpression): e.initializer ? SymbolFlags.Optional : 0 */ TODO)
			symbol := createSymbol(flags, text)
			symbol.links.type_ = getTypeFromBindingElement(e, includePatternInType, reportErrors)
			symbol.links.bindingElement = e
			members.set(symbol.escapedName, symbol)
		})
		result := createAnonymousType(nil, members, emptyArray, emptyArray /* TODO(ConditionalExpression): stringIndexInfo ? [stringIndexInfo] : emptyArray */, TODO)
		result.objectFlags |= objectFlags
		if includePatternInType {
			result.pattern = pattern
			result.objectFlags |= ObjectFlagsContainsObjectOrArrayLiteral
		}
		return result
	}
	getTypeFromArrayBindingPattern := func(pattern BindingPattern, includePatternInType bool, reportErrors bool) Type {
		elements := pattern.elements
		lastElement := lastOrUndefined(elements)
		restElement := /* TODO(ConditionalExpression): lastElement && lastElement.kind === SyntaxKind.BindingElement && lastElement.dotDotDotToken ? lastElement : undefined */ TODO
		if elements.length == 0 || elements.length == 1 && restElement {
			return /* TODO(ConditionalExpression): languageVersion >= ScriptTarget.ES2015 ? createIterableType(anyType) : anyArrayType */ TODO
		}
		elementTypes := map_(elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").OmittedExpression */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return /* TODO(ConditionalExpression): isOmittedExpression(e) ? anyType : getTypeFromBindingElement(e, includePatternInType, reportErrors) */ TODO
		})
		minLength := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): findLastIndex(elements, e => !(e === restElement || isOmittedExpression(e) || hasDefaultValue(e)), elements.length - 1) + 1 */ TODO
		elementFlags := map_(elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").OmittedExpression */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Required | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Optional | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Rest */ TODO {
			return /* TODO(ConditionalExpression): e === restElement ? ElementFlags.Rest : i >= minLength ? ElementFlags.Optional : ElementFlags.Required */ TODO
		})
		result := createTupleType(elementTypes, elementFlags)
		if includePatternInType {
			result = cloneTypeReference(result)
			result.pattern = pattern
			result.objectFlags |= ObjectFlagsContainsObjectOrArrayLiteral
		}
		return result
	}
	getTypeFromBindingPattern := func(pattern BindingPattern, includePatternInType /* TODO inferred type boolean */ TODO /*  = false */, reportErrors /* TODO inferred type boolean */ TODO /*  = false */) Type {
		if includePatternInType {
			contextualBindingPatterns.push(pattern)
		}
		result := /* TODO(ConditionalExpression): pattern.kind === SyntaxKind.ObjectBindingPattern             ? getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors)             : getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors) */ TODO
		if includePatternInType {
			contextualBindingPatterns.pop()
		}
		return result
	}
	getWidenedTypeForVariableLikeDeclaration := func(declaration /* TODO(UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, reportErrors bool) Type {
		return widenTypeForVariableLikeDeclaration(getTypeForVariableLikeDeclaration(declaration, true, CheckModeNormal), declaration, reportErrors)
	}
	getTypeFromImportAttributes := func(node ImportAttributes) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			symbol := createSymbol(SymbolFlagsObjectLiteral, InternalSymbolNameImportAttributes)
			members := createSymbolTable()
			forEach(node.elements, func(attr /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ImportAttribute */ TODO) {
				member := createSymbol(SymbolFlagsProperty, getNameFromImportAttribute(attr))
				member.parent = symbol
				member.links.type_ = checkImportAttribute(attr)
				member.links.target = member
				members.set(member.escapedName, member)
			})
			type_ := createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
			type_.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsNonInferrableType
			links.resolvedType = type_
		}
		return links.resolvedType
	}
	isGlobalSymbolConstructor := func(node Node) /* TODO inferred type boolean | undefined */ TODO {
		symbol := getSymbolOfNode(node)
		globalSymbol := getGlobalESSymbolConstructorTypeSymbol(false)
		return globalSymbol && symbol && symbol == globalSymbol
	}
	widenTypeForVariableLikeDeclaration := func(type_ *Type, declaration /* TODO(AnyKeyword): any */ any, reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if type_ {
			if type_.flags&TypeFlagsESSymbol && isGlobalSymbolConstructor(declaration.parent) {
				type_ = getESSymbolLikeTypeForNode(declaration)
			}
			if reportErrors {
				reportErrorsFromWidening(declaration, type_)
			}
			if type_.flags&TypeFlagsUniqueESSymbol && (isBindingElement(declaration) || !declaration.type_) && type_.symbol != getSymbolOfDeclaration(declaration) {
				type_ = esSymbolType
			}
			return getWidenedType(type_)
		}
		type_ = /* TODO(ConditionalExpression): isParameter(declaration) && declaration.dotDotDotToken ? anyArrayType : anyType */ TODO
		if reportErrors {
			if !declarationBelongsToPrivateAmbientMember(declaration) {
				reportImplicitAny(declaration, type_)
			}
		}
		return type_
	}
	declarationBelongsToPrivateAmbientMember := func(declaration VariableLikeDeclaration) /* TODO inferred type boolean */ TODO {
		root := getRootDeclaration(declaration)
		memberDeclaration := /* TODO(ConditionalExpression): root.kind === SyntaxKind.Parameter ? root.parent : root */ TODO
		return isPrivateWithinAmbient(memberDeclaration)
	}
	tryGetTypeFromEffectiveTypeNode := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		typeNode := getEffectiveTypeAnnotationNode(node)
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
	}
	isParameterOfContextSensitiveSignature := func(symbol Symbol) /* TODO inferred type boolean */ TODO {
		decl := symbol.valueDeclaration
		if !decl {
			return false
		}
		if isBindingElement(decl) {
			decl = walkUpBindingElementsAndPatterns(decl)
		}
		if isParameter(decl) {
			return isContextSensitiveFunctionOrObjectLiteralMethod(decl.parent)
		}
		return false
	}
	getTypeOfVariableOrParameterOrProperty := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			type_ := getTypeOfVariableOrParameterOrPropertyWorker(symbol)
			if !links.type_ && !isParameterOfContextSensitiveSignature(symbol) {
				links.type_ = type_
			}
			return type_
		}
		return links.type_
	}
	getTypeOfVariableOrParameterOrPropertyWorker := func(symbol Symbol) Type {
		if symbol.flags & SymbolFlagsPrototype {
			return getTypeOfPrototypeProperty(symbol)
		}
		if symbol == requireSymbol {
			return anyType
		}
		if symbol.flags&SymbolFlagsModuleExports && symbol.valueDeclaration {
			fileSymbol := getSymbolOfDeclaration(getSourceFileOfNode(symbol.valueDeclaration))
			result := createSymbol(fileSymbol.flags, "exports")
			result.declarations = /* TODO(ConditionalExpression): fileSymbol.declarations ? fileSymbol.declarations.slice() : [] */ TODO
			result.parent = symbol
			result.links.target = fileSymbol
			if fileSymbol.valueDeclaration {
				result.valueDeclaration = fileSymbol.valueDeclaration
			}
			if fileSymbol.members {
				result.members = /* TODO(NewExpression): new Map(fileSymbol.members) */ TODO
			}
			if fileSymbol.exports {
				result.exports = /* TODO(NewExpression): new Map(fileSymbol.exports) */ TODO
			}
			members := createSymbolTable()
			members.set("exports", result)
			return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
		}
		Debug.assertIsDefined(symbol.valueDeclaration)
		declaration := symbol.valueDeclaration
		if isSourceFile(declaration) && isJsonSourceFile(declaration) {
			if !declaration.statements.length {
				return emptyObjectType
			}
			return getWidenedType(getWidenedLiteralType(checkExpression( /* TODO(ElementAccessExpression): declaration.statements[0] */ TODO.expression)))
		}
		if isAccessor(declaration) {
			return getTypeOfAccessors(symbol)
		}
		if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
			if symbol.flags&SymbolFlagsValueModule && !(symbol.flags & SymbolFlagsAssignment) {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			return reportCircularityError(symbol)
		}
		var type_ Type
		if declaration.kind == SyntaxKindExportAssignment {
			type_ = widenTypeForVariableLikeDeclaration(tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionCached((declaration).expression), declaration)
		} else if isBinaryExpression(declaration) || (isInJSFile(declaration) && (isCallExpression(declaration) || (isPropertyAccessExpression(declaration) || isBindableStaticElementAccessExpression(declaration)) && isBinaryExpression(declaration.parent))) {
			type_ = getWidenedTypeForAssignmentDeclaration(symbol)
		} else if isPropertyAccessExpression(declaration) || isElementAccessExpression(declaration) || isIdentifier(declaration) || isStringLiteralLike(declaration) || isNumericLiteral(declaration) || isClassDeclaration(declaration) || isFunctionDeclaration(declaration) || (isMethodDeclaration(declaration) && !isObjectLiteralMethod(declaration)) || isMethodSignature(declaration) || isSourceFile(declaration) {
			if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsEnum | SymbolFlagsValueModule) {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			type_ = /* TODO(ConditionalExpression): isBinaryExpression(declaration.parent) ?                 getWidenedTypeForAssignmentDeclaration(symbol) :                 tryGetTypeFromEffectiveTypeNode(declaration) || anyType */ TODO
		} else if isPropertyAssignment(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkPropertyAssignment(declaration)
		} else if isJsxAttribute(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(declaration)
		} else if isShorthandPropertyAssignment(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(declaration.name, CheckModeNormal)
		} else if isObjectLiteralMethod(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(declaration, CheckModeNormal)
		} else if isParameter(declaration) || isPropertyDeclaration(declaration) || isPropertySignature(declaration) || isVariableDeclaration(declaration) || isBindingElement(declaration) || isJSDocPropertyLikeTag(declaration) {
			type_ = getWidenedTypeForVariableLikeDeclaration(declaration, true)
		} else if isEnumDeclaration(declaration) {
			type_ = getTypeOfFuncClassEnumModule(symbol)
		} else if isEnumMember(declaration) {
			type_ = getTypeOfEnumMember(symbol)
		} else {
			return Debug.fail( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "Unhandled declaration kind! " + Debug.formatSyntaxKind(declaration.kind) + " for " + Debug.formatSymbol(symbol) */ TODO)
		}
		if !popTypeResolution() {
			if symbol.flags&SymbolFlagsValueModule && !(symbol.flags & SymbolFlagsAssignment) {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			return reportCircularityError(symbol)
		}
		return type_
	}
	getAnnotatedAccessorTypeNode := func(accessor /* TODO(UnionType): AccessorDeclaration | PropertyDeclaration | undefined */ any) *TypeNode {
		if accessor {
			switch accessor.kind {
			case SyntaxKindGetAccessor:
				getterTypeAnnotation := getEffectiveReturnTypeNode(accessor)
				return getterTypeAnnotation
			case SyntaxKindSetAccessor:
				setterTypeAnnotation := getEffectiveSetAccessorTypeAnnotationNode(accessor)
				return setterTypeAnnotation
			case SyntaxKindPropertyDeclaration:
				Debug.assert(hasAccessorModifier(accessor))
				accessorTypeAnnotation := getEffectiveTypeAnnotationNode(accessor)
				return accessorTypeAnnotation
			}
		}
		return nil
	}
	getAnnotatedAccessorType := func(accessor /* TODO(UnionType): AccessorDeclaration | PropertyDeclaration | undefined */ any) *Type {
		node := getAnnotatedAccessorTypeNode(accessor)
		return node && getTypeFromTypeNode(node)
	}
	getAnnotatedAccessorThisParameter := func(accessor AccessorDeclaration) *Symbol {
		parameter := getAccessorThisParameter(accessor)
		return parameter && parameter.symbol
	}
	getThisTypeOfDeclaration := func(declaration SignatureDeclaration) *Type {
		return getThisTypeOfSignature(getSignatureFromDeclaration(declaration))
	}
	getTypeOfAccessors := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
				return errorType
			}
			getter := getDeclarationOfKind(symbol, SyntaxKindGetAccessor)
			setter := getDeclarationOfKind(symbol, SyntaxKindSetAccessor)
			accessor := tryCast(getDeclarationOfKind(symbol, SyntaxKindPropertyDeclaration), isAutoAccessorPropertyDeclaration)
			type_ := getter && isInJSFile(getter) && getTypeForDeclarationFromJSDocComment(getter) || getAnnotatedAccessorType(getter) || getAnnotatedAccessorType(setter) || getAnnotatedAccessorType(accessor) || getter && getter.body && getReturnTypeFromBody(getter) || accessor && accessor.initializer && getWidenedTypeForVariableLikeDeclaration(accessor, true)
			if !type_ {
				if setter && !isPrivateWithinAmbient(setter) {
					errorOrSuggestion(noImplicitAny, setter, Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation, symbolToString(symbol))
				} else if getter && !isPrivateWithinAmbient(getter) {
					errorOrSuggestion(noImplicitAny, getter, Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation, symbolToString(symbol))
				} else if accessor && !isPrivateWithinAmbient(accessor) {
					errorOrSuggestion(noImplicitAny, accessor, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), "any")
				}
				type_ = anyType
			}
			if !popTypeResolution() {
				if getAnnotatedAccessorTypeNode(getter) {
					error(getter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				} else if getAnnotatedAccessorTypeNode(setter) {
					error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				} else if getAnnotatedAccessorTypeNode(accessor) {
					error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				} else if getter && noImplicitAny {
					error(getter, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, symbolToString(symbol))
				}
				type_ = anyType
			}
			/* TODO(ExpressionStatement): links.type ??= type; */
		}
		return links.type_
	}
	getWriteTypeOfAccessors := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.writeType {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameWriteType) {
				return errorType
			}
			setter := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getDeclarationOfKind<AccessorDeclaration>(symbol, SyntaxKind.SetAccessor)                 ?? tryCast(getDeclarationOfKind<PropertyDeclaration>(symbol, SyntaxKind.PropertyDeclaration), isAutoAccessorPropertyDeclaration) */ TODO
			writeType := getAnnotatedAccessorType(setter)
			if !popTypeResolution() {
				if getAnnotatedAccessorTypeNode(setter) {
					error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				}
				writeType = anyType
			}
			/* TODO(ExpressionStatement): links.writeType ??= writeType || getTypeOfAccessors(symbol); */
		}
		return links.writeType
	}
	getBaseTypeVariableOfClass := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		baseConstructorType := getBaseConstructorTypeOfClass(getDeclaredTypeOfClassOrInterface(symbol))
		return /* TODO(ConditionalExpression): baseConstructorType.flags & TypeFlags.TypeVariable ? baseConstructorType :             baseConstructorType.flags & TypeFlags.Intersection ? find((baseConstructorType as IntersectionType).types, t => !!(t.flags & TypeFlags.TypeVariable)) :             undefined */ TODO
	}
	getTypeOfFuncClassEnumModule := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		originalLinks := links
		if !links.type_ {
			expando := symbol.valueDeclaration && getSymbolOfExpando(symbol.valueDeclaration, false)
			if expando {
				merged := mergeJSSymbols(symbol, expando)
				if merged {
					symbol = merged
					links = merged.links
				}
			}
			originalLinks.type_ = /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.type = getTypeOfFuncClassEnumModuleWorker(symbol) */ TODO
		}
		return links.type_
	}
	getTypeOfFuncClassEnumModuleWorker := func(symbol Symbol) Type {
		declaration := symbol.valueDeclaration
		if symbol.flags&SymbolFlagsModule && isShorthandAmbientModuleSymbol(symbol) {
			return anyType
		} else if declaration && (declaration.kind == SyntaxKindBinaryExpression || isAccessExpression(declaration) && declaration.parent.kind == SyntaxKindBinaryExpression) {
			return getWidenedTypeForAssignmentDeclaration(symbol)
		} else if symbol.flags&SymbolFlagsValueModule && declaration && isSourceFile(declaration) && declaration.commonJsModuleIndicator {
			resolvedModule := resolveExternalModuleSymbol(symbol)
			if resolvedModule != symbol {
				if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
					return errorType
				}
				exportEquals := getMergedSymbol(symbol.exports.get(InternalSymbolNameExportEquals))
				type_ := getWidenedTypeForAssignmentDeclaration(exportEquals /* TODO(ConditionalExpression): exportEquals === resolvedModule ? undefined : resolvedModule */, TODO)
				if !popTypeResolution() {
					return reportCircularityError(symbol)
				}
				return type_
			}
		}
		type_ := createObjectType(ObjectFlagsAnonymous, symbol)
		if symbol.flags & SymbolFlagsClass {
			baseTypeVariable := getBaseTypeVariableOfClass(symbol)
			return /* TODO(ConditionalExpression): baseTypeVariable ? getIntersectionType([type, baseTypeVariable]) : type */ TODO
		} else {
			return /* TODO(ConditionalExpression): strictNullChecks && symbol.flags & SymbolFlags.Optional ? getOptionalType(type, /*isProperty* / true) : type */ TODO
		}
	}
	getTypeOfEnumMember := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.type_ || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.type = getDeclaredTypeOfEnumMember(symbol) */ TODO)
	}
	getTypeOfAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
				return errorType
			}
			targetSymbol := resolveAlias(symbol)
			exportSymbol := symbol.declarations && getTargetOfAliasDeclaration(getDeclarationOfAliasSymbol(symbol), true)
			declaredType := firstDefined(exportSymbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
				return /* TODO(ConditionalExpression): isExportAssignment(d) ? tryGetTypeFromEffectiveTypeNode(d) : undefined */ TODO
			})
			/* TODO(ExpressionStatement): links.type ??= exportSymbol?.declarations && isDuplicatedCommonJSExport(exportSymbol.declarations) && symbol.declarations!.length ? getFlowTypeFromCommonJSExport(exportSymbol)                 : isDuplicatedCommonJSExport(symbol.declarations) ? autoType                 : declaredType ? declaredType                 : getSymbolFlags(targetSymbol) & SymbolFlags.Value ? getTypeOfSymbol(targetSymbol)                 : errorType; */
			if !popTypeResolution() {
				reportCircularityError( /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): exportSymbol ?? symbol */ TODO)
				return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): links.type ??= errorType */ TODO
			}
		}
		return links.type_
	}
	getTypeOfInstantiatedSymbol := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.type_ || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.type = instantiateType(getTypeOfSymbol(links.target!), links.mapper) */ TODO)
	}
	getWriteTypeOfInstantiatedSymbol := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.writeType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.writeType = instantiateType(getWriteTypeOfSymbol(links.target!), links.mapper) */ TODO)
	}
	reportCircularityError := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
		declaration := symbol.valueDeclaration
		if declaration {
			if getEffectiveTypeAnnotationNode(declaration) {
				error(symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				return errorType
			}
			if noImplicitAny && (declaration.kind != SyntaxKindParameter || (declaration).initializer) {
				error(symbol.valueDeclaration, Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer, symbolToString(symbol))
			}
		} else if symbol.flags & SymbolFlagsAlias {
			node := getDeclarationOfAliasSymbol(symbol)
			if node {
				error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol))
			}
		}
		return anyType
	}
	getTypeOfSymbolWithDeferredType := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			Debug.assertIsDefined(links.deferralParent)
			Debug.assertIsDefined(links.deferralConstituents)
			links.type_ = /* TODO(ConditionalExpression): links.deferralParent.flags & TypeFlags.Union ? getUnionType(links.deferralConstituents) : getIntersectionType(links.deferralConstituents) */ TODO
		}
		return links.type_
	}
	getWriteTypeOfSymbolWithDeferredType := func(symbol Symbol) *Type {
		links := getSymbolLinks(symbol)
		if !links.writeType && links.deferralWriteConstituents {
			Debug.assertIsDefined(links.deferralParent)
			Debug.assertIsDefined(links.deferralConstituents)
			links.writeType = /* TODO(ConditionalExpression): links.deferralParent.flags & TypeFlags.Union ? getUnionType(links.deferralWriteConstituents) : getIntersectionType(links.deferralWriteConstituents) */ TODO
		}
		return links.writeType
	}
	getWriteTypeOfSymbol := func(symbol Symbol) Type {
		checkFlags := getCheckFlags(symbol)
		if symbol.flags & SymbolFlagsProperty {
			return /* TODO(ConditionalExpression): checkFlags & CheckFlags.SyntheticProperty ?                 checkFlags & CheckFlags.DeferredType ?                     getWriteTypeOfSymbolWithDeferredType(symbol) || getTypeOfSymbolWithDeferredType(symbol) :                     // NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.SyntheticProperty                     (symbol as TransientSymbol).links.writeType || (symbol as TransientSymbol).links.type! :                 removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlags.Optional)) */ TODO
		}
		if symbol.flags & SymbolFlagsAccessor {
			return /* TODO(ConditionalExpression): checkFlags & CheckFlags.Instantiated ?                 getWriteTypeOfInstantiatedSymbol(symbol) :                 getWriteTypeOfAccessors(symbol) */ TODO
		}
		return getTypeOfSymbol(symbol)
	}
	getTypeOfSymbol := func(symbol Symbol) Type {
		checkFlags := getCheckFlags(symbol)
		if checkFlags & CheckFlagsDeferredType {
			return getTypeOfSymbolWithDeferredType(symbol)
		}
		if checkFlags & CheckFlagsInstantiated {
			return getTypeOfInstantiatedSymbol(symbol)
		}
		if checkFlags & CheckFlagsMapped {
			return getTypeOfMappedSymbol(symbol)
		}
		if checkFlags & CheckFlagsReverseMapped {
			return getTypeOfReverseMappedSymbol(symbol)
		}
		if symbol.flags & (SymbolFlagsVariable | SymbolFlagsProperty) {
			return getTypeOfVariableOrParameterOrProperty(symbol)
		}
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsEnum | SymbolFlagsValueModule) {
			return getTypeOfFuncClassEnumModule(symbol)
		}
		if symbol.flags & SymbolFlagsEnumMember {
			return getTypeOfEnumMember(symbol)
		}
		if symbol.flags & SymbolFlagsAccessor {
			return getTypeOfAccessors(symbol)
		}
		if symbol.flags & SymbolFlagsAlias {
			return getTypeOfAlias(symbol)
		}
		return errorType
	}
	getNonMissingTypeOfSymbol := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlagsOptional))
	}
	isReferenceToSomeType := func(type_ Type, targets []Type) /* TODO inferred type boolean */ TODO {
		if type_ == nil || (getObjectFlags(type_)&ObjectFlagsReference) == 0 {
			return false
		}
		for _, target := range targets {
			if (type_).target == target {
				return true
			}
		}
		return false
	}
	isReferenceToType := func(type_ Type, target Type) /* TODO inferred type boolean */ TODO {
		return type_ != nil && target != nil && (getObjectFlags(type_)&ObjectFlagsReference) != 0 && (type_).target == target
	}
	getTargetType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).target : type */ TODO
	}
	hasBaseType := func(type_ Type, checkBase *Type) /* TODO inferred type boolean */ TODO {
		return check(type_)
		check := func(type_ Type) bool {
			if getObjectFlags(type_) & (ObjectFlagsClassOrInterface | ObjectFlagsReference) {
				target := getTargetType(type_)
				return target == checkBase || some(getBaseTypes(target), check)
			} else if type_.flags & TypeFlagsIntersection {
				return some((type_).types, check)
			}
			return false
		}
	}
	appendTypeParameters := func(typeParameters /* TODO(ArrayType): TypeParameter[] */ any, declarations []TypeParameterDeclaration) /* TODO(ArrayType): TypeParameter[] */ any {
		for _, declaration := range declarations {
			typeParameters = appendIfUnique(typeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(declaration)))
		}
		return typeParameters
	}
	getOuterTypeParameters := func(node Node, includeThisTypes bool) /* TODO(ArrayType): TypeParameter[] */ any {
		for true {
			node = node.parent
			if node && isBinaryExpression(node) {
				assignmentKind := getAssignmentDeclarationKind(node)
				if assignmentKind == AssignmentDeclarationKindPrototype || assignmentKind == AssignmentDeclarationKindPrototypeProperty {
					symbol := getSymbolOfDeclaration(node.left)
					if symbol && symbol.parent && !findAncestor(symbol.parent.valueDeclaration, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
						return node == d
					}) {
						node = symbol.parent.valueDeclaration
					}
				}
			}
			if !node {
				return nil
			}
			kind := node.kind
			switch kind {
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindClassExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindCallSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionType:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructorType:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocFunctionType:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindArrowFunction:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeAliasDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocTemplateTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocTypedefTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocEnumTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocCallbackTag:
				fallthrough // TODO: merge cases
			case SyntaxKindMappedType:
				fallthrough // TODO: merge cases
			case SyntaxKindConditionalType:
				outerTypeParameters := getOuterTypeParameters(node, includeThisTypes)
				if (kind == SyntaxKindFunctionExpression || kind == SyntaxKindArrowFunction || isObjectLiteralMethod(node)) && isContextSensitive(node) {
					signature := firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node)), SignatureKindCall))
					if signature && signature.typeParameters {
						return /* TODO(ArrayLiteralExpression): [...(outerTypeParameters || emptyArray), ...signature.typeParameters] */ TODO
					}
				}
				if kind == SyntaxKindMappedType {
					return append(outerTypeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration((node).typeParameter)))
				} else if kind == SyntaxKindConditionalType {
					return concatenate(outerTypeParameters, getInferTypeParameters(node))
				}
				outerAndOwnTypeParameters := appendTypeParameters(outerTypeParameters, getEffectiveTypeParameterDeclarations(node))
				thisType := includeThisTypes && (kind == SyntaxKindClassDeclaration || kind == SyntaxKindClassExpression || kind == SyntaxKindInterfaceDeclaration || isJSConstructor(node)) && getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node)).thisType
				return /* TODO(ConditionalExpression): thisType ? append(outerAndOwnTypeParameters, thisType) : outerAndOwnTypeParameters */ TODO
				fallthrough
			case SyntaxKindJSDocParameterTag:
				paramSymbol := getParameterSymbolFromJSDoc(node)
				if paramSymbol {
					node = paramSymbol.valueDeclaration
				}
				break
			case SyntaxKindJSDoc:
				outerTypeParameters := getOuterTypeParameters(node, includeThisTypes)
				return /* TODO(ConditionalExpression): (node as JSDoc).tags                         ? appendTypeParameters(outerTypeParameters, flatMap((node as JSDoc).tags, t => isJSDocTemplateTag(t) ? t.typeParameters : undefined))                         : outerTypeParameters */ TODO
			}
		}
	}
	getOuterTypeParametersOfClassOrInterface := func(symbol Symbol) /* TODO(ArrayType): TypeParameter[] */ any {
		declaration := /* TODO(ConditionalExpression): (symbol.flags & SymbolFlags.Class || symbol.flags & SymbolFlags.Function)             ? symbol.valueDeclaration             : symbol.declarations?.find(decl => {                 if (decl.kind === SyntaxKind.InterfaceDeclaration) {                     return true;                 }                 if (decl.kind !== SyntaxKind.VariableDeclaration) {                     return false;                 }                 const initializer = (decl as VariableDeclaration).initializer;                 return !!initializer && (initializer.kind === SyntaxKind.FunctionExpression || initializer.kind === SyntaxKind.ArrowFunction);             })! */ TODO
		Debug.assert(!!declaration, "Class was missing valueDeclaration -OR- non-class had no interface declarations")
		return getOuterTypeParameters(declaration)
	}
	getLocalTypeParametersOfClassOrInterfaceOrTypeAlias := func(symbol Symbol) /* TODO(ArrayType): TypeParameter[] */ any {
		if !symbol.declarations {
			return
		}
		var result /* TODO(ArrayType): TypeParameter[] */ any
		for _, node := range symbol.declarations {
			if node.kind == SyntaxKindInterfaceDeclaration || node.kind == SyntaxKindClassDeclaration || node.kind == SyntaxKindClassExpression || isJSConstructor(node) || isTypeAlias(node) {
				declaration := node
				result = appendTypeParameters(result, getEffectiveTypeParameterDeclarations(declaration))
			}
		}
		return result
	}
	getTypeParametersOfClassOrInterface := func(symbol Symbol) /* TODO(ArrayType): TypeParameter[] */ any {
		return concatenate(getOuterTypeParametersOfClassOrInterface(symbol), getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol))
	}
	isMixinConstructorType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		signatures := getSignaturesOfType(type_, SignatureKindConstruct)
		if signatures.length == 1 {
			s := /* TODO(ElementAccessExpression): signatures[0] */ TODO
			if !s.typeParameters && s.parameters.length == 1 && signatureHasRestParameter(s) {
				paramType := getTypeOfParameter( /* TODO(ElementAccessExpression): s.parameters[0] */ TODO)
				return isTypeAny(paramType) || getElementTypeOfArrayType(paramType) == anyType
			}
		}
		return false
	}
	isConstructorType := func(type_ Type) bool {
		if getSignaturesOfType(type_, SignatureKindConstruct).length > 0 {
			return true
		}
		if type_.flags & TypeFlagsTypeVariable {
			constraint := getBaseConstraintOfType(type_)
			return !!constraint && isMixinConstructorType(constraint)
		}
		return false
	}
	getBaseTypeNodeOfClass := func(type_ InterfaceType) *ExpressionWithTypeArguments {
		decl := getClassLikeDeclarationOfSymbol(type_.symbol)
		return decl && getEffectiveBaseTypeNode(decl)
	}
	getConstructorsForTypeArguments := func(type_ Type, typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any, location Node) []Signature {
		typeArgCount := length(typeArgumentNodes)
		isJavascript := isInJSFile(location)
		return filter(getSignaturesOfType(type_, SignatureKindConstruct), func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
			return (isJavascript || typeArgCount >= getMinTypeArgumentCount(sig.typeParameters)) && typeArgCount <= length(sig.typeParameters)
		})
	}
	getInstantiatedConstructorsForTypeArguments := func(type_ Type, typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any, location Node) []Signature {
		signatures := getConstructorsForTypeArguments(type_, typeArgumentNodes, location)
		typeArguments := map_(typeArgumentNodes, getTypeFromTypeNode)
		return sameMap(signatures, func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
			return /* TODO(ConditionalExpression): some(sig.typeParameters) ? getSignatureInstantiation(sig, typeArguments, isInJSFile(location)) : sig */ TODO
		})
	}
	getBaseConstructorTypeOfClass := func(type_ InterfaceType) Type {
		if !type_.resolvedBaseConstructorType {
			decl := getClassLikeDeclarationOfSymbol(type_.symbol)
			extended := decl && getEffectiveBaseTypeNode(decl)
			baseTypeNode := getBaseTypeNodeOfClass(type_)
			if !baseTypeNode {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseConstructorType = undefinedType */ TODO
			}
			if !pushTypeResolution(type_, TypeSystemPropertyNameResolvedBaseConstructorType) {
				return errorType
			}
			baseConstructorType := checkExpression(baseTypeNode.expression)
			if extended && baseTypeNode != extended {
				Debug.assert(!extended.typeArguments)
				checkExpression(extended.expression)
			}
			if baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection) {
				resolveStructuredTypeMembers(baseConstructorType)
			}
			if !popTypeResolution() {
				error(type_.symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type_.symbol))
				return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): type.resolvedBaseConstructorType ??= errorType */ TODO
			}
			if !(baseConstructorType.flags & TypeFlagsAny) && baseConstructorType != nullWideningType && !isConstructorType(baseConstructorType) {
				err := error(baseTypeNode.expression, Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType))
				if baseConstructorType.flags & TypeFlagsTypeParameter {
					constraint := getConstraintFromTypeParameter(baseConstructorType)
					var ctorReturn Type = unknownType
					if constraint {
						ctorSig := getSignaturesOfType(constraint, SignatureKindConstruct)
						if /* TODO(ElementAccessExpression): ctorSig[0] */ TODO {
							ctorReturn = getReturnTypeOfSignature( /* TODO(ElementAccessExpression): ctorSig[0] */ TODO)
						}
					}
					if baseConstructorType.symbol.declarations {
						addRelatedInfo(err, createDiagnosticForNode( /* TODO(ElementAccessExpression): baseConstructorType.symbol.declarations[0] */ TODO, Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1, symbolToString(baseConstructorType.symbol), typeToString(ctorReturn)))
					}
				}
				return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): type.resolvedBaseConstructorType ??= errorType */ TODO
			}
			/* TODO(ExpressionStatement): type.resolvedBaseConstructorType ??= baseConstructorType; */
		}
		return type_.resolvedBaseConstructorType
	}
	getImplementsTypes := func(type_ InterfaceType) []BaseType {
		var resolvedImplementsTypes []BaseType = emptyArray
		if type_.symbol.declarations {
			for _, declaration := range type_.symbol.declarations {
				implementsTypeNodes := getEffectiveImplementsTypeNodes(declaration)
				if !implementsTypeNodes {
					continue
				}
				for _, node := range implementsTypeNodes {
					implementsType := getTypeFromTypeNode(node)
					if !isErrorType(implementsType) {
						if resolvedImplementsTypes == emptyArray {
							resolvedImplementsTypes = /* TODO(ArrayLiteralExpression): [implementsType as ObjectType] */ TODO
						} else {
							resolvedImplementsTypes.push(implementsType)
						}
					}
				}
			}
		}
		return resolvedImplementsTypes
	}
	reportCircularBaseType := func(node Node, type_ Type) {
		error(node, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type_, nil, TypeFormatFlagsWriteArrayAsGenericType))
	}
	getBaseTypes := func(type_ InterfaceType) []BaseType {
		if !type_.baseTypesResolved {
			if pushTypeResolution(type_, TypeSystemPropertyNameResolvedBaseTypes) {
				if type_.objectFlags & ObjectFlagsTuple {
					type_.resolvedBaseTypes = /* TODO(ArrayLiteralExpression): [getTupleBaseType(type as TupleType)] */ TODO
				} else if type_.symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
					if type_.symbol.flags & SymbolFlagsClass {
						resolveBaseTypesOfClass(type_)
					}
					if type_.symbol.flags & SymbolFlagsInterface {
						resolveBaseTypesOfInterface(type_)
					}
				} else {
					Debug.fail("type must be class or interface")
				}
				if !popTypeResolution() && type_.symbol.declarations {
					for _, declaration := range type_.symbol.declarations {
						if declaration.kind == SyntaxKindClassDeclaration || declaration.kind == SyntaxKindInterfaceDeclaration {
							reportCircularBaseType(declaration, type_)
						}
					}
				}
			}
			type_.baseTypesResolved = true
		}
		return type_.resolvedBaseTypes
	}
	getTupleBaseType := func(type_ TupleType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		elementTypes := sameMap(type_.typeParameters, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return /* TODO(ConditionalExpression): type.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t */ TODO
		})
		return createArrayType(getUnionType(elementTypes || emptyArray), type_.readonly)
	}
	resolveBaseTypesOfClass := func(type_ InterfaceType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BaseType[] */ TODO {
		type_.resolvedBaseTypes = resolvingEmptyArray
		baseConstructorType := getApparentType(getBaseConstructorTypeOfClass(type_))
		if !(baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsAny)) {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
		}
		baseTypeNode := getBaseTypeNodeOfClass(type_)
		var baseType Type
		originalBaseType := /* TODO(ConditionalExpression): baseConstructorType.symbol ? getDeclaredTypeOfSymbol(baseConstructorType.symbol) : undefined */ TODO
		if baseConstructorType.symbol && baseConstructorType.symbol.flags&SymbolFlagsClass && areAllOuterTypeParametersApplied(originalBaseType) {
			baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol)
		} else if baseConstructorType.flags & TypeFlagsAny {
			baseType = baseConstructorType
		} else {
			constructors := getInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.typeArguments, baseTypeNode)
			if !constructors.length {
				error(baseTypeNode.expression, Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments)
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
			}
			baseType = getReturnTypeOfSignature( /* TODO(ElementAccessExpression): constructors[0] */ TODO)
		}
		if isErrorType(baseType) {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
		}
		reducedBaseType := getReducedType(baseType)
		if !isValidBaseType(reducedBaseType) {
			elaboration := elaborateNeverIntersection(nil, baseType)
			diagnostic := chainDiagnosticMessages(elaboration, Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members, typeToString(reducedBaseType))
			diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(baseTypeNode.expression), baseTypeNode.expression, diagnostic))
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
		}
		if type_ == reducedBaseType || hasBaseType(reducedBaseType, type_) {
			error(type_.symbol.valueDeclaration, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type_, nil, TypeFormatFlagsWriteArrayAsGenericType))
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
		}
		if type_.resolvedBaseTypes == resolvingEmptyArray {
			type_.members = nil
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = [reducedBaseType] */ TODO
	}
	areAllOuterTypeParametersApplied := func(type_ Type) bool {
		outerTypeParameters := (type_).outerTypeParameters
		if outerTypeParameters {
			last := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): outerTypeParameters.length - 1 */ TODO
			typeArguments := getTypeArguments(type_)
			return /* TODO(ElementAccessExpression): outerTypeParameters[last] */ TODO.symbol != /* TODO(ElementAccessExpression): typeArguments[last] */ TODO.symbol
		}
		return true
	}
	isValidBaseType := func(type_ Type) /* TODO(TypePredicate): type is BaseType */ any {
		if type_.flags & TypeFlagsTypeParameter {
			constraint := getBaseConstraintOfType(type_)
			if constraint {
				return isValidBaseType(constraint)
			}
		}
		return !!(type_.flags&(TypeFlagsObject|TypeFlagsNonPrimitive|TypeFlagsAny) && !isGenericMappedType(type_) || type_.flags&TypeFlagsIntersection && every((type_).types, isValidBaseType))
	}
	resolveBaseTypesOfInterface := func(type_ InterfaceType) {
		type_.resolvedBaseTypes = type_.resolvedBaseTypes || emptyArray
		if type_.symbol.declarations {
			for _, declaration := range type_.symbol.declarations {
				if declaration.kind == SyntaxKindInterfaceDeclaration && getInterfaceBaseTypeNodes(declaration) {
					for _, node := range getInterfaceBaseTypeNodes(declaration) {
						baseType := getReducedType(getTypeFromTypeNode(node))
						if !isErrorType(baseType) {
							if isValidBaseType(baseType) {
								if type_ != baseType && !hasBaseType(baseType, type_) {
									if type_.resolvedBaseTypes == emptyArray {
										type_.resolvedBaseTypes = /* TODO(ArrayLiteralExpression): [baseType as ObjectType] */ TODO
									} else {
										type_.resolvedBaseTypes.push(baseType)
									}
								} else {
									reportCircularBaseType(declaration, type_)
								}
							} else {
								error(node, Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members)
							}
						}
					}
				}
			}
		}
	}
	isThislessInterface := func(symbol Symbol) bool {
		if !symbol.declarations {
			return true
		}
		for _, declaration := range symbol.declarations {
			if declaration.kind == SyntaxKindInterfaceDeclaration {
				if declaration.flags & NodeFlagsContainsThis {
					return false
				}
				baseTypeNodes := getInterfaceBaseTypeNodes(declaration)
				if baseTypeNodes {
					for _, node := range baseTypeNodes {
						if isEntityNameExpression(node.expression) {
							baseSymbol := resolveEntityName(node.expression, SymbolFlagsType, true)
							if !baseSymbol || !(baseSymbol.flags & SymbolFlagsInterface) || getDeclaredTypeOfClassOrInterface(baseSymbol).thisType {
								return false
							}
						}
					}
				}
			}
		}
		return true
	}
	getDeclaredTypeOfClassOrInterface := func(symbol Symbol) InterfaceType {
		links := getSymbolLinks(symbol)
		originalLinks := links
		if !links.declaredType {
			kind := /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Class ? ObjectFlags.Class : ObjectFlags.Interface */ TODO
			merged := mergeJSSymbols(symbol, symbol.valueDeclaration && getAssignedClassSymbol(symbol.valueDeclaration))
			if merged {
				symbol = merged
				links = merged.links
			}
			type_ := /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol) as InterfaceType */ TODO
			outerTypeParameters := getOuterTypeParametersOfClassOrInterface(symbol)
			localTypeParameters := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
			if outerTypeParameters || localTypeParameters || kind == ObjectFlagsClass || !isThislessInterface(symbol) {
				type_.objectFlags |= ObjectFlagsReference
				type_.typeParameters = concatenate(outerTypeParameters, localTypeParameters)
				type_.outerTypeParameters = outerTypeParameters
				type_.localTypeParameters = localTypeParameters
				(type_).instantiations = make(map[string]TypeReference)
				(type_).instantiations.set(getTypeListId(type_.typeParameters), type_)
				(type_).target = type_
				(type_).resolvedTypeArguments = type_.typeParameters
				type_.thisType = createTypeParameter(symbol)
				type_.thisType.isThisType = true
				type_.thisType.constraint = type_
			}
		}
		return links.declaredType
	}
	getDeclaredTypeOfTypeAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.declaredType {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameDeclaredType) {
				return errorType
			}
			declaration := Debug.checkDefined(symbol.declarations.find(isTypeAlias), "Type alias symbol with no valid declaration found")
			typeNode := /* TODO(ConditionalExpression): isJSDocTypeAlias(declaration) ? declaration.typeExpression : declaration.type */ TODO
			type_ := /* TODO(ConditionalExpression): typeNode ? getTypeFromTypeNode(typeNode) : errorType */ TODO
			if popTypeResolution() {
				typeParameters := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				if typeParameters {
					links.typeParameters = typeParameters
					links.instantiations = make(map[string]Type)
					links.instantiations.set(getTypeListId(typeParameters), type_)
				}
				if type_ == intrinsicMarkerType && symbol.escapedName == "BuiltinIteratorReturn" {
					type_ = getBuiltinIteratorReturnType()
				}
			} else {
				type_ = errorType
				if declaration.kind == SyntaxKindJSDocEnumTag {
					error(declaration.typeExpression.type_, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol))
				} else {
					error( /* TODO(ConditionalExpression): isNamedDeclaration(declaration) ? declaration.name || declaration : declaration */ TODO, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol))
				}
			}
			/* TODO(ExpressionStatement): links.declaredType ??= type; */
		}
		return links.declaredType
	}
	getBaseTypeOfEnumLikeType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike && type.symbol.flags & SymbolFlags.EnumMember ? getDeclaredTypeOfSymbol(getParentOfSymbol(type.symbol)!) : type */ TODO
	}
	getDeclaredTypeOfEnum := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.declaredType {
			var memberTypeList []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			if symbol.declarations {
				for _, declaration := range symbol.declarations {
					if declaration.kind == SyntaxKindEnumDeclaration {
						for _, member := range (declaration).members {
							if hasBindableName(member) {
								memberSymbol := getSymbolOfDeclaration(member)
								value := getEnumMemberValue(member).value
								memberType := getFreshTypeOfLiteralType( /* TODO(ConditionalExpression): value !== undefined ?                                         getEnumLiteralType(value, getSymbolId(symbol), memberSymbol) :                                         createComputedEnumType(memberSymbol) */ TODO)
								getSymbolLinks(memberSymbol).declaredType = memberType
								memberTypeList.push(getRegularTypeOfLiteralType(memberType))
							}
						}
					}
				}
			}
			enumType := /* TODO(ConditionalExpression): memberTypeList.length ?                 getUnionType(memberTypeList, UnionReduction.Literal, symbol, /*aliasTypeArguments* / undefined) :                 createComputedEnumType(symbol) */ TODO
			if enumType.flags & TypeFlagsUnion {
				enumType.flags |= TypeFlagsEnumLiteral
				enumType.symbol = symbol
			}
			links.declaredType = enumType
		}
		return links.declaredType
	}
	createComputedEnumType := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EnumType */ TODO {
		regularType := createTypeWithSymbol(TypeFlagsEnum, symbol)
		freshType := createTypeWithSymbol(TypeFlagsEnum, symbol)
		regularType.regularType = regularType
		regularType.freshType = freshType
		freshType.regularType = regularType
		freshType.freshType = freshType
		return regularType
	}
	getDeclaredTypeOfEnumMember := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.declaredType {
			enumType := getDeclaredTypeOfEnum(getParentOfSymbol(symbol))
			if !links.declaredType {
				links.declaredType = enumType
			}
		}
		return links.declaredType
	}
	getDeclaredTypeOfTypeParameter := func(symbol Symbol) TypeParameter {
		links := getSymbolLinks(symbol)
		return links.declaredType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.declaredType = createTypeParameter(symbol) */ TODO)
	}
	getDeclaredTypeOfAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.declaredType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol)) */ TODO)
	}
	getDeclaredTypeOfSymbol := func(symbol Symbol) Type {
		return tryGetDeclaredTypeOfSymbol(symbol) || errorType
	}
	tryGetDeclaredTypeOfSymbol := func(symbol Symbol) *Type {
		if symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
			return getDeclaredTypeOfClassOrInterface(symbol)
		}
		if symbol.flags & SymbolFlagsTypeAlias {
			return getDeclaredTypeOfTypeAlias(symbol)
		}
		if symbol.flags & SymbolFlagsTypeParameter {
			return getDeclaredTypeOfTypeParameter(symbol)
		}
		if symbol.flags & SymbolFlagsEnum {
			return getDeclaredTypeOfEnum(symbol)
		}
		if symbol.flags & SymbolFlagsEnumMember {
			return getDeclaredTypeOfEnumMember(symbol)
		}
		if symbol.flags & SymbolFlagsAlias {
			return getDeclaredTypeOfAlias(symbol)
		}
		return nil
	}
	isThislessType := func(node TypeNode) bool {
		switch node.kind {
		case SyntaxKindAnyKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindUnknownKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindStringKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindNumberKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindBigIntKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindBooleanKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindSymbolKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindObjectKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindVoidKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindUndefinedKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindNeverKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindLiteralType:
			return true
		case SyntaxKindArrayType:
			return isThislessType((node).elementType)
		case SyntaxKindTypeReference:
			return !(node).typeArguments || (node).typeArguments.every(isThislessType)
		}
		return false
	}
	isThislessTypeParameter := func(node TypeParameterDeclaration) /* TODO inferred type boolean */ TODO {
		constraint := getEffectiveConstraintOfTypeParameter(node)
		return !constraint || isThislessType(constraint)
	}
	isThislessVariableLikeDeclaration := func(node VariableLikeDeclaration) bool {
		typeNode := getEffectiveTypeAnnotationNode(node)
		return /* TODO(ConditionalExpression): typeNode ? isThislessType(typeNode) : !hasInitializer(node) */ TODO
	}
	isThislessFunctionLikeDeclaration := func(node FunctionLikeDeclaration) bool {
		returnType := getEffectiveReturnTypeNode(node)
		typeParameters := getEffectiveTypeParameterDeclarations(node)
		return (node.kind == SyntaxKindConstructor || (!!returnType && isThislessType(returnType))) && node.parameters.every(isThislessVariableLikeDeclaration) && typeParameters.every(isThislessTypeParameter)
	}
	isThisless := func(symbol Symbol) bool {
		if symbol.declarations && symbol.declarations.length == 1 {
			declaration := /* TODO(ElementAccessExpression): symbol.declarations[0] */ TODO
			if declaration {
				switch declaration.kind {
				case SyntaxKindPropertyDeclaration:
					fallthrough // TODO: merge cases
				case SyntaxKindPropertySignature:
					return isThislessVariableLikeDeclaration(declaration)
				case SyntaxKindMethodDeclaration:
					fallthrough // TODO: merge cases
				case SyntaxKindMethodSignature:
					fallthrough // TODO: merge cases
				case SyntaxKindConstructor:
					fallthrough // TODO: merge cases
				case SyntaxKindGetAccessor:
					fallthrough // TODO: merge cases
				case SyntaxKindSetAccessor:
					return isThislessFunctionLikeDeclaration(declaration)
				}
			}
		}
		return false
	}
	createInstantiatedSymbolTable := func(symbols []Symbol, mapper TypeMapper, mappingThisOnly bool) SymbolTable {
		result := createSymbolTable()
		for _, symbol := range symbols {
			result.set(symbol.escapedName /* TODO(ConditionalExpression): mappingThisOnly && isThisless(symbol) ? symbol : instantiateSymbol(symbol, mapper) */, TODO)
		}
		return result
	}
	addInheritedMembers := func(symbols SymbolTable, baseSymbols []Symbol) {
		for _, base := range baseSymbols {
			if isStaticPrivateIdentifierProperty(base) {
				continue
			}
			derived := symbols.get(base.escapedName)
			if !derived || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration) && !isConstructorDeclaredProperty(derived) && !getContainingClassStaticBlock(derived.valueDeclaration) {
				symbols.set(base.escapedName, base)
				symbols.set(base.escapedName, base)
			}
		}
	}
	isStaticPrivateIdentifierProperty := func(s Symbol) bool {
		return !!s.valueDeclaration && isPrivateIdentifierClassElementDeclaration(s.valueDeclaration) && isStatic(s.valueDeclaration)
	}
	resolveDeclaredMembers := func(type_ InterfaceType) InterfaceTypeWithDeclaredMembers {
		if !(type_).declaredProperties {
			symbol := type_.symbol
			members := getMembersOfSymbol(symbol)
			(type_).declaredProperties = getNamedMembers(members)
			(type_).declaredCallSignatures = emptyArray
			(type_).declaredConstructSignatures = emptyArray
			(type_).declaredIndexInfos = emptyArray
			(type_).declaredCallSignatures = getSignaturesOfSymbol(members.get(InternalSymbolNameCall))
			(type_).declaredConstructSignatures = getSignaturesOfSymbol(members.get(InternalSymbolNameNew))
			(type_).declaredIndexInfos = getIndexInfosOfSymbol(symbol)
		}
		return type_
	}
	isLateBindableName := func(node DeclarationName) /* TODO(TypePredicate): node is LateBoundName */ any {
		if !isComputedPropertyName(node) && !isElementAccessExpression(node) {
			return false
		}
		expr := /* TODO(ConditionalExpression): isComputedPropertyName(node) ? node.expression : node.argumentExpression */ TODO
		return isEntityNameExpression(expr) && isTypeUsableAsPropertyName( /* TODO(ConditionalExpression): isComputedPropertyName(node) ? checkComputedPropertyName(node) : checkExpressionCached(expr) */ TODO)
	}
	isLateBoundName := func(name __String) bool {
		return (name).charCodeAt(0) == CharacterCodes_ && (name).charCodeAt(1) == CharacterCodes_ && (name).charCodeAt(2) == CharacterCodesat
	}
	hasLateBindableName := func(node Declaration) /* TODO(TypePredicate): node is LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ any {
		name := getNameOfDeclaration(node)
		return !!name && isLateBindableName(name)
	}
	hasBindableName := func(node Declaration) /* TODO inferred type boolean */ TODO {
		return !hasDynamicName(node) || hasLateBindableName(node)
	}
	isNonBindableDynamicName := func(node DeclarationName) /* TODO inferred type boolean */ TODO {
		return isDynamicName(node) && !isLateBindableName(node)
	}
	addDeclarationToLateBoundSymbol := func(symbol Symbol, member /* TODO(UnionType): LateBoundDeclaration | BinaryExpression */ any, symbolFlags SymbolFlags) {
		Debug.assert(!!(getCheckFlags(symbol) & CheckFlagsLate), "Expected a late-bound symbol.")
		symbol.flags |= symbolFlags
		getSymbolLinks(member.symbol).lateSymbol = symbol
		if !symbol.declarations {
			symbol.declarations = /* TODO(ArrayLiteralExpression): [member] */ TODO
		} else if !member.symbol.isReplaceableByMethod {
			symbol.declarations.push(member)
		}
		if symbolFlags & SymbolFlagsValue {
			if !symbol.valueDeclaration || symbol.valueDeclaration.kind != member.kind {
				symbol.valueDeclaration = member
			}
		}
	}
	lateBindMember := func(parent Symbol, earlySymbols *SymbolTable, lateSymbols Map[__String, TransientSymbol], decl /* TODO(UnionType): LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		Debug.assert(!!decl.symbol, "The member is expected to have a symbol.")
		links := getNodeLinks(decl)
		if !links.resolvedSymbol {
			links.resolvedSymbol = decl.symbol
			declName := /* TODO(ConditionalExpression): isBinaryExpression(decl) ? decl.left : decl.name */ TODO
			type_ := /* TODO(ConditionalExpression): isElementAccessExpression(declName) ? checkExpressionCached(declName.argumentExpression) : checkComputedPropertyName(declName) */ TODO
			if isTypeUsableAsPropertyName(type_) {
				memberName := getPropertyNameFromType(type_)
				symbolFlags := decl.symbol.flags
				lateSymbol := lateSymbols.get(memberName)
				if !lateSymbol {
					lateSymbols.set(memberName /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): lateSymbol = createSymbol(SymbolFlags.None, memberName, CheckFlags.Late) */, TODO)
				}
				earlySymbol := earlySymbols && earlySymbols.get(memberName)
				if !(parent.flags & SymbolFlagsClass) && lateSymbol.flags&getExcludedSymbolFlags(symbolFlags) {
					declarations := /* TODO(ConditionalExpression): earlySymbol ? concatenate(earlySymbol.declarations, lateSymbol.declarations) : lateSymbol.declarations */ TODO
					name := !(type_.flags&TypeFlagsUniqueESSymbol) && unescapeLeadingUnderscores(memberName) || declarationNameToString(declName)
					forEach(declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic */ TODO {
						return error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Property_0_was_also_declared_here, name)
					})
					error(declName || decl, Diagnostics.Duplicate_property_0, name)
					lateSymbol = createSymbol(SymbolFlagsNone, memberName, CheckFlagsLate)
				}
				lateSymbol.links.nameType = type_
				addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags)
				if lateSymbol.parent {
					Debug.assert(lateSymbol.parent == parent, "Existing symbol parent should match new one")
				} else {
					lateSymbol.parent = parent
				}
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = lateSymbol */ TODO
			}
		}
		return links.resolvedSymbol
	}
	getResolvedMembersOrExportsOfSymbol := func(symbol Symbol, resolutionKind MembersOrExportsResolutionKind) Map[__String, Symbol] {
		links := getSymbolLinks(symbol)
		if ! /* TODO(ElementAccessExpression): links[resolutionKind] */ TODO {
			isStatic := resolutionKind == MembersOrExportsResolutionKindresolvedExports
			earlySymbols := /* TODO(ConditionalExpression): !isStatic ? symbol.members :                 symbol.flags & SymbolFlags.Module ? getExportsOfModuleWorker(symbol).exports :                 symbol.exports */ TODO
			/* TODO(ElementAccessExpression): links[resolutionKind] */ TODO = earlySymbols || emptySymbols
			lateSymbols := createSymbolTable()
			for _, decl := range symbol.declarations || emptyArray {
				members := getMembersOfDeclaration(decl)
				if members {
					for _, member := range members {
						if isStatic == hasStaticModifier(member) {
							if hasLateBindableName(member) {
								lateBindMember(symbol, earlySymbols, lateSymbols, member)
							}
						}
					}
				}
			}
			assignments := getFunctionExpressionParentSymbolOrSymbol(symbol).assignmentDeclarationMembers
			if assignments {
				decls := arrayFrom(assignments.values())
				for _, member := range decls {
					assignmentKind := getAssignmentDeclarationKind(member)
					isInstanceMember := assignmentKind == AssignmentDeclarationKindPrototypeProperty || isBinaryExpression(member) && isPossiblyAliasedThisProperty(member, assignmentKind) || assignmentKind == AssignmentDeclarationKindObjectDefinePrototypeProperty || assignmentKind == AssignmentDeclarationKindPrototype
					if isStatic == !isInstanceMember {
						if hasLateBindableName(member) {
							lateBindMember(symbol, earlySymbols, lateSymbols, member)
						}
					}
				}
			}
			resolved := combineSymbolTables(earlySymbols, lateSymbols)
			if symbol.flags&SymbolFlagsTransient && links.cjsExportMerged && symbol.declarations {
				for _, decl := range symbol.declarations {
					original := /* TODO(ElementAccessExpression): getSymbolLinks(decl.symbol)[resolutionKind] */ TODO
					if !resolved {
						resolved = original
						continue
					}
					if !original {
						continue
					}
					original.forEach(func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
						existing := resolved.get(name)
						if !existing {
							resolved.set(name, s)
						} else if existing == s {
							return
						} else {
							resolved.set(name, mergeSymbol(existing, s))
						}
					})
				}
			}
			/* TODO(ElementAccessExpression): links[resolutionKind] */ TODO = resolved || emptySymbols
		}
		return /* TODO(ElementAccessExpression): links[resolutionKind] */ TODO
	}
	getMembersOfSymbol := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ TODO {
		return /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.LateBindingContainer             ? getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKind.resolvedMembers)             : symbol.members || emptySymbols */ TODO
	}
	getLateBoundSymbol := func(symbol Symbol) Symbol {
		if symbol.flags&SymbolFlagsClassMember && symbol.escapedName == InternalSymbolNameComputed {
			links := getSymbolLinks(symbol)
			if !links.lateSymbol && some(symbol.declarations, hasLateBindableName) {
				parent := getMergedSymbol(symbol.parent)
				if some(symbol.declarations, hasStaticModifier) {
					getExportsOfSymbol(parent)
				} else {
					getMembersOfSymbol(parent)
				}
			}
			return links.lateSymbol || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.lateSymbol = symbol */ TODO)
		}
		return symbol
	}
	getTypeWithThisArgument := func(type_ Type, thisArgument Type, needApparentType bool) Type {
		if getObjectFlags(type_) & ObjectFlagsReference {
			target := (type_).target
			typeArguments := getTypeArguments(type_)
			return /* TODO(ConditionalExpression): length(target.typeParameters) === length(typeArguments) ? createTypeReference(target, concatenate(typeArguments, [thisArgument || target.thisType!])) : type */ TODO
		} else if type_.flags & TypeFlagsIntersection {
			types := sameMap((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return getTypeWithThisArgument(t, thisArgument, needApparentType)
			})
			return /* TODO(ConditionalExpression): types !== (type as IntersectionType).types ? getIntersectionType(types) : type */ TODO
		}
		return /* TODO(ConditionalExpression): needApparentType ? getApparentType(type) : type */ TODO
	}
	resolveObjectTypeMembers := func(type_ ObjectType, source InterfaceTypeWithDeclaredMembers, typeParameters []TypeParameter, typeArguments []Type) {
		var mapper *TypeMapper
		var members SymbolTable
		var callSignatures []Signature
		var constructSignatures []Signature
		var indexInfos []IndexInfo
		if rangeEquals(typeParameters, typeArguments, 0, typeParameters.length) {
			members = /* TODO(ConditionalExpression): source.symbol ? getMembersOfSymbol(source.symbol) : createSymbolTable(source.declaredProperties) */ TODO
			callSignatures = source.declaredCallSignatures
			constructSignatures = source.declaredConstructSignatures
			indexInfos = source.declaredIndexInfos
		} else {
			mapper = createTypeMapper(typeParameters, typeArguments)
			members = createInstantiatedSymbolTable(source.declaredProperties, mapper, typeParameters.length == 1)
			callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper)
			constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper)
			indexInfos = instantiateIndexInfos(source.declaredIndexInfos, mapper)
		}
		baseTypes := getBaseTypes(source)
		if baseTypes.length {
			if source.symbol && members == getMembersOfSymbol(source.symbol) {
				symbolTable := createSymbolTable(source.declaredProperties)
				sourceIndex := getIndexSymbol(source.symbol)
				if sourceIndex {
					symbolTable.set(InternalSymbolNameIndex, sourceIndex)
				}
				members = symbolTable
			}
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			thisArgument := lastOrUndefined(typeArguments)
			for _, baseType := range baseTypes {
				instantiatedBaseType := /* TODO(ConditionalExpression): thisArgument ? getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument) : baseType */ TODO
				addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType))
				callSignatures = concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKindCall))
				constructSignatures = concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKindConstruct))
				inheritedIndexInfos := /* TODO(ConditionalExpression): instantiatedBaseType !== anyType ? getIndexInfosOfType(instantiatedBaseType) : [createIndexInfo(stringType, anyType, /*isReadonly* / false)] */ TODO
				indexInfos = concatenate(indexInfos, filter(inheritedIndexInfos, func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO inferred type boolean */ TODO {
					return !findIndexInfo(indexInfos, info.keyType)
				}))
			}
		}
		setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
	}
	resolveClassOrInterfaceMembers := func(type_ InterfaceType) {
		resolveObjectTypeMembers(type_, resolveDeclaredMembers(type_), emptyArray, emptyArray)
	}
	resolveTypeReferenceMembers := func(type_ TypeReference) {
		source := resolveDeclaredMembers(type_.target)
		typeParameters := concatenate(source.typeParameters /* TODO(ArrayLiteralExpression): [source.thisType!] */, TODO)
		typeArguments := getTypeArguments(type_)
		paddedTypeArguments := /* TODO(ConditionalExpression): typeArguments.length === typeParameters.length ? typeArguments : concatenate(typeArguments, [type]) */ TODO
		resolveObjectTypeMembers(type_, source, typeParameters, paddedTypeArguments)
	}
	createSignature := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature | undefined */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, thisParameter *Symbol, parameters []Symbol, resolvedReturnType *Type, resolvedTypePredicate *TypePredicate, minArgumentCount number, flags SignatureFlags) Signature {
		sig := /* TODO(NewExpression): new Signature(checker, flags) */ TODO
		sig.declaration = declaration
		sig.typeParameters = typeParameters
		sig.parameters = parameters
		sig.thisParameter = thisParameter
		sig.resolvedReturnType = resolvedReturnType
		sig.resolvedTypePredicate = resolvedTypePredicate
		sig.minArgumentCount = minArgumentCount
		sig.resolvedMinArgumentCount = nil
		sig.target = nil
		sig.mapper = nil
		sig.compositeSignatures = nil
		sig.compositeKind = nil
		return sig
	}
	cloneSignature := func(sig Signature) Signature {
		result := createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, nil, nil, sig.minArgumentCount, sig.flags&SignatureFlagsPropagatingFlags)
		result.target = sig.target
		result.mapper = sig.mapper
		result.compositeSignatures = sig.compositeSignatures
		result.compositeKind = sig.compositeKind
		return result
	}
	createUnionSignature := func(signature Signature, unionSignatures []Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		result := cloneSignature(signature)
		result.compositeSignatures = unionSignatures
		result.compositeKind = TypeFlagsUnion
		result.target = nil
		result.mapper = nil
		return result
	}
	getOptionalCallSignature := func(signature Signature, callChainFlags SignatureFlags) Signature {
		if (signature.flags & SignatureFlagsCallChainFlags) == callChainFlags {
			return signature
		}
		if !signature.optionalCallSignatureCache {
			signature.optionalCallSignatureCache = /* TODO(ObjectLiteralExpression): {} */ TODO
		}
		key := /* TODO(ConditionalExpression): callChainFlags === SignatureFlags.IsInnerCallChain ? "inner" : "outer" */ TODO
		return /* TODO(ElementAccessExpression): signature.optionalCallSignatureCache[key] */ TODO || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): signature.optionalCallSignatureCache[key] = createOptionalCallSignature(signature, callChainFlags) */ TODO)
	}
	createOptionalCallSignature := func(signature Signature, callChainFlags SignatureFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		Debug.assert(callChainFlags == SignatureFlagsIsInnerCallChain || callChainFlags == SignatureFlagsIsOuterCallChain, "An optional call signature can either be for an inner call chain or an outer call chain, but not both.")
		result := cloneSignature(signature)
		result.flags |= callChainFlags
		return result
	}
	getExpandedParameters := func(sig Signature, skipUnionExpanding bool) [][]Symbol {
		if signatureHasRestParameter(sig) {
			restIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sig.parameters.length - 1 */ TODO
			restSymbol := /* TODO(ElementAccessExpression): sig.parameters[restIndex] */ TODO
			restType := getTypeOfSymbol(restSymbol)
			if isTupleType(restType) {
				return /* TODO(ArrayLiteralExpression): [expandSignatureParametersWithTupleMembers(restType, restIndex, restSymbol)] */ TODO
			} else if !skipUnionExpanding && restType.flags&TypeFlagsUnion && every((restType).types, isTupleType) {
				return map_((restType).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
					return expandSignatureParametersWithTupleMembers(t, restIndex, restSymbol)
				})
			}
		}
		return /* TODO(ArrayLiteralExpression): [sig.parameters] */ TODO
		expandSignatureParametersWithTupleMembers := func(restType TupleTypeReference, restIndex number, restSymbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			elementTypes := getTypeArguments(restType)
			associatedNames := getUniqAssociatedNamesFromTupleType(restType, restSymbol)
			restParams := map_(elementTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
				name := /* TODO(ConditionalExpression): associatedNames && associatedNames[i] ? associatedNames[i] :                     getParameterNameAtPosition(sig, restIndex + i, restType) */ TODO
				flags := /* TODO(ElementAccessExpression): restType.target.elementFlags[i] */ TODO
				checkFlags := /* TODO(ConditionalExpression): flags & ElementFlags.Variable ? CheckFlags.RestParameter :                     flags & ElementFlags.Optional ? CheckFlags.OptionalParameter : 0 */ TODO
				symbol := createSymbol(SymbolFlagsFunctionScopedVariable, name, checkFlags)
				symbol.links.type_ = /* TODO(ConditionalExpression): flags & ElementFlags.Rest ? createArrayType(t) : t */ TODO
				return symbol
			})
			return concatenate(sig.parameters.slice(0, restIndex), restParams)
		}
		getUniqAssociatedNamesFromTupleType := func(type_ TupleTypeReference, restSymbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String[] | undefined */ TODO {
			names := map_(type_.target.labeledElementDeclarations, func(labeledElement /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember | undefined */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
				return getTupleElementLabel(labeledElement, i /* TODO(ElementAccessExpression): type.target.elementFlags[i] */, TODO, restSymbol)
			})
			if names {
				var duplicates []number = /* TODO(ArrayLiteralExpression): [] */ TODO
				uniqueNames := make(map[__String]struct{})
				/* TODO(ForStatement): for (let i = 0; i < names.length; i++) {                     const name = names[i];                     if (!tryAddToSet(uniqueNames, name)) {                         duplicates.push(i);                     }                 } */
				counters := make(map[__String]number)
				for _, i := range duplicates {
					counter := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): counters.get(names[i]) ?? 1 */ TODO
					var name __String
					for !tryAddToSet(uniqueNames /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): name = `${names[i]}_${counter}` as __String */, TODO) {
						counter++
					}
					/* TODO(ElementAccessExpression): names[i] */ TODO = name
					counters.set( /* TODO(ElementAccessExpression): names[i] */ TODO /* TODO(PlusToken): + */ /* TODO(BinaryExpression): counter + 1 */, TODO)
				}
			}
			return names
		}
	}
	getDefaultConstructSignatures := func(classType InterfaceType) []Signature {
		baseConstructorType := getBaseConstructorTypeOfClass(classType)
		baseSignatures := getSignaturesOfType(baseConstructorType, SignatureKindConstruct)
		declaration := getClassLikeDeclarationOfSymbol(classType.symbol)
		isAbstract := !!declaration && hasSyntacticModifier(declaration, ModifierFlagsAbstract)
		if baseSignatures.length == 0 {
			return /* TODO(ArrayLiteralExpression): [createSignature(/*declaration* / undefined, classType.localTypeParameters, /*thisParameter* / undefined, emptyArray, classType, /*resolvedTypePredicate* / undefined, 0, isAbstract ? SignatureFlags.Abstract : SignatureFlags.None)] */ TODO
		}
		baseTypeNode := getBaseTypeNodeOfClass(classType)
		isJavaScript := isInJSFile(baseTypeNode)
		typeArguments := typeArgumentsFromTypeReferenceNode(baseTypeNode)
		typeArgCount := length(typeArguments)
		var result []Signature = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, baseSig := range baseSignatures {
			minTypeArgumentCount := getMinTypeArgumentCount(baseSig.typeParameters)
			typeParamCount := length(baseSig.typeParameters)
			if isJavaScript || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount {
				sig := /* TODO(ConditionalExpression): typeParamCount ? createSignatureInstantiation(baseSig, fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript)) : cloneSignature(baseSig) */ TODO
				sig.typeParameters = classType.localTypeParameters
				sig.resolvedReturnType = classType
				sig.flags = /* TODO(ConditionalExpression): isAbstract ? sig.flags | SignatureFlags.Abstract : sig.flags & ~SignatureFlags.Abstract */ TODO
				result.push(sig)
			}
		}
		return result
	}
	findMatchingSignature := func(signatureList []Signature, signature Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool) *Signature {
		for _, s := range signatureList {
			if compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes /* TODO(ConditionalExpression): partialMatch ? compareTypesSubtypeOf : compareTypesIdentical */, TODO) {
				return s
			}
		}
	}
	findMatchingSignatures := func(signatureLists [][]Signature, signature Signature, listIndex number) /* TODO(ArrayType): Signature[] */ any {
		if signature.typeParameters {
			if listIndex > 0 {
				return nil
			}
			/* TODO(ForStatement): for (let i = 1; i < signatureLists.length; i++) {                 if (!findMatchingSignature(signatureLists[i], signature, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / false)) {                     return undefined;                 }             } */
			return /* TODO(ArrayLiteralExpression): [signature] */ TODO
		}
		var result /* TODO(ArrayType): Signature[] */ any
		/* TODO(ForStatement): for (let i = 0; i < signatureLists.length; i++) {             // Allow matching non-generic signatures to have excess parameters (as a fallback if exact parameter match is not found) and different return types.             // Prefer matching this types if possible.             const match = i === listIndex                 ? signature                 : findMatchingSignature(signatureLists[i], signature, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true)                     || findMatchingSignature(signatureLists[i], signature, /*partialMatch* / true, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true);             if (!match) {                 return undefined;             }             result = appendIfUnique(result, match);         } */
		return result
	}
	getUnionSignatures := func(signatureLists [][]Signature) []Signature {
		var result /* TODO(ArrayType): Signature[] */ any
		var indexWithLengthOverOne /* TODO(NumberKeyword): number */ any
		/* TODO(ForStatement): for (let i = 0; i < signatureLists.length; i++) {             if (signatureLists[i].length === 0) return emptyArray;             if (signatureLists[i].length > 1) {                 indexWithLengthOverOne = indexWithLengthOverOne === undefined ? i : -1; // -1 is a signal there are multiple overload sets             }             for (const signature of signatureLists[i]) {                 // Only process signatures with parameter lists that aren't already in the result list                 if (!result || !findMatchingSignature(result, signature, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true)) {                     const unionSignatures = findMatchingSignatures(signatureLists, signature, i);                     if (unionSignatures) {                         let s = signature;                         // Union the result types when more than one signature matches                         if (unionSignatures.length > 1) {                             let thisParameter = signature.thisParameter;                             const firstThisParameterOfUnionSignatures = forEach(unionSignatures, sig => sig.thisParameter);                             if (firstThisParameterOfUnionSignatures) {                                 const thisType = getIntersectionType(mapDefined(unionSignatures, sig => sig.thisParameter && getTypeOfSymbol(sig.thisParameter)));                                 thisParameter = createSymbolWithType(firstThisParameterOfUnionSignatures, thisType);                             }                             s = createUnionSignature(signature, unionSignatures);                             s.thisParameter = thisParameter;                         }                         (result || (result = [])).push(s);                     }                 }             }         } */
		if !length(result) && indexWithLengthOverOne != -1 {
			masterList := /* TODO(ElementAccessExpression): signatureLists[indexWithLengthOverOne !== undefined ? indexWithLengthOverOne : 0] */ TODO
			var results /* TODO(ArrayType): Signature[] */ any = masterList.slice()
			for _, signatures := range signatureLists {
				if signatures != masterList {
					signature := /* TODO(ElementAccessExpression): signatures[0] */ TODO
					Debug.assert(!!signature, "getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass")
					results = /* TODO(ConditionalExpression): !!signature.typeParameters && some(results, s => !!s.typeParameters && !compareTypeParametersIdentical(signature.typeParameters, s.typeParameters)) ? undefined : map(results, sig => combineSignaturesOfUnionMembers(sig, signature)) */ TODO
					if !results {
						break
					}
				}
			}
			result = results
		}
		return result || emptyArray
	}
	compareTypeParametersIdentical := func(sourceParams /* TODO(TypeOperator): readonly TypeParameter[] */ any, targetParams /* TODO(TypeOperator): readonly TypeParameter[] */ any) bool {
		if length(sourceParams) != length(targetParams) {
			return false
		}
		if !sourceParams || !targetParams {
			return true
		}
		mapper := createTypeMapper(targetParams, sourceParams)
		/* TODO(ForStatement): for (let i = 0; i < sourceParams.length; i++) {             const source = sourceParams[i];             const target = targetParams[i];             if (source === target) continue;             // We instantiate the target type parameter constraints into the source types so we can recognize `<T, U extends T>` as the same as `<A, B extends A>`             if (!isTypeIdenticalTo(getConstraintFromTypeParameter(source) || unknownType, instantiateType(getConstraintFromTypeParameter(target) || unknownType, mapper))) return false;             // We don't compare defaults - we just use the type parameter defaults from the first signature that seems to match.             // It might make sense to combine these defaults in the future, but doing so intelligently requires knowing             // if the parameter is used covariantly or contravariantly (so we intersect if it's used like a parameter or union if used like a return type)             // and, since it's just an inference _default_, just picking one arbitrarily works OK.         } */
		return true
	}
	combineUnionThisParam := func(left *Symbol, right *Symbol, mapper *TypeMapper) *Symbol {
		if !left || !right {
			return left || right
		}
		thisType := getIntersectionType( /* TODO(ArrayLiteralExpression): [getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)] */ TODO)
		return createSymbolWithType(left, thisType)
	}
	combineUnionParameters := func(left Signature, right Signature, mapper *TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		leftCount := getParameterCount(left)
		rightCount := getParameterCount(right)
		longest := /* TODO(ConditionalExpression): leftCount >= rightCount ? left : right */ TODO
		shorter := /* TODO(ConditionalExpression): longest === left ? right : left */ TODO
		longestCount := /* TODO(ConditionalExpression): longest === left ? leftCount : rightCount */ TODO
		eitherHasEffectiveRest := hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right)
		needsExtraRestElement := eitherHasEffectiveRest && !hasEffectiveRestParameter(longest)
		params := /* TODO(NewExpression): new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0)) */ TODO
		/* TODO(ForStatement): for (let i = 0; i < longestCount; i++) {             let longestParamType = tryGetTypeAtPosition(longest, i)!;             if (longest === right) {                 longestParamType = instantiateType(longestParamType, mapper);             }             let shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;             if (shorter === right) {                 shorterParamType = instantiateType(shorterParamType, mapper);             }             const unionParamType = getIntersectionType([longestParamType, shorterParamType]);             const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);             const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);             const leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);             const rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);              const paramName = leftName === rightName ? leftName :                 !leftName ? rightName :                 !rightName ? leftName :                 undefined;             const paramSymbol = createSymbol(                 SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0),                 paramName || `arg${i}` as __String,                 isRestParam ? CheckFlags.RestParameter : isOptional ? CheckFlags.OptionalParameter : 0,             );             paramSymbol.links.type = isRestParam ? createArrayType(unionParamType) : unionParamType;             params[i] = paramSymbol;         } */
		if needsExtraRestElement {
			restParamSymbol := createSymbol(SymbolFlagsFunctionScopedVariable, "args", CheckFlagsRestParameter)
			restParamSymbol.links.type_ = createArrayType(getTypeAtPosition(shorter, longestCount))
			if shorter == right {
				restParamSymbol.links.type_ = instantiateType(restParamSymbol.links.type_, mapper)
			}
			/* TODO(ElementAccessExpression): params[longestCount] */ TODO = restParamSymbol
		}
		return params
	}
	combineSignaturesOfUnionMembers := func(left Signature, right Signature) Signature {
		typeParams := left.typeParameters || right.typeParameters
		var paramMapper *TypeMapper
		if left.typeParameters && right.typeParameters {
			paramMapper = createTypeMapper(right.typeParameters, left.typeParameters)
		}
		declaration := left.declaration
		params := combineUnionParameters(left, right, paramMapper)
		thisParam := combineUnionThisParam(left.thisParameter, right.thisParameter, paramMapper)
		minArgCount := Math.max(left.minArgumentCount, right.minArgumentCount)
		result := createSignature(declaration, typeParams, thisParam, params, nil, nil, minArgCount, (left.flags|right.flags)&SignatureFlagsPropagatingFlags)
		result.compositeKind = TypeFlagsUnion
		result.compositeSignatures = concatenate(left.compositeKind != TypeFlagsIntersection && left.compositeSignatures || /* TODO(ArrayLiteralExpression): [left] */ TODO /* TODO(ArrayLiteralExpression): [right] */, TODO)
		if paramMapper {
			result.mapper = /* TODO(ConditionalExpression): left.compositeKind !== TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper */ TODO
		} else if left.compositeKind != TypeFlagsIntersection && left.mapper && left.compositeSignatures {
			result.mapper = left.mapper
		}
		return result
	}
	getUnionIndexInfos := func(types []Type) []IndexInfo {
		sourceInfos := getIndexInfosOfType( /* TODO(ElementAccessExpression): types[0] */ TODO)
		if sourceInfos {
			result := /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, info := range sourceInfos {
				indexType := info.keyType
				if every(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !!getIndexInfoOfType(t, indexType)
				}) {
					result.push(createIndexInfo(indexType, getUnionType(map_(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
						return getIndexTypeOfType(t, indexType)
					})), some(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
						return getIndexInfoOfType(t, indexType).isReadonly
					})))
				}
			}
			return result
		}
		return emptyArray
	}
	resolveUnionTypeMembers := func(type_ UnionType) {
		callSignatures := getUnionSignatures(map_(type_.types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
			return /* TODO(ConditionalExpression): t === globalFunctionType ? [unknownSignature] : getSignaturesOfType(t, SignatureKind.Call) */ TODO
		}))
		constructSignatures := getUnionSignatures(map_(type_.types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
			return getSignaturesOfType(t, SignatureKindConstruct)
		}))
		indexInfos := getUnionIndexInfos(type_.types)
		setStructuredTypeMembers(type_, emptySymbols, callSignatures, constructSignatures, indexInfos)
	}
	// OVERLOAD: intersectTypes := func(type1 Type, type2 Type) Type
	// OVERLOAD: intersectTypes := func(type1 *Type, type2 *Type) *Type
	intersectTypes := func(type1 *Type, type2 *Type) *Type {
		return /* TODO(ConditionalExpression): !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]) */ TODO
	}
	findMixins := func(types []Type) []bool {
		constructorTypeCount := countWhere(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return getSignaturesOfType(t, SignatureKindConstruct).length > 0
		})
		mixinFlags := map_(types, isMixinConstructorType)
		if constructorTypeCount > 0 && constructorTypeCount == countWhere(mixinFlags, func(b /* TODO inferred type boolean */ TODO) /* TODO inferred type boolean */ TODO {
			return b
		}) {
			firstMixinIndex := mixinFlags.indexOf(true)
			/* TODO(ElementAccessExpression): mixinFlags[firstMixinIndex] */ TODO = false
		}
		return mixinFlags
	}
	includeMixinType := func(type_ Type, types []Type, mixinFlags []bool, index number) Type {
		var mixedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             if (i === index) {                 mixedTypes.push(type);             }             else if (mixinFlags[i]) {                 mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], SignatureKind.Construct)[0]));             }         } */
		return getIntersectionType(mixedTypes)
	}
	resolveIntersectionTypeMembers := func(type_ IntersectionType) {
		var callSignatures /* TODO(ArrayType): Signature[] */ any
		var constructSignatures /* TODO(ArrayType): Signature[] */ any
		var indexInfos /* TODO(ArrayType): IndexInfo[] */ any
		types := type_.types
		mixinFlags := findMixins(types)
		mixinCount := countWhere(mixinFlags, func(b /* TODO inferred type boolean */ TODO) /* TODO inferred type boolean */ TODO {
			return b
		})
		/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             const t = type.types[i];             // When an intersection type contains mixin constructor types, the construct signatures from             // those types are discarded and their return types are mixed into the return types of all             // other construct signatures in the intersection type. For example, the intersection type             // '{ new(...args: any[]) => A } & { new(s: string) => B }' has a single construct signature             // 'new(s: string) => A & B'.             if (!mixinFlags[i]) {                 let signatures = getSignaturesOfType(t, SignatureKind.Construct);                 if (signatures.length && mixinCount > 0) {                     signatures = map(signatures, s => {                         const clone = cloneSignature(s);                         clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i);                         return clone;                     });                 }                 constructSignatures = appendSignatures(constructSignatures, signatures);             }             callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, SignatureKind.Call));             indexInfos = reduceLeft(getIndexInfosOfType(t), (infos, newInfo) => appendIndexInfo(infos, newInfo, /*union* / false), indexInfos);         } */
		setStructuredTypeMembers(type_, emptySymbols, callSignatures || emptyArray, constructSignatures || emptyArray, indexInfos || emptyArray)
	}
	appendSignatures := func(signatures /* TODO(ArrayType): Signature[] */ any, newSignatures []Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] | undefined */ TODO {
		for _, sig := range newSignatures {
			if !signatures || every(signatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
				return !compareSignaturesIdentical(s, sig, false, false, false, compareTypesIdentical)
			}) {
				signatures = append(signatures, sig)
			}
		}
		return signatures
	}
	appendIndexInfo := func(indexInfos /* TODO(ArrayType): IndexInfo[] */ any, newInfo IndexInfo, union bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo[] */ TODO {
		if indexInfos {
			/* TODO(ForStatement): for (let i = 0; i < indexInfos.length; i++) {                 const info = indexInfos[i];                 if (info.keyType === newInfo.keyType) {                     indexInfos[i] = createIndexInfo(info.keyType, union ? getUnionType([info.type, newInfo.type]) : getIntersectionType([info.type, newInfo.type]), union ? info.isReadonly || newInfo.isReadonly : info.isReadonly && newInfo.isReadonly);                     return indexInfos;                 }             } */
		}
		return append(indexInfos, newInfo)
	}
	resolveAnonymousTypeMembers := func(type_ AnonymousType) {
		if type_.target {
			setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
			members := createInstantiatedSymbolTable(getPropertiesOfObjectType(type_.target), type_.mapper, false)
			callSignatures := instantiateSignatures(getSignaturesOfType(type_.target, SignatureKindCall), type_.mapper)
			constructSignatures := instantiateSignatures(getSignaturesOfType(type_.target, SignatureKindConstruct), type_.mapper)
			indexInfos := instantiateIndexInfos(getIndexInfosOfType(type_.target), type_.mapper)
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			return
		}
		symbol := getMergedSymbol(type_.symbol)
		if symbol.flags & SymbolFlagsTypeLiteral {
			setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
			members := getMembersOfSymbol(symbol)
			callSignatures := getSignaturesOfSymbol(members.get(InternalSymbolNameCall))
			constructSignatures := getSignaturesOfSymbol(members.get(InternalSymbolNameNew))
			indexInfos := getIndexInfosOfSymbol(symbol)
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			return
		}
		members := getExportsOfSymbol(symbol)
		var indexInfos /* TODO(ArrayType): IndexInfo[] */ any
		if symbol == globalThisSymbol {
			varsOnly := make(map[__String]Symbol)
			members.forEach(func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
				if !(p.flags & SymbolFlagsBlockScoped) && !(p.flags&SymbolFlagsValueModule && p.declarations.length && every(p.declarations, isAmbientModule)) {
					varsOnly.set(p.escapedName, p)
				}
			})
			members = varsOnly
		}
		var baseConstructorIndexInfo *IndexInfo
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, emptyArray)
		if symbol.flags & SymbolFlagsClass {
			classType := getDeclaredTypeOfClassOrInterface(symbol)
			baseConstructorType := getBaseConstructorTypeOfClass(classType)
			if baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsTypeVariable) {
				members = createSymbolTable(getNamedOrIndexSignatureMembers(members))
				addInheritedMembers(members, getPropertiesOfType(baseConstructorType))
			} else if baseConstructorType == anyType {
				baseConstructorIndexInfo = createIndexInfo(stringType, anyType, false)
			}
		}
		indexSymbol := getIndexSymbolFromSymbolTable(members)
		if indexSymbol {
			indexInfos = getIndexInfosOfIndexSymbol(indexSymbol)
		} else {
			if baseConstructorIndexInfo {
				indexInfos = append(indexInfos, baseConstructorIndexInfo)
			}
			if symbol.flags&SymbolFlagsEnum && (getDeclaredTypeOfSymbol(symbol).flags&TypeFlagsEnum || some(type_.properties, func(prop /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
				return !!(getTypeOfSymbol(prop).flags & TypeFlagsNumberLike)
			})) {
				indexInfos = append(indexInfos, enumNumberIndexInfo)
			}
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos || emptyArray)
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod) {
			type_.callSignatures = getSignaturesOfSymbol(symbol)
		}
		if symbol.flags & SymbolFlagsClass {
			classType := getDeclaredTypeOfClassOrInterface(symbol)
			constructSignatures := /* TODO(ConditionalExpression): symbol.members ? getSignaturesOfSymbol(symbol.members.get(InternalSymbolName.Constructor)) : emptyArray */ TODO
			if symbol.flags & SymbolFlagsFunction {
				constructSignatures = addRange(constructSignatures.slice(), mapDefined(type_.callSignatures, func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
					return /* TODO(ConditionalExpression): isJSConstructor(sig.declaration) ?                                 createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType, /*resolvedTypePredicate* / undefined, sig.minArgumentCount, sig.flags & SignatureFlags.PropagatingFlags) :                                 undefined */ TODO
				}))
			}
			if !constructSignatures.length {
				constructSignatures = getDefaultConstructSignatures(classType)
			}
			type_.constructSignatures = constructSignatures
		}
	}
	type ReplaceableIndexedAccessType /* TODO(IntersectionType): IndexedAccessType & { objectType: TypeParameter; indexType: TypeParameter; } */ any
	replaceIndexedAccess := func(instantiable Type, type_ ReplaceableIndexedAccessType, replacement Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return instantiateType(instantiable, createTypeMapper( /* TODO(ArrayLiteralExpression): [type.indexType, type.objectType] */ TODO /* TODO(ArrayLiteralExpression): [getNumberLiteralType(0), createTupleType([replacement])] */, TODO))
	}
	getLimitedConstraint := func(type_ ReverseMappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		constraint := getConstraintTypeFromMappedType(type_.mappedType)
		if !(constraint.flags&TypeFlagsUnion || constraint.flags&TypeFlagsIntersection) {
			return
		}
		origin := /* TODO(ConditionalExpression): (constraint.flags & TypeFlags.Union) ? (constraint as UnionType).origin : (constraint as IntersectionType) */ TODO
		if !origin || !(origin.flags & TypeFlagsIntersection) {
			return
		}
		limitedConstraint := getIntersectionType((origin).types.filter(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return t != type_.constraintType
		}))
		return /* TODO(ConditionalExpression): limitedConstraint !== neverType ? limitedConstraint : undefined */ TODO
	}
	resolveReverseMappedTypeMembers := func(type_ ReverseMappedType) {
		indexInfo := getIndexInfoOfType(type_.source, stringType)
		modifiers := getMappedTypeModifiers(type_.mappedType)
		readonlyMask := /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeReadonly ? false : true */ TODO
		optionalMask := /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeOptional ? 0 : SymbolFlags.Optional */ TODO
		indexInfos := /* TODO(ConditionalExpression): indexInfo ? [createIndexInfo(stringType, inferReverseMappedType(indexInfo.type, type.mappedType, type.constraintType) || unknownType, readonlyMask && indexInfo.isReadonly)] : emptyArray */ TODO
		members := createSymbolTable()
		limitedConstraint := getLimitedConstraint(type_)
		for _, prop := range getPropertiesOfType(type_.source) {
			if limitedConstraint {
				propertyNameType := getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique)
				if !isTypeAssignableTo(propertyNameType, limitedConstraint) {
					continue
				}
			}
			checkFlags := CheckFlagsReverseMapped | ( /* TODO(ConditionalExpression): readonlyMask && isReadonlySymbol(prop) ? CheckFlags.Readonly : 0 */ TODO)
			inferredProp := createSymbol(SymbolFlagsProperty|prop.flags&optionalMask, prop.escapedName, checkFlags)
			inferredProp.declarations = prop.declarations
			inferredProp.links.nameType = getSymbolLinks(prop).nameType
			inferredProp.links.propertyType = getTypeOfSymbol(prop)
			if type_.constraintType.type_.flags&TypeFlagsIndexedAccess && (type_.constraintType.type_).objectType.flags&TypeFlagsTypeParameter && (type_.constraintType.type_).indexType.flags&TypeFlagsTypeParameter {
				newTypeParam := (type_.constraintType.type_).objectType
				newMappedType := replaceIndexedAccess(type_.mappedType, type_.constraintType.type_, newTypeParam)
				inferredProp.links.mappedType = newMappedType
				inferredProp.links.constraintType = getIndexType(newTypeParam)
			} else {
				inferredProp.links.mappedType = type_.mappedType
				inferredProp.links.constraintType = type_.constraintType
			}
			members.set(prop.escapedName, inferredProp)
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos)
	}
	getLowerBoundOfKeyType := func(type_ Type) Type {
		if type_.flags & TypeFlagsIndex {
			t := getApparentType((type_).type_)
			return /* TODO(ConditionalExpression): isGenericTupleType(t) ? getKnownKeysOfTupleType(t) : getIndexType(t) */ TODO
		}
		if type_.flags & TypeFlagsConditional {
			if (type_).root.isDistributive {
				checkType := (type_).checkType
				constraint := getLowerBoundOfKeyType(checkType)
				if constraint != checkType {
					return getConditionalTypeInstantiation(type_, prependTypeMapping((type_).root.checkType, constraint, (type_).mapper), false)
				}
			}
			return type_
		}
		if type_.flags & TypeFlagsUnion {
			return mapType(type_, getLowerBoundOfKeyType, true)
		}
		if type_.flags & TypeFlagsIntersection {
			types := (type_).types
			if types.length == 2 && !!( /* TODO(ElementAccessExpression): types[0] */ TODO.flags & (TypeFlagsString | TypeFlagsNumber | TypeFlagsBigInt)) && /* TODO(ElementAccessExpression): types[1] */ TODO == emptyTypeLiteralType {
				return type_
			}
			return getIntersectionType(sameMap((type_).types, getLowerBoundOfKeyType))
		}
		return type_
	}
	getIsLateCheckFlag := func(s Symbol) CheckFlags {
		return getCheckFlags(s) & CheckFlagsLate
	}
	forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType := func(type_ Type, include TypeFlags, stringsOnly bool, cb func(keyType Type)) {
		for _, prop := range getPropertiesOfType(type_) {
			cb(getLiteralTypeFromProperty(prop, include))
		}
		if type_.flags & TypeFlagsAny {
			cb(stringType)
		} else {
			for _, info := range getIndexInfosOfType(type_) {
				if !stringsOnly || info.keyType.flags&(TypeFlagsString|TypeFlagsTemplateLiteral) {
					cb(info.keyType)
				}
			}
		}
	}
	resolveMappedTypeMembers := func(type_ MappedType) {
		var members SymbolTable = createSymbolTable()
		var indexInfos /* TODO(ArrayType): IndexInfo[] */ any
		setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
		typeParameter := getTypeParameterFromMappedType(type_)
		constraintType := getConstraintTypeFromMappedType(type_)
		mappedType := (type_.target) || type_
		nameType := getNameTypeFromMappedType(mappedType)
		shouldLinkPropDeclarations := getMappedTypeNameTypeKind(mappedType) != MappedTypeNameTypeKindRemapping
		templateType := getTemplateTypeFromMappedType(mappedType)
		modifiersType := getApparentType(getModifiersTypeFromMappedType(type_))
		templateModifiers := getMappedTypeModifiers(type_)
		include := TypeFlagsStringOrNumberLiteralOrUnique
		if isMappedTypeWithKeyofConstraintDeclaration(type_) {
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, include, false, addMemberForKeyType)
		} else {
			forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType)
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos || emptyArray)
		addMemberForKeyType := func(keyType Type) {
			propNameType := /* TODO(ConditionalExpression): nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType */ TODO
			forEachType(propNameType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
				return addMemberForKeyTypeWorker(keyType, t)
			})
		}
		addMemberForKeyTypeWorker := func(keyType Type, propNameType Type) {
			if isTypeUsableAsPropertyName(propNameType) {
				propName := getPropertyNameFromType(propNameType)
				existingProp := members.get(propName)
				if existingProp {
					existingProp.links.nameType = getUnionType( /* TODO(ArrayLiteralExpression): [existingProp.links.nameType!, propNameType] */ TODO)
					existingProp.links.keyType = getUnionType( /* TODO(ArrayLiteralExpression): [existingProp.links.keyType, keyType] */ TODO)
				} else {
					modifiersProp := /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(keyType) ? getPropertyOfType(modifiersType, getPropertyNameFromType(keyType)) : undefined */ TODO
					isOptional := !!(templateModifiers&MappedTypeModifiersIncludeOptional || !(templateModifiers&MappedTypeModifiersExcludeOptional) && modifiersProp && modifiersProp.flags&SymbolFlagsOptional)
					isReadonly := !!(templateModifiers&MappedTypeModifiersIncludeReadonly || !(templateModifiers&MappedTypeModifiersExcludeReadonly) && modifiersProp && isReadonlySymbol(modifiersProp))
					stripOptional := strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags&SymbolFlagsOptional
					var lateFlag CheckFlags = /* TODO(ConditionalExpression): modifiersProp ? getIsLateCheckFlag(modifiersProp) : 0 */ TODO
					prop := createSymbol(SymbolFlagsProperty|( /* TODO(ConditionalExpression): isOptional ? SymbolFlags.Optional : 0 */ TODO), propName, lateFlag|CheckFlagsMapped|( /* TODO(ConditionalExpression): isReadonly ? CheckFlags.Readonly : 0 */ TODO)|( /* TODO(ConditionalExpression): stripOptional ? CheckFlags.StripOptional : 0 */ TODO))
					prop.links.mappedType = type_
					prop.links.nameType = propNameType
					prop.links.keyType = keyType
					if modifiersProp {
						prop.links.syntheticOrigin = modifiersProp
						prop.declarations = /* TODO(ConditionalExpression): shouldLinkPropDeclarations ? modifiersProp.declarations : undefined */ TODO
					}
					members.set(propName, prop)
				}
			} else if isValidIndexKeyType(propNameType) || propNameType.flags&(TypeFlagsAny|TypeFlagsEnum) {
				indexKeyType := /* TODO(ConditionalExpression): propNameType.flags & (TypeFlags.Any | TypeFlags.String) ? stringType :                     propNameType.flags & (TypeFlags.Number | TypeFlags.Enum) ? numberType :                     propNameType */ TODO
				propType := instantiateType(templateType, appendTypeMapping(type_.mapper, typeParameter, keyType))
				modifiersIndexInfo := getApplicableIndexInfo(modifiersType, propNameType)
				isReadonly := !!(templateModifiers&MappedTypeModifiersIncludeReadonly || !(templateModifiers&MappedTypeModifiersExcludeReadonly) && modifiersIndexInfo.isReadonly)
				indexInfo := createIndexInfo(indexKeyType, propType, isReadonly)
				indexInfos = appendIndexInfo(indexInfos, indexInfo, true)
			}
		}
	}
	getTypeOfMappedSymbol := func(symbol MappedSymbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !symbol.links.type_ {
			mappedType := symbol.links.mappedType
			if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
				mappedType.containsError = true
				return errorType
			}
			templateType := getTemplateTypeFromMappedType(mappedType.target || mappedType)
			mapper := appendTypeMapping(mappedType.mapper, getTypeParameterFromMappedType(mappedType), symbol.links.keyType)
			propType := instantiateType(templateType, mapper)
			type_ := /* TODO(ConditionalExpression): strictNullChecks && symbol.flags & SymbolFlags.Optional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void) ? getOptionalType(propType, /*isProperty* / true) :                 symbol.links.checkFlags & CheckFlags.StripOptional ? removeMissingOrUndefinedType(propType) :                 propType */ TODO
			if !popTypeResolution() {
				error(currentNode, Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1, symbolToString(symbol), typeToString(mappedType))
				type_ = errorType
			}
			/* TODO(ExpressionStatement): symbol.links.type ??= type; */
		}
		return symbol.links.type_
	}
	getTypeParameterFromMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
		return type_.typeParameter || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(type.declaration.typeParameter)) */ TODO)
	}
	getConstraintTypeFromMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return type_.constraintType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType */ TODO)
	}
	getNameTypeFromMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): type.declaration.nameType ?             type.nameType || (type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper)) :             undefined */ TODO
	}
	getTemplateTypeFromMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return type_.templateType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.templateType = type.declaration.type ?                 instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), /*isProperty* / true, !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional)), type.mapper) :                 errorType */ TODO)
	}
	getConstraintDeclarationForMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		return getEffectiveConstraintOfTypeParameter(type_.declaration.typeParameter)
	}
	isMappedTypeWithKeyofConstraintDeclaration := func(type_ MappedType) /* TODO inferred type boolean */ TODO {
		constraintDeclaration := getConstraintDeclarationForMappedType(type_)
		return constraintDeclaration.kind == SyntaxKindTypeOperator && (constraintDeclaration).operator == SyntaxKindKeyOfKeyword
	}
	getModifiersTypeFromMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !type_.modifiersType {
			if isMappedTypeWithKeyofConstraintDeclaration(type_) {
				type_.modifiersType = instantiateType(getTypeFromTypeNode((getConstraintDeclarationForMappedType(type_)).type_), type_.mapper)
			} else {
				declaredType := getTypeFromMappedTypeNode(type_.declaration)
				constraint := getConstraintTypeFromMappedType(declaredType)
				extendedConstraint := /* TODO(ConditionalExpression): constraint && constraint.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(constraint as TypeParameter) : constraint */ TODO
				type_.modifiersType = /* TODO(ConditionalExpression): extendedConstraint && extendedConstraint.flags & TypeFlags.Index ? instantiateType((extendedConstraint as IndexType).type, type.mapper) : unknownType */ TODO
			}
		}
		return type_.modifiersType
	}
	getMappedTypeModifiers := func(type_ MappedType) MappedTypeModifiers {
		declaration := type_.declaration
		return ( /* TODO(ConditionalExpression): declaration.readonlyToken ? declaration.readonlyToken.kind === SyntaxKind.MinusToken ? MappedTypeModifiers.ExcludeReadonly : MappedTypeModifiers.IncludeReadonly : 0 */ TODO) | ( /* TODO(ConditionalExpression): declaration.questionToken ? declaration.questionToken.kind === SyntaxKind.MinusToken ? MappedTypeModifiers.ExcludeOptional : MappedTypeModifiers.IncludeOptional : 0 */ TODO)
	}
	getMappedTypeOptionality := func(type_ MappedType) number {
		modifiers := getMappedTypeModifiers(type_)
		return /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.ExcludeOptional ? -1 : modifiers & MappedTypeModifiers.IncludeOptional ? 1 : 0 */ TODO
	}
	getCombinedMappedTypeOptionality := func(type_ Type) number {
		if getObjectFlags(type_) & ObjectFlagsMapped {
			return getMappedTypeOptionality(type_) || getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(type_))
		}
		if type_.flags & TypeFlagsIntersection {
			optionality := getCombinedMappedTypeOptionality( /* TODO(ElementAccessExpression): (type as IntersectionType).types[0] */ TODO)
			return /* TODO(ConditionalExpression): every((type as IntersectionType).types, (t, i) => i === 0 || getCombinedMappedTypeOptionality(t) === optionality) ? optionality : 0 */ TODO
		}
		return 0
	}
	isPartialMappedType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(getObjectFlags(type_)&ObjectFlagsMapped && getMappedTypeModifiers(type_)&MappedTypeModifiersIncludeOptional)
	}
	isGenericMappedType := func(type_ Type) /* TODO(TypePredicate): type is MappedType */ any {
		if getObjectFlags(type_) & ObjectFlagsMapped {
			constraint := getConstraintTypeFromMappedType(type_)
			if isGenericIndexType(constraint) {
				return true
			}
			nameType := getNameTypeFromMappedType(type_)
			if nameType && isGenericIndexType(instantiateType(nameType, makeUnaryTypeMapper(getTypeParameterFromMappedType(type_), constraint))) {
				return true
			}
		}
		return false
	}
	getMappedTypeNameTypeKind := func(type_ MappedType) MappedTypeNameTypeKind {
		nameType := getNameTypeFromMappedType(type_)
		if !nameType {
			return MappedTypeNameTypeKindNone
		}
		return /* TODO(ConditionalExpression): isTypeAssignableTo(nameType, getTypeParameterFromMappedType(type)) ? MappedTypeNameTypeKind.Filtering : MappedTypeNameTypeKind.Remapping */ TODO
	}
	resolveStructuredTypeMembers := func(type_ StructuredType) ResolvedType {
		if !(type_).members {
			if type_.flags & TypeFlagsObject {
				if (type_).objectFlags & ObjectFlagsReference {
					resolveTypeReferenceMembers(type_)
				} else if (type_).objectFlags & ObjectFlagsClassOrInterface {
					resolveClassOrInterfaceMembers(type_)
				} else if (type_).objectFlags & ObjectFlagsReverseMapped {
					resolveReverseMappedTypeMembers(type_)
				} else if (type_).objectFlags & ObjectFlagsAnonymous {
					resolveAnonymousTypeMembers(type_)
				} else if (type_).objectFlags & ObjectFlagsMapped {
					resolveMappedTypeMembers(type_)
				} else {
					Debug.fail( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "Unhandled object type " + Debug.formatObjectFlags(type.objectFlags) */ TODO)
				}
			} else if type_.flags & TypeFlagsUnion {
				resolveUnionTypeMembers(type_)
			} else if type_.flags & TypeFlagsIntersection {
				resolveIntersectionTypeMembers(type_)
			} else {
				Debug.fail( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "Unhandled type " + Debug.formatTypeFlags(type.flags) */ TODO)
			}
		}
		return type_
	}
	getPropertiesOfObjectType := func(type_ Type) []Symbol {
		if type_.flags & TypeFlagsObject {
			return resolveStructuredTypeMembers(type_).properties
		}
		return emptyArray
	}
	getPropertyOfObjectType := func(type_ Type, name __String) *Symbol {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_)
			symbol := resolved.members.get(name)
			if symbol && symbolIsValue(symbol) {
				return symbol
			}
		}
	}
	getPropertiesOfUnionOrIntersectionType := func(type_ UnionOrIntersectionType) []Symbol {
		if !type_.resolvedProperties {
			members := createSymbolTable()
			for _, current := range type_.types {
				for _, prop := range getPropertiesOfType(current) {
					if !members.has(prop.escapedName) {
						combinedProp := getPropertyOfUnionOrIntersectionType(type_, prop.escapedName, !!(type_.flags & TypeFlagsIntersection))
						if combinedProp {
							members.set(prop.escapedName, combinedProp)
						}
					}
				}
				if type_.flags&TypeFlagsUnion && getIndexInfosOfType(current).length == 0 {
					break
				}
			}
			type_.resolvedProperties = getNamedMembers(members)
		}
		return type_.resolvedProperties
	}
	getPropertiesOfType := func(type_ Type) []Symbol {
		type_ = getReducedApparentType(type_)
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.UnionOrIntersection ?             getPropertiesOfUnionOrIntersectionType(type as UnionType) :             getPropertiesOfObjectType(type) */ TODO
	}
	forEachPropertyOfType := func(type_ Type, action func(symbol Symbol, escapedName __String)) {
		type_ = getReducedApparentType(type_)
		if type_.flags & TypeFlagsStructuredType {
			resolveStructuredTypeMembers(type_).members.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, escapedName /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
				if isNamedMember(symbol, escapedName) {
					action(symbol, escapedName)
				}
			})
		}
	}
	isTypeInvalidDueToUnionDiscriminant := func(contextualType Type, obj /* TODO(UnionType): ObjectLiteralExpression | JsxAttributes */ any) bool {
		list := obj.properties
		return list.some(func(property /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectLiteralElementLike | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttributeLike */ TODO) /* TODO inferred type boolean */ TODO {
			nameType := property.name && ( /* TODO(ConditionalExpression): isJsxNamespacedName(property.name) ? getStringLiteralType(getTextOfJsxAttributeName(property.name)) : getLiteralTypeFromPropertyName(property.name) */ TODO)
			name := /* TODO(ConditionalExpression): nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined */ TODO
			expected := /* TODO(ConditionalExpression): name === undefined ? undefined : getTypeOfPropertyOfType(contextualType, name) */ TODO
			return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected)
		})
	}
	getAllPossiblePropertiesOfTypes := func(types []Type) []Symbol {
		unionType := getUnionType(types)
		if !(unionType.flags & TypeFlagsUnion) {
			return getAugmentedPropertiesOfType(unionType)
		}
		props := createSymbolTable()
		for _, memberType := range types {
			for _, TODO_IDENTIFIER := range getAugmentedPropertiesOfType(memberType) {
				if !props.has(escapedName) {
					prop := createUnionOrIntersectionProperty(unionType, escapedName)
					if prop {
						props.set(escapedName, prop)
					}
				}
			}
		}
		return arrayFrom(props.values())
	}
	getConstraintOfType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any) *Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(type as TypeParameter) :             type.flags & TypeFlags.IndexedAccess ? getConstraintOfIndexedAccess(type as IndexedAccessType) :             type.flags & TypeFlags.Conditional ? getConstraintOfConditionalType(type as ConditionalType) :             getBaseConstraintOfType(type) */ TODO
	}
	getConstraintOfTypeParameter := func(typeParameter TypeParameter) *Type {
		return /* TODO(ConditionalExpression): hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(typeParameter) : undefined */ TODO
	}
	isConstMappedType := func(type_ MappedType, depth number) bool {
		typeVariable := getHomomorphicTypeVariable(type_)
		return !!typeVariable && isConstTypeVariable(typeVariable, depth)
	}
	isConstTypeVariable := func(type_ *Type, depth /* TODO inferred type number */ TODO /*  = 0 */) bool {
		return depth < 5 && !!(type_ && (type_.flags&TypeFlagsTypeParameter && some((type_).symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
			return hasSyntacticModifier(d, ModifierFlagsConst)
		}) || type_.flags&TypeFlagsUnionOrIntersection && some((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return isConstTypeVariable(t, depth)
		}) || type_.flags&TypeFlagsIndexedAccess && isConstTypeVariable((type_).objectType /* TODO(PlusToken): + */ /* TODO(BinaryExpression): depth + 1 */, TODO) || type_.flags&TypeFlagsConditional && isConstTypeVariable(getConstraintOfConditionalType(type_) /* TODO(PlusToken): + */ /* TODO(BinaryExpression): depth + 1 */, TODO) || type_.flags&TypeFlagsSubstitution && isConstTypeVariable((type_).baseType, depth) || getObjectFlags(type_)&ObjectFlagsMapped && isConstMappedType(type_, depth) || isGenericTupleType(type_) && findIndex(getElementTypes(type_), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type boolean */ TODO {
			return !!( /* TODO(ElementAccessExpression): type.target.elementFlags[i] */ TODO & ElementFlagsVariadic) && isConstTypeVariable(t, depth)
		}) >= 0))
	}
	getConstraintOfIndexedAccess := func(type_ IndexedAccessType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): hasNonCircularBaseConstraint(type) ? getConstraintFromIndexedAccess(type) : undefined */ TODO
	}
	getSimplifiedTypeOrConstraint := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		simplified := getSimplifiedType(type_, false)
		return /* TODO(ConditionalExpression): simplified !== type ? simplified : getConstraintOfType(type) */ TODO
	}
	getConstraintFromIndexedAccess := func(type_ IndexedAccessType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if isMappedTypeGenericIndexedAccess(type_) {
			return substituteIndexedMappedType(type_.objectType, type_.indexType)
		}
		indexConstraint := getSimplifiedTypeOrConstraint(type_.indexType)
		if indexConstraint && indexConstraint != type_.indexType {
			indexedAccess := getIndexedAccessTypeOrUndefined(type_.objectType, indexConstraint, type_.accessFlags)
			if indexedAccess {
				return indexedAccess
			}
		}
		objectConstraint := getSimplifiedTypeOrConstraint(type_.objectType)
		if objectConstraint && objectConstraint != type_.objectType {
			return getIndexedAccessTypeOrUndefined(objectConstraint, type_.indexType, type_.accessFlags)
		}
		return nil
	}
	getDefaultConstraintOfConditionalType := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !type_.resolvedDefaultConstraint {
			trueConstraint := getInferredTrueTypeFromConditionalType(type_)
			falseConstraint := getFalseTypeFromConditionalType(type_)
			type_.resolvedDefaultConstraint = /* TODO(ConditionalExpression): isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(falseConstraint) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]) */ TODO
		}
		return type_.resolvedDefaultConstraint
	}
	getConstraintOfDistributiveConditionalType := func(type_ ConditionalType) *Type {
		if type_.resolvedConstraintOfDistributive != nil {
			return type_.resolvedConstraintOfDistributive || nil
		}
		if type_.root.isDistributive && type_.restrictiveInstantiation != type_ {
			simplified := getSimplifiedType(type_.checkType, false)
			constraint := /* TODO(ConditionalExpression): simplified === type.checkType ? getConstraintOfType(simplified) : simplified */ TODO
			if constraint && constraint != type_.checkType {
				instantiated := getConditionalTypeInstantiation(type_, prependTypeMapping(type_.root.checkType, constraint, type_.mapper), true)
				if !(instantiated.flags & TypeFlagsNever) {
					type_.resolvedConstraintOfDistributive = instantiated
					return instantiated
				}
			}
		}
		type_.resolvedConstraintOfDistributive = false
		return nil
	}
	getConstraintFromConditionalType := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getConstraintOfDistributiveConditionalType(type_) || getDefaultConstraintOfConditionalType(type_)
	}
	getConstraintOfConditionalType := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): hasNonCircularBaseConstraint(type) ? getConstraintFromConditionalType(type) : undefined */ TODO
	}
	getEffectiveConstraintOfIntersection := func(types []Type, targetIsUnion bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		var constraints /* TODO(ArrayType): Type[] */ any
		hasDisjointDomainType := false
		for _, t := range types {
			if t.flags & TypeFlagsInstantiable {
				constraint := getConstraintOfType(t)
				for constraint && constraint.flags&(TypeFlagsTypeParameter|TypeFlagsIndex|TypeFlagsConditional) {
					constraint = getConstraintOfType(constraint)
				}
				if constraint {
					constraints = append(constraints, constraint)
					if targetIsUnion {
						constraints = append(constraints, t)
					}
				}
			} else if t.flags&TypeFlagsDisjointDomains || isEmptyAnonymousObjectType(t) {
				hasDisjointDomainType = true
			}
		}
		if constraints && (targetIsUnion || hasDisjointDomainType) {
			if hasDisjointDomainType {
				for _, t := range types {
					if t.flags&TypeFlagsDisjointDomains || isEmptyAnonymousObjectType(t) {
						constraints = append(constraints, t)
					}
				}
			}
			return getNormalizedType(getIntersectionType(constraints, IntersectionFlagsNoConstraintReduction), false)
		}
		return nil
	}
	getBaseConstraintOfType := func(type_ Type) *Type {
		if type_.flags&(TypeFlagsInstantiableNonPrimitive|TypeFlagsUnionOrIntersection|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || isGenericTupleType(type_) {
			constraint := getResolvedBaseConstraint(type_)
			return /* TODO(ConditionalExpression): constraint !== noConstraintType && constraint !== circularConstraintType ? constraint : undefined */ TODO
		}
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Index ? stringNumberSymbolType : undefined */ TODO
	}
	getBaseConstraintOrType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getBaseConstraintOfType(type_) || type_
	}
	hasNonCircularBaseConstraint := func(type_ InstantiableType) bool {
		return getResolvedBaseConstraint(type_) != circularConstraintType
	}
	getResolvedBaseConstraint := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any) Type {
		if type_.resolvedBaseConstraint {
			return type_.resolvedBaseConstraint
		}
		var stack [] /* TODO(ObjectKeyword): object */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseConstraint = getImmediateBaseConstraint(type) */ TODO
		getImmediateBaseConstraint := func(t Type) Type {
			if !t.immediateBaseConstraint {
				if !pushTypeResolution(t, TypeSystemPropertyNameImmediateBaseConstraint) {
					return circularConstraintType
				}
				var result TODO
				identity := getRecursionIdentity(t)
				if stack.length < 10 || stack.length < 50 && !contains(stack, identity) {
					stack.push(identity)
					result = computeBaseConstraint(getSimplifiedType(t, false))
					stack.pop()
				}
				if !popTypeResolution() {
					if t.flags & TypeFlagsTypeParameter {
						errorNode := getConstraintDeclaration(t)
						if errorNode {
							diagnostic := error(errorNode, Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(t))
							if currentNode && !isNodeDescendantOf(errorNode, currentNode) && !isNodeDescendantOf(currentNode, errorNode) {
								addRelatedInfo(diagnostic, createDiagnosticForNode(currentNode, Diagnostics.Circularity_originates_in_type_at_this_location))
							}
						}
					}
					result = circularConstraintType
				}
				/* TODO(ExpressionStatement): t.immediateBaseConstraint ??= result || noConstraintType; */
			}
			return t.immediateBaseConstraint
		}
		getBaseConstraint := func(t Type) *Type {
			c := getImmediateBaseConstraint(t)
			return /* TODO(ConditionalExpression): c !== noConstraintType && c !== circularConstraintType ? c : undefined */ TODO
		}
		computeBaseConstraint := func(t Type) *Type {
			if t.flags & TypeFlagsTypeParameter {
				constraint := getConstraintFromTypeParameter(t)
				return /* TODO(ConditionalExpression): (t as TypeParameter).isThisType || !constraint ?                     constraint :                     getBaseConstraint(constraint) */ TODO
			}
			if t.flags & TypeFlagsUnionOrIntersection {
				types := (t).types
				var baseTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
				different := false
				for _, type_ := range types {
					baseType := getBaseConstraint(type_)
					if baseType {
						if baseType != type_ {
							different = true
						}
						baseTypes.push(baseType)
					} else {
						different = true
					}
				}
				if !different {
					return t
				}
				return /* TODO(ConditionalExpression): t.flags & TypeFlags.Union && baseTypes.length === types.length ? getUnionType(baseTypes) :                     t.flags & TypeFlags.Intersection && baseTypes.length ? getIntersectionType(baseTypes) :                     undefined */ TODO
			}
			if t.flags & TypeFlagsIndex {
				return stringNumberSymbolType
			}
			if t.flags & TypeFlagsTemplateLiteral {
				types := (t).types
				constraints := mapDefined(types, getBaseConstraint)
				return /* TODO(ConditionalExpression): constraints.length === types.length ? getTemplateLiteralType((t as TemplateLiteralType).texts, constraints) : stringType */ TODO
			}
			if t.flags & TypeFlagsStringMapping {
				constraint := getBaseConstraint((t).type_)
				return /* TODO(ConditionalExpression): constraint && constraint !== (t as StringMappingType).type ? getStringMappingType((t as StringMappingType).symbol, constraint) : stringType */ TODO
			}
			if t.flags & TypeFlagsIndexedAccess {
				if isMappedTypeGenericIndexedAccess(t) {
					return getBaseConstraint(substituteIndexedMappedType((t).objectType, (t).indexType))
				}
				baseObjectType := getBaseConstraint((t).objectType)
				baseIndexType := getBaseConstraint((t).indexType)
				baseIndexedAccess := baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, (t).accessFlags)
				return baseIndexedAccess && getBaseConstraint(baseIndexedAccess)
			}
			if t.flags & TypeFlagsConditional {
				constraint := getConstraintFromConditionalType(t)
				return constraint && getBaseConstraint(constraint)
			}
			if t.flags & TypeFlagsSubstitution {
				return getBaseConstraint(getSubstitutionIntersection(t))
			}
			if isGenericTupleType(t) {
				newElements := map_(getElementTypes(t), func(v /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					constraint := v.flags&TypeFlagsTypeParameter && /* TODO(ElementAccessExpression): t.target.elementFlags[i] */ TODO&ElementFlagsVariadic && getBaseConstraint(v) || v
					return /* TODO(ConditionalExpression): constraint !== v && everyType(constraint, c => isArrayOrTupleType(c) && !isGenericTupleType(c)) ? constraint : v */ TODO
				})
				return createTupleType(newElements, t.target.elementFlags, t.target.readonly, t.target.labeledElementDeclarations)
			}
			return t
		}
	}
	getApparentTypeOfIntersectionType := func(type_ IntersectionType, thisArgument Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if type_ == thisArgument {
			return type_.resolvedApparentType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedApparentType = getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true) */ TODO)
		}
		key := /* TODO(TemplateExpression): `I${getTypeId(type)},${getTypeId(thisArgument)}` */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true)) */ TODO
	}
	getResolvedTypeParameterDefault := func(typeParameter TypeParameter) *Type {
		if !typeParameter.default_ {
			if typeParameter.target {
				targetDefault := getResolvedTypeParameterDefault(typeParameter.target)
				typeParameter.default_ = /* TODO(ConditionalExpression): targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType */ TODO
			} else {
				typeParameter.default_ = resolvingDefaultType
				defaultDeclaration := typeParameter.symbol && forEach(typeParameter.symbol.declarations, func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type false | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
					return isTypeParameterDeclaration(decl) && decl.default_
				})
				defaultType := /* TODO(ConditionalExpression): defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType */ TODO
				if typeParameter.default_ == resolvingDefaultType {
					typeParameter.default_ = defaultType
				}
			}
		} else if typeParameter.default_ == resolvingDefaultType {
			typeParameter.default_ = circularConstraintType
		}
		return typeParameter.default_
	}
	getDefaultFromTypeParameter := func(typeParameter TypeParameter) *Type {
		defaultType := getResolvedTypeParameterDefault(typeParameter)
		return /* TODO(ConditionalExpression): defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : undefined */ TODO
	}
	hasNonCircularTypeParameterDefault := func(typeParameter TypeParameter) /* TODO inferred type boolean */ TODO {
		return getResolvedTypeParameterDefault(typeParameter) != circularConstraintType
	}
	hasTypeParameterDefault := func(typeParameter TypeParameter) bool {
		return !!(typeParameter.symbol && forEach(typeParameter.symbol.declarations, func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type false | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			return isTypeParameterDeclaration(decl) && decl.default_
		}))
	}
	getApparentTypeOfMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return type_.resolvedApparentType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type) */ TODO)
	}
	getResolvedApparentTypeOfMappedType := func(type_ MappedType) Type {
		target := ( /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): type.target ?? type */ TODO)
		typeVariable := getHomomorphicTypeVariable(target)
		if typeVariable && !target.declaration.nameType {
			modifiersType := getModifiersTypeFromMappedType(type_)
			baseConstraint := /* TODO(ConditionalExpression): isGenericMappedType(modifiersType) ? getApparentTypeOfMappedType(modifiersType) : getBaseConstraintOfType(modifiersType) */ TODO
			if baseConstraint && everyType(baseConstraint, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return isArrayOrTupleType(t) || isArrayOrTupleOrIntersection(t)
			}) {
				return instantiateType(target, prependTypeMapping(typeVariable, baseConstraint, type_.mapper))
			}
		}
		return type_
	}
	isArrayOrTupleOrIntersection := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(type_.flags & TypeFlagsIntersection) && every((type_).types, isArrayOrTupleType)
	}
	isMappedTypeGenericIndexedAccess := func(type_ Type) /* TODO inferred type boolean */ TODO {
		var objectType TODO
		return !!(type_.flags&TypeFlagsIndexedAccess && getObjectFlags( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): objectType = (type as IndexedAccessType).objectType */ TODO)&ObjectFlagsMapped && !isGenericMappedType(objectType) && isGenericIndexType((type_).indexType) && !(getMappedTypeModifiers(objectType) & MappedTypeModifiersExcludeOptional) && !(objectType).declaration.nameType)
	}
	getApparentType := func(type_ Type) Type {
		t := /* TODO(ConditionalExpression): type.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(type) || unknownType : type */ TODO
		objectFlags := getObjectFlags(t)
		return /* TODO(ConditionalExpression): objectFlags & ObjectFlags.Mapped ? getApparentTypeOfMappedType(t as MappedType) :             objectFlags & ObjectFlags.Reference && t !== type ? getTypeWithThisArgument(t, type) :             t.flags & TypeFlags.Intersection ? getApparentTypeOfIntersectionType(t as IntersectionType, type) :             t.flags & TypeFlags.StringLike ? globalStringType :             t.flags & TypeFlags.NumberLike ? globalNumberType :             t.flags & TypeFlags.BigIntLike ? getGlobalBigIntType() :             t.flags & TypeFlags.BooleanLike ? globalBooleanType :             t.flags & TypeFlags.ESSymbolLike ? getGlobalESSymbolType() :             t.flags & TypeFlags.NonPrimitive ? emptyObjectType :             t.flags & TypeFlags.Index ? stringNumberSymbolType :             t.flags & TypeFlags.Unknown && !strictNullChecks ? emptyObjectType :             t */ TODO
	}
	getReducedApparentType := func(type_ Type) Type {
		return getReducedType(getApparentType(getReducedType(type_)))
	}
	createUnionOrIntersectionProperty := func(containingType UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
		var singleProp *Symbol
		var propSet *Map[SymbolId, Symbol]
		var indexTypes /* TODO(ArrayType): Type[] */ any
		isUnion := containingType.flags & TypeFlagsUnion
		var optionalFlag *SymbolFlags
		syntheticFlag := CheckFlagsSyntheticMethod
		checkFlags := /* TODO(ConditionalExpression): isUnion ? 0 : CheckFlags.Readonly */ TODO
		mergedInstantiations := false
		for _, current := range containingType.types {
			type_ := getApparentType(current)
			if !(isErrorType(type_) || type_.flags&TypeFlagsNever) {
				prop := getPropertyOfType(type_, name, skipObjectFunctionPropertyAugment)
				modifiers := /* TODO(ConditionalExpression): prop ? getDeclarationModifierFlagsFromSymbol(prop) : 0 */ TODO
				if prop {
					if prop.flags & SymbolFlagsClassMember {
						/* TODO(ExpressionStatement): optionalFlag ??= isUnion ? SymbolFlags.None : SymbolFlags.Optional; */
						if isUnion {
							optionalFlag |= prop.flags & SymbolFlagsOptional
						} else {
							optionalFlag &= prop.flags
						}
					}
					if !singleProp {
						singleProp = prop
					} else if prop != singleProp {
						isInstantiation := (getTargetSymbol(prop) || prop) == (getTargetSymbol(singleProp) || singleProp)
						if isInstantiation && compareProperties(singleProp, prop, func(a /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, b /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary.False | import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary.True */ TODO {
							return /* TODO(ConditionalExpression): a === b ? Ternary.True : Ternary.False */ TODO
						}) == TernaryTrue {
							mergedInstantiations = !!singleProp.parent && !!length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent))
						} else {
							if !propSet {
								propSet = make(map[SymbolId]Symbol)
								propSet.set(getSymbolId(singleProp), singleProp)
							}
							id := getSymbolId(prop)
							if !propSet.has(id) {
								propSet.set(id, prop)
							}
						}
					}
					if isUnion && isReadonlySymbol(prop) {
						checkFlags |= CheckFlagsReadonly
					} else if !isUnion && !isReadonlySymbol(prop) {
						checkFlags &= ~CheckFlagsReadonly
					}
					checkFlags |= ( /* TODO(ConditionalExpression): !(modifiers & ModifierFlags.NonPublicAccessibilityModifier) ? CheckFlags.ContainsPublic : 0 */ TODO) | ( /* TODO(ConditionalExpression): modifiers & ModifierFlags.Protected ? CheckFlags.ContainsProtected : 0 */ TODO) | ( /* TODO(ConditionalExpression): modifiers & ModifierFlags.Private ? CheckFlags.ContainsPrivate : 0 */ TODO) | ( /* TODO(ConditionalExpression): modifiers & ModifierFlags.Static ? CheckFlags.ContainsStatic : 0 */ TODO)
					if !isPrototypeProperty(prop) {
						syntheticFlag = CheckFlagsSyntheticProperty
					}
				} else if isUnion {
					indexInfo := !isLateBoundName(name) && getApplicableIndexInfoForName(type_, name)
					if indexInfo {
						checkFlags |= CheckFlagsWritePartial | ( /* TODO(ConditionalExpression): indexInfo.isReadonly ? CheckFlags.Readonly : 0 */ TODO)
						indexTypes = append(indexTypes /* TODO(ConditionalExpression): isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type */, TODO)
					} else if isObjectLiteralType(type_) && !(getObjectFlags(type_) & ObjectFlagsContainsSpread) {
						checkFlags |= CheckFlagsWritePartial
						indexTypes = append(indexTypes, undefinedType)
					} else {
						checkFlags |= CheckFlagsReadPartial
					}
				}
			}
		}
		if !singleProp || isUnion && (propSet || checkFlags&CheckFlagsPartial) && checkFlags&(CheckFlagsContainsPrivate|CheckFlagsContainsProtected) && !(propSet && getCommonDeclarationsOfSymbols(propSet.values())) {
			return nil
		}
		if !propSet && !(checkFlags & CheckFlagsReadPartial) && !indexTypes {
			if mergedInstantiations {
				links := tryCast(singleProp, isTransientSymbol).links
				clone := createSymbolWithType(singleProp, links.type_)
				clone.parent = singleProp.valueDeclaration.symbol.parent
				clone.links.containingType = containingType
				clone.links.mapper = links.mapper
				clone.links.writeType = getWriteTypeOfSymbol(singleProp)
				return clone
			} else {
				return singleProp
			}
		}
		props := /* TODO(ConditionalExpression): propSet ? arrayFrom(propSet.values()) : [singleProp] */ TODO
		var declarations /* TODO(ArrayType): Declaration[] */ any
		var firstType *Type
		var nameType *Type
		var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var writeTypes /* TODO(ArrayType): Type[] */ any
		var firstValueDeclaration Declaration
		hasNonUniformValueDeclaration := false
		for _, prop := range props {
			if !firstValueDeclaration {
				firstValueDeclaration = prop.valueDeclaration
			} else if prop.valueDeclaration && prop.valueDeclaration != firstValueDeclaration {
				hasNonUniformValueDeclaration = true
			}
			declarations = addRange(declarations, prop.declarations)
			type_ := getTypeOfSymbol(prop)
			if !firstType {
				firstType = type_
				nameType = getSymbolLinks(prop).nameType
			}
			writeType := getWriteTypeOfSymbol(prop)
			if writeTypes || writeType != type_ {
				writeTypes = append( /* TODO(ConditionalExpression): !writeTypes ? propTypes.slice() : writeTypes */ TODO, writeType)
			}
			if type_ != firstType {
				checkFlags |= CheckFlagsHasNonUniformType
			}
			if isLiteralType(type_) || isPatternLiteralType(type_) {
				checkFlags |= CheckFlagsHasLiteralType
			}
			if type_.flags&TypeFlagsNever && type_ != uniqueLiteralType {
				checkFlags |= CheckFlagsHasNeverType
			}
			propTypes.push(type_)
		}
		addRange(propTypes, indexTypes)
		result := createSymbol(SymbolFlagsProperty|( /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): optionalFlag ?? 0 */ TODO), name, syntheticFlag|checkFlags)
		result.links.containingType = containingType
		if !hasNonUniformValueDeclaration && firstValueDeclaration {
			result.valueDeclaration = firstValueDeclaration
			if firstValueDeclaration.symbol.parent {
				result.parent = firstValueDeclaration.symbol.parent
			}
		}
		result.declarations = declarations
		result.links.nameType = nameType
		if propTypes.length > 2 {
			result.links.checkFlags |= CheckFlagsDeferredType
			result.links.deferralParent = containingType
			result.links.deferralConstituents = propTypes
			result.links.deferralWriteConstituents = writeTypes
		} else {
			result.links.type_ = /* TODO(ConditionalExpression): isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes) */ TODO
			if writeTypes {
				result.links.writeType = /* TODO(ConditionalExpression): isUnion ? getUnionType(writeTypes) : getIntersectionType(writeTypes) */ TODO
			}
		}
		return result
	}
	getUnionOrIntersectionProperty := func(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
		property := /* TODO(ConditionalExpression): skipObjectFunctionPropertyAugment ?             type.propertyCacheWithoutObjectFunctionPropertyAugment?.get(name) :             type.propertyCache?.get(name) */ TODO
		if !property {
			property = createUnionOrIntersectionProperty(type_, name, skipObjectFunctionPropertyAugment)
			if property {
				properties := /* TODO(ConditionalExpression): skipObjectFunctionPropertyAugment ?                     type.propertyCacheWithoutObjectFunctionPropertyAugment ||= createSymbolTable() :                     type.propertyCache ||= createSymbolTable() */ TODO
				properties.set(name, property)
				if skipObjectFunctionPropertyAugment && !(getCheckFlags(property) & CheckFlagsPartial) && !type_.propertyCache.get(name) {
					properties := /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): type.propertyCache ||= createSymbolTable() */ TODO
					properties.set(name, property)
				}
			}
		}
		return property
	}
	getCommonDeclarationsOfSymbols := func(symbols Iterable[Symbol]) /* TODO inferred type Set<import("/home/jabaile/work/TypeScript/src/compiler/types").Node> | undefined */ TODO {
		var commonDeclarations *Set[Node]
		for _, symbol := range symbols {
			if !symbol.declarations {
				return nil
			}
			if !commonDeclarations {
				commonDeclarations = /* TODO(NewExpression): new Set(symbol.declarations) */ TODO
				continue
			}
			commonDeclarations.forEach(func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) {
				if !contains(symbol.declarations, declaration) {
					commonDeclarations.delete(declaration)
				}
			})
			if commonDeclarations.size == 0 {
				return nil
			}
		}
		return commonDeclarations
	}
	getPropertyOfUnionOrIntersectionType := func(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
		property := getUnionOrIntersectionProperty(type_, name, skipObjectFunctionPropertyAugment)
		return /* TODO(ConditionalExpression): property && !(getCheckFlags(property) & CheckFlags.ReadPartial) ? property : undefined */ TODO
	}
	getReducedType := func(type_ Type) Type {
		if type_.flags&TypeFlagsUnion && (type_).objectFlags&ObjectFlagsContainsIntersections {
			return (type_).resolvedReducedType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): (type as UnionType).resolvedReducedType = getReducedUnionType(type as UnionType) */ TODO)
		} else if type_.flags & TypeFlagsIntersection {
			if !((type_).objectFlags & ObjectFlagsIsNeverIntersectionComputed) {
				(type_).objectFlags |= ObjectFlagsIsNeverIntersectionComputed | ( /* TODO(ConditionalExpression): some(getPropertiesOfUnionOrIntersectionType(type as IntersectionType), isNeverReducedProperty) ? ObjectFlags.IsNeverIntersection : 0 */ TODO)
			}
			return /* TODO(ConditionalExpression): (type as IntersectionType).objectFlags & ObjectFlags.IsNeverIntersection ? neverType : type */ TODO
		}
		return type_
	}
	getReducedUnionType := func(unionType UnionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		reducedTypes := sameMap(unionType.types, getReducedType)
		if reducedTypes == unionType.types {
			return unionType
		}
		reduced := getUnionType(reducedTypes)
		if reduced.flags & TypeFlagsUnion {
			(reduced).resolvedReducedType = reduced
		}
		return reduced
	}
	isNeverReducedProperty := func(prop Symbol) /* TODO inferred type boolean */ TODO {
		return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop)
	}
	isDiscriminantWithNeverType := func(prop Symbol) /* TODO inferred type boolean */ TODO {
		return !(prop.flags & SymbolFlagsOptional) && (getCheckFlags(prop)&(CheckFlagsDiscriminant|CheckFlagsHasNeverType)) == CheckFlagsDiscriminant && !!(getTypeOfSymbol(prop).flags & TypeFlagsNever)
	}
	isConflictingPrivateProperty := func(prop Symbol) /* TODO inferred type boolean */ TODO {
		return !prop.valueDeclaration && !!(getCheckFlags(prop) & CheckFlagsContainsPrivate)
	}
	isGenericReducibleType := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsUnion && (type_).objectFlags&ObjectFlagsContainsIntersections && some((type_).types, isGenericReducibleType) || type_.flags&TypeFlagsIntersection && isReducibleIntersection(type_))
	}
	isReducibleIntersection := func(type_ IntersectionType) /* TODO inferred type boolean */ TODO {
		uniqueFilled := type_.uniqueLiteralFilledInstantiation || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.uniqueLiteralFilledInstantiation = instantiateType(type, uniqueLiteralMapper) */ TODO)
		return getReducedType(uniqueFilled) != uniqueFilled
	}
	elaborateNeverIntersection := func(errorInfo *DiagnosticMessageChain, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined */ TODO {
		if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsNeverIntersection {
			neverProp := find(getPropertiesOfUnionOrIntersectionType(type_), isDiscriminantWithNeverType)
			if neverProp {
				return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents, typeToString(type_, nil, TypeFormatFlagsNoTypeReduction), symbolToString(neverProp))
			}
			privateProp := find(getPropertiesOfUnionOrIntersectionType(type_), isConflictingPrivateProperty)
			if privateProp {
				return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some, typeToString(type_, nil, TypeFormatFlagsNoTypeReduction), symbolToString(privateProp))
			}
		}
		return errorInfo
	}
	getPropertyOfType := func(type_ Type, name __String, skipObjectFunctionPropertyAugment bool, includeTypeOnlyMembers bool) *Symbol {
		type_ = getReducedApparentType(type_)
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_)
			symbol := resolved.members.get(name)
			if symbol && !includeTypeOnlyMembers && type_.symbol.flags&SymbolFlagsValueModule && getSymbolLinks(type_.symbol).typeOnlyExportStarMap.has(name) {
				return nil
			}
			if symbol && symbolIsValue(symbol, includeTypeOnlyMembers) {
				return symbol
			}
			if skipObjectFunctionPropertyAugment {
				return nil
			}
			functionType := /* TODO(ConditionalExpression): resolved === anyFunctionType ? globalFunctionType :                 resolved.callSignatures.length ? globalCallableFunctionType :                 resolved.constructSignatures.length ? globalNewableFunctionType :                 undefined */ TODO
			if functionType {
				symbol := getPropertyOfObjectType(functionType, name)
				if symbol {
					return symbol
				}
			}
			return getPropertyOfObjectType(globalObjectType, name)
		}
		if type_.flags & TypeFlagsIntersection {
			prop := getPropertyOfUnionOrIntersectionType(type_, name, true)
			if prop {
				return prop
			}
			if !skipObjectFunctionPropertyAugment {
				return getPropertyOfUnionOrIntersectionType(type_, name, skipObjectFunctionPropertyAugment)
			}
			return nil
		}
		if type_.flags & TypeFlagsUnion {
			return getPropertyOfUnionOrIntersectionType(type_, name, skipObjectFunctionPropertyAugment)
		}
		return nil
	}
	getSignaturesOfStructuredType := func(type_ Type, kind SignatureKind) []Signature {
		if type_.flags & TypeFlagsStructuredType {
			resolved := resolveStructuredTypeMembers(type_)
			return /* TODO(ConditionalExpression): kind === SignatureKind.Call ? resolved.callSignatures : resolved.constructSignatures */ TODO
		}
		return emptyArray
	}
	getSignaturesOfType := func(type_ Type, kind SignatureKind) []Signature {
		result := getSignaturesOfStructuredType(getReducedApparentType(type_), kind)
		if kind == SignatureKindCall && !length(result) && type_.flags&TypeFlagsUnion {
			if (type_).arrayFallbackSignatures {
				return (type_).arrayFallbackSignatures
			}
			var memberName __String
			if everyType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return !!t.symbol.parent && isArrayOrTupleSymbol(t.symbol.parent) && ( /* TODO(ConditionalExpression): !memberName ? (memberName = t.symbol.escapedName, true) : memberName === t.symbol.escapedName */ TODO)
			}) {
				arrayArg := mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					return getMappedType( /* TODO(ElementAccessExpression): (isReadonlyArraySymbol(t.symbol.parent) ? globalReadonlyArrayType : globalArrayType).typeParameters![0] */ TODO, (t).mapper)
				})
				arrayType := createArrayType(arrayArg, someType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return isReadonlyArraySymbol(t.symbol.parent)
				}))
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): (type as UnionType).arrayFallbackSignatures = getSignaturesOfType(getTypeOfPropertyOfType(arrayType, memberName!)!, kind) */ TODO
			}
			(type_).arrayFallbackSignatures = result
		}
		return result
	}
	isArrayOrTupleSymbol := func(symbol *Symbol) /* TODO inferred type boolean */ TODO {
		if !symbol || !globalArrayType.symbol || !globalReadonlyArrayType.symbol {
			return false
		}
		return !!getSymbolIfSameReference(symbol, globalArrayType.symbol) || !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol)
	}
	isReadonlyArraySymbol := func(symbol *Symbol) /* TODO inferred type boolean */ TODO {
		if !symbol || !globalReadonlyArrayType.symbol {
			return false
		}
		return !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol)
	}
	findIndexInfo := func(indexInfos []IndexInfo, keyType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo | undefined */ TODO {
		return find(indexInfos, func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO inferred type boolean */ TODO {
			return info.keyType == keyType
		})
	}
	findApplicableIndexInfo := func(indexInfos []IndexInfo, keyType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo | undefined */ TODO {
		var stringIndexInfo *IndexInfo
		var applicableInfo *IndexInfo
		var applicableInfos /* TODO(ArrayType): IndexInfo[] */ any
		for _, info := range indexInfos {
			if info.keyType == stringType {
				stringIndexInfo = info
			} else if isApplicableIndexType(keyType, info.keyType) {
				if !applicableInfo {
					applicableInfo = info
				} else {
					(applicableInfos || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): applicableInfos = [applicableInfo] */ TODO)).push(info)
				}
			}
		}
		return /* TODO(ConditionalExpression): applicableInfos ? createIndexInfo(unknownType, getIntersectionType(map(applicableInfos, info => info.type)), reduceLeft(applicableInfos, (isReadonly, info) => isReadonly && info.isReadonly, /*initial* / true)) :             applicableInfo ? applicableInfo :             stringIndexInfo && isApplicableIndexType(keyType, stringType) ? stringIndexInfo :             undefined */ TODO
	}
	isApplicableIndexType := func(source Type, target Type) bool {
		return isTypeAssignableTo(source, target) || target == stringType && isTypeAssignableTo(source, numberType) || target == numberType && (source == numericStringType || !!(source.flags&TypeFlagsStringLiteral) && isNumericLiteralName((source).value))
	}
	getIndexInfosOfStructuredType := func(type_ Type) []IndexInfo {
		if type_.flags & TypeFlagsStructuredType {
			resolved := resolveStructuredTypeMembers(type_)
			return resolved.indexInfos
		}
		return emptyArray
	}
	getIndexInfosOfType := func(type_ Type) []IndexInfo {
		return getIndexInfosOfStructuredType(getReducedApparentType(type_))
	}
	getIndexInfoOfType := func(type_ Type, keyType Type) *IndexInfo {
		return findIndexInfo(getIndexInfosOfType(type_), keyType)
	}
	getIndexTypeOfType := func(type_ Type, keyType Type) *Type {
		return getIndexInfoOfType(type_, keyType).type_
	}
	getApplicableIndexInfos := func(type_ Type, keyType Type) []IndexInfo {
		return getIndexInfosOfType(type_).filter(func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO inferred type boolean */ TODO {
			return isApplicableIndexType(keyType, info.keyType)
		})
	}
	getApplicableIndexInfo := func(type_ Type, keyType Type) *IndexInfo {
		return findApplicableIndexInfo(getIndexInfosOfType(type_), keyType)
	}
	getApplicableIndexInfoForName := func(type_ Type, name __String) *IndexInfo {
		return getApplicableIndexInfo(type_ /* TODO(ConditionalExpression): isLateBoundName(name) ? esSymbolType : getStringLiteralType(unescapeLeadingUnderscores(name)) */, TODO)
	}
	getTypeParametersFromDeclaration := func(declaration DeclarationWithTypeParameters) /* TODO(TypeOperator): readonly TypeParameter[] */ any {
		var result /* TODO(ArrayType): TypeParameter[] */ any
		for _, node := range getEffectiveTypeParameterDeclarations(declaration) {
			result = appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol))
		}
		return /* TODO(ConditionalExpression): result?.length ? result             : isFunctionDeclaration(declaration) ? getSignatureOfTypeTag(declaration)?.typeParameters             : undefined */ TODO
	}
	symbolsToArray := func(symbols SymbolTable) []Symbol {
		var result []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		symbols.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
			if !isReservedMemberName(id) {
				result.push(symbol)
			}
		})
		return result
	}
	tryFindAmbientModule := func(moduleName string, withAugmentations bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if isExternalModuleNameRelative(moduleName) {
			return nil
		}
		symbol := getSymbol(globals /* TODO(PlusToken): + */ /* TODO(BinaryExpression): '"' + moduleName + '"' */, TODO, SymbolFlagsValueModule)
		return /* TODO(ConditionalExpression): symbol && withAugmentations ? getMergedSymbol(symbol) : symbol */ TODO
	}
	hasEffectiveQuestionToken := func(node /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) /* TODO inferred type boolean */ TODO {
		return hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isParameter(node) && isJSDocOptionalParameter(node)
	}
	isOptionalParameter := func(node /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) /* TODO inferred type boolean */ TODO {
		if hasEffectiveQuestionToken(node) {
			return true
		}
		if !isParameter(node) {
			return false
		}
		if node.initializer {
			signature := getSignatureFromDeclaration(node.parent)
			parameterIndex := node.parent.parameters.indexOf(node)
			Debug.assert(parameterIndex >= 0)
			return parameterIndex >= getMinArgumentCount(signature, MinArgumentCountFlagsStrongArityForUntypedJS|MinArgumentCountFlagsVoidIsNonOptional)
		}
		iife := getImmediatelyInvokedFunctionExpression(node.parent)
		if iife {
			return !node.type_ && !node.dotDotDotToken && node.parent.parameters.indexOf(node) >= getEffectiveCallArguments(iife).length
		}
		return false
	}
	isOptionalPropertyDeclaration := func(node Declaration) /* TODO inferred type false | import("/home/jabaile/work/TypeScript/src/compiler/types").QuestionToken | undefined */ TODO {
		return isPropertyDeclaration(node) && !hasAccessorModifier(node) && node.questionToken
	}
	createTypePredicate := func(kind TypePredicateKind, parameterName /* TODO(StringKeyword): string */ any, parameterIndex /* TODO(NumberKeyword): number */ any, type_ *Type) TypePredicate {
		return /* TODO(ObjectLiteralExpression): { kind, parameterName, parameterIndex, type } */ TODO
	}
	getMinTypeArgumentCount := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any) number {
		minTypeArgumentCount := 0
		if typeParameters {
			/* TODO(ForStatement): for (let i = 0; i < typeParameters.length; i++) {                 if (!hasTypeParameterDefault(typeParameters[i])) {                     minTypeArgumentCount = i + 1;                 }             } */
		}
		return minTypeArgumentCount
	}
	// OVERLOAD: fillMissingTypeArguments := func(typeArguments []Type, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, minTypeArgumentCount number, isJavaScriptImplicitAny bool) []Type
	// OVERLOAD: fillMissingTypeArguments := func(typeArguments /* TODO(TypeOperator): readonly Type[] */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, minTypeArgumentCount number, isJavaScriptImplicitAny bool) /* TODO(ArrayType): Type[] */ any
	fillMissingTypeArguments := func(typeArguments /* TODO(TypeOperator): readonly Type[] */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, minTypeArgumentCount number, isJavaScriptImplicitAny bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ TODO {
		numTypeParameters := length(typeParameters)
		if !numTypeParameters {
			return /* TODO(ArrayLiteralExpression): [] */ TODO
		}
		numTypeArguments := length(typeArguments)
		if isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters) {
			result := /* TODO(ConditionalExpression): typeArguments ? typeArguments.slice() : [] */ TODO
			/* TODO(ForStatement): for (let i = numTypeArguments; i < numTypeParameters; i++) {                 result[i] = errorType;             } */
			baseDefaultType := getDefaultTypeArgumentType(isJavaScriptImplicitAny)
			/* TODO(ForStatement): for (let i = numTypeArguments; i < numTypeParameters; i++) {                 let defaultType = getDefaultFromTypeParameter(typeParameters![i]);                 if (isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType))) {                     defaultType = anyType;                 }                 result[i] = defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters!, result)) : baseDefaultType;             } */
			result.length = typeParameters.length
			return result
		}
		return typeArguments && typeArguments.slice()
	}
	getSignatureFromDeclaration := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) Signature {
		links := getNodeLinks(declaration)
		if !links.resolvedSignature {
			var parameters []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
			flags := SignatureFlagsNone
			minArgumentCount := 0
			var thisParameter *Symbol
			var thisTag *JSDocThisTag = /* TODO(ConditionalExpression): isInJSFile(declaration) ? getJSDocThisTag(declaration) : undefined */ TODO
			hasThisParameter := false
			iife := getImmediatelyInvokedFunctionExpression(declaration)
			isJSConstructSignature := isJSDocConstructSignature(declaration)
			isUntypedSignatureInJSFile := !iife && isInJSFile(declaration) && isValueSignatureDeclaration(declaration) && !hasJSDocParameterTags(declaration) && !getJSDocType(declaration)
			if isUntypedSignatureInJSFile {
				flags |= SignatureFlagsIsUntypedSignatureInJSFile
			}
			/* TODO(ForStatement): for (let i = isJSConstructSignature ? 1 : 0; i < declaration.parameters.length; i++) {                 const param = declaration.parameters[i];                 if (isInJSFile(param) && isJSDocThisTag(param)) {                     thisTag = param;                     continue;                 }                  let paramSymbol = param.symbol;                 const type = isJSDocParameterTag(param) ? (param.typeExpression && param.typeExpression.type) : param.type;                 // Include parameter symbol instead of property symbol in the signature                 if (paramSymbol && !!(paramSymbol.flags & SymbolFlags.Property) && !isBindingPattern(param.name)) {                     const resolvedSymbol = resolveName(param, paramSymbol.escapedName, SymbolFlags.Value, /*nameNotFoundMessage* / undefined, /*isUse* / false);                     paramSymbol = resolvedSymbol!;                 }                 if (i === 0 && paramSymbol.escapedName === InternalSymbolName.This) {                     hasThisParameter = true;                     thisParameter = param.symbol;                 }                 else {                     parameters.push(paramSymbol);                 }                  if (type && type.kind === SyntaxKind.LiteralType) {                     flags |= SignatureFlags.HasLiteralTypes;                 }                  // Record a new minimum argument count if this is not an optional parameter                 const isOptionalParameter = hasEffectiveQuestionToken(param) ||                     isParameter(param) && param.initializer || isRestParameter(param) ||                     iife && parameters.length > iife.arguments.length && !type;                 if (!isOptionalParameter) {                     minArgumentCount = parameters.length;                 }             } */
			if (declaration.kind == SyntaxKindGetAccessor || declaration.kind == SyntaxKindSetAccessor) && hasBindableName(declaration) && (!hasThisParameter || !thisParameter) {
				otherKind := /* TODO(ConditionalExpression): declaration.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor */ TODO
				other := getDeclarationOfKind(getSymbolOfDeclaration(declaration), otherKind)
				if other {
					thisParameter = getAnnotatedAccessorThisParameter(other)
				}
			}
			if thisTag && thisTag.typeExpression {
				thisParameter = createSymbolWithType(createSymbol(SymbolFlagsFunctionScopedVariable, InternalSymbolNameThis), getTypeFromTypeNode(thisTag.typeExpression))
			}
			hostDeclaration := /* TODO(ConditionalExpression): isJSDocSignature(declaration) ? getEffectiveJSDocHost(declaration) : declaration */ TODO
			classType := /* TODO(ConditionalExpression): hostDeclaration && isConstructorDeclaration(hostDeclaration) ?                 getDeclaredTypeOfClassOrInterface(getMergedSymbol((hostDeclaration.parent as ClassDeclaration).symbol))                 : undefined */ TODO
			typeParameters := /* TODO(ConditionalExpression): classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration) */ TODO
			if hasRestParameter(declaration) || isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters) {
				flags |= SignatureFlagsHasRestParameter
			}
			if isConstructorTypeNode(declaration) && hasSyntacticModifier(declaration, ModifierFlagsAbstract) || isConstructorDeclaration(declaration) && hasSyntacticModifier(declaration.parent, ModifierFlagsAbstract) {
				flags |= SignatureFlagsAbstract
			}
			links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, nil, nil, minArgumentCount, flags)
		}
		return links.resolvedSignature
	}
	maybeAddJsSyntheticRestParameter := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any, parameters []Symbol) bool {
		if isJSDocSignature(declaration) || !containsArgumentsReference(declaration) {
			return false
		}
		lastParam := lastOrUndefined(declaration.parameters)
		lastParamTags := /* TODO(ConditionalExpression): lastParam ? getJSDocParameterTags(lastParam) : getJSDocTags(declaration).filter(isJSDocParameterTag) */ TODO
		lastParamVariadicType := firstDefined(lastParamTags, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocParameterTag */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocVariadicType | undefined */ TODO {
			return /* TODO(ConditionalExpression): p.typeExpression && isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : undefined */ TODO
		})
		syntheticArgsSymbol := createSymbol(SymbolFlagsVariable, "args", CheckFlagsRestParameter)
		if lastParamVariadicType {
			syntheticArgsSymbol.links.type_ = createArrayType(getTypeFromTypeNode(lastParamVariadicType.type_))
		} else {
			syntheticArgsSymbol.links.checkFlags |= CheckFlagsDeferredType
			syntheticArgsSymbol.links.deferralParent = neverType
			syntheticArgsSymbol.links.deferralConstituents = /* TODO(ArrayLiteralExpression): [anyArrayType] */ TODO
			syntheticArgsSymbol.links.deferralWriteConstituents = /* TODO(ArrayLiteralExpression): [anyArrayType] */ TODO
		}
		if lastParamVariadicType {
			parameters.pop()
		}
		parameters.push(syntheticArgsSymbol)
		return true
	}
	getSignatureOfTypeTag := func(node /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		if !(isInJSFile(node) && isFunctionLikeDeclaration(node)) {
			return nil
		}
		typeTag := getJSDocTypeTag(node)
		return typeTag.typeExpression && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression))
	}
	getParameterTypeOfTypeTag := func(func_ FunctionLikeDeclaration, parameter ParameterDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		signature := getSignatureOfTypeTag(func_)
		if !signature {
			return nil
		}
		pos := func_.parameters.indexOf(parameter)
		return /* TODO(ConditionalExpression): parameter.dotDotDotToken ? getRestTypeAtPosition(signature, pos) : getTypeAtPosition(signature, pos) */ TODO
	}
	getReturnTypeOfTypeTag := func(node /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		signature := getSignatureOfTypeTag(node)
		return signature && getReturnTypeOfSignature(signature)
	}
	containsArgumentsReference := func(declaration SignatureDeclaration) bool {
		links := getNodeLinks(declaration)
		if links.containsArgumentsReference == nil {
			if links.flags & NodeCheckFlagsCaptureArguments {
				links.containsArgumentsReference = true
			} else {
				links.containsArgumentsReference = traverse((declaration).body)
			}
		}
		return links.containsArgumentsReference
		traverse := func(node Node) bool {
			if !node {
				return false
			}
			switch node.kind {
			case SyntaxKindIdentifier:
				return (node).escapedText == argumentsSymbol.escapedName && getReferencedValueSymbol(node) == argumentsSymbol
			case SyntaxKindPropertyDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				return (node).name.kind == SyntaxKindComputedPropertyName && traverse((node).name)
			case SyntaxKindPropertyAccessExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindElementAccessExpression:
				return traverse((node).expression)
			case SyntaxKindPropertyAssignment:
				return traverse((node).initializer)
			default:
				return !nodeStartsNewLexicalEnvironment(node) && !isPartOfTypeNode(node) && !!forEachChild(node, traverse)
			}
		}
	}
	getSignaturesOfSymbol := func(symbol *Symbol) []Signature {
		if !symbol || !symbol.declarations {
			return emptyArray
		}
		var result []Signature = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < symbol.declarations.length; i++) {             const decl = symbol.declarations[i];             if (!isFunctionLike(decl)) continue;             // Don't include signature if node is the implementation of an overloaded function. A node is considered             // an implementation node if it has a body and the previous node is of the same kind and immediately             // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).             if (i > 0 && (decl as FunctionLikeDeclaration).body) {                 const previous = symbol.declarations[i - 1];                 if (decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end) {                     continue;                 }             }             if (isInJSFile(decl) && decl.jsDoc) {                 const tags = getJSDocOverloadTags(decl);                 if (length(tags)) {                     for (const tag of tags) {                         const jsDocSignature = tag.typeExpression;                         if (jsDocSignature.type === undefined && !isConstructorDeclaration(decl)) {                             reportImplicitAny(jsDocSignature, anyType);                         }                         result.push(getSignatureFromDeclaration(jsDocSignature));                     }                     continue;                 }             }             // If this is a function or method declaration, get the signature from the @type tag for the sake of optional parameters.             // Exclude contextually-typed kinds because we already apply the @type tag to the context, plus applying it here to the initializer would supress checks that the two are compatible.             result.push(                 (!isFunctionExpressionOrArrowFunction(decl) &&                     !isObjectLiteralMethod(decl) &&                     getSignatureOfTypeTag(decl)) ||                     getSignatureFromDeclaration(decl),             );         } */
		return result
	}
	resolveExternalModuleTypeByLiteral := func(name StringLiteral) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		moduleSym := resolveExternalModuleName(name, name)
		if moduleSym {
			resolvedModuleSymbol := resolveExternalModuleSymbol(moduleSym)
			if resolvedModuleSymbol {
				return getTypeOfSymbol(resolvedModuleSymbol)
			}
		}
		return anyType
	}
	getThisTypeOfSignature := func(signature Signature) *Type {
		if signature.thisParameter {
			return getTypeOfSymbol(signature.thisParameter)
		}
	}
	getTypePredicateOfSignature := func(signature Signature) *TypePredicate {
		if !signature.resolvedTypePredicate {
			if signature.target {
				targetTypePredicate := getTypePredicateOfSignature(signature.target)
				signature.resolvedTypePredicate = /* TODO(ConditionalExpression): targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper!) : noTypePredicate */ TODO
			} else if signature.compositeSignatures {
				signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate
			} else {
				type_ := signature.declaration && getEffectiveReturnTypeNode(signature.declaration)
				var jsdocPredicate *TypePredicate
				if !type_ {
					jsdocSignature := getSignatureOfTypeTag(signature.declaration)
					if jsdocSignature && signature != jsdocSignature {
						jsdocPredicate = getTypePredicateOfSignature(jsdocSignature)
					}
				}
				if type_ || jsdocPredicate {
					signature.resolvedTypePredicate = /* TODO(ConditionalExpression): type && isTypePredicateNode(type) ?                         createTypePredicateFromTypePredicateNode(type, signature) :                         jsdocPredicate || noTypePredicate */ TODO
				} else if signature.declaration && isFunctionLikeDeclaration(signature.declaration) && (!signature.resolvedReturnType || signature.resolvedReturnType.flags&TypeFlagsBoolean) && getParameterCount(signature) > 0 {
					TODO_IDENTIFIER := signature
					signature.resolvedTypePredicate = noTypePredicate
					signature.resolvedTypePredicate = getTypePredicateFromBody(declaration) || noTypePredicate
				} else {
					signature.resolvedTypePredicate = noTypePredicate
				}
			}
			Debug.assert(!!signature.resolvedTypePredicate)
		}
		return /* TODO(ConditionalExpression): signature.resolvedTypePredicate === noTypePredicate ? undefined : signature.resolvedTypePredicate */ TODO
	}
	createTypePredicateFromTypePredicateNode := func(node TypePredicateNode, signature Signature) TypePredicate {
		parameterName := node.parameterName
		type_ := node.type_ && getTypeFromTypeNode(node.type_)
		return /* TODO(ConditionalExpression): parameterName.kind === SyntaxKind.ThisType ?             createTypePredicate(node.assertsModifier ? TypePredicateKind.AssertsThis : TypePredicateKind.This, /*parameterName* / undefined, /*parameterIndex* / undefined, type) :             createTypePredicate(node.assertsModifier ? TypePredicateKind.AssertsIdentifier : TypePredicateKind.Identifier, parameterName.escapedText as string, findIndex(signature.parameters, p => p.escapedName === parameterName.escapedText), type) */ TODO
	}
	getUnionOrIntersectionType := func(types []Type, kind *TypeFlags, unionReduction UnionReduction) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): kind !== TypeFlags.Intersection ? getUnionType(types, unionReduction) : getIntersectionType(types) */ TODO
	}
	getReturnTypeOfSignature := func(signature Signature) Type {
		if !signature.resolvedReturnType {
			if !pushTypeResolution(signature, TypeSystemPropertyNameResolvedReturnType) {
				return errorType
			}
			type_ := /* TODO(ConditionalExpression): signature.target ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper) :                 signature.compositeSignatures ? instantiateType(getUnionOrIntersectionType(map(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, UnionReduction.Subtype), signature.mapper) :                 getReturnTypeFromAnnotation(signature.declaration!) ||                 (nodeIsMissing((signature.declaration as FunctionLikeDeclaration).body) ? anyType : getReturnTypeFromBody(signature.declaration as FunctionLikeDeclaration)) */ TODO
			if signature.flags & SignatureFlagsIsInnerCallChain {
				type_ = addOptionalTypeMarker(type_)
			} else if signature.flags & SignatureFlagsIsOuterCallChain {
				type_ = getOptionalType(type_)
			}
			if !popTypeResolution() {
				if signature.declaration {
					typeNode := getEffectiveReturnTypeNode(signature.declaration)
					if typeNode {
						error(typeNode, Diagnostics.Return_type_annotation_circularly_references_itself)
					} else if noImplicitAny {
						declaration := signature.declaration
						name := getNameOfDeclaration(declaration)
						if name {
							error(name, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, declarationNameToString(name))
						} else {
							error(declaration, Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions)
						}
					}
				}
				type_ = anyType
			}
			/* TODO(ExpressionStatement): signature.resolvedReturnType ??= type; */
		}
		return signature.resolvedReturnType
	}
	getReturnTypeFromAnnotation := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if declaration.kind == SyntaxKindConstructor {
			return getDeclaredTypeOfClassOrInterface(getMergedSymbol((declaration.parent).symbol))
		}
		typeNode := getEffectiveReturnTypeNode(declaration)
		if isJSDocSignature(declaration) {
			root := getJSDocRoot(declaration)
			if root && isConstructorDeclaration(root.parent) && !typeNode {
				return getDeclaredTypeOfClassOrInterface(getMergedSymbol((root.parent.parent).symbol))
			}
		}
		if isJSDocConstructSignature(declaration) {
			return getTypeFromTypeNode(( /* TODO(ElementAccessExpression): declaration.parameters[0] */ TODO).type_)
		}
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
		if declaration.kind == SyntaxKindGetAccessor && hasBindableName(declaration) {
			jsDocType := isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration)
			if jsDocType {
				return jsDocType
			}
			setter := getDeclarationOfKind(getSymbolOfDeclaration(declaration), SyntaxKindSetAccessor)
			setterType := getAnnotatedAccessorType(setter)
			if setterType {
				return setterType
			}
		}
		return getReturnTypeOfTypeTag(declaration)
	}
	isResolvingReturnTypeOfSignature := func(signature Signature) bool {
		return signature.compositeSignatures && some(signature.compositeSignatures, isResolvingReturnTypeOfSignature) || !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, TypeSystemPropertyNameResolvedReturnType) >= 0
	}
	getRestTypeOfSignature := func(signature Signature) Type {
		return tryGetRestTypeOfSignature(signature) || anyType
	}
	tryGetRestTypeOfSignature := func(signature Signature) *Type {
		if signatureHasRestParameter(signature) {
			sigRestType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
			restType := /* TODO(ConditionalExpression): isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) : sigRestType */ TODO
			return restType && getIndexTypeOfType(restType, numberType)
		}
		return nil
	}
	getSignatureInstantiation := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any, isJavascript bool, inferredTypeParameters []TypeParameter) Signature {
		instantiatedSignature := getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript))
		if inferredTypeParameters {
			returnSignature := getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature))
			if returnSignature {
				newReturnSignature := cloneSignature(returnSignature)
				newReturnSignature.typeParameters = inferredTypeParameters
				newInstantiatedSignature := cloneSignature(instantiatedSignature)
				newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature)
				return newInstantiatedSignature
			}
		}
		return instantiatedSignature
	}
	getSignatureInstantiationWithoutFillingInTypeArguments := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) Signature {
		instantiations := signature.instantiations || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): signature.instantiations = new Map<string, Signature>() */ TODO)
		id := getTypeListId(typeArguments)
		instantiation := instantiations.get(id)
		if !instantiation {
			instantiations.set(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): instantiation = createSignatureInstantiation(signature, typeArguments) */, TODO)
		}
		return instantiation
	}
	createSignatureInstantiation := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) Signature {
		return instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments), true)
	}
	getTypeParametersForMapper := func(signature Signature) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ TODO {
		return sameMap(signature.typeParameters, func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return /* TODO(ConditionalExpression): tp.mapper ? instantiateType(tp, tp.mapper) : tp */ TODO
		})
	}
	createSignatureTypeMapper := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) TypeMapper {
		return createTypeMapper(getTypeParametersForMapper(signature), typeArguments)
	}
	getErasedSignature := func(signature Signature) Signature {
		return /* TODO(ConditionalExpression): signature.typeParameters ?             signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) :             signature */ TODO
	}
	createErasedSignature := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		return instantiateSignature(signature, createTypeEraser(signature.typeParameters), true)
	}
	getCanonicalSignature := func(signature Signature) Signature {
		return /* TODO(ConditionalExpression): signature.typeParameters ?             signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) :             signature */ TODO
	}
	createCanonicalSignature := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		return getSignatureInstantiation(signature, map_(signature.typeParameters, func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
			return /* TODO(ConditionalExpression): tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp */ TODO
		}), isInJSFile(signature.declaration))
	}
	getImplementationSignature := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		return /* TODO(ConditionalExpression): signature.typeParameters ?             signature.implementationSignatureCache ||= createImplementationSignature(signature) :             signature */ TODO
	}
	createImplementationSignature := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		return /* TODO(ConditionalExpression): signature.typeParameters ? instantiateSignature(signature, createTypeMapper([], [])) : signature */ TODO
	}
	getBaseSignature := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		typeParameters := signature.typeParameters
		if typeParameters {
			if signature.baseSignatureCache {
				return signature.baseSignatureCache
			}
			typeEraser := createTypeEraser(typeParameters)
			baseConstraintMapper := createTypeMapper(typeParameters, map_(typeParameters, func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return getConstraintOfTypeParameter(tp) || unknownType
			}))
			var baseConstraints []Type = map_(typeParameters, func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return instantiateType(tp, baseConstraintMapper) || unknownType
			})
			/* TODO(ForStatement): for (let i = 0; i < typeParameters.length - 1; i++) {                 baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper);             } */
			baseConstraints = instantiateTypes(baseConstraints, typeEraser)
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): signature.baseSignatureCache = instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints), /*eraseTypeParameters* / true) */ TODO
		}
		return signature
	}
	getOrCreateTypeFromSignature := func(signature Signature, outerTypeParameters []TypeParameter) ObjectType {
		if !signature.isolatedSignatureType {
			kind := signature.declaration.kind
			isConstructor := kind == nil || kind == SyntaxKindConstructor || kind == SyntaxKindConstructSignature || kind == SyntaxKindConstructorType
			type_ := createObjectType(ObjectFlagsAnonymous|ObjectFlagsSingleSignatureType, createSymbol(SymbolFlagsFunction, InternalSymbolNameFunction))
			if signature.declaration && !nodeIsSynthesized(signature.declaration) {
				type_.symbol.declarations = /* TODO(ArrayLiteralExpression): [signature.declaration] */ TODO
				type_.symbol.valueDeclaration = signature.declaration
			}
			/* TODO(ExpressionStatement): outerTypeParameters ||= signature.declaration && getOuterTypeParameters(signature.declaration, /*includeThisTypes* / true); */
			type_.outerTypeParameters = outerTypeParameters
			type_.members = emptySymbols
			type_.properties = emptyArray
			type_.callSignatures = /* TODO(ConditionalExpression): !isConstructor ? [signature] : emptyArray */ TODO
			type_.constructSignatures = /* TODO(ConditionalExpression): isConstructor ? [signature] : emptyArray */ TODO
			type_.indexInfos = emptyArray
			signature.isolatedSignatureType = type_
		}
		return signature.isolatedSignatureType
	}
	getIndexSymbol := func(symbol Symbol) *Symbol {
		return /* TODO(ConditionalExpression): symbol.members ? getIndexSymbolFromSymbolTable(symbol.members) : undefined */ TODO
	}
	getIndexSymbolFromSymbolTable := func(symbolTable SymbolTable) *Symbol {
		return symbolTable.get(InternalSymbolNameIndex)
	}
	createIndexInfo := func(keyType Type, type_ Type, isReadonly bool, declaration IndexSignatureDeclaration) IndexInfo {
		return /* TODO(ObjectLiteralExpression): { keyType, type, isReadonly, declaration } */ TODO
	}
	getIndexInfosOfSymbol := func(symbol Symbol) []IndexInfo {
		indexSymbol := getIndexSymbol(symbol)
		return /* TODO(ConditionalExpression): indexSymbol ? getIndexInfosOfIndexSymbol(indexSymbol) : emptyArray */ TODO
	}
	getIndexInfosOfIndexSymbol := func(indexSymbol Symbol) []IndexInfo {
		if indexSymbol.declarations {
			var indexInfos []IndexInfo = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, declaration := range indexSymbol.declarations {
				if declaration.parameters.length == 1 {
					parameter := /* TODO(ElementAccessExpression): declaration.parameters[0] */ TODO
					if parameter.type_ {
						forEachType(getTypeFromTypeNode(parameter.type_), func(keyType /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
							if isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos, keyType) {
								indexInfos.push(createIndexInfo(keyType /* TODO(ConditionalExpression): declaration.type ? getTypeFromTypeNode(declaration.type) : anyType */, TODO, hasEffectiveModifier(declaration, ModifierFlagsReadonly), declaration))
							}
						})
					}
				}
			}
			return indexInfos
		}
		return emptyArray
	}
	isValidIndexKeyType := func(type_ Type) bool {
		return !!(type_.flags & (TypeFlagsString | TypeFlagsNumber | TypeFlagsESSymbol)) || isPatternLiteralType(type_) || !!(type_.flags&TypeFlagsIntersection) && !isGenericType(type_) && some((type_).types, isValidIndexKeyType)
	}
	getConstraintDeclaration := func(type_ TypeParameter) *TypeNode {
		return /* TODO(ElementAccessExpression): mapDefined(filter(type.symbol && type.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0] */ TODO
	}
	getInferredTypeParameterConstraint := func(typeParameter TypeParameter, omitTypeReferences bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		var inferences /* TODO(ArrayType): Type[] */ any
		if typeParameter.symbol.declarations {
			for _, declaration := range typeParameter.symbol.declarations {
				if declaration.parent.kind == SyntaxKindInferType {
					TODO_IDENTIFIER := walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent)
					if grandParent.kind == SyntaxKindTypeReference && !omitTypeReferences {
						typeReference := grandParent
						typeParameters := getTypeParametersForTypeReferenceOrImport(typeReference)
						if typeParameters {
							index := typeReference.typeArguments.indexOf(childTypeParameter)
							if index < typeParameters.length {
								declaredConstraint := getConstraintOfTypeParameter( /* TODO(ElementAccessExpression): typeParameters[index] */ TODO)
								if declaredConstraint {
									mapper := makeDeferredTypeMapper(typeParameters, typeParameters.map_(func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO, index /* TODO inferred type number */ TODO) /* TODO inferred type () => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
										return func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
											return getEffectiveTypeArgumentAtIndex(typeReference, typeParameters, index)
										}
									}))
									constraint := instantiateType(declaredConstraint, mapper)
									if constraint != typeParameter {
										inferences = append(inferences, constraint)
									}
								}
							}
						}
					} else if grandParent.kind == SyntaxKindParameter && (grandParent).dotDotDotToken || grandParent.kind == SyntaxKindRestType || grandParent.kind == SyntaxKindNamedTupleMember && (grandParent).dotDotDotToken {
						inferences = append(inferences, createArrayType(unknownType))
					} else if grandParent.kind == SyntaxKindTemplateLiteralTypeSpan {
						inferences = append(inferences, stringType)
					} else if grandParent.kind == SyntaxKindTypeParameter && grandParent.parent.kind == SyntaxKindMappedType {
						inferences = append(inferences, stringNumberSymbolType)
					} else if grandParent.kind == SyntaxKindMappedType && (grandParent).type_ && skipParentheses((grandParent).type_) == declaration.parent && grandParent.parent.kind == SyntaxKindConditionalType && (grandParent.parent).extendsType == grandParent && (grandParent.parent).checkType.kind == SyntaxKindMappedType && ((grandParent.parent).checkType).type_ {
						checkMappedType := (grandParent.parent).checkType
						nodeType := getTypeFromTypeNode(checkMappedType.type_)
						inferences = append(inferences, instantiateType(nodeType, makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(checkMappedType.typeParameter)) /* TODO(ConditionalExpression): checkMappedType.typeParameter.constraint ? getTypeFromTypeNode(checkMappedType.typeParameter.constraint) : stringNumberSymbolType */, TODO)))
					}
				}
			}
		}
		return inferences && getIntersectionType(inferences)
	}
	getConstraintFromTypeParameter := func(typeParameter TypeParameter) *Type {
		if !typeParameter.constraint {
			if typeParameter.target {
				targetConstraint := getConstraintOfTypeParameter(typeParameter.target)
				typeParameter.constraint = /* TODO(ConditionalExpression): targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType */ TODO
			} else {
				constraintDeclaration := getConstraintDeclaration(typeParameter)
				if !constraintDeclaration {
					typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType
				} else {
					type_ := getTypeFromTypeNode(constraintDeclaration)
					if type_.flags&TypeFlagsAny && !isErrorType(type_) {
						type_ = /* TODO(ConditionalExpression): constraintDeclaration.parent.parent.kind === SyntaxKind.MappedType ? stringNumberSymbolType : unknownType */ TODO
					}
					typeParameter.constraint = type_
				}
			}
		}
		return /* TODO(ConditionalExpression): typeParameter.constraint === noConstraintType ? undefined : typeParameter.constraint */ TODO
	}
	getParentSymbolOfTypeParameter := func(typeParameter TypeParameter) *Symbol {
		tp := getDeclarationOfKind(typeParameter.symbol, SyntaxKindTypeParameter)
		host := /* TODO(ConditionalExpression): isJSDocTemplateTag(tp.parent) ? getEffectiveContainerForJSDocTemplateTag(tp.parent) : tp.parent */ TODO
		return host && getSymbolOfNode(host)
	}
	getTypeListId := func(types /* TODO(TypeOperator): readonly Type[] */ any) /* TODO inferred type string */ TODO {
		result := ""
		if types {
			length := types.length
			i := 0
			for i < length {
				startId := /* TODO(ElementAccessExpression): types[i] */ TODO.id
				count := 1
				for /* TODO(PlusToken): + */ /* TODO(BinaryExpression): i + count */ TODO < length && /* TODO(ElementAccessExpression): types[i + count] */ TODO.id == /* TODO(PlusToken): + */ /* TODO(BinaryExpression): startId + count */ TODO {
					count++
				}
				if result.length {
					result += ","
				}
				result += startId
				if count > 1 {
					result += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): ":" + count */ TODO
				}
				i += count
			}
		}
		return result
	}
	getAliasId := func(aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO inferred type string */ TODO {
		return /* TODO(ConditionalExpression): aliasSymbol ? `@${getSymbolId(aliasSymbol)}` + (aliasTypeArguments ? `:${getTypeListId(aliasTypeArguments)}` : "") : "" */ TODO
	}
	getPropagatingFlagsOfTypes := func(types []Type, excludeKinds TypeFlags) ObjectFlags {
		var result ObjectFlags = 0
		for _, type_ := range types {
			if excludeKinds == nil || !(type_.flags & excludeKinds) {
				result |= getObjectFlags(type_)
			}
		}
		return result & ObjectFlagsPropagatingFlags
	}
	tryCreateTypeReference := func(target GenericType, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) Type {
		if some(typeArguments) && target == emptyGenericType {
			return unknownType
		}
		return createTypeReference(target, typeArguments)
	}
	createTypeReference := func(target GenericType, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) TypeReference {
		id := getTypeListId(typeArguments)
		type_ := target.instantiations.get(id)
		if !type_ {
			type_ = createObjectType(ObjectFlagsReference, target.symbol)
			target.instantiations.set(id, type_)
			type_.objectFlags |= /* TODO(ConditionalExpression): typeArguments ? getPropagatingFlagsOfTypes(typeArguments) : 0 */ TODO
			type_.target = target
			type_.resolvedTypeArguments = typeArguments
		}
		return type_
	}
	cloneTypeReference := func(source TypeReference) TypeReference {
		type_ := createTypeWithSymbol(source.flags, source.symbol)
		type_.objectFlags = source.objectFlags
		type_.target = source.target
		type_.resolvedTypeArguments = source.resolvedTypeArguments
		return type_
	}
	createDeferredTypeReference := func(target GenericType, node /* TODO(UnionType): TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) DeferredTypeReference {
		if !aliasSymbol {
			aliasSymbol = getAliasSymbolForTypeNode(node)
			localAliasTypeArguments := getTypeArgumentsForAliasSymbol(aliasSymbol)
			aliasTypeArguments = /* TODO(ConditionalExpression): mapper ? instantiateTypes(localAliasTypeArguments, mapper) : localAliasTypeArguments */ TODO
		}
		type_ := createObjectType(ObjectFlagsReference, target.symbol)
		type_.target = target
		type_.node = node
		type_.mapper = mapper
		type_.aliasSymbol = aliasSymbol
		type_.aliasTypeArguments = aliasTypeArguments
		return type_
	}
	getTypeArguments := func(type_ TypeReference) []Type {
		if !type_.resolvedTypeArguments {
			if !pushTypeResolution(type_, TypeSystemPropertyNameResolvedTypeArguments) {
				return concatenate(type_.target.outerTypeParameters, type_.target.localTypeParameters.map_(func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
					return errorType
				})) || emptyArray
			}
			node := type_.node
			typeArguments := /* TODO(ConditionalExpression): !node ? emptyArray :                 node.kind === SyntaxKind.TypeReference ? concatenate(type.target.outerTypeParameters, getEffectiveTypeArguments(node, type.target.localTypeParameters!)) :                 node.kind === SyntaxKind.ArrayType ? [getTypeFromTypeNode(node.elementType)] :                 map(node.elements, getTypeFromTypeNode) */ TODO
			if popTypeResolution() {
				/* TODO(ExpressionStatement): type.resolvedTypeArguments ??= type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments; */
			} else {
				/* TODO(ExpressionStatement): type.resolvedTypeArguments ??= concatenate(type.target.outerTypeParameters, type.target.localTypeParameters?.map(() => errorType) || emptyArray); */
				error(type_.node || currentNode /* TODO(ConditionalExpression): type.target.symbol ? Diagnostics.Type_arguments_for_0_circularly_reference_themselves : Diagnostics.Tuple_type_arguments_circularly_reference_themselves */, TODO, type_.target.symbol && symbolToString(type_.target.symbol))
			}
		}
		return type_.resolvedTypeArguments
	}
	getTypeReferenceArity := func(type_ TypeReference) number {
		return length(type_.target.typeParameters)
	}
	getTypeFromClassOrInterfaceReference := func(node NodeWithTypeArguments, symbol Symbol) Type {
		type_ := getDeclaredTypeOfSymbol(getMergedSymbol(symbol))
		typeParameters := type_.localTypeParameters
		if typeParameters {
			numTypeArguments := length(node.typeArguments)
			minTypeArgumentCount := getMinTypeArgumentCount(typeParameters)
			isJs := isInJSFile(node)
			isJsImplicitAny := !noImplicitAny && isJs
			if !isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
				missingAugmentsTag := isJs && isExpressionWithTypeArguments(node) && !isJSDocAugmentsTag(node.parent)
				diag := /* TODO(ConditionalExpression): minTypeArgumentCount === typeParameters.length ?                     missingAugmentsTag ?                         Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag :                         Diagnostics.Generic_type_0_requires_1_type_argument_s :                     missingAugmentsTag ?                     Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag :                     Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments */ TODO
				typeStr := typeToString(type_, nil, TypeFormatFlagsWriteArrayAsGenericType)
				error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length)
				if !isJs {
					return errorType
				}
			}
			if node.kind == SyntaxKindTypeReference && isDeferredTypeReferenceNode(node, length(node.typeArguments) != typeParameters.length) {
				return createDeferredTypeReference(type_, node, nil)
			}
			typeArguments := concatenate(type_.outerTypeParameters, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs))
			return createTypeReference(type_, typeArguments)
		}
		return /* TODO(ConditionalExpression): checkNoTypeArguments(node, symbol) ? type : errorType */ TODO
	}
	getTypeAliasInstantiation := func(symbol Symbol, typeArguments /* TODO(TypeOperator): readonly Type[] */ any, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		type_ := getDeclaredTypeOfSymbol(symbol)
		if type_ == intrinsicMarkerType {
			typeKind := intrinsicTypeKinds.get(symbol.escapedName)
			if typeKind != nil && typeArguments && typeArguments.length == 1 {
				return /* TODO(ConditionalExpression): typeKind === IntrinsicTypeKind.NoInfer ? getNoInferType(typeArguments[0]) : getStringMappingType(symbol, typeArguments[0]) */ TODO
			}
		}
		links := getSymbolLinks(symbol)
		typeParameters := links.typeParameters
		id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
		instantiation := links.instantiations.get(id)
		if !instantiation {
			links.instantiations.set(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments) */, TODO)
		}
		return instantiation
	}
	getTypeFromTypeAliasReference := func(node NodeWithTypeArguments, symbol Symbol) Type {
		if getCheckFlags(symbol) & CheckFlagsUnresolved {
			typeArguments := typeArgumentsFromTypeReferenceNode(node)
			id := getAliasId(symbol, typeArguments)
			errorType := errorTypes.get(id)
			if !errorType {
				errorType = createIntrinsicType(TypeFlagsAny, "error", nil /* TODO(TemplateExpression): `alias ${id}` */, TODO)
				errorType.aliasSymbol = symbol
				errorType.aliasTypeArguments = typeArguments
				errorTypes.set(id, errorType)
			}
			return errorType
		}
		type_ := getDeclaredTypeOfSymbol(symbol)
		typeParameters := getSymbolLinks(symbol).typeParameters
		if typeParameters {
			numTypeArguments := length(node.typeArguments)
			minTypeArgumentCount := getMinTypeArgumentCount(typeParameters)
			if numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length {
				error(node /* TODO(ConditionalExpression): minTypeArgumentCount === typeParameters.length ?                         Diagnostics.Generic_type_0_requires_1_type_argument_s :                         Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments */, TODO, symbolToString(symbol), minTypeArgumentCount, typeParameters.length)
				return errorType
			}
			aliasSymbol := getAliasSymbolForTypeNode(node)
			newAliasSymbol := /* TODO(ConditionalExpression): aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(aliasSymbol)) ? aliasSymbol : undefined */ TODO
			var aliasTypeArguments /* TODO(ArrayType): Type[] */ any
			if newAliasSymbol {
				aliasTypeArguments = getTypeArgumentsForAliasSymbol(newAliasSymbol)
			} else if isTypeReferenceType(node) {
				aliasSymbol := resolveTypeReferenceName(node, SymbolFlagsAlias, true)
				if aliasSymbol && aliasSymbol != unknownSymbol {
					resolved := resolveAlias(aliasSymbol)
					if resolved && resolved.flags&SymbolFlagsTypeAlias {
						newAliasSymbol = resolved
						aliasTypeArguments = typeArgumentsFromTypeReferenceNode(node) || ( /* TODO(ConditionalExpression): typeParameters ? [] : undefined */ TODO)
					}
				}
			}
			return getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, aliasTypeArguments)
		}
		return /* TODO(ConditionalExpression): checkNoTypeArguments(node, symbol) ? type : errorType */ TODO
	}
	isLocalTypeAlias := func(symbol Symbol) /* TODO inferred type boolean */ TODO {
		declaration := symbol.declarations.find(isTypeAlias)
		return !!(declaration && getContainingFunction(declaration))
	}
	getTypeReferenceName := func(node TypeReferenceType) *EntityNameOrEntityNameExpression {
		switch node.kind {
		case SyntaxKindTypeReference:
			return node.typeName
		case SyntaxKindExpressionWithTypeArguments:
			expr := node.expression
			if isEntityNameExpression(expr) {
				return expr
			}
		}
		return nil
	}
	getSymbolPath := func(symbol Symbol) string {
		return /* TODO(ConditionalExpression): symbol.parent ? `${getSymbolPath(symbol.parent)}.${symbol.escapedName}` : symbol.escapedName as string */ TODO
	}
	getUnresolvedSymbolForEntityName := func(name EntityNameOrEntityNameExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		identifier := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.right :             name.kind === SyntaxKind.PropertyAccessExpression ? name.name :             name */ TODO
		text := identifier.escapedText
		if text {
			parentSymbol := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? getUnresolvedSymbolForEntityName(name.left) :                 name.kind === SyntaxKind.PropertyAccessExpression ? getUnresolvedSymbolForEntityName(name.expression) :                 undefined */ TODO
			path := /* TODO(ConditionalExpression): parentSymbol ? `${getSymbolPath(parentSymbol)}.${text}` : text as string */ TODO
			result := unresolvedSymbols.get(path)
			if !result {
				unresolvedSymbols.set(path /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = createSymbol(SymbolFlags.TypeAlias, text, CheckFlags.Unresolved) */, TODO)
				result.parent = parentSymbol
				result.links.declaredType = unresolvedType
			}
			return result
		}
		return unknownSymbol
	}
	resolveTypeReferenceName := func(typeReference TypeReferenceType, meaning SymbolFlags, ignoreErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		name := getTypeReferenceName(typeReference)
		if !name {
			return unknownSymbol
		}
		symbol := resolveEntityName(name, meaning, ignoreErrors)
		return /* TODO(ConditionalExpression): symbol && symbol !== unknownSymbol ? symbol :             ignoreErrors ? unknownSymbol : getUnresolvedSymbolForEntityName(name) */ TODO
	}
	getTypeReferenceType := func(node NodeWithTypeArguments, symbol Symbol) Type {
		if symbol == unknownSymbol {
			return errorType
		}
		symbol = getExpandoSymbol(symbol) || symbol
		if symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
			return getTypeFromClassOrInterfaceReference(node, symbol)
		}
		if symbol.flags & SymbolFlagsTypeAlias {
			return getTypeFromTypeAliasReference(node, symbol)
		}
		res := tryGetDeclaredTypeOfSymbol(symbol)
		if res {
			return /* TODO(ConditionalExpression): checkNoTypeArguments(node, symbol) ? getRegularTypeOfLiteralType(res) : errorType */ TODO
		}
		if symbol.flags&SymbolFlagsValue && isJSDocTypeReference(node) {
			jsdocType := getTypeFromJSDocValueReference(node, symbol)
			if jsdocType {
				return jsdocType
			} else {
				resolveTypeReferenceName(node, SymbolFlagsType)
				return getTypeOfSymbol(symbol)
			}
		}
		return errorType
	}
	getTypeFromJSDocValueReference := func(node NodeWithTypeArguments, symbol Symbol) *Type {
		links := getNodeLinks(node)
		if !links.resolvedJSDocType {
			valueType := getTypeOfSymbol(symbol)
			typeType := valueType
			if symbol.valueDeclaration {
				isImportTypeWithQualifier := node.kind == SyntaxKindImportType && (node).qualifier
				if valueType.symbol && valueType.symbol != symbol && isImportTypeWithQualifier {
					typeType = getTypeReferenceType(node, valueType.symbol)
				}
			}
			links.resolvedJSDocType = typeType
		}
		return links.resolvedJSDocType
	}
	getNoInferType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): isNoInferTargetType(type) ? getOrCreateSubstitutionType(type, unknownType) : type */ TODO
	}
	isNoInferTargetType := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsUnionOrIntersection && some((type_).types, isNoInferTargetType) || type_.flags&TypeFlagsSubstitution && !isNoInferType(type_) && isNoInferTargetType((type_).baseType) || type_.flags&TypeFlagsObject && !isEmptyAnonymousObjectType(type_) || type_.flags&(TypeFlagsInstantiable&~TypeFlagsSubstitution) && !isPatternLiteralType(type_))
	}
	isNoInferType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(type_.flags&TypeFlagsSubstitution && (type_).constraint.flags&TypeFlagsUnknown)
	}
	getSubstitutionType := func(baseType Type, constraint Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): constraint.flags & TypeFlags.AnyOrUnknown || constraint === baseType || baseType.flags & TypeFlags.Any ?             baseType :             getOrCreateSubstitutionType(baseType, constraint) */ TODO
	}
	getOrCreateSubstitutionType := func(baseType Type, constraint Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SubstitutionType */ TODO {
		id := /* TODO(TemplateExpression): `${getTypeId(baseType)}>${getTypeId(constraint)}` */ TODO
		cached := substitutionTypes.get(id)
		if cached {
			return cached
		}
		result := createType(TypeFlagsSubstitution)
		result.baseType = baseType
		result.constraint = constraint
		substitutionTypes.set(id, result)
		return result
	}
	getSubstitutionIntersection := func(substitutionType SubstitutionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): isNoInferType(substitutionType) ? substitutionType.baseType : getIntersectionType([substitutionType.constraint, substitutionType.baseType]) */ TODO
	}
	isUnaryTupleTypeNode := func(node TypeNode) /* TODO inferred type boolean */ TODO {
		return node.kind == SyntaxKindTupleType && (node).elements.length == 1
	}
	getImpliedConstraint := func(type_ Type, checkNode TypeNode, extendsNode TypeNode) *Type {
		return /* TODO(ConditionalExpression): isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode) ? getImpliedConstraint(type, (checkNode as TupleTypeNode).elements[0], (extendsNode as TupleTypeNode).elements[0]) :             getActualTypeVariable(getTypeFromTypeNode(checkNode)) === getActualTypeVariable(type) ? getTypeFromTypeNode(extendsNode) :             undefined */ TODO
	}
	getConditionalFlowTypeOfType := func(type_ Type, node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		var constraints /* TODO(ArrayType): Type[] */ any
		covariant := true
		for node && !isStatement(node) && node.kind != SyntaxKindJSDoc {
			parent := node.parent
			if parent.kind == SyntaxKindParameter {
				covariant = !covariant
			}
			if (covariant || type_.flags&TypeFlagsTypeVariable) && parent.kind == SyntaxKindConditionalType && node == (parent).trueType {
				constraint := getImpliedConstraint(type_, (parent).checkType, (parent).extendsType)
				if constraint {
					constraints = append(constraints, constraint)
				}
			} else if type_.flags&TypeFlagsTypeParameter && parent.kind == SyntaxKindMappedType && !(parent).nameType && node == (parent).type_ {
				mappedType := getTypeFromTypeNode(parent)
				if getTypeParameterFromMappedType(mappedType) == getActualTypeVariable(type_) {
					typeParameter := getHomomorphicTypeVariable(mappedType)
					if typeParameter {
						constraint := getConstraintOfTypeParameter(typeParameter)
						if constraint && everyType(constraint, isArrayOrTupleType) {
							constraints = append(constraints, getUnionType( /* TODO(ArrayLiteralExpression): [numberType, numericStringType] */ TODO))
						}
					}
				}
			}
			node = parent
		}
		return /* TODO(ConditionalExpression): constraints ? getSubstitutionType(type, getIntersectionType(constraints)) : type */ TODO
	}
	isJSDocTypeReference := func(node Node) /* TODO(TypePredicate): node is TypeReferenceNode */ any {
		return !!(node.flags & NodeFlagsJSDoc) && (node.kind == SyntaxKindTypeReference || node.kind == SyntaxKindImportType)
	}
	checkNoTypeArguments := func(node NodeWithTypeArguments, symbol Symbol) /* TODO inferred type boolean */ TODO {
		if node.typeArguments {
			error(node, Diagnostics.Type_0_is_not_generic /* TODO(ConditionalExpression): symbol ? symbolToString(symbol) : (node as TypeReferenceNode).typeName ? declarationNameToString((node as TypeReferenceNode).typeName) : anon */, TODO)
			return false
		}
		return true
	}
	getIntendedTypeFromJSDocTypeReference := func(node TypeReferenceNode) *Type {
		if isIdentifier(node.typeName) {
			typeArgs := node.typeArguments
			switch node.typeName.escapedText {
			case "String":
				checkNoTypeArguments(node)
				return stringType
			case "Number":
				checkNoTypeArguments(node)
				return numberType
			case "Boolean":
				checkNoTypeArguments(node)
				return booleanType
			case "Void":
				checkNoTypeArguments(node)
				return voidType
			case "Undefined":
				checkNoTypeArguments(node)
				return undefinedType
			case "Null":
				checkNoTypeArguments(node)
				return nullType
			case "Function":
				fallthrough // TODO: merge cases
			case "function":
				checkNoTypeArguments(node)
				return globalFunctionType
			case "array":
				return /* TODO(ConditionalExpression): (!typeArgs || !typeArgs.length) && !noImplicitAny ? anyArrayType : undefined */ TODO
			case "promise":
				return /* TODO(ConditionalExpression): (!typeArgs || !typeArgs.length) && !noImplicitAny ? createPromiseType(anyType) : undefined */ TODO
			case "Object":
				if typeArgs && typeArgs.length == 2 {
					if isJSDocIndexSignature(node) {
						indexed := getTypeFromTypeNode( /* TODO(ElementAccessExpression): typeArgs[0] */ TODO)
						target := getTypeFromTypeNode( /* TODO(ElementAccessExpression): typeArgs[1] */ TODO)
						indexInfo := /* TODO(ConditionalExpression): indexed === stringType || indexed === numberType ? [createIndexInfo(indexed, target, /*isReadonly* / false)] : emptyArray */ TODO
						return createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, indexInfo)
					}
					return anyType
				}
				checkNoTypeArguments(node)
				return /* TODO(ConditionalExpression): !noImplicitAny ? anyType : undefined */ TODO
			}
		}
	}
	getTypeFromJSDocNullableTypeNode := func(node JSDocNullableType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		type_ := getTypeFromTypeNode(node.type_)
		return /* TODO(ConditionalExpression): strictNullChecks ? getNullableType(type, TypeFlags.Null) : type */ TODO
	}
	getTypeFromTypeReference := func(node TypeReferenceType) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			if isConstTypeReference(node) && isAssertionExpression(node.parent) {
				links.resolvedSymbol = unknownSymbol
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = checkExpressionCached(node.parent.expression) */ TODO
			}
			var symbol *Symbol
			var type_ *Type
			meaning := SymbolFlagsType
			if isJSDocTypeReference(node) {
				type_ = getIntendedTypeFromJSDocTypeReference(node)
				if !type_ {
					symbol = resolveTypeReferenceName(node, meaning, true)
					if symbol == unknownSymbol {
						symbol = resolveTypeReferenceName(node, meaning|SymbolFlagsValue)
					} else {
						resolveTypeReferenceName(node, meaning)
					}
					type_ = getTypeReferenceType(node, symbol)
				}
			}
			if !type_ {
				symbol = resolveTypeReferenceName(node, meaning)
				type_ = getTypeReferenceType(node, symbol)
			}
			links.resolvedSymbol = symbol
			links.resolvedType = type_
		}
		return links.resolvedType
	}
	typeArgumentsFromTypeReferenceNode := func(node NodeWithTypeArguments) /* TODO(ArrayType): Type[] */ any {
		return map_(node.typeArguments, getTypeFromTypeNode)
	}
	getTypeFromTypeQueryNode := func(node TypeQueryNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			type_ := checkExpressionWithTypeArguments(node)
			links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(type_))
		}
		return links.resolvedType
	}
	getTypeOfGlobalSymbol := func(symbol *Symbol, arity number) ObjectType {
		getTypeDeclaration := func(symbol Symbol) Declaration {
			declarations := symbol.declarations
			if declarations {
				for _, declaration := range declarations {
					switch declaration.kind {
					case SyntaxKindClassDeclaration:
						fallthrough // TODO: merge cases
					case SyntaxKindInterfaceDeclaration:
						fallthrough // TODO: merge cases
					case SyntaxKindEnumDeclaration:
						return declaration
					}
				}
			}
		}
		if !symbol {
			return /* TODO(ConditionalExpression): arity ? emptyGenericType : emptyObjectType */ TODO
		}
		type_ := getDeclaredTypeOfSymbol(symbol)
		if !(type_.flags & TypeFlagsObject) {
			error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_be_a_class_or_interface_type, symbolName(symbol))
			return /* TODO(ConditionalExpression): arity ? emptyGenericType : emptyObjectType */ TODO
		}
		if length((type_).typeParameters) != arity {
			error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity)
			return /* TODO(ConditionalExpression): arity ? emptyGenericType : emptyObjectType */ TODO
		}
		return type_
	}
	getGlobalValueSymbol := func(name __String, reportErrors bool) *Symbol {
		return getGlobalSymbol(name, SymbolFlagsValue /* TODO(ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_value_0 : undefined */, TODO)
	}
	getGlobalTypeSymbol := func(name __String, reportErrors bool) *Symbol {
		return getGlobalSymbol(name, SymbolFlagsType /* TODO(ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined */, TODO)
	}
	getGlobalTypeAliasSymbol := func(name __String, arity number, reportErrors bool) *Symbol {
		symbol := getGlobalSymbol(name, SymbolFlagsType /* TODO(ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined */, TODO)
		if symbol {
			getDeclaredTypeOfSymbol(symbol)
			if length(getSymbolLinks(symbol).typeParameters) != arity {
				decl := symbol.declarations && find(symbol.declarations, isTypeAliasDeclaration)
				error(decl, Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity)
				return nil
			}
		}
		return symbol
	}
	getGlobalSymbol := func(name __String, meaning SymbolFlags, diagnostic *DiagnosticMessage) *Symbol {
		return resolveName(nil, name, meaning, diagnostic, false, false)
	}
	// OVERLOAD: getGlobalType := func(name __String, arity /* TODO(LiteralType): 0 */ any, reportErrors /* TODO(LiteralType): true */ any) ObjectType
	// OVERLOAD: getGlobalType := func(name __String, arity /* TODO(LiteralType): 0 */ any, reportErrors bool) *ObjectType
	// OVERLOAD: getGlobalType := func(name __String, arity number, reportErrors /* TODO(LiteralType): true */ any) GenericType
	// OVERLOAD: getGlobalType := func(name __String, arity number, reportErrors bool) *GenericType
	getGlobalType := func(name __String, arity number, reportErrors bool) *ObjectType {
		symbol := getGlobalTypeSymbol(name, reportErrors)
		return /* TODO(ConditionalExpression): symbol || reportErrors ? getTypeOfGlobalSymbol(symbol, arity) : undefined */ TODO
	}
	// OVERLOAD: getGlobalBuiltinTypes := func(typeNames []string, arity /* TODO(LiteralType): 0 */ any) []ObjectType
	// OVERLOAD: getGlobalBuiltinTypes := func(typeNames []string, arity number) []GenericType
	getGlobalBuiltinTypes := func(typeNames []string, arity number) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
		var types /* TODO(ArrayType): Type[] */ any
		for _, typeName := range typeNames {
			types = append(types, getGlobalType(typeName, arity, false))
		}
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): types ?? emptyArray */ TODO
	}
	getGlobalTypedPropertyDescriptorType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalTypedPropertyDescriptorType ||= getGlobalType("TypedPropertyDescriptor" as __String, /*arity* / 1, /*reportErrors* / true) || emptyGenericType */ TODO
	}
	getGlobalTemplateStringsArrayType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalTemplateStringsArrayType ||= getGlobalType("TemplateStringsArray" as __String, /*arity* / 0, /*reportErrors* / true) || emptyObjectType */ TODO
	}
	getGlobalImportMetaType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalImportMetaType ||= getGlobalType("ImportMeta" as __String, /*arity* / 0, /*reportErrors* / true) || emptyObjectType */ TODO
	}
	getGlobalImportMetaExpressionType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		if !deferredGlobalImportMetaExpressionType {
			symbol := createSymbol(SymbolFlagsNone, "ImportMetaExpression")
			importMetaType := getGlobalImportMetaType()
			metaPropertySymbol := createSymbol(SymbolFlagsProperty, "meta", CheckFlagsReadonly)
			metaPropertySymbol.parent = symbol
			metaPropertySymbol.links.type_ = importMetaType
			members := createSymbolTable( /* TODO(ArrayLiteralExpression): [metaPropertySymbol] */ TODO)
			symbol.members = members
			deferredGlobalImportMetaExpressionType = createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
		}
		return deferredGlobalImportMetaExpressionType
	}
	getGlobalImportCallOptionsType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalImportCallOptionsType ||= getGlobalType("ImportCallOptions" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalImportAttributesType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalImportAttributesType ||= getGlobalType("ImportAttributes" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalESSymbolConstructorSymbol := func(reportErrors bool) *Symbol {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalESSymbolConstructorSymbol ||= getGlobalValueSymbol("Symbol" as __String, reportErrors) */ TODO
	}
	getGlobalESSymbolConstructorTypeSymbol := func(reportErrors bool) *Symbol {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalESSymbolConstructorTypeSymbol ||= getGlobalTypeSymbol("SymbolConstructor" as __String, reportErrors) */ TODO
	}
	getGlobalESSymbolType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalESSymbolType ||= getGlobalType("Symbol" as __String, /*arity* / 0, /*reportErrors* / false) */ TODO) || emptyObjectType
	}
	getGlobalPromiseType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalPromiseType ||= getGlobalType("Promise" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalPromiseLikeType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalPromiseLikeType ||= getGlobalType("PromiseLike" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalPromiseConstructorSymbol := func(reportErrors bool) *Symbol {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalPromiseConstructorSymbol ||= getGlobalValueSymbol("Promise" as __String, reportErrors) */ TODO
	}
	getGlobalPromiseConstructorLikeType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalPromiseConstructorLikeType ||= getGlobalType("PromiseConstructorLike" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalAsyncIterableType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalAsyncIterableType ||= getGlobalType("AsyncIterable" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalAsyncIteratorType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalAsyncIteratorType ||= getGlobalType("AsyncIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalAsyncIterableIteratorType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalAsyncIterableIteratorType ||= getGlobalType("AsyncIterableIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalBuiltinAsyncIteratorTypes := func() /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType[] */ TODO {
		return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): deferredGlobalBuiltinAsyncIteratorTypes ??= getGlobalBuiltinTypes(["ReadableStreamAsyncIterator"], 1) */ TODO
	}
	getGlobalAsyncIteratorObjectType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalAsyncIteratorObjectType ||= getGlobalType("AsyncIteratorObject" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalAsyncGeneratorType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalAsyncGeneratorType ||= getGlobalType("AsyncGenerator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIterableType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalIterableType ||= getGlobalType("Iterable" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIteratorType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalIteratorType ||= getGlobalType("Iterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIterableIteratorType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalIterableIteratorType ||= getGlobalType("IterableIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getBuiltinIteratorReturnType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
		return /* TODO(ConditionalExpression): strictBuiltinIteratorReturn ? undefinedType : anyType */ TODO
	}
	getGlobalBuiltinIteratorTypes := func() /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType[] */ TODO {
		return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): deferredGlobalBuiltinIteratorTypes ??= getGlobalBuiltinTypes(["ArrayIterator", "MapIterator", "SetIterator", "StringIterator"], 1) */ TODO
	}
	getGlobalIteratorObjectType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalIteratorObjectType ||= getGlobalType("IteratorObject" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalGeneratorType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalGeneratorType ||= getGlobalType("Generator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIteratorYieldResultType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalIteratorYieldResultType ||= getGlobalType("IteratorYieldResult" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIteratorReturnResultType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalIteratorReturnResultType ||= getGlobalType("IteratorReturnResult" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalDisposableType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalDisposableType ||= getGlobalType("Disposable" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalAsyncDisposableType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalAsyncDisposableType ||= getGlobalType("AsyncDisposable" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalTypeOrUndefined := func(name __String, arity /* TODO inferred type number */ TODO /*  = 0 */) *ObjectType {
		symbol := getGlobalSymbol(name, SymbolFlagsType, nil)
		return symbol && getTypeOfGlobalSymbol(symbol, arity)
	}
	getGlobalExtractSymbol := func() *Symbol {
		/* TODO(ExpressionStatement): deferredGlobalExtractSymbol ||= getGlobalTypeAliasSymbol("Extract" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol; */
		return /* TODO(ConditionalExpression): deferredGlobalExtractSymbol === unknownSymbol ? undefined : deferredGlobalExtractSymbol */ TODO
	}
	getGlobalOmitSymbol := func() *Symbol {
		/* TODO(ExpressionStatement): deferredGlobalOmitSymbol ||= getGlobalTypeAliasSymbol("Omit" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol; */
		return /* TODO(ConditionalExpression): deferredGlobalOmitSymbol === unknownSymbol ? undefined : deferredGlobalOmitSymbol */ TODO
	}
	getGlobalAwaitedSymbol := func(reportErrors bool) *Symbol {
		/* TODO(ExpressionStatement): deferredGlobalAwaitedSymbol ||= getGlobalTypeAliasSymbol("Awaited" as __String, /*arity* / 1, reportErrors) || (reportErrors ? unknownSymbol : undefined); */
		return /* TODO(ConditionalExpression): deferredGlobalAwaitedSymbol === unknownSymbol ? undefined : deferredGlobalAwaitedSymbol */ TODO
	}
	getGlobalBigIntType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalBigIntType ||= getGlobalType("BigInt" as __String, /*arity* / 0, /*reportErrors* / false) */ TODO) || emptyObjectType
	}
	getGlobalClassDecoratorContextType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassDecoratorContextType ??= getGlobalType("ClassDecoratorContext" as __String, /*arity* / 1, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassMethodDecoratorContextType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassMethodDecoratorContextType ??= getGlobalType("ClassMethodDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassGetterDecoratorContextType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassGetterDecoratorContextType ??= getGlobalType("ClassGetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassSetterDecoratorContextType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassSetterDecoratorContextType ??= getGlobalType("ClassSetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorContextType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassAccessorDecoratorContextType ??= getGlobalType("ClassAccessorDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorTargetType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassAccessorDecoratorTargetType ??= getGlobalType("ClassAccessorDecoratorTarget" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorResultType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassAccessorDecoratorResultType ??= getGlobalType("ClassAccessorDecoratorResult" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassFieldDecoratorContextType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassFieldDecoratorContextType ??= getGlobalType("ClassFieldDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalNaNSymbol := func() *Symbol {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalNaNSymbol ||= getGlobalValueSymbol("NaN" as __String, /*reportErrors* / false) */ TODO)
	}
	getGlobalRecordSymbol := func() *Symbol {
		/* TODO(ExpressionStatement): deferredGlobalRecordSymbol ||= getGlobalTypeAliasSymbol("Record" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol; */
		return /* TODO(ConditionalExpression): deferredGlobalRecordSymbol === unknownSymbol ? undefined : deferredGlobalRecordSymbol */ TODO
	}
	createTypeFromGenericGlobalType := func(genericGlobalType GenericType, typeArguments []Type) ObjectType {
		return /* TODO(ConditionalExpression): genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, typeArguments) : emptyObjectType */ TODO
	}
	createTypedPropertyDescriptorType := func(propertyType Type) Type {
		return createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType() /* TODO(ArrayLiteralExpression): [propertyType] */, TODO)
	}
	createIterableType := func(iteratedType Type) Type {
		return createTypeFromGenericGlobalType(getGlobalIterableType(true) /* TODO(ArrayLiteralExpression): [iteratedType, voidType, undefinedType] */, TODO)
	}
	createArrayType := func(elementType Type, readonly bool) ObjectType {
		return createTypeFromGenericGlobalType( /* TODO(ConditionalExpression): readonly ? globalReadonlyArrayType : globalArrayType */ TODO /* TODO(ArrayLiteralExpression): [elementType] */, TODO)
	}
	getTupleElementFlags := func(node TypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Required | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Optional | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Rest | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Variadic */ TODO {
		switch node.kind {
		case SyntaxKindOptionalType:
			return ElementFlagsOptional
		case SyntaxKindRestType:
			return getRestTypeElementFlags(node)
		case SyntaxKindNamedTupleMember:
			return /* TODO(ConditionalExpression): (node as NamedTupleMember).questionToken ? ElementFlags.Optional :                     (node as NamedTupleMember).dotDotDotToken ? getRestTypeElementFlags(node as NamedTupleMember) :                     ElementFlags.Required */ TODO
		default:
			return ElementFlagsRequired
		}
	}
	getRestTypeElementFlags := func(node /* TODO(UnionType): RestTypeNode | NamedTupleMember */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Rest | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Variadic */ TODO {
		return /* TODO(ConditionalExpression): getArrayElementTypeNode(node.type) ? ElementFlags.Rest : ElementFlags.Variadic */ TODO
	}
	getArrayOrTupleTargetType := func(node /* TODO(UnionType): ArrayTypeNode | TupleTypeNode */ any) GenericType {
		readonly := isReadonlyTypeOperator(node.parent)
		elementType := getArrayElementTypeNode(node)
		if elementType {
			return /* TODO(ConditionalExpression): readonly ? globalReadonlyArrayType : globalArrayType */ TODO
		}
		elementFlags := map_((node).elements, getTupleElementFlags)
		return getTupleTargetType(elementFlags, readonly, map_((node).elements, memberIfLabeledElementDeclaration))
	}
	memberIfLabeledElementDeclaration := func(member Node) /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any {
		return /* TODO(ConditionalExpression): isNamedTupleMember(member) || isParameter(member) ? member : undefined */ TODO
	}
	isDeferredTypeReferenceNode := func(node /* TODO(UnionType): TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, hasDefaultTypeArguments bool) /* TODO inferred type boolean */ TODO {
		return !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && ( /* TODO(ConditionalExpression): node.kind === SyntaxKind.ArrayType ? mayResolveTypeAlias(node.elementType) :                         node.kind === SyntaxKind.TupleType ? some(node.elements, mayResolveTypeAlias) :                         hasDefaultTypeArguments || some(node.typeArguments, mayResolveTypeAlias) */ TODO)
	}
	isResolvedByTypeAlias := func(node Node) bool {
		parent := node.parent
		switch parent.kind {
		case SyntaxKindParenthesizedType:
			fallthrough // TODO: merge cases
		case SyntaxKindNamedTupleMember:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeReference:
			fallthrough // TODO: merge cases
		case SyntaxKindUnionType:
			fallthrough // TODO: merge cases
		case SyntaxKindIntersectionType:
			fallthrough // TODO: merge cases
		case SyntaxKindIndexedAccessType:
			fallthrough // TODO: merge cases
		case SyntaxKindConditionalType:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeOperator:
			fallthrough // TODO: merge cases
		case SyntaxKindArrayType:
			fallthrough // TODO: merge cases
		case SyntaxKindTupleType:
			return isResolvedByTypeAlias(parent)
		case SyntaxKindTypeAliasDeclaration:
			return true
		}
		return false
	}
	mayResolveTypeAlias := func(node Node) bool {
		switch node.kind {
		case SyntaxKindTypeReference:
			return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(node, SymbolFlagsType).flags & SymbolFlagsTypeAlias)
		case SyntaxKindTypeQuery:
			return true
		case SyntaxKindTypeOperator:
			return (node).operator != SyntaxKindUniqueKeyword && mayResolveTypeAlias((node).type_)
		case SyntaxKindParenthesizedType:
			fallthrough // TODO: merge cases
		case SyntaxKindOptionalType:
			fallthrough // TODO: merge cases
		case SyntaxKindNamedTupleMember:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocOptionalType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocNullableType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocNonNullableType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocTypeExpression:
			return mayResolveTypeAlias((node).type_)
		case SyntaxKindRestType:
			return (node).type_.kind != SyntaxKindArrayType || mayResolveTypeAlias(((node).type_).elementType)
		case SyntaxKindUnionType:
			fallthrough // TODO: merge cases
		case SyntaxKindIntersectionType:
			return some((node).types, mayResolveTypeAlias)
		case SyntaxKindIndexedAccessType:
			return mayResolveTypeAlias((node).objectType) || mayResolveTypeAlias((node).indexType)
		case SyntaxKindConditionalType:
			return mayResolveTypeAlias((node).checkType) || mayResolveTypeAlias((node).extendsType) || mayResolveTypeAlias((node).trueType) || mayResolveTypeAlias((node).falseType)
		}
		return false
	}
	getTypeFromArrayOrTupleTypeNode := func(node /* TODO(UnionType): ArrayTypeNode | TupleTypeNode */ any) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			target := getArrayOrTupleTargetType(node)
			if target == emptyGenericType {
				links.resolvedType = emptyObjectType
			} else if !(node.kind == SyntaxKindTupleType && some(node.elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember */ TODO) /* TODO inferred type boolean */ TODO {
				return !!(getTupleElementFlags(e) & ElementFlagsVariadic)
			})) && isDeferredTypeReferenceNode(node) {
				links.resolvedType = /* TODO(ConditionalExpression): node.kind === SyntaxKind.TupleType && node.elements.length === 0 ? target :                     createDeferredTypeReference(target, node, /*mapper* / undefined) */ TODO
			} else {
				elementTypes := /* TODO(ConditionalExpression): node.kind === SyntaxKind.ArrayType ? [getTypeFromTypeNode(node.elementType)] : map(node.elements, getTypeFromTypeNode) */ TODO
				links.resolvedType = createNormalizedTypeReference(target, elementTypes)
			}
		}
		return links.resolvedType
	}
	isReadonlyTypeOperator := func(node Node) /* TODO inferred type boolean */ TODO {
		return isTypeOperatorNode(node) && node.operator == SyntaxKindReadonlyKeyword
	}
	createTupleType := func(elementTypes []Type, elementFlags []ElementFlags, readonly /* TODO inferred type boolean */ TODO /*  = false */, namedMemberDeclarations [] /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any /*  = [] */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		tupleTarget := getTupleTargetType(elementFlags || map_(elementTypes, func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Required */ TODO {
			return ElementFlagsRequired
		}), readonly, namedMemberDeclarations)
		return /* TODO(ConditionalExpression): tupleTarget === emptyGenericType ? emptyObjectType :             elementTypes.length ? createNormalizedTypeReference(tupleTarget, elementTypes) :             tupleTarget */ TODO
	}
	getTupleTargetType := func(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations [] /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) GenericType {
		if elementFlags.length == 1 && /* TODO(ElementAccessExpression): elementFlags[0] */ TODO&ElementFlagsRest {
			return /* TODO(ConditionalExpression): readonly ? globalReadonlyArrayType : globalArrayType */ TODO
		}
		key := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): map(elementFlags, f => f & ElementFlags.Required ? "#" : f & ElementFlags.Optional ? "?" : f & ElementFlags.Rest ? "." : "*").join() +             (readonly ? "R" : "") +             (some(namedMemberDeclarations, node => !!node) ? "," + map(namedMemberDeclarations, node => node ? getNodeId(node) : "_").join(",") : "") */ TODO
		type_ := tupleTypes.get(key)
		if !type_ {
			tupleTypes.set(key /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations) */, TODO)
		}
		return type_
	}
	createTupleTargetType := func(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations [] /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) TupleType {
		arity := elementFlags.length
		minLength := countWhere(elementFlags, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ TODO) /* TODO inferred type boolean */ TODO {
			return !!(f & (ElementFlagsRequired | ElementFlagsVariadic))
		})
		var typeParameters /* TODO(ArrayType): TypeParameter[] */ any
		var properties []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		combinedFlags := 0
		if arity {
			typeParameters = /* TODO(NewExpression): new Array(arity) */ TODO
			/* TODO(ForStatement): for (let i = 0; i < arity; i++) {                 const typeParameter = typeParameters[i] = createTypeParameter();                 const flags = elementFlags[i];                 combinedFlags |= flags;                 if (!(combinedFlags & ElementFlags.Variable)) {                     const property = createSymbol(SymbolFlags.Property | (flags & ElementFlags.Optional ? SymbolFlags.Optional : 0), "" + i as __String, readonly ? CheckFlags.Readonly : 0);                     property.links.tupleLabelDeclaration = namedMemberDeclarations?.[i];                     property.links.type = typeParameter;                     properties.push(property);                 }             } */
		}
		fixedLength := properties.length
		lengthSymbol := createSymbol(SymbolFlagsProperty, "length" /* TODO(ConditionalExpression): readonly ? CheckFlags.Readonly : 0 */, TODO)
		if combinedFlags & ElementFlagsVariable {
			lengthSymbol.links.type_ = numberType
		} else {
			literalTypes := /* TODO(ArrayLiteralExpression): [] */ TODO
			/* TODO(ForStatement): for (let i = minLength; i <= arity; i++) literalTypes.push(getNumberLiteralType(i)); */
			lengthSymbol.links.type_ = getUnionType(literalTypes)
		}
		properties.push(lengthSymbol)
		type_ := createObjectType(ObjectFlagsTuple | ObjectFlagsReference)
		type_.typeParameters = typeParameters
		type_.outerTypeParameters = nil
		type_.localTypeParameters = typeParameters
		type_.instantiations = make(map[string]TypeReference)
		type_.instantiations.set(getTypeListId(type_.typeParameters), type_)
		type_.target = type_
		type_.resolvedTypeArguments = type_.typeParameters
		type_.thisType = createTypeParameter()
		type_.thisType.isThisType = true
		type_.thisType.constraint = type_
		type_.declaredProperties = properties
		type_.declaredCallSignatures = emptyArray
		type_.declaredConstructSignatures = emptyArray
		type_.declaredIndexInfos = emptyArray
		type_.elementFlags = elementFlags
		type_.minLength = minLength
		type_.fixedLength = fixedLength
		type_.hasRestElement = !!(combinedFlags & ElementFlagsVariable)
		type_.combinedFlags = combinedFlags
		type_.readonly = readonly
		type_.labeledElementDeclarations = namedMemberDeclarations
		return type_
	}
	createNormalizedTypeReference := func(target GenericType, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): target.objectFlags & ObjectFlags.Tuple ? createNormalizedTupleType(target as TupleType, typeArguments!) : createTypeReference(target, typeArguments) */ TODO
	}
	createNormalizedTupleType := func(target TupleType, elementTypes []Type) Type {
		if !(target.combinedFlags & ElementFlagsNonRequired) {
			return createTypeReference(target, elementTypes)
		}
		if target.combinedFlags & ElementFlagsVariadic {
			unionIndex := findIndex(elementTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type boolean */ TODO {
				return !!( /* TODO(ElementAccessExpression): target.elementFlags[i] */ TODO&ElementFlagsVariadic && t.flags&(TypeFlagsNever|TypeFlagsUnion))
			})
			if unionIndex >= 0 {
				return /* TODO(ConditionalExpression): checkCrossProductUnion(map(elementTypes, (t, i) => target.elementFlags[i] & ElementFlags.Variadic ? t : unknownType)) ?                     mapType(elementTypes[unionIndex], t => createNormalizedTupleType(target, replaceElement(elementTypes, unionIndex, t))) :                     errorType */ TODO
			}
		}
		var expandedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var expandedFlags []ElementFlags = /* TODO(ArrayLiteralExpression): [] */ TODO
		var expandedDeclarations [] /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
		lastRequiredIndex := -1
		firstRestIndex := -1
		lastOptionalOrRestIndex := -1
		/* TODO(ForStatement): for (let i = 0; i < elementTypes.length; i++) {             const type = elementTypes[i];             const flags = target.elementFlags[i];             if (flags & ElementFlags.Variadic) {                 if (type.flags & TypeFlags.Any) {                     addElement(type, ElementFlags.Rest, target.labeledElementDeclarations?.[i]);                 }                 else if (type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(type)) {                     // Generic variadic elements stay as they are.                     addElement(type, ElementFlags.Variadic, target.labeledElementDeclarations?.[i]);                 }                 else if (isTupleType(type)) {                     const elements = getElementTypes(type);                     if (elements.length + expandedTypes.length >= 10_000) {                         error(                             currentNode,                             isPartOfTypeNode(currentNode!)                                 ? Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent                                 : Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent,                         );                         return errorType;                     }                     // Spread variadic elements with tuple types into the resulting tuple.                     forEach(elements, (t, n) => addElement(t, type.target.elementFlags[n], type.target.labeledElementDeclarations?.[n]));                 }                 else {                     // Treat everything else as an array type and create a rest element.                     addElement(isArrayLikeType(type) && getIndexTypeOfType(type, numberType) || errorType, ElementFlags.Rest, target.labeledElementDeclarations?.[i]);                 }             }             else {                 // Copy other element kinds with no change.                 addElement(type, flags, target.labeledElementDeclarations?.[i]);             }         } */
		/* TODO(ForStatement): for (let i = 0; i < lastRequiredIndex; i++) {             if (expandedFlags[i] & ElementFlags.Optional) expandedFlags[i] = ElementFlags.Required;         } */
		if firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex {
			/* TODO(ElementAccessExpression): expandedTypes[firstRestIndex] */ TODO = getUnionType(sameMap(expandedTypes.slice(firstRestIndex /* TODO(PlusToken): + */ /* TODO(BinaryExpression): lastOptionalOrRestIndex + 1 */, TODO), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return /* TODO(ConditionalExpression): expandedFlags[firstRestIndex + i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t */ TODO
			}))
			expandedTypes.splice( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): firstRestIndex + 1 */ TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): lastOptionalOrRestIndex - firstRestIndex */, TODO)
			expandedFlags.splice( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): firstRestIndex + 1 */ TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): lastOptionalOrRestIndex - firstRestIndex */, TODO)
			expandedDeclarations.splice( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): firstRestIndex + 1 */ TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): lastOptionalOrRestIndex - firstRestIndex */, TODO)
		}
		tupleTarget := getTupleTargetType(expandedFlags, target.readonly, expandedDeclarations)
		return /* TODO(ConditionalExpression): tupleTarget === emptyGenericType ? emptyObjectType :             expandedFlags.length ? createTypeReference(tupleTarget, expandedTypes) :             tupleTarget */ TODO
		addElement := func(type_ Type, flags ElementFlags, declaration /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) {
			if flags & ElementFlagsRequired {
				lastRequiredIndex = expandedFlags.length
			}
			if flags&ElementFlagsRest && firstRestIndex < 0 {
				firstRestIndex = expandedFlags.length
			}
			if flags & (ElementFlagsOptional | ElementFlagsRest) {
				lastOptionalOrRestIndex = expandedFlags.length
			}
			expandedTypes.push( /* TODO(ConditionalExpression): flags & ElementFlags.Optional ? addOptionality(type, /*isProperty* / true) : type */ TODO)
			expandedFlags.push(flags)
			expandedDeclarations.push(declaration)
		}
	}
	sliceTupleType := func(type_ TupleTypeReference, index number, endSkipCount /* TODO inferred type number */ TODO /*  = 0 */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		target := type_.target
		endIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): getTypeReferenceArity(type) - endSkipCount */ TODO
		return /* TODO(ConditionalExpression): index > target.fixedLength ? getRestArrayTypeOfTupleType(type) || createTupleType(emptyArray) :             createTupleType(getTypeArguments(type).slice(index, endIndex), target.elementFlags.slice(index, endIndex), /*readonly* / false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex)) */ TODO
	}
	getKnownKeysOfTupleType := func(type_ TupleTypeReference) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getUnionType(append(arrayOf(type_.target.fixedLength, func(i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralType */ TODO {
			return getStringLiteralType( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + i */ TODO)
		}), getIndexType( /* TODO(ConditionalExpression): type.target.readonly ? globalReadonlyArrayType : globalArrayType */ TODO)))
	}
	getStartElementCount := func(type_ TupleType, flags ElementFlags) /* TODO inferred type number */ TODO {
		index := findIndex(type_.elementFlags, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ TODO) /* TODO inferred type boolean */ TODO {
			return !(f & flags)
		})
		return /* TODO(ConditionalExpression): index >= 0 ? index : type.elementFlags.length */ TODO
	}
	getEndElementCount := func(type_ TupleType, flags ElementFlags) /* TODO inferred type number */ TODO {
		return /* TODO(MinusToken): - */ /* TODO(BinaryExpression): type.elementFlags.length - findLastIndex(type.elementFlags, f => !(f & flags)) - 1 */ TODO
	}
	getTotalFixedElementCount := func(type_ TupleType) /* TODO inferred type number */ TODO {
		return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): type.fixedLength + getEndElementCount(type, ElementFlags.Fixed) */ TODO
	}
	getElementTypes := func(type_ TupleTypeReference) []Type {
		typeArguments := getTypeArguments(type_)
		arity := getTypeReferenceArity(type_)
		return /* TODO(ConditionalExpression): typeArguments.length === arity ? typeArguments : typeArguments.slice(0, arity) */ TODO
	}
	getTypeFromOptionalTypeNode := func(node OptionalTypeNode) Type {
		return addOptionality(getTypeFromTypeNode(node.type_), true)
	}
	getTypeId := func(type_ Type) TypeId {
		return type_.id
	}
	containsType := func(types []Type, type_ Type) bool {
		return binarySearch(types, type_, getTypeId, compareValues) >= 0
	}
	insertType := func(types []Type, type_ Type) bool {
		index := binarySearch(types, type_, getTypeId, compareValues)
		if index < 0 {
			types.splice(~index, 0, type_)
			return true
		}
		return false
	}
	addTypeToUnion := func(typeSet []Type, includes TypeFlags, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO {
		flags := type_.flags
		if !(flags & TypeFlagsNever) {
			includes |= flags & TypeFlagsIncludesMask
			if flags & TypeFlagsInstantiable {
				includes |= TypeFlagsIncludesInstantiable
			}
			if flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
				includes |= TypeFlagsIncludesConstrainedTypeVariable
			}
			if type_ == wildcardType {
				includes |= TypeFlagsIncludesWildcard
			}
			if isErrorType(type_) {
				includes |= TypeFlagsIncludesError
			}
			if !strictNullChecks && flags&TypeFlagsNullable {
				if !(getObjectFlags(type_) & ObjectFlagsContainsWideningType) {
					includes |= TypeFlagsIncludesNonWideningType
				}
			} else {
				len := typeSet.length
				index := /* TODO(ConditionalExpression): len && type.id > typeSet[len - 1].id ? ~len : binarySearch(typeSet, type, getTypeId, compareValues) */ TODO
				if index < 0 {
					typeSet.splice(~index, 0, type_)
				}
			}
		}
		return includes
	}
	addTypesToUnion := func(typeSet []Type, includes TypeFlags, types []Type) TypeFlags {
		var lastType *Type
		for _, type_ := range types {
			if type_ != lastType {
				includes = /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ?                     addTypesToUnion(typeSet, includes | (isNamedUnionType(type) ? TypeFlags.Union : 0), (type as UnionType).types) :                     addTypeToUnion(typeSet, includes, type) */ TODO
				lastType = type_
			}
		}
		return includes
	}
	removeSubtypes := func(types []Type, hasObjectTypes bool) /* TODO(ArrayType): Type[] */ any {
		if types.length < 2 {
			return types
		}
		id := getTypeListId(types)
		match := subtypeReductionCache.get(id)
		if match {
			return match
		}
		hasEmptyObject := hasObjectTypes && some(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return !!(t.flags & TypeFlagsObject) && !isGenericMappedType(t) && isEmptyResolvedType(resolveStructuredTypeMembers(t))
		})
		len := types.length
		i := len
		count := 0
		for i > 0 {
			i--
			source := /* TODO(ElementAccessExpression): types[i] */ TODO
			if hasEmptyObject || source.flags&TypeFlagsStructuredOrInstantiable {
				if source.flags&TypeFlagsTypeParameter && getBaseConstraintOrType(source).flags&TypeFlagsUnion {
					if isTypeRelatedTo(source, getUnionType(map_(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
						return /* TODO(ConditionalExpression): t === source ? neverType : t */ TODO
					})), strictSubtypeRelation) {
						orderedRemoveItemAt(types, i)
					}
					continue
				}
				keyProperty := /* TODO(ConditionalExpression): source.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive) ?                     find(getPropertiesOfType(source), p => isUnitType(getTypeOfSymbol(p))) :                     undefined */ TODO
				keyPropertyType := keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty))
				for _, target := range types {
					if source != target {
						if count == 100000 {
							estimatedCount := /* TODO(AsteriskToken): * */ /* TODO(BinaryExpression): (count / (len - i)) * len */ TODO
							if estimatedCount > 1000000 {
								tracing.instant(tracing.Phase.CheckTypes, "removeSubtypes_DepthLimit" /* TODO(ObjectLiteralExpression): { typeIds: types.map(t => t.id) } */, TODO)
								error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent)
								return nil
							}
						}
						count++
						if keyProperty && target.flags&(TypeFlagsObject|TypeFlagsIntersection|TypeFlagsInstantiableNonPrimitive) {
							t := getTypeOfPropertyOfType(target, keyProperty.escapedName)
							if t && isUnitType(t) && getRegularTypeOfLiteralType(t) != keyPropertyType {
								continue
							}
						}
						if isTypeRelatedTo(source, target, strictSubtypeRelation) && (!(getObjectFlags(getTargetType(source)) & ObjectFlagsClass) || !(getObjectFlags(getTargetType(target)) & ObjectFlagsClass) || isTypeDerivedFrom(source, target)) {
							orderedRemoveItemAt(types, i)
							break
						}
					}
				}
			}
		}
		subtypeReductionCache.set(id, types)
		return types
	}
	removeRedundantLiteralTypes := func(types []Type, includes TypeFlags, reduceVoidUndefined bool) {
		i := types.length
		for i > 0 {
			i--
			t := /* TODO(ElementAccessExpression): types[i] */ TODO
			flags := t.flags
			remove := flags&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && includes&TypeFlagsString || flags&TypeFlagsNumberLiteral && includes&TypeFlagsNumber || flags&TypeFlagsBigIntLiteral && includes&TypeFlagsBigInt || flags&TypeFlagsUniqueESSymbol && includes&TypeFlagsESSymbol || reduceVoidUndefined && flags&TypeFlagsUndefined && includes&TypeFlagsVoid || isFreshLiteralType(t) && containsType(types, (t).regularType)
			if remove {
				orderedRemoveItemAt(types, i)
			}
		}
	}
	removeStringLiteralsMatchedByTemplateLiterals := func(types []Type) {
		patterns := filter(types, isPatternLiteralType)
		templateLiterals := filter(patterns, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType | import("/home/jabaile/work/TypeScript/src/compiler/types").StringMappingType */ TODO) /* TODO inferred type boolean */ TODO {
			return !!(t.flags & TypeFlagsTemplateLiteral)
		})
		estimatedCount := /* TODO(AsteriskToken): * */ /* TODO(BinaryExpression): templateLiterals.length * countWhere(types, t => !!(t.flags & TypeFlags.StringLiteral)) */ TODO
		if estimatedCount > 0 {
			trie := createPrefixSuffixTrie()
			forEach(templateLiterals, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType */ TODO) {
				prefix := /* TODO(ElementAccessExpression): t.texts[0] */ TODO
				suffix := /* TODO(ElementAccessExpression): t.texts[t.texts.length - 1] */ TODO
				trie.set(prefix, suffix, func(templates /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType[] | undefined */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType[] */ TODO {
					return append(templates, t)
				})
			})
			i := types.length
			/* TODO(LabeledStatement): outer: while (i > 0) {                 i--;                 const t = types[i];                 if (!(t.flags & TypeFlags.StringLiteral)) continue;                 const text = (t as StringLiteralType).value;                  for (const templates of trie.iterateAllMatches(text)) {                     if (some(templates, template => isTypeMatchedByTemplateLiteralOrStringMapping(t, template))) {                         orderedRemoveItemAt(types, i);                         continue outer;                     }                 }             } */
			patterns = filter(patterns, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType | import("/home/jabaile/work/TypeScript/src/compiler/types").StringMappingType */ TODO) /* TODO inferred type boolean */ TODO {
				return !!(t.flags & TypeFlagsStringMapping)
			})
		}
		if patterns.length {
			i := types.length
			for i > 0 {
				i--
				t := /* TODO(ElementAccessExpression): types[i] */ TODO
				if !(t.flags & TypeFlagsStringLiteral) {
					continue
				}
				if some(patterns, func(template /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType | import("/home/jabaile/work/TypeScript/src/compiler/types").StringMappingType */ TODO) /* TODO inferred type boolean */ TODO {
					return isTypeMatchedByTemplateLiteralOrStringMapping(t, template)
				}) {
					orderedRemoveItemAt(types, i)
				}
			}
		}
	}
	isTypeMatchedByTemplateLiteralOrStringMapping := func(type_ Type, template /* TODO(UnionType): TemplateLiteralType | StringMappingType */ any) /* TODO inferred type boolean */ TODO {
		return /* TODO(ConditionalExpression): template.flags & TypeFlags.TemplateLiteral ?             isTypeMatchedByTemplateLiteralType(type, template as TemplateLiteralType) :             isMemberOfStringMapping(type, template) */ TODO
	}
	removeConstrainedTypeVariables := func(types []Type) {
		var typeVariables []TypeVariable = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, type_ := range types {
			if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
				index := /* TODO(ConditionalExpression): (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
				pushIfUnique(typeVariables /* TODO(ElementAccessExpression): (type as IntersectionType).types[index] */, TODO)
			}
		}
		for _, typeVariable := range typeVariables {
			var primitives []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, type_ := range types {
				if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
					index := /* TODO(ConditionalExpression): (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
					if /* TODO(ElementAccessExpression): (type as IntersectionType).types[index] */ TODO == typeVariable {
						insertType(primitives /* TODO(ElementAccessExpression): (type as IntersectionType).types[1 - index] */, TODO)
					}
				}
			}
			constraint := getBaseConstraintOfType(typeVariable)
			if everyType(constraint, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return containsType(primitives, t)
			}) {
				i := types.length
				for i > 0 {
					i--
					type_ := /* TODO(ElementAccessExpression): types[i] */ TODO
					if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
						index := /* TODO(ConditionalExpression): (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
						if /* TODO(ElementAccessExpression): (type as IntersectionType).types[index] */ TODO == typeVariable && containsType(primitives /* TODO(ElementAccessExpression): (type as IntersectionType).types[1 - index] */, TODO) {
							orderedRemoveItemAt(types, i)
						}
					}
				}
				insertType(types, typeVariable)
			}
		}
	}
	isNamedUnionType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(type_.flags&TypeFlagsUnion && (type_.aliasSymbol || (type_).origin))
	}
	addNamedUnions := func(namedUnions []Type, types []Type) {
		for _, t := range types {
			if t.flags & TypeFlagsUnion {
				origin := (t).origin
				if t.aliasSymbol || origin && !(origin.flags&TypeFlagsUnion) {
					pushIfUnique(namedUnions, t)
				} else if origin && origin.flags&TypeFlagsUnion {
					addNamedUnions(namedUnions, (origin).types)
				}
			}
		}
	}
	createOriginUnionOrIntersectionType := func(flags TypeFlags, types []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").UnionOrIntersectionType */ TODO {
		result := createOriginType(flags)
		result.types = types
		return result
	}
	getUnionType := func(types []Type, unionReduction UnionReduction /*  = UnionReduction.Literal */, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
		if types.length == 0 {
			return neverType
		}
		if types.length == 1 {
			return /* TODO(ElementAccessExpression): types[0] */ TODO
		}
		if types.length == 2 && !origin && ( /* TODO(ElementAccessExpression): types[0] */ TODO.flags&TypeFlagsUnion || /* TODO(ElementAccessExpression): types[1] */ TODO.flags&TypeFlagsUnion) {
			infix := /* TODO(ConditionalExpression): unionReduction === UnionReduction.None ? "N" : unionReduction === UnionReduction.Subtype ? "S" : "L" */ TODO
			index := /* TODO(ConditionalExpression): types[0].id < types[1].id ? 0 : 1 */ TODO
			id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): types[index].id + infix + types[1 - index].id + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
			type_ := unionOfUnionTypes.get(id)
			if !type_ {
				type_ = getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, nil)
				unionOfUnionTypes.set(id, type_)
			}
			return type_
		}
		return getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, origin)
	}
	getUnionTypeWorker := func(types []Type, unionReduction UnionReduction, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any, origin *Type) Type {
		var typeSet /* TODO(ArrayType): Type[] */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
		includes := addTypesToUnion(typeSet, 0, types)
		if unionReduction != UnionReductionNone {
			if includes & TypeFlagsAnyOrUnknown {
				return /* TODO(ConditionalExpression): includes & TypeFlags.Any ?                     includes & TypeFlags.IncludesWildcard ? wildcardType :                         includes & TypeFlags.IncludesError ? errorType : anyType :                     unknownType */ TODO
			}
			if includes & TypeFlagsUndefined {
				if typeSet.length >= 2 && /* TODO(ElementAccessExpression): typeSet[0] */ TODO == undefinedType && /* TODO(ElementAccessExpression): typeSet[1] */ TODO == missingType {
					orderedRemoveItemAt(typeSet, 1)
				}
			}
			if includes&(TypeFlagsEnum|TypeFlagsLiteral|TypeFlagsUniqueESSymbol|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || includes&TypeFlagsVoid && includes&TypeFlagsUndefined {
				removeRedundantLiteralTypes(typeSet, includes, !!(unionReduction & UnionReductionSubtype))
			}
			if includes&TypeFlagsStringLiteral && includes&(TypeFlagsTemplateLiteral|TypeFlagsStringMapping) {
				removeStringLiteralsMatchedByTemplateLiterals(typeSet)
			}
			if includes & TypeFlagsIncludesConstrainedTypeVariable {
				removeConstrainedTypeVariables(typeSet)
			}
			if unionReduction == UnionReductionSubtype {
				typeSet = removeSubtypes(typeSet, !!(includes & TypeFlagsObject))
				if !typeSet {
					return errorType
				}
			}
			if typeSet.length == 0 {
				return /* TODO(ConditionalExpression): includes & TypeFlags.Null ? includes & TypeFlags.IncludesNonWideningType ? nullType : nullWideningType :                     includes & TypeFlags.Undefined ? includes & TypeFlags.IncludesNonWideningType ? undefinedType : undefinedWideningType :                     neverType */ TODO
			}
		}
		if !origin && includes&TypeFlagsUnion {
			var namedUnions []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			addNamedUnions(namedUnions, types)
			var reducedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, t := range typeSet {
				if !some(namedUnions, func(union /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return containsType((union).types, t)
				}) {
					reducedTypes.push(t)
				}
			}
			if !aliasSymbol && namedUnions.length == 1 && reducedTypes.length == 0 {
				return /* TODO(ElementAccessExpression): namedUnions[0] */ TODO
			}
			namedTypesCount := reduceLeft(namedUnions, func(sum /* TODO inferred type number */ TODO, union /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type number */ TODO {
				return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): sum + (union as UnionType).types.length */ TODO
			}, 0)
			if /* TODO(PlusToken): + */ /* TODO(BinaryExpression): namedTypesCount + reducedTypes.length */ TODO == typeSet.length {
				for _, t := range namedUnions {
					insertType(reducedTypes, t)
				}
				origin = createOriginUnionOrIntersectionType(TypeFlagsUnion, reducedTypes)
			}
		}
		objectFlags := ( /* TODO(ConditionalExpression): includes & TypeFlags.NotPrimitiveUnion ? 0 : ObjectFlags.PrimitiveUnion */ TODO) | ( /* TODO(ConditionalExpression): includes & TypeFlags.Intersection ? ObjectFlags.ContainsIntersections : 0 */ TODO)
		return getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin)
	}
	getUnionOrIntersectionTypePredicate := func(signatures []Signature, kind *TypeFlags) *TypePredicate {
		var last *TypePredicate
		var types []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, sig := range signatures {
			pred := getTypePredicateOfSignature(sig)
			if pred {
				if pred.kind != TypePredicateKindThis && pred.kind != TypePredicateKindIdentifier || last && !typePredicateKindsMatch(last, pred) {
					return nil
				}
				last = pred
				types.push(pred.type_)
			} else {
				returnType := /* TODO(ConditionalExpression): kind !== TypeFlags.Intersection ? getReturnTypeOfSignature(sig) : undefined */ TODO
				if returnType != falseType && returnType != regularFalseType {
					return nil
				}
			}
		}
		if !last {
			return nil
		}
		compositeType := getUnionOrIntersectionType(types, kind)
		return createTypePredicate(last.kind, last.parameterName, last.parameterIndex, compositeType)
	}
	typePredicateKindsMatch := func(a TypePredicate, b TypePredicate) bool {
		return a.kind == b.kind && a.parameterIndex == b.parameterIndex
	}
	getUnionTypeFromSortedList := func(types []Type, precomputedObjectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
		if types.length == 0 {
			return neverType
		}
		if types.length == 1 {
			return /* TODO(ElementAccessExpression): types[0] */ TODO
		}
		typeKey := /* TODO(ConditionalExpression): !origin ? getTypeListId(types) :             origin.flags & TypeFlags.Union ? `|${getTypeListId((origin as UnionType).types)}` :             origin.flags & TypeFlags.Intersection ? `&${getTypeListId((origin as IntersectionType).types)}` :             `#${(origin as IndexType).type.id}|${getTypeListId(types)}` */ TODO
		id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): typeKey + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
		type_ := unionTypes.get(id)
		if !type_ {
			type_ = createType(TypeFlagsUnion)
			type_.objectFlags = precomputedObjectFlags | getPropagatingFlagsOfTypes(types, TypeFlagsNullable)
			type_.types = types
			type_.origin = origin
			type_.aliasSymbol = aliasSymbol
			type_.aliasTypeArguments = aliasTypeArguments
			if types.length == 2 && /* TODO(ElementAccessExpression): types[0] */ TODO.flags&TypeFlagsBooleanLiteral && /* TODO(ElementAccessExpression): types[1] */ TODO.flags&TypeFlagsBooleanLiteral {
				type_.flags |= TypeFlagsBoolean
				(type_).intrinsicName = "boolean"
			}
			unionTypes.set(id, type_)
		}
		return type_
	}
	getTypeFromUnionTypeNode := func(node UnionTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			links.resolvedType = getUnionType(map_(node.types, getTypeFromTypeNode), UnionReductionLiteral, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol))
		}
		return links.resolvedType
	}
	addTypeToIntersection := func(typeSet Map[string, Type], includes TypeFlags, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO {
		flags := type_.flags
		if flags & TypeFlagsIntersection {
			return addTypesToIntersection(typeSet, includes, (type_).types)
		}
		if isEmptyAnonymousObjectType(type_) {
			if !(includes & TypeFlagsIncludesEmptyObject) {
				includes |= TypeFlagsIncludesEmptyObject
				typeSet.set(type_.id.toString(), type_)
			}
		} else {
			if flags & TypeFlagsAnyOrUnknown {
				if type_ == wildcardType {
					includes |= TypeFlagsIncludesWildcard
				}
				if isErrorType(type_) {
					includes |= TypeFlagsIncludesError
				}
			} else if strictNullChecks || !(flags & TypeFlagsNullable) {
				if type_ == missingType {
					includes |= TypeFlagsIncludesMissingType
					type_ = undefinedType
				}
				if !typeSet.has(type_.id.toString()) {
					if type_.flags&TypeFlagsUnit && includes&TypeFlagsUnit {
						includes |= TypeFlagsNonPrimitive
					}
					typeSet.set(type_.id.toString(), type_)
				}
			}
			includes |= flags & TypeFlagsIncludesMask
		}
		return includes
	}
	addTypesToIntersection := func(typeSet Map[string, Type], includes TypeFlags, types []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO {
		for _, type_ := range types {
			includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type_))
		}
		return includes
	}
	removeRedundantSupertypes := func(types []Type, includes TypeFlags) {
		i := types.length
		for i > 0 {
			i--
			t := /* TODO(ElementAccessExpression): types[i] */ TODO
			remove := t.flags&TypeFlagsString && includes&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || t.flags&TypeFlagsNumber && includes&TypeFlagsNumberLiteral || t.flags&TypeFlagsBigInt && includes&TypeFlagsBigIntLiteral || t.flags&TypeFlagsESSymbol && includes&TypeFlagsUniqueESSymbol || t.flags&TypeFlagsVoid && includes&TypeFlagsUndefined || isEmptyAnonymousObjectType(t) && includes&TypeFlagsDefinitelyNonNullable
			if remove {
				orderedRemoveItemAt(types, i)
			}
		}
	}
	eachUnionContains := func(unionTypes []UnionType, type_ Type) /* TODO inferred type boolean */ TODO {
		for _, u := range unionTypes {
			if !containsType(u.types, type_) {
				if type_ == missingType {
					return containsType(u.types, undefinedType)
				}
				if type_ == undefinedType {
					return containsType(u.types, missingType)
				}
				primitive := /* TODO(ConditionalExpression): type.flags & TypeFlags.StringLiteral ? stringType :                     type.flags & (TypeFlags.Enum | TypeFlags.NumberLiteral) ? numberType :                     type.flags & TypeFlags.BigIntLiteral ? bigintType :                     type.flags & TypeFlags.UniqueESSymbol ? esSymbolType :                     undefined */ TODO
				if !primitive || !containsType(u.types, primitive) {
					return false
				}
			}
		}
		return true
	}
	extractRedundantTemplateLiterals := func(types []Type) bool {
		i := types.length
		literals := filter(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return !!(t.flags & TypeFlagsStringLiteral)
		})
		for i > 0 {
			i--
			t := /* TODO(ElementAccessExpression): types[i] */ TODO
			if !(t.flags & (TypeFlagsTemplateLiteral | TypeFlagsStringMapping)) {
				continue
			}
			for _, t2 := range literals {
				if isTypeSubtypeOf(t2, t) {
					orderedRemoveItemAt(types, i)
					break
				} else if isPatternLiteralType(t) {
					return true
				}
			}
		}
		return false
	}
	removeFromEach := func(types []Type, flag TypeFlags) {
		/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             types[i] = filterType(types[i], t => !(t.flags & flag));         } */
	}
	intersectUnionsOfPrimitiveTypes := func(types []Type) /* TODO inferred type boolean */ TODO {
		var unionTypes /* TODO(ArrayType): UnionType[] */ any
		index := findIndex(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return !!(getObjectFlags(t) & ObjectFlagsPrimitiveUnion)
		})
		if index < 0 {
			return false
		}
		i := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): index + 1 */ TODO
		for i < types.length {
			t := /* TODO(ElementAccessExpression): types[i] */ TODO
			if getObjectFlags(t) & ObjectFlagsPrimitiveUnion {
				(unionTypes || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): unionTypes = [types[index] as UnionType] */ TODO)).push(t)
				orderedRemoveItemAt(types, i)
			} else {
				i++
			}
		}
		if !unionTypes {
			return false
		}
		var checked []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var result []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, u := range unionTypes {
			for _, t := range u.types {
				if insertType(checked, t) {
					if eachUnionContains(unionTypes, t) {
						if t == undefinedType && result.length && /* TODO(ElementAccessExpression): result[0] */ TODO == missingType {
							continue
						}
						if t == missingType && result.length && /* TODO(ElementAccessExpression): result[0] */ TODO == undefinedType {
							/* TODO(ElementAccessExpression): result[0] */ TODO = missingType
							continue
						}
						insertType(result, t)
					}
				}
			}
		}
		/* TODO(ElementAccessExpression): types[index] */ TODO = getUnionTypeFromSortedList(result, ObjectFlagsPrimitiveUnion)
		return true
	}
	createIntersectionType := func(types []Type, objectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntersectionType */ TODO {
		result := createType(TypeFlagsIntersection)
		result.objectFlags = objectFlags | getPropagatingFlagsOfTypes(types, TypeFlagsNullable)
		result.types = types
		result.aliasSymbol = aliasSymbol
		result.aliasTypeArguments = aliasTypeArguments
		return result
	}
	getIntersectionType := func(types []Type, flags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntersectionFlags */ TODO /*  = IntersectionFlags.None */, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		typeMembershipMap := make(map[string]Type)
		includes := addTypesToIntersection(typeMembershipMap, 0, types)
		var typeSet []Type = arrayFrom(typeMembershipMap.values())
		objectFlags := ObjectFlagsNone
		if includes & TypeFlagsNever {
			return /* TODO(ConditionalExpression): contains(typeSet, silentNeverType) ? silentNeverType : neverType */ TODO
		}
		if strictNullChecks && includes&TypeFlagsNullable && includes&(TypeFlagsObject|TypeFlagsNonPrimitive|TypeFlagsIncludesEmptyObject) || includes&TypeFlagsNonPrimitive && includes&(TypeFlagsDisjointDomains&~TypeFlagsNonPrimitive) || includes&TypeFlagsStringLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsStringLike) || includes&TypeFlagsNumberLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsNumberLike) || includes&TypeFlagsBigIntLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsBigIntLike) || includes&TypeFlagsESSymbolLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsESSymbolLike) || includes&TypeFlagsVoidLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsVoidLike) {
			return neverType
		}
		if includes&(TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && includes&TypeFlagsStringLiteral && extractRedundantTemplateLiterals(typeSet) {
			return neverType
		}
		if includes & TypeFlagsAny {
			return /* TODO(ConditionalExpression): includes & TypeFlags.IncludesWildcard ? wildcardType : includes & TypeFlags.IncludesError ? errorType : anyType */ TODO
		}
		if !strictNullChecks && includes&TypeFlagsNullable {
			return /* TODO(ConditionalExpression): includes & TypeFlags.IncludesEmptyObject ? neverType : includes & TypeFlags.Undefined ? undefinedType : nullType */ TODO
		}
		if includes&TypeFlagsString && includes&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || includes&TypeFlagsNumber && includes&TypeFlagsNumberLiteral || includes&TypeFlagsBigInt && includes&TypeFlagsBigIntLiteral || includes&TypeFlagsESSymbol && includes&TypeFlagsUniqueESSymbol || includes&TypeFlagsVoid && includes&TypeFlagsUndefined || includes&TypeFlagsIncludesEmptyObject && includes&TypeFlagsDefinitelyNonNullable {
			if !(flags & IntersectionFlagsNoSupertypeReduction) {
				removeRedundantSupertypes(typeSet, includes)
			}
		}
		if includes & TypeFlagsIncludesMissingType {
			/* TODO(ElementAccessExpression): typeSet[typeSet.indexOf(undefinedType)] */ TODO = missingType
		}
		if typeSet.length == 0 {
			return unknownType
		}
		if typeSet.length == 1 {
			return /* TODO(ElementAccessExpression): typeSet[0] */ TODO
		}
		if typeSet.length == 2 && !(flags & IntersectionFlagsNoConstraintReduction) {
			typeVarIndex := /* TODO(ConditionalExpression): typeSet[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
			typeVariable := /* TODO(ElementAccessExpression): typeSet[typeVarIndex] */ TODO
			primitiveType := /* TODO(ElementAccessExpression): typeSet[1 - typeVarIndex] */ TODO
			if typeVariable.flags&TypeFlagsTypeVariable && (primitiveType.flags&(TypeFlagsPrimitive|TypeFlagsNonPrimitive) && !isGenericStringLikeType(primitiveType) || includes&TypeFlagsIncludesEmptyObject) {
				constraint := getBaseConstraintOfType(typeVariable)
				if constraint && everyType(constraint, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !!(t.flags & (TypeFlagsPrimitive | TypeFlagsNonPrimitive)) || isEmptyAnonymousObjectType(t)
				}) {
					if isTypeStrictSubtypeOf(constraint, primitiveType) {
						return typeVariable
					}
					if !(constraint.flags&TypeFlagsUnion && someType(constraint, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
						return isTypeStrictSubtypeOf(c, primitiveType)
					})) {
						if !isTypeStrictSubtypeOf(primitiveType, constraint) {
							return neverType
						}
					}
					objectFlags = ObjectFlagsIsConstrainedTypeVariable
				}
			}
		}
		id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): getTypeListId(typeSet) + (flags & IntersectionFlags.NoConstraintReduction ? "*" : getAliasId(aliasSymbol, aliasTypeArguments)) */ TODO
		result := intersectionTypes.get(id)
		if !result {
			if includes & TypeFlagsUnion {
				if intersectUnionsOfPrimitiveTypes(typeSet) {
					result = getIntersectionType(typeSet, flags, aliasSymbol, aliasTypeArguments)
				} else if every(typeSet, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !!(t.flags&TypeFlagsUnion && /* TODO(ElementAccessExpression): (t as UnionType).types[0] */ TODO.flags&TypeFlagsUndefined)
				}) {
					containedUndefinedType := /* TODO(ConditionalExpression): some(typeSet, containsMissingType) ? missingType : undefinedType */ TODO
					removeFromEach(typeSet, TypeFlagsUndefined)
					result = getUnionType( /* TODO(ArrayLiteralExpression): [getIntersectionType(typeSet, flags), containedUndefinedType] */ TODO, UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
				} else if every(typeSet, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !!(t.flags&TypeFlagsUnion && ( /* TODO(ElementAccessExpression): (t as UnionType).types[0] */ TODO.flags&TypeFlagsNull || /* TODO(ElementAccessExpression): (t as UnionType).types[1] */ TODO.flags&TypeFlagsNull))
				}) {
					removeFromEach(typeSet, TypeFlagsNull)
					result = getUnionType( /* TODO(ArrayLiteralExpression): [getIntersectionType(typeSet, flags), nullType] */ TODO, UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
				} else if typeSet.length >= 3 && types.length > 2 {
					middle := Math.floor( /* TODO(SlashToken): / */ /* TODO(BinaryExpression): typeSet.length / 2 */ TODO)
					result = getIntersectionType( /* TODO(ArrayLiteralExpression): [getIntersectionType(typeSet.slice(0, middle), flags), getIntersectionType(typeSet.slice(middle), flags)] */ TODO, flags, aliasSymbol, aliasTypeArguments)
				} else {
					if !checkCrossProductUnion(typeSet) {
						return errorType
					}
					constituents := getCrossProductIntersections(typeSet, flags)
					origin := /* TODO(ConditionalExpression): some(constituents, t => !!(t.flags & TypeFlags.Intersection)) && getConstituentCountOfTypes(constituents) > getConstituentCountOfTypes(typeSet) ? createOriginUnionOrIntersectionType(TypeFlags.Intersection, typeSet) : undefined */ TODO
					result = getUnionType(constituents, UnionReductionLiteral, aliasSymbol, aliasTypeArguments, origin)
				}
			} else {
				result = createIntersectionType(typeSet, objectFlags, aliasSymbol, aliasTypeArguments)
			}
			intersectionTypes.set(id, result)
		}
		return result
	}
	getCrossProductUnionSize := func(types []Type) /* TODO inferred type number */ TODO {
		return reduceLeft(types, func(n /* TODO inferred type number */ TODO, t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type number */ TODO {
			return /* TODO(ConditionalExpression): t.flags & TypeFlags.Union ? n * (t as UnionType).types.length : t.flags & TypeFlags.Never ? 0 : n */ TODO
		}, 1)
	}
	checkCrossProductUnion := func(types []Type) /* TODO inferred type boolean */ TODO {
		size := getCrossProductUnionSize(types)
		if size >= 100000 {
			tracing.instant(tracing.Phase.CheckTypes, "checkCrossProductUnion_DepthLimit" /* TODO(ObjectLiteralExpression): { typeIds: types.map(t => t.id), size } */, TODO)
			error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent)
			return false
		}
		return true
	}
	getCrossProductIntersections := func(types []Type, flags IntersectionFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
		count := getCrossProductUnionSize(types)
		var intersections []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < count; i++) {             const constituents = types.slice();             let n = i;             for (let j = types.length - 1; j >= 0; j--) {                 if (types[j].flags & TypeFlags.Union) {                     const sourceTypes = (types[j] as UnionType).types;                     const length = sourceTypes.length;                     constituents[j] = sourceTypes[n % length];                     n = Math.floor(n / length);                 }             }             const t = getIntersectionType(constituents, flags);             if (!(t.flags & TypeFlags.Never)) intersections.push(t);         } */
		return intersections
	}
	getConstituentCount := func(type_ Type) number {
		return /* TODO(ConditionalExpression): !(type.flags & TypeFlags.UnionOrIntersection) || type.aliasSymbol ? 1 :             type.flags & TypeFlags.Union && (type as UnionType).origin ? getConstituentCount((type as UnionType).origin!) :             getConstituentCountOfTypes((type as UnionOrIntersectionType).types) */ TODO
	}
	getConstituentCountOfTypes := func(types []Type) number {
		return reduceLeft(types, func(n /* TODO inferred type number */ TODO, t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type number */ TODO {
			return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): n + getConstituentCount(t) */ TODO
		}, 0)
	}
	getTypeFromIntersectionTypeNode := func(node IntersectionTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			types := map_(node.types, getTypeFromTypeNode)
			emptyIndex := /* TODO(ConditionalExpression): types.length === 2 ? types.indexOf(emptyTypeLiteralType) : -1 */ TODO
			t := /* TODO(ConditionalExpression): emptyIndex >= 0 ? types[1 - emptyIndex] : unknownType */ TODO
			noSupertypeReduction := !!(t.flags&(TypeFlagsString|TypeFlagsNumber|TypeFlagsBigInt) || t.flags&TypeFlagsTemplateLiteral && isPatternLiteralType(t))
			links.resolvedType = getIntersectionType(types /* TODO(ConditionalExpression): noSupertypeReduction ? IntersectionFlags.NoSupertypeReduction : 0 */, TODO, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol))
		}
		return links.resolvedType
	}
	createIndexType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ TODO {
		result := createType(TypeFlagsIndex)
		result.type_ = type_
		result.indexFlags = indexFlags
		return result
	}
	createOriginIndexType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ TODO {
		result := createOriginType(TypeFlagsIndex)
		result.type_ = type_
		return result
	}
	getIndexTypeForGenericType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ TODO {
		return /* TODO(ConditionalExpression): indexFlags & IndexFlags.StringsOnly ?             type.resolvedStringIndexType || (type.resolvedStringIndexType = createIndexType(type, IndexFlags.StringsOnly)) :             type.resolvedIndexType || (type.resolvedIndexType = createIndexType(type, IndexFlags.None)) */ TODO
	}
	getIndexTypeForMappedType := func(type_ MappedType, indexFlags IndexFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		typeParameter := getTypeParameterFromMappedType(type_)
		constraintType := getConstraintTypeFromMappedType(type_)
		nameType := getNameTypeFromMappedType(type_.target || type_)
		if !nameType && !(indexFlags & IndexFlagsNoIndexSignatures) {
			return constraintType
		}
		var keyTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		if isGenericIndexType(constraintType) {
			if isMappedTypeWithKeyofConstraintDeclaration(type_) {
				return getIndexTypeForGenericType(type_, indexFlags)
			}
			forEachType(constraintType, addMemberForKeyType)
		} else if isMappedTypeWithKeyofConstraintDeclaration(type_) {
			modifiersType := getApparentType(getModifiersTypeFromMappedType(type_))
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, TypeFlagsStringOrNumberLiteralOrUnique, !!(indexFlags & IndexFlagsStringsOnly), addMemberForKeyType)
		} else {
			forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType)
		}
		result := /* TODO(ConditionalExpression): indexFlags & IndexFlags.NoIndexSignatures ? filterType(getUnionType(keyTypes), t => !(t.flags & (TypeFlags.Any | TypeFlags.String))) : getUnionType(keyTypes) */ TODO
		if result.flags&TypeFlagsUnion && constraintType.flags&TypeFlagsUnion && getTypeListId((result).types) == getTypeListId((constraintType).types) {
			return constraintType
		}
		return result
		addMemberForKeyType := func(keyType Type) {
			propNameType := /* TODO(ConditionalExpression): nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType */ TODO
			keyTypes.push( /* TODO(ConditionalExpression): propNameType === stringType ? stringOrNumberType : propNameType */ TODO)
		}
	}
	hasDistributiveNameType := func(mappedType MappedType) /* TODO inferred type boolean */ TODO {
		typeVariable := getTypeParameterFromMappedType(mappedType)
		return isDistributive(getNameTypeFromMappedType(mappedType) || typeVariable)
		isDistributive := func(type_ Type) bool {
			return /* TODO(ConditionalExpression): type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Primitive | TypeFlags.Never | TypeFlags.TypeParameter | TypeFlags.Object | TypeFlags.NonPrimitive) ? true :                 type.flags & TypeFlags.Conditional ? (type as ConditionalType).root.isDistributive && (type as ConditionalType).checkType === typeVariable :                 type.flags & (TypeFlags.UnionOrIntersection | TypeFlags.TemplateLiteral) ? every((type as UnionOrIntersectionType | TemplateLiteralType).types, isDistributive) :                 type.flags & TypeFlags.IndexedAccess ? isDistributive((type as IndexedAccessType).objectType) && isDistributive((type as IndexedAccessType).indexType) :                 type.flags & TypeFlags.Substitution ? isDistributive((type as SubstitutionType).baseType) && isDistributive((type as SubstitutionType).constraint) :                 type.flags & TypeFlags.StringMapping ? isDistributive((type as StringMappingType).type) :                 false */ TODO
		}
	}
	getLiteralTypeFromPropertyName := func(name /* TODO(UnionType): PropertyName | JsxAttributeName */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isPrivateIdentifier(name) {
			return neverType
		}
		if isNumericLiteral(name) {
			return getRegularTypeOfLiteralType(checkExpression(name))
		}
		if isComputedPropertyName(name) {
			return getRegularTypeOfLiteralType(checkComputedPropertyName(name))
		}
		propertyName := getPropertyNameForPropertyNameNode(name)
		if propertyName != nil {
			return getStringLiteralType(unescapeLeadingUnderscores(propertyName))
		}
		if isExpression(name) {
			return getRegularTypeOfLiteralType(checkExpression(name))
		}
		return neverType
	}
	getLiteralTypeFromProperty := func(prop Symbol, include TypeFlags, includeNonPublic bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if includeNonPublic || !(getDeclarationModifierFlagsFromSymbol(prop) & ModifierFlagsNonPublicAccessibilityModifier) {
			type_ := getSymbolLinks(getLateBoundSymbol(prop)).nameType
			if !type_ {
				name := getNameOfDeclaration(prop.valueDeclaration)
				type_ = /* TODO(ConditionalExpression): prop.escapedName === InternalSymbolName.Default ? getStringLiteralType("default") :                     name && getLiteralTypeFromPropertyName(name) || (!isKnownSymbol(prop) ? getStringLiteralType(symbolName(prop)) : undefined) */ TODO
			}
			if type_ && type_.flags&include {
				return type_
			}
		}
		return neverType
	}
	isKeyTypeIncluded := func(keyType Type, include TypeFlags) bool {
		return !!(keyType.flags&include || keyType.flags&TypeFlagsIntersection && some((keyType).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return isKeyTypeIncluded(t, include)
		}))
	}
	getLiteralTypeFromProperties := func(type_ Type, include TypeFlags, includeOrigin bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		origin := /* TODO(ConditionalExpression): includeOrigin && (getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference) || type.aliasSymbol) ? createOriginIndexType(type) : undefined */ TODO
		propertyTypes := map_(getPropertiesOfType(type_), func(prop /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return getLiteralTypeFromProperty(prop, include)
		})
		indexKeyTypes := map_(getIndexInfosOfType(type_), func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return /* TODO(ConditionalExpression): info !== enumNumberIndexInfo && isKeyTypeIncluded(info.keyType, include) ?                 info.keyType === stringType && include & TypeFlags.Number ? stringOrNumberType : info.keyType : neverType */ TODO
		})
		return getUnionType(concatenate(propertyTypes, indexKeyTypes), UnionReductionLiteral, nil, nil, origin)
	}
	shouldDeferIndexType := func(type_ Type, indexFlags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexFlags */ TODO /*  = IndexFlags.None */) /* TODO inferred type boolean */ TODO {
		return !!(type_.flags&TypeFlagsInstantiableNonPrimitive || isGenericTupleType(type_) || isGenericMappedType(type_) && (!hasDistributiveNameType(type_) || getMappedTypeNameTypeKind(type_) == MappedTypeNameTypeKindRemapping) || type_.flags&TypeFlagsUnion && !(indexFlags&IndexFlagsNoReducibleCheck) && isGenericReducibleType(type_) || type_.flags&TypeFlagsIntersection && maybeTypeOfKind(type_, TypeFlagsInstantiable) && some((type_).types, isEmptyAnonymousObjectType))
	}
	getIndexType := func(type_ Type, indexFlags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexFlags */ TODO /*  = IndexFlags.None */) Type {
		type_ = getReducedType(type_)
		return /* TODO(ConditionalExpression): isNoInferType(type) ? getNoInferType(getIndexType((type as SubstitutionType).baseType, indexFlags)) :             shouldDeferIndexType(type, indexFlags) ? getIndexTypeForGenericType(type as InstantiableType | UnionOrIntersectionType, indexFlags) :             type.flags & TypeFlags.Union ? getIntersectionType(map((type as UnionType).types, t => getIndexType(t, indexFlags))) :             type.flags & TypeFlags.Intersection ? getUnionType(map((type as IntersectionType).types, t => getIndexType(t, indexFlags))) :             getObjectFlags(type) & ObjectFlags.Mapped ? getIndexTypeForMappedType(type as MappedType, indexFlags) :             type === wildcardType ? wildcardType :             type.flags & TypeFlags.Unknown ? neverType :             type.flags & (TypeFlags.Any | TypeFlags.Never) ? stringNumberSymbolType :             getLiteralTypeFromProperties(type, (indexFlags & IndexFlags.NoIndexSignatures ? TypeFlags.StringLiteral : TypeFlags.StringLike) | (indexFlags & IndexFlags.StringsOnly ? 0 : TypeFlags.NumberLike | TypeFlags.ESSymbolLike), indexFlags === IndexFlags.None) */ TODO
	}
	getExtractStringType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		extractTypeAlias := getGlobalExtractSymbol()
		return /* TODO(ConditionalExpression): extractTypeAlias ? getTypeAliasInstantiation(extractTypeAlias, [type, stringType]) : stringType */ TODO
	}
	getIndexTypeOrString := func(type_ Type) Type {
		indexType := getExtractStringType(getIndexType(type_))
		return /* TODO(ConditionalExpression): indexType.flags & TypeFlags.Never ? stringType : indexType */ TODO
	}
	getTypeFromTypeOperatorNode := func(node TypeOperatorNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			switch node.operator {
			case SyntaxKindKeyOfKeyword:
				links.resolvedType = getIndexType(getTypeFromTypeNode(node.type_))
				break
			case SyntaxKindUniqueKeyword:
				links.resolvedType = /* TODO(ConditionalExpression): node.type.kind === SyntaxKind.SymbolKeyword                         ? getESSymbolLikeTypeForNode(walkUpParenthesizedTypes(node.parent))                         : errorType */ TODO
				break
			case SyntaxKindReadonlyKeyword:
				links.resolvedType = getTypeFromTypeNode(node.type_)
				break
			default:
				Debug.assertNever(node.operator)
			}
		}
		return links.resolvedType
	}
	getTypeFromTemplateTypeNode := func(node TemplateLiteralTypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getTemplateLiteralType( /* TODO(ArrayLiteralExpression): [node.head.text, ...map(node.templateSpans, span => span.literal.text)] */ TODO, map_(node.templateSpans, func(span /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralTypeSpan */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return getTypeFromTypeNode(span.type_)
			}))
		}
		return links.resolvedType
	}
	getTemplateLiteralType := func(texts []string, types []Type) Type {
		unionIndex := findIndex(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return !!(t.flags & (TypeFlagsNever | TypeFlagsUnion))
		})
		if unionIndex >= 0 {
			return /* TODO(ConditionalExpression): checkCrossProductUnion(types) ?                 mapType(types[unionIndex], t => getTemplateLiteralType(texts, replaceElement(types, unionIndex, t))) :                 errorType */ TODO
		}
		if contains(types, wildcardType) {
			return wildcardType
		}
		var newTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var newTexts []string = /* TODO(ArrayLiteralExpression): [] */ TODO
		text := /* TODO(ElementAccessExpression): texts[0] */ TODO
		if !addSpans(texts, types) {
			return stringType
		}
		if newTypes.length == 0 {
			return getStringLiteralType(text)
		}
		newTexts.push(text)
		if every(newTexts, func(t /* TODO inferred type string */ TODO) /* TODO inferred type boolean */ TODO {
			return t == ""
		}) {
			if every(newTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return !!(t.flags & TypeFlagsString)
			}) {
				return stringType
			}
			if newTypes.length == 1 && isPatternLiteralType( /* TODO(ElementAccessExpression): newTypes[0] */ TODO) {
				return /* TODO(ElementAccessExpression): newTypes[0] */ TODO
			}
		}
		id := /* TODO(TemplateExpression): `${getTypeListId(newTypes)}|${map(newTexts, t => t.length).join(",")}|${newTexts.join("")}` */ TODO
		type_ := templateLiteralTypes.get(id)
		if !type_ {
			templateLiteralTypes.set(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type = createTemplateLiteralType(newTexts, newTypes) */, TODO)
		}
		return type_
		addSpans := func(texts []string, types []Type) bool {
			/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                 const t = types[i];                 if (t.flags & (TypeFlags.Literal | TypeFlags.Null | TypeFlags.Undefined)) {                     text += getTemplateStringForType(t) || "";                     text += texts[i + 1];                 }                 else if (t.flags & TypeFlags.TemplateLiteral) {                     text += (t as TemplateLiteralType).texts[0];                     if (!addSpans((t as TemplateLiteralType).texts, (t as TemplateLiteralType).types)) return false;                     text += texts[i + 1];                 }                 else if (isGenericIndexType(t) || isPatternLiteralPlaceholderType(t)) {                     newTypes.push(t);                     newTexts.push(text);                     text = texts[i + 1];                 }                 else {                     return false;                 }             } */
			return true
		}
	}
	getTemplateStringForType := func(type_ Type) /* TODO inferred type string | undefined */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.StringLiteral ? (type as StringLiteralType).value :             type.flags & TypeFlags.NumberLiteral ? "" + (type as NumberLiteralType).value :             type.flags & TypeFlags.BigIntLiteral ? pseudoBigIntToString((type as BigIntLiteralType).value) :             type.flags & (TypeFlags.BooleanLiteral | TypeFlags.Nullable) ? (type as IntrinsicType).intrinsicName :             undefined */ TODO
	}
	createTemplateLiteralType := func(texts []string, types []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType */ TODO {
		type_ := createType(TypeFlagsTemplateLiteral)
		type_.texts = texts
		type_.types = types
		return type_
	}
	getStringMappingType := func(symbol Symbol, type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.Union | TypeFlags.Never) ? mapType(type, t => getStringMappingType(symbol, t)) :             type.flags & TypeFlags.StringLiteral ? getStringLiteralType(applyStringMapping(symbol, (type as StringLiteralType).value)) :             type.flags & TypeFlags.TemplateLiteral ? getTemplateLiteralType(...applyTemplateStringMapping(symbol, (type as TemplateLiteralType).texts, (type as TemplateLiteralType).types)) :             // Mapping<Mapping<T>> === Mapping<T>             type.flags & TypeFlags.StringMapping && symbol === type.symbol ? type :             type.flags & (TypeFlags.Any | TypeFlags.String | TypeFlags.StringMapping) || isGenericIndexType(type) ? getStringMappingTypeForGenericType(symbol, type) :             // This handles Mapping<`${number}`> and Mapping<`${bigint}`>             isPatternLiteralPlaceholderType(type) ? getStringMappingTypeForGenericType(symbol, getTemplateLiteralType(["", ""], [type])) :             type */ TODO
	}
	applyStringMapping := func(symbol Symbol, str string) /* TODO inferred type string */ TODO {
		switch intrinsicTypeKinds.get(symbol.escapedName) {
		case IntrinsicTypeKindUppercase:
			return str.toUpperCase()
		case IntrinsicTypeKindLowercase:
			return str.toLowerCase()
		case IntrinsicTypeKindCapitalize:
			return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): str.charAt(0).toUpperCase() + str.slice(1) */ TODO
		case IntrinsicTypeKindUncapitalize:
			return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): str.charAt(0).toLowerCase() + str.slice(1) */ TODO
		}
		return str
	}
	applyTemplateStringMapping := func(symbol Symbol, texts []string, types []Type) /* TODO(TupleType): [texts: readonly string[], types: readonly Type[]] */ any {
		switch intrinsicTypeKinds.get(symbol.escapedName) {
		case IntrinsicTypeKindUppercase:
			return /* TODO(ArrayLiteralExpression): [texts.map(t => t.toUpperCase()), types.map(t => getStringMappingType(symbol, t))] */ TODO
		case IntrinsicTypeKindLowercase:
			return /* TODO(ArrayLiteralExpression): [texts.map(t => t.toLowerCase()), types.map(t => getStringMappingType(symbol, t))] */ TODO
		case IntrinsicTypeKindCapitalize:
			return /* TODO(ArrayLiteralExpression): [texts[0] === "" ? texts : [texts[0].charAt(0).toUpperCase() + texts[0].slice(1), ...texts.slice(1)], texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types] */ TODO
		case IntrinsicTypeKindUncapitalize:
			return /* TODO(ArrayLiteralExpression): [texts[0] === "" ? texts : [texts[0].charAt(0).toLowerCase() + texts[0].slice(1), ...texts.slice(1)], texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types] */ TODO
		}
		return /* TODO(ArrayLiteralExpression): [texts, types] */ TODO
	}
	getStringMappingTypeForGenericType := func(symbol Symbol, type_ Type) Type {
		id := /* TODO(TemplateExpression): `${getSymbolId(symbol)},${getTypeId(type)}` */ TODO
		result := stringMappingTypes.get(id)
		if !result {
			stringMappingTypes.set(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = createStringMappingType(symbol, type) */, TODO)
		}
		return result
	}
	createStringMappingType := func(symbol Symbol, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringMappingType */ TODO {
		result := createTypeWithSymbol(TypeFlagsStringMapping, symbol)
		result.type_ = type_
		return result
	}
	createIndexedAccessType := func(objectType Type, indexType Type, accessFlags AccessFlags, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexedAccessType */ TODO {
		type_ := createType(TypeFlagsIndexedAccess)
		type_.objectType = objectType
		type_.indexType = indexType
		type_.accessFlags = accessFlags
		type_.aliasSymbol = aliasSymbol
		type_.aliasTypeArguments = aliasTypeArguments
		return type_
	}
	isJSLiteralType := func(type_ Type) bool {
		if noImplicitAny {
			return false
		}
		if getObjectFlags(type_) & ObjectFlagsJSLiteral {
			return true
		}
		if type_.flags & TypeFlagsUnion {
			return every((type_).types, isJSLiteralType)
		}
		if type_.flags & TypeFlagsIntersection {
			return some((type_).types, isJSLiteralType)
		}
		if type_.flags & TypeFlagsInstantiable {
			constraint := getResolvedBaseConstraint(type_)
			return constraint != type_ && isJSLiteralType(constraint)
		}
		return false
	}
	getPropertyNameFromIndex := func(indexType Type, accessNode /* TODO(UnionType): PropertyName | ObjectBindingPattern | ArrayBindingPattern | IndexedAccessTypeNode | ElementAccessExpression | SyntheticExpression | undefined */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		return /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(indexType) ?             getPropertyNameFromType(indexType) :             accessNode && isPropertyName(accessNode) ?             // late bound names are handled in the first branch, so here we only need to handle normal names             getPropertyNameForPropertyNameNode(accessNode) :             undefined */ TODO
	}
	isUncalledFunctionReference := func(node Node, symbol Symbol) /* TODO inferred type boolean */ TODO {
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod) {
			parent := findAncestor(node.parent, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
				return !isAccessExpression(n)
			}) || node.parent
			if isCallLikeExpression(parent) {
				return isCallOrNewExpression(parent) && isIdentifier(node) && hasMatchingArgument(parent, node)
			}
			return every(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
				return !isFunctionLike(d) || isDeprecatedDeclaration(d)
			})
		}
		return true
	}
	getPropertyTypeForIndexType := func(originalObjectType Type, objectType Type, indexType Type, fullIndexType Type, accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression | undefined */ any, accessFlags AccessFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		accessExpression := /* TODO(ConditionalExpression): accessNode && accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode : undefined */ TODO
		propName := /* TODO(ConditionalExpression): accessNode && isPrivateIdentifier(accessNode) ? undefined : getPropertyNameFromIndex(indexType, accessNode) */ TODO
		if propName != nil {
			if accessFlags & AccessFlagsContextual {
				return getTypeOfPropertyOfContextualType(objectType, propName) || anyType
			}
			prop := getPropertyOfType(objectType, propName)
			if prop {
				if accessFlags&AccessFlagsReportDeprecated && accessNode && prop.declarations && isDeprecatedSymbol(prop) && isUncalledFunctionReference(accessNode, prop) {
					deprecatedNode := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): accessExpression?.argumentExpression ?? (isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode) */ TODO
					addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName)
				}
				if accessExpression {
					markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess(accessExpression.expression, objectType.symbol))
					if isAssignmentToReadonlyEntity(accessExpression, prop, getAssignmentTargetKind(accessExpression)) {
						error(accessExpression.argumentExpression, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop))
						return nil
					}
					if accessFlags & AccessFlagsCacheSymbol {
						getNodeLinks(accessNode).resolvedSymbol = prop
					}
					if isThisPropertyAccessInConstructor(accessExpression, prop) {
						return autoType
					}
				}
				propType := /* TODO(ConditionalExpression): accessFlags & AccessFlags.Writing ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop) */ TODO
				return /* TODO(ConditionalExpression): accessExpression && getAssignmentTargetKind(accessExpression) !== AssignmentKind.Definite ? getFlowTypeOfReference(accessExpression, propType) :                     accessNode && isIndexedAccessTypeNode(accessNode) && containsMissingType(propType) ? getUnionType([propType, undefinedType]) :                     propType */ TODO
			}
			if everyType(objectType, isTupleType) && isNumericLiteralName(propName) {
				index := +propName
				if accessNode && everyType(objectType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !((t).target.combinedFlags & ElementFlagsVariable)
				}) && !(accessFlags & AccessFlagsAllowMissing) {
					indexNode := getIndexNodeForAccessExpression(accessNode)
					if isTupleType(objectType) {
						if index < 0 {
							error(indexNode, Diagnostics.A_tuple_type_cannot_be_indexed_with_a_negative_value)
							return undefinedType
						}
						error(indexNode, Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2, typeToString(objectType), getTypeReferenceArity(objectType), unescapeLeadingUnderscores(propName))
					} else {
						error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType))
					}
				}
				if index >= 0 {
					errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType))
					return getTupleElementTypeOutOfStartCount(objectType, index /* TODO(ConditionalExpression): accessFlags & AccessFlags.IncludeUndefined ? missingType : undefined */, TODO)
				}
			}
		}
		if !(indexType.flags & TypeFlagsNullable) && isTypeAssignableToKind(indexType, TypeFlagsStringLike|TypeFlagsNumberLike|TypeFlagsESSymbolLike) {
			if objectType.flags & (TypeFlagsAny | TypeFlagsNever) {
				return objectType
			}
			indexInfo := getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(objectType, stringType)
			if indexInfo {
				if accessFlags&AccessFlagsNoIndexSignatures && indexInfo.keyType != numberType {
					if accessExpression {
						if accessFlags & AccessFlagsWriting {
							error(accessExpression, Diagnostics.Type_0_is_generic_and_can_only_be_indexed_for_reading, typeToString(originalObjectType))
						} else {
							error(accessExpression, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType))
						}
					}
					return nil
				}
				if accessNode && indexInfo.keyType == stringType && !isTypeAssignableToKind(indexType, TypeFlagsString|TypeFlagsNumber) {
					indexNode := getIndexNodeForAccessExpression(accessNode)
					error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType))
					return /* TODO(ConditionalExpression): accessFlags & AccessFlags.IncludeUndefined ? getUnionType([indexInfo.type, missingType]) : indexInfo.type */ TODO
				}
				errorIfWritingToReadonlyIndex(indexInfo)
				if (accessFlags & AccessFlagsIncludeUndefined) && !(objectType.symbol && objectType.symbol.flags&(SymbolFlagsRegularEnum|SymbolFlagsConstEnum) && (indexType.symbol && indexType.flags&TypeFlagsEnumLiteral && getParentOfSymbol(indexType.symbol) == objectType.symbol)) {
					return getUnionType( /* TODO(ArrayLiteralExpression): [indexInfo.type, missingType] */ TODO)
				}
				return indexInfo.type_
			}
			if indexType.flags & TypeFlagsNever {
				return neverType
			}
			if isJSLiteralType(objectType) {
				return anyType
			}
			if accessExpression && !isConstEnumObjectType(objectType) {
				if isObjectLiteralType(objectType) {
					if noImplicitAny && indexType.flags&(TypeFlagsStringLiteral|TypeFlagsNumberLiteral) {
						diagnostics.add(createDiagnosticForNode(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType).value, typeToString(objectType)))
						return undefinedType
					} else if indexType.flags & (TypeFlagsNumber | TypeFlagsString) {
						types := map_((objectType).properties, func(property /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
							return getTypeOfSymbol(property)
						})
						return getUnionType(append(types, undefinedType))
					}
				}
				if objectType.symbol == globalThisSymbol && propName != nil && globalThisSymbol.exports.has(propName) && (globalThisSymbol.exports.get(propName).flags & SymbolFlagsBlockScoped) {
					error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType))
				} else if noImplicitAny && !(accessFlags & AccessFlagsSuppressNoImplicitAnyError) {
					if propName != nil && typeHasStaticProperty(propName, objectType) {
						typeName := typeToString(objectType)
						error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName /* TODO(PlusToken): + */ /* TODO(BinaryExpression): typeName + "[" + getTextOfNode(accessExpression.argumentExpression) + "]" */, TODO)
					} else if getIndexTypeOfType(objectType, numberType) {
						error(accessExpression.argumentExpression, Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number)
					} else {
						var suggestion /* TODO(StringKeyword): string */ any
						if propName != nil && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): suggestion = getSuggestionForNonexistentProperty(propName as string, objectType) */ TODO) {
							if suggestion != nil {
								error(accessExpression.argumentExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(objectType), suggestion)
							}
						} else {
							suggestion := getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType)
							if suggestion != nil {
								error(accessExpression, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion)
							} else {
								var errorInfo *DiagnosticMessageChain
								if indexType.flags & TypeFlagsEnumLiteral {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1 /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "[" + typeToString(indexType) + "]" */, TODO, typeToString(objectType))
								} else if indexType.flags & TypeFlagsUniqueESSymbol {
									symbolName := getFullyQualifiedName((indexType).symbol, accessExpression)
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1 /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "[" + symbolName + "]" */, TODO, typeToString(objectType))
								} else if indexType.flags & TypeFlagsStringLiteral {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType).value, typeToString(objectType))
								} else if indexType.flags & TypeFlagsNumberLiteral {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType).value, typeToString(objectType))
								} else if indexType.flags & (TypeFlagsNumber | TypeFlagsString) {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType))
								}
								errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1, typeToString(fullIndexType), typeToString(objectType))
								diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(accessExpression), accessExpression, errorInfo))
							}
						}
					}
				}
				return nil
			}
		}
		if accessFlags&AccessFlagsAllowMissing && isObjectLiteralType(objectType) {
			return undefinedType
		}
		if isJSLiteralType(objectType) {
			return anyType
		}
		if accessNode {
			indexNode := getIndexNodeForAccessExpression(accessNode)
			if indexNode.kind != SyntaxKindBigIntLiteral && indexType.flags&(TypeFlagsStringLiteral|TypeFlagsNumberLiteral) {
				error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1 /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + (indexType as StringLiteralType | NumberLiteralType).value */, TODO, typeToString(objectType))
			} else if indexType.flags & (TypeFlagsString | TypeFlagsNumber) {
				error(indexNode, Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType))
			} else {
				typeString := /* TODO(ConditionalExpression): indexNode.kind === SyntaxKind.BigIntLiteral ? "bigint" : typeToString(indexType) */ TODO
				error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeString)
			}
		}
		if isTypeAny(indexType) {
			return indexType
		}
		return nil
		errorIfWritingToReadonlyIndex := func(indexInfo *IndexInfo) {
			if indexInfo && indexInfo.isReadonly && accessExpression && (isAssignmentTarget(accessExpression) || isDeleteTarget(accessExpression)) {
				error(accessExpression, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType))
			}
		}
	}
	getIndexNodeForAccessExpression := func(accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectBindingPattern | import("/home/jabaile/work/TypeScript/src/compiler/types").ArrayBindingPattern */ TODO {
		return /* TODO(ConditionalExpression): accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode.argumentExpression :             accessNode.kind === SyntaxKind.IndexedAccessType ? accessNode.indexType :             accessNode.kind === SyntaxKind.ComputedPropertyName ? accessNode.expression :             accessNode */ TODO
	}
	isPatternLiteralPlaceholderType := func(type_ Type) bool {
		if type_.flags & TypeFlagsIntersection {
			seenPlaceholder := false
			for _, t := range (type_).types {
				if t.flags&(TypeFlagsLiteral|TypeFlagsNullable) || isPatternLiteralPlaceholderType(t) {
					seenPlaceholder = true
				} else if !(t.flags & TypeFlagsObject) {
					return false
				}
			}
			return seenPlaceholder
		}
		return !!(type_.flags & (TypeFlagsAny | TypeFlagsString | TypeFlagsNumber | TypeFlagsBigInt)) || isPatternLiteralType(type_)
	}
	isPatternLiteralType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(type_.flags&TypeFlagsTemplateLiteral) && every((type_).types, isPatternLiteralPlaceholderType) || !!(type_.flags&TypeFlagsStringMapping) && isPatternLiteralPlaceholderType((type_).type_)
	}
	isGenericStringLikeType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(type_.flags & (TypeFlagsTemplateLiteral | TypeFlagsStringMapping)) && !isPatternLiteralType(type_)
	}
	isGenericType := func(type_ Type) bool {
		return !!getGenericObjectFlags(type_)
	}
	isGenericObjectType := func(type_ Type) bool {
		return !!(getGenericObjectFlags(type_) & ObjectFlagsIsGenericObjectType)
	}
	isGenericIndexType := func(type_ Type) bool {
		return !!(getGenericObjectFlags(type_) & ObjectFlagsIsGenericIndexType)
	}
	getGenericObjectFlags := func(type_ Type) ObjectFlags {
		if type_.flags & (TypeFlagsUnionOrIntersection) {
			if !((type_).objectFlags & ObjectFlagsIsGenericTypeComputed) {
				(type_).objectFlags |= ObjectFlagsIsGenericTypeComputed | reduceLeft((type_).types, func(flags /* TODO inferred type number */ TODO, t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type number */ TODO {
					return flags | getGenericObjectFlags(t)
				}, 0)
			}
			return (type_).objectFlags & ObjectFlagsIsGenericType
		}
		if type_.flags & TypeFlagsSubstitution {
			if !((type_).objectFlags & ObjectFlagsIsGenericTypeComputed) {
				(type_).objectFlags |= ObjectFlagsIsGenericTypeComputed | getGenericObjectFlags((type_).baseType) | getGenericObjectFlags((type_).constraint)
			}
			return (type_).objectFlags & ObjectFlagsIsGenericType
		}
		return ( /* TODO(ConditionalExpression): type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(type) || isGenericTupleType(type) ? ObjectFlags.IsGenericObjectType : 0 */ TODO) | ( /* TODO(ConditionalExpression): type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.Index) || isGenericStringLikeType(type) ? ObjectFlags.IsGenericIndexType : 0 */ TODO)
	}
	getSimplifiedType := func(type_ Type, writing bool) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.IndexedAccess ? getSimplifiedIndexedAccessType(type as IndexedAccessType, writing) :             type.flags & TypeFlags.Conditional ? getSimplifiedConditionalType(type as ConditionalType, writing) :             type */ TODO
	}
	distributeIndexOverObjectType := func(objectType Type, indexType Type, writing bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if objectType.flags&TypeFlagsUnion || objectType.flags&TypeFlagsIntersection && !shouldDeferIndexType(objectType) {
			types := map_((objectType).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return getSimplifiedType(getIndexedAccessType(t, indexType), writing)
			})
			return /* TODO(ConditionalExpression): objectType.flags & TypeFlags.Intersection || writing ? getIntersectionType(types) : getUnionType(types) */ TODO
		}
	}
	distributeObjectOverIndexType := func(objectType Type, indexType Type, writing bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if indexType.flags & TypeFlagsUnion {
			types := map_((indexType).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return getSimplifiedType(getIndexedAccessType(objectType, t), writing)
			})
			return /* TODO(ConditionalExpression): writing ? getIntersectionType(types) : getUnionType(types) */ TODO
		}
	}
	getSimplifiedIndexedAccessType := func(type_ IndexedAccessType, writing bool) Type {
		cache := /* TODO(ConditionalExpression): writing ? "simplifiedForWriting" : "simplifiedForReading" */ TODO
		if /* TODO(ElementAccessExpression): type[cache] */ TODO {
			return /* TODO(ConditionalExpression): type[cache] === circularConstraintType ? type : type[cache] */ TODO
		}
		/* TODO(ElementAccessExpression): type[cache] */ TODO = circularConstraintType
		objectType := getSimplifiedType(type_.objectType, writing)
		indexType := getSimplifiedType(type_.indexType, writing)
		distributedOverIndex := distributeObjectOverIndexType(objectType, indexType, writing)
		if distributedOverIndex {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = distributedOverIndex */ TODO
		}
		if !(indexType.flags & TypeFlagsInstantiable) {
			distributedOverObject := distributeIndexOverObjectType(objectType, indexType, writing)
			if distributedOverObject {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = distributedOverObject */ TODO
			}
		}
		if isGenericTupleType(objectType) && indexType.flags&TypeFlagsNumberLike {
			elementType := getElementTypeOfSliceOfTupleType(objectType /* TODO(ConditionalExpression): indexType.flags & TypeFlags.Number ? 0 : objectType.target.fixedLength */, TODO, 0, writing)
			if elementType {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = elementType */ TODO
			}
		}
		if isGenericMappedType(objectType) {
			if getMappedTypeNameTypeKind(objectType) != MappedTypeNameTypeKindRemapping {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = mapType(substituteIndexedMappedType(objectType, type.indexType), t => getSimplifiedType(t, writing)) */ TODO
			}
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = type */ TODO
	}
	getSimplifiedConditionalType := func(type_ ConditionalType, writing bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		checkType := type_.checkType
		extendsType := type_.extendsType
		trueType := getTrueTypeFromConditionalType(type_)
		falseType := getFalseTypeFromConditionalType(type_)
		if falseType.flags&TypeFlagsNever && getActualTypeVariable(trueType) == getActualTypeVariable(checkType) {
			if checkType.flags&TypeFlagsAny || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType)) {
				return getSimplifiedType(trueType, writing)
			} else if isIntersectionEmpty(checkType, extendsType) {
				return neverType
			}
		} else if trueType.flags&TypeFlagsNever && getActualTypeVariable(falseType) == getActualTypeVariable(checkType) {
			if !(checkType.flags & TypeFlagsAny) && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType)) {
				return neverType
			} else if checkType.flags&TypeFlagsAny || isIntersectionEmpty(checkType, extendsType) {
				return getSimplifiedType(falseType, writing)
			}
		}
		return type_
	}
	isIntersectionEmpty := func(type1 Type, type2 Type) /* TODO inferred type boolean */ TODO {
		return !!(getUnionType( /* TODO(ArrayLiteralExpression): [intersectTypes(type1, type2), neverType] */ TODO).flags & TypeFlagsNever)
	}
	substituteIndexedMappedType := func(objectType MappedType, index Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		mapper := createTypeMapper( /* TODO(ArrayLiteralExpression): [getTypeParameterFromMappedType(objectType)] */ TODO /* TODO(ArrayLiteralExpression): [index] */, TODO)
		templateMapper := combineTypeMappers(objectType.mapper, mapper)
		instantiatedTemplateType := instantiateType(getTemplateTypeFromMappedType(objectType.target || objectType), templateMapper)
		isOptional := getMappedTypeOptionality(objectType) > 0 || ( /* TODO(ConditionalExpression): isGenericType(objectType) ?             getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(objectType)) > 0 :             couldAccessOptionalProperty(objectType, index) */ TODO)
		return addOptionality(instantiatedTemplateType, true, isOptional)
	}
	couldAccessOptionalProperty := func(objectType Type, indexType Type) /* TODO inferred type boolean */ TODO {
		indexConstraint := getBaseConstraintOfType(indexType)
		return !!indexConstraint && some(getPropertiesOfType(objectType), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
			return !!(p.flags & SymbolFlagsOptional) && isTypeAssignableTo(getLiteralTypeFromProperty(p, TypeFlagsStringOrNumberLiteralOrUnique), indexConstraint)
		})
	}
	getIndexedAccessType := func(objectType Type, indexType Type, accessFlags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").AccessFlags */ TODO /*  = AccessFlags.None */, accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		return getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || ( /* TODO(ConditionalExpression): accessNode ? errorType : unknownType */ TODO)
	}
	indexTypeLessThan := func(indexType Type, limit number) /* TODO inferred type boolean */ TODO {
		return everyType(indexType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			if t.flags & TypeFlagsStringOrNumberLiteral {
				propName := getPropertyNameFromType(t)
				if isNumericLiteralName(propName) {
					index := +propName
					return index >= 0 && index < limit
				}
			}
			return false
		})
	}
	getIndexedAccessTypeOrUndefined := func(objectType Type, indexType Type, accessFlags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").AccessFlags */ TODO /*  = AccessFlags.None */, accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) *Type {
		if objectType == wildcardType || indexType == wildcardType {
			return wildcardType
		}
		objectType = getReducedType(objectType)
		if isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & TypeFlagsNullable) && isTypeAssignableToKind(indexType, TypeFlagsString|TypeFlagsNumber) {
			indexType = stringType
		}
		if compilerOptions.noUncheckedIndexedAccess && accessFlags&AccessFlagsExpressionPosition {
			accessFlags |= AccessFlagsIncludeUndefined
		}
		if isGenericIndexType(indexType) || ( /* TODO(ConditionalExpression): accessNode && accessNode.kind !== SyntaxKind.IndexedAccessType ?                 isGenericTupleType(objectType) && !indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target)) :                 isGenericObjectType(objectType) && !(isTupleType(objectType) && indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target))) || isGenericReducibleType(objectType) */ TODO) {
			if objectType.flags & TypeFlagsAnyOrUnknown {
				return objectType
			}
			persistentAccessFlags := accessFlags & AccessFlagsPersistent
			id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
			type_ := indexedAccessTypes.get(id)
			if !type_ {
				indexedAccessTypes.set(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments) */, TODO)
			}
			return type_
		}
		apparentObjectType := getReducedApparentType(objectType)
		if indexType.flags&TypeFlagsUnion && !(indexType.flags & TypeFlagsBoolean) {
			var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			wasMissingProp := false
			for _, t := range (indexType).types {
				propType := getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags|( /* TODO(ConditionalExpression): wasMissingProp ? AccessFlags.SuppressNoImplicitAnyError : 0 */ TODO))
				if propType {
					propTypes.push(propType)
				} else if !accessNode {
					return nil
				} else {
					wasMissingProp = true
				}
			}
			if wasMissingProp {
				return nil
			}
			return /* TODO(ConditionalExpression): accessFlags & AccessFlags.Writing                 ? getIntersectionType(propTypes, IntersectionFlags.None, aliasSymbol, aliasTypeArguments)                 : getUnionType(propTypes, UnionReduction.Literal, aliasSymbol, aliasTypeArguments) */ TODO
		}
		return getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode, accessFlags|AccessFlagsCacheSymbol|AccessFlagsReportDeprecated)
	}
	getTypeFromIndexedAccessTypeNode := func(node IndexedAccessTypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getNodeLinks(node)
		if !links.resolvedType {
			objectType := getTypeFromTypeNode(node.objectType)
			indexType := getTypeFromTypeNode(node.indexType)
			potentialAlias := getAliasSymbolForTypeNode(node)
			links.resolvedType = getIndexedAccessType(objectType, indexType, AccessFlagsNone, node, potentialAlias, getTypeArgumentsForAliasSymbol(potentialAlias))
		}
		return links.resolvedType
	}
	getTypeFromMappedTypeNode := func(node MappedTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			type_ := createObjectType(ObjectFlagsMapped, node.symbol)
			type_.declaration = node
			type_.aliasSymbol = getAliasSymbolForTypeNode(node)
			type_.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type_.aliasSymbol)
			links.resolvedType = type_
			getConstraintTypeFromMappedType(type_)
		}
		return links.resolvedType
	}
	getActualTypeVariable := func(type_ Type) Type {
		if type_.flags & TypeFlagsSubstitution {
			return getActualTypeVariable((type_).baseType)
		}
		if type_.flags&TypeFlagsIndexedAccess && ((type_).objectType.flags&TypeFlagsSubstitution || (type_).indexType.flags&TypeFlagsSubstitution) {
			return getIndexedAccessType(getActualTypeVariable((type_).objectType), getActualTypeVariable((type_).indexType))
		}
		return type_
	}
	isSimpleTupleType := func(node TypeNode) bool {
		return isTupleTypeNode(node) && length(node.elements) > 0 && !some(node.elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember */ TODO) /* TODO inferred type boolean */ TODO {
			return isOptionalTypeNode(e) || isRestTypeNode(e) || isNamedTupleMember(e) && !!(e.questionToken || e.dotDotDotToken)
		})
	}
	isDeferredType := func(type_ Type, checkTuples bool) /* TODO inferred type boolean */ TODO {
		return isGenericType(type_) || checkTuples && isTupleType(type_) && some(getElementTypes(type_), isGenericType)
	}
	getConditionalType := func(root ConditionalRoot, mapper *TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		var result TODO
		var extraTypes /* TODO(ArrayType): Type[] */ any
		tailCount := 0
		for true {
			if tailCount == 1000 {
				error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite)
				return errorType
			}
			checkType := instantiateType(getActualTypeVariable(root.checkType), mapper)
			extendsType := instantiateType(root.extendsType, mapper)
			if checkType == errorType || extendsType == errorType {
				return errorType
			}
			if checkType == wildcardType || extendsType == wildcardType {
				return wildcardType
			}
			checkTypeNode := skipTypeParentheses(root.node.checkType)
			extendsTypeNode := skipTypeParentheses(root.node.extendsType)
			checkTuples := isSimpleTupleType(checkTypeNode) && isSimpleTupleType(extendsTypeNode) && length((checkTypeNode).elements) == length((extendsTypeNode).elements)
			checkTypeDeferred := isDeferredType(checkType, checkTuples)
			var combinedMapper *TypeMapper
			if root.inferTypeParameters {
				context := createInferenceContext(root.inferTypeParameters, nil, InferenceFlagsNone)
				if mapper {
					context.nonFixingMapper = combineTypeMappers(context.nonFixingMapper, mapper)
				}
				if !checkTypeDeferred {
					inferTypes(context.inferences, checkType, extendsType, InferencePriorityNoConstraints|InferencePriorityAlwaysStrict)
				}
				combinedMapper = /* TODO(ConditionalExpression): mapper ? combineTypeMappers(context.mapper, mapper) : context.mapper */ TODO
			}
			inferredExtendsType := /* TODO(ConditionalExpression): combinedMapper ? instantiateType(root.extendsType, combinedMapper) : extendsType */ TODO
			if !checkTypeDeferred && !isDeferredType(inferredExtendsType, checkTuples) {
				if !(inferredExtendsType.flags & TypeFlagsAnyOrUnknown) && (checkType.flags&TypeFlagsAny || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType))) {
					if checkType.flags&TypeFlagsAny || forConstraint && !(inferredExtendsType.flags&TypeFlagsNever) && someType(getPermissiveInstantiation(inferredExtendsType), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
						return isTypeAssignableTo(t, getPermissiveInstantiation(checkType))
					}) {
						(extraTypes || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): extraTypes = [] */ TODO)).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper))
					}
					falseType := getTypeFromTypeNode(root.node.falseType)
					if falseType.flags & TypeFlagsConditional {
						newRoot := (falseType).root
						if newRoot.node.parent == root.node && (!newRoot.isDistributive || newRoot.checkType == root.checkType) {
							root = newRoot
							continue
						}
						if canTailRecurse(falseType, mapper) {
							continue
						}
					}
					result = instantiateType(falseType, mapper)
					break
				}
				if inferredExtendsType.flags&TypeFlagsAnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType)) {
					trueType := getTypeFromTypeNode(root.node.trueType)
					trueMapper := combinedMapper || mapper
					if canTailRecurse(trueType, trueMapper) {
						continue
					}
					result = instantiateType(trueType, trueMapper)
					break
				}
			}
			result = createType(TypeFlagsConditional)
			result.root = root
			result.checkType = instantiateType(root.checkType, mapper)
			result.extendsType = instantiateType(root.extendsType, mapper)
			result.mapper = mapper
			result.combinedMapper = combinedMapper
			result.aliasSymbol = aliasSymbol || root.aliasSymbol
			result.aliasTypeArguments = /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(root.aliasTypeArguments, mapper!) */ TODO
			break
		}
		return /* TODO(ConditionalExpression): extraTypes ? getUnionType(append(extraTypes, result)) : result */ TODO
		canTailRecurse := func(newType Type, newMapper *TypeMapper) /* TODO inferred type boolean */ TODO {
			if newType.flags&TypeFlagsConditional && newMapper {
				newRoot := (newType).root
				if newRoot.outerTypeParameters {
					typeParamMapper := combineTypeMappers((newType).mapper, newMapper)
					typeArguments := map_(newRoot.outerTypeParameters, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
						return getMappedType(t, typeParamMapper)
					})
					newRootMapper := createTypeMapper(newRoot.outerTypeParameters, typeArguments)
					newCheckType := /* TODO(ConditionalExpression): newRoot.isDistributive ? getMappedType(newRoot.checkType, newRootMapper) : undefined */ TODO
					if !newCheckType || newCheckType == newRoot.checkType || !(newCheckType.flags & (TypeFlagsUnion | TypeFlagsNever)) {
						root = newRoot
						mapper = newRootMapper
						aliasSymbol = nil
						aliasTypeArguments = nil
						if newRoot.aliasSymbol {
							tailCount++
						}
						return true
					}
				}
			}
			return false
		}
	}
	getTrueTypeFromConditionalType := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return type_.resolvedTrueType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedTrueType = instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.mapper) */ TODO)
	}
	getFalseTypeFromConditionalType := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return type_.resolvedFalseType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedFalseType = instantiateType(getTypeFromTypeNode(type.root.node.falseType), type.mapper) */ TODO)
	}
	getInferredTrueTypeFromConditionalType := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return type_.resolvedInferredTrueType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.combinedMapper) : getTrueTypeFromConditionalType(type) */ TODO)
	}
	getInferTypeParameters := func(node ConditionalTypeNode) /* TODO(ArrayType): TypeParameter[] */ any {
		var result /* TODO(ArrayType): TypeParameter[] */ any
		if node.locals {
			node.locals.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
				if symbol.flags & SymbolFlagsTypeParameter {
					result = append(result, getDeclaredTypeOfSymbol(symbol))
				}
			})
		}
		return result
	}
	isDistributionDependent := func(root ConditionalRoot) /* TODO inferred type boolean */ TODO {
		return root.isDistributive && (isTypeParameterPossiblyReferenced(root.checkType, root.node.trueType) || isTypeParameterPossiblyReferenced(root.checkType, root.node.falseType))
	}
	getTypeFromConditionalTypeNode := func(node ConditionalTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			checkType := getTypeFromTypeNode(node.checkType)
			aliasSymbol := getAliasSymbolForTypeNode(node)
			aliasTypeArguments := getTypeArgumentsForAliasSymbol(aliasSymbol)
			allOuterTypeParameters := getOuterTypeParameters(node, true)
			outerTypeParameters := /* TODO(ConditionalExpression): aliasTypeArguments ? allOuterTypeParameters : filter(allOuterTypeParameters, tp => isTypeParameterPossiblyReferenced(tp, node)) */ TODO
			var root ConditionalRoot = /* TODO(ObjectLiteralExpression): {                 node,                 checkType,                 extendsType: getTypeFromTypeNode(node.extendsType),                 isDistributive: !!(checkType.flags & TypeFlags.TypeParameter),                 inferTypeParameters: getInferTypeParameters(node),                 outerTypeParameters,                 instantiations: undefined,                 aliasSymbol,                 aliasTypeArguments,             } */ TODO
			links.resolvedType = getConditionalType(root, nil, false)
			if outerTypeParameters {
				root.instantiations = make(map[string]Type)
				root.instantiations.set(getTypeListId(outerTypeParameters), links.resolvedType)
			}
		}
		return links.resolvedType
	}
	getTypeFromInferTypeNode := func(node InferTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter))
		}
		return links.resolvedType
	}
	getIdentifierChain := func(node EntityName) []Identifier {
		if isIdentifier(node) {
			return /* TODO(ArrayLiteralExpression): [node] */ TODO
		} else {
			return append(getIdentifierChain(node.left), node.right)
		}
	}
	getTypeFromImportTypeNode := func(node ImportTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			if !isLiteralImportTypeNode(node) {
				error(node.argument, Diagnostics.String_literal_expected)
				links.resolvedSymbol = unknownSymbol
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = errorType */ TODO
			}
			targetMeaning := /* TODO(ConditionalExpression): node.isTypeOf ? SymbolFlags.Value : node.flags & NodeFlags.JSDoc ? SymbolFlags.Value | SymbolFlags.Type : SymbolFlags.Type */ TODO
			innerModuleSymbol := resolveExternalModuleName(node, node.argument.literal)
			if !innerModuleSymbol {
				links.resolvedSymbol = unknownSymbol
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = errorType */ TODO
			}
			isExportEquals := !!innerModuleSymbol.exports.get(InternalSymbolNameExportEquals)
			moduleSymbol := resolveExternalModuleSymbol(innerModuleSymbol, false)
			if !nodeIsMissing(node.qualifier) {
				var nameStack []Identifier = getIdentifierChain(node.qualifier)
				currentNamespace := moduleSymbol
				var current *Identifier
				for /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): current = nameStack.shift() */ TODO {
					meaning := /* TODO(ConditionalExpression): nameStack.length ? SymbolFlags.Namespace : targetMeaning */ TODO
					mergedResolvedSymbol := getMergedSymbol(resolveSymbol(currentNamespace))
					symbolFromVariable := /* TODO(ConditionalExpression): node.isTypeOf || isInJSFile(node) && isExportEquals                         ? getPropertyOfType(getTypeOfSymbol(mergedResolvedSymbol), current.escapedText, /*skipObjectFunctionPropertyAugment* / false, /*includeTypeOnlyMembers* / true)                         : undefined */ TODO
					symbolFromModule := /* TODO(ConditionalExpression): node.isTypeOf ? undefined : getSymbol(getExportsOfSymbol(mergedResolvedSymbol), current.escapedText, meaning) */ TODO
					next := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): symbolFromModule ?? symbolFromVariable */ TODO
					if !next {
						error(current, Diagnostics.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(currentNamespace), declarationNameToString(current))
						return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = errorType */ TODO
					}
					getNodeLinks(current).resolvedSymbol = next
					getNodeLinks(current.parent).resolvedSymbol = next
					currentNamespace = next
				}
				links.resolvedType = resolveImportSymbolType(node, links, currentNamespace, targetMeaning)
			} else {
				if moduleSymbol.flags & targetMeaning {
					links.resolvedType = resolveImportSymbolType(node, links, moduleSymbol, targetMeaning)
				} else {
					errorMessage := /* TODO(ConditionalExpression): targetMeaning === SymbolFlags.Value                         ? Diagnostics.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here                         : Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0 */ TODO
					error(node, errorMessage, node.argument.literal.text)
					links.resolvedSymbol = unknownSymbol
					links.resolvedType = errorType
				}
			}
		}
		return links.resolvedType
	}
	resolveImportSymbolType := func(node ImportTypeNode, links NodeLinks, symbol Symbol, meaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		resolvedSymbol := resolveSymbol(symbol)
		links.resolvedSymbol = resolvedSymbol
		if meaning == SymbolFlagsValue {
			return getInstantiationExpressionType(getTypeOfSymbol(symbol), node)
		} else {
			return getTypeReferenceType(node, resolvedSymbol)
		}
	}
	getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode := func(node /* TODO(UnionType): TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature */ any) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			if getMembersOfSymbol(node.symbol).size == 0 && !aliasSymbol {
				links.resolvedType = emptyTypeLiteralType
			} else {
				type_ := createObjectType(ObjectFlagsAnonymous, node.symbol)
				type_.aliasSymbol = aliasSymbol
				type_.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol)
				if isJSDocTypeLiteral(node) && node.isArrayType {
					type_ = createArrayType(type_)
				}
				links.resolvedType = type_
			}
		}
		return links.resolvedType
	}
	getAliasSymbolForTypeNode := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		host := node.parent
		for isParenthesizedTypeNode(host) || isJSDocTypeExpression(host) || isTypeOperatorNode(host) && host.operator == SyntaxKindReadonlyKeyword {
			host = host.parent
		}
		return /* TODO(ConditionalExpression): isTypeAlias(host) ? getSymbolOfDeclaration(host) : undefined */ TODO
	}
	getTypeArgumentsForAliasSymbol := func(symbol *Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
		return /* TODO(ConditionalExpression): symbol ? getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) : undefined */ TODO
	}
	isNonGenericObjectType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(type_.flags & TypeFlagsObject) && !isGenericMappedType(type_)
	}
	isEmptyObjectTypeOrSpreadsIntoEmptyObject := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return isEmptyObjectType(type_) || !!(type_.flags & (TypeFlagsNull | TypeFlagsUndefined | TypeFlagsBooleanLike | TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsEnumLike | TypeFlagsNonPrimitive | TypeFlagsIndex))
	}
	tryMergeUnionOfObjectTypeAndEmptyObject := func(type_ Type, readonly bool) Type {
		if !(type_.flags & TypeFlagsUnion) {
			return type_
		}
		if every((type_).types, isEmptyObjectTypeOrSpreadsIntoEmptyObject) {
			return find((type_).types, isEmptyObjectType) || emptyObjectType
		}
		firstType := find((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t)
		})
		if !firstType {
			return type_
		}
		secondType := find((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return t != firstType && !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t)
		})
		if secondType {
			return type_
		}
		return getAnonymousPartialType(firstType)
		getAnonymousPartialType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
			members := createSymbolTable()
			for _, prop := range getPropertiesOfType(type_) {
				if getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlagsPrivate | ModifierFlagsProtected) {
				} else if isSpreadableProperty(prop) {
					isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
					flags := SymbolFlagsProperty | SymbolFlagsOptional
					result := createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop)|( /* TODO(ConditionalExpression): readonly ? CheckFlags.Readonly : 0 */ TODO))
					result.links.type_ = /* TODO(ConditionalExpression): isSetonlyAccessor ? undefinedType : addOptionality(getTypeOfSymbol(prop), /*isProperty* / true) */ TODO
					result.declarations = prop.declarations
					result.links.nameType = getSymbolLinks(prop).nameType
					result.links.syntheticOrigin = prop
					members.set(prop.escapedName, result)
				}
			}
			spread := createAnonymousType(type_.symbol, members, emptyArray, emptyArray, getIndexInfosOfType(type_))
			spread.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
			return spread
		}
	}
	getSpreadType := func(left Type, right Type, symbol *Symbol, objectFlags ObjectFlags, readonly bool) Type {
		if left.flags&TypeFlagsAny || right.flags&TypeFlagsAny {
			return anyType
		}
		if left.flags&TypeFlagsUnknown || right.flags&TypeFlagsUnknown {
			return unknownType
		}
		if left.flags & TypeFlagsNever {
			return right
		}
		if right.flags & TypeFlagsNever {
			return left
		}
		left = tryMergeUnionOfObjectTypeAndEmptyObject(left, readonly)
		if left.flags & TypeFlagsUnion {
			return /* TODO(ConditionalExpression): checkCrossProductUnion([left, right])                 ? mapType(left, t => getSpreadType(t, right, symbol, objectFlags, readonly))                 : errorType */ TODO
		}
		right = tryMergeUnionOfObjectTypeAndEmptyObject(right, readonly)
		if right.flags & TypeFlagsUnion {
			return /* TODO(ConditionalExpression): checkCrossProductUnion([left, right])                 ? mapType(right, t => getSpreadType(left, t, symbol, objectFlags, readonly))                 : errorType */ TODO
		}
		if right.flags & (TypeFlagsBooleanLike | TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsEnumLike | TypeFlagsNonPrimitive | TypeFlagsIndex) {
			return left
		}
		if isGenericObjectType(left) || isGenericObjectType(right) {
			if isEmptyObjectType(left) {
				return right
			}
			if left.flags & TypeFlagsIntersection {
				types := (left).types
				lastLeft := /* TODO(ElementAccessExpression): types[types.length - 1] */ TODO
				if isNonGenericObjectType(lastLeft) && isNonGenericObjectType(right) {
					return getIntersectionType(concatenate(types.slice(0 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): types.length - 1 */, TODO) /* TODO(ArrayLiteralExpression): [getSpreadType(lastLeft, right, symbol, objectFlags, readonly)] */, TODO))
				}
			}
			return getIntersectionType( /* TODO(ArrayLiteralExpression): [left, right] */ TODO)
		}
		members := createSymbolTable()
		skippedPrivateMembers := make(map[__String]struct{})
		indexInfos := /* TODO(ConditionalExpression): left === emptyObjectType ? getIndexInfosOfType(right) : getUnionIndexInfos([left, right]) */ TODO
		for _, rightProp := range getPropertiesOfType(right) {
			if getDeclarationModifierFlagsFromSymbol(rightProp) & (ModifierFlagsPrivate | ModifierFlagsProtected) {
				skippedPrivateMembers.add(rightProp.escapedName)
			} else if isSpreadableProperty(rightProp) {
				members.set(rightProp.escapedName, getSpreadSymbol(rightProp, readonly))
			}
		}
		for _, leftProp := range getPropertiesOfType(left) {
			if skippedPrivateMembers.has(leftProp.escapedName) || !isSpreadableProperty(leftProp) {
				continue
			}
			if members.has(leftProp.escapedName) {
				rightProp := members.get(leftProp.escapedName)
				rightType := getTypeOfSymbol(rightProp)
				if rightProp.flags & SymbolFlagsOptional {
					declarations := concatenate(leftProp.declarations, rightProp.declarations)
					flags := SymbolFlagsProperty | (leftProp.flags & SymbolFlagsOptional)
					result := createSymbol(flags, leftProp.escapedName)
					leftType := getTypeOfSymbol(leftProp)
					leftTypeWithoutUndefined := removeMissingOrUndefinedType(leftType)
					rightTypeWithoutUndefined := removeMissingOrUndefinedType(rightType)
					result.links.type_ = /* TODO(ConditionalExpression): leftTypeWithoutUndefined === rightTypeWithoutUndefined ? leftType : getUnionType([leftType, rightTypeWithoutUndefined], UnionReduction.Subtype) */ TODO
					result.links.leftSpread = leftProp
					result.links.rightSpread = rightProp
					result.declarations = declarations
					result.links.nameType = getSymbolLinks(leftProp).nameType
					members.set(leftProp.escapedName, result)
				}
			} else {
				members.set(leftProp.escapedName, getSpreadSymbol(leftProp, readonly))
			}
		}
		spread := createAnonymousType(symbol, members, emptyArray, emptyArray, sameMap(indexInfos, func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO {
			return getIndexInfoWithReadonly(info, readonly)
		}))
		spread.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral | ObjectFlagsContainsSpread | objectFlags
		return spread
	}
	isSpreadableProperty := func(prop Symbol) bool {
		return !some(prop.declarations, isPrivateIdentifierClassElementDeclaration) && (!(prop.flags & (SymbolFlagsMethod | SymbolFlagsGetAccessor | SymbolFlagsSetAccessor)) || !prop.declarations.some(func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
			return isClassLike(decl.parent)
		}))
	}
	getSpreadSymbol := func(prop Symbol, readonly bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
		if !isSetonlyAccessor && readonly == isReadonlySymbol(prop) {
			return prop
		}
		flags := SymbolFlagsProperty | (prop.flags & SymbolFlagsOptional)
		result := createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop)|( /* TODO(ConditionalExpression): readonly ? CheckFlags.Readonly : 0 */ TODO))
		result.links.type_ = /* TODO(ConditionalExpression): isSetonlyAccessor ? undefinedType : getTypeOfSymbol(prop) */ TODO
		result.declarations = prop.declarations
		result.links.nameType = getSymbolLinks(prop).nameType
		result.links.syntheticOrigin = prop
		return result
	}
	getIndexInfoWithReadonly := func(info IndexInfo, readonly bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO {
		return /* TODO(ConditionalExpression): info.isReadonly !== readonly ? createIndexInfo(info.keyType, info.type, readonly, info.declaration) : info */ TODO
	}
	createLiteralType := func(flags TypeFlags, value /* TODO(UnionType): string | number | PseudoBigInt */ any, symbol Symbol, regularType LiteralType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType */ TODO {
		type_ := createTypeWithSymbol(flags, symbol)
		type_.value = value
		type_.regularType = regularType || type_
		return type_
	}
	getFreshTypeOfLiteralType := func(type_ Type) Type {
		if type_.flags & TypeFlagsFreshable {
			if !(type_).freshType {
				freshType := createLiteralType(type_.flags, (type_).value, (type_).symbol, type_)
				freshType.freshType = freshType
				(type_).freshType = freshType
			}
			return (type_).freshType
		}
		return type_
	}
	getRegularTypeOfLiteralType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Freshable ? (type as FreshableType).regularType :             type.flags & TypeFlags.Union ? ((type as UnionType).regularType || ((type as UnionType).regularType = mapType(type, getRegularTypeOfLiteralType) as UnionType)) :             type */ TODO
	}
	isFreshLiteralType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(type_.flags & TypeFlagsFreshable) && (type_).freshType == type_
	}
	getStringLiteralType := func(value string) StringLiteralType {
		var type_ TODO
		return stringLiteralTypes.get(value) || ( /* TODO(CommaToken): , */ /* TODO(BinaryExpression): stringLiteralTypes.set(value, type = createLiteralType(TypeFlags.StringLiteral, value) as StringLiteralType), type */ TODO)
	}
	getNumberLiteralType := func(value number) NumberLiteralType {
		var type_ TODO
		return numberLiteralTypes.get(value) || ( /* TODO(CommaToken): , */ /* TODO(BinaryExpression): numberLiteralTypes.set(value, type = createLiteralType(TypeFlags.NumberLiteral, value) as NumberLiteralType), type */ TODO)
	}
	getBigIntLiteralType := func(value PseudoBigInt) BigIntLiteralType {
		var type_ TODO
		key := pseudoBigIntToString(value)
		return bigIntLiteralTypes.get(key) || ( /* TODO(CommaToken): , */ /* TODO(BinaryExpression): bigIntLiteralTypes.set(key, type = createLiteralType(TypeFlags.BigIntLiteral, value) as BigIntLiteralType), type */ TODO)
	}
	getEnumLiteralType := func(value /* TODO(UnionType): string | number */ any, enumId number, symbol Symbol) LiteralType {
		var type_ TODO
		key := /* TODO(TemplateExpression): `${enumId}${typeof value === "string" ? "@" : "#"}${value}` */ TODO
		flags := TypeFlagsEnumLiteral | ( /* TODO(ConditionalExpression): typeof value === "string" ? TypeFlags.StringLiteral : TypeFlags.NumberLiteral */ TODO)
		return enumLiteralTypes.get(key) || ( /* TODO(CommaToken): , */ /* TODO(BinaryExpression): enumLiteralTypes.set(key, type = createLiteralType(flags, value, symbol)), type */ TODO)
	}
	getTypeFromLiteralTypeNode := func(node LiteralTypeNode) Type {
		if node.literal.kind == SyntaxKindNullKeyword {
			return nullType
		}
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal))
		}
		return links.resolvedType
	}
	createUniqueESSymbolType := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").UniqueESSymbolType */ TODO {
		type_ := createTypeWithSymbol(TypeFlagsUniqueESSymbol, symbol)
		type_.escapedName = /* TODO(TemplateExpression): `__@${type.symbol.escapedName}@${getSymbolId(type.symbol)}` */ TODO
		return type_
	}
	getESSymbolLikeTypeForNode := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isInJSFile(node) && isJSDocTypeExpression(node) {
			host := getJSDocHost(node)
			if host {
				node = getSingleVariableOfVariableStatement(host) || host
			}
		}
		if isValidESSymbolDeclaration(node) {
			symbol := /* TODO(ConditionalExpression): isCommonJsExportPropertyAssignment(node) ? getSymbolOfNode((node as BinaryExpression).left) : getSymbolOfNode(node) */ TODO
			if symbol {
				links := getSymbolLinks(symbol)
				return links.uniqueESSymbolType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.uniqueESSymbolType = createUniqueESSymbolType(symbol) */ TODO)
			}
		}
		return esSymbolType
	}
	getThisType := func(node Node) Type {
		container := getThisContainer(node, false, false)
		parent := container && container.parent
		if parent && (isClassLike(parent) || parent.kind == SyntaxKindInterfaceDeclaration) {
			if !isStatic(container) && (!isConstructorDeclaration(container) || isNodeDescendantOf(node, container.body)) {
				return getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(parent)).thisType
			}
		}
		if parent && isObjectLiteralExpression(parent) && isBinaryExpression(parent.parent) && getAssignmentDeclarationKind(parent.parent) == AssignmentDeclarationKindPrototype {
			return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent.parent.left).parent).thisType
		}
		host := /* TODO(ConditionalExpression): node.flags & NodeFlags.JSDoc ? getHostSignatureFromJSDoc(node) : undefined */ TODO
		if host && isFunctionExpression(host) && isBinaryExpression(host.parent) && getAssignmentDeclarationKind(host.parent) == AssignmentDeclarationKindPrototypeProperty {
			return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(host.parent.left).parent).thisType
		}
		if isJSConstructor(container) && isNodeDescendantOf(node, container.body) {
			return getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(container)).thisType
		}
		error(node, Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface)
		return errorType
	}
	getTypeFromThisTypeNode := func(node /* TODO(UnionType): ThisExpression | ThisTypeNode */ any) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getThisType(node)
		}
		return links.resolvedType
	}
	getTypeFromRestTypeNode := func(node /* TODO(UnionType): RestTypeNode | NamedTupleMember */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getTypeFromTypeNode(getArrayElementTypeNode(node.type_) || node.type_)
	}
	getArrayElementTypeNode := func(node TypeNode) *TypeNode {
		switch node.kind {
		case SyntaxKindParenthesizedType:
			return getArrayElementTypeNode((node).type_)
		case SyntaxKindTupleType:
			if (node).elements.length == 1 {
				node = /* TODO(ElementAccessExpression): (node as TupleTypeNode).elements[0] */ TODO
				if node.kind == SyntaxKindRestType || node.kind == SyntaxKindNamedTupleMember && (node).dotDotDotToken {
					return getArrayElementTypeNode((node).type_)
				}
			}
			break
		case SyntaxKindArrayType:
			return (node).elementType
		}
		return nil
	}
	getTypeFromNamedTupleTypeNode := func(node NamedTupleMember) Type {
		links := getNodeLinks(node)
		return links.resolvedType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = node.dotDotDotToken ? getTypeFromRestTypeNode(node) :             addOptionality(getTypeFromTypeNode(node.type), /*isProperty* / true, !!node.questionToken) */ TODO)
	}
	getTypeFromTypeNode := func(node TypeNode) Type {
		return getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node)
	}
	getTypeFromTypeNodeWorker := func(node TypeNode) Type {
		switch node.kind {
		case SyntaxKindAnyKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocAllType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocUnknownType:
			return anyType
		case SyntaxKindUnknownKeyword:
			return unknownType
		case SyntaxKindStringKeyword:
			return stringType
		case SyntaxKindNumberKeyword:
			return numberType
		case SyntaxKindBigIntKeyword:
			return bigintType
		case SyntaxKindBooleanKeyword:
			return booleanType
		case SyntaxKindSymbolKeyword:
			return esSymbolType
		case SyntaxKindVoidKeyword:
			return voidType
		case SyntaxKindUndefinedKeyword:
			return undefinedType
		case SyntaxKindNullKeyword:
			return nullType
		case SyntaxKindNeverKeyword:
			return neverType
		case SyntaxKindObjectKeyword:
			return /* TODO(ConditionalExpression): node.flags & NodeFlags.JavaScriptFile && !noImplicitAny ? anyType : nonPrimitiveType */ TODO
		case SyntaxKindIntrinsicKeyword:
			return intrinsicMarkerType
		case SyntaxKindThisType:
			fallthrough // TODO: merge cases
		case SyntaxKindThisKeyword:
			return getTypeFromThisTypeNode(node)
		case SyntaxKindLiteralType:
			return getTypeFromLiteralTypeNode(node)
		case SyntaxKindTypeReference:
			return getTypeFromTypeReference(node)
		case SyntaxKindTypePredicate:
			return /* TODO(ConditionalExpression): (node as TypePredicateNode).assertsModifier ? voidType : booleanType */ TODO
		case SyntaxKindExpressionWithTypeArguments:
			return getTypeFromTypeReference(node)
		case SyntaxKindTypeQuery:
			return getTypeFromTypeQueryNode(node)
		case SyntaxKindArrayType:
			fallthrough // TODO: merge cases
		case SyntaxKindTupleType:
			return getTypeFromArrayOrTupleTypeNode(node)
		case SyntaxKindOptionalType:
			return getTypeFromOptionalTypeNode(node)
		case SyntaxKindUnionType:
			return getTypeFromUnionTypeNode(node)
		case SyntaxKindIntersectionType:
			return getTypeFromIntersectionTypeNode(node)
		case SyntaxKindJSDocNullableType:
			return getTypeFromJSDocNullableTypeNode(node)
		case SyntaxKindJSDocOptionalType:
			return addOptionality(getTypeFromTypeNode((node).type_))
		case SyntaxKindNamedTupleMember:
			return getTypeFromNamedTupleTypeNode(node)
		case SyntaxKindParenthesizedType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocNonNullableType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocTypeExpression:
			return getTypeFromTypeNode((node).type_)
		case SyntaxKindRestType:
			return getTypeFromRestTypeNode(node)
		case SyntaxKindJSDocVariadicType:
			return getTypeFromJSDocVariadicType(node)
		case SyntaxKindFunctionType:
			fallthrough // TODO: merge cases
		case SyntaxKindConstructorType:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocTypeLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocFunctionType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocSignature:
			return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node)
		case SyntaxKindTypeOperator:
			return getTypeFromTypeOperatorNode(node)
		case SyntaxKindIndexedAccessType:
			return getTypeFromIndexedAccessTypeNode(node)
		case SyntaxKindMappedType:
			return getTypeFromMappedTypeNode(node)
		case SyntaxKindConditionalType:
			return getTypeFromConditionalTypeNode(node)
		case SyntaxKindInferType:
			return getTypeFromInferTypeNode(node)
		case SyntaxKindTemplateLiteralType:
			return getTypeFromTemplateTypeNode(node)
		case SyntaxKindImportType:
			return getTypeFromImportTypeNode(node)
		case SyntaxKindIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindQualifiedName:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAccessExpression:
			symbol := getSymbolAtLocation(node)
			return /* TODO(ConditionalExpression): symbol ? getDeclaredTypeOfSymbol(symbol) : errorType */ TODO
		default:
			return errorType
		}
	}
	// OVERLOAD: instantiateList := func(items []T, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) []T
	// OVERLOAD: instantiateList := func(items /* TODO(TypeOperator): readonly T[] */ any, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) /* TODO(TypeOperator): readonly T[] */ any
	instantiateList := func(items /* TODO(TypeOperator): readonly T[] */ any, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) /* TODO(TypeOperator): readonly T[] */ any {
		if items && items.length {
			/* TODO(ForStatement): for (let i = 0; i < items.length; i++) {                 const item = items[i];                 const mapped = instantiator(item, mapper);                 if (item !== mapped) {                     const result = i === 0 ? [] : items.slice(0, i);                     result.push(mapped);                     for (i++; i < items.length; i++) {                         result.push(instantiator(items[i], mapper));                     }                     return result;                 }             } */
		}
		return items
	}
	// OVERLOAD: instantiateTypes := func(types []Type, mapper TypeMapper) []Type
	// OVERLOAD: instantiateTypes := func(types /* TODO(TypeOperator): readonly Type[] */ any, mapper TypeMapper) /* TODO(TypeOperator): readonly Type[] */ any
	instantiateTypes := func(types /* TODO(TypeOperator): readonly Type[] */ any, mapper TypeMapper) /* TODO(TypeOperator): readonly Type[] */ any {
		return instantiateList(types, mapper, instantiateType)
	}
	instantiateSignatures := func(signatures []Signature, mapper TypeMapper) []Signature {
		return instantiateList(signatures, mapper, instantiateSignature)
	}
	instantiateIndexInfos := func(indexInfos []IndexInfo, mapper TypeMapper) []IndexInfo {
		return instantiateList(indexInfos, mapper, instantiateIndexInfo)
	}
	createTypeMapper := func(sources []TypeParameter, targets /* TODO(TypeOperator): readonly Type[] */ any) TypeMapper {
		return /* TODO(ConditionalExpression): sources.length === 1 ? makeUnaryTypeMapper(sources[0], targets ? targets[0] : anyType) : makeArrayTypeMapper(sources, targets) */ TODO
	}
	getMappedType := func(type_ Type, mapper TypeMapper) Type {
		switch mapper.kind {
		case TypeMapKindSimple:
			return /* TODO(ConditionalExpression): type === mapper.source ? mapper.target : type */ TODO
		case TypeMapKindArray:
			sources := mapper.sources
			targets := mapper.targets
			/* TODO(ForStatement): for (let i = 0; i < sources.length; i++) {                     if (type === sources[i]) {                         return targets ? targets[i] : anyType;                     }                 } */
			return type_
			fallthrough
		case TypeMapKindDeferred:
			sources := mapper.sources
			targets := mapper.targets
			/* TODO(ForStatement): for (let i = 0; i < sources.length; i++) {                     if (type === sources[i]) {                         return targets[i]();                     }                 } */
			return type_
			fallthrough
		case TypeMapKindFunction:
			return mapper.func_(type_)
		case TypeMapKindComposite:
			fallthrough // TODO: merge cases
		case TypeMapKindMerged:
			t1 := getMappedType(type_, mapper.mapper1)
			return /* TODO(ConditionalExpression): t1 !== type && mapper.kind === TypeMapKind.Composite ? instantiateType(t1, mapper.mapper2) : getMappedType(t1, mapper.mapper2) */ TODO
		}
	}
	makeUnaryTypeMapper := func(source Type, target Type) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Simple, source, target } */ TODO)
	}
	makeArrayTypeMapper := func(sources []TypeParameter, targets /* TODO(TypeOperator): readonly Type[] */ any) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Array, sources, targets } */ TODO)
	}
	makeFunctionTypeMapper := func(func_ func(t Type) Type, debugInfo func() string) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Function, func, debugInfo: Debug.isDebugging ? debugInfo : undefined } */ TODO)
	}
	makeDeferredTypeMapper := func(sources []TypeParameter, targets []func() Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Deferred, sources, targets } */ TODO)
	}
	makeCompositeTypeMapper := func(kind /* TODO(UnionType): TypeMapKind.Composite | TypeMapKind.Merged */ any, mapper1 TypeMapper, mapper2 TypeMapper) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(ObjectLiteralExpression): { kind, mapper1, mapper2 } */ TODO)
	}
	createTypeEraser := func(sources []TypeParameter) TypeMapper {
		return createTypeMapper(sources, nil)
	}
	createBackreferenceMapper := func(context InferenceContext, index number) TypeMapper {
		forwardInferences := context.inferences.slice(index)
		return createTypeMapper(map_(forwardInferences, func(i /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
			return i.typeParameter
		}), map_(forwardInferences, func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
			return unknownType
		}))
	}
	combineTypeMappers := func(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
		return /* TODO(ConditionalExpression): mapper1 ? makeCompositeTypeMapper(TypeMapKind.Composite, mapper1, mapper2) : mapper2 */ TODO
	}
	mergeTypeMappers := func(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
		return /* TODO(ConditionalExpression): mapper1 ? makeCompositeTypeMapper(TypeMapKind.Merged, mapper1, mapper2) : mapper2 */ TODO
	}
	prependTypeMapping := func(source Type, target Type, mapper *TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return /* TODO(ConditionalExpression): !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, makeUnaryTypeMapper(source, target), mapper) */ TODO
	}
	appendTypeMapping := func(mapper *TypeMapper, source Type, target Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return /* TODO(ConditionalExpression): !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, mapper, makeUnaryTypeMapper(source, target)) */ TODO
	}
	getRestrictiveTypeParameter := func(tp TypeParameter) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): !tp.constraint && !getConstraintDeclaration(tp) || tp.constraint === noConstraintType ? tp : tp.restrictiveInstantiation || (             tp.restrictiveInstantiation = createTypeParameter(tp.symbol), (tp.restrictiveInstantiation as TypeParameter).constraint = noConstraintType, tp.restrictiveInstantiation         ) */ TODO
	}
	cloneTypeParameter := func(typeParameter TypeParameter) TypeParameter {
		result := createTypeParameter(typeParameter.symbol)
		result.target = typeParameter
		return result
	}
	instantiateTypePredicate := func(predicate TypePredicate, mapper TypeMapper) TypePredicate {
		return createTypePredicate(predicate.kind, predicate.parameterName, predicate.parameterIndex, instantiateType(predicate.type_, mapper))
	}
	instantiateSignature := func(signature Signature, mapper TypeMapper, eraseTypeParameters bool) Signature {
		var freshTypeParameters /* TODO(ArrayType): TypeParameter[] */ any
		if signature.typeParameters && !eraseTypeParameters {
			freshTypeParameters = map_(signature.typeParameters, cloneTypeParameter)
			mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper)
			for _, tp := range freshTypeParameters {
				tp.mapper = mapper
			}
		}
		result := createSignature(signature.declaration, freshTypeParameters, signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper), instantiateList(signature.parameters, mapper, instantiateSymbol), nil, nil, signature.minArgumentCount, signature.flags&SignatureFlagsPropagatingFlags)
		result.target = signature
		result.mapper = mapper
		return result
	}
	instantiateSymbol := func(symbol Symbol, mapper TypeMapper) Symbol {
		links := getSymbolLinks(symbol)
		if links.type_ && !couldContainTypeVariables(links.type_) {
			if !(symbol.flags & SymbolFlagsSetAccessor) {
				return symbol
			}
			if links.writeType && !couldContainTypeVariables(links.writeType) {
				return symbol
			}
		}
		if getCheckFlags(symbol) & CheckFlagsInstantiated {
			symbol = links.target
			mapper = combineTypeMappers(links.mapper, mapper)
		}
		result := createSymbol(symbol.flags, symbol.escapedName, CheckFlagsInstantiated|getCheckFlags(symbol)&(CheckFlagsReadonly|CheckFlagsLate|CheckFlagsOptionalParameter|CheckFlagsRestParameter))
		result.declarations = symbol.declarations
		result.parent = symbol.parent
		result.links.target = symbol
		result.links.mapper = mapper
		if symbol.valueDeclaration {
			result.valueDeclaration = symbol.valueDeclaration
		}
		if links.nameType {
			result.links.nameType = links.nameType
		}
		return result
	}
	getObjectTypeInstantiation := func(type_ /* TODO(UnionType): AnonymousType | DeferredTypeReference */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		declaration := /* TODO(ConditionalExpression): type.objectFlags & ObjectFlags.Reference ? (type as TypeReference).node! :             type.objectFlags & ObjectFlags.InstantiationExpressionType ? (type as InstantiationExpressionType).node :             type.symbol.declarations![0] */ TODO
		links := getNodeLinks(declaration)
		target := /* TODO(ConditionalExpression): type.objectFlags & ObjectFlags.Reference ? links.resolvedType! as DeferredTypeReference :             type.objectFlags & ObjectFlags.Instantiated ? type.target! : type */ TODO
		typeParameters := /* TODO(ConditionalExpression): type.objectFlags & ObjectFlags.SingleSignatureType ? (type as SingleSignatureType).outerTypeParameters : links.outerTypeParameters */ TODO
		if !typeParameters {
			outerTypeParameters := getOuterTypeParameters(declaration, true)
			if isJSConstructor(declaration) {
				templateTagParameters := getTypeParametersFromDeclaration(declaration)
				outerTypeParameters = addRange(outerTypeParameters, templateTagParameters)
			}
			typeParameters = outerTypeParameters || emptyArray
			allDeclarations := /* TODO(ConditionalExpression): type.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) ? [declaration] : type.symbol.declarations! */ TODO
			typeParameters = /* TODO(ConditionalExpression): (target.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) || target.symbol.flags & SymbolFlags.Method || target.symbol.flags & SymbolFlags.TypeLiteral) && !target.aliasTypeArguments ?                 filter(typeParameters, tp => some(allDeclarations, d => isTypeParameterPossiblyReferenced(tp, d))) :                 typeParameters */ TODO
			links.outerTypeParameters = typeParameters
		}
		if typeParameters.length {
			combinedMapper := combineTypeMappers(type_.mapper, mapper)
			typeArguments := map_(typeParameters, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return getMappedType(t, combinedMapper)
			})
			newAliasSymbol := aliasSymbol || type_.aliasSymbol
			newAliasTypeArguments := /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
			id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (type.objectFlags & ObjectFlags.SingleSignatureType ? "S" : "") + getTypeListId(typeArguments) + getAliasId(newAliasSymbol, newAliasTypeArguments) */ TODO
			if !target.instantiations {
				target.instantiations = make(map[string]Type)
				target.instantiations.set( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): getTypeListId(typeParameters) + getAliasId(target.aliasSymbol, target.aliasTypeArguments) */ TODO, target)
			}
			result := target.instantiations.get(id)
			if !result {
				if type_.objectFlags & ObjectFlagsSingleSignatureType {
					result = instantiateAnonymousType(type_, mapper)
					target.instantiations.set(id, result)
					return result
				}
				newMapper := createTypeMapper(typeParameters, typeArguments)
				result = /* TODO(ConditionalExpression): target.objectFlags & ObjectFlags.Reference ? createDeferredTypeReference((type as DeferredTypeReference).target, (type as DeferredTypeReference).node, newMapper, newAliasSymbol, newAliasTypeArguments) :                     target.objectFlags & ObjectFlags.Mapped ? instantiateMappedType(target as MappedType, newMapper, newAliasSymbol, newAliasTypeArguments) :                     instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments) */ TODO
				target.instantiations.set(id, result)
				resultObjectFlags := getObjectFlags(result)
				if result.flags&TypeFlagsObjectFlagsType && !(resultObjectFlags & ObjectFlagsCouldContainTypeVariablesComputed) {
					resultCouldContainTypeVariables := some(typeArguments, couldContainTypeVariables)
					if !(getObjectFlags(result) & ObjectFlagsCouldContainTypeVariablesComputed) {
						if resultObjectFlags & (ObjectFlagsMapped | ObjectFlagsAnonymous | ObjectFlagsReference) {
							(result).objectFlags |= ObjectFlagsCouldContainTypeVariablesComputed | ( /* TODO(ConditionalExpression): resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariables : 0 */ TODO)
						} else {
							(result).objectFlags |= /* TODO(ConditionalExpression): !resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariablesComputed : 0 */ TODO
						}
					}
				}
			}
			return result
		}
		return type_
	}
	maybeTypeParameterReference := func(node Node) /* TODO inferred type boolean */ TODO {
		return !(node.parent.kind == SyntaxKindTypeReference && (node.parent).typeArguments && node == (node.parent).typeName || node.parent.kind == SyntaxKindImportType && (node.parent).typeArguments && node == (node.parent).qualifier)
	}
	isTypeParameterPossiblyReferenced := func(tp TypeParameter, node Node) /* TODO inferred type boolean */ TODO {
		if tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length == 1 {
			container := /* TODO(ElementAccessExpression): tp.symbol.declarations[0] */ TODO.parent
			/* TODO(ForStatement): for (let n = node; n !== container; n = n.parent) {                 if (!n || n.kind === SyntaxKind.Block || n.kind === SyntaxKind.ConditionalType && forEachChild((n as ConditionalTypeNode).extendsType, containsReference)) {                     return true;                 }             } */
			return containsReference(node)
		}
		return true
		containsReference := func(node Node) bool {
			switch node.kind {
			case SyntaxKindThisType:
				return !!tp.isThisType
			case SyntaxKindIdentifier:
				return !tp.isThisType && isPartOfTypeNode(node) && maybeTypeParameterReference(node) && getTypeFromTypeNodeWorker(node) == tp
			case SyntaxKindTypeQuery:
				entityName := (node).exprName
				firstIdentifier := getFirstIdentifier(entityName)
				if !isThisIdentifier(firstIdentifier) {
					firstIdentifierSymbol := getResolvedSymbol(firstIdentifier)
					tpDeclaration := /* TODO(ElementAccessExpression): tp.symbol.declarations![0] */ TODO
					tpScope := /* TODO(ConditionalExpression): tpDeclaration.kind === SyntaxKind.TypeParameter ? tpDeclaration.parent : // Type parameter is a regular type parameter, e.g. foo<T>                             tp.isThisType ? tpDeclaration : // Type parameter is the this type, and its declaration is the class declaration.                             undefined */ TODO
					if firstIdentifierSymbol.declarations && tpScope {
						return some(firstIdentifierSymbol.declarations, func(idDecl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
							return isNodeDescendantOf(idDecl, tpScope)
						}) || some((node).typeArguments, containsReference)
					}
				}
				return true
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodSignature:
				return !(node).type_ && !!(node).body || some((node).typeParameters, containsReference) || some((node).parameters, containsReference) || !!(node).type_ && containsReference((node).type_)
			}
			return !!forEachChild(node, containsReference)
		}
	}
	getHomomorphicTypeVariable := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter | undefined */ TODO {
		constraintType := getConstraintTypeFromMappedType(type_)
		if constraintType.flags & TypeFlagsIndex {
			typeVariable := getActualTypeVariable((constraintType).type_)
			if typeVariable.flags & TypeFlagsTypeParameter {
				return typeVariable
			}
		}
		return nil
	}
	instantiateMappedType := func(type_ MappedType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		typeVariable := getHomomorphicTypeVariable(type_)
		if typeVariable {
			mappedTypeVariable := instantiateType(typeVariable, mapper)
			if typeVariable != mappedTypeVariable {
				return mapTypeWithAlias(getReducedType(mappedTypeVariable), instantiateConstituent, aliasSymbol, aliasTypeArguments)
			}
		}
		return /* TODO(ConditionalExpression): instantiateType(getConstraintTypeFromMappedType(type), mapper) === wildcardType ? wildcardType : instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments) */ TODO
		instantiateConstituent := func(t Type) Type {
			if t.flags&(TypeFlagsAnyOrUnknown|TypeFlagsInstantiableNonPrimitive|TypeFlagsObject|TypeFlagsIntersection) && t != wildcardType && !isErrorType(t) {
				if !type_.declaration.nameType {
					var constraint TODO
					if isArrayType(t) || t.flags&TypeFlagsAny && findResolutionCycleStartIndex(typeVariable, TypeSystemPropertyNameImmediateBaseConstraint) < 0 && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): constraint = getConstraintOfTypeParameter(typeVariable!) */ TODO) && everyType(constraint, isArrayOrTupleType) {
						return instantiateMappedArrayType(t, type_, prependTypeMapping(typeVariable, t, mapper))
					}
					if isTupleType(t) {
						return instantiateMappedTupleType(t, type_, typeVariable, mapper)
					}
					if isArrayOrTupleOrIntersection(t) {
						return getIntersectionType(map_((t).types, instantiateConstituent))
					}
				}
				return instantiateAnonymousType(type_, prependTypeMapping(typeVariable, t, mapper))
			}
			return t
		}
	}
	getModifiedReadonlyState := func(state bool, modifiers MappedTypeModifiers) /* TODO inferred type boolean */ TODO {
		return /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeReadonly ? true : modifiers & MappedTypeModifiers.ExcludeReadonly ? false : state */ TODO
	}
	instantiateMappedTupleType := func(tupleType TupleTypeReference, mappedType MappedType, typeVariable TypeVariable, mapper TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		elementFlags := tupleType.target.elementFlags
		fixedLength := tupleType.target.fixedLength
		fixedMapper := /* TODO(ConditionalExpression): fixedLength ? prependTypeMapping(typeVariable, tupleType, mapper) : mapper */ TODO
		newElementTypes := map_(getElementTypes(tupleType), func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			flags := /* TODO(ElementAccessExpression): elementFlags[i] */ TODO
			return /* TODO(ConditionalExpression): i < fixedLength ? instantiateMappedTypeTemplate(mappedType, getStringLiteralType("" + i), !!(flags & ElementFlags.Optional), fixedMapper) :                 flags & ElementFlags.Variadic ? instantiateType(mappedType, prependTypeMapping(typeVariable, type, mapper)) :                 getElementTypeOfArrayType(instantiateType(mappedType, prependTypeMapping(typeVariable, createArrayType(type), mapper))) ?? unknownType */ TODO
		})
		modifiers := getMappedTypeModifiers(mappedType)
		newElementFlags := /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeOptional ? map(elementFlags, f => f & ElementFlags.Required ? ElementFlags.Optional : f) :             modifiers & MappedTypeModifiers.ExcludeOptional ? map(elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) :             elementFlags */ TODO
		newReadonly := getModifiedReadonlyState(tupleType.target.readonly, getMappedTypeModifiers(mappedType))
		return /* TODO(ConditionalExpression): contains(newElementTypes, errorType) ? errorType :             createTupleType(newElementTypes, newElementFlags, newReadonly, tupleType.target.labeledElementDeclarations) */ TODO
	}
	instantiateMappedArrayType := func(arrayType Type, mappedType MappedType, mapper TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType | import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		elementType := instantiateMappedTypeTemplate(mappedType, numberType, true, mapper)
		return /* TODO(ConditionalExpression): isErrorType(elementType) ? errorType :             createArrayType(elementType, getModifiedReadonlyState(isReadonlyArrayType(arrayType), getMappedTypeModifiers(mappedType))) */ TODO
	}
	instantiateMappedTypeTemplate := func(type_ MappedType, key Type, isOptional bool, mapper TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		templateMapper := appendTypeMapping(mapper, getTypeParameterFromMappedType(type_), key)
		propType := instantiateType(getTemplateTypeFromMappedType(type_.target || type_), templateMapper)
		modifiers := getMappedTypeModifiers(type_)
		return /* TODO(ConditionalExpression): strictNullChecks && modifiers & MappedTypeModifiers.IncludeOptional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void) ? getOptionalType(propType, /*isProperty* / true) :             strictNullChecks && modifiers & MappedTypeModifiers.ExcludeOptional && isOptional ? getTypeWithFacts(propType, TypeFacts.NEUndefined) :             propType */ TODO
	}
	instantiateAnonymousType := func(type_ AnonymousType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) AnonymousType {
		Debug.assert(type_.symbol, "anonymous type must have symbol to be instantiated")
		result := createObjectType(type_.objectFlags&~(ObjectFlagsCouldContainTypeVariablesComputed|ObjectFlagsCouldContainTypeVariables)|ObjectFlagsInstantiated, type_.symbol)
		if type_.objectFlags & ObjectFlagsMapped {
			(result).declaration = (type_).declaration
			origTypeParameter := getTypeParameterFromMappedType(type_)
			freshTypeParameter := cloneTypeParameter(origTypeParameter)
			(result).typeParameter = freshTypeParameter
			mapper = combineTypeMappers(makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper)
			freshTypeParameter.mapper = mapper
		}
		if type_.objectFlags & ObjectFlagsInstantiationExpressionType {
			(result).node = (type_).node
		}
		if type_.objectFlags & ObjectFlagsSingleSignatureType {
			(result).outerTypeParameters = (type_).outerTypeParameters
		}
		result.target = type_
		result.mapper = mapper
		result.aliasSymbol = aliasSymbol || type_.aliasSymbol
		result.aliasTypeArguments = /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
		result.objectFlags |= /* TODO(ConditionalExpression): result.aliasTypeArguments ? getPropagatingFlagsOfTypes(result.aliasTypeArguments) : 0 */ TODO
		return result
	}
	getConditionalTypeInstantiation := func(type_ ConditionalType, mapper TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		root := type_.root
		if root.outerTypeParameters {
			typeArguments := map_(root.outerTypeParameters, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return getMappedType(t, mapper)
			})
			id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (forConstraint ? "C" : "") + getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
			result := root.instantiations.get(id)
			if !result {
				newMapper := createTypeMapper(root.outerTypeParameters, typeArguments)
				checkType := root.checkType
				distributionType := /* TODO(ConditionalExpression): root.isDistributive ? getReducedType(getMappedType(checkType, newMapper)) : undefined */ TODO
				result = /* TODO(ConditionalExpression): distributionType && checkType !== distributionType && distributionType.flags & (TypeFlags.Union | TypeFlags.Never) ?                     mapTypeWithAlias(distributionType, t => getConditionalType(root, prependTypeMapping(checkType, t, newMapper), forConstraint), aliasSymbol, aliasTypeArguments) :                     getConditionalType(root, newMapper, forConstraint, aliasSymbol, aliasTypeArguments) */ TODO
				root.instantiations.set(id, result)
			}
			return result
		}
		return type_
	}
	// OVERLOAD: instantiateType := func(type_ Type, mapper *TypeMapper) Type
	// OVERLOAD: instantiateType := func(type_ *Type, mapper *TypeMapper) *Type
	instantiateType := func(type_ *Type, mapper *TypeMapper) *Type {
		return /* TODO(ConditionalExpression): type && mapper ? instantiateTypeWithAlias(type, mapper, /*aliasSymbol* / undefined, /*aliasTypeArguments* / undefined) : type */ TODO
	}
	instantiateTypeWithAlias := func(type_ Type, mapper TypeMapper, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) Type {
		if !couldContainTypeVariables(type_) {
			return type_
		}
		if instantiationDepth == 100 || instantiationCount >= 5000000 {
			tracing.instant(tracing.Phase.CheckTypes, "instantiateType_DepthLimit" /* TODO(ObjectLiteralExpression): { typeId: type.id, instantiationDepth, instantiationCount } */, TODO)
			error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite)
			return errorType
		}
		totalInstantiationCount++
		instantiationCount++
		instantiationDepth++
		result := instantiateTypeWorker(type_, mapper, aliasSymbol, aliasTypeArguments)
		instantiationDepth--
		return result
	}
	instantiateTypeWorker := func(type_ Type, mapper TypeMapper, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) Type {
		flags := type_.flags
		if flags & TypeFlagsTypeParameter {
			return getMappedType(type_, mapper)
		}
		if flags & TypeFlagsObject {
			objectFlags := (type_).objectFlags
			if objectFlags & (ObjectFlagsReference | ObjectFlagsAnonymous | ObjectFlagsMapped) {
				if objectFlags&ObjectFlagsReference && !(type_).node {
					resolvedTypeArguments := (type_).resolvedTypeArguments
					newTypeArguments := instantiateTypes(resolvedTypeArguments, mapper)
					return /* TODO(ConditionalExpression): newTypeArguments !== resolvedTypeArguments ? createNormalizedTypeReference((type as TypeReference).target, newTypeArguments) : type */ TODO
				}
				if objectFlags & ObjectFlagsReverseMapped {
					return instantiateReverseMappedType(type_, mapper)
				}
				return getObjectTypeInstantiation(type_, mapper, aliasSymbol, aliasTypeArguments)
			}
			return type_
		}
		if flags & TypeFlagsUnionOrIntersection {
			origin := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).origin : undefined */ TODO
			types := /* TODO(ConditionalExpression): origin && origin.flags & TypeFlags.UnionOrIntersection ? (origin as UnionOrIntersectionType).types : (type as UnionOrIntersectionType).types */ TODO
			newTypes := instantiateTypes(types, mapper)
			if newTypes == types && aliasSymbol == type_.aliasSymbol {
				return type_
			}
			newAliasSymbol := aliasSymbol || type_.aliasSymbol
			newAliasTypeArguments := /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
			return /* TODO(ConditionalExpression): flags & TypeFlags.Intersection || origin && origin.flags & TypeFlags.Intersection ?                 getIntersectionType(newTypes, IntersectionFlags.None, newAliasSymbol, newAliasTypeArguments) :                 getUnionType(newTypes, UnionReduction.Literal, newAliasSymbol, newAliasTypeArguments) */ TODO
		}
		if flags & TypeFlagsIndex {
			return getIndexType(instantiateType((type_).type_, mapper))
		}
		if flags & TypeFlagsTemplateLiteral {
			return getTemplateLiteralType((type_).texts, instantiateTypes((type_).types, mapper))
		}
		if flags & TypeFlagsStringMapping {
			return getStringMappingType((type_).symbol, instantiateType((type_).type_, mapper))
		}
		if flags & TypeFlagsIndexedAccess {
			newAliasSymbol := aliasSymbol || type_.aliasSymbol
			newAliasTypeArguments := /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
			return getIndexedAccessType(instantiateType((type_).objectType, mapper), instantiateType((type_).indexType, mapper), (type_).accessFlags, nil, newAliasSymbol, newAliasTypeArguments)
		}
		if flags & TypeFlagsConditional {
			return getConditionalTypeInstantiation(type_, combineTypeMappers((type_).mapper, mapper), false, aliasSymbol, aliasTypeArguments)
		}
		if flags & TypeFlagsSubstitution {
			newBaseType := instantiateType((type_).baseType, mapper)
			if isNoInferType(type_) {
				return getNoInferType(newBaseType)
			}
			newConstraint := instantiateType((type_).constraint, mapper)
			if newBaseType.flags&TypeFlagsTypeVariable && isGenericType(newConstraint) {
				return getSubstitutionType(newBaseType, newConstraint)
			}
			if newConstraint.flags&TypeFlagsAnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(newBaseType), getRestrictiveInstantiation(newConstraint)) {
				return newBaseType
			}
			return /* TODO(ConditionalExpression): newBaseType.flags & TypeFlags.TypeVariable ? getSubstitutionType(newBaseType, newConstraint) : getIntersectionType([newConstraint, newBaseType]) */ TODO
		}
		return type_
	}
	instantiateReverseMappedType := func(type_ ReverseMappedType, mapper TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		innerMappedType := instantiateType(type_.mappedType, mapper)
		if !(getObjectFlags(innerMappedType) & ObjectFlagsMapped) {
			return type_
		}
		innerIndexType := instantiateType(type_.constraintType, mapper)
		if !(innerIndexType.flags & TypeFlagsIndex) {
			return type_
		}
		instantiated := inferTypeForHomomorphicMappedType(instantiateType(type_.source, mapper), innerMappedType, innerIndexType)
		if instantiated {
			return instantiated
		}
		return type_
	}
	getPermissiveInstantiation := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never) ? type :             type.permissiveInstantiation || (type.permissiveInstantiation = instantiateType(type, permissiveMapper)) */ TODO
	}
	getRestrictiveInstantiation := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if type_.flags & (TypeFlagsPrimitive | TypeFlagsAnyOrUnknown | TypeFlagsNever) {
			return type_
		}
		if type_.restrictiveInstantiation {
			return type_.restrictiveInstantiation
		}
		type_.restrictiveInstantiation = instantiateType(type_, restrictiveMapper)
		type_.restrictiveInstantiation.restrictiveInstantiation = type_.restrictiveInstantiation
		return type_.restrictiveInstantiation
	}
	instantiateIndexInfo := func(info IndexInfo, mapper TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO {
		return createIndexInfo(info.keyType, instantiateType(info.type_, mapper), info.isReadonly, info.declaration)
	}
	isContextSensitive := func(node /* TODO(UnionType): Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike | JsxChild */ any) bool {
		Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
		switch node.kind {
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionDeclaration:
			return isContextSensitiveFunctionLikeDeclaration(node)
		case SyntaxKindObjectLiteralExpression:
			return some((node).properties, isContextSensitive)
		case SyntaxKindArrayLiteralExpression:
			return some((node).elements, isContextSensitive)
		case SyntaxKindConditionalExpression:
			return isContextSensitive((node).whenTrue) || isContextSensitive((node).whenFalse)
		case SyntaxKindBinaryExpression:
			return ((node).operatorToken.kind == SyntaxKindBarBarToken || (node).operatorToken.kind == SyntaxKindQuestionQuestionToken) && (isContextSensitive((node).left) || isContextSensitive((node).right))
		case SyntaxKindPropertyAssignment:
			return isContextSensitive((node).initializer)
		case SyntaxKindParenthesizedExpression:
			return isContextSensitive((node).expression)
		case SyntaxKindJsxAttributes:
			return some((node).properties, isContextSensitive) || isJsxOpeningElement(node.parent) && some(node.parent.parent.children, isContextSensitive)
		case SyntaxKindJsxAttribute:
			TODO_IDENTIFIER := node
			return !!initializer && isContextSensitive(initializer)
			fallthrough
		case SyntaxKindJsxExpression:
			TODO_IDENTIFIER := node
			return !!expression && isContextSensitive(expression)
		}
		return false
	}
	isContextSensitiveFunctionLikeDeclaration := func(node FunctionLikeDeclaration) bool {
		return hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node)
	}
	hasContextSensitiveReturnExpression := func(node FunctionLikeDeclaration) /* TODO inferred type boolean */ TODO {
		if node.typeParameters || getEffectiveReturnTypeNode(node) || !node.body {
			return false
		}
		if node.body.kind != SyntaxKindBlock {
			return isContextSensitive(node.body)
		}
		return !!forEachReturnStatement(node.body, func(statement /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ReturnStatement */ TODO) /* TODO inferred type boolean */ TODO {
			return !!statement.expression && isContextSensitive(statement.expression)
		})
	}
	isContextSensitiveFunctionOrObjectLiteralMethod := func(func_ Node) /* TODO(TypePredicate): func is FunctionExpression | ArrowFunction | MethodDeclaration */ any {
		return (isFunctionExpressionOrArrowFunction(func_) || isObjectLiteralMethod(func_)) && isContextSensitiveFunctionLikeDeclaration(func_)
	}
	getTypeWithoutSignatures := func(type_ Type) Type {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_)
			if resolved.constructSignatures.length || resolved.callSignatures.length {
				result := createObjectType(ObjectFlagsAnonymous, type_.symbol)
				result.members = resolved.members
				result.properties = resolved.properties
				result.callSignatures = emptyArray
				result.constructSignatures = emptyArray
				result.indexInfos = emptyArray
				return result
			}
		} else if type_.flags & TypeFlagsIntersection {
			return getIntersectionType(map_((type_).types, getTypeWithoutSignatures))
		}
		return type_
	}
	isTypeIdenticalTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, identityRelation)
	}
	compareTypesIdentical := func(source Type, target Type) Ternary {
		return /* TODO(ConditionalExpression): isTypeRelatedTo(source, target, identityRelation) ? Ternary.True : Ternary.False */ TODO
	}
	compareTypesAssignable := func(source Type, target Type) Ternary {
		return /* TODO(ConditionalExpression): isTypeRelatedTo(source, target, assignableRelation) ? Ternary.True : Ternary.False */ TODO
	}
	compareTypesSubtypeOf := func(source Type, target Type) Ternary {
		return /* TODO(ConditionalExpression): isTypeRelatedTo(source, target, subtypeRelation) ? Ternary.True : Ternary.False */ TODO
	}
	isTypeSubtypeOf := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, subtypeRelation)
	}
	isTypeStrictSubtypeOf := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, strictSubtypeRelation)
	}
	isTypeAssignableTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, assignableRelation)
	}
	isTypeDerivedFrom := func(source Type, target Type) bool {
		return /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? every((source as UnionType).types, t => isTypeDerivedFrom(t, target)) :             target.flags & TypeFlags.Union ? some((target as UnionType).types, t => isTypeDerivedFrom(source, t)) :             source.flags & TypeFlags.Intersection ? some((source as IntersectionType).types, t => isTypeDerivedFrom(t, target)) :             source.flags & TypeFlags.InstantiableNonPrimitive ? isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target) :             isEmptyAnonymousObjectType(target) ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive)) :             target === globalObjectType ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive)) && !isEmptyAnonymousObjectType(source) :             target === globalFunctionType ? !!(source.flags & TypeFlags.Object) && isFunctionObjectType(source as ObjectType) :             hasBaseType(source, getTargetType(target)) || (isArrayType(target) && !isReadonlyArrayType(target) && isTypeDerivedFrom(source, globalReadonlyArrayType)) */ TODO
	}
	isTypeComparableTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, comparableRelation)
	}
	areTypesComparable := func(type1 Type, type2 Type) bool {
		return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1)
	}
	checkTypeAssignableTo := func(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputObject /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ any) bool {
		return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject)
	}
	checkTypeAssignableToAndOptionallyElaborate := func(source Type, target Type, errorNode Node, expr *Expression, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
		return checkTypeRelatedToAndOptionallyElaborate(source, target, assignableRelation, errorNode, expr, headMessage, containingMessageChain, nil)
	}
	checkTypeRelatedToAndOptionallyElaborate := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, expr *Expression, headMessage *DiagnosticMessage, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if isTypeRelatedTo(source, target, relation) {
			return true
		}
		if !errorNode || !elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
			return checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer)
		}
		return false
	}
	isOrHasGenericConditional := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsConditional || (type_.flags&TypeFlagsIntersection && some((type_).types, isOrHasGenericConditional)))
	}
	elaborateError := func(node *Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if !node || isOrHasGenericConditional(target) {
			return false
		}
		if !checkTypeRelatedTo(source, target, relation, nil) && elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
			return true
		}
		switch node.kind {
		case SyntaxKindAsExpression:
			if !isConstAssertion(node) {
				break
			}
			fallthrough
		case SyntaxKindJsxExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindParenthesizedExpression:
			return elaborateError((node).expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)
		case SyntaxKindBinaryExpression:
			switch (node).operatorToken.kind {
			case SyntaxKindEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindCommaToken:
				return elaborateError((node).right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)
			}
			break
		case SyntaxKindObjectLiteralExpression:
			return elaborateObjectLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer)
		case SyntaxKindArrayLiteralExpression:
			return elaborateArrayLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer)
		case SyntaxKindJsxAttributes:
			return elaborateJsxComponents(node, source, target, relation, containingMessageChain, errorOutputContainer)
		case SyntaxKindArrowFunction:
			return elaborateArrowFunction(node, source, target, relation, containingMessageChain, errorOutputContainer)
		}
		return false
	}
	elaborateDidYouMeanToCallOrConstruct := func(node Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		callSignatures := getSignaturesOfType(source, SignatureKindCall)
		constructSignatures := getSignaturesOfType(source, SignatureKindConstruct)
		for _, signatures := range /* TODO(ArrayLiteralExpression): [constructSignatures, callSignatures] */ TODO {
			if some(signatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
				returnType := getReturnTypeOfSignature(s)
				return !(returnType.flags & (TypeFlagsAny | TypeFlagsNever)) && checkTypeRelatedTo(returnType, target, relation, nil)
			}) {
				var resultObj /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ any = errorOutputContainer || /* TODO(ObjectLiteralExpression): {} */ TODO
				checkTypeAssignableTo(source, target, node, headMessage, containingMessageChain, resultObj)
				diagnostic := /* TODO(ElementAccessExpression): resultObj.errors![resultObj.errors!.length - 1] */ TODO
				addRelatedInfo(diagnostic, createDiagnosticForNode(node /* TODO(ConditionalExpression): signatures === constructSignatures ? Diagnostics.Did_you_mean_to_use_new_with_this_expression : Diagnostics.Did_you_mean_to_call_this_expression */, TODO))
				return true
			}
		}
		return false
	}
	elaborateArrowFunction := func(node ArrowFunction, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if isBlock(node.body) {
			return false
		}
		if some(node.parameters, hasType) {
			return false
		}
		sourceSig := getSingleCallSignature(source)
		if !sourceSig {
			return false
		}
		targetSignatures := getSignaturesOfType(target, SignatureKindCall)
		if !length(targetSignatures) {
			return false
		}
		returnExpression := node.body
		sourceReturn := getReturnTypeOfSignature(sourceSig)
		targetReturn := getUnionType(map_(targetSignatures, getReturnTypeOfSignature))
		if !checkTypeRelatedTo(sourceReturn, targetReturn, relation, nil) {
			elaborated := returnExpression && elaborateError(returnExpression, sourceReturn, targetReturn, relation, nil, containingMessageChain, errorOutputContainer)
			if elaborated {
				return elaborated
			}
			var resultObj /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ any = errorOutputContainer || /* TODO(ObjectLiteralExpression): {} */ TODO
			checkTypeRelatedTo(sourceReturn, targetReturn, relation, returnExpression, nil, containingMessageChain, resultObj)
			if resultObj.errors {
				if target.symbol && length(target.symbol.declarations) {
					addRelatedInfo( /* TODO(ElementAccessExpression): resultObj.errors[resultObj.errors.length - 1] */ TODO, createDiagnosticForNode( /* TODO(ElementAccessExpression): target.symbol.declarations![0] */ TODO, Diagnostics.The_expected_type_comes_from_the_return_type_of_this_signature))
				}
				if (getFunctionFlags(node)&FunctionFlagsAsync) == 0 && !getTypeOfPropertyOfType(sourceReturn, "then") && checkTypeRelatedTo(createPromiseType(sourceReturn), targetReturn, relation, nil) {
					addRelatedInfo( /* TODO(ElementAccessExpression): resultObj.errors[resultObj.errors.length - 1] */ TODO, createDiagnosticForNode(node, Diagnostics.Did_you_mean_to_mark_this_function_as_async))
				}
				return true
			}
		}
		return false
	}
	getBestMatchIndexedAccessTypeOrUndefined := func(source Type, target Type, nameType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		idx := getIndexedAccessTypeOrUndefined(target, nameType)
		if idx {
			return idx
		}
		if target.flags & TypeFlagsUnion {
			best := getBestMatchingType(source, target)
			if best {
				return getIndexedAccessTypeOrUndefined(best, nameType)
			}
		}
	}
	checkExpressionForMutableLocationWithContextualType := func(next Expression, sourcePropType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		pushContextualType(next, sourcePropType, false)
		result := checkExpressionForMutableLocation(next, CheckModeContextual)
		popContextualType()
		return result
	}
	type ElaborationIterator IterableIterator[ /* TODO(TypeLiteral): { errorNode: Node; innerExpression: Expression | undefined; nameType: Type; errorMessage?: DiagnosticMessage | undefined; } */ any]
	elaborateElementwise := func(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO inferred type boolean */ TODO {
		reportedError := false
		for _, value := range iterator {
			TODO_IDENTIFIER := value
			targetPropType := getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType)
			if !targetPropType || targetPropType.flags&TypeFlagsIndexedAccess {
				continue
			}
			sourcePropType := getIndexedAccessTypeOrUndefined(source, nameType)
			if !sourcePropType {
				continue
			}
			propName := getPropertyNameFromIndex(nameType, nil)
			if !checkTypeRelatedTo(sourcePropType, targetPropType, relation, nil) {
				elaborated := next && elaborateError(next, sourcePropType, targetPropType, relation, nil, containingMessageChain, errorOutputContainer)
				reportedError = true
				if !elaborated {
					var resultObj /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ any = errorOutputContainer || /* TODO(ObjectLiteralExpression): {} */ TODO
					specificSource := /* TODO(ConditionalExpression): next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType */ TODO
					if exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType) {
						diag := createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType))
						diagnostics.add(diag)
						resultObj.errors = /* TODO(ArrayLiteralExpression): [diag] */ TODO
					} else {
						targetIsOptional := !!(propName && (getPropertyOfType(target, propName) || unknownSymbol).flags&SymbolFlagsOptional)
						sourceIsOptional := !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags&SymbolFlagsOptional)
						targetPropType = removeMissingType(targetPropType, targetIsOptional)
						sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional)
						result := checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						if result && specificSource != sourcePropType {
							checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						}
					}
					if resultObj.errors {
						reportedDiag := /* TODO(ElementAccessExpression): resultObj.errors[resultObj.errors.length - 1] */ TODO
						propertyName := /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined */ TODO
						targetProp := /* TODO(ConditionalExpression): propertyName !== undefined ? getPropertyOfType(target, propertyName) : undefined */ TODO
						issuedElaboration := false
						if !targetProp {
							indexInfo := getApplicableIndexInfo(target, nameType)
							if indexInfo && indexInfo.declaration && !getSourceFileOfNode(indexInfo.declaration).hasNoDefaultLib {
								issuedElaboration = true
								addRelatedInfo(reportedDiag, createDiagnosticForNode(indexInfo.declaration, Diagnostics.The_expected_type_comes_from_this_index_signature))
							}
						}
						if !issuedElaboration && (targetProp && length(targetProp.declarations) || target.symbol && length(target.symbol.declarations)) {
							targetNode := /* TODO(ConditionalExpression): targetProp && length(targetProp.declarations) ? targetProp.declarations![0] : target.symbol.declarations![0] */ TODO
							if !getSourceFileOfNode(targetNode).hasNoDefaultLib {
								addRelatedInfo(reportedDiag, createDiagnosticForNode(targetNode, Diagnostics.The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1 /* TODO(ConditionalExpression): propertyName && !(nameType.flags & TypeFlags.UniqueESSymbol) ? unescapeLeadingUnderscores(propertyName) : typeToString(nameType) */, TODO, typeToString(target)))
							}
						}
					}
				}
			}
		}
		return reportedError
	}
	elaborateIterableOrArrayLikeTargetElementwise := func(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO inferred type boolean */ TODO {
		tupleOrArrayLikeTargetParts := filterType(target, isArrayOrTupleLikeType)
		nonTupleOrArrayLikeTargetParts := filterType(target, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return !isArrayOrTupleLikeType(t)
		})
		iterationType := /* TODO(ConditionalExpression): nonTupleOrArrayLikeTargetParts !== neverType             ? getIterationTypeOfIterable(IterationUse.ForOf, IterationTypeKind.Yield, nonTupleOrArrayLikeTargetParts, /*errorNode* / undefined)             : undefined */ TODO
		reportedError := false
		/* TODO(ForStatement): for (let status = iterator.next(); !status.done; status = iterator.next()) {             const { errorNode: prop, innerExpression: next, nameType, errorMessage } = status.value;             let targetPropType = iterationType;             const targetIndexedPropType = tupleOrArrayLikeTargetParts !== neverType ? getBestMatchIndexedAccessTypeOrUndefined(source, tupleOrArrayLikeTargetParts, nameType) : undefined;             if (targetIndexedPropType && !(targetIndexedPropType.flags & TypeFlags.IndexedAccess)) { // Don't elaborate on indexes on generic variables                 targetPropType = iterationType ? getUnionType([iterationType, targetIndexedPropType]) : targetIndexedPropType;             }             if (!targetPropType) continue;             let sourcePropType = getIndexedAccessTypeOrUndefined(source, nameType);             if (!sourcePropType) continue;             const propName = getPropertyNameFromIndex(nameType, /*accessNode* / undefined);             if (!checkTypeRelatedTo(sourcePropType, targetPropType, relation, /*errorNode* / undefined)) {                 const elaborated = next && elaborateError(next, sourcePropType, targetPropType, relation, /*headMessage* / undefined, containingMessageChain, errorOutputContainer);                 reportedError = true;                 if (!elaborated) {                     // Issue error on the prop itself, since the prop couldn't elaborate the error                     const resultObj: { errors?: Diagnostic[]; } = errorOutputContainer || {};                     // Use the expression type, if available                     const specificSource = next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType;                     if (exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType)) {                         const diag = createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType));                         diagnostics.add(diag);                         resultObj.errors = [diag];                     }                     else {                         const targetIsOptional = !!(propName && (getPropertyOfType(tupleOrArrayLikeTargetParts, propName) || unknownSymbol).flags & SymbolFlags.Optional);                         const sourceIsOptional = !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags & SymbolFlags.Optional);                         targetPropType = removeMissingType(targetPropType, targetIsOptional);                         sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional);                         const result = checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);                         if (result && specificSource !== sourcePropType) {                             // If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType                             checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);                         }                     }                 }             }         } */
		return reportedError
	}
	generateJsxAttributes := func(node JsxAttributes) ElaborationIterator {
		if !length(node.properties) {
			return
		}
		for _, prop := range node.properties {
			if isJsxSpreadAttribute(prop) || isHyphenatedJsxName(getTextOfJsxAttributeName(prop.name)) {
				continue
			}
			/* TODO(ExpressionStatement): yield { errorNode: prop.name, innerExpression: prop.initializer, nameType: getStringLiteralType(getTextOfJsxAttributeName(prop.name)) }; */
		}
	}
	generateJsxChildren := func(node JsxElement, getInvalidTextDiagnostic func() DiagnosticMessage) ElaborationIterator {
		if !length(node.children) {
			return
		}
		memberOffset := 0
		/* TODO(ForStatement): for (let i = 0; i < node.children.length; i++) {             const child = node.children[i];             const nameType = getNumberLiteralType(i - memberOffset);             const elem = getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic);             if (elem) {                 yield elem;             }             else {                 memberOffset++;             }         } */
	}
	getElaborationElementForJsxChild := func(child JsxChild, nameType LiteralType, getInvalidTextDiagnostic func() DiagnosticMessage) /* TODO inferred type { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxExpression; innerExpression: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage?: undefined; } | { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxText; innerExpression: undefined; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage; } | { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSelfClosingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxFragment; innerExpression: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSelfClosingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxFragment; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage?: undefined; } | undefined */ TODO {
		switch child.kind {
		case SyntaxKindJsxExpression:
			return /* TODO(ObjectLiteralExpression): { errorNode: child, innerExpression: child.expression, nameType } */ TODO
		case SyntaxKindJsxText:
			if child.containsOnlyTriviaWhiteSpaces {
				break
			}
			return /* TODO(ObjectLiteralExpression): { errorNode: child, innerExpression: undefined, nameType, errorMessage: getInvalidTextDiagnostic() } */ TODO
		case SyntaxKindJsxElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSelfClosingElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxFragment:
			return /* TODO(ObjectLiteralExpression): { errorNode: child, innerExpression: child, nameType } */ TODO
		default:
			return Debug.assertNever(child, "Found invalid jsx child")
		}
	}
	elaborateJsxComponents := func(node JsxAttributes, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO inferred type boolean */ TODO {
		result := elaborateElementwise(generateJsxAttributes(node), source, target, relation, containingMessageChain, errorOutputContainer)
		var invalidTextDiagnostic *DiagnosticMessage
		if isJsxOpeningElement(node.parent) && isJsxElement(node.parent.parent) {
			containingElement := node.parent.parent
			childPropName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
			childrenPropName := /* TODO(ConditionalExpression): childPropName === undefined ? "children" : unescapeLeadingUnderscores(childPropName) */ TODO
			childrenNameType := getStringLiteralType(childrenPropName)
			childrenTargetType := getIndexedAccessType(target, childrenNameType)
			validChildren := getSemanticJsxChildren(containingElement.children)
			if !length(validChildren) {
				return result
			}
			moreThanOneRealChildren := length(validChildren) > 1
			var arrayLikeTargetParts Type
			var nonArrayLikeTargetParts Type
			iterableType := getGlobalIterableType(false)
			if iterableType != emptyGenericType {
				anyIterable := createIterableType(anyType)
				arrayLikeTargetParts = filterType(childrenTargetType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return isTypeAssignableTo(t, anyIterable)
				})
				nonArrayLikeTargetParts = filterType(childrenTargetType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !isTypeAssignableTo(t, anyIterable)
				})
			} else {
				arrayLikeTargetParts = filterType(childrenTargetType, isArrayOrTupleLikeType)
				nonArrayLikeTargetParts = filterType(childrenTargetType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !isArrayOrTupleLikeType(t)
				})
			}
			if moreThanOneRealChildren {
				if arrayLikeTargetParts != neverType {
					realSource := createTupleType(checkJsxChildren(containingElement, CheckModeNormal))
					children := generateJsxChildren(containingElement, getInvalidTextualChildDiagnostic)
					result = elaborateIterableOrArrayLikeTargetElementwise(children, realSource, arrayLikeTargetParts, relation, containingMessageChain, errorOutputContainer) || result
				} else if !isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) {
					result = true
					diag := error(containingElement.openingElement.tagName, Diagnostics.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided, childrenPropName, typeToString(childrenTargetType))
					if errorOutputContainer && errorOutputContainer.skipLogging {
						(errorOutputContainer.errors || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
					}
				}
			} else {
				if nonArrayLikeTargetParts != neverType {
					child := /* TODO(ElementAccessExpression): validChildren[0] */ TODO
					elem := getElaborationElementForJsxChild(child, childrenNameType, getInvalidTextualChildDiagnostic)
					if elem {
						result = elaborateElementwise(( /* TODO(FunctionExpression): function* () {                                 yield elem;                             } */ TODO)(), source, target, relation, containingMessageChain, errorOutputContainer) || result
					}
				} else if !isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) {
					result = true
					diag := error(containingElement.openingElement.tagName, Diagnostics.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided, childrenPropName, typeToString(childrenTargetType))
					if errorOutputContainer && errorOutputContainer.skipLogging {
						(errorOutputContainer.errors || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
					}
				}
			}
		}
		return result
		getInvalidTextualChildDiagnostic := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO {
			if !invalidTextDiagnostic {
				tagNameText := getTextOfNode(node.parent.tagName)
				childPropName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
				childrenPropName := /* TODO(ConditionalExpression): childPropName === undefined ? "children" : unescapeLeadingUnderscores(childPropName) */ TODO
				childrenTargetType := getIndexedAccessType(target, getStringLiteralType(childrenPropName))
				diagnostic := Diagnostics._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2
				invalidTextDiagnostic = /* TODO(ObjectLiteralExpression): { ...diagnostic, key: "!!ALREADY FORMATTED!!", message: formatMessage(diagnostic, tagNameText, childrenPropName, typeToString(childrenTargetType)) } */ TODO
			}
			return invalidTextDiagnostic
		}
	}
	generateLimitedTupleElements := func(node ArrayLiteralExpression, target Type) ElaborationIterator {
		len := length(node.elements)
		if !len {
			return
		}
		/* TODO(ForStatement): for (let i = 0; i < len; i++) {             // Skip elements which do not exist in the target - a length error on the tuple overall is likely better than an error on a mismatched index signature             if (isTupleLikeType(target) && !getPropertyOfType(target, ("" + i) as __String)) continue;             const elem = node.elements[i];             if (isOmittedExpression(elem)) continue;             const nameType = getNumberLiteralType(i);             const checkNode = getEffectiveCheckNode(elem);             yield { errorNode: checkNode, innerExpression: checkNode, nameType };         } */
	}
	elaborateArrayLiteral := func(node ArrayLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO inferred type boolean */ TODO {
		if target.flags & (TypeFlagsPrimitive | TypeFlagsNever) {
			return false
		}
		if isTupleLikeType(source) {
			return elaborateElementwise(generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer)
		}
		pushContextualType(node, target, false)
		tupleizedType := checkArrayLiteral(node, CheckModeContextual, true)
		popContextualType()
		if isTupleLikeType(tupleizedType) {
			return elaborateElementwise(generateLimitedTupleElements(node, target), tupleizedType, target, relation, containingMessageChain, errorOutputContainer)
		}
		return false
	}
	generateObjectLiteralElements := func(node ObjectLiteralExpression) ElaborationIterator {
		if !length(node.properties) {
			return
		}
		for _, prop := range node.properties {
			if isSpreadAssignment(prop) {
				continue
			}
			type_ := getLiteralTypeFromProperty(getSymbolOfDeclaration(prop), TypeFlagsStringOrNumberLiteralOrUnique)
			if !type_ || (type_.flags & TypeFlagsNever) {
				continue
			}
			switch prop.kind {
			case SyntaxKindSetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindShorthandPropertyAssignment:
				/* TODO(ExpressionStatement): yield { errorNode: prop.name, innerExpression: undefined, nameType: type }; */
				break
			case SyntaxKindPropertyAssignment:
				/* TODO(ExpressionStatement): yield { errorNode: prop.name, innerExpression: prop.initializer, nameType: type, errorMessage: isComputedNonLiteralName(prop.name) ? Diagnostics.Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1 : undefined }; */
				break
			default:
				Debug.assertNever(prop)
			}
		}
	}
	elaborateObjectLiteral := func(node ObjectLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO inferred type boolean */ TODO {
		if target.flags & (TypeFlagsPrimitive | TypeFlagsNever) {
			return false
		}
		return elaborateElementwise(generateObjectLiteralElements(node), source, target, relation, containingMessageChain, errorOutputContainer)
	}
	checkTypeComparableTo := func(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
		return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain)
	}
	isSignatureAssignableTo := func(source Signature, target Signature, ignoreReturnTypes bool) bool {
		return compareSignaturesRelated(source, target /* TODO(ConditionalExpression): ignoreReturnTypes ? SignatureCheckMode.IgnoreReturnTypes : SignatureCheckMode.None */, TODO, false, nil, nil, compareTypesAssignable, nil) != TernaryFalse
	}
	type ErrorReporter func(message DiagnosticMessage, args DiagnosticArguments)
	isTopSignature := func(s Signature) /* TODO inferred type boolean */ TODO {
		if !s.typeParameters && (!s.thisParameter || isTypeAny(getTypeOfParameter(s.thisParameter))) && s.parameters.length == 1 && signatureHasRestParameter(s) {
			paramType := getTypeOfParameter( /* TODO(ElementAccessExpression): s.parameters[0] */ TODO)
			restType := /* TODO(ConditionalExpression): isArrayType(paramType) ? getTypeArguments(paramType)[0] : paramType */ TODO
			return !!(restType.flags&(TypeFlagsAny|TypeFlagsNever) && getReturnTypeOfSignature(s).flags&TypeFlagsAnyOrUnknown)
		}
		return false
	}
	compareSignaturesRelated := func(source Signature, target Signature, checkMode SignatureCheckMode, reportErrors bool, errorReporter *ErrorReporter, incompatibleErrorReporter /* TODO(ParenthesizedType): ((source: Type, target: Type) => void) */ any, compareTypes TypeComparer, reportUnreliableMarkers *TypeMapper) Ternary {
		if source == target {
			return TernaryTrue
		}
		if !(checkMode&SignatureCheckModeStrictTopSignature && isTopSignature(source)) && isTopSignature(target) {
			return TernaryTrue
		}
		if checkMode&SignatureCheckModeStrictTopSignature && isTopSignature(source) && !isTopSignature(target) {
			return TernaryFalse
		}
		targetCount := getParameterCount(target)
		sourceHasMoreParameters := !hasEffectiveRestParameter(target) && ( /* TODO(ConditionalExpression): checkMode & SignatureCheckMode.StrictArity ? hasEffectiveRestParameter(source) || getParameterCount(source) > targetCount : getMinArgumentCount(source) > targetCount */ TODO)
		if sourceHasMoreParameters {
			if reportErrors && !(checkMode & SignatureCheckModeStrictArity) {
				errorReporter(Diagnostics.Target_signature_provides_too_few_arguments_Expected_0_or_more_but_got_1, getMinArgumentCount(source), targetCount)
			}
			return TernaryFalse
		}
		if source.typeParameters && source.typeParameters != target.typeParameters {
			target = getCanonicalSignature(target)
			source = instantiateSignatureInContextOf(source, target, nil, compareTypes)
		}
		sourceCount := getParameterCount(source)
		sourceRestType := getNonArrayRestType(source)
		targetRestType := getNonArrayRestType(target)
		if sourceRestType || targetRestType {
			/* TODO(ExpressionStatement): void instantiateType(sourceRestType || targetRestType, reportUnreliableMarkers); */
		}
		kind := /* TODO(ConditionalExpression): target.declaration ? target.declaration.kind : SyntaxKind.Unknown */ TODO
		strictVariance := !(checkMode & SignatureCheckModeCallback) && strictFunctionTypes && kind != SyntaxKindMethodDeclaration && kind != SyntaxKindMethodSignature && kind != SyntaxKindConstructor
		result := TernaryTrue
		sourceThisType := getThisTypeOfSignature(source)
		if sourceThisType && sourceThisType != voidType {
			targetThisType := getThisTypeOfSignature(target)
			if targetThisType {
				related := !strictVariance && compareTypes(sourceThisType, targetThisType, false) || compareTypes(targetThisType, sourceThisType, reportErrors)
				if !related {
					if reportErrors {
						errorReporter(Diagnostics.The_this_types_of_each_signature_are_incompatible)
					}
					return TernaryFalse
				}
				result &= related
			}
		}
		paramCount := /* TODO(ConditionalExpression): sourceRestType || targetRestType ? Math.min(sourceCount, targetCount) : Math.max(sourceCount, targetCount) */ TODO
		restIndex := /* TODO(ConditionalExpression): sourceRestType || targetRestType ? paramCount - 1 : -1 */ TODO
		/* TODO(ForStatement): for (let i = 0; i < paramCount; i++) {             const sourceType = i === restIndex ? getRestOrAnyTypeAtPosition(source, i) : tryGetTypeAtPosition(source, i);             const targetType = i === restIndex ? getRestOrAnyTypeAtPosition(target, i) : tryGetTypeAtPosition(target, i);             if (sourceType && targetType && (sourceType !== targetType || checkMode & SignatureCheckMode.StrictArity)) {                 // In order to ensure that any generic type Foo<T> is at least co-variant with respect to T no matter                 // how Foo uses T, we need to relate parameters bi-variantly (given that parameters are input positions,                 // they naturally relate only contra-variantly). However, if the source and target parameters both have                 // function types with a single call signature, we know we are relating two callback parameters. In                 // that case it is sufficient to only relate the parameters of the signatures co-variantly because,                 // similar to return values, callback parameters are output positions. This means that a Promise<T>,                 // where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant)                 // with respect to T.                 const sourceSig = checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(source, i) ? undefined : getSingleCallSignature(getNonNullableType(sourceType));                 const targetSig = checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(target, i) ? undefined : getSingleCallSignature(getNonNullableType(targetType));                 const callbacks = sourceSig && targetSig && !getTypePredicateOfSignature(sourceSig) && !getTypePredicateOfSignature(targetSig) &&                     getTypeFacts(sourceType, TypeFacts.IsUndefinedOrNull) === getTypeFacts(targetType, TypeFacts.IsUndefinedOrNull);                 let related = callbacks ?                     compareSignaturesRelated(targetSig, sourceSig, (checkMode & SignatureCheckMode.StrictArity) | (strictVariance ? SignatureCheckMode.StrictCallback : SignatureCheckMode.BivariantCallback), reportErrors, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers) :                     !(checkMode & SignatureCheckMode.Callback) && !strictVariance && compareTypes(sourceType, targetType, /*reportErrors* / false) || compareTypes(targetType, sourceType, reportErrors);                 // With strict arity, (x: number | undefined) => void is a subtype of (x?: number | undefined) => void                 if (related && checkMode & SignatureCheckMode.StrictArity && i >= getMinArgumentCount(source) && i < getMinArgumentCount(target) && compareTypes(sourceType, targetType, /*reportErrors* / false)) {                     related = Ternary.False;                 }                 if (!related) {                     if (reportErrors) {                         errorReporter!(Diagnostics.Types_of_parameters_0_and_1_are_incompatible, unescapeLeadingUnderscores(getParameterNameAtPosition(source, i)), unescapeLeadingUnderscores(getParameterNameAtPosition(target, i)));                     }                     return Ternary.False;                 }                 result &= related;             }         } */
		if !(checkMode & SignatureCheckModeIgnoreReturnTypes) {
			targetReturnType := /* TODO(ConditionalExpression): isResolvingReturnTypeOfSignature(target) ? anyType                 : target.declaration && isJSConstructor(target.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(target.declaration.symbol))                 : getReturnTypeOfSignature(target) */ TODO
			if targetReturnType == voidType || targetReturnType == anyType {
				return result
			}
			sourceReturnType := /* TODO(ConditionalExpression): isResolvingReturnTypeOfSignature(source) ? anyType                 : source.declaration && isJSConstructor(source.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(source.declaration.symbol))                 : getReturnTypeOfSignature(source) */ TODO
			targetTypePredicate := getTypePredicateOfSignature(target)
			if targetTypePredicate {
				sourceTypePredicate := getTypePredicateOfSignature(source)
				if sourceTypePredicate {
					result &= compareTypePredicateRelatedTo(sourceTypePredicate, targetTypePredicate, reportErrors, errorReporter, compareTypes)
				} else if isIdentifierTypePredicate(targetTypePredicate) || isThisTypePredicate(targetTypePredicate) {
					if reportErrors {
						errorReporter(Diagnostics.Signature_0_must_be_a_type_predicate, signatureToString(source))
					}
					return TernaryFalse
				}
			} else {
				result &= checkMode&SignatureCheckModeBivariantCallback && compareTypes(targetReturnType, sourceReturnType, false) || compareTypes(sourceReturnType, targetReturnType, reportErrors)
				if !result && reportErrors && incompatibleErrorReporter {
					incompatibleErrorReporter(sourceReturnType, targetReturnType)
				}
			}
		}
		return result
	}
	compareTypePredicateRelatedTo := func(source TypePredicate, target TypePredicate, reportErrors bool, errorReporter *ErrorReporter, compareTypes func(s Type, t Type, reportErrors bool) Ternary) Ternary {
		if source.kind != target.kind {
			if reportErrors {
				errorReporter(Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard)
				errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target))
			}
			return TernaryFalse
		}
		if source.kind == TypePredicateKindIdentifier || source.kind == TypePredicateKindAssertsIdentifier {
			if source.parameterIndex != (target).parameterIndex {
				if reportErrors {
					errorReporter(Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1, source.parameterName, (target).parameterName)
					errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target))
				}
				return TernaryFalse
			}
		}
		related := /* TODO(ConditionalExpression): source.type === target.type ? Ternary.True :             source.type && target.type ? compareTypes(source.type, target.type, reportErrors) :             Ternary.False */ TODO
		if related == TernaryFalse && reportErrors {
			errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target))
		}
		return related
	}
	isImplementationCompatibleWithOverload := func(implementation Signature, overload Signature) bool {
		erasedSource := getErasedSignature(implementation)
		erasedTarget := getErasedSignature(overload)
		sourceReturnType := getReturnTypeOfSignature(erasedSource)
		targetReturnType := getReturnTypeOfSignature(erasedTarget)
		if targetReturnType == voidType || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation) || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation) {
			return isSignatureAssignableTo(erasedSource, erasedTarget, true)
		}
		return false
	}
	isEmptyResolvedType := func(t ResolvedType) /* TODO inferred type boolean */ TODO {
		return t != anyFunctionType && t.properties.length == 0 && t.callSignatures.length == 0 && t.constructSignatures.length == 0 && t.indexInfos.length == 0
	}
	isEmptyObjectType := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Object ? !isGenericMappedType(type) && isEmptyResolvedType(resolveStructuredTypeMembers(type as ObjectType)) :             type.flags & TypeFlags.NonPrimitive ? true :             type.flags & TypeFlags.Union ? some((type as UnionType).types, isEmptyObjectType) :             type.flags & TypeFlags.Intersection ? every((type as UnionType).types, isEmptyObjectType) :             false */ TODO
	}
	isEmptyAnonymousObjectType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(getObjectFlags(type_)&ObjectFlagsAnonymous && ((type_).members && isEmptyResolvedType(type_) || type_.symbol && type_.symbol.flags&SymbolFlagsTypeLiteral && getMembersOfSymbol(type_.symbol).size == 0))
	}
	isUnknownLikeUnionType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		if strictNullChecks && type_.flags&TypeFlagsUnion {
			if !((type_).objectFlags & ObjectFlagsIsUnknownLikeUnionComputed) {
				types := (type_).types
				(type_).objectFlags |= ObjectFlagsIsUnknownLikeUnionComputed | ( /* TODO(ConditionalExpression): types.length >= 3 && types[0].flags & TypeFlags.Undefined &&                         types[1].flags & TypeFlags.Null && some(types, isEmptyAnonymousObjectType) ? ObjectFlags.IsUnknownLikeUnion : 0 */ TODO)
			}
			return !!((type_).objectFlags & ObjectFlagsIsUnknownLikeUnion)
		}
		return false
	}
	containsUndefinedType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(( /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type */ TODO).flags & TypeFlagsUndefined)
	}
	containsNonMissingUndefinedType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		candidate := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type */ TODO
		return !!(candidate.flags & TypeFlagsUndefined) && candidate != missingType
	}
	isStringIndexSignatureOnlyType := func(type_ Type) bool {
		return type_.flags&TypeFlagsObject && !isGenericMappedType(type_) && getPropertiesOfType(type_).length == 0 && getIndexInfosOfType(type_).length == 1 && !!getIndexInfoOfType(type_, stringType) || type_.flags&TypeFlagsUnionOrIntersection && every((type_).types, isStringIndexSignatureOnlyType) || false
	}
	isEnumTypeRelatedTo := func(source Symbol, target Symbol, errorReporter ErrorReporter) /* TODO inferred type boolean */ TODO {
		sourceSymbol := /* TODO(ConditionalExpression): source.flags & SymbolFlags.EnumMember ? getParentOfSymbol(source)! : source */ TODO
		targetSymbol := /* TODO(ConditionalExpression): target.flags & SymbolFlags.EnumMember ? getParentOfSymbol(target)! : target */ TODO
		if sourceSymbol == targetSymbol {
			return true
		}
		if sourceSymbol.escapedName != targetSymbol.escapedName || !(sourceSymbol.flags & SymbolFlagsRegularEnum) || !(targetSymbol.flags & SymbolFlagsRegularEnum) {
			return false
		}
		id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): getSymbolId(sourceSymbol) + "," + getSymbolId(targetSymbol) */ TODO
		entry := enumRelation.get(id)
		if entry != nil && !(entry&RelationComparisonResultFailed && errorReporter) {
			return !!(entry & RelationComparisonResultSucceeded)
		}
		targetEnumType := getTypeOfSymbol(targetSymbol)
		for _, sourceProperty := range getPropertiesOfType(getTypeOfSymbol(sourceSymbol)) {
			if sourceProperty.flags & SymbolFlagsEnumMember {
				targetProperty := getPropertyOfType(targetEnumType, sourceProperty.escapedName)
				if !targetProperty || !(targetProperty.flags & SymbolFlagsEnumMember) {
					if errorReporter {
						errorReporter(Diagnostics.Property_0_is_missing_in_type_1, symbolName(sourceProperty), typeToString(getDeclaredTypeOfSymbol(targetSymbol), nil, TypeFormatFlagsUseFullyQualifiedType))
					}
					enumRelation.set(id, RelationComparisonResultFailed)
					return false
				}
				sourceValue := getEnumMemberValue(getDeclarationOfKind(sourceProperty, SyntaxKindEnumMember)).value
				targetValue := getEnumMemberValue(getDeclarationOfKind(targetProperty, SyntaxKindEnumMember)).value
				if sourceValue != targetValue {
					sourceIsString := /* TODO(TypeOfExpression): typeof sourceValue */ TODO == "string"
					targetIsString := /* TODO(TypeOfExpression): typeof targetValue */ TODO == "string"
					if sourceValue != nil && targetValue != nil {
						if errorReporter {
							escapedSource := /* TODO(ConditionalExpression): sourceIsString ? `"${escapeString(sourceValue)}"` : sourceValue */ TODO
							escapedTarget := /* TODO(ConditionalExpression): targetIsString ? `"${escapeString(targetValue)}"` : targetValue */ TODO
							errorReporter(Diagnostics.Each_declaration_of_0_1_differs_in_its_value_where_2_was_expected_but_3_was_given, symbolName(targetSymbol), symbolName(targetProperty), escapedTarget, escapedSource)
						}
						enumRelation.set(id, RelationComparisonResultFailed)
						return false
					}
					if sourceIsString || targetIsString {
						if errorReporter {
							knownStringValue := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): sourceValue ?? targetValue */ TODO
							Debug.assert( /* TODO(TypeOfExpression): typeof knownStringValue */ TODO == "string")
							escapedValue := /* TODO(TemplateExpression): `"${escapeString(knownStringValue)}"` */ TODO
							errorReporter(Diagnostics.One_value_of_0_1_is_the_string_2_and_the_other_is_assumed_to_be_an_unknown_numeric_value, symbolName(targetSymbol), symbolName(targetProperty), escapedValue)
						}
						enumRelation.set(id, RelationComparisonResultFailed)
						return false
					}
				}
			}
		}
		enumRelation.set(id, RelationComparisonResultSucceeded)
		return true
	}
	isSimpleTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorReporter ErrorReporter) /* TODO inferred type boolean */ TODO {
		s := source.flags
		t := target.flags
		if t&TypeFlagsAny || s&TypeFlagsNever || source == wildcardType {
			return true
		}
		if t&TypeFlagsUnknown && !(relation == strictSubtypeRelation && s&TypeFlagsAny) {
			return true
		}
		if t & TypeFlagsNever {
			return false
		}
		if s&TypeFlagsStringLike && t&TypeFlagsString {
			return true
		}
		if s&TypeFlagsStringLiteral && s&TypeFlagsEnumLiteral && t&TypeFlagsStringLiteral && !(t & TypeFlagsEnumLiteral) && (source).value == (target).value {
			return true
		}
		if s&TypeFlagsNumberLike && t&TypeFlagsNumber {
			return true
		}
		if s&TypeFlagsNumberLiteral && s&TypeFlagsEnumLiteral && t&TypeFlagsNumberLiteral && !(t & TypeFlagsEnumLiteral) && (source).value == (target).value {
			return true
		}
		if s&TypeFlagsBigIntLike && t&TypeFlagsBigInt {
			return true
		}
		if s&TypeFlagsBooleanLike && t&TypeFlagsBoolean {
			return true
		}
		if s&TypeFlagsESSymbolLike && t&TypeFlagsESSymbol {
			return true
		}
		if s&TypeFlagsEnum && t&TypeFlagsEnum && source.symbol.escapedName == target.symbol.escapedName && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
			return true
		}
		if s&TypeFlagsEnumLiteral && t&TypeFlagsEnumLiteral {
			if s&TypeFlagsUnion && t&TypeFlagsUnion && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
				return true
			}
			if s&TypeFlagsLiteral && t&TypeFlagsLiteral && (source).value == (target).value && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
				return true
			}
		}
		if s&TypeFlagsUndefined && (!strictNullChecks && !(t&TypeFlagsUnionOrIntersection) || t&(TypeFlagsUndefined|TypeFlagsVoid)) {
			return true
		}
		if s&TypeFlagsNull && (!strictNullChecks && !(t&TypeFlagsUnionOrIntersection) || t&TypeFlagsNull) {
			return true
		}
		if s&TypeFlagsObject && t&TypeFlagsNonPrimitive && !(relation == strictSubtypeRelation && isEmptyAnonymousObjectType(source) && !(getObjectFlags(source) & ObjectFlagsFreshLiteral)) {
			return true
		}
		if relation == assignableRelation || relation == comparableRelation {
			if s & TypeFlagsAny {
				return true
			}
			if s&TypeFlagsNumber && (t&TypeFlagsEnum || t&TypeFlagsNumberLiteral && t&TypeFlagsEnumLiteral) {
				return true
			}
			if s&TypeFlagsNumberLiteral && !(s & TypeFlagsEnumLiteral) && (t&TypeFlagsEnum || t&TypeFlagsNumberLiteral && t&TypeFlagsEnumLiteral && (source).value == (target).value) {
				return true
			}
			if isUnknownLikeUnionType(target) {
				return true
			}
		}
		return false
	}
	isTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult]) /* TODO inferred type boolean */ TODO {
		if isFreshLiteralType(source) {
			source = (source).regularType
		}
		if isFreshLiteralType(target) {
			target = (target).regularType
		}
		if source == target {
			return true
		}
		if relation != identityRelation {
			if relation == comparableRelation && !(target.flags&TypeFlagsNever) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation) {
				return true
			}
		} else if !((source.flags | target.flags) & (TypeFlagsUnionOrIntersection | TypeFlagsIndexedAccess | TypeFlagsConditional | TypeFlagsSubstitution)) {
			if source.flags != target.flags {
				return false
			}
			if source.flags & TypeFlagsSingleton {
				return true
			}
		}
		if source.flags&TypeFlagsObject && target.flags&TypeFlagsObject {
			related := relation.get(getRelationKey(source, target, IntersectionStateNone, relation, false))
			if related != nil {
				return !!(related & RelationComparisonResultSucceeded)
			}
		}
		if source.flags&TypeFlagsStructuredOrInstantiable || target.flags&TypeFlagsStructuredOrInstantiable {
			return checkTypeRelatedTo(source, target, relation, nil)
		}
		return false
	}
	isIgnoredJsxProperty := func(source Type, sourceProp Symbol) /* TODO inferred type boolean | 0 */ TODO {
		return getObjectFlags(source)&ObjectFlagsJsxAttributes && isHyphenatedJsxName(sourceProp.escapedName)
	}
	getNormalizedType := func(type_ Type, writing bool) Type {
		for true {
			t := /* TODO(ConditionalExpression): isFreshLiteralType(type) ? (type as FreshableType).regularType :                 isGenericTupleType(type) ? getNormalizedTupleType(type, writing) :                 getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).node ? createTypeReference((type as TypeReference).target, getTypeArguments(type as TypeReference)) : getSingleBaseForNonAugmentingSubtype(type) || type :                 type.flags & TypeFlags.UnionOrIntersection ? getNormalizedUnionOrIntersectionType(type as UnionOrIntersectionType, writing) :                 type.flags & TypeFlags.Substitution ? writing ? (type as SubstitutionType).baseType : getSubstitutionIntersection(type as SubstitutionType) :                 type.flags & TypeFlags.Simplifiable ? getSimplifiedType(type, writing) :                 type */ TODO
			if t == type_ {
				return t
			}
			type_ = t
		}
	}
	getNormalizedUnionOrIntersectionType := func(type_ UnionOrIntersectionType, writing bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		reduced := getReducedType(type_)
		if reduced != type_ {
			return reduced
		}
		if type_.flags&TypeFlagsIntersection && shouldNormalizeIntersection(type_) {
			normalizedTypes := sameMap(type_.types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return getNormalizedType(t, writing)
			})
			if normalizedTypes != type_.types {
				return getIntersectionType(normalizedTypes)
			}
		}
		return type_
	}
	shouldNormalizeIntersection := func(type_ IntersectionType) /* TODO inferred type boolean */ TODO {
		hasInstantiable := false
		hasNullableOrEmpty := false
		for _, t := range type_.types {
			/* TODO(ExpressionStatement): hasInstantiable ||= !!(t.flags & TypeFlags.Instantiable); */
			/* TODO(ExpressionStatement): hasNullableOrEmpty ||= !!(t.flags & TypeFlags.Nullable) || isEmptyAnonymousObjectType(t); */
			if hasInstantiable && hasNullableOrEmpty {
				return true
			}
		}
		return false
	}
	getNormalizedTupleType := func(type_ TupleTypeReference, writing bool) Type {
		elements := getElementTypes(type_)
		normalizedElements := sameMap(elements, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return /* TODO(ConditionalExpression): t.flags & TypeFlags.Simplifiable ? getSimplifiedType(t, writing) : t */ TODO
		})
		return /* TODO(ConditionalExpression): elements !== normalizedElements ? createNormalizedTupleType(type.target, normalizedElements) : type */ TODO
	}
	checkTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		var errorInfo *DiagnosticMessageChain
		var relatedInfo /* TODO(TupleType): [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] */ any
		var maybeKeys []string
		var maybeKeysSet Set[string]
		var sourceStack []Type
		var targetStack []Type
		maybeCount := 0
		sourceDepth := 0
		targetDepth := 0
		expandingFlags := ExpandingFlagsNone
		overflow := false
		overrideNextErrorInfo := 0
		skipParentCounter := 0
		var lastSkippedInfo /* TODO(TupleType): [Type, Type] */ any
		var incompatibleStack /* TODO(ArrayType): DiagnosticAndArguments[] */ any
		relationCount := /* TODO(GreaterThanGreaterThanToken): >> */ /* TODO(BinaryExpression): (16_000_000 - relation.size) >> 3 */ TODO
		Debug.assert(relation != identityRelation || !errorNode, "no error reporting in identity checking")
		result := isRelatedTo(source, target, RecursionFlagsBoth, !!errorNode, headMessage)
		if incompatibleStack {
			reportIncompatibleStack()
		}
		if overflow {
			id := getRelationKey(source, target, IntersectionStateNone, relation, false)
			relation.set(id, RelationComparisonResultFailed|( /* TODO(ConditionalExpression): relationCount <= 0 ? RelationComparisonResult.ComplexityOverflow : RelationComparisonResult.StackDepthOverflow */ TODO))
			tracing.instant(tracing.Phase.CheckTypes, "checkTypeRelatedTo_DepthLimit" /* TODO(ObjectLiteralExpression): { sourceId: source.id, targetId: target.id, depth: sourceDepth, targetDepth } */, TODO)
			message := /* TODO(ConditionalExpression): relationCount <= 0 ?                 Diagnostics.Excessive_complexity_comparing_types_0_and_1 :                 Diagnostics.Excessive_stack_depth_comparing_types_0_and_1 */ TODO
			diag := error(errorNode || currentNode, message, typeToString(source), typeToString(target))
			if errorOutputContainer {
				(errorOutputContainer.errors || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
			}
		} else if errorInfo {
			if containingMessageChain {
				chain := containingMessageChain()
				if chain {
					concatenateDiagnosticMessageChains(chain, errorInfo)
					errorInfo = chain
				}
			}
			var relatedInformation /* TODO(ArrayType): DiagnosticRelatedInformation[] */ any
			if headMessage && errorNode && !result && source.symbol {
				links := getSymbolLinks(source.symbol)
				if links.originatingImport && !isImportCall(links.originatingImport) {
					helpfulRetry := checkTypeRelatedTo(getTypeOfSymbol(links.target), target, relation, nil)
					if helpfulRetry {
						diag := createDiagnosticForNode(links.originatingImport, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead)
						relatedInformation = append(relatedInformation, diag)
					}
				}
			}
			diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, errorInfo, relatedInformation)
			if relatedInfo {
				addRelatedInfo(diag /* TODO(SpreadElement): ...relatedInfo */, TODO)
			}
			if errorOutputContainer {
				(errorOutputContainer.errors || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
			}
			if !errorOutputContainer || !errorOutputContainer.skipLogging {
				diagnostics.add(diag)
			}
		}
		if errorNode && errorOutputContainer && errorOutputContainer.skipLogging && result == TernaryFalse {
			Debug.assert(!!errorOutputContainer.errors, "missed opportunity to interact with error.")
		}
		return result != TernaryFalse
		resetErrorInfo := func(saved ReturnType[ /* TODO(TypeQuery): typeof captureErrorCalculationState */ any]) {
			errorInfo = saved.errorInfo
			lastSkippedInfo = saved.lastSkippedInfo
			incompatibleStack = saved.incompatibleStack
			overrideNextErrorInfo = saved.overrideNextErrorInfo
			skipParentCounter = saved.skipParentCounter
			relatedInfo = saved.relatedInfo
		}
		captureErrorCalculationState := func() /* TODO inferred type { errorInfo: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined; lastSkippedInfo: [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, import("/home/jabaile/work/TypeScript/src/compiler/types").Type] | undefined; incompatibleStack: [message: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage, ...args: (string | number)[]][] | undefined; overrideNextErrorInfo: number; skipParentCounter: number; relatedInfo: [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined; } */ TODO {
			return /* TODO(ObjectLiteralExpression): {                 errorInfo,                 lastSkippedInfo,                 incompatibleStack: incompatibleStack?.slice(),                 overrideNextErrorInfo,                 skipParentCounter,                 relatedInfo: relatedInfo?.slice() as [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined,             } */ TODO
		}
		reportIncompatibleError := func(message DiagnosticMessage, args DiagnosticArguments) {
			overrideNextErrorInfo++
			lastSkippedInfo = nil
			( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): incompatibleStack ||= [] */ TODO).push( /* TODO(ArrayLiteralExpression): [message, ...args] */ TODO)
		}
		reportIncompatibleStack := func() /* TODO inferred type undefined */ TODO {
			stack := incompatibleStack || /* TODO(ArrayLiteralExpression): [] */ TODO
			incompatibleStack = nil
			info := lastSkippedInfo
			lastSkippedInfo = nil
			if stack.length == 1 {
				reportError( /* TODO(SpreadElement): ...stack[0] */ TODO)
				if info {
					reportRelationError(nil /* TODO(SpreadElement): ...info */, TODO)
				}
				return
			}
			path := ""
			var secondaryRootErrors []DiagnosticAndArguments = /* TODO(ArrayLiteralExpression): [] */ TODO
			for stack.length {
				TODO_IDENTIFIER := stack.pop()
				switch msg.code {
				case Diagnostics.Types_of_property_0_are_incompatible.code:
					if path.indexOf("new ") == 0 {
						path = /* TODO(TemplateExpression): `(${path})` */ TODO
					}
					str := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + args[0] */ TODO
					if path.length == 0 {
						path = /* TODO(TemplateExpression): `${str}` */ TODO
					} else if isIdentifierText(str, getEmitScriptTarget(compilerOptions)) {
						path = /* TODO(TemplateExpression): `${path}.${str}` */ TODO
					} else if /* TODO(ElementAccessExpression): str[0] */ TODO == "[" && /* TODO(ElementAccessExpression): str[str.length - 1] */ TODO == "]" {
						path = /* TODO(TemplateExpression): `${path}${str}` */ TODO
					} else {
						path = /* TODO(TemplateExpression): `${path}[${str}]` */ TODO
					}
					break
					fallthrough
				case Diagnostics.Call_signature_return_types_0_and_1_are_incompatible.code:
					fallthrough // TODO: merge cases
				case Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code:
					fallthrough // TODO: merge cases
				case Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:
					fallthrough // TODO: merge cases
				case Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:
					if path.length == 0 {
						mappedMsg := msg
						if msg.code == Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code {
							mappedMsg = Diagnostics.Call_signature_return_types_0_and_1_are_incompatible
						} else if msg.code == Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code {
							mappedMsg = Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible
						}
						secondaryRootErrors.unshift( /* TODO(ArrayLiteralExpression): [mappedMsg, args[0], args[1]] */ TODO)
					} else {
						prefix := /* TODO(ConditionalExpression): (msg.code === Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code ||                                     msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)                                 ? "new "                                 : "" */ TODO
						params := /* TODO(ConditionalExpression): (msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code ||                                     msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)                                 ? ""                                 : "..." */ TODO
						path = /* TODO(TemplateExpression): `${prefix}${path}(${params})` */ TODO
					}
					break
					fallthrough
				case Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target.code:
					secondaryRootErrors.unshift( /* TODO(ArrayLiteralExpression): [Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, args[0], args[1]] */ TODO)
					break
					fallthrough
				case Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target.code:
					secondaryRootErrors.unshift( /* TODO(ArrayLiteralExpression): [Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, args[0], args[1], args[2]] */ TODO)
					break
					fallthrough
				default:
					return Debug.fail( /* TODO(TemplateExpression): `Unhandled Diagnostic: ${msg.code}` */ TODO)
				}
			}
			if path {
				reportError( /* TODO(ConditionalExpression): path[path.length - 1] === ")"                         ? Diagnostics.The_types_returned_by_0_are_incompatible_between_these_types                         : Diagnostics.The_types_of_0_are_incompatible_between_these_types */ TODO, path)
			} else {
				secondaryRootErrors.shift()
			}
			for _, TODO_IDENTIFIER := range secondaryRootErrors {
				originalValue := msg.elidedInCompatabilityPyramid
				msg.elidedInCompatabilityPyramid = false
				reportError(msg /* TODO(SpreadElement): ...args */, TODO)
				msg.elidedInCompatabilityPyramid = originalValue
			}
			if info {
				reportRelationError(nil /* TODO(SpreadElement): ...info */, TODO)
			}
		}
		reportError := func(message DiagnosticMessage, args DiagnosticArguments) {
			Debug.assert(!!errorNode)
			if incompatibleStack {
				reportIncompatibleStack()
			}
			if message.elidedInCompatabilityPyramid {
				return
			}
			if skipParentCounter == 0 {
				errorInfo = chainDiagnosticMessages(errorInfo, message /* TODO(SpreadElement): ...args */, TODO)
			} else {
				skipParentCounter--
			}
		}
		reportParentSkippedError := func(message DiagnosticMessage, args DiagnosticArguments) {
			reportError(message /* TODO(SpreadElement): ...args */, TODO)
			skipParentCounter++
		}
		associateRelatedInfo := func(info DiagnosticRelatedInformation) {
			Debug.assert(!!errorInfo)
			if !relatedInfo {
				relatedInfo = /* TODO(ArrayLiteralExpression): [info] */ TODO
			} else {
				relatedInfo.push(info)
			}
		}
		reportRelationError := func(message *DiagnosticMessage, source Type, target Type) {
			if incompatibleStack {
				reportIncompatibleStack()
			}
			TODO_IDENTIFIER := getTypeNamesForErrorDisplay(source, target)
			generalizedSource := source
			generalizedSourceType := sourceType
			if isLiteralType(source) && !typeCouldHaveTopLevelSingletonTypes(target) {
				generalizedSource = getBaseTypeOfLiteralType(source)
				Debug.assert(!isTypeAssignableTo(generalizedSource, target), "generalized source shouldn't be assignable")
				generalizedSourceType = getTypeNameForErrorDisplay(generalizedSource)
			}
			targetFlags := /* TODO(ConditionalExpression): target.flags & TypeFlags.IndexedAccess && !(source.flags & TypeFlags.IndexedAccess) ?                 (target as IndexedAccessType).objectType.flags :                 target.flags */ TODO
			if targetFlags&TypeFlagsTypeParameter && target != markerSuperTypeForCheck && target != markerSubTypeForCheck {
				constraint := getBaseConstraintOfType(target)
				var needsOriginalSource TODO
				if constraint && (isTypeAssignableTo(generalizedSource, constraint) || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): needsOriginalSource = isTypeAssignableTo(source, constraint) */ TODO)) {
					reportError(Diagnostics._0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2 /* TODO(ConditionalExpression): needsOriginalSource ? sourceType : generalizedSourceType */, TODO, targetType, typeToString(constraint))
				} else {
					errorInfo = nil
					reportError(Diagnostics._0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1, targetType, generalizedSourceType)
				}
			}
			if !message {
				if relation == comparableRelation {
					message = Diagnostics.Type_0_is_not_comparable_to_type_1
				} else if sourceType == targetType {
					message = Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated
				} else if exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(source, target).length {
					message = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
				} else {
					if source.flags&TypeFlagsStringLiteral && target.flags&TypeFlagsUnion {
						suggestedType := getSuggestedTypeForNonexistentStringLiteralType(source, target)
						if suggestedType {
							reportError(Diagnostics.Type_0_is_not_assignable_to_type_1_Did_you_mean_2, generalizedSourceType, targetType, typeToString(suggestedType))
							return
						}
					}
					message = Diagnostics.Type_0_is_not_assignable_to_type_1
				}
			} else if message == Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1 && exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(source, target).length {
				message = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
			}
			reportError(message, generalizedSourceType, targetType)
		}
		tryElaborateErrorsForPrimitivesAndObjects := func(source Type, target Type) {
			sourceType := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(source.symbol) ? typeToString(source, source.symbol.valueDeclaration) : typeToString(source) */ TODO
			targetType := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(target.symbol) ? typeToString(target, target.symbol.valueDeclaration) : typeToString(target) */ TODO
			if (globalStringType == source && stringType == target) || (globalNumberType == source && numberType == target) || (globalBooleanType == source && booleanType == target) || (getGlobalESSymbolType() == source && esSymbolType == target) {
				reportError(Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType)
			}
		}
		tryElaborateArrayLikeErrors := func(source Type, target Type, reportErrors bool) bool {
			if isTupleType(source) {
				if source.target.readonly && isMutableArrayOrTuple(target) {
					if reportErrors {
						reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target))
					}
					return false
				}
				return isArrayOrTupleType(target)
			}
			if isReadonlyArrayType(source) && isMutableArrayOrTuple(target) {
				if reportErrors {
					reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target))
				}
				return false
			}
			if isTupleType(target) {
				return isArrayType(source)
			}
			return true
		}
		isRelatedToWorker := func(source Type, target Type, reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
			return isRelatedTo(source, target, RecursionFlagsBoth, reportErrors)
		}
		isRelatedTo := func(originalSource Type, originalTarget Type, recursionFlags RecursionFlags /*  = RecursionFlags.Both */, reportErrors /* TODO inferred type boolean */ TODO /*  = false */, headMessage DiagnosticMessage, intersectionState /* TODO inferred type IntersectionState */ TODO /*  = IntersectionState.None */) Ternary {
			if originalSource == originalTarget {
				return TernaryTrue
			}
			if originalSource.flags&TypeFlagsObject && originalTarget.flags&TypeFlagsPrimitive {
				if relation == comparableRelation && !(originalTarget.flags&TypeFlagsNever) && isSimpleTypeRelatedTo(originalTarget, originalSource, relation) || isSimpleTypeRelatedTo(originalSource, originalTarget, relation /* TODO(ConditionalExpression): reportErrors ? reportError : undefined */, TODO) {
					return TernaryTrue
				}
				if reportErrors {
					reportErrorResults(originalSource, originalTarget, originalSource, originalTarget, headMessage)
				}
				return TernaryFalse
			}
			source := getNormalizedType(originalSource, false)
			target := getNormalizedType(originalTarget, true)
			if source == target {
				return TernaryTrue
			}
			if relation == identityRelation {
				if source.flags != target.flags {
					return TernaryFalse
				}
				if source.flags & TypeFlagsSingleton {
					return TernaryTrue
				}
				traceUnionsOrIntersectionsTooLarge(source, target)
				return recursiveTypeRelatedTo(source, target, false, IntersectionStateNone, recursionFlags)
			}
			if source.flags&TypeFlagsTypeParameter && getConstraintOfType(source) == target {
				return TernaryTrue
			}
			if source.flags&TypeFlagsDefinitelyNonNullable && target.flags&TypeFlagsUnion {
				types := (target).types
				candidate := /* TODO(ConditionalExpression): types.length === 2 && types[0].flags & TypeFlags.Nullable ? types[1] :                     types.length === 3 && types[0].flags & TypeFlags.Nullable && types[1].flags & TypeFlags.Nullable ? types[2] :                     undefined */ TODO
				if candidate && !(candidate.flags & TypeFlagsNullable) {
					target = getNormalizedType(candidate, true)
					if source == target {
						return TernaryTrue
					}
				}
			}
			if relation == comparableRelation && !(target.flags&TypeFlagsNever) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation /* TODO(ConditionalExpression): reportErrors ? reportError : undefined */, TODO) {
				return TernaryTrue
			}
			if source.flags&TypeFlagsStructuredOrInstantiable || target.flags&TypeFlagsStructuredOrInstantiable {
				isPerformingExcessPropertyChecks := !(intersectionState & IntersectionStateTarget) && (isObjectLiteralType(source) && getObjectFlags(source)&ObjectFlagsFreshLiteral)
				if isPerformingExcessPropertyChecks {
					if hasExcessProperties(source, target, reportErrors) {
						if reportErrors {
							reportRelationError(headMessage, source /* TODO(ConditionalExpression): originalTarget.aliasSymbol ? originalTarget : target */, TODO)
						}
						return TernaryFalse
					}
				}
				isPerformingCommonPropertyChecks := (relation != comparableRelation || isUnitType(source)) && !(intersectionState & IntersectionStateTarget) && source.flags&(TypeFlagsPrimitive|TypeFlagsObject|TypeFlagsIntersection) && source != globalObjectType && target.flags&(TypeFlagsObject|TypeFlagsIntersection) && isWeakType(target) && (getPropertiesOfType(source).length > 0 || typeHasCallOrConstructSignatures(source))
				isComparingJsxAttributes := !!(getObjectFlags(source) & ObjectFlagsJsxAttributes)
				if isPerformingCommonPropertyChecks && !hasCommonProperties(source, target, isComparingJsxAttributes) {
					if reportErrors {
						sourceString := typeToString( /* TODO(ConditionalExpression): originalSource.aliasSymbol ? originalSource : source */ TODO)
						targetString := typeToString( /* TODO(ConditionalExpression): originalTarget.aliasSymbol ? originalTarget : target */ TODO)
						calls := getSignaturesOfType(source, SignatureKindCall)
						constructs := getSignaturesOfType(source, SignatureKindConstruct)
						if calls.length > 0 && isRelatedTo(getReturnTypeOfSignature( /* TODO(ElementAccessExpression): calls[0] */ TODO), target, RecursionFlagsSource, false) || constructs.length > 0 && isRelatedTo(getReturnTypeOfSignature( /* TODO(ElementAccessExpression): constructs[0] */ TODO), target, RecursionFlagsSource, false) {
							reportError(Diagnostics.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it, sourceString, targetString)
						} else {
							reportError(Diagnostics.Type_0_has_no_properties_in_common_with_type_1, sourceString, targetString)
						}
					}
					return TernaryFalse
				}
				traceUnionsOrIntersectionsTooLarge(source, target)
				skipCaching := source.flags&TypeFlagsUnion && (source).types.length < 4 && !(target.flags&TypeFlagsUnion) || target.flags&TypeFlagsUnion && (target).types.length < 4 && !(source.flags&TypeFlagsStructuredOrInstantiable)
				result := /* TODO(ConditionalExpression): skipCaching ?                     unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) :                     recursiveTypeRelatedTo(source, target, reportErrors, intersectionState, recursionFlags) */ TODO
				if result {
					return result
				}
			}
			if reportErrors {
				reportErrorResults(originalSource, originalTarget, source, target, headMessage)
			}
			return TernaryFalse
		}
		reportErrorResults := func(originalSource Type, originalTarget Type, source Type, target Type, headMessage *DiagnosticMessage) {
			sourceHasBase := !!getSingleBaseForNonAugmentingSubtype(originalSource)
			targetHasBase := !!getSingleBaseForNonAugmentingSubtype(originalTarget)
			source = /* TODO(ConditionalExpression): (originalSource.aliasSymbol || sourceHasBase) ? originalSource : source */ TODO
			target = /* TODO(ConditionalExpression): (originalTarget.aliasSymbol || targetHasBase) ? originalTarget : target */ TODO
			maybeSuppress := overrideNextErrorInfo > 0
			if maybeSuppress {
				overrideNextErrorInfo--
			}
			if source.flags&TypeFlagsObject && target.flags&TypeFlagsObject {
				currentError := errorInfo
				tryElaborateArrayLikeErrors(source, target, true)
				if errorInfo != currentError {
					maybeSuppress = !!errorInfo
				}
			}
			if source.flags&TypeFlagsObject && target.flags&TypeFlagsPrimitive {
				tryElaborateErrorsForPrimitivesAndObjects(source, target)
			} else if source.symbol && source.flags&TypeFlagsObject && globalObjectType == source {
				reportError(Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead)
			} else if getObjectFlags(source)&ObjectFlagsJsxAttributes && target.flags&TypeFlagsIntersection {
				targetTypes := (target).types
				intrinsicAttributes := getJsxType(JsxNames.IntrinsicAttributes, errorNode)
				intrinsicClassAttributes := getJsxType(JsxNames.IntrinsicClassAttributes, errorNode)
				if !isErrorType(intrinsicAttributes) && !isErrorType(intrinsicClassAttributes) && (contains(targetTypes, intrinsicAttributes) || contains(targetTypes, intrinsicClassAttributes)) {
					return
				}
			} else {
				errorInfo = elaborateNeverIntersection(errorInfo, originalTarget)
			}
			if !headMessage && maybeSuppress {
				savedErrorState := captureErrorCalculationState()
				reportRelationError(headMessage, source, target)
				var canonical TODO
				if errorInfo && errorInfo != savedErrorState.errorInfo {
					canonical = /* TODO(ObjectLiteralExpression): { code: errorInfo.code, messageText: errorInfo.messageText } */ TODO
				}
				resetErrorInfo(savedErrorState)
				if canonical && errorInfo {
					errorInfo.canonicalHead = canonical
				}
				lastSkippedInfo = /* TODO(ArrayLiteralExpression): [source, target] */ TODO
				return
			}
			reportRelationError(headMessage, source, target)
			if source.flags&TypeFlagsTypeParameter && /* TODO(ElementAccessExpression): source.symbol?.declarations?.[0] */ TODO && !getConstraintOfType(source) {
				syntheticParam := cloneTypeParameter(source)
				syntheticParam.constraint = instantiateType(target, makeUnaryTypeMapper(source, syntheticParam))
				if hasNonCircularBaseConstraint(syntheticParam) {
					targetConstraintString := typeToString(target /* TODO(ElementAccessExpression): source.symbol.declarations[0] */, TODO)
					associateRelatedInfo(createDiagnosticForNode( /* TODO(ElementAccessExpression): source.symbol.declarations[0] */ TODO, Diagnostics.This_type_parameter_might_need_an_extends_0_constraint, targetConstraintString))
				}
			}
		}
		traceUnionsOrIntersectionsTooLarge := func(source Type, target Type) {
			if !tracing {
				return
			}
			if (source.flags & TypeFlagsUnionOrIntersection) && (target.flags & TypeFlagsUnionOrIntersection) {
				sourceUnionOrIntersection := source
				targetUnionOrIntersection := target
				if sourceUnionOrIntersection.objectFlags & targetUnionOrIntersection.objectFlags & ObjectFlagsPrimitiveUnion {
					return
				}
				sourceSize := sourceUnionOrIntersection.types.length
				targetSize := targetUnionOrIntersection.types.length
				if /* TODO(AsteriskToken): * */ /* TODO(BinaryExpression): sourceSize * targetSize */ TODO > 1e6 {
					tracing.instant(tracing.Phase.CheckTypes, "traceUnionsOrIntersectionsTooLarge_DepthLimit" /* TODO(ObjectLiteralExpression): {                         sourceId: source.id,                         sourceSize,                         targetId: target.id,                         targetSize,                         pos: errorNode?.pos,                         end: errorNode?.end,                     } */, TODO)
				}
			}
		}
		getTypeOfPropertyInTypes := func(types []Type, name __String) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			appendPropType := func(propTypes /* TODO(ArrayType): Type[] */ any, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
				type_ = getApparentType(type_)
				prop := /* TODO(ConditionalExpression): type.flags & TypeFlags.UnionOrIntersection ? getPropertyOfUnionOrIntersectionType(type as UnionOrIntersectionType, name) : getPropertyOfObjectType(type, name) */ TODO
				propType := prop && getTypeOfSymbol(prop) || getApplicableIndexInfoForName(type_, name).type_ || undefinedType
				return append(propTypes, propType)
			}
			return getUnionType(reduceLeft(types, appendPropType, nil) || emptyArray)
		}
		hasExcessProperties := func(source FreshObjectLiteralType, target Type, reportErrors bool) bool {
			if !isExcessPropertyCheckTarget(target) || !noImplicitAny && getObjectFlags(target)&ObjectFlagsJSLiteral {
				return false
			}
			isComparingJsxAttributes := !!(getObjectFlags(source) & ObjectFlagsJsxAttributes)
			if (relation == assignableRelation || relation == comparableRelation) && (isTypeSubsetOf(globalObjectType, target) || (!isComparingJsxAttributes && isEmptyObjectType(target))) {
				return false
			}
			reducedTarget := target
			var checkTypes /* TODO(ArrayType): Type[] */ any
			if target.flags & TypeFlagsUnion {
				reducedTarget = findMatchingDiscriminantType(source, target, isRelatedTo) || filterPrimitivesIfContainsNonPrimitive(target)
				checkTypes = /* TODO(ConditionalExpression): reducedTarget.flags & TypeFlags.Union ? (reducedTarget as UnionType).types : [reducedTarget] */ TODO
			}
			for _, prop := range getPropertiesOfType(source) {
				if shouldCheckAsExcessProperty(prop, source.symbol) && !isIgnoredJsxProperty(source, prop) {
					if !isKnownProperty(reducedTarget, prop.escapedName, isComparingJsxAttributes) {
						if reportErrors {
							errorTarget := filterType(reducedTarget, isExcessPropertyCheckTarget)
							if !errorNode {
								return Debug.fail()
							}
							if isJsxAttributes(errorNode) || isJsxOpeningLikeElement(errorNode) || isJsxOpeningLikeElement(errorNode.parent) {
								if prop.valueDeclaration && isJsxAttribute(prop.valueDeclaration) && getSourceFileOfNode(errorNode) == getSourceFileOfNode(prop.valueDeclaration.name) {
									errorNode = prop.valueDeclaration.name
								}
								propName := symbolToString(prop)
								suggestionSymbol := getSuggestedSymbolForNonexistentJSXAttribute(propName, errorTarget)
								suggestion := /* TODO(ConditionalExpression): suggestionSymbol ? symbolToString(suggestionSymbol) : undefined */ TODO
								if suggestion {
									reportError(Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(errorTarget), suggestion)
								} else {
									reportError(Diagnostics.Property_0_does_not_exist_on_type_1, propName, typeToString(errorTarget))
								}
							} else {
								objectLiteralDeclaration := source.symbol.declarations && firstOrUndefined(source.symbol.declarations)
								var suggestion /* TODO(StringKeyword): string */ any
								if prop.valueDeclaration && findAncestor(prop.valueDeclaration, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
									return d == objectLiteralDeclaration
								}) && getSourceFileOfNode(objectLiteralDeclaration) == getSourceFileOfNode(errorNode) {
									propDeclaration := prop.valueDeclaration
									Debug.assertNode(propDeclaration, isObjectLiteralElementLike)
									name := propDeclaration.name
									errorNode = name
									if isIdentifier(name) {
										suggestion = getSuggestionForNonexistentProperty(name, errorTarget)
									}
								}
								if suggestion != nil {
									reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2, symbolToString(prop), typeToString(errorTarget), suggestion)
								} else {
									reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(prop), typeToString(errorTarget))
								}
							}
						}
						return true
					}
					if checkTypes && !isRelatedTo(getTypeOfSymbol(prop), getTypeOfPropertyInTypes(checkTypes, prop.escapedName), RecursionFlagsBoth, reportErrors) {
						if reportErrors {
							reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(prop))
						}
						return true
					}
				}
			}
			return false
		}
		shouldCheckAsExcessProperty := func(prop Symbol, container Symbol) /* TODO inferred type boolean | undefined */ TODO {
			return prop.valueDeclaration && container.valueDeclaration && prop.valueDeclaration.parent == container.valueDeclaration
		}
		unionOrIntersectionRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			if source.flags & TypeFlagsUnion {
				if target.flags & TypeFlagsUnion {
					sourceOrigin := (source).origin
					if sourceOrigin && sourceOrigin.flags&TypeFlagsIntersection && target.aliasSymbol && contains((sourceOrigin).types, target) {
						return TernaryTrue
					}
					targetOrigin := (target).origin
					if targetOrigin && targetOrigin.flags&TypeFlagsUnion && source.aliasSymbol && contains((targetOrigin).types, source) {
						return TernaryTrue
					}
				}
				return /* TODO(ConditionalExpression): relation === comparableRelation ?                     someTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState) :                     eachTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState) */ TODO
			}
			if target.flags & TypeFlagsUnion {
				return typeRelatedToSomeType(getRegularTypeOfObjectLiteral(source), target, reportErrors && !(source.flags&TypeFlagsPrimitive) && !(target.flags&TypeFlagsPrimitive), intersectionState)
			}
			if target.flags & TypeFlagsIntersection {
				return typeRelatedToEachType(source, target, reportErrors, IntersectionStateTarget)
			}
			if relation == comparableRelation && target.flags&TypeFlagsPrimitive {
				constraints := sameMap((source).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					return /* TODO(ConditionalExpression): t.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(t) || unknownType : t */ TODO
				})
				if constraints != (source).types {
					source = getIntersectionType(constraints)
					if source.flags & TypeFlagsNever {
						return TernaryFalse
					}
					if !(source.flags & TypeFlagsIntersection) {
						return isRelatedTo(source, target, RecursionFlagsSource, false) || isRelatedTo(target, source, RecursionFlagsSource, false)
					}
				}
			}
			return someTypeRelatedToType(source, target, false, IntersectionStateSource)
		}
		eachTypeRelatedToSomeType := func(source UnionOrIntersectionType, target UnionOrIntersectionType) Ternary {
			result := TernaryTrue
			sourceTypes := source.types
			for _, sourceType := range sourceTypes {
				related := typeRelatedToSomeType(sourceType, target, false, IntersectionStateNone)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		typeRelatedToSomeType := func(source Type, target UnionOrIntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
			targetTypes := target.types
			if target.flags & TypeFlagsUnion {
				if containsType(targetTypes, source) {
					return TernaryTrue
				}
				if relation != comparableRelation && getObjectFlags(target)&ObjectFlagsPrimitiveUnion && !(source.flags & TypeFlagsEnumLiteral) && (source.flags&(TypeFlagsStringLiteral|TypeFlagsBooleanLiteral|TypeFlagsBigIntLiteral) || (relation == subtypeRelation || relation == strictSubtypeRelation) && source.flags&TypeFlagsNumberLiteral) {
					alternateForm := /* TODO(ConditionalExpression): source === (source as StringLiteralType).regularType ? (source as StringLiteralType).freshType : (source as StringLiteralType).regularType */ TODO
					primitive := /* TODO(ConditionalExpression): source.flags & TypeFlags.StringLiteral ? stringType :                         source.flags & TypeFlags.NumberLiteral ? numberType :                         source.flags & TypeFlags.BigIntLiteral ? bigintType :                         undefined */ TODO
					return /* TODO(ConditionalExpression): primitive && containsType(targetTypes, primitive) || alternateForm && containsType(targetTypes, alternateForm) ? Ternary.True : Ternary.False */ TODO
				}
				match := getMatchingUnionConstituentForType(target, source)
				if match {
					related := isRelatedTo(source, match, RecursionFlagsTarget, false, nil, intersectionState)
					if related {
						return related
					}
				}
			}
			for _, type_ := range targetTypes {
				related := isRelatedTo(source, type_, RecursionFlagsTarget, false, nil, intersectionState)
				if related {
					return related
				}
			}
			if reportErrors {
				bestMatchingType := getBestMatchingType(source, target, isRelatedTo)
				if bestMatchingType {
					isRelatedTo(source, bestMatchingType, RecursionFlagsTarget, true, nil, intersectionState)
				}
			}
			return TernaryFalse
		}
		typeRelatedToEachType := func(source Type, target IntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := TernaryTrue
			targetTypes := target.types
			for _, targetType := range targetTypes {
				related := isRelatedTo(source, targetType, RecursionFlagsTarget, reportErrors, nil, intersectionState)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		someTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			sourceTypes := source.types
			if source.flags&TypeFlagsUnion && containsType(sourceTypes, target) {
				return TernaryTrue
			}
			len := sourceTypes.length
			/* TODO(ForStatement): for (let i = 0; i < len; i++) {                 const related = isRelatedTo(sourceTypes[i], target, RecursionFlags.Source, reportErrors && i === len - 1, /*headMessage* / undefined, intersectionState);                 if (related) {                     return related;                 }             } */
			return TernaryFalse
		}
		getUndefinedStrippedTargetIfNeeded := func(source Type, target Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if source.flags&TypeFlagsUnion && target.flags&TypeFlagsUnion && !( /* TODO(ElementAccessExpression): (source as UnionType).types[0] */ TODO.flags & TypeFlagsUndefined) && /* TODO(ElementAccessExpression): (target as UnionType).types[0] */ TODO.flags&TypeFlagsUndefined {
				return extractTypesOfKind(target, ~TypeFlagsUndefined)
			}
			return target
		}
		eachTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := TernaryTrue
			sourceTypes := source.types
			undefinedStrippedTarget := getUndefinedStrippedTargetIfNeeded(source, target)
			/* TODO(ForStatement): for (let i = 0; i < sourceTypes.length; i++) {                 const sourceType = sourceTypes[i];                 if (undefinedStrippedTarget.flags & TypeFlags.Union && sourceTypes.length >= (undefinedStrippedTarget as UnionType).types.length && sourceTypes.length % (undefinedStrippedTarget as UnionType).types.length === 0) {                     // many unions are mappings of one another; in such cases, simply comparing members at the same index can shortcut the comparison                     // such unions will have identical lengths, and their corresponding elements will match up. Another common scenario is where a large                     // union has a union of objects intersected with it. In such cases, if the input was, eg `("a" | "b" | "c") & (string | boolean | {} | {whatever})`,                     // the result will have the structure `"a" | "b" | "c" | "a" & {} | "b" & {} | "c" & {} | "a" & {whatever} | "b" & {whatever} | "c" & {whatever}`                     // - the resulting union has a length which is a multiple of the original union, and the elements correspond modulo the length of the original union                     const related = isRelatedTo(sourceType, (undefinedStrippedTarget as UnionType).types[i % (undefinedStrippedTarget as UnionType).types.length], RecursionFlags.Both, /*reportErrors* / false, /*headMessage* / undefined, intersectionState);                     if (related) {                         result &= related;                         continue;                     }                 }                 const related = isRelatedTo(sourceType, target, RecursionFlags.Source, reportErrors, /*headMessage* / undefined, intersectionState);                 if (!related) {                     return Ternary.False;                 }                 result &= related;             } */
			return result
		}
		typeArgumentsRelatedTo := func(sources []Type /*  = emptyArray */, targets []Type /*  = emptyArray */, variances []VarianceFlags /*  = emptyArray */, reportErrors bool, intersectionState IntersectionState) Ternary {
			if sources.length != targets.length && relation == identityRelation {
				return TernaryFalse
			}
			length := /* TODO(ConditionalExpression): sources.length <= targets.length ? sources.length : targets.length */ TODO
			result := TernaryTrue
			/* TODO(ForStatement): for (let i = 0; i < length; i++) {                 // When variance information isn't available we default to covariance. This happens                 // in the process of computing variance information for recursive types and when                 // comparing 'this' type arguments.                 const varianceFlags = i < variances.length ? variances[i] : VarianceFlags.Covariant;                 const variance = varianceFlags & VarianceFlags.VarianceMask;                 // We ignore arguments for independent type parameters (because they're never witnessed).                 if (variance !== VarianceFlags.Independent) {                     const s = sources[i];                     const t = targets[i];                     let related = Ternary.True;                     if (varianceFlags & VarianceFlags.Unmeasurable) {                         // Even an `Unmeasurable` variance works out without a structural check if the source and target are _identical_.                         // We can't simply assume invariance, because `Unmeasurable` marks nonlinear relations, for example, a relation tained by                         // the `-?` modifier in a mapped type (where, no matter how the inputs are related, the outputs still might not be)                         related = relation === identityRelation ? isRelatedTo(s, t, RecursionFlags.Both, /*reportErrors* / false) : compareTypesIdentical(s, t);                     }                     else if (variance === VarianceFlags.Covariant) {                         related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                     }                     else if (variance === VarianceFlags.Contravariant) {                         related = isRelatedTo(t, s, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                     }                     else if (variance === VarianceFlags.Bivariant) {                         // In the bivariant case we first compare contravariantly without reporting                         // errors. Then, if that doesn't succeed, we compare covariantly with error                         // reporting. Thus, error elaboration will be based on the the covariant check,                         // which is generally easier to reason about.                         related = isRelatedTo(t, s, RecursionFlags.Both, /*reportErrors* / false);                         if (!related) {                             related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         }                     }                     else {                         // In the invariant case we first compare covariantly, and only when that                         // succeeds do we proceed to compare contravariantly. Thus, error elaboration                         // will typically be based on the covariant check.                         related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         if (related) {                             related &= isRelatedTo(t, s, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         }                     }                     if (!related) {                         return Ternary.False;                     }                     result &= related;                 }             } */
			return result
		}
		recursiveTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, recursionFlags RecursionFlags) Ternary {
			if overflow {
				return TernaryFalse
			}
			id := getRelationKey(source, target, intersectionState, relation, false)
			entry := relation.get(id)
			if entry != nil {
				if reportErrors && entry&RelationComparisonResultFailed && !(entry & RelationComparisonResultOverflow) {
				} else {
					if outofbandVarianceMarkerHandler {
						saved := entry & RelationComparisonResultReportsMask
						if saved & RelationComparisonResultReportsUnmeasurable {
							instantiateType(source, reportUnmeasurableMapper)
						}
						if saved & RelationComparisonResultReportsUnreliable {
							instantiateType(source, reportUnreliableMapper)
						}
					}
					if reportErrors && entry&RelationComparisonResultOverflow {
						message := /* TODO(ConditionalExpression): entry & RelationComparisonResult.ComplexityOverflow ?                             Diagnostics.Excessive_complexity_comparing_types_0_and_1 :                             Diagnostics.Excessive_stack_depth_comparing_types_0_and_1 */ TODO
						reportError(message, typeToString(source), typeToString(target))
						overrideNextErrorInfo++
					}
					return /* TODO(ConditionalExpression): entry & RelationComparisonResult.Succeeded ? Ternary.True : Ternary.False */ TODO
				}
			}
			if relationCount <= 0 {
				overflow = true
				return TernaryFalse
			}
			if !maybeKeys {
				maybeKeys = /* TODO(ArrayLiteralExpression): [] */ TODO
				maybeKeysSet = /* TODO(NewExpression): new Set() */ make(map[any]struct{})
				sourceStack = /* TODO(ArrayLiteralExpression): [] */ TODO
				targetStack = /* TODO(ArrayLiteralExpression): [] */ TODO
			} else {
				if maybeKeysSet.has(id) {
					return TernaryMaybe
				}
				broadestEquivalentId := /* TODO(ConditionalExpression): id.startsWith("*") ? getRelationKey(source, target, intersectionState, relation, /*ignoreConstraints* / true) : undefined */ TODO
				if broadestEquivalentId && maybeKeysSet.has(broadestEquivalentId) {
					return TernaryMaybe
				}
				if sourceDepth == 100 || targetDepth == 100 {
					overflow = true
					return TernaryFalse
				}
			}
			maybeStart := maybeCount
			/* TODO(ElementAccessExpression): maybeKeys[maybeCount] */ TODO = id
			maybeKeysSet.add(id)
			maybeCount++
			saveExpandingFlags := expandingFlags
			if recursionFlags & RecursionFlagsSource {
				/* TODO(ElementAccessExpression): sourceStack[sourceDepth] */ TODO = source
				sourceDepth++
				if !(expandingFlags & ExpandingFlagsSource) && isDeeplyNestedType(source, sourceStack, sourceDepth) {
					expandingFlags |= ExpandingFlagsSource
				}
			}
			if recursionFlags & RecursionFlagsTarget {
				/* TODO(ElementAccessExpression): targetStack[targetDepth] */ TODO = target
				targetDepth++
				if !(expandingFlags & ExpandingFlagsTarget) && isDeeplyNestedType(target, targetStack, targetDepth) {
					expandingFlags |= ExpandingFlagsTarget
				}
			}
			var originalHandler /* TODO(TypeQuery): typeof outofbandVarianceMarkerHandler */ any
			propagatingVarianceFlags := 0
			if outofbandVarianceMarkerHandler {
				originalHandler = outofbandVarianceMarkerHandler
				outofbandVarianceMarkerHandler = func(onlyUnreliable /* TODO inferred type boolean */ TODO) {
					propagatingVarianceFlags |= /* TODO(ConditionalExpression): onlyUnreliable ? RelationComparisonResult.ReportsUnreliable : RelationComparisonResult.ReportsUnmeasurable */ TODO
					return originalHandler(onlyUnreliable)
				}
			}
			var result Ternary
			if expandingFlags == ExpandingFlagsBoth {
				tracing.instant(tracing.Phase.CheckTypes, "recursiveTypeRelatedTo_DepthLimit" /* TODO(ObjectLiteralExpression): {                     sourceId: source.id,                     sourceIdStack: sourceStack.map(t => t.id),                     targetId: target.id,                     targetIdStack: targetStack.map(t => t.id),                     depth: sourceDepth,                     targetDepth,                 } */, TODO)
				result = TernaryMaybe
			} else {
				tracing.push(tracing.Phase.CheckTypes, "structuredTypeRelatedTo" /* TODO(ObjectLiteralExpression): { sourceId: source.id, targetId: target.id } */, TODO)
				result = structuredTypeRelatedTo(source, target, reportErrors, intersectionState)
				tracing.pop()
			}
			if outofbandVarianceMarkerHandler {
				outofbandVarianceMarkerHandler = originalHandler
			}
			if recursionFlags & RecursionFlagsSource {
				sourceDepth--
			}
			if recursionFlags & RecursionFlagsTarget {
				targetDepth--
			}
			expandingFlags = saveExpandingFlags
			if result {
				if result == TernaryTrue || (sourceDepth == 0 && targetDepth == 0) {
					if result == TernaryTrue || result == TernaryMaybe {
						resetMaybeStack(true)
					} else {
						resetMaybeStack(false)
					}
				}
			} else {
				relation.set(id, RelationComparisonResultFailed|propagatingVarianceFlags)
				relationCount--
				resetMaybeStack(false)
			}
			return result
			resetMaybeStack := func(markAllAsSucceeded bool) {
				/* TODO(ForStatement): for (let i = maybeStart; i < maybeCount; i++) {                     maybeKeysSet.delete(maybeKeys[i]);                     if (markAllAsSucceeded) {                         relation.set(maybeKeys[i], RelationComparisonResult.Succeeded | propagatingVarianceFlags);                         relationCount--;                     }                 } */
				maybeCount = maybeStart
			}
		}
		structuredTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			saveErrorInfo := captureErrorCalculationState()
			result := structuredTypeRelatedToWorker(source, target, reportErrors, intersectionState, saveErrorInfo)
			if relation != identityRelation {
				if !result && (source.flags&TypeFlagsIntersection || source.flags&TypeFlagsTypeParameter && target.flags&TypeFlagsUnion) {
					constraint := getEffectiveConstraintOfIntersection( /* TODO(ConditionalExpression): source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source] */ TODO, !!(target.flags & TypeFlagsUnion))
					if constraint && everyType(constraint, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
						return c != source
					}) {
						result = isRelatedTo(constraint, target, RecursionFlagsSource, false, nil, intersectionState)
					}
				}
				if result && !(intersectionState & IntersectionStateTarget) && target.flags&TypeFlagsIntersection && !isGenericObjectType(target) && source.flags&(TypeFlagsObject|TypeFlagsIntersection) {
					result &= propertiesRelatedTo(source, target, reportErrors, nil, false, IntersectionStateNone)
					if result && isObjectLiteralType(source) && getObjectFlags(source)&ObjectFlagsFreshLiteral {
						result &= indexSignaturesRelatedTo(source, target, false, reportErrors, IntersectionStateNone)
					}
				} else if result && isNonGenericObjectType(target) && !isArrayOrTupleType(target) && source.flags&TypeFlagsIntersection && getApparentType(source).flags&TypeFlagsStructuredType && !some((source).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return t == target || !!(getObjectFlags(t) & ObjectFlagsNonInferrableType)
				}) {
					result &= propertiesRelatedTo(source, target, reportErrors, nil, true, intersectionState)
				}
			}
			if result {
				resetErrorInfo(saveErrorInfo)
			}
			return result
		}
		getApparentMappedTypeKeys := func(nameType Type, targetType MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			modifiersType := getApparentType(getModifiersTypeFromMappedType(targetType))
			var mappedKeys []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, TypeFlagsStringOrNumberLiteralOrUnique, false, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type undefined */ TODO {
				return /* TODO(VoidExpression): void mappedKeys.push(instantiateType(nameType, appendTypeMapping(targetType.mapper, getTypeParameterFromMappedType(targetType), t))) */ TODO
			})
			return getUnionType(mappedKeys)
		}
		structuredTypeRelatedToWorker := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, saveErrorInfo ReturnType[ /* TODO(TypeQuery): typeof captureErrorCalculationState */ any]) Ternary {
			var result Ternary
			var originalErrorInfo *DiagnosticMessageChain
			varianceCheckFailed := false
			sourceFlags := source.flags
			targetFlags := target.flags
			if relation == identityRelation {
				if sourceFlags & TypeFlagsUnionOrIntersection {
					result := eachTypeRelatedToSomeType(source, target)
					if result {
						result &= eachTypeRelatedToSomeType(target, source)
					}
					return result
				}
				if sourceFlags & TypeFlagsIndex {
					return isRelatedTo((source).type_, (target).type_, RecursionFlagsBoth, false)
				}
				if sourceFlags & TypeFlagsIndexedAccess {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							return result
						}
					}
				}
				if sourceFlags & TypeFlagsConditional {
					if (source).root.isDistributive == (target).root.isDistributive {
						if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as ConditionalType).checkType, (target as ConditionalType).checkType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo((source as ConditionalType).extendsType, (target as ConditionalType).extendsType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
								if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo(getTrueTypeFromConditionalType(source as ConditionalType), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
									if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
										return result
									}
								}
							}
						}
					}
				}
				if sourceFlags & TypeFlagsSubstitution {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as SubstitutionType).baseType, (target as SubstitutionType).baseType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo((source as SubstitutionType).constraint, (target as SubstitutionType).constraint, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							return result
						}
					}
				}
				if !(sourceFlags & TypeFlagsObject) {
					return TernaryFalse
				}
			} else if sourceFlags&TypeFlagsUnionOrIntersection || targetFlags&TypeFlagsUnionOrIntersection {
				if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) */ TODO {
					return result
				}
				if !(sourceFlags&TypeFlagsInstantiable || sourceFlags&TypeFlagsObject && targetFlags&TypeFlagsUnion || sourceFlags&TypeFlagsIntersection && targetFlags&(TypeFlagsObject|TypeFlagsUnion|TypeFlagsInstantiable)) {
					return TernaryFalse
				}
			}
			if sourceFlags&(TypeFlagsObject|TypeFlagsConditional) && source.aliasSymbol && source.aliasTypeArguments && source.aliasSymbol == target.aliasSymbol && !(isMarkerType(source) || isMarkerType(target)) {
				variances := getAliasVariances(source.aliasSymbol)
				if variances == emptyArray {
					return TernaryUnknown
				}
				params := getSymbolLinks(source.aliasSymbol).typeParameters
				minParams := getMinTypeArgumentCount(params)
				sourceTypes := fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
				targetTypes := fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
				varianceResult := relateVariances(sourceTypes, targetTypes, variances, intersectionState)
				if varianceResult != nil {
					return varianceResult
				}
			}
			if isSingleElementGenericTupleType(source) && !source.target.readonly && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(getTypeArguments(source)[0], target, RecursionFlags.Source) */ TODO) || isSingleElementGenericTupleType(target) && (target.target.readonly || isMutableArrayOrTuple(getBaseConstraintOfType(source) || source)) && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(source, getTypeArguments(target)[0], RecursionFlags.Target) */ TODO) {
				return result
			}
			if targetFlags & TypeFlagsTypeParameter {
				if getObjectFlags(source)&ObjectFlagsMapped && !(source).declaration.nameType && isRelatedTo(getIndexType(target), getConstraintTypeFromMappedType(source), RecursionFlagsBoth) {
					if !(getMappedTypeModifiers(source) & MappedTypeModifiersIncludeOptional) {
						templateType := getTemplateTypeFromMappedType(source)
						indexedAccessType := getIndexedAccessType(target, getTypeParameterFromMappedType(source))
						if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(templateType, indexedAccessType, RecursionFlags.Both, reportErrors) */ TODO {
							return result
						}
					}
				}
				if relation == comparableRelation && sourceFlags&TypeFlagsTypeParameter {
					constraint := getConstraintOfTypeParameter(source)
					if constraint {
						for constraint && someType(constraint, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
							return !!(c.flags & TypeFlagsTypeParameter)
						}) {
							if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false) */ TODO {
								return result
							}
							constraint = getConstraintOfTypeParameter(constraint)
						}
					}
					return TernaryFalse
				}
			} else if targetFlags & TypeFlagsIndex {
				targetType := (target).type_
				if sourceFlags & TypeFlagsIndex {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(targetType, (source as IndexType).type, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						return result
					}
				}
				if isTupleType(targetType) {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(source, getKnownKeysOfTupleType(targetType), RecursionFlags.Target, reportErrors) */ TODO {
						return result
					}
				} else {
					constraint := getSimplifiedTypeOrConstraint(targetType)
					if constraint {
						if isRelatedTo(source, getIndexType(constraint, (target).indexFlags|IndexFlagsNoReducibleCheck), RecursionFlagsTarget, reportErrors) == TernaryTrue {
							return TernaryTrue
						}
					} else if isGenericMappedType(targetType) {
						nameType := getNameTypeFromMappedType(targetType)
						constraintType := getConstraintTypeFromMappedType(targetType)
						var targetKeys TODO
						if nameType && isMappedTypeWithKeyofConstraintDeclaration(targetType) {
							mappedKeys := getApparentMappedTypeKeys(nameType, targetType)
							targetKeys = getUnionType( /* TODO(ArrayLiteralExpression): [mappedKeys, nameType] */ TODO)
						} else {
							targetKeys = nameType || constraintType
						}
						if isRelatedTo(source, targetKeys, RecursionFlagsTarget, reportErrors) == TernaryTrue {
							return TernaryTrue
						}
					}
				}
			} else if targetFlags & TypeFlagsIndexedAccess {
				if sourceFlags & TypeFlagsIndexedAccess {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, reportErrors) */ TODO {
						result &= isRelatedTo((source).indexType, (target).indexType, RecursionFlagsBoth, reportErrors)
					}
					if result {
						return result
					}
					if reportErrors {
						originalErrorInfo = errorInfo
					}
				}
				if relation == assignableRelation || relation == comparableRelation {
					objectType := (target).objectType
					indexType := (target).indexType
					baseObjectType := getBaseConstraintOfType(objectType) || objectType
					baseIndexType := getBaseConstraintOfType(indexType) || indexType
					if !isGenericObjectType(baseObjectType) && !isGenericIndexType(baseIndexType) {
						accessFlags := AccessFlagsWriting | ( /* TODO(ConditionalExpression): baseObjectType !== objectType ? AccessFlags.NoIndexSignatures : 0 */ TODO)
						constraint := getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, accessFlags)
						if constraint {
							if reportErrors && originalErrorInfo {
								resetErrorInfo(saveErrorInfo)
							}
							if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(source, constraint, RecursionFlags.Target, reportErrors, /*headMessage* / undefined, intersectionState) */ TODO {
								return result
							}
							if reportErrors && originalErrorInfo && errorInfo {
								errorInfo = /* TODO(ConditionalExpression): countMessageChainBreadth([originalErrorInfo]) <= countMessageChainBreadth([errorInfo]) ? originalErrorInfo : errorInfo */ TODO
							}
						}
					}
				}
				if reportErrors {
					originalErrorInfo = nil
				}
			} else if isGenericMappedType(target) && relation != identityRelation {
				keysRemapped := !!target.declaration.nameType
				templateType := getTemplateTypeFromMappedType(target)
				modifiers := getMappedTypeModifiers(target)
				if !(modifiers & MappedTypeModifiersExcludeOptional) {
					if !keysRemapped && templateType.flags&TypeFlagsIndexedAccess && (templateType).objectType == source && (templateType).indexType == getTypeParameterFromMappedType(target) {
						return TernaryTrue
					}
					if !isGenericMappedType(source) {
						targetKeys := /* TODO(ConditionalExpression): keysRemapped ? getNameTypeFromMappedType(target)! : getConstraintTypeFromMappedType(target) */ TODO
						sourceKeys := getIndexType(source, IndexFlagsNoIndexSignatures)
						includeOptional := modifiers & MappedTypeModifiersIncludeOptional
						filteredByApplicability := /* TODO(ConditionalExpression): includeOptional ? intersectTypes(targetKeys, sourceKeys) : undefined */ TODO
						if /* TODO(ConditionalExpression): includeOptional                                 ? !(filteredByApplicability!.flags & TypeFlags.Never)                                 : isRelatedTo(targetKeys, sourceKeys, RecursionFlags.Both) */ TODO {
							templateType := getTemplateTypeFromMappedType(target)
							typeParameter := getTypeParameterFromMappedType(target)
							nonNullComponent := extractTypesOfKind(templateType, ~TypeFlagsNullable)
							if !keysRemapped && nonNullComponent.flags&TypeFlagsIndexedAccess && (nonNullComponent).indexType == typeParameter {
								if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(source, (nonNullComponent as IndexedAccessType).objectType, RecursionFlags.Target, reportErrors) */ TODO {
									return result
								}
							} else {
								indexingType := /* TODO(ConditionalExpression): keysRemapped                                     ? (filteredByApplicability || targetKeys)                                     : filteredByApplicability                                     ? getIntersectionType([filteredByApplicability, typeParameter])                                     : typeParameter */ TODO
								indexedAccessType := getIndexedAccessType(source, indexingType)
								if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(indexedAccessType, templateType, RecursionFlags.Both, reportErrors) */ TODO {
									return result
								}
							}
						}
						originalErrorInfo = errorInfo
						resetErrorInfo(saveErrorInfo)
					}
				}
			} else if targetFlags & TypeFlagsConditional {
				if isDeeplyNestedType(target, targetStack, targetDepth, 10) {
					return TernaryMaybe
				}
				c := target
				if !c.root.inferTypeParameters && !isDistributionDependent(c.root) && !(source.flags&TypeFlagsConditional && (source).root == c.root) {
					skipTrue := !isTypeAssignableTo(getPermissiveInstantiation(c.checkType), getPermissiveInstantiation(c.extendsType))
					skipFalse := !skipTrue && isTypeAssignableTo(getRestrictiveInstantiation(c.checkType), getRestrictiveInstantiation(c.extendsType))
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = skipTrue ? Ternary.True : isRelatedTo(source, getTrueTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
						result &= /* TODO(ConditionalExpression): skipFalse ? Ternary.True : isRelatedTo(source, getFalseTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO
						if result {
							return result
						}
					}
				}
			} else if targetFlags & TypeFlagsTemplateLiteral {
				if sourceFlags & TypeFlagsTemplateLiteral {
					if relation == comparableRelation {
						return /* TODO(ConditionalExpression): templateLiteralTypesDefinitelyUnrelated(source as TemplateLiteralType, target as TemplateLiteralType) ? Ternary.False : Ternary.True */ TODO
					}
					instantiateType(source, reportUnreliableMapper)
				}
				if isTypeMatchedByTemplateLiteralType(source, target) {
					return TernaryTrue
				}
			} else if target.flags & TypeFlagsStringMapping {
				if !(source.flags & TypeFlagsStringMapping) {
					if isMemberOfStringMapping(source, target) {
						return TernaryTrue
					}
				}
			}
			if sourceFlags & TypeFlagsTypeVariable {
				if !(sourceFlags&TypeFlagsIndexedAccess && targetFlags&TypeFlagsIndexedAccess) {
					constraint := getConstraintOfType(source) || unknownType
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
						return result
					} else if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(getTypeWithThisArgument(constraint, source), target, RecursionFlags.Source, reportErrors && constraint !== unknownType && !(targetFlags & sourceFlags & TypeFlags.TypeParameter), /*headMessage* / undefined, intersectionState) */ TODO {
						return result
					}
					if isMappedTypeGenericIndexedAccess(source) {
						indexConstraint := getConstraintOfType((source).indexType)
						if indexConstraint {
							if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(getIndexedAccessType((source as IndexedAccessType).objectType, indexConstraint), target, RecursionFlags.Source, reportErrors) */ TODO {
								return result
							}
						}
					}
				}
			} else if sourceFlags & TypeFlagsIndex {
				isDeferredMappedIndex := shouldDeferIndexType((source).type_, (source).indexFlags) && getObjectFlags((source).type_)&ObjectFlagsMapped
				if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(stringNumberSymbolType, target, RecursionFlags.Source, reportErrors && !isDeferredMappedIndex) */ TODO {
					return result
				}
				if isDeferredMappedIndex {
					mappedType := (source).type_
					nameType := getNameTypeFromMappedType(mappedType)
					sourceMappedKeys := /* TODO(ConditionalExpression): nameType && isMappedTypeWithKeyofConstraintDeclaration(mappedType) ? getApparentMappedTypeKeys(nameType, mappedType) : (nameType || getConstraintTypeFromMappedType(mappedType)) */ TODO
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(sourceMappedKeys, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
			} else if sourceFlags&TypeFlagsTemplateLiteral && !(targetFlags & TypeFlagsObject) {
				if !(targetFlags & TypeFlagsTemplateLiteral) {
					constraint := getBaseConstraintOfType(source)
					if constraint && constraint != source && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors) */ TODO) {
						return result
					}
				}
			} else if sourceFlags & TypeFlagsStringMapping {
				if targetFlags & TypeFlagsStringMapping {
					if (source).symbol != (target).symbol {
						return TernaryFalse
					}
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as StringMappingType).type, (target as StringMappingType).type, RecursionFlags.Both, reportErrors) */ TODO {
						return result
					}
				} else {
					constraint := getBaseConstraintOfType(source)
					if constraint && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors) */ TODO) {
						return result
					}
				}
			} else if sourceFlags & TypeFlagsConditional {
				if isDeeplyNestedType(source, sourceStack, sourceDepth, 10) {
					return TernaryMaybe
				}
				if targetFlags & TypeFlagsConditional {
					sourceParams := (source).root.inferTypeParameters
					sourceExtends := (source).extendsType
					var mapper *TypeMapper
					if sourceParams {
						ctx := createInferenceContext(sourceParams, nil, InferenceFlagsNone, isRelatedToWorker)
						inferTypes(ctx.inferences, (target).extendsType, sourceExtends, InferencePriorityNoConstraints|InferencePriorityAlwaysStrict)
						sourceExtends = instantiateType(sourceExtends, ctx.mapper)
						mapper = ctx.mapper
					}
					if isTypeIdenticalTo(sourceExtends, (target).extendsType) && (isRelatedTo((source).checkType, (target).checkType, RecursionFlagsBoth) || isRelatedTo((target).checkType, (source).checkType, RecursionFlagsBoth)) {
						if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(instantiateType(getTrueTypeFromConditionalType(source as ConditionalType), mapper), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, reportErrors) */ TODO {
							result &= isRelatedTo(getFalseTypeFromConditionalType(source), getFalseTypeFromConditionalType(target), RecursionFlagsBoth, reportErrors)
						}
						if result {
							return result
						}
					}
				}
				defaultConstraint := getDefaultConstraintOfConditionalType(source)
				if defaultConstraint {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(defaultConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
				distributiveConstraint := /* TODO(ConditionalExpression): !(targetFlags & TypeFlags.Conditional) && hasNonCircularBaseConstraint(source) ? getConstraintOfDistributiveConditionalType(source as ConditionalType) : undefined */ TODO
				if distributiveConstraint {
					resetErrorInfo(saveErrorInfo)
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(distributiveConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
			} else {
				if relation != subtypeRelation && relation != strictSubtypeRelation && isPartialMappedType(target) && isEmptyObjectType(source) {
					return TernaryTrue
				}
				if isGenericMappedType(target) {
					if isGenericMappedType(source) {
						if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = mappedTypeRelatedTo(source, target, reportErrors) */ TODO {
							return result
						}
					}
					return TernaryFalse
				}
				sourceIsPrimitive := !!(sourceFlags & TypeFlagsPrimitive)
				if relation != identityRelation {
					source = getApparentType(source)
					sourceFlags = source.flags
				} else if isGenericMappedType(source) {
					return TernaryFalse
				}
				if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && (source).target == (target).target && !isTupleType(source) && !(isMarkerType(source) || isMarkerType(target)) {
					if isEmptyArrayLiteralType(source) {
						return TernaryTrue
					}
					variances := getVariances((source).target)
					if variances == emptyArray {
						return TernaryUnknown
					}
					varianceResult := relateVariances(getTypeArguments(source), getTypeArguments(target), variances, intersectionState)
					if varianceResult != nil {
						return varianceResult
					}
				} else if /* TODO(ConditionalExpression): isReadonlyArrayType(target) ? everyType(source, isArrayOrTupleType) : isArrayType(target) && everyType(source, t => isTupleType(t) && !t.target.readonly) */ TODO {
					if relation != identityRelation {
						return isRelatedTo(getIndexTypeOfType(source, numberType) || anyType, getIndexTypeOfType(target, numberType) || anyType, RecursionFlagsBoth, reportErrors)
					} else {
						return TernaryFalse
					}
				} else if isGenericTupleType(source) && isTupleType(target) && !isGenericTupleType(target) {
					constraint := getBaseConstraintOrType(source)
					if constraint != source {
						return isRelatedTo(constraint, target, RecursionFlagsSource, reportErrors)
					}
				} else if (relation == subtypeRelation || relation == strictSubtypeRelation) && isEmptyObjectType(target) && getObjectFlags(target)&ObjectFlagsFreshLiteral && !isEmptyObjectType(source) {
					return TernaryFalse
				}
				if sourceFlags&(TypeFlagsObject|TypeFlagsIntersection) && targetFlags&TypeFlagsObject {
					reportStructuralErrors := reportErrors && errorInfo == saveErrorInfo.errorInfo && !sourceIsPrimitive
					result = propertiesRelatedTo(source, target, reportStructuralErrors, nil, false, intersectionState)
					if result {
						result &= signaturesRelatedTo(source, target, SignatureKindCall, reportStructuralErrors, intersectionState)
						if result {
							result &= signaturesRelatedTo(source, target, SignatureKindConstruct, reportStructuralErrors, intersectionState)
							if result {
								result &= indexSignaturesRelatedTo(source, target, sourceIsPrimitive, reportStructuralErrors, intersectionState)
							}
						}
					}
					if varianceCheckFailed && result {
						errorInfo = originalErrorInfo || errorInfo || saveErrorInfo.errorInfo
					} else if result {
						return result
					}
				}
				if sourceFlags&(TypeFlagsObject|TypeFlagsIntersection) && targetFlags&TypeFlagsUnion {
					objectOnlyTarget := extractTypesOfKind(target, TypeFlagsObject|TypeFlagsIntersection|TypeFlagsSubstitution)
					if objectOnlyTarget.flags & TypeFlagsUnion {
						result := typeRelatedToDiscriminatedType(source, objectOnlyTarget)
						if result {
							return result
						}
					}
				}
			}
			return TernaryFalse
			countMessageChainBreadth := func(info /* TODO(ArrayType): DiagnosticMessageChain[] */ any) number {
				if !info {
					return 0
				}
				return reduceLeft(info, func(value /* TODO inferred type number */ TODO, chain /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ TODO) /* TODO inferred type number */ TODO {
					return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): value + 1 + countMessageChainBreadth(chain.next) */ TODO
				}, 0)
			}
			relateVariances := func(sourceTypeArguments /* TODO(TypeOperator): readonly Type[] */ any, targetTypeArguments /* TODO(TypeOperator): readonly Type[] */ any, variances []VarianceFlags, intersectionState IntersectionState) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary | undefined */ TODO {
				if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = typeArgumentsRelatedTo(sourceTypeArguments, targetTypeArguments, variances, reportErrors, intersectionState) */ TODO {
					return result
				}
				if some(variances, func(v /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").VarianceFlags */ TODO) /* TODO inferred type boolean */ TODO {
					return !!(v & VarianceFlagsAllowsStructuralFallback)
				}) {
					originalErrorInfo = nil
					resetErrorInfo(saveErrorInfo)
					return nil
				}
				allowStructuralFallback := targetTypeArguments && hasCovariantVoidArgument(targetTypeArguments, variances)
				varianceCheckFailed = !allowStructuralFallback
				if variances != emptyArray && !allowStructuralFallback {
					if varianceCheckFailed && !(reportErrors && some(variances, func(v /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").VarianceFlags */ TODO) /* TODO inferred type boolean */ TODO {
						return (v & VarianceFlagsVarianceMask) == VarianceFlagsInvariant
					})) {
						return TernaryFalse
					}
					originalErrorInfo = errorInfo
					resetErrorInfo(saveErrorInfo)
				}
			}
		}
		mappedTypeRelatedTo := func(source MappedType, target MappedType, reportErrors bool) Ternary {
			modifiersRelated := relation == comparableRelation || ( /* TODO(ConditionalExpression): relation === identityRelation ? getMappedTypeModifiers(source) === getMappedTypeModifiers(target) :                 getCombinedMappedTypeOptionality(source) <= getCombinedMappedTypeOptionality(target) */ TODO)
			if modifiersRelated {
				var result Ternary
				targetConstraint := getConstraintTypeFromMappedType(target)
				sourceConstraint := instantiateType(getConstraintTypeFromMappedType(source) /* TODO(ConditionalExpression): getCombinedMappedTypeOptionality(source) < 0 ? reportUnmeasurableMapper : reportUnreliableMapper */, TODO)
				if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(targetConstraint, sourceConstraint, RecursionFlags.Both, reportErrors) */ TODO {
					mapper := createTypeMapper( /* TODO(ArrayLiteralExpression): [getTypeParameterFromMappedType(source)] */ TODO /* TODO(ArrayLiteralExpression): [getTypeParameterFromMappedType(target)] */, TODO)
					if instantiateType(getNameTypeFromMappedType(source), mapper) == instantiateType(getNameTypeFromMappedType(target), mapper) {
						return result & isRelatedTo(instantiateType(getTemplateTypeFromMappedType(source), mapper), getTemplateTypeFromMappedType(target), RecursionFlagsBoth, reportErrors)
					}
				}
			}
			return TernaryFalse
		}
		typeRelatedToDiscriminatedType := func(source Type, target UnionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
			sourceProperties := getPropertiesOfType(source)
			sourcePropertiesFiltered := findDiscriminantProperties(sourceProperties, target)
			if !sourcePropertiesFiltered {
				return TernaryFalse
			}
			numCombinations := 1
			for _, sourceProperty := range sourcePropertiesFiltered {
				numCombinations *= countTypes(getNonMissingTypeOfSymbol(sourceProperty))
				if numCombinations > 25 {
					tracing.instant(tracing.Phase.CheckTypes, "typeRelatedToDiscriminatedType_DepthLimit" /* TODO(ObjectLiteralExpression): { sourceId: source.id, targetId: target.id, numCombinations } */, TODO)
					return TernaryFalse
				}
			}
			var sourceDiscriminantTypes [][]Type = /* TODO(NewExpression): new Array<Type[]>(sourcePropertiesFiltered.length) */ TODO
			excludedProperties := make(map[__String]struct{})
			/* TODO(ForStatement): for (let i = 0; i < sourcePropertiesFiltered.length; i++) {                 const sourceProperty = sourcePropertiesFiltered[i];                 const sourcePropertyType = getNonMissingTypeOfSymbol(sourceProperty);                 sourceDiscriminantTypes[i] = sourcePropertyType.flags & TypeFlags.Union                     ? (sourcePropertyType as UnionType).types                     : [sourcePropertyType];                 excludedProperties.add(sourceProperty.escapedName);             } */
			discriminantCombinations := cartesianProduct(sourceDiscriminantTypes)
			var matchingTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, combination := range discriminantCombinations {
				hasMatch := false
				/* TODO(LabeledStatement): outer:                 for (const type of target.types) {                     for (let i = 0; i < sourcePropertiesFiltered.length; i++) {                         const sourceProperty = sourcePropertiesFiltered[i];                         const targetProperty = getPropertyOfType(type, sourceProperty.escapedName);                         if (!targetProperty) continue outer;                         if (sourceProperty === targetProperty) continue;                         // We compare the source property to the target in the context of a single discriminant type.                         const related = propertyRelatedTo(source, target, sourceProperty, targetProperty, _ => combination[i], /*reportErrors* / false, IntersectionState.None, /*skipOptional* / strictNullChecks || relation === comparableRelation);                         // If the target property could not be found, or if the properties were not related,                         // then this constituent is not a match.                         if (!related) {                             continue outer;                         }                     }                     pushIfUnique(matchingTypes, type, equateValues);                     hasMatch = true;                 } */
				if !hasMatch {
					return TernaryFalse
				}
			}
			result := TernaryTrue
			for _, type_ := range matchingTypes {
				result &= propertiesRelatedTo(source, type_, false, excludedProperties, false, IntersectionStateNone)
				if result {
					result &= signaturesRelatedTo(source, type_, SignatureKindCall, false, IntersectionStateNone)
					if result {
						result &= signaturesRelatedTo(source, type_, SignatureKindConstruct, false, IntersectionStateNone)
						if result && !(isTupleType(source) && isTupleType(type_)) {
							result &= indexSignaturesRelatedTo(source, type_, false, false, IntersectionStateNone)
						}
					}
				}
				if !result {
					return result
				}
			}
			return result
		}
		excludeProperties := func(properties []Symbol, excludedProperties *Set[__String]) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			if !excludedProperties || properties.length == 0 {
				return properties
			}
			var result /* TODO(ArrayType): Symbol[] */ any
			/* TODO(ForStatement): for (let i = 0; i < properties.length; i++) {                 if (!excludedProperties.has(properties[i].escapedName)) {                     if (result) {                         result.push(properties[i]);                     }                 }                 else if (!result) {                     result = properties.slice(0, i);                 }             } */
			return result || properties
		}
		isPropertySymbolTypeRelated := func(sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			targetIsOptional := strictNullChecks && !!(getCheckFlags(targetProp) & CheckFlagsPartial)
			effectiveTarget := addOptionality(getNonMissingTypeOfSymbol(targetProp), false, targetIsOptional)
			effectiveSource := getTypeOfSourceProperty(sourceProp)
			return isRelatedTo(effectiveSource, effectiveTarget, RecursionFlagsBoth, reportErrors, nil, intersectionState)
		}
		propertyRelatedTo := func(source Type, target Type, sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState, skipOptional bool) Ternary {
			sourcePropFlags := getDeclarationModifierFlagsFromSymbol(sourceProp)
			targetPropFlags := getDeclarationModifierFlagsFromSymbol(targetProp)
			if sourcePropFlags&ModifierFlagsPrivate || targetPropFlags&ModifierFlagsPrivate {
				if sourceProp.valueDeclaration != targetProp.valueDeclaration {
					if reportErrors {
						if sourcePropFlags&ModifierFlagsPrivate && targetPropFlags&ModifierFlagsPrivate {
							reportError(Diagnostics.Types_have_separate_declarations_of_a_private_property_0, symbolToString(targetProp))
						} else {
							reportError(Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, symbolToString(targetProp), typeToString( /* TODO(ConditionalExpression): sourcePropFlags & ModifierFlags.Private ? source : target */ TODO), typeToString( /* TODO(ConditionalExpression): sourcePropFlags & ModifierFlags.Private ? target : source */ TODO))
						}
					}
					return TernaryFalse
				}
			} else if targetPropFlags & ModifierFlagsProtected {
				if !isValidOverrideOf(sourceProp, targetProp) {
					if reportErrors {
						reportError(Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, symbolToString(targetProp), typeToString(getDeclaringClass(sourceProp) || source), typeToString(getDeclaringClass(targetProp) || target))
					}
					return TernaryFalse
				}
			} else if sourcePropFlags & ModifierFlagsProtected {
				if reportErrors {
					reportError(Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target))
				}
				return TernaryFalse
			}
			if relation == strictSubtypeRelation && isReadonlySymbol(sourceProp) && !isReadonlySymbol(targetProp) {
				return TernaryFalse
			}
			related := isPropertySymbolTypeRelated(sourceProp, targetProp, getTypeOfSourceProperty, reportErrors, intersectionState)
			if !related {
				if reportErrors {
					reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(targetProp))
				}
				return TernaryFalse
			}
			if !skipOptional && sourceProp.flags&SymbolFlagsOptional && targetProp.flags&SymbolFlagsClassMember && !(targetProp.flags & SymbolFlagsOptional) {
				if reportErrors {
					reportError(Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target))
				}
				return TernaryFalse
			}
			return related
		}
		reportUnmatchedProperty := func(source Type, target Type, unmatchedProperty Symbol, requireOptionalProperties bool) {
			shouldSkipElaboration := false
			if unmatchedProperty.valueDeclaration && isNamedDeclaration(unmatchedProperty.valueDeclaration) && isPrivateIdentifier(unmatchedProperty.valueDeclaration.name) && source.symbol && source.symbol.flags&SymbolFlagsClass {
				privateIdentifierDescription := unmatchedProperty.valueDeclaration.name.escapedText
				symbolTableKey := getSymbolNameForPrivateIdentifier(source.symbol, privateIdentifierDescription)
				if symbolTableKey && getPropertyOfType(source, symbolTableKey) {
					sourceName := factory.getDeclarationName(source.symbol.valueDeclaration)
					targetName := factory.getDeclarationName(target.symbol.valueDeclaration)
					reportError(Diagnostics.Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2, diagnosticName(privateIdentifierDescription), diagnosticName( /* TODO(ConditionalExpression): sourceName.escapedText === "" ? anon : sourceName */ TODO), diagnosticName( /* TODO(ConditionalExpression): targetName.escapedText === "" ? anon : targetName */ TODO))
					return
				}
			}
			props := arrayFrom(getUnmatchedProperties(source, target, requireOptionalProperties, false))
			if !headMessage || (headMessage.code != Diagnostics.Class_0_incorrectly_implements_interface_1.code && headMessage.code != Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass.code) {
				shouldSkipElaboration = true
			}
			if props.length == 1 {
				propName := symbolToString(unmatchedProperty, nil, SymbolFlagsNone, SymbolFormatFlagsAllowAnyNodeKind|SymbolFormatFlagsWriteComputedProps)
				reportError(Diagnostics.Property_0_is_missing_in_type_1_but_required_in_type_2, propName /* TODO(SpreadElement): ...getTypeNamesForErrorDisplay(source, target) */, TODO)
				if length(unmatchedProperty.declarations) {
					associateRelatedInfo(createDiagnosticForNode( /* TODO(ElementAccessExpression): unmatchedProperty.declarations![0] */ TODO, Diagnostics._0_is_declared_here, propName))
				}
				if shouldSkipElaboration && errorInfo {
					overrideNextErrorInfo++
				}
			} else if tryElaborateArrayLikeErrors(source, target, false) {
				if props.length > 5 {
					reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more, typeToString(source), typeToString(target), map_(props.slice(0, 4), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type string */ TODO {
						return symbolToString(p)
					}).join(", "), /* TODO(MinusToken): - */ /* TODO(BinaryExpression): props.length - 4 */ TODO)
				} else {
					reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2, typeToString(source), typeToString(target), map_(props, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type string */ TODO {
						return symbolToString(p)
					}).join(", "))
				}
				if shouldSkipElaboration && errorInfo {
					overrideNextErrorInfo++
				}
			}
		}
		propertiesRelatedTo := func(source Type, target Type, reportErrors bool, excludedProperties *Set[__String], optionalsOnly bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return propertiesIdenticalTo(source, target, excludedProperties)
			}
			result := TernaryTrue
			if isTupleType(target) {
				if isArrayOrTupleType(source) {
					if !target.target.readonly && (isReadonlyArrayType(source) || isTupleType(source) && source.target.readonly) {
						return TernaryFalse
					}
					sourceArity := getTypeReferenceArity(source)
					targetArity := getTypeReferenceArity(target)
					sourceRestFlag := /* TODO(ConditionalExpression): isTupleType(source) ? source.target.combinedFlags & ElementFlags.Rest : ElementFlags.Rest */ TODO
					targetHasRestElement := !!(target.target.combinedFlags & ElementFlagsVariable)
					sourceMinLength := /* TODO(ConditionalExpression): isTupleType(source) ? source.target.minLength : 0 */ TODO
					targetMinLength := target.target.minLength
					if !sourceRestFlag && sourceArity < targetMinLength {
						if reportErrors {
							reportError(Diagnostics.Source_has_0_element_s_but_target_requires_1, sourceArity, targetMinLength)
						}
						return TernaryFalse
					}
					if !targetHasRestElement && targetArity < sourceMinLength {
						if reportErrors {
							reportError(Diagnostics.Source_has_0_element_s_but_target_allows_only_1, sourceMinLength, targetArity)
						}
						return TernaryFalse
					}
					if !targetHasRestElement && (sourceRestFlag || targetArity < sourceArity) {
						if reportErrors {
							if sourceMinLength < targetMinLength {
								reportError(Diagnostics.Target_requires_0_element_s_but_source_may_have_fewer, targetMinLength)
							} else {
								reportError(Diagnostics.Target_allows_only_0_element_s_but_source_may_have_more, targetArity)
							}
						}
						return TernaryFalse
					}
					sourceTypeArguments := getTypeArguments(source)
					targetTypeArguments := getTypeArguments(target)
					targetStartCount := getStartElementCount(target.target, ElementFlagsNonRest)
					targetEndCount := getEndElementCount(target.target, ElementFlagsNonRest)
					canExcludeDiscriminants := !!excludedProperties
					/* TODO(ForStatement): for (let sourcePosition = 0; sourcePosition < sourceArity; sourcePosition++) {                         const sourceFlags = isTupleType(source) ? source.target.elementFlags[sourcePosition] : ElementFlags.Rest;                         const sourcePositionFromEnd = sourceArity - 1 - sourcePosition;                          const targetPosition = targetHasRestElement && sourcePosition >= targetStartCount                             ? targetArity - 1 - Math.min(sourcePositionFromEnd, targetEndCount)                             : sourcePosition;                          const targetFlags = target.target.elementFlags[targetPosition];                          if (targetFlags & ElementFlags.Variadic && !(sourceFlags & ElementFlags.Variadic)) {                             if (reportErrors) {                                 reportError(Diagnostics.Source_provides_no_match_for_variadic_element_at_position_0_in_target, targetPosition);                             }                             return Ternary.False;                         }                         if (sourceFlags & ElementFlags.Variadic && !(targetFlags & ElementFlags.Variable)) {                             if (reportErrors) {                                 reportError(Diagnostics.Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target, sourcePosition, targetPosition);                             }                             return Ternary.False;                         }                         if (targetFlags & ElementFlags.Required && !(sourceFlags & ElementFlags.Required)) {                             if (reportErrors) {                                 reportError(Diagnostics.Source_provides_no_match_for_required_element_at_position_0_in_target, targetPosition);                             }                             return Ternary.False;                         }                         // We can only exclude discriminant properties if we have not yet encountered a variable-length element.                         if (canExcludeDiscriminants) {                             if (sourceFlags & ElementFlags.Variable || targetFlags & ElementFlags.Variable) {                                 canExcludeDiscriminants = false;                             }                             if (canExcludeDiscriminants && excludedProperties?.has(("" + sourcePosition) as __String)) {                                 continue;                             }                         }                          const sourceType = removeMissingType(sourceTypeArguments[sourcePosition], !!(sourceFlags & targetFlags & ElementFlags.Optional));                         const targetType = targetTypeArguments[targetPosition];                          const targetCheckType = sourceFlags & ElementFlags.Variadic && targetFlags & ElementFlags.Rest ? createArrayType(targetType) :                             removeMissingType(targetType, !!(targetFlags & ElementFlags.Optional));                         const related = isRelatedTo(sourceType, targetCheckType, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         if (!related) {                             if (reportErrors && (targetArity > 1 || sourceArity > 1)) {                                 if (targetHasRestElement && sourcePosition >= targetStartCount && sourcePositionFromEnd >= targetEndCount && targetStartCount !== sourceArity - targetEndCount - 1) {                                     reportIncompatibleError(Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, targetStartCount, sourceArity - targetEndCount - 1, targetPosition);                                 }                                 else {                                     reportIncompatibleError(Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, sourcePosition, targetPosition);                                 }                             }                             return Ternary.False;                         }                         result &= related;                     } */
					return result
				}
				if target.target.combinedFlags & ElementFlagsVariable {
					return TernaryFalse
				}
			}
			requireOptionalProperties := (relation == subtypeRelation || relation == strictSubtypeRelation) && !isObjectLiteralType(source) && !isEmptyArrayLiteralType(source) && !isTupleType(source)
			unmatchedProperty := getUnmatchedProperty(source, target, requireOptionalProperties, false)
			if unmatchedProperty {
				if reportErrors && shouldReportUnmatchedPropertyError(source, target) {
					reportUnmatchedProperty(source, target, unmatchedProperty, requireOptionalProperties)
				}
				return TernaryFalse
			}
			if isObjectLiteralType(target) {
				for _, sourceProp := range excludeProperties(getPropertiesOfType(source), excludedProperties) {
					if !getPropertyOfObjectType(target, sourceProp.escapedName) {
						sourceType := getTypeOfSymbol(sourceProp)
						if !(sourceType.flags & TypeFlagsUndefined) {
							if reportErrors {
								reportError(Diagnostics.Property_0_does_not_exist_on_type_1, symbolToString(sourceProp), typeToString(target))
							}
							return TernaryFalse
						}
					}
				}
			}
			properties := getPropertiesOfType(target)
			numericNamesOnly := isTupleType(source) && isTupleType(target)
			for _, targetProp := range excludeProperties(properties, excludedProperties) {
				name := targetProp.escapedName
				if !(targetProp.flags & SymbolFlagsPrototype) && (!numericNamesOnly || isNumericLiteralName(name) || name == "length") && (!optionalsOnly || targetProp.flags&SymbolFlagsOptional) {
					sourceProp := getPropertyOfType(source, name)
					if sourceProp && sourceProp != targetProp {
						related := propertyRelatedTo(source, target, sourceProp, targetProp, getNonMissingTypeOfSymbol, reportErrors, intersectionState, relation == comparableRelation)
						if !related {
							return TernaryFalse
						}
						result &= related
					}
				}
			}
			return result
		}
		propertiesIdenticalTo := func(source Type, target Type, excludedProperties *Set[__String]) Ternary {
			if !(source.flags&TypeFlagsObject && target.flags&TypeFlagsObject) {
				return TernaryFalse
			}
			sourceProperties := excludeProperties(getPropertiesOfObjectType(source), excludedProperties)
			targetProperties := excludeProperties(getPropertiesOfObjectType(target), excludedProperties)
			if sourceProperties.length != targetProperties.length {
				return TernaryFalse
			}
			result := TernaryTrue
			for _, sourceProp := range sourceProperties {
				targetProp := getPropertyOfObjectType(target, sourceProp.escapedName)
				if !targetProp {
					return TernaryFalse
				}
				related := compareProperties(sourceProp, targetProp, isRelatedTo)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		signaturesRelatedTo := func(source Type, target Type, kind SignatureKind, reportErrors bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return signaturesIdenticalTo(source, target, kind)
			}
			if target == anyFunctionType || source == anyFunctionType {
				return TernaryTrue
			}
			sourceIsJSConstructor := source.symbol && isJSConstructor(source.symbol.valueDeclaration)
			targetIsJSConstructor := target.symbol && isJSConstructor(target.symbol.valueDeclaration)
			sourceSignatures := getSignaturesOfType(source /* TODO(ConditionalExpression): (sourceIsJSConstructor && kind === SignatureKind.Construct) ?                     SignatureKind.Call : kind */, TODO)
			targetSignatures := getSignaturesOfType(target /* TODO(ConditionalExpression): (targetIsJSConstructor && kind === SignatureKind.Construct) ?                     SignatureKind.Call : kind */, TODO)
			if kind == SignatureKindConstruct && sourceSignatures.length && targetSignatures.length {
				sourceIsAbstract := !!( /* TODO(ElementAccessExpression): sourceSignatures[0] */ TODO.flags & SignatureFlagsAbstract)
				targetIsAbstract := !!( /* TODO(ElementAccessExpression): targetSignatures[0] */ TODO.flags & SignatureFlagsAbstract)
				if sourceIsAbstract && !targetIsAbstract {
					if reportErrors {
						reportError(Diagnostics.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type)
					}
					return TernaryFalse
				}
				if !constructorVisibilitiesAreCompatible( /* TODO(ElementAccessExpression): sourceSignatures[0] */ TODO /* TODO(ElementAccessExpression): targetSignatures[0] */, TODO, reportErrors) {
					return TernaryFalse
				}
			}
			result := TernaryTrue
			incompatibleReporter := /* TODO(ConditionalExpression): kind === SignatureKind.Construct ? reportIncompatibleConstructSignatureReturn : reportIncompatibleCallSignatureReturn */ TODO
			sourceObjectFlags := getObjectFlags(source)
			targetObjectFlags := getObjectFlags(target)
			if sourceObjectFlags&ObjectFlagsInstantiated && targetObjectFlags&ObjectFlagsInstantiated && source.symbol == target.symbol || sourceObjectFlags&ObjectFlagsReference && targetObjectFlags&ObjectFlagsReference && (source).target == (target).target {
				Debug.assertEqual(sourceSignatures.length, targetSignatures.length)
				/* TODO(ForStatement): for (let i = 0; i < targetSignatures.length; i++) {                     const related = signatureRelatedTo(sourceSignatures[i], targetSignatures[i], /*erase* / true, reportErrors, intersectionState, incompatibleReporter(sourceSignatures[i], targetSignatures[i]));                     if (!related) {                         return Ternary.False;                     }                     result &= related;                 } */
			} else if sourceSignatures.length == 1 && targetSignatures.length == 1 {
				eraseGenerics := relation == comparableRelation
				sourceSignature := first(sourceSignatures)
				targetSignature := first(targetSignatures)
				result = signatureRelatedTo(sourceSignature, targetSignature, eraseGenerics, reportErrors, intersectionState, incompatibleReporter(sourceSignature, targetSignature))
				if !result && reportErrors && kind == SignatureKindConstruct && (sourceObjectFlags & targetObjectFlags) && (targetSignature.declaration.kind == SyntaxKindConstructor || sourceSignature.declaration.kind == SyntaxKindConstructor) {
					constructSignatureToString := func(signature Signature) /* TODO inferred type string */ TODO {
						return signatureToString(signature, nil, TypeFormatFlagsWriteArrowStyleSignature, kind)
					}
					reportError(Diagnostics.Type_0_is_not_assignable_to_type_1, constructSignatureToString(sourceSignature), constructSignatureToString(targetSignature))
					reportError(Diagnostics.Types_of_construct_signatures_are_incompatible)
					return result
				}
			} else {
				/* TODO(LabeledStatement): outer:                 for (const t of targetSignatures) {                     const saveErrorInfo = captureErrorCalculationState();                     // Only elaborate errors from the first failure                     let shouldElaborateErrors = reportErrors;                     for (const s of sourceSignatures) {                         const related = signatureRelatedTo(s, t, /*erase* / true, shouldElaborateErrors, intersectionState, incompatibleReporter(s, t));                         if (related) {                             result &= related;                             resetErrorInfo(saveErrorInfo);                             continue outer;                         }                         shouldElaborateErrors = false;                     }                     if (shouldElaborateErrors) {                         reportError(Diagnostics.Type_0_provides_no_match_for_the_signature_1, typeToString(source), signatureToString(t, /*enclosingDeclaration* / undefined, /*flags* / undefined, kind));                     }                     return Ternary.False;                 } */
			}
			return result
		}
		shouldReportUnmatchedPropertyError := func(source Type, target Type) bool {
			typeCallSignatures := getSignaturesOfStructuredType(source, SignatureKindCall)
			typeConstructSignatures := getSignaturesOfStructuredType(source, SignatureKindConstruct)
			typeProperties := getPropertiesOfObjectType(source)
			if (typeCallSignatures.length || typeConstructSignatures.length) && !typeProperties.length {
				if (getSignaturesOfType(target, SignatureKindCall).length && typeCallSignatures.length) || (getSignaturesOfType(target, SignatureKindConstruct).length && typeConstructSignatures.length) {
					return true
				}
				return false
			}
			return true
		}
		reportIncompatibleCallSignatureReturn := func(siga Signature, sigb Signature) /* TODO inferred type (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => void */ TODO {
			if siga.parameters.length == 0 && sigb.parameters.length == 0 {
				return func(source Type, target Type) {
					return reportIncompatibleError(Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target))
				}
			}
			return func(source Type, target Type) {
				return reportIncompatibleError(Diagnostics.Call_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target))
			}
		}
		reportIncompatibleConstructSignatureReturn := func(siga Signature, sigb Signature) /* TODO inferred type (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => void */ TODO {
			if siga.parameters.length == 0 && sigb.parameters.length == 0 {
				return func(source Type, target Type) {
					return reportIncompatibleError(Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target))
				}
			}
			return func(source Type, target Type) {
				return reportIncompatibleError(Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target))
			}
		}
		signatureRelatedTo := func(source Signature, target Signature, erase bool, reportErrors bool, intersectionState IntersectionState, incompatibleReporter func(source Type, target Type)) Ternary {
			checkMode := /* TODO(ConditionalExpression): relation === subtypeRelation ? SignatureCheckMode.StrictTopSignature :                 relation === strictSubtypeRelation ? SignatureCheckMode.StrictTopSignature | SignatureCheckMode.StrictArity :                 SignatureCheckMode.None */ TODO
			return compareSignaturesRelated( /* TODO(ConditionalExpression): erase ? getErasedSignature(source) : source */ TODO /* TODO(ConditionalExpression): erase ? getErasedSignature(target) : target */, TODO, checkMode, reportErrors, reportError, incompatibleReporter, isRelatedToWorker, reportUnreliableMapper)
			isRelatedToWorker := func(source Type, target Type, reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
				return isRelatedTo(source, target, RecursionFlagsBoth, reportErrors, nil, intersectionState)
			}
		}
		signaturesIdenticalTo := func(source Type, target Type, kind SignatureKind) Ternary {
			sourceSignatures := getSignaturesOfType(source, kind)
			targetSignatures := getSignaturesOfType(target, kind)
			if sourceSignatures.length != targetSignatures.length {
				return TernaryFalse
			}
			result := TernaryTrue
			/* TODO(ForStatement): for (let i = 0; i < sourceSignatures.length; i++) {                 const related = compareSignaturesIdentical(sourceSignatures[i], targetSignatures[i], /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / false, isRelatedTo);                 if (!related) {                     return Ternary.False;                 }                 result &= related;             } */
			return result
		}
		membersRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := TernaryTrue
			keyType := targetInfo.keyType
			props := /* TODO(ConditionalExpression): source.flags & TypeFlags.Intersection ? getPropertiesOfUnionOrIntersectionType(source as IntersectionType) : getPropertiesOfObjectType(source) */ TODO
			for _, prop := range props {
				if isIgnoredJsxProperty(source, prop) {
					continue
				}
				if isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique), keyType) {
					propType := getNonMissingTypeOfSymbol(prop)
					type_ := /* TODO(ConditionalExpression): exactOptionalPropertyTypes || propType.flags & TypeFlags.Undefined || keyType === numberType || !(prop.flags & SymbolFlags.Optional)                         ? propType                         : getTypeWithFacts(propType, TypeFacts.NEUndefined) */ TODO
					related := isRelatedTo(type_, targetInfo.type_, RecursionFlagsBoth, reportErrors, nil, intersectionState)
					if !related {
						if reportErrors {
							reportError(Diagnostics.Property_0_is_incompatible_with_index_signature, symbolToString(prop))
						}
						return TernaryFalse
					}
					result &= related
				}
			}
			for _, info := range getIndexInfosOfType(source) {
				if isApplicableIndexType(info.keyType, keyType) {
					related := indexInfoRelatedTo(info, targetInfo, reportErrors, intersectionState)
					if !related {
						return TernaryFalse
					}
					result &= related
				}
			}
			return result
		}
		indexInfoRelatedTo := func(sourceInfo IndexInfo, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
			related := isRelatedTo(sourceInfo.type_, targetInfo.type_, RecursionFlagsBoth, reportErrors, nil, intersectionState)
			if !related && reportErrors {
				if sourceInfo.keyType == targetInfo.keyType {
					reportError(Diagnostics._0_index_signatures_are_incompatible, typeToString(sourceInfo.keyType))
				} else {
					reportError(Diagnostics._0_and_1_index_signatures_are_incompatible, typeToString(sourceInfo.keyType), typeToString(targetInfo.keyType))
				}
			}
			return related
		}
		indexSignaturesRelatedTo := func(source Type, target Type, sourceIsPrimitive bool, reportErrors bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return indexSignaturesIdenticalTo(source, target)
			}
			indexInfos := getIndexInfosOfType(target)
			targetHasStringIndex := some(indexInfos, func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO inferred type boolean */ TODO {
				return info.keyType == stringType
			})
			result := TernaryTrue
			for _, targetInfo := range indexInfos {
				related := /* TODO(ConditionalExpression): relation !== strictSubtypeRelation && !sourceIsPrimitive && targetHasStringIndex && targetInfo.type.flags & TypeFlags.Any ? Ternary.True :                     isGenericMappedType(source) && targetHasStringIndex ? isRelatedTo(getTemplateTypeFromMappedType(source), targetInfo.type, RecursionFlags.Both, reportErrors) :                     typeRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState) */ TODO
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		typeRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
			sourceInfo := getApplicableIndexInfo(source, targetInfo.keyType)
			if sourceInfo {
				return indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors, intersectionState)
			}
			if !(intersectionState & IntersectionStateSource) && (relation != strictSubtypeRelation || getObjectFlags(source)&ObjectFlagsFreshLiteral) && isObjectTypeWithInferableIndex(source) {
				return membersRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState)
			}
			if reportErrors {
				reportError(Diagnostics.Index_signature_for_type_0_is_missing_in_type_1, typeToString(targetInfo.keyType), typeToString(source))
			}
			return TernaryFalse
		}
		indexSignaturesIdenticalTo := func(source Type, target Type) Ternary {
			sourceInfos := getIndexInfosOfType(source)
			targetInfos := getIndexInfosOfType(target)
			if sourceInfos.length != targetInfos.length {
				return TernaryFalse
			}
			for _, targetInfo := range targetInfos {
				sourceInfo := getIndexInfoOfType(source, targetInfo.keyType)
				if !(sourceInfo && isRelatedTo(sourceInfo.type_, targetInfo.type_, RecursionFlagsBoth) && sourceInfo.isReadonly == targetInfo.isReadonly) {
					return TernaryFalse
				}
			}
			return TernaryTrue
		}
		constructorVisibilitiesAreCompatible := func(sourceSignature Signature, targetSignature Signature, reportErrors bool) /* TODO inferred type boolean */ TODO {
			if !sourceSignature.declaration || !targetSignature.declaration {
				return true
			}
			sourceAccessibility := getSelectedEffectiveModifierFlags(sourceSignature.declaration, ModifierFlagsNonPublicAccessibilityModifier)
			targetAccessibility := getSelectedEffectiveModifierFlags(targetSignature.declaration, ModifierFlagsNonPublicAccessibilityModifier)
			if targetAccessibility == ModifierFlagsPrivate {
				return true
			}
			if targetAccessibility == ModifierFlagsProtected && sourceAccessibility != ModifierFlagsPrivate {
				return true
			}
			if targetAccessibility != ModifierFlagsProtected && !sourceAccessibility {
				return true
			}
			if reportErrors {
				reportError(Diagnostics.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type, visibilityToString(sourceAccessibility), visibilityToString(targetAccessibility))
			}
			return false
		}
	}
	typeCouldHaveTopLevelSingletonTypes := func(type_ Type) bool {
		if type_.flags & TypeFlagsBoolean {
			return false
		}
		if type_.flags & TypeFlagsUnionOrIntersection {
			return !!forEach((type_).types, typeCouldHaveTopLevelSingletonTypes)
		}
		if type_.flags & TypeFlagsInstantiable {
			constraint := getConstraintOfType(type_)
			if constraint && constraint != type_ {
				return typeCouldHaveTopLevelSingletonTypes(constraint)
			}
		}
		return isUnitType(type_) || !!(type_.flags & TypeFlagsTemplateLiteral) || !!(type_.flags & TypeFlagsStringMapping)
	}
	getExactOptionalUnassignableProperties := func(source Type, target Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		if isTupleType(source) && isTupleType(target) {
			return emptyArray
		}
		return getPropertiesOfType(target).filter(func(targetProp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
			return isExactOptionalPropertyMismatch(getTypeOfPropertyOfType(source, targetProp.escapedName), getTypeOfSymbol(targetProp))
		})
	}
	isExactOptionalPropertyMismatch := func(source *Type, target *Type) /* TODO inferred type boolean */ TODO {
		return !!source && !!target && maybeTypeOfKind(source, TypeFlagsUndefined) && !!containsMissingType(target)
	}
	getExactOptionalProperties := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		return getPropertiesOfType(type_).filter(func(targetProp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
			return containsMissingType(getTypeOfSymbol(targetProp))
		})
	}
	getBestMatchingType := func(source Type, target UnionOrIntersectionType, isRelatedTo /* TODO inferred type (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO /*  = compareTypesAssignable */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return findMatchingDiscriminantType(source, target, isRelatedTo) || findMatchingTypeReferenceOrTypeAliasReference(source, target) || findBestTypeForObjectLiteral(source, target) || findBestTypeForInvokable(source, target) || findMostOverlappyType(source, target)
	}
	discriminateTypeByDiscriminableItems := func(target UnionType, discriminators [] /* TODO(TupleType): [() => Type, __String] */ any, related func(source Type, target Type) /* TODO(UnionType): boolean | Ternary */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		types := target.types
		var include []Ternary = types.map_(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary.False | import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary.True */ TODO {
			return /* TODO(ConditionalExpression): t.flags & TypeFlags.Primitive ? Ternary.False : Ternary.True */ TODO
		})
		for _, TODO_IDENTIFIER := range discriminators {
			matched := false
			/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                 if (include[i]) {                     const targetType = getTypeOfPropertyOrIndexSignatureOfType(types[i], propertyName);                     if (targetType && someType(getDiscriminatingType(), t => !!related(t, targetType))) {                         matched = true;                     }                     else {                         include[i] = Ternary.Maybe;                     }                 }             } */
			/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                 if (include[i] === Ternary.Maybe) {                     include[i] = matched ? Ternary.False : Ternary.True;                 }             } */
		}
		filtered := /* TODO(ConditionalExpression): contains(include, Ternary.False) ? getUnionType(types.filter((_, i) => include[i]), UnionReduction.None) : target */ TODO
		return /* TODO(ConditionalExpression): filtered.flags & TypeFlags.Never ? target : filtered */ TODO
	}
	isWeakType := func(type_ Type) bool {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_)
			return resolved.callSignatures.length == 0 && resolved.constructSignatures.length == 0 && resolved.indexInfos.length == 0 && resolved.properties.length > 0 && every(resolved.properties, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
				return !!(p.flags & SymbolFlagsOptional)
			})
		}
		if type_.flags & TypeFlagsSubstitution {
			return isWeakType((type_).baseType)
		}
		if type_.flags & TypeFlagsIntersection {
			return every((type_).types, isWeakType)
		}
		return false
	}
	hasCommonProperties := func(source Type, target Type, isComparingJsxAttributes bool) /* TODO inferred type boolean */ TODO {
		for _, prop := range getPropertiesOfType(source) {
			if isKnownProperty(target, prop.escapedName, isComparingJsxAttributes) {
				return true
			}
		}
		return false
	}
	getVariances := func(type_ GenericType) []VarianceFlags {
		return /* TODO(ConditionalExpression): type === globalArrayType || type === globalReadonlyArrayType || type.objectFlags & ObjectFlags.Tuple ?             arrayVariances :             getVariancesWorker(type.symbol, type.typeParameters) */ TODO
	}
	getAliasVariances := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").VarianceFlags[] */ TODO {
		return getVariancesWorker(symbol, getSymbolLinks(symbol).typeParameters)
	}
	getVariancesWorker := func(symbol Symbol, typeParameters []TypeParameter /*  = emptyArray */) []VarianceFlags {
		links := getSymbolLinks(symbol)
		if !links.variances {
			tracing.push(tracing.Phase.CheckTypes, "getVariancesWorker" /* TODO(ObjectLiteralExpression): { arity: typeParameters.length, id: getTypeId(getDeclaredTypeOfSymbol(symbol)) } */, TODO)
			oldVarianceComputation := inVarianceComputation
			saveResolutionStart := resolutionStart
			if !inVarianceComputation {
				inVarianceComputation = true
				resolutionStart = resolutionTargets.length
			}
			links.variances = emptyArray
			variances := /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, tp := range typeParameters {
				modifiers := getTypeParameterModifiers(tp)
				variance := /* TODO(ConditionalExpression): modifiers & ModifierFlags.Out ?                     modifiers & ModifierFlags.In ? VarianceFlags.Invariant : VarianceFlags.Covariant :                     modifiers & ModifierFlags.In ? VarianceFlags.Contravariant : undefined */ TODO
				if variance == nil {
					unmeasurable := false
					unreliable := false
					oldHandler := outofbandVarianceMarkerHandler
					outofbandVarianceMarkerHandler = func(onlyUnreliable /* TODO inferred type boolean */ TODO) /* TODO inferred type boolean */ TODO {
						return /* TODO(ConditionalExpression): onlyUnreliable ? unreliable = true : unmeasurable = true */ TODO
					}
					typeWithSuper := createMarkerType(symbol, tp, markerSuperType)
					typeWithSub := createMarkerType(symbol, tp, markerSubType)
					variance = ( /* TODO(ConditionalExpression): isTypeAssignableTo(typeWithSub, typeWithSuper) ? VarianceFlags.Covariant : 0 */ TODO) | ( /* TODO(ConditionalExpression): isTypeAssignableTo(typeWithSuper, typeWithSub) ? VarianceFlags.Contravariant : 0 */ TODO)
					if variance == VarianceFlagsBivariant && isTypeAssignableTo(createMarkerType(symbol, tp, markerOtherType), typeWithSuper) {
						variance = VarianceFlagsIndependent
					}
					outofbandVarianceMarkerHandler = oldHandler
					if unmeasurable || unreliable {
						if unmeasurable {
							variance |= VarianceFlagsUnmeasurable
						}
						if unreliable {
							variance |= VarianceFlagsUnreliable
						}
					}
				}
				variances.push(variance)
			}
			if !oldVarianceComputation {
				inVarianceComputation = false
				resolutionStart = saveResolutionStart
			}
			links.variances = variances
			tracing.pop( /* TODO(ObjectLiteralExpression): { variances: variances.map(Debug.formatVariance) } */ TODO)
		}
		return links.variances
	}
	createMarkerType := func(symbol Symbol, source TypeParameter, target Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		mapper := makeUnaryTypeMapper(source, target)
		type_ := getDeclaredTypeOfSymbol(symbol)
		if isErrorType(type_) {
			return type_
		}
		result := /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.TypeAlias ?             getTypeAliasInstantiation(symbol, instantiateTypes(getSymbolLinks(symbol).typeParameters!, mapper)) :             createTypeReference(type as GenericType, instantiateTypes((type as GenericType).typeParameters, mapper)) */ TODO
		markerTypes.add(getTypeId(result))
		return result
	}
	isMarkerType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return markerTypes.has(getTypeId(type_))
	}
	getTypeParameterModifiers := func(tp TypeParameter) ModifierFlags {
		return reduceLeft(tp.symbol.declarations, func(modifiers /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ModifierFlags */ TODO, d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type number */ TODO {
			return modifiers | getEffectiveModifierFlags(d)
		}, ModifierFlagsNone) & (ModifierFlagsIn | ModifierFlagsOut | ModifierFlagsConst)
	}
	hasCovariantVoidArgument := func(typeArguments []Type, variances []VarianceFlags) bool {
		/* TODO(ForStatement): for (let i = 0; i < variances.length; i++) {             if ((variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Covariant && typeArguments[i].flags & TypeFlags.Void) {                 return true;             }         } */
		return false
	}
	isUnconstrainedTypeParameter := func(type_ Type) /* TODO inferred type boolean | 0 */ TODO {
		return type_.flags&TypeFlagsTypeParameter && !getConstraintOfTypeParameter(type_)
	}
	isNonDeferredTypeReference := func(type_ Type) /* TODO(TypePredicate): type is TypeReference */ any {
		return !!(getObjectFlags(type_) & ObjectFlagsReference) && !(type_).node
	}
	isTypeReferenceWithGenericArguments := func(type_ Type) bool {
		return isNonDeferredTypeReference(type_) && some(getTypeArguments(type_), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return !!(t.flags & TypeFlagsTypeParameter) || isTypeReferenceWithGenericArguments(t)
		})
	}
	getGenericTypeReferenceRelationKey := func(source TypeReference, target TypeReference, postFix string, ignoreConstraints bool) /* TODO inferred type string */ TODO {
		var typeParameters []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		constraintMarker := ""
		sourceId := getTypeReferenceId(source, 0)
		targetId := getTypeReferenceId(target, 0)
		return /* TODO(TemplateExpression): `${constraintMarker}${sourceId},${targetId}${postFix}` */ TODO
		getTypeReferenceId := func(type_ TypeReference, depth /* TODO inferred type number */ TODO /*  = 0 */) /* TODO inferred type string */ TODO {
			result := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + type.target.id */ TODO
			for _, t := range getTypeArguments(type_) {
				if t.flags & TypeFlagsTypeParameter {
					if ignoreConstraints || isUnconstrainedTypeParameter(t) {
						index := typeParameters.indexOf(t)
						if index < 0 {
							index = typeParameters.length
							typeParameters.push(t)
						}
						result += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "=" + index */ TODO
						continue
					}
					constraintMarker = "*"
				} else if depth < 4 && isTypeReferenceWithGenericArguments(t) {
					result += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "<" + getTypeReferenceId(t as TypeReference, depth + 1) + ">" */ TODO
					continue
				}
				result += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "-" + t.id */ TODO
			}
			return result
		}
	}
	getRelationKey := func(source Type, target Type, intersectionState IntersectionState, relation Map[string, RelationComparisonResult], ignoreConstraints bool) /* TODO inferred type string */ TODO {
		if relation == identityRelation && source.id > target.id {
			temp := source
			source = target
			target = temp
		}
		postFix := /* TODO(ConditionalExpression): intersectionState ? ":" + intersectionState : "" */ TODO
		return /* TODO(ConditionalExpression): isTypeReferenceWithGenericArguments(source) && isTypeReferenceWithGenericArguments(target) ?             getGenericTypeReferenceRelationKey(source as TypeReference, target as TypeReference, postFix, ignoreConstraints) :             `${source.id},${target.id}${postFix}` */ TODO
	}
	forEachProperty := func(prop Symbol, callback func(p Symbol) T) *T {
		if getCheckFlags(prop) & CheckFlagsSynthetic {
			for _, t := range (prop).links.containingType.types {
				p := getPropertyOfType(t, prop.escapedName)
				result := p && forEachProperty(p, callback)
				if result {
					return result
				}
			}
			return nil
		}
		return callback(prop)
	}
	getDeclaringClass := func(prop Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceType | undefined */ TODO {
		return /* TODO(ConditionalExpression): prop.parent && prop.parent.flags & SymbolFlags.Class ? getDeclaredTypeOfSymbol(getParentOfSymbol(prop)!) as InterfaceType : undefined */ TODO
	}
	getTypeOfPropertyInBaseClass := func(property Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		classType := getDeclaringClass(property)
		baseClassType := classType && /* TODO(ElementAccessExpression): getBaseTypes(classType)[0] */ TODO
		return baseClassType && getTypeOfPropertyOfType(baseClassType, property.escapedName)
	}
	isPropertyInClassDerivedFrom := func(prop Symbol, baseClass *Type) /* TODO inferred type boolean | undefined */ TODO {
		return forEachProperty(prop, func(sp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
			sourceClass := getDeclaringClass(sp)
			return /* TODO(ConditionalExpression): sourceClass ? hasBaseType(sourceClass, baseClass) : false */ TODO
		})
	}
	isValidOverrideOf := func(sourceProp Symbol, targetProp Symbol) /* TODO inferred type boolean */ TODO {
		return !forEachProperty(targetProp, func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
			return /* TODO(ConditionalExpression): getDeclarationModifierFlagsFromSymbol(tp) & ModifierFlags.Protected ?                 !isPropertyInClassDerivedFrom(sourceProp, getDeclaringClass(tp)) : false */ TODO
		})
	}
	isClassDerivedFromDeclaringClasses := func(checkClass T, prop Symbol, writing bool) /* TODO inferred type T | undefined */ TODO {
		return /* TODO(ConditionalExpression): forEachProperty(prop, p =>                 getDeclarationModifierFlagsFromSymbol(p, writing) & ModifierFlags.Protected ?                     !hasBaseType(checkClass, getDeclaringClass(p)) : false) ? undefined : checkClass */ TODO
	}
	isDeeplyNestedType := func(type_ Type, stack []Type, depth number, maxDepth /* TODO inferred type number */ TODO /*  = 3 */) bool {
		if depth >= maxDepth {
			if (getObjectFlags(type_) & ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped {
				type_ = getMappedTargetWithSymbol(type_)
			}
			if type_.flags & TypeFlagsIntersection {
				return some((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return isDeeplyNestedType(t, stack, depth, maxDepth)
				})
			}
			identity := getRecursionIdentity(type_)
			count := 0
			lastTypeId := 0
			/* TODO(ForStatement): for (let i = 0; i < depth; i++) {                 const t = stack[i];                 if (hasMatchingRecursionIdentity(t, identity)) {                     // We only count occurrences with a higher type id than the previous occurrence, since higher                     // type ids are an indicator of newer instantiations caused by recursion.                     if (t.id >= lastTypeId) {                         count++;                         if (count >= maxDepth) {                             return true;                         }                     }                     lastTypeId = t.id;                 }             } */
		}
		return false
	}
	getMappedTargetWithSymbol := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		var target TODO
		for (getObjectFlags(type_)&ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): target = getModifiersTypeFromMappedType(type as MappedType) */ TODO) && (target.symbol || target.flags&TypeFlagsIntersection && some((target).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type true */ TODO {
			return !!t.symbol
		})) {
			type_ = target
		}
		return type_
	}
	hasMatchingRecursionIdentity := func(type_ Type, identity /* TODO(ObjectKeyword): object */ any) bool {
		if (getObjectFlags(type_) & ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped {
			type_ = getMappedTargetWithSymbol(type_)
		}
		if type_.flags & TypeFlagsIntersection {
			return some((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return hasMatchingRecursionIdentity(t, identity)
			})
		}
		return getRecursionIdentity(type_) == identity
	}
	getRecursionIdentity := func(type_ Type) /* TODO(ObjectKeyword): object */ any {
		if type_.flags&TypeFlagsObject && !isObjectOrArrayLiteralType(type_) {
			if getObjectFlags(type_)&ObjectFlagsReference && (type_).node {
				return (type_).node
			}
			if type_.symbol && !(getObjectFlags(type_)&ObjectFlagsAnonymous && type_.symbol.flags&SymbolFlagsClass) {
				return type_.symbol
			}
			if isTupleType(type_) {
				return type_.target
			}
		}
		if type_.flags & TypeFlagsTypeParameter {
			return type_.symbol
		}
		if type_.flags & TypeFlagsIndexedAccess {
			// TODO: refactor do-while loop approximation
			for ok := true; ok; ok = type_.flags & TypeFlagsIndexedAccess {
				type_ = (type_).objectType
			}
			return type_
		}
		if type_.flags & TypeFlagsConditional {
			return (type_).root
		}
		return type_
	}
	isPropertyIdenticalTo := func(sourceProp Symbol, targetProp Symbol) bool {
		return compareProperties(sourceProp, targetProp, compareTypesIdentical) != TernaryFalse
	}
	compareProperties := func(sourceProp Symbol, targetProp Symbol, compareTypes func(source Type, target Type) Ternary) Ternary {
		if sourceProp == targetProp {
			return TernaryTrue
		}
		sourcePropAccessibility := getDeclarationModifierFlagsFromSymbol(sourceProp) & ModifierFlagsNonPublicAccessibilityModifier
		targetPropAccessibility := getDeclarationModifierFlagsFromSymbol(targetProp) & ModifierFlagsNonPublicAccessibilityModifier
		if sourcePropAccessibility != targetPropAccessibility {
			return TernaryFalse
		}
		if sourcePropAccessibility {
			if getTargetSymbol(sourceProp) != getTargetSymbol(targetProp) {
				return TernaryFalse
			}
		} else {
			if (sourceProp.flags & SymbolFlagsOptional) != (targetProp.flags & SymbolFlagsOptional) {
				return TernaryFalse
			}
		}
		if isReadonlySymbol(sourceProp) != isReadonlySymbol(targetProp) {
			return TernaryFalse
		}
		return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp))
	}
	isMatchingSignature := func(source Signature, target Signature, partialMatch bool) /* TODO inferred type boolean */ TODO {
		sourceParameterCount := getParameterCount(source)
		targetParameterCount := getParameterCount(target)
		sourceMinArgumentCount := getMinArgumentCount(source)
		targetMinArgumentCount := getMinArgumentCount(target)
		sourceHasRestParameter := hasEffectiveRestParameter(source)
		targetHasRestParameter := hasEffectiveRestParameter(target)
		if sourceParameterCount == targetParameterCount && sourceMinArgumentCount == targetMinArgumentCount && sourceHasRestParameter == targetHasRestParameter {
			return true
		}
		if partialMatch && sourceMinArgumentCount <= targetMinArgumentCount {
			return true
		}
		return false
	}
	compareSignaturesIdentical := func(source Signature, target Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool, compareTypes func(s Type, t Type) Ternary) Ternary {
		if source == target {
			return TernaryTrue
		}
		if !(isMatchingSignature(source, target, partialMatch)) {
			return TernaryFalse
		}
		if length(source.typeParameters) != length(target.typeParameters) {
			return TernaryFalse
		}
		if target.typeParameters {
			mapper := createTypeMapper(source.typeParameters, target.typeParameters)
			/* TODO(ForStatement): for (let i = 0; i < target.typeParameters.length; i++) {                 const s = source.typeParameters![i];                 const t = target.typeParameters[i];                 if (                     !(s === t || compareTypes(instantiateType(getConstraintFromTypeParameter(s), mapper) || unknownType, getConstraintFromTypeParameter(t) || unknownType) &&                             compareTypes(instantiateType(getDefaultFromTypeParameter(s), mapper) || unknownType, getDefaultFromTypeParameter(t) || unknownType))                 ) {                     return Ternary.False;                 }             } */
			source = instantiateSignature(source, mapper, true)
		}
		result := TernaryTrue
		if !ignoreThisTypes {
			sourceThisType := getThisTypeOfSignature(source)
			if sourceThisType {
				targetThisType := getThisTypeOfSignature(target)
				if targetThisType {
					related := compareTypes(sourceThisType, targetThisType)
					if !related {
						return TernaryFalse
					}
					result &= related
				}
			}
		}
		targetLen := getParameterCount(target)
		/* TODO(ForStatement): for (let i = 0; i < targetLen; i++) {             const s = getTypeAtPosition(source, i);             const t = getTypeAtPosition(target, i);             const related = compareTypes(t, s);             if (!related) {                 return Ternary.False;             }             result &= related;         } */
		if !ignoreReturnTypes {
			sourceTypePredicate := getTypePredicateOfSignature(source)
			targetTypePredicate := getTypePredicateOfSignature(target)
			result &= /* TODO(ConditionalExpression): sourceTypePredicate || targetTypePredicate ?                 compareTypePredicatesIdentical(sourceTypePredicate, targetTypePredicate, compareTypes) :                 compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target)) */ TODO
		}
		return result
	}
	compareTypePredicatesIdentical := func(source *TypePredicate, target *TypePredicate, compareTypes func(s Type, t Type) Ternary) Ternary {
		return /* TODO(ConditionalExpression): !(source && target && typePredicateKindsMatch(source, target)) ? Ternary.False :             source.type === target.type ? Ternary.True :             source.type && target.type ? compareTypes(source.type, target.type) :             Ternary.False */ TODO
	}
	literalTypesWithSameBaseType := func(types []Type) bool {
		var commonBaseType *Type
		for _, t := range types {
			if !(t.flags & TypeFlagsNever) {
				baseType := getBaseTypeOfLiteralType(t)
				/* TODO(ExpressionStatement): commonBaseType ??= baseType; */
				if baseType == t || baseType != commonBaseType {
					return false
				}
			}
		}
		return true
	}
	getCombinedTypeFlags := func(types []Type) TypeFlags {
		return reduceLeft(types, func(flags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO, t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type number */ TODO {
			return flags | ( /* TODO(ConditionalExpression): t.flags & TypeFlags.Union ? getCombinedTypeFlags((t as UnionType).types) : t.flags */ TODO)
		}, 0)
	}
	getCommonSupertype := func(types []Type) Type {
		if types.length == 1 {
			return /* TODO(ElementAccessExpression): types[0] */ TODO
		}
		primaryTypes := /* TODO(ConditionalExpression): strictNullChecks ? sameMap(types, t => filterType(t, u => !(u.flags & TypeFlags.Nullable))) : types */ TODO
		superTypeOrUnion := /* TODO(ConditionalExpression): literalTypesWithSameBaseType(primaryTypes) ?             getUnionType(primaryTypes) :             reduceLeft(primaryTypes, (s, t) => isTypeSubtypeOf(s, t) ? t : s)! */ TODO
		return /* TODO(ConditionalExpression): primaryTypes === types ? superTypeOrUnion : getNullableType(superTypeOrUnion, getCombinedTypeFlags(types) & TypeFlags.Nullable) */ TODO
	}
	getCommonSubtype := func(types []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return reduceLeft(types, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return /* TODO(ConditionalExpression): isTypeSubtypeOf(t, s) ? t : s */ TODO
		})
	}
	isArrayType := func(type_ Type) /* TODO(TypePredicate): type is TypeReference */ any {
		return !!(getObjectFlags(type_) & ObjectFlagsReference) && ((type_).target == globalArrayType || (type_).target == globalReadonlyArrayType)
	}
	isReadonlyArrayType := func(type_ Type) bool {
		return !!(getObjectFlags(type_) & ObjectFlagsReference) && (type_).target == globalReadonlyArrayType
	}
	isArrayOrTupleType := func(type_ Type) /* TODO(TypePredicate): type is TypeReference */ any {
		return isArrayType(type_) || isTupleType(type_)
	}
	isMutableArrayOrTuple := func(type_ Type) bool {
		return isArrayType(type_) && !isReadonlyArrayType(type_) || isTupleType(type_) && !type_.target.readonly
	}
	getElementTypeOfArrayType := func(type_ Type) *Type {
		return /* TODO(ConditionalExpression): isArrayType(type) ? getTypeArguments(type)[0] : undefined */ TODO
	}
	isArrayLikeType := func(type_ Type) bool {
		return isArrayType(type_) || !(type_.flags&TypeFlagsNullable) && isTypeAssignableTo(type_, anyReadonlyArrayType)
	}
	isMutableArrayLikeType := func(type_ Type) bool {
		return isMutableArrayOrTuple(type_) || !(type_.flags&(TypeFlagsAny|TypeFlagsNullable)) && isTypeAssignableTo(type_, anyArrayType)
	}
	getSingleBaseForNonAugmentingSubtype := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if !(getObjectFlags(type_) & ObjectFlagsReference) || !(getObjectFlags((type_).target) & ObjectFlagsClassOrInterface) {
			return nil
		}
		if getObjectFlags(type_) & ObjectFlagsIdenticalBaseTypeCalculated {
			return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.IdenticalBaseTypeExists ? (type as TypeReference).cachedEquivalentBaseType : undefined */ TODO
		}
		(type_).objectFlags |= ObjectFlagsIdenticalBaseTypeCalculated
		target := (type_).target
		if getObjectFlags(target) & ObjectFlagsClass {
			baseTypeNode := getBaseTypeNodeOfClass(target)
			if baseTypeNode && baseTypeNode.expression.kind != SyntaxKindIdentifier && baseTypeNode.expression.kind != SyntaxKindPropertyAccessExpression {
				return nil
			}
		}
		bases := getBaseTypes(target)
		if bases.length != 1 {
			return nil
		}
		if getMembersOfSymbol(type_.symbol).size {
			return nil
		}
		instantiatedBase := /* TODO(ConditionalExpression): !length(target.typeParameters) ? bases[0] : instantiateType(bases[0], createTypeMapper(target.typeParameters!, getTypeArguments(type as TypeReference).slice(0, target.typeParameters!.length))) */ TODO
		if length(getTypeArguments(type_)) > length(target.typeParameters) {
			instantiatedBase = getTypeWithThisArgument(instantiatedBase, last(getTypeArguments(type_)))
		}
		(type_).objectFlags |= ObjectFlagsIdenticalBaseTypeExists
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): (type as TypeReference).cachedEquivalentBaseType = instantiatedBase */ TODO
	}
	isEmptyLiteralType := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): strictNullChecks ? type === implicitNeverType : type === undefinedWideningType */ TODO
	}
	isEmptyArrayLiteralType := func(type_ Type) bool {
		elementType := getElementTypeOfArrayType(type_)
		return !!elementType && isEmptyLiteralType(elementType)
	}
	isTupleLikeType := func(type_ Type) bool {
		var lengthType TODO
		return isTupleType(type_) || !!getPropertyOfType(type_, "0") || isArrayLikeType(type_) && !!( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): lengthType = getTypeOfPropertyOfType(type, "length" as __String) */ TODO) && everyType(lengthType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return !!(t.flags & TypeFlagsNumberLiteral)
		})
	}
	isArrayOrTupleLikeType := func(type_ Type) bool {
		return isArrayLikeType(type_) || isTupleLikeType(type_)
	}
	getTupleElementType := func(type_ Type, index number) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		propType := getTypeOfPropertyOfType(type_ /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + index */, TODO)
		if propType {
			return propType
		}
		if everyType(type_, isTupleType) {
			return getTupleElementTypeOutOfStartCount(type_, index /* TODO(ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ? undefinedType : undefined */, TODO)
		}
		return nil
	}
	isNeitherUnitTypeNorNever := func(type_ Type) bool {
		return !(type_.flags & (TypeFlagsUnit | TypeFlagsNever))
	}
	isUnitType := func(type_ Type) bool {
		return !!(type_.flags & TypeFlagsUnit)
	}
	isUnitLikeType := func(type_ Type) bool {
		t := getBaseConstraintOrType(type_)
		return /* TODO(ConditionalExpression): t.flags & TypeFlags.Intersection ? some((t as IntersectionType).types, isUnitType) : isUnitType(t) */ TODO
	}
	extractUnitType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection ? find((type as IntersectionType).types, isUnitType) || type : type */ TODO
	}
	isLiteralType := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Boolean ? true :             type.flags & TypeFlags.Union ? type.flags & TypeFlags.EnumLiteral ? true : every((type as UnionType).types, isUnitType) :             isUnitType(type) */ TODO
	}
	getBaseTypeOfLiteralType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike ? getBaseTypeOfEnumLikeType(type as LiteralType) :             type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? stringType :             type.flags & TypeFlags.NumberLiteral ? numberType :             type.flags & TypeFlags.BigIntLiteral ? bigintType :             type.flags & TypeFlags.BooleanLiteral ? booleanType :             type.flags & TypeFlags.Union ? getBaseTypeOfLiteralTypeUnion(type as UnionType) :             type */ TODO
	}
	getBaseTypeOfLiteralTypeUnion := func(type_ UnionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		key := /* TODO(TemplateExpression): `B${getTypeId(type)}` */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, mapType(type, getBaseTypeOfLiteralType)) */ TODO
	}
	getBaseTypeOfLiteralTypeForComparison := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? stringType :             type.flags & (TypeFlags.NumberLiteral | TypeFlags.Enum) ? numberType :             type.flags & TypeFlags.BigIntLiteral ? bigintType :             type.flags & TypeFlags.BooleanLiteral ? booleanType :             type.flags & TypeFlags.Union ? mapType(type, getBaseTypeOfLiteralTypeForComparison) :             type */ TODO
	}
	getWidenedLiteralType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike && isFreshLiteralType(type) ? getBaseTypeOfEnumLikeType(type as LiteralType) :             type.flags & TypeFlags.StringLiteral && isFreshLiteralType(type) ? stringType :             type.flags & TypeFlags.NumberLiteral && isFreshLiteralType(type) ? numberType :             type.flags & TypeFlags.BigIntLiteral && isFreshLiteralType(type) ? bigintType :             type.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(type) ? booleanType :             type.flags & TypeFlags.Union ? mapType(type as UnionType, getWidenedLiteralType) :             type */ TODO
	}
	getWidenedUniqueESSymbolType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.UniqueESSymbol ? esSymbolType :             type.flags & TypeFlags.Union ? mapType(type as UnionType, getWidenedUniqueESSymbolType) :             type */ TODO
	}
	getWidenedLiteralLikeTypeForContextualType := func(type_ Type, contextualType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !isLiteralOfContextualType(type_, contextualType) {
			type_ = getWidenedUniqueESSymbolType(getWidenedLiteralType(type_))
		}
		return getRegularTypeOfLiteralType(type_)
	}
	getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded := func(type_ *Type, contextualSignatureReturnType *Type, isAsync bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if type_ && isUnitType(type_) {
			contextualType := /* TODO(ConditionalExpression): !contextualSignatureReturnType ? undefined :                 isAsync ? getPromisedTypeOfPromise(contextualSignatureReturnType) :                 contextualSignatureReturnType */ TODO
			type_ = getWidenedLiteralLikeTypeForContextualType(type_, contextualType)
		}
		return type_
	}
	getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded := func(type_ *Type, contextualSignatureReturnType *Type, kind IterationTypeKind, isAsyncGenerator bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if type_ && isUnitType(type_) {
			contextualType := /* TODO(ConditionalExpression): !contextualSignatureReturnType ? undefined :                 getIterationTypeOfGeneratorFunctionReturnType(kind, contextualSignatureReturnType, isAsyncGenerator) */ TODO
			type_ = getWidenedLiteralLikeTypeForContextualType(type_, contextualType)
		}
		return type_
	}
	isTupleType := func(type_ Type) /* TODO(TypePredicate): type is TupleTypeReference */ any {
		return !!(getObjectFlags(type_)&ObjectFlagsReference && (type_).target.objectFlags&ObjectFlagsTuple)
	}
	isGenericTupleType := func(type_ Type) /* TODO(TypePredicate): type is TupleTypeReference */ any {
		return isTupleType(type_) && !!(type_.target.combinedFlags & ElementFlagsVariadic)
	}
	isSingleElementGenericTupleType := func(type_ Type) /* TODO(TypePredicate): type is TupleTypeReference */ any {
		return isGenericTupleType(type_) && type_.target.elementFlags.length == 1
	}
	getRestTypeOfTupleType := func(type_ TupleTypeReference) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return getElementTypeOfSliceOfTupleType(type_, type_.target.fixedLength)
	}
	getTupleElementTypeOutOfStartCount := func(type_ Type, index number, undefinedOrMissingType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			tupleType := t
			restType := getRestTypeOfTupleType(tupleType)
			if !restType {
				return undefinedType
			}
			if undefinedOrMissingType && index >= getTotalFixedElementCount(tupleType.target) {
				return getUnionType( /* TODO(ArrayLiteralExpression): [restType, undefinedOrMissingType] */ TODO)
			}
			return restType
		})
	}
	getRestArrayTypeOfTupleType := func(type_ TupleTypeReference) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType | undefined */ TODO {
		restType := getRestTypeOfTupleType(type_)
		return restType && createArrayType(restType)
	}
	getElementTypeOfSliceOfTupleType := func(type_ TupleTypeReference, index number, endSkipCount /* TODO inferred type number */ TODO /*  = 0 */, writing /* TODO inferred type boolean */ TODO /*  = false */, noReductions /* TODO inferred type boolean */ TODO /*  = false */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		length := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): getTypeReferenceArity(type) - endSkipCount */ TODO
		if index < length {
			typeArguments := getTypeArguments(type_)
			var elementTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			/* TODO(ForStatement): for (let i = index; i < length; i++) {                 const t = typeArguments[i];                 elementTypes.push(type.target.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t);             } */
			return /* TODO(ConditionalExpression): writing ? getIntersectionType(elementTypes) : getUnionType(elementTypes, noReductions ? UnionReduction.None : UnionReduction.Literal) */ TODO
		}
		return nil
	}
	isTupleTypeStructureMatching := func(t1 TupleTypeReference, t2 TupleTypeReference) /* TODO inferred type boolean */ TODO {
		return getTypeReferenceArity(t1) == getTypeReferenceArity(t2) && every(t1.target.elementFlags, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type boolean */ TODO {
			return (f & ElementFlagsVariable) == ( /* TODO(ElementAccessExpression): t2.target.elementFlags[i] */ TODO & ElementFlagsVariable)
		})
	}
	isZeroBigInt := func(TODO_IDENTIFIER BigIntLiteralType) /* TODO inferred type boolean */ TODO {
		return value.base10Value == "0"
	}
	removeDefinitelyFalsyTypes := func(type_ Type) Type {
		return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return hasTypeFacts(t, TypeFactsTruthy)
		})
	}
	extractDefinitelyFalsyTypes := func(type_ Type) Type {
		return mapType(type_, getDefinitelyFalsyPartOfType)
	}
	getDefinitelyFalsyPartOfType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.String ? emptyStringType :             type.flags & TypeFlags.Number ? zeroType :             type.flags & TypeFlags.BigInt ? zeroBigIntType :             type === regularFalseType ||                 type === falseType ||                 type.flags & (TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null | TypeFlags.AnyOrUnknown) ||                 type.flags & TypeFlags.StringLiteral && (type as StringLiteralType).value === "" ||                 type.flags & TypeFlags.NumberLiteral && (type as NumberLiteralType).value === 0 ||                 type.flags & TypeFlags.BigIntLiteral && isZeroBigInt(type as BigIntLiteralType) ? type :             neverType */ TODO
	}
	getNullableType := func(type_ Type, flags TypeFlags) Type {
		missing := (flags & ~type_.flags) & (TypeFlagsUndefined | TypeFlagsNull)
		return /* TODO(ConditionalExpression): missing === 0 ? type :             missing === TypeFlags.Undefined ? getUnionType([type, undefinedType]) :             missing === TypeFlags.Null ? getUnionType([type, nullType]) :             getUnionType([type, undefinedType, nullType]) */ TODO
	}
	getOptionalType := func(type_ Type, isProperty /* TODO inferred type boolean */ TODO /*  = false */) Type {
		Debug.assert(strictNullChecks)
		missingOrUndefined := /* TODO(ConditionalExpression): isProperty ? undefinedOrMissingType : undefinedType */ TODO
		return /* TODO(ConditionalExpression): type === missingOrUndefined || type.flags & TypeFlags.Union && (type as UnionType).types[0] === missingOrUndefined ? type : getUnionType([type, missingOrUndefined]) */ TODO
	}
	getGlobalNonNullableTypeInstantiation := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !deferredGlobalNonNullableTypeAlias {
			deferredGlobalNonNullableTypeAlias = getGlobalSymbol("NonNullable", SymbolFlagsTypeAlias, nil) || unknownSymbol
		}
		return /* TODO(ConditionalExpression): deferredGlobalNonNullableTypeAlias !== unknownSymbol ?             getTypeAliasInstantiation(deferredGlobalNonNullableTypeAlias, [type]) :             getIntersectionType([type, emptyObjectType]) */ TODO
	}
	getNonNullableType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): strictNullChecks ? getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO
	}
	addOptionalTypeMarker := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): strictNullChecks ? getUnionType([type, optionalType]) : type */ TODO
	}
	removeOptionalTypeMarker := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): strictNullChecks ? removeType(type, optionalType) : type */ TODO
	}
	propagateOptionalTypeMarker := func(type_ Type, node OptionalChain, wasOptional bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): wasOptional ? isOutermostOptionalChain(node) ? getOptionalType(type) : addOptionalTypeMarker(type) : type */ TODO
	}
	getOptionalExpressionType := func(exprType Type, expression Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): isExpressionOfOptionalChainRoot(expression) ? getNonNullableType(exprType) :             isOptionalChain(expression) ? removeOptionalTypeMarker(exprType) :             exprType */ TODO
	}
	removeMissingType := func(type_ Type, isOptional bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): exactOptionalPropertyTypes && isOptional ? removeType(type, missingType) : type */ TODO
	}
	containsMissingType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return type_ == missingType || !!(type_.flags&TypeFlagsUnion) && /* TODO(ElementAccessExpression): (type as UnionType).types[0] */ TODO == missingType
	}
	removeMissingOrUndefinedType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): exactOptionalPropertyTypes ? removeType(type, missingType) : getTypeWithFacts(type, TypeFacts.NEUndefined) */ TODO
	}
	isCoercibleUnderDoubleEquals := func(source Type, target Type) bool {
		return ((source.flags & (TypeFlagsNumber | TypeFlagsString | TypeFlagsBooleanLiteral)) != 0) && ((target.flags & (TypeFlagsNumber | TypeFlagsString | TypeFlagsBoolean)) != 0)
	}
	isObjectTypeWithInferableIndex := func(type_ Type) bool {
		objectFlags := getObjectFlags(type_)
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection             ? every((type as IntersectionType).types, isObjectTypeWithInferableIndex)             : !!(                 type.symbol                 && (type.symbol.flags & (SymbolFlags.ObjectLiteral | SymbolFlags.TypeLiteral | SymbolFlags.Enum | SymbolFlags.ValueModule)) !== 0                 && !(type.symbol.flags & SymbolFlags.Class)                 && !typeHasCallOrConstructSignatures(type)             ) || !!(                 objectFlags & ObjectFlags.ObjectRestType             ) || !!(objectFlags & ObjectFlags.ReverseMapped && isObjectTypeWithInferableIndex((type as ReverseMappedType).source)) */ TODO
	}
	createSymbolWithType := func(source Symbol, type_ *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		symbol := createSymbol(source.flags, source.escapedName, getCheckFlags(source)&CheckFlagsReadonly)
		symbol.declarations = source.declarations
		symbol.parent = source.parent
		symbol.links.type_ = type_
		symbol.links.target = source
		if source.valueDeclaration {
			symbol.valueDeclaration = source.valueDeclaration
		}
		nameType := getSymbolLinks(source).nameType
		if nameType {
			symbol.links.nameType = nameType
		}
		return symbol
	}
	transformTypeOfMembers := func(type_ Type, f func(propertyType Type) Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ TODO {
		members := createSymbolTable()
		for _, property := range getPropertiesOfObjectType(type_) {
			original := getTypeOfSymbol(property)
			updated := f(original)
			members.set(property.escapedName /* TODO(ConditionalExpression): updated === original ? property : createSymbolWithType(property, updated) */, TODO)
		}
		return members
	}
	getRegularTypeOfObjectLiteral := func(type_ Type) Type {
		if !(isObjectLiteralType(type_) && getObjectFlags(type_)&ObjectFlagsFreshLiteral) {
			return type_
		}
		regularType := (type_).regularType
		if regularType {
			return regularType
		}
		resolved := type_
		members := transformTypeOfMembers(type_, getRegularTypeOfObjectLiteral)
		regularNew := createAnonymousType(resolved.symbol, members, resolved.callSignatures, resolved.constructSignatures, resolved.indexInfos)
		regularNew.flags = resolved.flags
		regularNew.objectFlags |= resolved.objectFlags & ~ObjectFlagsFreshLiteral
		(type_).regularType = regularNew
		return regularNew
	}
	createWideningContext := func(parent *WideningContext, propertyName *__String, siblings /* TODO(ArrayType): Type[] */ any) WideningContext {
		return /* TODO(ObjectLiteralExpression): { parent, propertyName, siblings, resolvedProperties: undefined } */ TODO
	}
	getSiblingsOfContext := func(context WideningContext) []Type {
		if !context.siblings {
			var siblings []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, type_ := range getSiblingsOfContext(context.parent) {
				if isObjectLiteralType(type_) {
					prop := getPropertyOfObjectType(type_, context.propertyName)
					if prop {
						forEachType(getTypeOfSymbol(prop), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
							siblings.push(t)
						})
					}
				}
			}
			context.siblings = siblings
		}
		return context.siblings
	}
	getPropertiesOfContext := func(context WideningContext) []Symbol {
		if !context.resolvedProperties {
			names := make(map[__String]Symbol)
			for _, t := range getSiblingsOfContext(context) {
				if isObjectLiteralType(t) && !(getObjectFlags(t) & ObjectFlagsContainsSpread) {
					for _, prop := range getPropertiesOfType(t) {
						names.set(prop.escapedName, prop)
					}
				}
			}
			context.resolvedProperties = arrayFrom(names.values())
		}
		return context.resolvedProperties
	}
	getWidenedProperty := func(prop Symbol, context *WideningContext) Symbol {
		if !(prop.flags & SymbolFlagsProperty) {
			return prop
		}
		original := getTypeOfSymbol(prop)
		propContext := context && createWideningContext(context, prop.escapedName, nil)
		widened := getWidenedTypeWithContext(original, propContext)
		return /* TODO(ConditionalExpression): widened === original ? prop : createSymbolWithType(prop, widened) */ TODO
	}
	getUndefinedProperty := func(prop Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		cached := undefinedProperties.get(prop.escapedName)
		if cached {
			return cached
		}
		result := createSymbolWithType(prop, undefinedOrMissingType)
		result.flags |= SymbolFlagsOptional
		undefinedProperties.set(prop.escapedName, result)
		return result
	}
	getWidenedTypeOfObjectLiteral := func(type_ Type, context *WideningContext) Type {
		members := createSymbolTable()
		for _, prop := range getPropertiesOfObjectType(type_) {
			members.set(prop.escapedName, getWidenedProperty(prop, context))
		}
		if context {
			for _, prop := range getPropertiesOfContext(context) {
				if !members.has(prop.escapedName) {
					members.set(prop.escapedName, getUndefinedProperty(prop))
				}
			}
		}
		result := createAnonymousType(type_.symbol, members, emptyArray, emptyArray, sameMap(getIndexInfosOfType(type_), func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO {
			return createIndexInfo(info.keyType, getWidenedType(info.type_), info.isReadonly)
		}))
		result.objectFlags |= getObjectFlags(type_) & (ObjectFlagsJSLiteral | ObjectFlagsNonInferrableType)
		return result
	}
	getWidenedType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getWidenedTypeWithContext(type_, nil)
	}
	getWidenedTypeWithContext := func(type_ Type, context *WideningContext) Type {
		if getObjectFlags(type_) & ObjectFlagsRequiresWidening {
			if context == nil && type_.widened {
				return type_.widened
			}
			var result *Type
			if type_.flags & (TypeFlagsAny | TypeFlagsNullable) {
				result = anyType
			} else if isObjectLiteralType(type_) {
				result = getWidenedTypeOfObjectLiteral(type_, context)
			} else if type_.flags & TypeFlagsUnion {
				unionContext := context || createWideningContext(nil, nil, (type_).types)
				widenedTypes := sameMap((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					return /* TODO(ConditionalExpression): t.flags & TypeFlags.Nullable ? t : getWidenedTypeWithContext(t, unionContext) */ TODO
				})
				result = getUnionType(widenedTypes /* TODO(ConditionalExpression): some(widenedTypes, isEmptyObjectType) ? UnionReduction.Subtype : UnionReduction.Literal */, TODO)
			} else if type_.flags & TypeFlagsIntersection {
				result = getIntersectionType(sameMap((type_).types, getWidenedType))
			} else if isArrayOrTupleType(type_) {
				result = createTypeReference(type_.target, sameMap(getTypeArguments(type_), getWidenedType))
			}
			if result && context == nil {
				type_.widened = result
			}
			return result || type_
		}
		return type_
	}
	reportWideningErrorsInType := func(type_ Type) bool {
		errorReported := false
		if getObjectFlags(type_) & ObjectFlagsContainsWideningType {
			if type_.flags & TypeFlagsUnion {
				if some((type_).types, isEmptyObjectType) {
					errorReported = true
				} else {
					for _, t := range (type_).types {
						/* TODO(ExpressionStatement): errorReported ||= reportWideningErrorsInType(t); */
					}
				}
			} else if isArrayOrTupleType(type_) {
				for _, t := range getTypeArguments(type_) {
					/* TODO(ExpressionStatement): errorReported ||= reportWideningErrorsInType(t); */
				}
			} else if isObjectLiteralType(type_) {
				for _, p := range getPropertiesOfObjectType(type_) {
					t := getTypeOfSymbol(p)
					if getObjectFlags(t) & ObjectFlagsContainsWideningType {
						errorReported = reportWideningErrorsInType(t)
						if !errorReported {
							valueDeclaration := p.declarations.find(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
								return d.symbol.valueDeclaration.parent == type_.symbol.valueDeclaration
							})
							if valueDeclaration {
								error(valueDeclaration, Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, symbolToString(p), typeToString(getWidenedType(t)))
								errorReported = true
							}
						}
					}
				}
			}
		}
		return errorReported
	}
	reportImplicitAny := func(declaration Declaration, type_ Type, wideningKind WideningKind) {
		typeAsString := typeToString(getWidenedType(type_))
		if isInJSFile(declaration) && !isCheckJsEnabledForFile(getSourceFileOfNode(declaration), compilerOptions) {
			return
		}
		var diagnostic DiagnosticMessage
		switch declaration.kind {
		case SyntaxKindBinaryExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertySignature:
			diagnostic = /* TODO(ConditionalExpression): noImplicitAny ? Diagnostics.Member_0_implicitly_has_an_1_type : Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage */ TODO
			break
		case SyntaxKindParameter:
			param := declaration
			if isIdentifier(param.name) {
				originalKeywordKind := identifierToKeywordKind(param.name)
				if (isCallSignatureDeclaration(param.parent) || isMethodSignature(param.parent) || isFunctionTypeNode(param.parent)) && param.parent.parameters.includes(param) && (resolveName(param, param.name.escapedText, SymbolFlagsType, nil, true) || originalKeywordKind && isTypeNodeKind(originalKeywordKind)) {
					newName := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "arg" + param.parent.parameters.indexOf(param) */ TODO
					typeName := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): declarationNameToString(param.name) + (param.dotDotDotToken ? "[]" : "") */ TODO
					errorOrSuggestion(noImplicitAny, declaration, Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1, newName, typeName)
					return
				}
			}
			diagnostic = /* TODO(ConditionalExpression): (declaration as ParameterDeclaration).dotDotDotToken ?                     noImplicitAny ? Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage :                     noImplicitAny ? Diagnostics.Parameter_0_implicitly_has_an_1_type : Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage */ TODO
			break
		case SyntaxKindBindingElement:
			diagnostic = Diagnostics.Binding_element_0_implicitly_has_an_1_type
			if !noImplicitAny {
				return
			}
			break
		case SyntaxKindJSDocFunctionType:
			error(declaration, Diagnostics.Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString)
			return
		case SyntaxKindJSDocSignature:
			if noImplicitAny && isJSDocOverloadTag(declaration.parent) {
				error(declaration.parent.tagName, Diagnostics.This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation, typeAsString)
			}
			return
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodSignature:
			fallthrough // TODO: merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			if noImplicitAny && !(declaration).name {
				if wideningKind == WideningKindGeneratorYield {
					error(declaration, Diagnostics.Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation, typeAsString)
				} else {
					error(declaration, Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString)
				}
				return
			}
			diagnostic = /* TODO(ConditionalExpression): !noImplicitAny ? Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage :                     wideningKind === WideningKind.GeneratorYield ? Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type :                     Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type */ TODO
			break
		case SyntaxKindMappedType:
			if noImplicitAny {
				error(declaration, Diagnostics.Mapped_object_type_implicitly_has_an_any_template_type)
			}
			return
		default:
			diagnostic = /* TODO(ConditionalExpression): noImplicitAny ? Diagnostics.Variable_0_implicitly_has_an_1_type : Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage */ TODO
		}
		errorOrSuggestion(noImplicitAny, declaration, diagnostic, declarationNameToString(getNameOfDeclaration(declaration)), typeAsString)
	}
	reportErrorsFromWidening := func(declaration Declaration, type_ Type, wideningKind WideningKind) {
		addLazyDiagnostic(func() {
			if noImplicitAny && getObjectFlags(type_)&ObjectFlagsContainsWideningType && (!wideningKind || !getContextualSignatureForFunctionLikeDeclaration(declaration)) {
				if !reportWideningErrorsInType(type_) {
					reportImplicitAny(declaration, type_, wideningKind)
				}
			}
		})
	}
	applyToParameterTypes := func(source Signature, target Signature, callback func(s Type, t Type)) {
		sourceCount := getParameterCount(source)
		targetCount := getParameterCount(target)
		sourceRestType := getEffectiveRestType(source)
		targetRestType := getEffectiveRestType(target)
		targetNonRestCount := /* TODO(ConditionalExpression): targetRestType ? targetCount - 1 : targetCount */ TODO
		paramCount := /* TODO(ConditionalExpression): sourceRestType ? targetNonRestCount : Math.min(sourceCount, targetNonRestCount) */ TODO
		sourceThisType := getThisTypeOfSignature(source)
		if sourceThisType {
			targetThisType := getThisTypeOfSignature(target)
			if targetThisType {
				callback(sourceThisType, targetThisType)
			}
		}
		/* TODO(ForStatement): for (let i = 0; i < paramCount; i++) {             callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i));         } */
		if targetRestType {
			callback(getRestTypeAtPosition(source, paramCount, isConstTypeVariable(targetRestType) && !someType(targetRestType, isMutableArrayLikeType)), targetRestType)
		}
	}
	applyToReturnTypes := func(source Signature, target Signature, callback func(s Type, t Type)) {
		targetTypePredicate := getTypePredicateOfSignature(target)
		if targetTypePredicate {
			sourceTypePredicate := getTypePredicateOfSignature(source)
			if sourceTypePredicate && typePredicateKindsMatch(sourceTypePredicate, targetTypePredicate) && sourceTypePredicate.type_ && targetTypePredicate.type_ {
				callback(sourceTypePredicate.type_, targetTypePredicate.type_)
				return
			}
		}
		targetReturnType := getReturnTypeOfSignature(target)
		if couldContainTypeVariables(targetReturnType) {
			callback(getReturnTypeOfSignature(source), targetReturnType)
		}
	}
	createInferenceContext := func(typeParameters []TypeParameter, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
		return createInferenceContextWorker(typeParameters.map_(createInferenceInfo), signature, flags, compareTypes || compareTypesAssignable)
	}
	cloneInferenceContext := func(context T, extraFlags InferenceFlags /*  = 0 */) /* TODO(UnionType): InferenceContext | T & undefined */ any {
		return context && createInferenceContextWorker(map_(context.inferences, cloneInferenceInfo), context.signature, context.flags|extraFlags, context.compareTypes)
	}
	createInferenceContextWorker := func(inferences []InferenceInfo, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
		var context InferenceContext = /* TODO(ObjectLiteralExpression): {             inferences,             signature,             flags,             compareTypes,             mapper: reportUnmeasurableMapper, // initialize to a noop mapper so the context object is available, but the underlying object shape is right upon construction             nonFixingMapper: reportUnmeasurableMapper,         } */ TODO
		context.mapper = makeFixingMapperForContext(context)
		context.nonFixingMapper = makeNonFixingMapperForContext(context)
		return context
	}
	makeFixingMapperForContext := func(context InferenceContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return makeDeferredTypeMapper(map_(context.inferences, func(i /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
			return i.typeParameter
		}), map_(context.inferences, func(inference /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type () => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				if !inference.isFixed {
					inferFromIntraExpressionSites(context)
					clearCachedInferences(context.inferences)
					inference.isFixed = true
				}
				return getInferredType(context, i)
			}
		}))
	}
	makeNonFixingMapperForContext := func(context InferenceContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return makeDeferredTypeMapper(map_(context.inferences, func(i /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
			return i.typeParameter
		}), map_(context.inferences, func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type () => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return getInferredType(context, i)
			}
		}))
	}
	clearCachedInferences := func(inferences []InferenceInfo) {
		for _, inference := range inferences {
			if !inference.isFixed {
				inference.inferredType = nil
			}
		}
	}
	addIntraExpressionInferenceSite := func(context InferenceContext, node /* TODO(UnionType): Expression | MethodDeclaration */ any, type_ Type) {
		( /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): context.intraExpressionInferenceSites ??= [] */ TODO).push( /* TODO(ObjectLiteralExpression): { node, type } */ TODO)
	}
	inferFromIntraExpressionSites := func(context InferenceContext) {
		if context.intraExpressionInferenceSites {
			for _, TODO_IDENTIFIER := range context.intraExpressionInferenceSites {
				contextualType := /* TODO(ConditionalExpression): node.kind === SyntaxKind.MethodDeclaration ?                     getContextualTypeForObjectLiteralMethod(node as MethodDeclaration, ContextFlags.NoConstraints) :                     getContextualType(node, ContextFlags.NoConstraints) */ TODO
				if contextualType {
					inferTypes(context.inferences, type_, contextualType)
				}
			}
			context.intraExpressionInferenceSites = nil
		}
	}
	createInferenceInfo := func(typeParameter TypeParameter) InferenceInfo {
		return /* TODO(ObjectLiteralExpression): {             typeParameter,             candidates: undefined,             contraCandidates: undefined,             inferredType: undefined,             priority: undefined,             topLevel: true,             isFixed: false,             impliedArity: undefined,         } */ TODO
	}
	cloneInferenceInfo := func(inference InferenceInfo) InferenceInfo {
		return /* TODO(ObjectLiteralExpression): {             typeParameter: inference.typeParameter,             candidates: inference.candidates && inference.candidates.slice(),             contraCandidates: inference.contraCandidates && inference.contraCandidates.slice(),             inferredType: inference.inferredType,             priority: inference.priority,             topLevel: inference.topLevel,             isFixed: inference.isFixed,             impliedArity: inference.impliedArity,         } */ TODO
	}
	cloneInferredPartOfContext := func(context InferenceContext) *InferenceContext {
		inferences := filter(context.inferences, hasInferenceCandidates)
		return /* TODO(ConditionalExpression): inferences.length ?             createInferenceContextWorker(map(inferences, cloneInferenceInfo), context.signature, context.flags, context.compareTypes) :             undefined */ TODO
	}
	getMapperFromContext := func(context T) /* TODO(UnionType): TypeMapper | T & undefined */ any {
		return context && context.mapper
	}
	couldContainTypeVariables := func(type_ Type) bool {
		objectFlags := getObjectFlags(type_)
		if objectFlags & ObjectFlagsCouldContainTypeVariablesComputed {
			return !!(objectFlags & ObjectFlagsCouldContainTypeVariables)
		}
		result := !!(type_.flags&TypeFlagsInstantiable || type_.flags&TypeFlagsObject && !isNonGenericTopLevelType(type_) && (objectFlags&ObjectFlagsReference && ((type_).node || some(getTypeArguments(type_), couldContainTypeVariables)) || objectFlags&ObjectFlagsSingleSignatureType && !!length((type_).outerTypeParameters) || objectFlags&ObjectFlagsAnonymous && type_.symbol && type_.symbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod|SymbolFlagsClass|SymbolFlagsTypeLiteral|SymbolFlagsObjectLiteral) && type_.symbol.declarations || objectFlags&(ObjectFlagsMapped|ObjectFlagsReverseMapped|ObjectFlagsObjectRestType|ObjectFlagsInstantiationExpressionType)) || type_.flags&TypeFlagsUnionOrIntersection && !(type_.flags&TypeFlagsEnumLiteral) && !isNonGenericTopLevelType(type_) && some((type_).types, couldContainTypeVariables))
		if type_.flags & TypeFlagsObjectFlagsType {
			(type_).objectFlags |= ObjectFlagsCouldContainTypeVariablesComputed | ( /* TODO(ConditionalExpression): result ? ObjectFlags.CouldContainTypeVariables : 0 */ TODO)
		}
		return result
	}
	isNonGenericTopLevelType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		if type_.aliasSymbol && !type_.aliasTypeArguments {
			declaration := getDeclarationOfKind(type_.aliasSymbol, SyntaxKindTypeAliasDeclaration)
			return !!(declaration && findAncestor(declaration.parent, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
				return /* TODO(ConditionalExpression): n.kind === SyntaxKind.SourceFile ? true : n.kind === SyntaxKind.ModuleDeclaration ? false : "quit" */ TODO
			}))
		}
		return false
	}
	isTypeParameterAtTopLevel := func(type_ Type, tp TypeParameter, depth /* TODO inferred type number */ TODO /*  = 0 */) bool {
		return !!(type_ == tp || type_.flags&TypeFlagsUnionOrIntersection && some((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return isTypeParameterAtTopLevel(t, tp, depth)
		}) || depth < 3 && type_.flags&TypeFlagsConditional && (isTypeParameterAtTopLevel(getTrueTypeFromConditionalType(type_), tp /* TODO(PlusToken): + */ /* TODO(BinaryExpression): depth + 1 */, TODO) || isTypeParameterAtTopLevel(getFalseTypeFromConditionalType(type_), tp /* TODO(PlusToken): + */ /* TODO(BinaryExpression): depth + 1 */, TODO)))
	}
	isTypeParameterAtTopLevelInReturnType := func(signature Signature, typeParameter TypeParameter) /* TODO inferred type boolean */ TODO {
		typePredicate := getTypePredicateOfSignature(signature)
		return /* TODO(ConditionalExpression): typePredicate ? !!typePredicate.type && isTypeParameterAtTopLevel(typePredicate.type, typeParameter) :             isTypeParameterAtTopLevel(getReturnTypeOfSignature(signature), typeParameter) */ TODO
	}
	createEmptyObjectTypeFromStringLiteral := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
		members := createSymbolTable()
		forEachType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
			if !(t.flags & TypeFlagsStringLiteral) {
				return
			}
			name := escapeLeadingUnderscores((t).value)
			literalProp := createSymbol(SymbolFlagsProperty, name)
			literalProp.links.type_ = anyType
			if t.symbol {
				literalProp.declarations = t.symbol.declarations
				literalProp.valueDeclaration = t.symbol.valueDeclaration
			}
			members.set(name, literalProp)
		})
		indexInfos := /* TODO(ConditionalExpression): type.flags & TypeFlags.String ? [createIndexInfo(stringType, emptyObjectType, /*isReadonly* / false)] : emptyArray */ TODO
		return createAnonymousType(nil, members, emptyArray, emptyArray, indexInfos)
	}
	inferTypeForHomomorphicMappedType := func(source Type, target MappedType, constraint IndexType) *Type {
		cacheKey := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): source.id + "," + target.id + "," + constraint.id */ TODO
		if reverseHomomorphicMappedCache.has(cacheKey) {
			return reverseHomomorphicMappedCache.get(cacheKey)
		}
		type_ := createReverseMappedType(source, target, constraint)
		reverseHomomorphicMappedCache.set(cacheKey, type_)
		return type_
	}
	isPartiallyInferableType := func(type_ Type) bool {
		return !(getObjectFlags(type_) & ObjectFlagsNonInferrableType) || isObjectLiteralType(type_) && some(getPropertiesOfType(type_), func(prop /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
			return isPartiallyInferableType(getTypeOfSymbol(prop))
		}) || isTupleType(type_) && some(getElementTypes(type_), isPartiallyInferableType)
	}
	createReverseMappedType := func(source Type, target MappedType, constraint IndexType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if !(getIndexInfoOfType(source, stringType) || getPropertiesOfType(source).length != 0 && isPartiallyInferableType(source)) {
			return nil
		}
		if isArrayType(source) {
			elementType := inferReverseMappedType( /* TODO(ElementAccessExpression): getTypeArguments(source)[0] */ TODO, target, constraint)
			if !elementType {
				return nil
			}
			return createArrayType(elementType, isReadonlyArrayType(source))
		}
		if isTupleType(source) {
			elementTypes := map_(getElementTypes(source), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
				return inferReverseMappedType(t, target, constraint)
			})
			if !every(elementTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO) /* TODO(TypePredicate): t is Type */ any {
				return !!t
			}) {
				return nil
			}
			elementFlags := /* TODO(ConditionalExpression): getMappedTypeModifiers(target) & MappedTypeModifiers.IncludeOptional ?                 sameMap(source.target.elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) :                 source.target.elementFlags */ TODO
			return createTupleType(elementTypes, elementFlags, source.target.readonly, source.target.labeledElementDeclarations)
		}
		reversed := createObjectType(ObjectFlagsReverseMapped|ObjectFlagsAnonymous, nil)
		reversed.source = source
		reversed.mappedType = target
		reversed.constraintType = constraint
		return reversed
	}
	getTypeOfReverseMappedSymbol := func(symbol ReverseMappedSymbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			links.type_ = inferReverseMappedType(symbol.links.propertyType, symbol.links.mappedType, symbol.links.constraintType) || unknownType
		}
		return links.type_
	}
	inferReverseMappedTypeWorker := func(sourceType Type, target MappedType, constraint IndexType) Type {
		typeParameter := getIndexedAccessType(constraint.type_, getTypeParameterFromMappedType(target))
		templateType := getTemplateTypeFromMappedType(target)
		inference := createInferenceInfo(typeParameter)
		inferTypes( /* TODO(ArrayLiteralExpression): [inference] */ TODO, sourceType, templateType)
		return getTypeFromInference(inference) || unknownType
	}
	inferReverseMappedType := func(source Type, target MappedType, constraint IndexType) *Type {
		cacheKey := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): source.id + "," + target.id + "," + constraint.id */ TODO
		if reverseMappedCache.has(cacheKey) {
			return reverseMappedCache.get(cacheKey) || unknownType
		}
		reverseMappedSourceStack.push(source)
		reverseMappedTargetStack.push(target)
		saveExpandingFlags := reverseExpandingFlags
		if isDeeplyNestedType(source, reverseMappedSourceStack, reverseMappedSourceStack.length, 2) {
			reverseExpandingFlags |= ExpandingFlagsSource
		}
		if isDeeplyNestedType(target, reverseMappedTargetStack, reverseMappedTargetStack.length, 2) {
			reverseExpandingFlags |= ExpandingFlagsTarget
		}
		var type_ TODO
		if reverseExpandingFlags != ExpandingFlagsBoth {
			type_ = inferReverseMappedTypeWorker(source, target, constraint)
		}
		reverseMappedSourceStack.pop()
		reverseMappedTargetStack.pop()
		reverseExpandingFlags = saveExpandingFlags
		reverseMappedCache.set(cacheKey, type_)
		return type_
	}
	getUnmatchedProperties := func(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) IterableIterator[Symbol] {
		properties := getPropertiesOfType(target)
		for _, targetProp := range properties {
			if isStaticPrivateIdentifierProperty(targetProp) {
				continue
			}
			if requireOptionalProperties || !(targetProp.flags&SymbolFlagsOptional || getCheckFlags(targetProp)&CheckFlagsPartial) {
				sourceProp := getPropertyOfType(source, targetProp.escapedName)
				if !sourceProp {
					/* TODO(ExpressionStatement): yield targetProp; */
				} else if matchDiscriminantProperties {
					targetType := getTypeOfSymbol(targetProp)
					if targetType.flags & TypeFlagsUnit {
						sourceType := getTypeOfSymbol(sourceProp)
						if !(sourceType.flags&TypeFlagsAny || getRegularTypeOfLiteralType(sourceType) == getRegularTypeOfLiteralType(targetType)) {
							/* TODO(ExpressionStatement): yield targetProp; */
						}
					}
				}
			}
		}
	}
	getUnmatchedProperty := func(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) *Symbol {
		return firstOrUndefinedIterator(getUnmatchedProperties(source, target, requireOptionalProperties, matchDiscriminantProperties))
	}
	tupleTypesDefinitelyUnrelated := func(source TupleTypeReference, target TupleTypeReference) /* TODO inferred type boolean */ TODO {
		return !(target.target.combinedFlags&ElementFlagsVariadic) && target.target.minLength > source.target.minLength || !(target.target.combinedFlags&ElementFlagsVariable) && (!!(source.target.combinedFlags&ElementFlagsVariable) || target.target.fixedLength < source.target.fixedLength)
	}
	typesDefinitelyUnrelated := func(source Type, target Type) /* TODO inferred type boolean */ TODO {
		return /* TODO(ConditionalExpression): isTupleType(source) && isTupleType(target) ? tupleTypesDefinitelyUnrelated(source, target) :             !!getUnmatchedProperty(source, target, /*requireOptionalProperties* / false, /*matchDiscriminantProperties* / true) &&             !!getUnmatchedProperty(target, source, /*requireOptionalProperties* / false, /*matchDiscriminantProperties* / false) */ TODO
	}
	getTypeFromInference := func(inference InferenceInfo) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): inference.candidates ? getUnionType(inference.candidates, UnionReduction.Subtype) :             inference.contraCandidates ? getIntersectionType(inference.contraCandidates) :             undefined */ TODO
	}
	hasSkipDirectInferenceFlag := func(node Node) /* TODO inferred type boolean */ TODO {
		return !!getNodeLinks(node).skipDirectInference
	}
	isFromInferenceBlockedSource := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(type_.symbol && some(type_.symbol.declarations, hasSkipDirectInferenceFlag))
	}
	templateLiteralTypesDefinitelyUnrelated := func(source TemplateLiteralType, target TemplateLiteralType) /* TODO inferred type boolean */ TODO {
		sourceStart := /* TODO(ElementAccessExpression): source.texts[0] */ TODO
		targetStart := /* TODO(ElementAccessExpression): target.texts[0] */ TODO
		sourceEnd := /* TODO(ElementAccessExpression): source.texts[source.texts.length - 1] */ TODO
		targetEnd := /* TODO(ElementAccessExpression): target.texts[target.texts.length - 1] */ TODO
		startLen := Math.min(sourceStart.length, targetStart.length)
		endLen := Math.min(sourceEnd.length, targetEnd.length)
		return sourceStart.slice(0, startLen) != targetStart.slice(0, startLen) || sourceEnd.slice( /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceEnd.length - endLen */ TODO) != targetEnd.slice( /* TODO(MinusToken): - */ /* TODO(BinaryExpression): targetEnd.length - endLen */ TODO)
	}
	isValidNumberString := func(s string, roundTripOnly bool) bool {
		if s == "" {
			return false
		}
		n := +s
		return isFinite(n) && (!roundTripOnly || /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + n */ TODO == s)
	}
	parseBigIntLiteralType := func(text string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BigIntLiteralType */ TODO {
		return getBigIntLiteralType(parseValidBigInt(text))
	}
	isMemberOfStringMapping := func(source Type, target Type) bool {
		if target.flags & TypeFlagsAny {
			return true
		}
		if target.flags & (TypeFlagsString | TypeFlagsTemplateLiteral) {
			return isTypeAssignableTo(source, target)
		}
		if target.flags & TypeFlagsStringMapping {
			mappingStack := /* TODO(ArrayLiteralExpression): [] */ TODO
			for target.flags & TypeFlagsStringMapping {
				mappingStack.unshift(target.symbol)
				target = (target).type_
			}
			mappedSource := reduceLeft(mappingStack, func(memo /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, value /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return getStringMappingType(value, memo)
			}, source)
			return mappedSource == source && isMemberOfStringMapping(source, target)
		}
		return false
	}
	isValidTypeForTemplateLiteralPlaceholder := func(source Type, target Type) bool {
		if target.flags & TypeFlagsIntersection {
			return every((target).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return t == emptyTypeLiteralType || isValidTypeForTemplateLiteralPlaceholder(source, t)
			})
		}
		if target.flags&TypeFlagsString || isTypeAssignableTo(source, target) {
			return true
		}
		if source.flags & TypeFlagsStringLiteral {
			value := (source).value
			return !!(target.flags&TypeFlagsNumber && isValidNumberString(value, false) || target.flags&TypeFlagsBigInt && isValidBigIntString(value, false) || target.flags&(TypeFlagsBooleanLiteral|TypeFlagsNullable) && value == (target).intrinsicName || target.flags&TypeFlagsStringMapping && isMemberOfStringMapping(getStringLiteralType(value), target) || target.flags&TypeFlagsTemplateLiteral && isTypeMatchedByTemplateLiteralType(source, target))
		}
		if source.flags & TypeFlagsTemplateLiteral {
			texts := (source).texts
			return texts.length == 2 && /* TODO(ElementAccessExpression): texts[0] */ TODO == "" && /* TODO(ElementAccessExpression): texts[1] */ TODO == "" && isTypeAssignableTo( /* TODO(ElementAccessExpression): (source as TemplateLiteralType).types[0] */ TODO, target)
		}
		return false
	}
	inferTypesFromTemplateLiteralType := func(source Type, target TemplateLiteralType) /* TODO(ArrayType): Type[] */ any {
		return /* TODO(ConditionalExpression): source.flags & TypeFlags.StringLiteral ? inferFromLiteralPartsToTemplateLiteral([(source as StringLiteralType).value], emptyArray, target) :             source.flags & TypeFlags.TemplateLiteral ?             arrayIsEqualTo((source as TemplateLiteralType).texts, target.texts) ? map((source as TemplateLiteralType).types, (s, i) => {                 return isTypeAssignableTo(getBaseConstraintOrType(s), getBaseConstraintOrType(target.types[i])) ? s : getStringLikeTypeForType(s);             }) :                 inferFromLiteralPartsToTemplateLiteral((source as TemplateLiteralType).texts, (source as TemplateLiteralType).types, target) :             undefined */ TODO
	}
	isTypeMatchedByTemplateLiteralType := func(source Type, target TemplateLiteralType) bool {
		inferences := inferTypesFromTemplateLiteralType(source, target)
		return !!inferences && every(inferences, func(r /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type boolean */ TODO {
			return isValidTypeForTemplateLiteralPlaceholder(r /* TODO(ElementAccessExpression): target.types[i] */, TODO)
		})
	}
	getStringLikeTypeForType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.Any | TypeFlags.StringLike) ? type : getTemplateLiteralType(["", ""], [type]) */ TODO
	}
	inferFromLiteralPartsToTemplateLiteral := func(sourceTexts []string, sourceTypes []Type, target TemplateLiteralType) /* TODO(ArrayType): Type[] */ any {
		lastSourceIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceTexts.length - 1 */ TODO
		sourceStartText := /* TODO(ElementAccessExpression): sourceTexts[0] */ TODO
		sourceEndText := /* TODO(ElementAccessExpression): sourceTexts[lastSourceIndex] */ TODO
		targetTexts := target.texts
		lastTargetIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): targetTexts.length - 1 */ TODO
		targetStartText := /* TODO(ElementAccessExpression): targetTexts[0] */ TODO
		targetEndText := /* TODO(ElementAccessExpression): targetTexts[lastTargetIndex] */ TODO
		if lastSourceIndex == 0 && sourceStartText.length < /* TODO(PlusToken): + */ /* TODO(BinaryExpression): targetStartText.length + targetEndText.length */ TODO || !sourceStartText.startsWith(targetStartText) || !sourceEndText.endsWith(targetEndText) {
			return nil
		}
		remainingEndText := sourceEndText.slice(0 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceEndText.length - targetEndText.length */, TODO)
		var matches []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		seg := 0
		pos := targetStartText.length
		/* TODO(ForStatement): for (let i = 1; i < lastTargetIndex; i++) {             const delim = targetTexts[i];             if (delim.length > 0) {                 let s = seg;                 let p = pos;                 while (true) {                     p = getSourceText(s).indexOf(delim, p);                     if (p >= 0) break;                     s++;                     if (s === sourceTexts.length) return undefined;                     p = 0;                 }                 addMatch(s, p);                 pos += delim.length;             }             else if (pos < getSourceText(seg).length) {                 addMatch(seg, pos + 1);             }             else if (seg < lastSourceIndex) {                 addMatch(seg + 1, 0);             }             else {                 return undefined;             }         } */
		addMatch(lastSourceIndex, getSourceText(lastSourceIndex).length)
		return matches
		getSourceText := func(index number) /* TODO inferred type string */ TODO {
			return /* TODO(ConditionalExpression): index < lastSourceIndex ? sourceTexts[index] : remainingEndText */ TODO
		}
		addMatch := func(s number, p number) {
			matchType := /* TODO(ConditionalExpression): s === seg ?                 getStringLiteralType(getSourceText(s).slice(pos, p)) :                 getTemplateLiteralType(                     [sourceTexts[seg].slice(pos), ...sourceTexts.slice(seg + 1, s), getSourceText(s).slice(0, p)],                     sourceTypes.slice(seg, s),                 ) */ TODO
			matches.push(matchType)
			seg = s
			pos = p
		}
	}
	isTupleOfSelf := func(typeParameter TypeParameter, type_ Type) /* TODO inferred type boolean */ TODO {
		return isTupleType(type_) && getTupleElementType(type_, 0) == getIndexedAccessType(typeParameter, getNumberLiteralType(0)) && !getTypeOfPropertyOfType(type_, "1")
	}
	inferTypes := func(inferences []InferenceInfo, originalSource Type, originalTarget Type, priority /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferencePriority */ TODO /*  = InferencePriority.None */, contravariant /* TODO inferred type boolean */ TODO /*  = false */) {
		bivariant := false
		var propagationType Type
		var inferencePriority number = InferencePriorityMaxValue
		var visited Map[string, number]
		var sourceStack []Type
		var targetStack []Type
		expandingFlags := ExpandingFlagsNone
		inferFromTypes(originalSource, originalTarget)
		inferFromTypes := func(source Type, target Type) {
			if !couldContainTypeVariables(target) || isNoInferType(target) {
				return
			}
			if source == wildcardType || source == blockedStringType {
				savePropagationType := propagationType
				propagationType = source
				inferFromTypes(target, target)
				propagationType = savePropagationType
				return
			}
			if source.aliasSymbol && source.aliasSymbol == target.aliasSymbol {
				if source.aliasTypeArguments {
					params := getSymbolLinks(source.aliasSymbol).typeParameters
					minParams := getMinTypeArgumentCount(params)
					sourceTypes := fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
					targetTypes := fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
					inferFromTypeArguments(sourceTypes, targetTypes, getAliasVariances(source.aliasSymbol))
				}
				return
			}
			if source == target && source.flags&TypeFlagsUnionOrIntersection {
				for _, t := range (source).types {
					inferFromTypes(t, t)
				}
				return
			}
			if target.flags & TypeFlagsUnion {
				TODO_IDENTIFIER := inferFromMatchingTypes( /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? (source as UnionType).types : [source] */ TODO, (target).types, isTypeOrBaseIdenticalTo)
				TODO_IDENTIFIER := inferFromMatchingTypes(tempSources, tempTargets, isTypeCloselyMatchedBy)
				if targets.length == 0 {
					return
				}
				target = getUnionType(targets)
				if sources.length == 0 {
					inferWithPriority(source, target, InferencePriorityNakedTypeVariable)
					return
				}
				source = getUnionType(sources)
			} else if target.flags&TypeFlagsIntersection && !every((target).types, isNonGenericObjectType) {
				if !(source.flags & TypeFlagsUnion) {
					TODO_IDENTIFIER := inferFromMatchingTypes( /* TODO(ConditionalExpression): source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source] */ TODO, (target).types, isTypeIdenticalTo)
					if sources.length == 0 || targets.length == 0 {
						return
					}
					source = getIntersectionType(sources)
					target = getIntersectionType(targets)
				}
			}
			if target.flags & (TypeFlagsIndexedAccess | TypeFlagsSubstitution) {
				if isNoInferType(target) {
					return
				}
				target = getActualTypeVariable(target)
			}
			if target.flags & TypeFlagsTypeVariable {
				if isFromInferenceBlockedSource(source) {
					return
				}
				inference := getInferenceInfoForType(target)
				if inference {
					if getObjectFlags(source)&ObjectFlagsNonInferrableType || source == nonInferrableAnyType {
						return
					}
					if !inference.isFixed {
						candidate := propagationType || source
						if candidate == blockedStringType {
							return
						}
						if inference.priority == nil || priority < inference.priority {
							inference.candidates = nil
							inference.contraCandidates = nil
							inference.topLevel = true
							inference.priority = priority
						}
						if priority == inference.priority {
							if isTupleOfSelf(inference.typeParameter, candidate) {
								return
							}
							if contravariant && !bivariant {
								if !contains(inference.contraCandidates, candidate) {
									inference.contraCandidates = append(inference.contraCandidates, candidate)
									clearCachedInferences(inferences)
								}
							} else if !contains(inference.candidates, candidate) {
								inference.candidates = append(inference.candidates, candidate)
								clearCachedInferences(inferences)
							}
						}
						if !(priority & InferencePriorityReturnType) && target.flags&TypeFlagsTypeParameter && inference.topLevel && !isTypeParameterAtTopLevel(originalTarget, target) {
							inference.topLevel = false
							clearCachedInferences(inferences)
						}
					}
					inferencePriority = Math.min(inferencePriority, priority)
					return
				}
				simplified := getSimplifiedType(target, false)
				if simplified != target {
					inferFromTypes(source, simplified)
				} else if target.flags & TypeFlagsIndexedAccess {
					indexType := getSimplifiedType((target).indexType, false)
					if indexType.flags & TypeFlagsInstantiable {
						simplified := distributeIndexOverObjectType(getSimplifiedType((target).objectType, false), indexType, false)
						if simplified && simplified != target {
							inferFromTypes(source, simplified)
						}
					}
				}
			}
			if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && ((source).target == (target).target || isArrayType(source) && isArrayType(target)) && !((source).node && (target).node) {
				inferFromTypeArguments(getTypeArguments(source), getTypeArguments(target), getVariances((source).target))
			} else if source.flags&TypeFlagsIndex && target.flags&TypeFlagsIndex {
				inferFromContravariantTypes((source).type_, (target).type_)
			} else if (isLiteralType(source) || source.flags&TypeFlagsString) && target.flags&TypeFlagsIndex {
				empty := createEmptyObjectTypeFromStringLiteral(source)
				inferFromContravariantTypesWithPriority(empty, (target).type_, InferencePriorityLiteralKeyof)
			} else if source.flags&TypeFlagsIndexedAccess && target.flags&TypeFlagsIndexedAccess {
				inferFromTypes((source).objectType, (target).objectType)
				inferFromTypes((source).indexType, (target).indexType)
			} else if source.flags&TypeFlagsStringMapping && target.flags&TypeFlagsStringMapping {
				if (source).symbol == (target).symbol {
					inferFromTypes((source).type_, (target).type_)
				}
			} else if source.flags & TypeFlagsSubstitution {
				inferFromTypes((source).baseType, target)
				inferWithPriority(getSubstitutionIntersection(source), target, InferencePrioritySubstituteSource)
			} else if target.flags & TypeFlagsConditional {
				invokeOnce(source, target, inferToConditionalType)
			} else if target.flags & TypeFlagsUnionOrIntersection {
				inferToMultipleTypes(source, (target).types, target.flags)
			} else if source.flags & TypeFlagsUnion {
				sourceTypes := (source).types
				for _, sourceType := range sourceTypes {
					inferFromTypes(sourceType, target)
				}
			} else if target.flags & TypeFlagsTemplateLiteral {
				inferToTemplateLiteralType(source, target)
			} else {
				source = getReducedType(source)
				if isGenericMappedType(source) && isGenericMappedType(target) {
					invokeOnce(source, target, inferFromGenericMappedTypes)
				}
				if !(priority&InferencePriorityNoConstraints && source.flags&(TypeFlagsIntersection|TypeFlagsInstantiable)) {
					apparentSource := getApparentType(source)
					if apparentSource != source && !(apparentSource.flags & (TypeFlagsObject | TypeFlagsIntersection)) {
						return inferFromTypes(apparentSource, target)
					}
					source = apparentSource
				}
				if source.flags & (TypeFlagsObject | TypeFlagsIntersection) {
					invokeOnce(source, target, inferFromObjectTypes)
				}
			}
		}
		inferWithPriority := func(source Type, target Type, newPriority InferencePriority) {
			savePriority := priority
			priority |= newPriority
			inferFromTypes(source, target)
			priority = savePriority
		}
		inferFromContravariantTypesWithPriority := func(source Type, target Type, newPriority InferencePriority) {
			savePriority := priority
			priority |= newPriority
			inferFromContravariantTypes(source, target)
			priority = savePriority
		}
		inferToMultipleTypesWithPriority := func(source Type, targets []Type, targetFlags TypeFlags, newPriority InferencePriority) {
			savePriority := priority
			priority |= newPriority
			inferToMultipleTypes(source, targets, targetFlags)
			priority = savePriority
		}
		invokeOnce := func(source Source, target Target, action func(source Source, target Target)) {
			key := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): source.id + "," + target.id */ TODO
			status := visited && visited.get(key)
			if status != nil {
				inferencePriority = Math.min(inferencePriority, status)
				return
			}
			(visited || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): visited = new Map<string, number>() */ TODO)).set(key, InferencePriorityCircularity)
			saveInferencePriority := inferencePriority
			inferencePriority = InferencePriorityMaxValue
			saveExpandingFlags := expandingFlags
			( /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): sourceStack ??= [] */ TODO).push(source)
			( /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): targetStack ??= [] */ TODO).push(target)
			if isDeeplyNestedType(source, sourceStack, sourceStack.length, 2) {
				expandingFlags |= ExpandingFlagsSource
			}
			if isDeeplyNestedType(target, targetStack, targetStack.length, 2) {
				expandingFlags |= ExpandingFlagsTarget
			}
			if expandingFlags != ExpandingFlagsBoth {
				action(source, target)
			} else {
				inferencePriority = InferencePriorityCircularity
			}
			targetStack.pop()
			sourceStack.pop()
			expandingFlags = saveExpandingFlags
			visited.set(key, inferencePriority)
			inferencePriority = Math.min(inferencePriority, saveInferencePriority)
		}
		inferFromMatchingTypes := func(sources []Type, targets []Type, matches func(s Type, t Type) bool) /* TODO(TupleType): [Type[], Type[]] */ any {
			var matchedSources /* TODO(ArrayType): Type[] */ any
			var matchedTargets /* TODO(ArrayType): Type[] */ any
			for _, t := range targets {
				for _, s := range sources {
					if matches(s, t) {
						inferFromTypes(s, t)
						matchedSources = appendIfUnique(matchedSources, s)
						matchedTargets = appendIfUnique(matchedTargets, t)
					}
				}
			}
			return /* TODO(ArrayLiteralExpression): [                 matchedSources ? filter(sources, t => !contains(matchedSources, t)) : sources,                 matchedTargets ? filter(targets, t => !contains(matchedTargets, t)) : targets,             ] */ TODO
		}
		inferFromTypeArguments := func(sourceTypes []Type, targetTypes []Type, variances []VarianceFlags) {
			count := /* TODO(ConditionalExpression): sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length */ TODO
			/* TODO(ForStatement): for (let i = 0; i < count; i++) {                 if (i < variances.length && (variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Contravariant) {                     inferFromContravariantTypes(sourceTypes[i], targetTypes[i]);                 }                 else {                     inferFromTypes(sourceTypes[i], targetTypes[i]);                 }             } */
		}
		inferFromContravariantTypes := func(source Type, target Type) {
			contravariant = !contravariant
			inferFromTypes(source, target)
			contravariant = !contravariant
		}
		inferFromContravariantTypesIfStrictFunctionTypes := func(source Type, target Type) {
			if strictFunctionTypes || priority&InferencePriorityAlwaysStrict {
				inferFromContravariantTypes(source, target)
			} else {
				inferFromTypes(source, target)
			}
		}
		getInferenceInfoForType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo | undefined */ TODO {
			if type_.flags & TypeFlagsTypeVariable {
				for _, inference := range inferences {
					if type_ == inference.typeParameter {
						return inference
					}
				}
			}
			return nil
		}
		getSingleTypeVariableFromIntersectionTypes := func(types []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			var typeVariable *Type
			for _, type_ := range types {
				t := type_.flags&TypeFlagsIntersection && find((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !!getInferenceInfoForType(t)
				})
				if !t || typeVariable && t != typeVariable {
					return nil
				}
				typeVariable = t
			}
			return typeVariable
		}
		inferToMultipleTypes := func(source Type, targets []Type, targetFlags TypeFlags) {
			typeVariableCount := 0
			if targetFlags & TypeFlagsUnion {
				var nakedTypeVariable *Type
				sources := /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? (source as UnionType).types : [source] */ TODO
				matched := /* TODO(NewExpression): new Array<boolean>(sources.length) */ TODO
				inferenceCircularity := false
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						nakedTypeVariable = t
						typeVariableCount++
					} else {
						/* TODO(ForStatement): for (let i = 0; i < sources.length; i++) {                             const saveInferencePriority = inferencePriority;                             inferencePriority = InferencePriority.MaxValue;                             inferFromTypes(sources[i], t);                             if (inferencePriority === priority) matched[i] = true;                             inferenceCircularity = inferenceCircularity || inferencePriority === InferencePriority.Circularity;                             inferencePriority = Math.min(inferencePriority, saveInferencePriority);                         } */
					}
				}
				if typeVariableCount == 0 {
					intersectionTypeVariable := getSingleTypeVariableFromIntersectionTypes(targets)
					if intersectionTypeVariable {
						inferWithPriority(source, intersectionTypeVariable, InferencePriorityNakedTypeVariable)
					}
					return
				}
				if typeVariableCount == 1 && !inferenceCircularity {
					unmatched := flatMap(sources, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
						return /* TODO(ConditionalExpression): matched[i] ? undefined : s */ TODO
					})
					if unmatched.length {
						inferFromTypes(getUnionType(unmatched), nakedTypeVariable)
						return
					}
				}
			} else {
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						typeVariableCount++
					} else {
						inferFromTypes(source, t)
					}
				}
			}
			if /* TODO(ConditionalExpression): targetFlags & TypeFlags.Intersection ? typeVariableCount === 1 : typeVariableCount > 0 */ TODO {
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						inferWithPriority(source, t, InferencePriorityNakedTypeVariable)
					}
				}
			}
		}
		inferToMappedType := func(source Type, target MappedType, constraintType Type) bool {
			if (constraintType.flags & TypeFlagsUnion) || (constraintType.flags & TypeFlagsIntersection) {
				result := false
				for _, type_ := range (constraintType).types {
					result = inferToMappedType(source, target, type_) || result
				}
				return result
			}
			if constraintType.flags & TypeFlagsIndex {
				inference := getInferenceInfoForType((constraintType).type_)
				if inference && !inference.isFixed && !isFromInferenceBlockedSource(source) {
					inferredType := inferTypeForHomomorphicMappedType(source, target, constraintType)
					if inferredType {
						inferWithPriority(inferredType, inference.typeParameter /* TODO(ConditionalExpression): getObjectFlags(source) & ObjectFlags.NonInferrableType ?                                 InferencePriority.PartialHomomorphicMappedType :                                 InferencePriority.HomomorphicMappedType */, TODO)
					}
				}
				return true
			}
			if constraintType.flags & TypeFlagsTypeParameter {
				inferWithPriority(getIndexType(source /* TODO(ConditionalExpression): !!source.pattern ? IndexFlags.NoIndexSignatures : IndexFlags.None */, TODO), constraintType, InferencePriorityMappedTypeConstraint)
				extendedConstraint := getConstraintOfType(constraintType)
				if extendedConstraint && inferToMappedType(source, target, extendedConstraint) {
					return true
				}
				propTypes := map_(getPropertiesOfType(source), getTypeOfSymbol)
				indexTypes := map_(getIndexInfosOfType(source), func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					return /* TODO(ConditionalExpression): info !== enumNumberIndexInfo ? info.type : neverType */ TODO
				})
				inferFromTypes(getUnionType(concatenate(propTypes, indexTypes)), getTemplateTypeFromMappedType(target))
				return true
			}
			return false
		}
		inferToConditionalType := func(source Type, target ConditionalType) {
			if source.flags & TypeFlagsConditional {
				inferFromTypes((source).checkType, target.checkType)
				inferFromTypes((source).extendsType, target.extendsType)
				inferFromTypes(getTrueTypeFromConditionalType(source), getTrueTypeFromConditionalType(target))
				inferFromTypes(getFalseTypeFromConditionalType(source), getFalseTypeFromConditionalType(target))
			} else {
				targetTypes := /* TODO(ArrayLiteralExpression): [getTrueTypeFromConditionalType(target), getFalseTypeFromConditionalType(target)] */ TODO
				inferToMultipleTypesWithPriority(source, targetTypes, target.flags /* TODO(ConditionalExpression): contravariant ? InferencePriority.ContravariantConditional : 0 */, TODO)
			}
		}
		inferToTemplateLiteralType := func(source Type, target TemplateLiteralType) {
			matches := inferTypesFromTemplateLiteralType(source, target)
			types := target.types
			if matches || every(target.texts, func(s /* TODO inferred type string */ TODO) /* TODO inferred type boolean */ TODO {
				return s.length == 0
			}) {
				/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                     const source = matches ? matches[i] : neverType;                     const target = types[i];                      // If we are inferring from a string literal type to a type variable whose constraint includes one of the                     // allowed template literal placeholder types, infer from a literal type corresponding to the constraint.                     if (source.flags & TypeFlags.StringLiteral && target.flags & TypeFlags.TypeVariable) {                         const inferenceContext = getInferenceInfoForType(target);                         const constraint = inferenceContext ? getBaseConstraintOfType(inferenceContext.typeParameter) : undefined;                         if (constraint && !isTypeAny(constraint)) {                             const constraintTypes = constraint.flags & TypeFlags.Union ? (constraint as UnionType).types : [constraint];                             let allTypeFlags: TypeFlags = reduceLeft(constraintTypes, (flags, t) => flags | t.flags, 0 as TypeFlags);                              // If the constraint contains `string`, we don't need to look for a more preferred type                             if (!(allTypeFlags & TypeFlags.String)) {                                 const str = (source as StringLiteralType).value;                                  // If the type contains `number` or a number literal and the string isn't a valid number, exclude numbers                                 if (allTypeFlags & TypeFlags.NumberLike && !isValidNumberString(str, /*roundTripOnly* / true)) {                                     allTypeFlags &= ~TypeFlags.NumberLike;                                 }                                  // If the type contains `bigint` or a bigint literal and the string isn't a valid bigint, exclude bigints                                 if (allTypeFlags & TypeFlags.BigIntLike && !isValidBigIntString(str, /*roundTripOnly* / true)) {                                     allTypeFlags &= ~TypeFlags.BigIntLike;                                 }                                  // for each type in the constraint, find the highest priority matching type                                 const matchingType = reduceLeft(constraintTypes, (left, right) =>                                     !(right.flags & allTypeFlags) ? left :                                         left.flags & TypeFlags.String ? left : right.flags & TypeFlags.String ? source :                                         left.flags & TypeFlags.TemplateLiteral ? left : right.flags & TypeFlags.TemplateLiteral && isTypeMatchedByTemplateLiteralType(source, right as TemplateLiteralType) ? source :                                         left.flags & TypeFlags.StringMapping ? left : right.flags & TypeFlags.StringMapping && str === applyStringMapping(right.symbol, str) ? source :                                         left.flags & TypeFlags.StringLiteral ? left : right.flags & TypeFlags.StringLiteral && (right as StringLiteralType).value === str ? right :                                         left.flags & TypeFlags.Number ? left : right.flags & TypeFlags.Number ? getNumberLiteralType(+str) :                                         left.flags & TypeFlags.Enum ? left : right.flags & TypeFlags.Enum ? getNumberLiteralType(+str) :                                         left.flags & TypeFlags.NumberLiteral ? left : right.flags & TypeFlags.NumberLiteral && (right as NumberLiteralType).value === +str ? right :                                         left.flags & TypeFlags.BigInt ? left : right.flags & TypeFlags.BigInt ? parseBigIntLiteralType(str) :                                         left.flags & TypeFlags.BigIntLiteral ? left : right.flags & TypeFlags.BigIntLiteral && pseudoBigIntToString((right as BigIntLiteralType).value) === str ? right :                                         left.flags & TypeFlags.Boolean ? left : right.flags & TypeFlags.Boolean ? str === "true" ? trueType : str === "false" ? falseType : booleanType :                                         left.flags & TypeFlags.BooleanLiteral ? left : right.flags & TypeFlags.BooleanLiteral && (right as IntrinsicType).intrinsicName === str ? right :                                         left.flags & TypeFlags.Undefined ? left : right.flags & TypeFlags.Undefined && (right as IntrinsicType).intrinsicName === str ? right :                                         left.flags & TypeFlags.Null ? left : right.flags & TypeFlags.Null && (right as IntrinsicType).intrinsicName === str ? right :                                         left, neverType as Type);                                  if (!(matchingType.flags & TypeFlags.Never)) {                                     inferFromTypes(matchingType, target);                                     continue;                                 }                             }                         }                     }                      inferFromTypes(source, target);                 } */
			}
		}
		inferFromGenericMappedTypes := func(source MappedType, target MappedType) {
			inferFromTypes(getConstraintTypeFromMappedType(source), getConstraintTypeFromMappedType(target))
			inferFromTypes(getTemplateTypeFromMappedType(source), getTemplateTypeFromMappedType(target))
			sourceNameType := getNameTypeFromMappedType(source)
			targetNameType := getNameTypeFromMappedType(target)
			if sourceNameType && targetNameType {
				inferFromTypes(sourceNameType, targetNameType)
			}
		}
		inferFromObjectTypes := func(source Type, target Type) {
			if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && ((source).target == (target).target || isArrayType(source) && isArrayType(target)) {
				inferFromTypeArguments(getTypeArguments(source), getTypeArguments(target), getVariances((source).target))
				return
			}
			if isGenericMappedType(source) && isGenericMappedType(target) {
				inferFromGenericMappedTypes(source, target)
			}
			if getObjectFlags(target)&ObjectFlagsMapped && !(target).declaration.nameType {
				constraintType := getConstraintTypeFromMappedType(target)
				if inferToMappedType(source, target, constraintType) {
					return
				}
			}
			if !typesDefinitelyUnrelated(source, target) {
				if isArrayOrTupleType(source) {
					if isTupleType(target) {
						sourceArity := getTypeReferenceArity(source)
						targetArity := getTypeReferenceArity(target)
						elementTypes := getTypeArguments(target)
						elementFlags := target.target.elementFlags
						if isTupleType(source) && isTupleTypeStructureMatching(source, target) {
							/* TODO(ForStatement): for (let i = 0; i < targetArity; i++) {                                 inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);                             } */
							return
						}
						startLength := /* TODO(ConditionalExpression): isTupleType(source) ? Math.min(source.target.fixedLength, target.target.fixedLength) : 0 */ TODO
						endLength := Math.min( /* TODO(ConditionalExpression): isTupleType(source) ? getEndElementCount(source.target, ElementFlags.Fixed) : 0 */ TODO /* TODO(ConditionalExpression): target.target.combinedFlags & ElementFlags.Variable ? getEndElementCount(target.target, ElementFlags.Fixed) : 0 */, TODO)
						/* TODO(ForStatement): for (let i = 0; i < startLength; i++) {                             inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);                         } */
						if !isTupleType(source) || /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceArity - startLength - endLength */ TODO == 1 && /* TODO(ElementAccessExpression): source.target.elementFlags[startLength] */ TODO&ElementFlagsRest {
							restType := /* TODO(ElementAccessExpression): getTypeArguments(source)[startLength] */ TODO
							/* TODO(ForStatement): for (let i = startLength; i < targetArity - endLength; i++) {                                 inferFromTypes(elementFlags[i] & ElementFlags.Variadic ? createArrayType(restType) : restType, elementTypes[i]);                             } */
						} else {
							middleLength := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): targetArity - startLength - endLength */ TODO
							if middleLength == 2 {
								if /* TODO(ElementAccessExpression): elementFlags[startLength] */ TODO & /* TODO(ElementAccessExpression): elementFlags[startLength + 1] */ TODO & ElementFlagsVariadic {
									targetInfo := getInferenceInfoForType( /* TODO(ElementAccessExpression): elementTypes[startLength] */ TODO)
									if targetInfo && targetInfo.impliedArity != nil {
										inferFromTypes(sliceTupleType(source, startLength /* TODO(MinusToken): - */ /* TODO(BinaryExpression): endLength + sourceArity - targetInfo.impliedArity */, TODO) /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO)
										inferFromTypes(sliceTupleType(source /* TODO(PlusToken): + */ /* TODO(BinaryExpression): startLength + targetInfo.impliedArity */, TODO, endLength) /* TODO(ElementAccessExpression): elementTypes[startLength + 1] */, TODO)
									}
								} else if /* TODO(ElementAccessExpression): elementFlags[startLength] */ TODO&ElementFlagsVariadic && /* TODO(ElementAccessExpression): elementFlags[startLength + 1] */ TODO&ElementFlagsRest {
									param := getInferenceInfoForType( /* TODO(ElementAccessExpression): elementTypes[startLength] */ TODO).typeParameter
									constraint := param && getBaseConstraintOfType(param)
									if constraint && isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlagsVariable) {
										impliedArity := constraint.target.fixedLength
										inferFromTypes(sliceTupleType(source, startLength /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceArity - (startLength + impliedArity) */, TODO) /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO)
										inferFromTypes(getElementTypeOfSliceOfTupleType(source /* TODO(PlusToken): + */ /* TODO(BinaryExpression): startLength + impliedArity */, TODO, endLength) /* TODO(ElementAccessExpression): elementTypes[startLength + 1] */, TODO)
									}
								} else if /* TODO(ElementAccessExpression): elementFlags[startLength] */ TODO&ElementFlagsRest && /* TODO(ElementAccessExpression): elementFlags[startLength + 1] */ TODO&ElementFlagsVariadic {
									param := getInferenceInfoForType( /* TODO(ElementAccessExpression): elementTypes[startLength + 1] */ TODO).typeParameter
									constraint := param && getBaseConstraintOfType(param)
									if constraint && isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlagsVariable) {
										impliedArity := constraint.target.fixedLength
										endIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceArity - getEndElementCount(target.target, ElementFlags.Fixed) */ TODO
										startIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): endIndex - impliedArity */ TODO
										trailingSlice := createTupleType(getTypeArguments(source).slice(startIndex, endIndex), source.target.elementFlags.slice(startIndex, endIndex), false, source.target.labeledElementDeclarations && source.target.labeledElementDeclarations.slice(startIndex, endIndex))
										inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength /* TODO(PlusToken): + */ /* TODO(BinaryExpression): endLength + impliedArity */, TODO) /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO)
										inferFromTypes(trailingSlice /* TODO(ElementAccessExpression): elementTypes[startLength + 1] */, TODO)
									}
								}
							} else if middleLength == 1 && /* TODO(ElementAccessExpression): elementFlags[startLength] */ TODO&ElementFlagsVariadic {
								endsInOptional := /* TODO(ElementAccessExpression): target.target.elementFlags[targetArity - 1] */ TODO & ElementFlagsOptional
								sourceSlice := sliceTupleType(source, startLength, endLength)
								inferWithPriority(sourceSlice /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO /* TODO(ConditionalExpression): endsInOptional ? InferencePriority.SpeculativeTuple : 0 */, TODO)
							} else if middleLength == 1 && /* TODO(ElementAccessExpression): elementFlags[startLength] */ TODO&ElementFlagsRest {
								restType := getElementTypeOfSliceOfTupleType(source, startLength, endLength)
								if restType {
									inferFromTypes(restType /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO)
								}
							}
						}
						/* TODO(ForStatement): for (let i = 0; i < endLength; i++) {                             inferFromTypes(getTypeArguments(source)[sourceArity - i - 1], elementTypes[targetArity - i - 1]);                         } */
						return
					}
					if isArrayType(target) {
						inferFromIndexTypes(source, target)
						return
					}
				}
				inferFromProperties(source, target)
				inferFromSignatures(source, target, SignatureKindCall)
				inferFromSignatures(source, target, SignatureKindConstruct)
				inferFromIndexTypes(source, target)
			}
		}
		inferFromProperties := func(source Type, target Type) {
			properties := getPropertiesOfObjectType(target)
			for _, targetProp := range properties {
				sourceProp := getPropertyOfType(source, targetProp.escapedName)
				if sourceProp && !some(sourceProp.declarations, hasSkipDirectInferenceFlag) {
					inferFromTypes(removeMissingType(getTypeOfSymbol(sourceProp), !!(sourceProp.flags&SymbolFlagsOptional)), removeMissingType(getTypeOfSymbol(targetProp), !!(targetProp.flags&SymbolFlagsOptional)))
				}
			}
		}
		inferFromSignatures := func(source Type, target Type, kind SignatureKind) {
			sourceSignatures := getSignaturesOfType(source, kind)
			sourceLen := sourceSignatures.length
			if sourceLen > 0 {
				targetSignatures := getSignaturesOfType(target, kind)
				targetLen := targetSignatures.length
				/* TODO(ForStatement): for (let i = 0; i < targetLen; i++) {                     const sourceIndex = Math.max(sourceLen - targetLen + i, 0);                     inferFromSignature(getBaseSignature(sourceSignatures[sourceIndex]), getErasedSignature(targetSignatures[i]));                 } */
			}
		}
		inferFromSignature := func(source Signature, target Signature) {
			if !(source.flags & SignatureFlagsIsNonInferrable) {
				saveBivariant := bivariant
				kind := /* TODO(ConditionalExpression): target.declaration ? target.declaration.kind : SyntaxKind.Unknown */ TODO
				bivariant = bivariant || kind == SyntaxKindMethodDeclaration || kind == SyntaxKindMethodSignature || kind == SyntaxKindConstructor
				applyToParameterTypes(source, target, inferFromContravariantTypesIfStrictFunctionTypes)
				bivariant = saveBivariant
			}
			applyToReturnTypes(source, target, inferFromTypes)
		}
		inferFromIndexTypes := func(source Type, target Type) {
			priority := /* TODO(ConditionalExpression): (getObjectFlags(source) & getObjectFlags(target) & ObjectFlags.Mapped) ? InferencePriority.HomomorphicMappedType : 0 */ TODO
			indexInfos := getIndexInfosOfType(target)
			if isObjectTypeWithInferableIndex(source) {
				for _, targetInfo := range indexInfos {
					var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
					for _, prop := range getPropertiesOfType(source) {
						if isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique), targetInfo.keyType) {
							propType := getTypeOfSymbol(prop)
							propTypes.push( /* TODO(ConditionalExpression): prop.flags & SymbolFlags.Optional ? removeMissingOrUndefinedType(propType) : propType */ TODO)
						}
					}
					for _, info := range getIndexInfosOfType(source) {
						if isApplicableIndexType(info.keyType, targetInfo.keyType) {
							propTypes.push(info.type_)
						}
					}
					if propTypes.length {
						inferWithPriority(getUnionType(propTypes), targetInfo.type_, priority)
					}
				}
			}
			for _, targetInfo := range indexInfos {
				sourceInfo := getApplicableIndexInfo(source, targetInfo.keyType)
				if sourceInfo {
					inferWithPriority(sourceInfo.type_, targetInfo.type_, priority)
				}
			}
		}
	}
	isTypeOrBaseIdenticalTo := func(s Type, t Type) /* TODO inferred type boolean */ TODO {
		return /* TODO(ConditionalExpression): t === missingType ? s === t :             (isTypeIdenticalTo(s, t) || !!(t.flags & TypeFlags.String && s.flags & TypeFlags.StringLiteral || t.flags & TypeFlags.Number && s.flags & TypeFlags.NumberLiteral)) */ TODO
	}
	isTypeCloselyMatchedBy := func(s Type, t Type) /* TODO inferred type boolean */ TODO {
		return !!(s.flags&TypeFlagsObject && t.flags&TypeFlagsObject && s.symbol && s.symbol == t.symbol || s.aliasSymbol && s.aliasTypeArguments && s.aliasSymbol == t.aliasSymbol)
	}
	hasPrimitiveConstraint := func(type_ TypeParameter) bool {
		constraint := getConstraintOfTypeParameter(type_)
		return !!constraint && maybeTypeOfKind( /* TODO(ConditionalExpression): constraint.flags & TypeFlags.Conditional ? getDefaultConstraintOfConditionalType(constraint as ConditionalType) : constraint */ TODO, TypeFlagsPrimitive|TypeFlagsIndex|TypeFlagsTemplateLiteral|TypeFlagsStringMapping)
	}
	isObjectLiteralType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(getObjectFlags(type_) & ObjectFlagsObjectLiteral)
	}
	isObjectOrArrayLiteralType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return !!(getObjectFlags(type_) & (ObjectFlagsObjectLiteral | ObjectFlagsArrayLiteral))
	}
	unionObjectAndArrayLiteralCandidates := func(candidates []Type) []Type {
		if candidates.length > 1 {
			objectLiterals := filter(candidates, isObjectOrArrayLiteralType)
			if objectLiterals.length {
				literalsType := getUnionType(objectLiterals, UnionReductionSubtype)
				return concatenate(filter(candidates, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !isObjectOrArrayLiteralType(t)
				}), /* TODO(ArrayLiteralExpression): [literalsType] */ TODO)
			}
		}
		return candidates
	}
	getContravariantInference := func(inference InferenceInfo) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): inference.priority! & InferencePriority.PriorityImpliesCombination ? getIntersectionType(inference.contraCandidates!) : getCommonSubtype(inference.contraCandidates!) */ TODO
	}
	getCovariantInference := func(inference InferenceInfo, signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		candidates := unionObjectAndArrayLiteralCandidates(inference.candidates)
		primitiveConstraint := hasPrimitiveConstraint(inference.typeParameter) || isConstTypeVariable(inference.typeParameter)
		widenLiteralTypes := !primitiveConstraint && inference.topLevel && (inference.isFixed || !isTypeParameterAtTopLevelInReturnType(signature, inference.typeParameter))
		baseCandidates := /* TODO(ConditionalExpression): primitiveConstraint ? sameMap(candidates, getRegularTypeOfLiteralType) :             widenLiteralTypes ? sameMap(candidates, getWidenedLiteralType) :             candidates */ TODO
		unwidenedType := /* TODO(ConditionalExpression): inference.priority! & InferencePriority.PriorityImpliesCombination ?             getUnionType(baseCandidates, UnionReduction.Subtype) :             getCommonSupertype(baseCandidates) */ TODO
		return getWidenedType(unwidenedType)
	}
	getInferredType := func(context InferenceContext, index number) Type {
		inference := /* TODO(ElementAccessExpression): context.inferences[index] */ TODO
		if !inference.inferredType {
			var inferredType *Type
			var fallbackType *Type
			if context.signature {
				inferredCovariantType := /* TODO(ConditionalExpression): inference.candidates ? getCovariantInference(inference, context.signature) : undefined */ TODO
				inferredContravariantType := /* TODO(ConditionalExpression): inference.contraCandidates ? getContravariantInference(inference) : undefined */ TODO
				if inferredCovariantType || inferredContravariantType {
					preferCovariantType := inferredCovariantType && (!inferredContravariantType || !(inferredCovariantType.flags&(TypeFlagsNever|TypeFlagsAny)) && some(inference.contraCandidates, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
						return isTypeAssignableTo(inferredCovariantType, t)
					}) && every(context.inferences, func(other /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO) /* TODO inferred type boolean */ TODO {
						return other != inference && getConstraintOfTypeParameter(other.typeParameter) != inference.typeParameter || every(other.candidates, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
							return isTypeAssignableTo(t, inferredCovariantType)
						})
					}))
					inferredType = /* TODO(ConditionalExpression): preferCovariantType ? inferredCovariantType : inferredContravariantType */ TODO
					fallbackType = /* TODO(ConditionalExpression): preferCovariantType ? inferredContravariantType : inferredCovariantType */ TODO
				} else if context.flags & InferenceFlagsNoDefault {
					inferredType = silentNeverType
				} else {
					defaultType := getDefaultFromTypeParameter(inference.typeParameter)
					if defaultType {
						inferredType = instantiateType(defaultType, mergeTypeMappers(createBackreferenceMapper(context, index), context.nonFixingMapper))
					}
				}
			} else {
				inferredType = getTypeFromInference(inference)
			}
			inference.inferredType = inferredType || getDefaultTypeArgumentType(!!(context.flags & InferenceFlagsAnyDefault))
			constraint := getConstraintOfTypeParameter(inference.typeParameter)
			if constraint {
				instantiatedConstraint := instantiateType(constraint, context.nonFixingMapper)
				if !inferredType || !context.compareTypes(inferredType, getTypeWithThisArgument(instantiatedConstraint, inferredType)) {
					inference.inferredType = /* TODO(ConditionalExpression): fallbackType && context.compareTypes(fallbackType, getTypeWithThisArgument(instantiatedConstraint, fallbackType)) ? fallbackType : instantiatedConstraint */ TODO
				}
			}
		}
		return inference.inferredType
	}
	getDefaultTypeArgumentType := func(isInJavaScriptFile bool) Type {
		return /* TODO(ConditionalExpression): isInJavaScriptFile ? anyType : unknownType */ TODO
	}
	getInferredTypes := func(context InferenceContext) []Type {
		var result []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < context.inferences.length; i++) {             result.push(getInferredType(context, i));         } */
		return result
	}
	getCannotFindNameDiagnosticForName := func(node Identifier) DiagnosticMessage {
		switch node.escapedText {
		case "document":
			fallthrough // TODO: merge cases
		case "console":
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom
		case "$":
			return /* TODO(ConditionalExpression): compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery */ TODO
		case "describe":
			fallthrough // TODO: merge cases
		case "suite":
			fallthrough // TODO: merge cases
		case "it":
			fallthrough // TODO: merge cases
		case "test":
			return /* TODO(ConditionalExpression): compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha */ TODO
		case "process":
			fallthrough // TODO: merge cases
		case "require":
			fallthrough // TODO: merge cases
		case "Buffer":
			fallthrough // TODO: merge cases
		case "module":
			return /* TODO(ConditionalExpression): compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode */ TODO
		case "Bun":
			return /* TODO(ConditionalExpression): compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun_and_then_add_bun_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun */ TODO
		case "Map":
			fallthrough // TODO: merge cases
		case "Set":
			fallthrough // TODO: merge cases
		case "Promise":
			fallthrough // TODO: merge cases
		case "Symbol":
			fallthrough // TODO: merge cases
		case "WeakMap":
			fallthrough // TODO: merge cases
		case "WeakSet":
			fallthrough // TODO: merge cases
		case "Iterator":
			fallthrough // TODO: merge cases
		case "AsyncIterator":
			fallthrough // TODO: merge cases
		case "SharedArrayBuffer":
			fallthrough // TODO: merge cases
		case "Atomics":
			fallthrough // TODO: merge cases
		case "AsyncIterable":
			fallthrough // TODO: merge cases
		case "AsyncIterableIterator":
			fallthrough // TODO: merge cases
		case "AsyncGenerator":
			fallthrough // TODO: merge cases
		case "AsyncGeneratorFunction":
			fallthrough // TODO: merge cases
		case "BigInt":
			fallthrough // TODO: merge cases
		case "Reflect":
			fallthrough // TODO: merge cases
		case "BigInt64Array":
			fallthrough // TODO: merge cases
		case "BigUint64Array":
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later
		case "await":
			if isCallExpression(node.parent) {
				return Diagnostics.Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function
			}
			fallthrough
		default:
			if node.parent.kind == SyntaxKindShorthandPropertyAssignment {
				return Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer
			} else {
				return Diagnostics.Cannot_find_name_0
			}
		}
	}
	getResolvedSymbol := func(node Identifier) Symbol {
		links := getNodeLinks(node)
		if !links.resolvedSymbol {
			links.resolvedSymbol = !nodeIsMissing(node) && resolveName(node, node, SymbolFlagsValue|SymbolFlagsExportValue, getCannotFindNameDiagnosticForName(node), !isWriteOnlyAccess(node), false) || unknownSymbol
		}
		return links.resolvedSymbol
	}
	isInAmbientOrTypeNode := func(node Node) bool {
		return !!(node.flags&NodeFlagsAmbient || findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
			return isInterfaceDeclaration(n) || isTypeAliasDeclaration(n) || isTypeLiteralNode(n)
		}))
	}
	getFlowCacheKey := func(node Node, declaredType Type, initialType Type, flowContainer Node) /* TODO(StringKeyword): string */ any {
		switch node.kind {
		case SyntaxKindIdentifier:
			if !isThisInTypeQuery(node) {
				symbol := getResolvedSymbol(node)
				return /* TODO(ConditionalExpression): symbol !== unknownSymbol ? `${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}|${getSymbolId(symbol)}` : undefined */ TODO
			}
			fallthrough
		case SyntaxKindThisKeyword:
			return /* TODO(TemplateExpression): `0|${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}` */ TODO
		case SyntaxKindNonNullExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindParenthesizedExpression:
			return getFlowCacheKey((node).expression, declaredType, initialType, flowContainer)
		case SyntaxKindQualifiedName:
			left := getFlowCacheKey((node).left, declaredType, initialType, flowContainer)
			return left && /* TODO(TemplateExpression): `${left}.${(node as QualifiedName).right.escapedText}` */ TODO
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindElementAccessExpression:
			propName := getAccessedPropertyName(node)
			if propName != nil {
				key := getFlowCacheKey((node).expression, declaredType, initialType, flowContainer)
				return key && /* TODO(TemplateExpression): `${key}.${propName}` */ TODO
			}
			if isElementAccessExpression(node) && isIdentifier(node.argumentExpression) {
				symbol := getResolvedSymbol(node.argumentExpression)
				if isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol) {
					key := getFlowCacheKey((node).expression, declaredType, initialType, flowContainer)
					return key && /* TODO(TemplateExpression): `${key}.@${getSymbolId(symbol)}` */ TODO
				}
			}
			break
		case SyntaxKindObjectBindingPattern:
			fallthrough // TODO: merge cases
		case SyntaxKindArrayBindingPattern:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodDeclaration:
			return /* TODO(TemplateExpression): `${getNodeId(node)}#${getTypeId(declaredType)}` */ TODO
		}
		return nil
	}
	isMatchingReference := func(source Node, target Node) bool {
		switch target.kind {
		case SyntaxKindParenthesizedExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNonNullExpression:
			return isMatchingReference(source, (target).expression)
		case SyntaxKindBinaryExpression:
			return (isAssignmentExpression(target) && isMatchingReference(source, target.left)) || (isBinaryExpression(target) && target.operatorToken.kind == SyntaxKindCommaToken && isMatchingReference(source, target.right))
		}
		switch source.kind {
		case SyntaxKindMetaProperty:
			return target.kind == SyntaxKindMetaProperty && (source).keywordToken == (target).keywordToken && (source).name.escapedText == (target).name.escapedText
		case SyntaxKindIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindPrivateIdentifier:
			return /* TODO(ConditionalExpression): isThisInTypeQuery(source) ?                     target.kind === SyntaxKind.ThisKeyword :                     target.kind === SyntaxKind.Identifier && getResolvedSymbol(source as Identifier) === getResolvedSymbol(target as Identifier) ||                     (isVariableDeclaration(target) || isBindingElement(target)) &&                         getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(source as Identifier)) === getSymbolOfDeclaration(target) */ TODO
		case SyntaxKindThisKeyword:
			return target.kind == SyntaxKindThisKeyword
		case SyntaxKindSuperKeyword:
			return target.kind == SyntaxKindSuperKeyword
		case SyntaxKindNonNullExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindParenthesizedExpression:
			return isMatchingReference((source).expression, target)
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindElementAccessExpression:
			sourcePropertyName := getAccessedPropertyName(source)
			if sourcePropertyName != nil {
				targetPropertyName := /* TODO(ConditionalExpression): isAccessExpression(target) ? getAccessedPropertyName(target) : undefined */ TODO
				if targetPropertyName != nil {
					return targetPropertyName == sourcePropertyName && isMatchingReference((source).expression, (target).expression)
				}
			}
			if isElementAccessExpression(source) && isElementAccessExpression(target) && isIdentifier(source.argumentExpression) && isIdentifier(target.argumentExpression) {
				symbol := getResolvedSymbol(source.argumentExpression)
				if symbol == getResolvedSymbol(target.argumentExpression) && (isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol)) {
					return isMatchingReference(source.expression, target.expression)
				}
			}
			break
		case SyntaxKindQualifiedName:
			return isAccessExpression(target) && (source).right.escapedText == getAccessedPropertyName(target) && isMatchingReference((source).left, target.expression)
		case SyntaxKindBinaryExpression:
			return (isBinaryExpression(source) && source.operatorToken.kind == SyntaxKindCommaToken && isMatchingReference(source.right, target))
		}
		return false
	}
	getAccessedPropertyName := func(access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any) *__String {
		if isPropertyAccessExpression(access) {
			return access.name.escapedText
		}
		if isElementAccessExpression(access) {
			return tryGetElementAccessExpressionName(access)
		}
		if isBindingElement(access) {
			name := getDestructuringPropertyName(access)
			return /* TODO(ConditionalExpression): name ? escapeLeadingUnderscores(name) : undefined */ TODO
		}
		if isParameter(access) {
			return ( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + access.parent.parameters.indexOf(access) */ TODO)
		}
		return nil
	}
	tryGetNameFromType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.UniqueESSymbol ? (type as UniqueESSymbolType).escapedName :             type.flags & TypeFlags.StringOrNumberLiteral ? escapeLeadingUnderscores("" + (type as StringLiteralType | NumberLiteralType).value) : undefined */ TODO
	}
	tryGetElementAccessExpressionName := func(node ElementAccessExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		return /* TODO(ConditionalExpression): isStringOrNumericLiteralLike(node.argumentExpression) ? escapeLeadingUnderscores(node.argumentExpression.text) :             isEntityNameExpression(node.argumentExpression) ? tryGetNameFromEntityNameExpression(node.argumentExpression) : undefined */ TODO
	}
	tryGetNameFromEntityNameExpression := func(node EntityNameOrEntityNameExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		symbol := resolveEntityName(node, SymbolFlagsValue, true)
		if !symbol || !(isConstantVariable(symbol) || (symbol.flags & SymbolFlagsEnumMember)) {
			return nil
		}
		declaration := symbol.valueDeclaration
		if declaration == nil {
			return nil
		}
		type_ := tryGetTypeFromEffectiveTypeNode(declaration)
		if type_ {
			name := tryGetNameFromType(type_)
			if name != nil {
				return name
			}
		}
		if hasOnlyExpressionInitializer(declaration) && isBlockScopedNameDeclaredBeforeUse(declaration, node) {
			initializer := getEffectiveInitializer(declaration)
			if initializer {
				initializerType := /* TODO(ConditionalExpression): isBindingPattern(declaration.parent) ? getTypeForBindingElement(declaration as BindingElement) : getTypeOfExpression(initializer) */ TODO
				return initializerType && tryGetNameFromType(initializerType)
			}
			if isEnumMember(declaration) {
				return getTextOfPropertyName(declaration.name)
			}
		}
		return nil
	}
	containsMatchingReference := func(source Node, target Node) /* TODO inferred type boolean */ TODO {
		for isAccessExpression(source) {
			source = source.expression
			if isMatchingReference(source, target) {
				return true
			}
		}
		return false
	}
	optionalChainContainsReference := func(source Node, target Node) /* TODO inferred type boolean */ TODO {
		for isOptionalChain(source) {
			source = source.expression
			if isMatchingReference(source, target) {
				return true
			}
		}
		return false
	}
	isDiscriminantProperty := func(type_ *Type, name __String) /* TODO inferred type boolean */ TODO {
		if type_ && type_.flags&TypeFlagsUnion {
			prop := getUnionOrIntersectionProperty(type_, name)
			if prop && getCheckFlags(prop)&CheckFlagsSyntheticProperty {
				if (prop).links.isDiscriminantProperty == nil {
					(prop).links.isDiscriminantProperty = ((prop).links.checkFlags&CheckFlagsDiscriminant) == CheckFlagsDiscriminant && !isGenericType(getTypeOfSymbol(prop))
				}
				return !!(prop).links.isDiscriminantProperty
			}
		}
		return false
	}
	findDiscriminantProperties := func(sourceProperties []Symbol, target Type) /* TODO(ArrayType): Symbol[] */ any {
		var result /* TODO(ArrayType): Symbol[] */ any
		for _, sourceProperty := range sourceProperties {
			if isDiscriminantProperty(target, sourceProperty.escapedName) {
				if result {
					result.push(sourceProperty)
					continue
				}
				result = /* TODO(ArrayLiteralExpression): [sourceProperty] */ TODO
			}
		}
		return result
	}
	mapTypesByKeyProperty := func(types []Type, name __String) /* TODO inferred type Map<number, import("/home/jabaile/work/TypeScript/src/compiler/types").Type> | undefined */ TODO {
		map_ := make(map[TypeId]Type)
		count := 0
		for _, type_ := range types {
			if type_.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsInstantiableNonPrimitive) {
				discriminant := getTypeOfPropertyOfType(type_, name)
				if discriminant {
					if !isLiteralType(discriminant) {
						return nil
					}
					duplicate := false
					forEachType(discriminant, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
						id := getTypeId(getRegularTypeOfLiteralType(t))
						existing := map_.get(id)
						if !existing {
							map_.set(id, type_)
						} else if existing != unknownType {
							map_.set(id, unknownType)
							duplicate = true
						}
					})
					if !duplicate {
						count++
					}
				}
			}
		}
		return /* TODO(ConditionalExpression): count >= 10 && count * 2 >= types.length ? map : undefined */ TODO
	}
	getKeyPropertyName := func(unionType UnionType) *__String {
		types := unionType.types
		if types.length < 10 || getObjectFlags(unionType)&ObjectFlagsPrimitiveUnion || countWhere(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return !!(t.flags & (TypeFlagsObject | TypeFlagsInstantiableNonPrimitive))
		}) < 10 {
			return nil
		}
		if unionType.keyPropertyName == nil {
			keyPropertyName := forEach(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type (string & { __escapedIdentifier: void; }) | (void & { __escapedIdentifier: void; }) | import("/home/jabaile/work/TypeScript/src/compiler/types").InternalSymbolName | undefined */ TODO {
				return /* TODO(ConditionalExpression): t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive) ?                     forEach(getPropertiesOfType(t), p => isUnitType(getTypeOfSymbol(p)) ? p.escapedName : undefined) :                     undefined */ TODO
			})
			mapByKeyProperty := keyPropertyName && mapTypesByKeyProperty(types, keyPropertyName)
			unionType.keyPropertyName = /* TODO(ConditionalExpression): mapByKeyProperty ? keyPropertyName : "" as __String */ TODO
			unionType.constituentMap = mapByKeyProperty
		}
		return /* TODO(ConditionalExpression): (unionType.keyPropertyName as string).length ? unionType.keyPropertyName : undefined */ TODO
	}
	getConstituentTypeForKeyType := func(unionType UnionType, keyType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		result := unionType.constituentMap.get(getTypeId(getRegularTypeOfLiteralType(keyType)))
		return /* TODO(ConditionalExpression): result !== unknownType ? result : undefined */ TODO
	}
	getMatchingUnionConstituentForType := func(unionType UnionType, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		keyPropertyName := getKeyPropertyName(unionType)
		propType := keyPropertyName && getTypeOfPropertyOfType(type_, keyPropertyName)
		return propType && getConstituentTypeForKeyType(unionType, propType)
	}
	getMatchingUnionConstituentForObjectLiteral := func(unionType UnionType, node ObjectLiteralExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		keyPropertyName := getKeyPropertyName(unionType)
		propNode := keyPropertyName && find(node.properties, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").MethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").GetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").ShorthandPropertyAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").SpreadAssignment */ TODO) /* TODO inferred type boolean */ TODO {
			return p.symbol && p.kind == SyntaxKindPropertyAssignment && p.symbol.escapedName == keyPropertyName && isPossiblyDiscriminantValue(p.initializer)
		})
		propType := propNode && getContextFreeTypeOfExpression((propNode).initializer)
		return propType && getConstituentTypeForKeyType(unionType, propType)
	}
	isOrContainsMatchingReference := func(source Node, target Node) /* TODO inferred type boolean */ TODO {
		return isMatchingReference(source, target) || containsMatchingReference(source, target)
	}
	hasMatchingArgument := func(expression /* TODO(UnionType): CallExpression | NewExpression */ any, reference Node) /* TODO inferred type boolean */ TODO {
		if expression.arguments {
			for _, argument := range expression.arguments {
				if isOrContainsMatchingReference(reference, argument) || optionalChainContainsReference(argument, reference) {
					return true
				}
			}
		}
		if expression.expression.kind == SyntaxKindPropertyAccessExpression && isOrContainsMatchingReference(reference, (expression.expression).expression) {
			return true
		}
		return false
	}
	getFlowNodeId := func(flow FlowNode) number {
		if flow.id <= 0 {
			flow.id = nextFlowId
			nextFlowId++
		}
		return flow.id
	}
	typeMaybeAssignableTo := func(source Type, target Type) /* TODO inferred type boolean */ TODO {
		if !(source.flags & TypeFlagsUnion) {
			return isTypeAssignableTo(source, target)
		}
		for _, t := range (source).types {
			if isTypeAssignableTo(t, target) {
				return true
			}
		}
		return false
	}
	getAssignmentReducedType := func(declaredType UnionType, assignedType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if declaredType == assignedType {
			return declaredType
		}
		if assignedType.flags & TypeFlagsNever {
			return assignedType
		}
		key := /* TODO(TemplateExpression): `A${getTypeId(declaredType)},${getTypeId(assignedType)}` */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, getAssignmentReducedTypeWorker(declaredType, assignedType)) */ TODO
	}
	getAssignmentReducedTypeWorker := func(declaredType UnionType, assignedType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		filteredType := filterType(declaredType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return typeMaybeAssignableTo(assignedType, t)
		})
		reducedType := /* TODO(ConditionalExpression): assignedType.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(assignedType) ? mapType(filteredType, getFreshTypeOfLiteralType) : filteredType */ TODO
		return /* TODO(ConditionalExpression): isTypeAssignableTo(assignedType, reducedType) ? reducedType : declaredType */ TODO
	}
	isFunctionObjectType := func(type_ ObjectType) bool {
		if getObjectFlags(type_) & ObjectFlagsEvolvingArray {
			return false
		}
		resolved := resolveStructuredTypeMembers(type_)
		return !!(resolved.callSignatures.length || resolved.constructSignatures.length || resolved.members.get("bind") && isTypeSubtypeOf(type_, globalFunctionType))
	}
	getTypeFacts := func(type_ Type, mask TypeFacts) TypeFacts {
		return getTypeFactsWorker(type_, mask) & mask
	}
	hasTypeFacts := func(type_ Type, mask TypeFacts) bool {
		return getTypeFacts(type_, mask) != 0
	}
	getTypeFactsWorker := func(type_ Type, callerOnlyNeeds TypeFacts) TypeFacts {
		if type_.flags & (TypeFlagsIntersection | TypeFlagsInstantiable) {
			type_ = getBaseConstraintOfType(type_) || unknownType
		}
		flags := type_.flags
		if flags & (TypeFlagsString | TypeFlagsStringMapping) {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.StringStrictFacts : TypeFacts.StringFacts */ TODO
		}
		if flags & (TypeFlagsStringLiteral | TypeFlagsTemplateLiteral) {
			isEmpty := flags&TypeFlagsStringLiteral && (type_).value == ""
			return /* TODO(ConditionalExpression): strictNullChecks ?                 isEmpty ? TypeFacts.EmptyStringStrictFacts : TypeFacts.NonEmptyStringStrictFacts :                 isEmpty ? TypeFacts.EmptyStringFacts : TypeFacts.NonEmptyStringFacts */ TODO
		}
		if flags & (TypeFlagsNumber | TypeFlagsEnum) {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.NumberStrictFacts : TypeFacts.NumberFacts */ TODO
		}
		if flags & TypeFlagsNumberLiteral {
			isZero := (type_).value == 0
			return /* TODO(ConditionalExpression): strictNullChecks ?                 isZero ? TypeFacts.ZeroNumberStrictFacts : TypeFacts.NonZeroNumberStrictFacts :                 isZero ? TypeFacts.ZeroNumberFacts : TypeFacts.NonZeroNumberFacts */ TODO
		}
		if flags & TypeFlagsBigInt {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.BigIntStrictFacts : TypeFacts.BigIntFacts */ TODO
		}
		if flags & TypeFlagsBigIntLiteral {
			isZero := isZeroBigInt(type_)
			return /* TODO(ConditionalExpression): strictNullChecks ?                 isZero ? TypeFacts.ZeroBigIntStrictFacts : TypeFacts.NonZeroBigIntStrictFacts :                 isZero ? TypeFacts.ZeroBigIntFacts : TypeFacts.NonZeroBigIntFacts */ TODO
		}
		if flags & TypeFlagsBoolean {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.BooleanStrictFacts : TypeFacts.BooleanFacts */ TODO
		}
		if flags & TypeFlagsBooleanLike {
			return /* TODO(ConditionalExpression): strictNullChecks ?                 (type === falseType || type === regularFalseType) ? TypeFacts.FalseStrictFacts : TypeFacts.TrueStrictFacts :                 (type === falseType || type === regularFalseType) ? TypeFacts.FalseFacts : TypeFacts.TrueFacts */ TODO
		}
		if flags & TypeFlagsObject {
			possibleFacts := /* TODO(ConditionalExpression): strictNullChecks                 ? TypeFacts.EmptyObjectStrictFacts | TypeFacts.FunctionStrictFacts | TypeFacts.ObjectStrictFacts                 : TypeFacts.EmptyObjectFacts | TypeFacts.FunctionFacts | TypeFacts.ObjectFacts */ TODO
			if (callerOnlyNeeds & possibleFacts) == 0 {
				return 0
			}
			return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Anonymous && isEmptyObjectType(type as ObjectType) ?                 strictNullChecks ? TypeFacts.EmptyObjectStrictFacts : TypeFacts.EmptyObjectFacts :                 isFunctionObjectType(type as ObjectType) ?                 strictNullChecks ? TypeFacts.FunctionStrictFacts : TypeFacts.FunctionFacts :                 strictNullChecks ? TypeFacts.ObjectStrictFacts : TypeFacts.ObjectFacts */ TODO
		}
		if flags & TypeFlagsVoid {
			return TypeFactsVoidFacts
		}
		if flags & TypeFlagsUndefined {
			return TypeFactsUndefinedFacts
		}
		if flags & TypeFlagsNull {
			return TypeFactsNullFacts
		}
		if flags & TypeFlagsESSymbolLike {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.SymbolStrictFacts : TypeFacts.SymbolFacts */ TODO
		}
		if flags & TypeFlagsNonPrimitive {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.ObjectStrictFacts : TypeFacts.ObjectFacts */ TODO
		}
		if flags & TypeFlagsNever {
			return TypeFactsNone
		}
		if flags & TypeFlagsUnion {
			return reduceLeft((type_).types, func(facts /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/checker").TypeFacts.None */ TODO, t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type number */ TODO {
				return facts | getTypeFactsWorker(t, callerOnlyNeeds)
			}, TypeFactsNone)
		}
		if flags & TypeFlagsIntersection {
			return getIntersectionTypeFacts(type_, callerOnlyNeeds)
		}
		return TypeFactsUnknownFacts
	}
	getIntersectionTypeFacts := func(type_ IntersectionType, callerOnlyNeeds TypeFacts) TypeFacts {
		ignoreObjects := maybeTypeOfKind(type_, TypeFlagsPrimitive)
		oredFacts := TypeFactsNone
		andedFacts := TypeFactsAll
		for _, t := range type_.types {
			if !(ignoreObjects && t.flags&TypeFlagsObject) {
				f := getTypeFactsWorker(t, callerOnlyNeeds)
				oredFacts |= f
				andedFacts &= f
			}
		}
		return oredFacts&TypeFactsOrFactsMask | andedFacts&TypeFactsAndFactsMask
	}
	getTypeWithFacts := func(type_ Type, include TypeFacts) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return hasTypeFacts(t, include)
		})
	}
	getAdjustedTypeWithFacts := func(type_ Type, facts TypeFacts) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		reduced := recombineUnknownType(getTypeWithFacts( /* TODO(ConditionalExpression): strictNullChecks && type.flags & TypeFlags.Unknown ? unknownUnionType : type */ TODO, facts))
		if strictNullChecks {
			switch facts {
			case TypeFactsNEUndefined:
				return removeNullableByIntersection(reduced, TypeFactsEQUndefined, TypeFactsEQNull, TypeFactsIsNull, nullType)
			case TypeFactsNENull:
				return removeNullableByIntersection(reduced, TypeFactsEQNull, TypeFactsEQUndefined, TypeFactsIsUndefined, undefinedType)
			case TypeFactsNEUndefinedOrNull:
				fallthrough // TODO: merge cases
			case TypeFactsTruthy:
				return mapType(reduced, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					return /* TODO(ConditionalExpression): hasTypeFacts(t, TypeFacts.EQUndefinedOrNull) ? getGlobalNonNullableTypeInstantiation(t) : t */ TODO
				})
			}
		}
		return reduced
	}
	removeNullableByIntersection := func(type_ Type, targetFacts TypeFacts, otherFacts TypeFacts, otherIncludesFacts TypeFacts, otherType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		facts := getTypeFacts(type_, TypeFactsEQUndefined|TypeFactsEQNull|TypeFactsIsUndefined|TypeFactsIsNull)
		if !(facts & targetFacts) {
			return type_
		}
		emptyAndOtherUnion := getUnionType( /* TODO(ArrayLiteralExpression): [emptyObjectType, otherType] */ TODO)
		return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return /* TODO(ConditionalExpression): hasTypeFacts(t, targetFacts) ? getIntersectionType([t, !(facts & otherIncludesFacts) && hasTypeFacts(t, otherFacts) ? emptyAndOtherUnion : emptyObjectType]) : t */ TODO
		})
	}
	recombineUnknownType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type === unknownUnionType ? unknownType : type */ TODO
	}
	getTypeWithDefault := func(type_ Type, defaultExpression Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): defaultExpression ?             getUnionType([getNonUndefinedType(type), getTypeOfExpression(defaultExpression)]) :             type */ TODO
	}
	getTypeOfDestructuredProperty := func(type_ Type, name PropertyName) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		nameType := getLiteralTypeFromPropertyName(name)
		if !isTypeUsableAsPropertyName(nameType) {
			return errorType
		}
		text := getPropertyNameFromType(nameType)
		return getTypeOfPropertyOfType(type_, text) || includeUndefinedInIndexSignature(getApplicableIndexInfoForName(type_, text).type_) || errorType
	}
	getTypeOfDestructuredArrayElement := func(type_ Type, index number) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return everyType(type_, isTupleLikeType) && getTupleElementType(type_, index) || includeUndefinedInIndexSignature(checkIteratedTypeOrElementType(IterationUseDestructuring, type_, undefinedType, nil)) || errorType
	}
	includeUndefinedInIndexSignature := func(type_ *Type) *Type {
		if !type_ {
			return type_
		}
		return /* TODO(ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ?             getUnionType([type, missingType]) :             type */ TODO
	}
	getTypeOfDestructuredSpreadExpression := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return createArrayType(checkIteratedTypeOrElementType(IterationUseDestructuring, type_, undefinedType, nil) || errorType)
	}
	getAssignedTypeOfBinaryExpression := func(node BinaryExpression) Type {
		isDestructuringDefaultAssignment := node.parent.kind == SyntaxKindArrayLiteralExpression && isDestructuringAssignmentTarget(node.parent) || node.parent.kind == SyntaxKindPropertyAssignment && isDestructuringAssignmentTarget(node.parent.parent)
		return /* TODO(ConditionalExpression): isDestructuringDefaultAssignment ?             getTypeWithDefault(getAssignedType(node), node.right) :             getTypeOfExpression(node.right) */ TODO
	}
	isDestructuringAssignmentTarget := func(parent Node) /* TODO inferred type boolean */ TODO {
		return parent.parent.kind == SyntaxKindBinaryExpression && (parent.parent).left == parent || parent.parent.kind == SyntaxKindForOfStatement && (parent.parent).initializer == parent
	}
	getAssignedTypeOfArrayLiteralElement := func(node ArrayLiteralExpression, element Expression) Type {
		return getTypeOfDestructuredArrayElement(getAssignedType(node), node.elements.indexOf(element))
	}
	getAssignedTypeOfSpreadExpression := func(node SpreadElement) Type {
		return getTypeOfDestructuredSpreadExpression(getAssignedType(node.parent))
	}
	getAssignedTypeOfPropertyAssignment := func(node /* TODO(UnionType): PropertyAssignment | ShorthandPropertyAssignment */ any) Type {
		return getTypeOfDestructuredProperty(getAssignedType(node.parent), node.name)
	}
	getAssignedTypeOfShorthandPropertyAssignment := func(node ShorthandPropertyAssignment) Type {
		return getTypeWithDefault(getAssignedTypeOfPropertyAssignment(node), node.objectAssignmentInitializer)
	}
	getAssignedType := func(node Expression) Type {
		TODO_IDENTIFIER := node
		switch parent.kind {
		case SyntaxKindForInStatement:
			return stringType
		case SyntaxKindForOfStatement:
			return checkRightHandSideOfForOf(parent) || errorType
		case SyntaxKindBinaryExpression:
			return getAssignedTypeOfBinaryExpression(parent)
		case SyntaxKindDeleteExpression:
			return undefinedType
		case SyntaxKindArrayLiteralExpression:
			return getAssignedTypeOfArrayLiteralElement(parent, node)
		case SyntaxKindSpreadElement:
			return getAssignedTypeOfSpreadExpression(parent)
		case SyntaxKindPropertyAssignment:
			return getAssignedTypeOfPropertyAssignment(parent)
		case SyntaxKindShorthandPropertyAssignment:
			return getAssignedTypeOfShorthandPropertyAssignment(parent)
		}
		return errorType
	}
	getInitialTypeOfBindingElement := func(node BindingElement) Type {
		pattern := node.parent
		parentType := getInitialType(pattern.parent)
		type_ := /* TODO(ConditionalExpression): pattern.kind === SyntaxKind.ObjectBindingPattern ?             getTypeOfDestructuredProperty(parentType, node.propertyName || node.name as Identifier) :             !node.dotDotDotToken ?             getTypeOfDestructuredArrayElement(parentType, pattern.elements.indexOf(node)) :             getTypeOfDestructuredSpreadExpression(parentType) */ TODO
		return getTypeWithDefault(type_, node.initializer)
	}
	getTypeOfInitializer := func(node Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getNodeLinks(node)
		return links.resolvedType || getTypeOfExpression(node)
	}
	getInitialTypeOfVariableDeclaration := func(node VariableDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if node.initializer {
			return getTypeOfInitializer(node.initializer)
		}
		if node.parent.parent.kind == SyntaxKindForInStatement {
			return stringType
		}
		if node.parent.parent.kind == SyntaxKindForOfStatement {
			return checkRightHandSideOfForOf(node.parent.parent) || errorType
		}
		return errorType
	}
	getInitialType := func(node /* TODO(UnionType): VariableDeclaration | BindingElement */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): node.kind === SyntaxKind.VariableDeclaration ?             getInitialTypeOfVariableDeclaration(node) :             getInitialTypeOfBindingElement(node) */ TODO
	}
	isEmptyArrayAssignment := func(node /* TODO(UnionType): VariableDeclaration | BindingElement | Expression */ any) /* TODO inferred type boolean */ TODO {
		return node.kind == SyntaxKindVariableDeclaration && (node).initializer && isEmptyArrayLiteral((node).initializer) || node.kind != SyntaxKindBindingElement && node.parent.kind == SyntaxKindBinaryExpression && isEmptyArrayLiteral((node.parent).right)
	}
	getReferenceCandidate := func(node Expression) Expression {
		switch node.kind {
		case SyntaxKindParenthesizedExpression:
			return getReferenceCandidate((node).expression)
		case SyntaxKindBinaryExpression:
			switch (node).operatorToken.kind {
			case SyntaxKindEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindBarBarEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindAmpersandAmpersandEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindQuestionQuestionEqualsToken:
				return getReferenceCandidate((node).left)
			case SyntaxKindCommaToken:
				return getReferenceCandidate((node).right)
			}
		}
		return node
	}
	getReferenceRoot := func(node Node) Node {
		TODO_IDENTIFIER := node
		return /* TODO(ConditionalExpression): parent.kind === SyntaxKind.ParenthesizedExpression ||                 parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken && (parent as BinaryExpression).left === node ||                 parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.CommaToken && (parent as BinaryExpression).right === node ?             getReferenceRoot(parent) : node */ TODO
	}
	getTypeOfSwitchClause := func(clause /* TODO(UnionType): CaseClause | DefaultClause */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if clause.kind == SyntaxKindCaseClause {
			return getRegularTypeOfLiteralType(getTypeOfExpression(clause.expression))
		}
		return neverType
	}
	getSwitchClauseTypes := func(switchStatement SwitchStatement) []Type {
		links := getNodeLinks(switchStatement)
		if !links.switchTypes {
			links.switchTypes = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, clause := range switchStatement.caseBlock.clauses {
				links.switchTypes.push(getTypeOfSwitchClause(clause))
			}
		}
		return links.switchTypes
	}
	getSwitchClauseTypeOfWitnesses := func(switchStatement SwitchStatement) /* TODO(ArrayType): (string | undefined)[] */ any {
		if some(switchStatement.caseBlock.clauses, func(clause /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").CaseClause | import("/home/jabaile/work/TypeScript/src/compiler/types").DefaultClause */ TODO) /* TODO inferred type boolean */ TODO {
			return clause.kind == SyntaxKindCaseClause && !isStringLiteralLike(clause.expression)
		}) {
			return nil
		}
		var witnesses [] /* TODO(StringKeyword): string */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, clause := range switchStatement.caseBlock.clauses {
			text := /* TODO(ConditionalExpression): clause.kind === SyntaxKind.CaseClause ? (clause.expression as StringLiteralLike).text : undefined */ TODO
			witnesses.push( /* TODO(ConditionalExpression): text && !contains(witnesses, text) ? text : undefined */ TODO)
		}
		return witnesses
	}
	eachTypeContainedIn := func(source Type, types []Type) /* TODO inferred type boolean */ TODO {
		return /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? !forEach((source as UnionType).types, t => !contains(types, t)) : contains(types, source) */ TODO
	}
	isTypeSubsetOf := func(source Type, target Type) /* TODO inferred type boolean */ TODO {
		return !!(source == target || source.flags&TypeFlagsNever || target.flags&TypeFlagsUnion && isTypeSubsetOfUnion(source, target))
	}
	isTypeSubsetOfUnion := func(source Type, target UnionType) /* TODO inferred type boolean */ TODO {
		if source.flags & TypeFlagsUnion {
			for _, t := range (source).types {
				if !containsType(target.types, t) {
					return false
				}
			}
			return true
		}
		if source.flags&TypeFlagsEnumLike && getBaseTypeOfEnumLikeType(source) == target {
			return true
		}
		return containsType(target.types, source)
	}
	forEachType := func(type_ Type, f func(t Type) *T) *T {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? forEach((type as UnionType).types, f) : f(type) */ TODO
	}
	someType := func(type_ Type, f func(t Type) bool) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? some((type as UnionType).types, f) : f(type) */ TODO
	}
	everyType := func(type_ Type, f func(t Type) bool) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? every((type as UnionType).types, f) : f(type) */ TODO
	}
	everyContainedType := func(type_ Type, f func(t Type) bool) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.UnionOrIntersection ? every((type as UnionOrIntersectionType).types, f) : f(type) */ TODO
	}
	filterType := func(type_ Type, f func(t Type) bool) Type {
		if type_.flags & TypeFlagsUnion {
			types := (type_).types
			filtered := filter(types, f)
			if filtered == types {
				return type_
			}
			origin := (type_).origin
			var newOrigin *Type
			if origin && origin.flags&TypeFlagsUnion {
				originTypes := (origin).types
				originFiltered := filter(originTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !!(t.flags & TypeFlagsUnion) || f(t)
				})
				if /* TODO(MinusToken): - */ /* TODO(BinaryExpression): originTypes.length - originFiltered.length */ TODO == /* TODO(MinusToken): - */ /* TODO(BinaryExpression): types.length - filtered.length */ TODO {
					if originFiltered.length == 1 {
						return /* TODO(ElementAccessExpression): originFiltered[0] */ TODO
					}
					newOrigin = createOriginUnionOrIntersectionType(TypeFlagsUnion, originFiltered)
				}
			}
			return getUnionTypeFromSortedList(filtered, (type_).objectFlags&(ObjectFlagsPrimitiveUnion|ObjectFlagsContainsIntersections), nil, nil, newOrigin)
		}
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Never || f(type) ? type : neverType */ TODO
	}
	removeType := func(type_ Type, targetType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return t != targetType
		})
	}
	countTypes := func(type_ Type) /* TODO inferred type number */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).types.length : 1 */ TODO
	}
	// OVERLOAD: mapType := func(type_ Type, mapper func(t Type) Type, noReductions bool) Type
	// OVERLOAD: mapType := func(type_ Type, mapper func(t Type) *Type, noReductions bool) *Type
	mapType := func(type_ Type, mapper func(t Type) *Type, noReductions bool) *Type {
		if type_.flags & TypeFlagsNever {
			return type_
		}
		if !(type_.flags & TypeFlagsUnion) {
			return mapper(type_)
		}
		origin := (type_).origin
		types := /* TODO(ConditionalExpression): origin && origin.flags & TypeFlags.Union ? (origin as UnionType).types : (type as UnionType).types */ TODO
		var mappedTypes /* TODO(ArrayType): Type[] */ any
		changed := false
		for _, t := range types {
			mapped := /* TODO(ConditionalExpression): t.flags & TypeFlags.Union ? mapType(t, mapper, noReductions) : mapper(t) */ TODO
			/* TODO(ExpressionStatement): changed ||= t !== mapped; */
			if mapped {
				if !mappedTypes {
					mappedTypes = /* TODO(ArrayLiteralExpression): [mapped] */ TODO
				} else {
					mappedTypes.push(mapped)
				}
			}
		}
		return /* TODO(ConditionalExpression): changed ? mappedTypes && getUnionType(mappedTypes, noReductions ? UnionReduction.None : UnionReduction.Literal) : type */ TODO
	}
	mapTypeWithAlias := func(type_ Type, mapper func(t Type) Type, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union && aliasSymbol ?             getUnionType(map((type as UnionType).types, mapper), UnionReduction.Literal, aliasSymbol, aliasTypeArguments) :             mapType(type, mapper) */ TODO
	}
	extractTypesOfKind := func(type_ Type, kind TypeFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return (t.flags & kind) != 0
		})
	}
	replacePrimitivesWithLiterals := func(typeWithPrimitives Type, typeWithLiterals Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if maybeTypeOfKind(typeWithPrimitives, TypeFlagsString|TypeFlagsTemplateLiteral|TypeFlagsNumber|TypeFlagsBigInt) && maybeTypeOfKind(typeWithLiterals, TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping|TypeFlagsNumberLiteral|TypeFlagsBigIntLiteral) {
			return mapType(typeWithPrimitives, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return /* TODO(ConditionalExpression): t.flags & TypeFlags.String ? extractTypesOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) :                     isPatternLiteralType(t) && !maybeTypeOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? extractTypesOfKind(typeWithLiterals, TypeFlags.StringLiteral) :                     t.flags & TypeFlags.Number ? extractTypesOfKind(typeWithLiterals, TypeFlags.Number | TypeFlags.NumberLiteral) :                     t.flags & TypeFlags.BigInt ? extractTypesOfKind(typeWithLiterals, TypeFlags.BigInt | TypeFlags.BigIntLiteral) : t */ TODO
			})
		}
		return typeWithPrimitives
	}
	isIncomplete := func(flowType FlowType) /* TODO inferred type boolean */ TODO {
		return flowType.flags == 0
	}
	getTypeFromFlowType := func(flowType FlowType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): flowType.flags === 0 ? flowType.type : flowType as Type */ TODO
	}
	createFlowType := func(type_ Type, incomplete bool) FlowType {
		return /* TODO(ConditionalExpression): incomplete ? { flags: 0, type: type.flags & TypeFlags.Never ? silentNeverType : type } : type */ TODO
	}
	createEvolvingArrayType := func(elementType Type) EvolvingArrayType {
		result := createObjectType(ObjectFlagsEvolvingArray)
		result.elementType = elementType
		return result
	}
	getEvolvingArrayType := func(elementType Type) EvolvingArrayType {
		return /* TODO(ElementAccessExpression): evolvingArrayTypes[elementType.id] */ TODO || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): evolvingArrayTypes[elementType.id] = createEvolvingArrayType(elementType) */ TODO)
	}
	addEvolvingArrayElementType := func(evolvingArrayType EvolvingArrayType, node Expression) EvolvingArrayType {
		elementType := getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(getContextFreeTypeOfExpression(node)))
		return /* TODO(ConditionalExpression): isTypeSubsetOf(elementType, evolvingArrayType.elementType) ? evolvingArrayType : getEvolvingArrayType(getUnionType([evolvingArrayType.elementType, elementType])) */ TODO
	}
	createFinalArrayType := func(elementType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): elementType.flags & TypeFlags.Never ?             autoArrayType :             createArrayType(                 elementType.flags & TypeFlags.Union ?                     getUnionType((elementType as UnionType).types, UnionReduction.Subtype) :                     elementType,             ) */ TODO
	}
	getFinalArrayType := func(evolvingArrayType EvolvingArrayType) Type {
		return evolvingArrayType.finalArrayType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): evolvingArrayType.finalArrayType = createFinalArrayType(evolvingArrayType.elementType) */ TODO)
	}
	finalizeEvolvingArrayType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.EvolvingArray ? getFinalArrayType(type as EvolvingArrayType) : type */ TODO
	}
	getElementTypeOfEvolvingArrayType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.EvolvingArray ? (type as EvolvingArrayType).elementType : neverType */ TODO
	}
	isEvolvingArrayTypeList := func(types []Type) /* TODO inferred type boolean */ TODO {
		hasEvolvingArrayType := false
		for _, t := range types {
			if !(t.flags & TypeFlagsNever) {
				if !(getObjectFlags(t) & ObjectFlagsEvolvingArray) {
					return false
				}
				hasEvolvingArrayType = true
			}
		}
		return hasEvolvingArrayType
	}
	isEvolvingArrayOperationTarget := func(node Node) /* TODO inferred type boolean */ TODO {
		root := getReferenceRoot(node)
		parent := root.parent
		isLengthPushOrUnshift := isPropertyAccessExpression(parent) && (parent.name.escapedText == "length" || parent.parent.kind == SyntaxKindCallExpression && isIdentifier(parent.name) && isPushOrUnshiftIdentifier(parent.name))
		isElementAssignment := parent.kind == SyntaxKindElementAccessExpression && (parent).expression == root && parent.parent.kind == SyntaxKindBinaryExpression && (parent.parent).operatorToken.kind == SyntaxKindEqualsToken && (parent.parent).left == parent && !isAssignmentTarget(parent.parent) && isTypeAssignableToKind(getTypeOfExpression((parent).argumentExpression), TypeFlagsNumberLike)
		return isLengthPushOrUnshift || isElementAssignment
	}
	isDeclarationWithExplicitTypeAnnotation := func(node Declaration) /* TODO inferred type boolean */ TODO {
		return (isVariableDeclaration(node) || isPropertyDeclaration(node) || isPropertySignature(node) || isParameter(node)) && !!(getEffectiveTypeAnnotationNode(node) || isInJSFile(node) && hasInitializer(node) && node.initializer && isFunctionExpressionOrArrowFunction(node.initializer) && getEffectiveReturnTypeNode(node.initializer))
	}
	getExplicitTypeOfSymbol := func(symbol Symbol, diagnostic Diagnostic) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		symbol = resolveSymbol(symbol)
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsValueModule) {
			return getTypeOfSymbol(symbol)
		}
		if symbol.flags & (SymbolFlagsVariable | SymbolFlagsProperty) {
			if getCheckFlags(symbol) & CheckFlagsMapped {
				origin := (symbol).links.syntheticOrigin
				if origin && getExplicitTypeOfSymbol(origin) {
					return getTypeOfSymbol(symbol)
				}
			}
			declaration := symbol.valueDeclaration
			if declaration {
				if isDeclarationWithExplicitTypeAnnotation(declaration) {
					return getTypeOfSymbol(symbol)
				}
				if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForOfStatement {
					statement := declaration.parent.parent
					expressionType := getTypeOfDottedName(statement.expression, nil)
					if expressionType {
						use := /* TODO(ConditionalExpression): statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf */ TODO
						return checkIteratedTypeOrElementType(use, expressionType, undefinedType, nil)
					}
				}
				if diagnostic {
					addRelatedInfo(diagnostic, createDiagnosticForNode(declaration, Diagnostics._0_needs_an_explicit_type_annotation, symbolToString(symbol)))
				}
			}
		}
	}
	getTypeOfDottedName := func(node Expression, diagnostic *Diagnostic) *Type {
		if !(node.flags & NodeFlagsInWithStatement) {
			switch node.kind {
			case SyntaxKindIdentifier:
				symbol := getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(node))
				return getExplicitTypeOfSymbol(symbol, diagnostic)
			case SyntaxKindThisKeyword:
				return getExplicitThisType(node)
			case SyntaxKindSuperKeyword:
				return checkSuperExpression(node)
			case SyntaxKindPropertyAccessExpression:
				type_ := getTypeOfDottedName((node).expression, diagnostic)
				if type_ {
					name := (node).name
					var prop *Symbol
					if isPrivateIdentifier(name) {
						if !type_.symbol {
							return nil
						}
						prop = getPropertyOfType(type_, getSymbolNameForPrivateIdentifier(type_.symbol, name.escapedText))
					} else {
						prop = getPropertyOfType(type_, name.escapedText)
					}
					return prop && getExplicitTypeOfSymbol(prop, diagnostic)
				}
				return nil
				fallthrough
			case SyntaxKindParenthesizedExpression:
				return getTypeOfDottedName((node).expression, diagnostic)
			}
		}
	}
	getEffectsSignature := func(node /* TODO(UnionType): CallExpression | InstanceofExpression */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		links := getNodeLinks(node)
		signature := links.effectsSignature
		if signature == nil {
			var funcType *Type
			if isBinaryExpression(node) {
				rightType := checkNonNullExpression(node.right)
				funcType = getSymbolHasInstanceMethodOfObjectType(rightType)
			} else if node.parent.kind == SyntaxKindExpressionStatement {
				funcType = getTypeOfDottedName(node.expression, nil)
			} else if node.expression.kind != SyntaxKindSuperKeyword {
				if isOptionalChain(node) {
					funcType = checkNonNullType(getOptionalExpressionType(checkExpression(node.expression), node.expression), node.expression)
				} else {
					funcType = checkNonNullExpression(node.expression)
				}
			}
			signatures := getSignaturesOfType(funcType && getApparentType(funcType) || unknownType, SignatureKindCall)
			candidate := /* TODO(ConditionalExpression): signatures.length === 1 && !signatures[0].typeParameters ? signatures[0] :                 some(signatures, hasTypePredicateOrNeverReturnType) ? getResolvedSignature(node) :                 undefined */ TODO
			signature = /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.effectsSignature = candidate && hasTypePredicateOrNeverReturnType(candidate) ? candidate : unknownSignature */ TODO
		}
		return /* TODO(ConditionalExpression): signature === unknownSignature ? undefined : signature */ TODO
	}
	hasTypePredicateOrNeverReturnType := func(signature Signature) /* TODO inferred type boolean */ TODO {
		return !!(getTypePredicateOfSignature(signature) || signature.declaration && (getReturnTypeFromAnnotation(signature.declaration) || unknownType).flags&TypeFlagsNever)
	}
	getTypePredicateArgument := func(predicate TypePredicate, callExpression CallExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ TODO {
		if predicate.kind == TypePredicateKindIdentifier || predicate.kind == TypePredicateKindAssertsIdentifier {
			return /* TODO(ElementAccessExpression): callExpression.arguments[predicate.parameterIndex] */ TODO
		}
		invokedExpression := skipParentheses(callExpression.expression)
		return /* TODO(ConditionalExpression): isAccessExpression(invokedExpression) ? skipParentheses(invokedExpression.expression) : undefined */ TODO
	}
	reportFlowControlError := func(node Node) {
		block := findAncestor(node, isFunctionOrModuleBlock)
		sourceFile := getSourceFileOfNode(node)
		span := getSpanOfTokenAtPosition(sourceFile, block.statements.pos)
		diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_containing_function_or_module_body_is_too_large_for_control_flow_analysis))
	}
	isReachableFlowNode := func(flow FlowNode) /* TODO inferred type boolean */ TODO {
		result := isReachableFlowNodeWorker(flow, false)
		lastFlowNode = flow
		lastFlowNodeReachable = result
		return result
	}
	isFalseExpression := func(expr Expression) bool {
		node := skipParentheses(expr, true)
		return node.kind == SyntaxKindFalseKeyword || node.kind == SyntaxKindBinaryExpression && ((node).operatorToken.kind == SyntaxKindAmpersandAmpersandToken && (isFalseExpression((node).left) || isFalseExpression((node).right)) || (node).operatorToken.kind == SyntaxKindBarBarToken && isFalseExpression((node).left) && isFalseExpression((node).right))
	}
	isReachableFlowNodeWorker := func(flow FlowNode, noCacheCheck bool) bool {
		for true {
			if flow == lastFlowNode {
				return lastFlowNodeReachable
			}
			flags := flow.flags
			if flags & FlowFlagsShared {
				if !noCacheCheck {
					id := getFlowNodeId(flow)
					reachable := /* TODO(ElementAccessExpression): flowNodeReachable[id] */ TODO
					return /* TODO(ConditionalExpression): reachable !== undefined ? reachable : (flowNodeReachable[id] = isReachableFlowNodeWorker(flow, /*noCacheCheck* / true)) */ TODO
				}
				noCacheCheck = false
			}
			if flags & (FlowFlagsAssignment | FlowFlagsCondition | FlowFlagsArrayMutation) {
				flow = (flow).antecedent
			} else if flags & FlowFlagsCall {
				signature := getEffectsSignature((flow).node)
				if signature {
					predicate := getTypePredicateOfSignature(signature)
					if predicate && predicate.kind == TypePredicateKindAssertsIdentifier && !predicate.type_ {
						predicateArgument := /* TODO(ElementAccessExpression): (flow as FlowCall).node.arguments[predicate.parameterIndex] */ TODO
						if predicateArgument && isFalseExpression(predicateArgument) {
							return false
						}
					}
					if getReturnTypeOfSignature(signature).flags & TypeFlagsNever {
						return false
					}
				}
				flow = (flow).antecedent
			} else if flags & FlowFlagsBranchLabel {
				return some((flow).antecedent, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").FlowNode */ TODO) /* TODO inferred type boolean */ TODO {
					return isReachableFlowNodeWorker(f, false)
				})
			} else if flags & FlowFlagsLoopLabel {
				antecedents := (flow).antecedent
				if antecedents == nil || antecedents.length == 0 {
					return false
				}
				flow = /* TODO(ElementAccessExpression): antecedents[0] */ TODO
			} else if flags & FlowFlagsSwitchClause {
				data := (flow).node
				if data.clauseStart == data.clauseEnd && isExhaustiveSwitchStatement(data.switchStatement) {
					return false
				}
				flow = (flow).antecedent
			} else if flags & FlowFlagsReduceLabel {
				lastFlowNode = nil
				target := (flow).node.target
				saveAntecedents := target.antecedent
				target.antecedent = (flow).node.antecedents
				result := isReachableFlowNodeWorker((flow).antecedent, false)
				target.antecedent = saveAntecedents
				return result
			} else {
				return !(flags & FlowFlagsUnreachable)
			}
		}
	}
	isPostSuperFlowNode := func(flow FlowNode, noCacheCheck bool) bool {
		for true {
			flags := flow.flags
			if flags & FlowFlagsShared {
				if !noCacheCheck {
					id := getFlowNodeId(flow)
					postSuper := /* TODO(ElementAccessExpression): flowNodePostSuper[id] */ TODO
					return /* TODO(ConditionalExpression): postSuper !== undefined ? postSuper : (flowNodePostSuper[id] = isPostSuperFlowNode(flow, /*noCacheCheck* / true)) */ TODO
				}
				noCacheCheck = false
			}
			if flags & (FlowFlagsAssignment | FlowFlagsCondition | FlowFlagsArrayMutation | FlowFlagsSwitchClause) {
				flow = (flow).antecedent
			} else if flags & FlowFlagsCall {
				if (flow).node.expression.kind == SyntaxKindSuperKeyword {
					return true
				}
				flow = (flow).antecedent
			} else if flags & FlowFlagsBranchLabel {
				return every((flow).antecedent, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").FlowNode */ TODO) /* TODO inferred type boolean */ TODO {
					return isPostSuperFlowNode(f, false)
				})
			} else if flags & FlowFlagsLoopLabel {
				flow = /* TODO(ElementAccessExpression): (flow as FlowLabel).antecedent![0] */ TODO
			} else if flags & FlowFlagsReduceLabel {
				target := (flow).node.target
				saveAntecedents := target.antecedent
				target.antecedent = (flow).node.antecedents
				result := isPostSuperFlowNode((flow).antecedent, false)
				target.antecedent = saveAntecedents
				return result
			} else {
				return !!(flags & FlowFlagsUnreachable)
			}
		}
	}
	isConstantReference := func(node Node) bool {
		switch node.kind {
		case SyntaxKindThisKeyword:
			return true
		case SyntaxKindIdentifier:
			if !isThisInTypeQuery(node) {
				symbol := getResolvedSymbol(node)
				return isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol) || !!symbol.valueDeclaration && isFunctionExpression(symbol.valueDeclaration)
			}
			break
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindElementAccessExpression:
			return isConstantReference((node).expression) && isReadonlySymbol(getNodeLinks(node).resolvedSymbol || unknownSymbol)
		case SyntaxKindObjectBindingPattern:
			fallthrough // TODO: merge cases
		case SyntaxKindArrayBindingPattern:
			rootDeclaration := getRootDeclaration(node.parent)
			return /* TODO(ConditionalExpression): isParameter(rootDeclaration) || isCatchClauseVariableDeclaration(rootDeclaration)                     ? !isSomeSymbolAssigned(rootDeclaration)                     : isVariableDeclaration(rootDeclaration) && isVarConstLike(rootDeclaration) */ TODO
		}
		return false
	}
	getFlowTypeOfReference := func(reference Node, declaredType Type, initialType /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO /*  = declaredType */, flowContainer Node, flowNode /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").FlowNode | undefined */ TODO /*  = tryCast(reference, canHaveFlowNode)?.flowNode */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		var key /* TODO(StringKeyword): string */ any
		isKeySet := false
		flowDepth := 0
		if flowAnalysisDisabled {
			return errorType
		}
		if !flowNode {
			return declaredType
		}
		flowInvocationCount++
		sharedFlowStart := sharedFlowCount
		evolvedType := getTypeFromFlowType(getTypeAtFlowNode(flowNode))
		sharedFlowCount = sharedFlowStart
		resultType := /* TODO(ConditionalExpression): getObjectFlags(evolvedType) & ObjectFlags.EvolvingArray && isEvolvingArrayOperationTarget(reference) ? autoArrayType : finalizeEvolvingArrayType(evolvedType) */ TODO
		if resultType == unreachableNeverType || reference.parent && reference.parent.kind == SyntaxKindNonNullExpression && !(resultType.flags&TypeFlagsNever) && getTypeWithFacts(resultType, TypeFactsNEUndefinedOrNull).flags&TypeFlagsNever {
			return declaredType
		}
		return resultType
		getOrSetCacheKey := func() /* TODO inferred type string | undefined */ TODO {
			if isKeySet {
				return key
			}
			isKeySet = true
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): key = getFlowCacheKey(reference, declaredType, initialType, flowContainer) */ TODO
		}
		getTypeAtFlowNode := func(flow FlowNode) FlowType {
			if flowDepth == 2000 {
				tracing.instant(tracing.Phase.CheckTypes, "getTypeAtFlowNode_DepthLimit" /* TODO(ObjectLiteralExpression): { flowId: flow.id } */, TODO)
				flowAnalysisDisabled = true
				reportFlowControlError(reference)
				return errorType
			}
			flowDepth++
			var sharedFlow *FlowNode
			for true {
				flags := flow.flags
				if flags & FlowFlagsShared {
					/* TODO(ForStatement): for (let i = sharedFlowStart; i < sharedFlowCount; i++) {                         if (sharedFlowNodes[i] === flow) {                             flowDepth--;                             return sharedFlowTypes[i];                         }                     } */
					sharedFlow = flow
				}
				var type_ *FlowType
				if flags & FlowFlagsAssignment {
					type_ = getTypeAtFlowAssignment(flow)
					if !type_ {
						flow = (flow).antecedent
						continue
					}
				} else if flags & FlowFlagsCall {
					type_ = getTypeAtFlowCall(flow)
					if !type_ {
						flow = (flow).antecedent
						continue
					}
				} else if flags & FlowFlagsCondition {
					type_ = getTypeAtFlowCondition(flow)
				} else if flags & FlowFlagsSwitchClause {
					type_ = getTypeAtSwitchClause(flow)
				} else if flags & FlowFlagsLabel {
					if (flow).antecedent.length == 1 {
						flow = /* TODO(ElementAccessExpression): (flow as FlowLabel).antecedent![0] */ TODO
						continue
					}
					type_ = /* TODO(ConditionalExpression): flags & FlowFlags.BranchLabel ?                         getTypeAtFlowBranchLabel(flow as FlowLabel) :                         getTypeAtFlowLoopLabel(flow as FlowLabel) */ TODO
				} else if flags & FlowFlagsArrayMutation {
					type_ = getTypeAtFlowArrayMutation(flow)
					if !type_ {
						flow = (flow).antecedent
						continue
					}
				} else if flags & FlowFlagsReduceLabel {
					target := (flow).node.target
					saveAntecedents := target.antecedent
					target.antecedent = (flow).node.antecedents
					type_ = getTypeAtFlowNode((flow).antecedent)
					target.antecedent = saveAntecedents
				} else if flags & FlowFlagsStart {
					container := (flow).node
					if container && container != flowContainer && reference.kind != SyntaxKindPropertyAccessExpression && reference.kind != SyntaxKindElementAccessExpression && !(reference.kind == SyntaxKindThisKeyword && container.kind != SyntaxKindArrowFunction) {
						flow = container.flowNode
						continue
					}
					type_ = initialType
				} else {
					type_ = convertAutoToAny(declaredType)
				}
				if sharedFlow {
					/* TODO(ElementAccessExpression): sharedFlowNodes[sharedFlowCount] */ TODO = sharedFlow
					/* TODO(ElementAccessExpression): sharedFlowTypes[sharedFlowCount] */ TODO = type_
					sharedFlowCount++
				}
				flowDepth--
				return type_
			}
		}
		getInitialOrAssignedType := func(flow FlowAssignment) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			node := flow.node
			return getNarrowableTypeForReference( /* TODO(ConditionalExpression): node.kind === SyntaxKind.VariableDeclaration || node.kind === SyntaxKind.BindingElement ?                     getInitialType(node as VariableDeclaration | BindingElement) :                     getAssignedType(node) */ TODO, reference)
		}
		getTypeAtFlowAssignment := func(flow FlowAssignment) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").FlowType | undefined */ TODO {
			node := flow.node
			if isMatchingReference(reference, node) {
				if !isReachableFlowNode(flow) {
					return unreachableNeverType
				}
				if getAssignmentTargetKind(node) == AssignmentKindCompound {
					flowType := getTypeAtFlowNode(flow.antecedent)
					return createFlowType(getBaseTypeOfLiteralType(getTypeFromFlowType(flowType)), isIncomplete(flowType))
				}
				if declaredType == autoType || declaredType == autoArrayType {
					if isEmptyArrayAssignment(node) {
						return getEvolvingArrayType(neverType)
					}
					assignedType := getWidenedLiteralType(getInitialOrAssignedType(flow))
					return /* TODO(ConditionalExpression): isTypeAssignableTo(assignedType, declaredType) ? assignedType : anyArrayType */ TODO
				}
				t := /* TODO(ConditionalExpression): isInCompoundLikeAssignment(node) ? getBaseTypeOfLiteralType(declaredType) : declaredType */ TODO
				if t.flags & TypeFlagsUnion {
					return getAssignmentReducedType(t, getInitialOrAssignedType(flow))
				}
				return t
			}
			if containsMatchingReference(reference, node) {
				if !isReachableFlowNode(flow) {
					return unreachableNeverType
				}
				if isVariableDeclaration(node) && (isInJSFile(node) || isVarConstLike(node)) {
					init := getDeclaredExpandoInitializer(node)
					if init && (init.kind == SyntaxKindFunctionExpression || init.kind == SyntaxKindArrowFunction) {
						return getTypeAtFlowNode(flow.antecedent)
					}
				}
				return declaredType
			}
			if isVariableDeclaration(node) && node.parent.parent.kind == SyntaxKindForInStatement && (isMatchingReference(reference, node.parent.parent.expression) || optionalChainContainsReference(node.parent.parent.expression, reference)) {
				return getNonNullableTypeIfNeeded(finalizeEvolvingArrayType(getTypeFromFlowType(getTypeAtFlowNode(flow.antecedent))))
			}
			return nil
		}
		narrowTypeByAssertion := func(type_ Type, expr Expression) Type {
			node := skipParentheses(expr, true)
			if node.kind == SyntaxKindFalseKeyword {
				return unreachableNeverType
			}
			if node.kind == SyntaxKindBinaryExpression {
				if (node).operatorToken.kind == SyntaxKindAmpersandAmpersandToken {
					return narrowTypeByAssertion(narrowTypeByAssertion(type_, (node).left), (node).right)
				}
				if (node).operatorToken.kind == SyntaxKindBarBarToken {
					return getUnionType( /* TODO(ArrayLiteralExpression): [narrowTypeByAssertion(type, (node as BinaryExpression).left), narrowTypeByAssertion(type, (node as BinaryExpression).right)] */ TODO)
				}
			}
			return narrowType(type_, node, true)
		}
		getTypeAtFlowCall := func(flow FlowCall) *FlowType {
			signature := getEffectsSignature(flow.node)
			if signature {
				predicate := getTypePredicateOfSignature(signature)
				if predicate && (predicate.kind == TypePredicateKindAssertsThis || predicate.kind == TypePredicateKindAssertsIdentifier) {
					flowType := getTypeAtFlowNode(flow.antecedent)
					type_ := finalizeEvolvingArrayType(getTypeFromFlowType(flowType))
					narrowedType := /* TODO(ConditionalExpression): predicate.type ? narrowTypeByTypePredicate(type, predicate, flow.node, /*assumeTrue* / true) :                         predicate.kind === TypePredicateKind.AssertsIdentifier && predicate.parameterIndex >= 0 && predicate.parameterIndex < flow.node.arguments.length ? narrowTypeByAssertion(type, flow.node.arguments[predicate.parameterIndex]) :                         type */ TODO
					return /* TODO(ConditionalExpression): narrowedType === type ? flowType : createFlowType(narrowedType, isIncomplete(flowType)) */ TODO
				}
				if getReturnTypeOfSignature(signature).flags & TypeFlagsNever {
					return unreachableNeverType
				}
			}
			return nil
		}
		getTypeAtFlowArrayMutation := func(flow FlowArrayMutation) *FlowType {
			if declaredType == autoType || declaredType == autoArrayType {
				node := flow.node
				expr := /* TODO(ConditionalExpression): node.kind === SyntaxKind.CallExpression ?                     (node.expression as PropertyAccessExpression).expression :                     (node.left as ElementAccessExpression).expression */ TODO
				if isMatchingReference(reference, getReferenceCandidate(expr)) {
					flowType := getTypeAtFlowNode(flow.antecedent)
					type_ := getTypeFromFlowType(flowType)
					if getObjectFlags(type_) & ObjectFlagsEvolvingArray {
						evolvedType := type_
						if node.kind == SyntaxKindCallExpression {
							for _, arg := range node.arguments {
								evolvedType = addEvolvingArrayElementType(evolvedType, arg)
							}
						} else {
							indexType := getContextFreeTypeOfExpression((node.left).argumentExpression)
							if isTypeAssignableToKind(indexType, TypeFlagsNumberLike) {
								evolvedType = addEvolvingArrayElementType(evolvedType, node.right)
							}
						}
						return /* TODO(ConditionalExpression): evolvedType === type ? flowType : createFlowType(evolvedType, isIncomplete(flowType)) */ TODO
					}
					return flowType
				}
			}
			return nil
		}
		getTypeAtFlowCondition := func(flow FlowCondition) FlowType {
			flowType := getTypeAtFlowNode(flow.antecedent)
			type_ := getTypeFromFlowType(flowType)
			if type_.flags & TypeFlagsNever {
				return flowType
			}
			assumeTrue := (flow.flags & FlowFlagsTrueCondition) != 0
			nonEvolvingType := finalizeEvolvingArrayType(type_)
			narrowedType := narrowType(nonEvolvingType, flow.node, assumeTrue)
			if narrowedType == nonEvolvingType {
				return flowType
			}
			return createFlowType(narrowedType, isIncomplete(flowType))
		}
		getTypeAtSwitchClause := func(flow FlowSwitchClause) FlowType {
			expr := skipParentheses(flow.node.switchStatement.expression)
			flowType := getTypeAtFlowNode(flow.antecedent)
			type_ := getTypeFromFlowType(flowType)
			if isMatchingReference(reference, expr) {
				type_ = narrowTypeBySwitchOnDiscriminant(type_, flow.node)
			} else if expr.kind == SyntaxKindTypeOfExpression && isMatchingReference(reference, (expr).expression) {
				type_ = narrowTypeBySwitchOnTypeOf(type_, flow.node)
			} else if expr.kind == SyntaxKindTrueKeyword {
				type_ = narrowTypeBySwitchOnTrue(type_, flow.node)
			} else {
				if strictNullChecks {
					if optionalChainContainsReference(expr, reference) {
						type_ = narrowTypeBySwitchOptionalChainContainment(type_, flow.node, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
							return !(t.flags & (TypeFlagsUndefined | TypeFlagsNever))
						})
					} else if expr.kind == SyntaxKindTypeOfExpression && optionalChainContainsReference((expr).expression, reference) {
						type_ = narrowTypeBySwitchOptionalChainContainment(type_, flow.node, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
							return !(t.flags&TypeFlagsNever || t.flags&TypeFlagsStringLiteral && (t).value == "undefined")
						})
					}
				}
				access := getDiscriminantPropertyAccess(expr, type_)
				if access {
					type_ = narrowTypeBySwitchOnDiscriminantProperty(type_, access, flow.node)
				}
			}
			return createFlowType(type_, isIncomplete(flowType))
		}
		getTypeAtFlowBranchLabel := func(flow FlowLabel) FlowType {
			var antecedentTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			subtypeReduction := false
			seenIncomplete := false
			var bypassFlow *FlowSwitchClause
			for _, antecedent := range flow.antecedent {
				if !bypassFlow && antecedent.flags&FlowFlagsSwitchClause && (antecedent).node.clauseStart == (antecedent).node.clauseEnd {
					bypassFlow = antecedent
					continue
				}
				flowType := getTypeAtFlowNode(antecedent)
				type_ := getTypeFromFlowType(flowType)
				if type_ == declaredType && declaredType == initialType {
					return type_
				}
				pushIfUnique(antecedentTypes, type_)
				if !isTypeSubsetOf(type_, initialType) {
					subtypeReduction = true
				}
				if isIncomplete(flowType) {
					seenIncomplete = true
				}
			}
			if bypassFlow {
				flowType := getTypeAtFlowNode(bypassFlow)
				type_ := getTypeFromFlowType(flowType)
				if !(type_.flags & TypeFlagsNever) && !contains(antecedentTypes, type_) && !isExhaustiveSwitchStatement(bypassFlow.node.switchStatement) {
					if type_ == declaredType && declaredType == initialType {
						return type_
					}
					antecedentTypes.push(type_)
					if !isTypeSubsetOf(type_, initialType) {
						subtypeReduction = true
					}
					if isIncomplete(flowType) {
						seenIncomplete = true
					}
				}
			}
			return createFlowType(getUnionOrEvolvingArrayType(antecedentTypes /* TODO(ConditionalExpression): subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal */, TODO), seenIncomplete)
		}
		getTypeAtFlowLoopLabel := func(flow FlowLabel) FlowType {
			id := getFlowNodeId(flow)
			cache := /* TODO(ElementAccessExpression): flowLoopCaches[id] */ TODO || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): flowLoopCaches[id] = new Map<string, Type>() */ TODO)
			key := getOrSetCacheKey()
			if !key {
				return declaredType
			}
			cached := cache.get(key)
			if cached {
				return cached
			}
			/* TODO(ForStatement): for (let i = flowLoopStart; i < flowLoopCount; i++) {                 if (flowLoopNodes[i] === flow && flowLoopKeys[i] === key && flowLoopTypes[i].length) {                     return createFlowType(getUnionOrEvolvingArrayType(flowLoopTypes[i], UnionReduction.Literal), /*incomplete* / true);                 }             } */
			var antecedentTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			subtypeReduction := false
			var firstAntecedentType *FlowType
			for _, antecedent := range flow.antecedent {
				var flowType TODO
				if !firstAntecedentType {
					flowType = /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): firstAntecedentType = getTypeAtFlowNode(antecedent) */ TODO
				} else {
					/* TODO(ElementAccessExpression): flowLoopNodes[flowLoopCount] */ TODO = flow
					/* TODO(ElementAccessExpression): flowLoopKeys[flowLoopCount] */ TODO = key
					/* TODO(ElementAccessExpression): flowLoopTypes[flowLoopCount] */ TODO = antecedentTypes
					flowLoopCount++
					saveFlowTypeCache := flowTypeCache
					flowTypeCache = nil
					flowType = getTypeAtFlowNode(antecedent)
					flowTypeCache = saveFlowTypeCache
					flowLoopCount--
					cached := cache.get(key)
					if cached {
						return cached
					}
				}
				type_ := getTypeFromFlowType(flowType)
				pushIfUnique(antecedentTypes, type_)
				if !isTypeSubsetOf(type_, initialType) {
					subtypeReduction = true
				}
				if type_ == declaredType {
					break
				}
			}
			result := getUnionOrEvolvingArrayType(antecedentTypes /* TODO(ConditionalExpression): subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal */, TODO)
			if isIncomplete(firstAntecedentType) {
				return createFlowType(result, true)
			}
			cache.set(key, result)
			return result
		}
		getUnionOrEvolvingArrayType := func(types []Type, subtypeReduction UnionReduction) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if isEvolvingArrayTypeList(types) {
				return getEvolvingArrayType(getUnionType(map_(types, getElementTypeOfEvolvingArrayType)))
			}
			result := recombineUnknownType(getUnionType(sameMap(types, finalizeEvolvingArrayType), subtypeReduction))
			if result != declaredType && result.flags&declaredType.flags&TypeFlagsUnion && arrayIsEqualTo((result).types, (declaredType).types) {
				return declaredType
			}
			return result
		}
		getCandidateDiscriminantPropertyAccess := func(expr Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessExpression | undefined */ TODO {
			if isBindingPattern(reference) || isFunctionExpressionOrArrowFunction(reference) || isObjectLiteralMethod(reference) {
				if isIdentifier(expr) {
					symbol := getResolvedSymbol(expr)
					declaration := symbol.valueDeclaration
					if declaration && (isBindingElement(declaration) || isParameter(declaration)) && reference == declaration.parent && !declaration.initializer && !declaration.dotDotDotToken {
						return declaration
					}
				}
			} else if isAccessExpression(expr) {
				if isMatchingReference(reference, expr.expression) {
					return expr
				}
			} else if isIdentifier(expr) {
				symbol := getResolvedSymbol(expr)
				if isConstantVariable(symbol) {
					declaration := symbol.valueDeclaration
					if isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && isAccessExpression(declaration.initializer) && isMatchingReference(reference, declaration.initializer.expression) {
						return declaration.initializer
					}
					if isBindingElement(declaration) && !declaration.initializer {
						parent := declaration.parent.parent
						if isVariableDeclaration(parent) && !parent.type_ && parent.initializer && (isIdentifier(parent.initializer) || isAccessExpression(parent.initializer)) && isMatchingReference(reference, parent.initializer) {
							return declaration
						}
					}
				}
			}
			return nil
		}
		getDiscriminantPropertyAccess := func(expr Expression, computedType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessExpression | undefined */ TODO {
			if declaredType.flags&TypeFlagsUnion || computedType.flags&TypeFlagsUnion {
				access := getCandidateDiscriminantPropertyAccess(expr)
				if access {
					name := getAccessedPropertyName(access)
					if name {
						type_ := /* TODO(ConditionalExpression): declaredType.flags & TypeFlags.Union && isTypeSubsetOf(computedType, declaredType) ? declaredType : computedType */ TODO
						if isDiscriminantProperty(type_, name) {
							return access
						}
					}
				}
			}
			return nil
		}
		narrowTypeByDiscriminant := func(type_ Type, access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, narrowType func(t Type) Type) Type {
			propName := getAccessedPropertyName(access)
			if propName == nil {
				return type_
			}
			optionalChain := isOptionalChain(access)
			removeNullable := strictNullChecks && (optionalChain || isNonNullAccess(access)) && maybeTypeOfKind(type_, TypeFlagsNullable)
			propType := getTypeOfPropertyOfType( /* TODO(ConditionalExpression): removeNullable ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO, propName)
			if !propType {
				return type_
			}
			propType = /* TODO(ConditionalExpression): removeNullable && optionalChain ? getOptionalType(propType) : propType */ TODO
			narrowedPropType := narrowType(propType)
			return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				discriminantType := getTypeOfPropertyOrIndexSignatureOfType(t, propName) || unknownType
				return !(discriminantType.flags & TypeFlagsNever) && !(narrowedPropType.flags & TypeFlagsNever) && areTypesComparable(narrowedPropType, discriminantType)
			})
		}
		narrowTypeByDiscriminantProperty := func(type_ Type, access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, operator SyntaxKind, value Expression, assumeTrue bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if (operator == SyntaxKindEqualsEqualsEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken) && type_.flags&TypeFlagsUnion {
				keyPropertyName := getKeyPropertyName(type_)
				if keyPropertyName && keyPropertyName == getAccessedPropertyName(access) {
					candidate := getConstituentTypeForKeyType(type_, getTypeOfExpression(value))
					if candidate {
						return /* TODO(ConditionalExpression): operator === (assumeTrue ? SyntaxKind.EqualsEqualsEqualsToken : SyntaxKind.ExclamationEqualsEqualsToken) ? candidate :                             isUnitType(getTypeOfPropertyOfType(candidate, keyPropertyName) || unknownType) ? removeType(type, candidate) :                             type */ TODO
					}
				}
			}
			return narrowTypeByDiscriminant(type_, access, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return narrowTypeByEquality(t, operator, value, assumeTrue)
			})
		}
		narrowTypeBySwitchOnDiscriminantProperty := func(type_ Type, access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, data FlowSwitchClauseData) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if data.clauseStart < data.clauseEnd && type_.flags&TypeFlagsUnion && getKeyPropertyName(type_) == getAccessedPropertyName(access) {
				clauseTypes := getSwitchClauseTypes(data.switchStatement).slice(data.clauseStart, data.clauseEnd)
				candidate := getUnionType(map_(clauseTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					return getConstituentTypeForKeyType(type_, t) || unknownType
				}))
				if candidate != unknownType {
					return candidate
				}
			}
			return narrowTypeByDiscriminant(type_, access, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return narrowTypeBySwitchOnDiscriminant(t, data)
			})
		}
		narrowTypeByTruthiness := func(type_ Type, expr Expression, assumeTrue bool) Type {
			if isMatchingReference(reference, expr) {
				return getAdjustedTypeWithFacts(type_ /* TODO(ConditionalExpression): assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy */, TODO)
			}
			if strictNullChecks && assumeTrue && optionalChainContainsReference(expr, reference) {
				type_ = getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
			}
			access := getDiscriminantPropertyAccess(expr, type_)
			if access {
				return narrowTypeByDiscriminant(type_, access, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					return getTypeWithFacts(t /* TODO(ConditionalExpression): assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy */, TODO)
				})
			}
			return type_
		}
		isTypePresencePossible := func(type_ Type, propName __String, assumeTrue bool) /* TODO inferred type boolean */ TODO {
			prop := getPropertyOfType(type_, propName)
			return /* TODO(ConditionalExpression): prop ?                 !!(prop.flags & SymbolFlags.Optional || getCheckFlags(prop) & CheckFlags.Partial) || assumeTrue :                 !!getApplicableIndexInfoForName(type, propName) || !assumeTrue */ TODO
		}
		narrowTypeByInKeyword := func(type_ Type, nameType /* TODO(UnionType): StringLiteralType | NumberLiteralType | UniqueESSymbolType */ any, assumeTrue bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			name := getPropertyNameFromType(nameType)
			isKnownProperty := someType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return isTypePresencePossible(t, name, true)
			})
			if isKnownProperty {
				return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return isTypePresencePossible(t, name, assumeTrue)
				})
			}
			if assumeTrue {
				recordSymbol := getGlobalRecordSymbol()
				if recordSymbol {
					return getIntersectionType( /* TODO(ArrayLiteralExpression): [type, getTypeAliasInstantiation(recordSymbol, [nameType, unknownType])] */ TODO)
				}
			}
			return type_
		}
		narrowTypeByBooleanComparison := func(type_ Type, expr Expression, bool BooleanLiteral, operator BinaryOperator, assumeTrue bool) Type {
			assumeTrue = (assumeTrue != (bool.kind == SyntaxKindTrueKeyword)) != (operator != SyntaxKindExclamationEqualsEqualsToken && operator != SyntaxKindExclamationEqualsToken)
			return narrowType(type_, expr, assumeTrue)
		}
		narrowTypeByBinaryExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
			switch expr.operatorToken.kind {
			case SyntaxKindEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindBarBarEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindAmpersandAmpersandEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindQuestionQuestionEqualsToken:
				return narrowTypeByTruthiness(narrowType(type_, expr.right, assumeTrue), expr.left, assumeTrue)
			case SyntaxKindEqualsEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindExclamationEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindEqualsEqualsEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindExclamationEqualsEqualsToken:
				operator := expr.operatorToken.kind
				left := getReferenceCandidate(expr.left)
				right := getReferenceCandidate(expr.right)
				if left.kind == SyntaxKindTypeOfExpression && isStringLiteralLike(right) {
					return narrowTypeByTypeof(type_, left, operator, right, assumeTrue)
				}
				if right.kind == SyntaxKindTypeOfExpression && isStringLiteralLike(left) {
					return narrowTypeByTypeof(type_, right, operator, left, assumeTrue)
				}
				if isMatchingReference(reference, left) {
					return narrowTypeByEquality(type_, operator, right, assumeTrue)
				}
				if isMatchingReference(reference, right) {
					return narrowTypeByEquality(type_, operator, left, assumeTrue)
				}
				if strictNullChecks {
					if optionalChainContainsReference(left, reference) {
						type_ = narrowTypeByOptionalChainContainment(type_, operator, right, assumeTrue)
					} else if optionalChainContainsReference(right, reference) {
						type_ = narrowTypeByOptionalChainContainment(type_, operator, left, assumeTrue)
					}
				}
				leftAccess := getDiscriminantPropertyAccess(left, type_)
				if leftAccess {
					return narrowTypeByDiscriminantProperty(type_, leftAccess, operator, right, assumeTrue)
				}
				rightAccess := getDiscriminantPropertyAccess(right, type_)
				if rightAccess {
					return narrowTypeByDiscriminantProperty(type_, rightAccess, operator, left, assumeTrue)
				}
				if isMatchingConstructorReference(left) {
					return narrowTypeByConstructor(type_, operator, right, assumeTrue)
				}
				if isMatchingConstructorReference(right) {
					return narrowTypeByConstructor(type_, operator, left, assumeTrue)
				}
				if isBooleanLiteral(right) && !isAccessExpression(left) {
					return narrowTypeByBooleanComparison(type_, left, right, operator, assumeTrue)
				}
				if isBooleanLiteral(left) && !isAccessExpression(right) {
					return narrowTypeByBooleanComparison(type_, right, left, operator, assumeTrue)
				}
				break
			case SyntaxKindInstanceOfKeyword:
				return narrowTypeByInstanceof(type_, expr, assumeTrue)
			case SyntaxKindInKeyword:
				if isPrivateIdentifier(expr.left) {
					return narrowTypeByPrivateIdentifierInInExpression(type_, expr, assumeTrue)
				}
				target := getReferenceCandidate(expr.right)
				if containsMissingType(type_) && isAccessExpression(reference) && isMatchingReference(reference.expression, target) {
					leftType := getTypeOfExpression(expr.left)
					if isTypeUsableAsPropertyName(leftType) && getAccessedPropertyName(reference) == getPropertyNameFromType(leftType) {
						return getTypeWithFacts(type_ /* TODO(ConditionalExpression): assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined */, TODO)
					}
				}
				if isMatchingReference(reference, target) {
					leftType := getTypeOfExpression(expr.left)
					if isTypeUsableAsPropertyName(leftType) {
						return narrowTypeByInKeyword(type_, leftType, assumeTrue)
					}
				}
				break
			case SyntaxKindCommaToken:
				return narrowType(type_, expr.right, assumeTrue)
			case SyntaxKindAmpersandAmpersandToken:
				return /* TODO(ConditionalExpression): assumeTrue ?                         narrowType(narrowType(type, expr.left, /*assumeTrue* / true), expr.right, /*assumeTrue* / true) :                         getUnionType([narrowType(type, expr.left, /*assumeTrue* / false), narrowType(type, expr.right, /*assumeTrue* / false)]) */ TODO
			case SyntaxKindBarBarToken:
				return /* TODO(ConditionalExpression): assumeTrue ?                         getUnionType([narrowType(type, expr.left, /*assumeTrue* / true), narrowType(type, expr.right, /*assumeTrue* / true)]) :                         narrowType(narrowType(type, expr.left, /*assumeTrue* / false), expr.right, /*assumeTrue* / false) */ TODO
			}
			return type_
		}
		narrowTypeByPrivateIdentifierInInExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
			target := getReferenceCandidate(expr.right)
			if !isMatchingReference(reference, target) {
				return type_
			}
			Debug.assertNode(expr.left, isPrivateIdentifier)
			symbol := getSymbolForPrivateIdentifierExpression(expr.left)
			if symbol == nil {
				return type_
			}
			classSymbol := symbol.parent
			targetType := /* TODO(ConditionalExpression): hasStaticModifier(Debug.checkDefined(symbol.valueDeclaration, "should always have a declaration"))                 ? getTypeOfSymbol(classSymbol) as InterfaceType                 : getDeclaredTypeOfSymbol(classSymbol) */ TODO
			return getNarrowedType(type_, targetType, assumeTrue, true)
		}
		narrowTypeByOptionalChainContainment := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
			equalsOperator := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindEqualsEqualsEqualsToken
			nullableFlags := /* TODO(ConditionalExpression): operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? TypeFlags.Nullable : TypeFlags.Undefined */ TODO
			valueType := getTypeOfExpression(value)
			removeNullable := equalsOperator != assumeTrue && everyType(valueType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return !!(t.flags & nullableFlags)
			}) || equalsOperator == assumeTrue && everyType(valueType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return !(t.flags & (TypeFlagsAnyOrUnknown | nullableFlags))
			})
			return /* TODO(ConditionalExpression): removeNullable ? getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO
		}
		narrowTypeByEquality := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
			if type_.flags & TypeFlagsAny {
				return type_
			}
			if operator == SyntaxKindExclamationEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken {
				assumeTrue = !assumeTrue
			}
			valueType := getTypeOfExpression(value)
			doubleEquals := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindExclamationEqualsToken
			if valueType.flags & TypeFlagsNullable {
				if !strictNullChecks {
					return type_
				}
				facts := /* TODO(ConditionalExpression): doubleEquals ?                     assumeTrue ? TypeFacts.EQUndefinedOrNull : TypeFacts.NEUndefinedOrNull :                     valueType.flags & TypeFlags.Null ?                     assumeTrue ? TypeFacts.EQNull : TypeFacts.NENull :                     assumeTrue ? TypeFacts.EQUndefined : TypeFacts.NEUndefined */ TODO
				return getAdjustedTypeWithFacts(type_, facts)
			}
			if assumeTrue {
				if !doubleEquals && (type_.flags&TypeFlagsUnknown || someType(type_, isEmptyAnonymousObjectType)) {
					if valueType.flags&(TypeFlagsPrimitive|TypeFlagsNonPrimitive) || isEmptyAnonymousObjectType(valueType) {
						return valueType
					}
					if valueType.flags & TypeFlagsObject {
						return nonPrimitiveType
					}
				}
				filteredType := filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return areTypesComparable(t, valueType) || doubleEquals && isCoercibleUnderDoubleEquals(t, valueType)
				})
				return replacePrimitivesWithLiterals(filteredType, valueType)
			}
			if isUnitType(valueType) {
				return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !(isUnitLikeType(t) && areTypesComparable(t, valueType))
				})
			}
			return type_
		}
		narrowTypeByTypeof := func(type_ Type, typeOfExpr TypeOfExpression, operator SyntaxKind, literal LiteralExpression, assumeTrue bool) Type {
			if operator == SyntaxKindExclamationEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken {
				assumeTrue = !assumeTrue
			}
			target := getReferenceCandidate(typeOfExpr.expression)
			if !isMatchingReference(reference, target) {
				if strictNullChecks && optionalChainContainsReference(target, reference) && assumeTrue == (literal.text != "undefined") {
					type_ = getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
				}
				propertyAccess := getDiscriminantPropertyAccess(target, type_)
				if propertyAccess {
					return narrowTypeByDiscriminant(type_, propertyAccess, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
						return narrowTypeByLiteralExpression(t, literal, assumeTrue)
					})
				}
				return type_
			}
			return narrowTypeByLiteralExpression(type_, literal, assumeTrue)
		}
		narrowTypeByLiteralExpression := func(type_ Type, literal LiteralExpression, assumeTrue bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return /* TODO(ConditionalExpression): assumeTrue ?                 narrowTypeByTypeName(type, literal.text) :                 getAdjustedTypeWithFacts(type, typeofNEFacts.get(literal.text) || TypeFacts.TypeofNEHostObject) */ TODO
		}
		narrowTypeBySwitchOptionalChainContainment := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData, clauseCheck func(type_ Type) bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			everyClauseChecks := clauseStart != clauseEnd && every(getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd), clauseCheck)
			return /* TODO(ConditionalExpression): everyClauseChecks ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO
		}
		narrowTypeBySwitchOnDiscriminant := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			switchTypes := getSwitchClauseTypes(switchStatement)
			if !switchTypes.length {
				return type_
			}
			clauseTypes := switchTypes.slice(clauseStart, clauseEnd)
			hasDefaultClause := clauseStart == clauseEnd || contains(clauseTypes, neverType)
			if (type_.flags & TypeFlagsUnknown) && !hasDefaultClause {
				var groundClauseTypes /* TODO(ArrayType): Type[] */ any
				/* TODO(ForStatement): for (let i = 0; i < clauseTypes.length; i += 1) {                     const t = clauseTypes[i];                     if (t.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) {                         if (groundClauseTypes !== undefined) {                             groundClauseTypes.push(t);                         }                     }                     else if (t.flags & TypeFlags.Object) {                         if (groundClauseTypes === undefined) {                             groundClauseTypes = clauseTypes.slice(0, i);                         }                         groundClauseTypes.push(nonPrimitiveType);                     }                     else {                         return type;                     }                 } */
				return getUnionType( /* TODO(ConditionalExpression): groundClauseTypes === undefined ? clauseTypes : groundClauseTypes */ TODO)
			}
			discriminantType := getUnionType(clauseTypes)
			caseType := /* TODO(ConditionalExpression): discriminantType.flags & TypeFlags.Never ? neverType :                 replacePrimitivesWithLiterals(filterType(type, t => areTypesComparable(discriminantType, t)), discriminantType) */ TODO
			if !hasDefaultClause {
				return caseType
			}
			defaultType := filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return !(isUnitLikeType(t) && contains(switchTypes /* TODO(ConditionalExpression): t.flags & TypeFlags.Undefined ? undefinedType : getRegularTypeOfLiteralType(extractUnitType(t)) */, TODO))
			})
			return /* TODO(ConditionalExpression): caseType.flags & TypeFlags.Never ? defaultType : getUnionType([caseType, defaultType]) */ TODO
		}
		narrowTypeByTypeName := func(type_ Type, typeName string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			switch typeName {
			case "string":
				return narrowTypeByTypeFacts(type_, stringType, TypeFactsTypeofEQString)
			case "number":
				return narrowTypeByTypeFacts(type_, numberType, TypeFactsTypeofEQNumber)
			case "bigint":
				return narrowTypeByTypeFacts(type_, bigintType, TypeFactsTypeofEQBigInt)
			case "boolean":
				return narrowTypeByTypeFacts(type_, booleanType, TypeFactsTypeofEQBoolean)
			case "symbol":
				return narrowTypeByTypeFacts(type_, esSymbolType, TypeFactsTypeofEQSymbol)
			case "object":
				return /* TODO(ConditionalExpression): type.flags & TypeFlags.Any ? type : getUnionType([narrowTypeByTypeFacts(type, nonPrimitiveType, TypeFacts.TypeofEQObject), narrowTypeByTypeFacts(type, nullType, TypeFacts.EQNull)]) */ TODO
			case "function":
				return /* TODO(ConditionalExpression): type.flags & TypeFlags.Any ? type : narrowTypeByTypeFacts(type, globalFunctionType, TypeFacts.TypeofEQFunction) */ TODO
			case "undefined":
				return narrowTypeByTypeFacts(type_, undefinedType, TypeFactsEQUndefined)
			}
			return narrowTypeByTypeFacts(type_, nonPrimitiveType, TypeFactsTypeofEQHostObject)
		}
		narrowTypeByTypeFacts := func(type_ Type, impliedType Type, facts TypeFacts) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return /* TODO(ConditionalExpression): isTypeRelatedTo(t, impliedType, strictSubtypeRelation) ? hasTypeFacts(t, facts) ? t : neverType :                     // We next check if the consituent is a supertype of the implied type. If so, we substitute the implied                     // type. This handles top types like `unknown` and `{}`, and supertypes like `{ toString(): string }`.                     isTypeSubtypeOf(impliedType, t) ? impliedType :                     // Neither the constituent nor the implied type is a subtype of the other, however their domains may still                     // overlap. For example, an unconstrained type parameter and type `string`. If the type facts indicate                     // possible overlap, we form an intersection. Otherwise, we eliminate the constituent.                     hasTypeFacts(t, facts) ? getIntersectionType([t, impliedType]) :                     neverType */ TODO
			})
		}
		narrowTypeBySwitchOnTypeOf := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
			witnesses := getSwitchClauseTypeOfWitnesses(switchStatement)
			if !witnesses {
				return type_
			}
			defaultIndex := findIndex(switchStatement.caseBlock.clauses, func(clause /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").CaseClause | import("/home/jabaile/work/TypeScript/src/compiler/types").DefaultClause */ TODO) /* TODO inferred type boolean */ TODO {
				return clause.kind == SyntaxKindDefaultClause
			})
			hasDefaultClause := clauseStart == clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd)
			if hasDefaultClause {
				notEqualFacts := getNotEqualFactsFromTypeofSwitch(clauseStart, clauseEnd, witnesses)
				return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return getTypeFacts(t, notEqualFacts) == notEqualFacts
				})
			}
			clauseWitnesses := witnesses.slice(clauseStart, clauseEnd)
			return getUnionType(map_(clauseWitnesses, func(text /* TODO inferred type string | undefined */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return /* TODO(ConditionalExpression): text ? narrowTypeByTypeName(type, text) : neverType */ TODO
			}))
		}
		narrowTypeBySwitchOnTrue := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
			defaultIndex := findIndex(switchStatement.caseBlock.clauses, func(clause /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").CaseClause | import("/home/jabaile/work/TypeScript/src/compiler/types").DefaultClause */ TODO) /* TODO inferred type boolean */ TODO {
				return clause.kind == SyntaxKindDefaultClause
			})
			hasDefaultClause := clauseStart == clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd)
			/* TODO(ForStatement): for (let i = 0; i < clauseStart; i++) {                 const clause = switchStatement.caseBlock.clauses[i];                 if (clause.kind === SyntaxKind.CaseClause) {                     type = narrowType(type, clause.expression, /*assumeTrue* / false);                 }             } */
			if hasDefaultClause {
				/* TODO(ForStatement): for (let i = clauseEnd; i < switchStatement.caseBlock.clauses.length; i++) {                     const clause = switchStatement.caseBlock.clauses[i];                     if (clause.kind === SyntaxKind.CaseClause) {                         type = narrowType(type, clause.expression, /*assumeTrue* / false);                     }                 } */
				return type_
			}
			clauses := switchStatement.caseBlock.clauses.slice(clauseStart, clauseEnd)
			return getUnionType(map_(clauses, func(clause /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").CaseOrDefaultClause */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return /* TODO(ConditionalExpression): clause.kind === SyntaxKind.CaseClause ? narrowType(type, clause.expression, /*assumeTrue* / true) : neverType */ TODO
			}))
		}
		isMatchingConstructorReference := func(expr Expression) /* TODO inferred type boolean */ TODO {
			return (isPropertyAccessExpression(expr) && idText(expr.name) == "constructor" || isElementAccessExpression(expr) && isStringLiteralLike(expr.argumentExpression) && expr.argumentExpression.text == "constructor") && isMatchingReference(reference, expr.expression)
		}
		narrowTypeByConstructor := func(type_ Type, operator SyntaxKind, identifier Expression, assumeTrue bool) Type {
			if /* TODO(ConditionalExpression): assumeTrue ? (operator !== SyntaxKind.EqualsEqualsToken && operator !== SyntaxKind.EqualsEqualsEqualsToken) : (operator !== SyntaxKind.ExclamationEqualsToken && operator !== SyntaxKind.ExclamationEqualsEqualsToken) */ TODO {
				return type_
			}
			identifierType := getTypeOfExpression(identifier)
			if !isFunctionType(identifierType) && !isConstructorType(identifierType) {
				return type_
			}
			prototypeProperty := getPropertyOfType(identifierType, "prototype")
			if !prototypeProperty {
				return type_
			}
			prototypeType := getTypeOfSymbol(prototypeProperty)
			candidate := /* TODO(ConditionalExpression): !isTypeAny(prototypeType) ? prototypeType : undefined */ TODO
			if !candidate || candidate == globalObjectType || candidate == globalFunctionType {
				return type_
			}
			if isTypeAny(type_) {
				return candidate
			}
			return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return isConstructedBy(t, candidate)
			})
			isConstructedBy := func(source Type, target Type) /* TODO inferred type boolean */ TODO {
				if source.flags&TypeFlagsObject && getObjectFlags(source)&ObjectFlagsClass || target.flags&TypeFlagsObject && getObjectFlags(target)&ObjectFlagsClass {
					return source.symbol == target.symbol
				}
				return isTypeSubtypeOf(source, target)
			}
		}
		narrowTypeByInstanceof := func(type_ Type, expr InstanceofExpression, assumeTrue bool) Type {
			left := getReferenceCandidate(expr.left)
			if !isMatchingReference(reference, left) {
				if assumeTrue && strictNullChecks && optionalChainContainsReference(left, reference) {
					return getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
				}
				return type_
			}
			right := expr.right
			rightType := getTypeOfExpression(right)
			if !isTypeDerivedFrom(rightType, globalObjectType) {
				return type_
			}
			signature := getEffectsSignature(expr)
			predicate := signature && getTypePredicateOfSignature(signature)
			if predicate && predicate.kind == TypePredicateKindIdentifier && predicate.parameterIndex == 0 {
				return getNarrowedType(type_, predicate.type_, assumeTrue, true)
			}
			if !isTypeDerivedFrom(rightType, globalFunctionType) {
				return type_
			}
			instanceType := mapType(rightType, getInstanceType)
			if isTypeAny(type_) && (instanceType == globalObjectType || instanceType == globalFunctionType) || !assumeTrue && !(instanceType.flags&TypeFlagsObject && !isEmptyAnonymousObjectType(instanceType)) {
				return type_
			}
			return getNarrowedType(type_, instanceType, assumeTrue, true)
		}
		getInstanceType := func(constructorType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			prototypePropertyType := getTypeOfPropertyOfType(constructorType, "prototype")
			if prototypePropertyType && !isTypeAny(prototypePropertyType) {
				return prototypePropertyType
			}
			constructSignatures := getSignaturesOfType(constructorType, SignatureKindConstruct)
			if constructSignatures.length {
				return getUnionType(map_(constructSignatures, func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					return getReturnTypeOfSignature(getErasedSignature(signature))
				}))
			}
			return emptyObjectType
		}
		getNarrowedType := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) Type {
			key := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? `N${getTypeId(type)},${getTypeId(candidate)},${(assumeTrue ? 1 : 0) | (checkDerived ? 2 : 0)}` : undefined */ TODO
			return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, getNarrowedTypeWorker(type, candidate, assumeTrue, checkDerived)) */ TODO
		}
		getNarrowedTypeWorker := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if !assumeTrue {
				if type_ == candidate {
					return neverType
				}
				if checkDerived {
					return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
						return !isTypeDerivedFrom(t, candidate)
					})
				}
				trueType := getNarrowedType(type_, candidate, true, false)
				return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !isTypeSubsetOf(t, trueType)
				})
			}
			if type_.flags & TypeFlagsAnyOrUnknown {
				return candidate
			}
			if type_ == candidate {
				return candidate
			}
			isRelated := /* TODO(ConditionalExpression): checkDerived ? isTypeDerivedFrom : isTypeSubtypeOf */ TODO
			keyPropertyName := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? getKeyPropertyName(type as UnionType) : undefined */ TODO
			narrowedType := mapType(candidate, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				discriminant := keyPropertyName && getTypeOfPropertyOfType(c, keyPropertyName)
				matching := discriminant && getConstituentTypeForKeyType(type_, discriminant)
				directlyRelated := mapType(matching || type_ /* TODO(ConditionalExpression): checkDerived ?                         t => isTypeDerivedFrom(t, c) ? t : isTypeDerivedFrom(c, t) ? c : neverType :                         t => isTypeStrictSubtypeOf(t, c) ? t : isTypeStrictSubtypeOf(c, t) ? c : isTypeSubtypeOf(t, c) ? t : isTypeSubtypeOf(c, t) ? c : neverType */, TODO)
				return /* TODO(ConditionalExpression): directlyRelated.flags & TypeFlags.Never ?                     mapType(type, t => maybeTypeOfKind(t, TypeFlags.Instantiable) && isRelated(c, getBaseConstraintOfType(t) || unknownType) ? getIntersectionType([t, c]) : neverType) :                     directlyRelated */ TODO
			})
			return /* TODO(ConditionalExpression): !(narrowedType.flags & TypeFlags.Never) ? narrowedType :                 isTypeSubtypeOf(candidate, type) ? candidate :                 isTypeAssignableTo(type, candidate) ? type :                 isTypeAssignableTo(candidate, type) ? candidate :                 getIntersectionType([type, candidate]) */ TODO
		}
		narrowTypeByCallExpression := func(type_ Type, callExpression CallExpression, assumeTrue bool) Type {
			if hasMatchingArgument(callExpression, reference) {
				signature := /* TODO(ConditionalExpression): assumeTrue || !isCallChain(callExpression) ? getEffectsSignature(callExpression) : undefined */ TODO
				predicate := signature && getTypePredicateOfSignature(signature)
				if predicate && (predicate.kind == TypePredicateKindThis || predicate.kind == TypePredicateKindIdentifier) {
					return narrowTypeByTypePredicate(type_, predicate, callExpression, assumeTrue)
				}
			}
			if containsMissingType(type_) && isAccessExpression(reference) && isPropertyAccessExpression(callExpression.expression) {
				callAccess := callExpression.expression
				if isMatchingReference(reference.expression, getReferenceCandidate(callAccess.expression)) && isIdentifier(callAccess.name) && callAccess.name.escapedText == "hasOwnProperty" && callExpression.arguments.length == 1 {
					argument := /* TODO(ElementAccessExpression): callExpression.arguments[0] */ TODO
					if isStringLiteralLike(argument) && getAccessedPropertyName(reference) == escapeLeadingUnderscores(argument.text) {
						return getTypeWithFacts(type_ /* TODO(ConditionalExpression): assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined */, TODO)
					}
				}
			}
			return type_
		}
		narrowTypeByTypePredicate := func(type_ Type, predicate TypePredicate, callExpression CallExpression, assumeTrue bool) Type {
			if predicate.type_ && !(isTypeAny(type_) && (predicate.type_ == globalObjectType || predicate.type_ == globalFunctionType)) {
				predicateArgument := getTypePredicateArgument(predicate, callExpression)
				if predicateArgument {
					if isMatchingReference(reference, predicateArgument) {
						return getNarrowedType(type_, predicate.type_, assumeTrue, false)
					}
					if strictNullChecks && optionalChainContainsReference(predicateArgument, reference) && (assumeTrue && !(hasTypeFacts(predicate.type_, TypeFactsEQUndefined)) || !assumeTrue && everyType(predicate.type_, isNullableType)) {
						type_ = getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
					}
					access := getDiscriminantPropertyAccess(predicateArgument, type_)
					if access {
						return narrowTypeByDiscriminant(type_, access, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
							return getNarrowedType(t, predicate.type_, assumeTrue, false)
						})
					}
				}
			}
			return type_
		}
		narrowType := func(type_ Type, expr Expression, assumeTrue bool) Type {
			if isExpressionOfOptionalChainRoot(expr) || isBinaryExpression(expr.parent) && (expr.parent.operatorToken.kind == SyntaxKindQuestionQuestionToken || expr.parent.operatorToken.kind == SyntaxKindQuestionQuestionEqualsToken) && expr.parent.left == expr {
				return narrowTypeByOptionality(type_, expr, assumeTrue)
			}
			switch expr.kind {
			case SyntaxKindIdentifier:
				if !isMatchingReference(reference, expr) && inlineLevel < 5 {
					symbol := getResolvedSymbol(expr)
					if isConstantVariable(symbol) {
						declaration := symbol.valueDeclaration
						if declaration && isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && isConstantReference(reference) {
							inlineLevel++
							result := narrowType(type_, declaration.initializer, assumeTrue)
							inlineLevel--
							return result
						}
					}
				}
				fallthrough
			case SyntaxKindThisKeyword:
				fallthrough // TODO: merge cases
			case SyntaxKindSuperKeyword:
				fallthrough // TODO: merge cases
			case SyntaxKindPropertyAccessExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindElementAccessExpression:
				return narrowTypeByTruthiness(type_, expr, assumeTrue)
			case SyntaxKindCallExpression:
				return narrowTypeByCallExpression(type_, expr, assumeTrue)
			case SyntaxKindParenthesizedExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindNonNullExpression:
				return narrowType(type_, (expr).expression, assumeTrue)
			case SyntaxKindBinaryExpression:
				return narrowTypeByBinaryExpression(type_, expr, assumeTrue)
			case SyntaxKindPrefixUnaryExpression:
				if (expr).operator == SyntaxKindExclamationToken {
					return narrowType(type_, (expr).operand, !assumeTrue)
				}
				break
			}
			return type_
		}
		narrowTypeByOptionality := func(type_ Type, expr Expression, assumePresent bool) Type {
			if isMatchingReference(reference, expr) {
				return getAdjustedTypeWithFacts(type_ /* TODO(ConditionalExpression): assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull */, TODO)
			}
			access := getDiscriminantPropertyAccess(expr, type_)
			if access {
				return narrowTypeByDiscriminant(type_, access, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					return getTypeWithFacts(t /* TODO(ConditionalExpression): assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull */, TODO)
				})
			}
			return type_
		}
	}
	getTypeOfSymbolAtLocation := func(symbol Symbol, location Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		symbol = getExportSymbolOfValueSymbolIfExported(symbol)
		if location.kind == SyntaxKindIdentifier || location.kind == SyntaxKindPrivateIdentifier {
			if isRightSideOfQualifiedNameOrPropertyAccess(location) {
				location = location.parent
			}
			if isExpressionNode(location) && (!isAssignmentTarget(location) || isWriteAccess(location)) {
				type_ := removeOptionalTypeMarker( /* TODO(ConditionalExpression): isWriteAccess(location) && location.kind === SyntaxKind.PropertyAccessExpression ?                         checkPropertyAccessExpression(location as PropertyAccessExpression, /*checkMode* / undefined, /*writeOnly* / true) :                         getTypeOfExpression(location as Expression) */ TODO)
				if getExportSymbolOfValueSymbolIfExported(getNodeLinks(location).resolvedSymbol) == symbol {
					return type_
				}
			}
		}
		if isDeclarationName(location) && isSetAccessor(location.parent) && getAnnotatedAccessorTypeNode(location.parent) {
			return getWriteTypeOfAccessors(location.parent.symbol)
		}
		return /* TODO(ConditionalExpression): isRightSideOfAccessExpression(location) && isWriteAccess(location.parent) ? getWriteTypeOfSymbol(symbol) : getNonMissingTypeOfSymbol(symbol) */ TODO
	}
	getControlFlowContainer := func(node Node) Node {
		return findAncestor(node.parent, func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
			return isFunctionLike(node) && !getImmediatelyInvokedFunctionExpression(node) || node.kind == SyntaxKindModuleBlock || node.kind == SyntaxKindSourceFile || node.kind == SyntaxKindPropertyDeclaration
		})
	}
	isSymbolAssignedDefinitely := func(symbol Symbol) /* TODO inferred type boolean */ TODO {
		if symbol.lastAssignmentPos != nil {
			return symbol.lastAssignmentPos < 0
		}
		return isSymbolAssigned(symbol) && symbol.lastAssignmentPos != nil && symbol.lastAssignmentPos < 0
	}
	isSymbolAssigned := func(symbol Symbol) /* TODO inferred type boolean */ TODO {
		return !isPastLastAssignment(symbol, nil)
	}
	isPastLastAssignment := func(symbol Symbol, location Node) /* TODO inferred type boolean | undefined */ TODO {
		parent := findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile)
		if !parent {
			return false
		}
		links := getNodeLinks(parent)
		if !(links.flags & NodeCheckFlagsAssignmentsMarked) {
			links.flags |= NodeCheckFlagsAssignmentsMarked
			if !hasParentWithAssignmentsMarked(parent) {
				markNodeAssignments(parent)
			}
		}
		return !symbol.lastAssignmentPos || location && Math.abs(symbol.lastAssignmentPos) < location.pos
	}
	isSomeSymbolAssigned := func(rootDeclaration Node) /* TODO inferred type boolean */ TODO {
		Debug.assert(isVariableDeclaration(rootDeclaration) || isParameter(rootDeclaration))
		return isSomeSymbolAssignedWorker(rootDeclaration.name)
	}
	isSomeSymbolAssignedWorker := func(node BindingName) bool {
		if node.kind == SyntaxKindIdentifier {
			return isSymbolAssigned(getSymbolOfDeclaration(node.parent))
		}
		return some(node.elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").OmittedExpression */ TODO) /* TODO inferred type boolean */ TODO {
			return e.kind != SyntaxKindOmittedExpression && isSomeSymbolAssignedWorker(e.name)
		})
	}
	hasParentWithAssignmentsMarked := func(node Node) /* TODO inferred type boolean */ TODO {
		return !!findAncestor(node.parent, func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
			return isFunctionOrSourceFile(node) && !!(getNodeLinks(node).flags & NodeCheckFlagsAssignmentsMarked)
		})
	}
	isFunctionOrSourceFile := func(node Node) /* TODO inferred type boolean */ TODO {
		return isFunctionLikeDeclaration(node) || isSourceFile(node)
	}
	markNodeAssignments := func(node Node) {
		switch node.kind {
		case SyntaxKindIdentifier:
			assigmentTarget := getAssignmentTargetKind(node)
			if assigmentTarget != AssignmentKindNone {
				symbol := getResolvedSymbol(node)
				hasDefiniteAssignment := assigmentTarget == AssignmentKindDefinite || (symbol.lastAssignmentPos != nil && symbol.lastAssignmentPos < 0)
				if isParameterOrMutableLocalVariable(symbol) {
					if symbol.lastAssignmentPos == nil || Math.abs(symbol.lastAssignmentPos) != Number.MAX_VALUE {
						referencingFunction := findAncestor(node, isFunctionOrSourceFile)
						declaringFunction := findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile)
						symbol.lastAssignmentPos = /* TODO(ConditionalExpression): referencingFunction === declaringFunction ? extendAssignmentPosition(node, symbol.valueDeclaration!) : Number.MAX_VALUE */ TODO
					}
					if hasDefiniteAssignment && symbol.lastAssignmentPos > 0 {
						symbol.lastAssignmentPos *= -1
					}
				}
			}
			return
		case SyntaxKindExportSpecifier:
			exportDeclaration := (node).parent.parent
			name := (node).propertyName || (node).name
			if !(node).isTypeOnly && !exportDeclaration.isTypeOnly && !exportDeclaration.moduleSpecifier && name.kind != SyntaxKindStringLiteral {
				symbol := resolveEntityName(name, SymbolFlagsValue, true, true)
				if symbol && isParameterOrMutableLocalVariable(symbol) {
					sign := /* TODO(ConditionalExpression): symbol.lastAssignmentPos !== undefined && symbol.lastAssignmentPos < 0 ? -1 : 1 */ TODO
					symbol.lastAssignmentPos = /* TODO(AsteriskToken): * */ /* TODO(BinaryExpression): sign * Number.MAX_VALUE */ TODO
				}
			}
			return
		case SyntaxKindInterfaceDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeAliasDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindEnumDeclaration:
			return
		}
		if isTypeNode(node) {
			return
		}
		forEachChild(node, markNodeAssignments)
	}
	extendAssignmentPosition := func(node Node, declaration Declaration) /* TODO inferred type number */ TODO {
		pos := node.pos
		for node && node.pos > declaration.pos {
			switch node.kind {
			case SyntaxKindVariableStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindExpressionStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindIfStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindDoStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindWhileStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForInStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForOfStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindWithStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindSwitchStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindTryStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindClassDeclaration:
				pos = node.end
			}
			node = node.parent
		}
		return pos
	}
	isConstantVariable := func(symbol Symbol) /* TODO inferred type boolean | 0 */ TODO {
		return symbol.flags&SymbolFlagsVariable && (getDeclarationNodeFlagsFromSymbol(symbol)&NodeFlagsConstant) != 0
	}
	isParameterOrMutableLocalVariable := func(symbol Symbol) /* TODO inferred type boolean */ TODO {
		declaration := symbol.valueDeclaration && getRootDeclaration(symbol.valueDeclaration)
		return !!declaration && (isParameter(declaration) || isVariableDeclaration(declaration) && (isCatchClause(declaration.parent) || isMutableLocalVariableDeclaration(declaration)))
	}
	isMutableLocalVariableDeclaration := func(declaration VariableDeclaration) /* TODO inferred type boolean */ TODO {
		return !!(declaration.parent.flags & NodeFlagsLet) && !(getCombinedModifierFlags(declaration)&ModifierFlagsExport || declaration.parent.parent.kind == SyntaxKindVariableStatement && isGlobalSourceFile(declaration.parent.parent.parent))
	}
	parameterInitializerContainsUndefined := func(declaration ParameterDeclaration) bool {
		links := getNodeLinks(declaration)
		if links.parameterInitializerContainsUndefined == nil {
			if !pushTypeResolution(declaration, TypeSystemPropertyNameParameterInitializerContainsUndefined) {
				reportCircularityError(declaration.symbol)
				return true
			}
			containsUndefined := !!(hasTypeFacts(checkDeclarationInitializer(declaration, CheckModeNormal), TypeFactsIsUndefined))
			if !popTypeResolution() {
				reportCircularityError(declaration.symbol)
				return true
			}
			/* TODO(ExpressionStatement): links.parameterInitializerContainsUndefined ??= containsUndefined; */
		}
		return links.parameterInitializerContainsUndefined
	}
	removeOptionalityFromDeclaredType := func(declaredType Type, declaration VariableLikeDeclaration) Type {
		removeUndefined := strictNullChecks && declaration.kind == SyntaxKindParameter && declaration.initializer && hasTypeFacts(declaredType, TypeFactsIsUndefined) && !parameterInitializerContainsUndefined(declaration)
		return /* TODO(ConditionalExpression): removeUndefined ? getTypeWithFacts(declaredType, TypeFacts.NEUndefined) : declaredType */ TODO
	}
	isConstraintPosition := func(type_ Type, node Node) /* TODO inferred type boolean */ TODO {
		parent := node.parent
		return parent.kind == SyntaxKindPropertyAccessExpression || parent.kind == SyntaxKindQualifiedName || parent.kind == SyntaxKindCallExpression && (parent).expression == node || parent.kind == SyntaxKindNewExpression && (parent).expression == node || parent.kind == SyntaxKindElementAccessExpression && (parent).expression == node && !(someType(type_, isGenericTypeWithoutNullableConstraint) && isGenericIndexType(getTypeOfExpression((parent).argumentExpression)))
	}
	isGenericTypeWithUnionConstraint := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection ?             some((type as IntersectionType).types, isGenericTypeWithUnionConstraint) :             !!(type.flags & TypeFlags.Instantiable && getBaseConstraintOrType(type).flags & (TypeFlags.Nullable | TypeFlags.Union)) */ TODO
	}
	isGenericTypeWithoutNullableConstraint := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection ?             some((type as IntersectionType).types, isGenericTypeWithoutNullableConstraint) :             !!(type.flags & TypeFlags.Instantiable && !maybeTypeOfKind(getBaseConstraintOrType(type), TypeFlags.Nullable)) */ TODO
	}
	hasContextualTypeWithNoGenericTypes := func(node Node, checkMode *CheckMode) /* TODO inferred type boolean | undefined */ TODO {
		contextualType := (isIdentifier(node) || isPropertyAccessExpression(node) || isElementAccessExpression(node)) && !((isJsxOpeningElement(node.parent) || isJsxSelfClosingElement(node.parent)) && node.parent.tagName == node) && ( /* TODO(ConditionalExpression): checkMode && checkMode & CheckMode.RestBindingElement ?                 getContextualType(node, ContextFlags.SkipBindingPatterns)                 : getContextualType(node, /*contextFlags* / undefined) */ TODO)
		return contextualType && !isGenericType(contextualType)
	}
	getNarrowableTypeForReference := func(type_ Type, reference Node, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isNoInferType(type_) {
			type_ = (type_).baseType
		}
		substituteConstraints := !(checkMode && checkMode&CheckModeInferential) && someType(type_, isGenericTypeWithUnionConstraint) && (isConstraintPosition(type_, reference) || hasContextualTypeWithNoGenericTypes(reference, checkMode))
		return /* TODO(ConditionalExpression): substituteConstraints ? mapType(type, getBaseConstraintOrType) : type */ TODO
	}
	isExportOrExportExpression := func(location Node) /* TODO inferred type boolean */ TODO {
		return !!findAncestor(location, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
			parent := n.parent
			if parent == nil {
				return "quit"
			}
			if isExportAssignment(parent) {
				return parent.expression == n && isEntityNameExpression(n)
			}
			if isExportSpecifier(parent) {
				return parent.name == n || parent.propertyName == n
			}
			return false
		})
	}
	// OVERLOAD: markLinkedReferences := func(location /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, hint /* TODO(QualifiedName): ReferenceHint.Property */ TODO, propSymbol *Symbol, parentType Type)
	// OVERLOAD: markLinkedReferences := func(location Identifier, hint /* TODO(QualifiedName): ReferenceHint.Identifier */ TODO)
	// OVERLOAD: markLinkedReferences := func(location ExportAssignment, hint /* TODO(QualifiedName): ReferenceHint.ExportAssignment */ TODO)
	// OVERLOAD: markLinkedReferences := func(location /* TODO(UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any, hint /* TODO(QualifiedName): ReferenceHint.Jsx */ TODO)
	// OVERLOAD: markLinkedReferences := func(location /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any, hint /* TODO(QualifiedName): ReferenceHint.AsyncFunction */ TODO)
	// OVERLOAD: markLinkedReferences := func(location ImportEqualsDeclaration, hint /* TODO(QualifiedName): ReferenceHint.ExportImportEquals */ TODO)
	// OVERLOAD: markLinkedReferences := func(location ExportSpecifier, hint /* TODO(QualifiedName): ReferenceHint.ExportSpecifier */ TODO)
	// OVERLOAD: markLinkedReferences := func(location HasDecorators, hint /* TODO(QualifiedName): ReferenceHint.Decorator */ TODO)
	// OVERLOAD: markLinkedReferences := func(location Node, hint /* TODO(QualifiedName): ReferenceHint.Unspecified */ TODO, propSymbol Symbol, parentType Type)
	markLinkedReferences := func(location Node, hint ReferenceHint, propSymbol Symbol, parentType Type) {
		if !canCollectSymbolAliasAccessabilityData {
			return
		}
		if location.flags&NodeFlagsAmbient && !isPropertySignature(location) && !isPropertyDeclaration(location) {
			return
		}
		switch hint {
		case ReferenceHintIdentifier:
			return markIdentifierAliasReferenced(location)
		case ReferenceHintProperty:
			return markPropertyAliasReferenced(location, propSymbol, parentType)
		case ReferenceHintExportAssignment:
			return markExportAssignmentAliasReferenced(location)
		case ReferenceHintJsx:
			return markJsxAliasReferenced(location)
		case ReferenceHintAsyncFunction:
			return markAsyncFunctionAliasReferenced(location)
		case ReferenceHintExportImportEquals:
			return markImportEqualsAliasReferenced(location)
		case ReferenceHintExportSpecifier:
			return markExportSpecifierAliasReferenced(location)
		case ReferenceHintDecorator:
			return markDecoratorAliasReferenced(location)
		case ReferenceHintUnspecified:
			if isIdentifier(location) && (isExpressionNode(location) || isShorthandPropertyAssignment(location.parent) || (isImportEqualsDeclaration(location.parent) && location.parent.moduleReference == location)) && shouldMarkIdentifierAliasReferenced(location) {
				if isPropertyAccessOrQualifiedName(location.parent) {
					left := /* TODO(ConditionalExpression): isPropertyAccessExpression(location.parent) ? location.parent.expression : location.parent.left */ TODO
					if left != location {
						return
					}
				}
				markIdentifierAliasReferenced(location)
				return
			}
			if isPropertyAccessOrQualifiedName(location) {
				var topProp Node = location
				for isPropertyAccessOrQualifiedName(topProp) {
					if isPartOfTypeNode(topProp) {
						return
					}
					topProp = topProp.parent
				}
				return markPropertyAliasReferenced(location)
			}
			if isExportAssignment(location) {
				return markExportAssignmentAliasReferenced(location)
			}
			if isJsxOpeningLikeElement(location) || isJsxOpeningFragment(location) {
				return markJsxAliasReferenced(location)
			}
			if isImportEqualsDeclaration(location) {
				if isInternalModuleImportEqualsDeclaration(location) || checkExternalImportOrExportDeclaration(location) {
					return markImportEqualsAliasReferenced(location)
				}
				return
			}
			if isExportSpecifier(location) {
				return markExportSpecifierAliasReferenced(location)
			}
			if isFunctionLikeDeclaration(location) || isMethodSignature(location) {
				markAsyncFunctionAliasReferenced(location)
			}
			if !compilerOptions.emitDecoratorMetadata {
				return
			}
			if !canHaveDecorators(location) || !hasDecorators(location) || !location.modifiers || !nodeCanBeDecorated(legacyDecorators, location, location.parent, location.parent.parent) {
				return
			}
			return markDecoratorAliasReferenced(location)
			fallthrough
		default:
			Debug.assertNever(hint /* TODO(TemplateExpression): `Unhandled reference hint: ${hint}` */, TODO)
		}
	}
	markIdentifierAliasReferenced := func(location Identifier) {
		symbol := getResolvedSymbol(location)
		if symbol && symbol != argumentsSymbol && symbol != unknownSymbol && !isThisInTypeQuery(location) {
			markAliasReferenced(symbol, location)
		}
	}
	markPropertyAliasReferenced := func(location /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, propSymbol Symbol, parentType Type) {
		left := /* TODO(ConditionalExpression): isPropertyAccessExpression(location) ? location.expression : location.left */ TODO
		if isThisIdentifier(left) || !isIdentifier(left) {
			return
		}
		parentSymbol := getResolvedSymbol(left)
		if !parentSymbol || parentSymbol == unknownSymbol {
			return
		}
		if getIsolatedModules(compilerOptions) || (shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location)) {
			markAliasReferenced(parentSymbol, location)
			return
		}
		leftType := parentType || checkExpressionCached(left)
		if isTypeAny(leftType) || leftType == silentNeverType {
			markAliasReferenced(parentSymbol, location)
			return
		}
		prop := propSymbol
		if !prop && !parentType {
			right := /* TODO(ConditionalExpression): isPropertyAccessExpression(location) ? location.name : location.right */ TODO
			lexicallyScopedSymbol := isPrivateIdentifier(right) && lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right)
			assignmentKind := getAssignmentTargetKind(location)
			apparentType := getApparentType( /* TODO(ConditionalExpression): assignmentKind !== AssignmentKind.None || isMethodAccessForCall(location) ? getWidenedType(leftType) : leftType */ TODO)
			prop = /* TODO(ConditionalExpression): isPrivateIdentifier(right) ? lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(apparentType, lexicallyScopedSymbol) || undefined : getPropertyOfType(apparentType, right.escapedText) */ TODO
		}
		if !(prop && (isConstEnumOrConstEnumOnlyModule(prop) || prop.flags&SymbolFlagsEnumMember && location.parent.kind == SyntaxKindEnumMember)) {
			markAliasReferenced(parentSymbol, location)
		}
		return
	}
	markExportAssignmentAliasReferenced := func(location ExportAssignment) {
		if isIdentifier(location.expression) {
			id := location.expression
			sym := getExportSymbolOfValueSymbolIfExported(resolveEntityName(id, SymbolFlagsAll, true, true, location))
			if sym {
				markAliasReferenced(sym, id)
			}
		}
	}
	markJsxAliasReferenced := func(node /* TODO(UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any) {
		if !getJsxNamespaceContainerForImplicitImport(node) {
			jsxFactoryRefErr := /* TODO(ConditionalExpression): diagnostics && compilerOptions.jsx === JsxEmit.React ? Diagnostics.Cannot_find_name_0 : undefined */ TODO
			jsxFactoryNamespace := getJsxNamespace(node)
			jsxFactoryLocation := /* TODO(ConditionalExpression): isJsxOpeningLikeElement(node) ? node.tagName : node */ TODO
			var jsxFactorySym *Symbol
			if !(isJsxOpeningFragment(node) && jsxFactoryNamespace == "null") {
				jsxFactorySym = resolveName(jsxFactoryLocation, jsxFactoryNamespace, SymbolFlagsValue, jsxFactoryRefErr, true)
			}
			if jsxFactorySym {
				jsxFactorySym.isReferenced = SymbolFlagsAll
				if canCollectSymbolAliasAccessabilityData && jsxFactorySym.flags&SymbolFlagsAlias && !getTypeOnlyAliasDeclaration(jsxFactorySym) {
					markAliasSymbolAsReferenced(jsxFactorySym)
				}
			}
			if isJsxOpeningFragment(node) {
				file := getSourceFileOfNode(node)
				localJsxNamespace := getLocalJsxNamespace(file)
				if localJsxNamespace {
					resolveName(jsxFactoryLocation, localJsxNamespace, SymbolFlagsValue, jsxFactoryRefErr, true)
				}
			}
		}
		return
	}
	markAsyncFunctionAliasReferenced := func(location /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any) {
		if languageVersion < ScriptTargetES2015 {
			if getFunctionFlags(location) & FunctionFlagsAsync {
				returnTypeNode := getEffectiveReturnTypeNode(location)
				markTypeNodeAsReferenced(returnTypeNode)
			}
		}
	}
	markImportEqualsAliasReferenced := func(location ImportEqualsDeclaration) {
		if hasSyntacticModifier(location, ModifierFlagsExport) {
			markExportAsReferenced(location)
		}
	}
	markExportSpecifierAliasReferenced := func(location ExportSpecifier) {
		if !location.parent.parent.moduleSpecifier && !location.isTypeOnly && !location.parent.parent.isTypeOnly {
			exportedName := location.propertyName || location.name
			if exportedName.kind == SyntaxKindStringLiteral {
				return
			}
			symbol := resolveName(exportedName, exportedName.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias, nil, true)
			if symbol && (symbol == undefinedSymbol || symbol == globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer( /* TODO(ElementAccessExpression): symbol.declarations[0] */ TODO))) {
			} else {
				target := symbol && ( /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol */ TODO)
				if !target || getSymbolFlags(target)&SymbolFlagsValue {
					markExportAsReferenced(location)
					markIdentifierAliasReferenced(exportedName)
				}
			}
			return
		}
	}
	markDecoratorAliasReferenced := func(node HasDecorators) {
		if compilerOptions.emitDecoratorMetadata {
			firstDecorator := find(node.modifiers, isDecorator)
			if !firstDecorator {
				return
			}
			checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersMetadata)
			switch node.kind {
			case SyntaxKindClassDeclaration:
				constructor := getFirstConstructorWithBody(node)
				if constructor {
					for _, parameter := range constructor.parameters {
						markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter))
					}
				}
				break
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				otherKind := /* TODO(ConditionalExpression): node.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor */ TODO
				otherAccessor := getDeclarationOfKind(getSymbolOfDeclaration(node), otherKind)
				markDecoratorMedataDataTypeNodeAsReferenced(getAnnotatedAccessorTypeNode(node) || otherAccessor && getAnnotatedAccessorTypeNode(otherAccessor))
				break
			case SyntaxKindMethodDeclaration:
				for _, parameter := range node.parameters {
					markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter))
				}
				markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(node))
				break
			case SyntaxKindPropertyDeclaration:
				markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveTypeAnnotationNode(node))
				break
			case SyntaxKindParameter:
				markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(node))
				containingSignature := node.parent
				for _, parameter := range containingSignature.parameters {
					markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter))
				}
				markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(containingSignature))
				break
			}
		}
	}
	markAliasReferenced := func(symbol Symbol, location Node) {
		if !canCollectSymbolAliasAccessabilityData {
			return
		}
		if isNonLocalAlias(symbol, SymbolFlagsValue) && !isInTypeQuery(location) {
			target := resolveAlias(symbol)
			if getSymbolFlags(symbol, true) & (SymbolFlagsValue | SymbolFlagsExportValue) {
				if getIsolatedModules(compilerOptions) || shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location) || !isConstEnumOrConstEnumOnlyModule(getExportSymbolOfValueSymbolIfExported(target)) {
					markAliasSymbolAsReferenced(symbol)
				}
			}
		}
	}
	markAliasSymbolAsReferenced := func(symbol Symbol) /* TODO inferred type undefined */ TODO {
		Debug.assert(canCollectSymbolAliasAccessabilityData)
		links := getSymbolLinks(symbol)
		if !links.referenced {
			links.referenced = true
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				return Debug.fail()
			}
			if isInternalModuleImportEqualsDeclaration(node) {
				if getSymbolFlags(resolveSymbol(symbol)) & SymbolFlagsValue {
					left := getFirstIdentifier(node.moduleReference)
					markIdentifierAliasReferenced(left)
				}
			}
		}
	}
	markExportAsReferenced := func(node /* TODO(UnionType): ImportEqualsDeclaration | ExportSpecifier */ any) {
		symbol := getSymbolOfDeclaration(node)
		target := resolveAlias(symbol)
		if target {
			markAlias := target == unknownSymbol || ((getSymbolFlags(symbol, true) & SymbolFlagsValue) && !isConstEnumOrConstEnumOnlyModule(target))
			if markAlias {
				markAliasSymbolAsReferenced(symbol)
			}
		}
	}
	markEntityNameOrEntityExpressionAsReference := func(typeName *EntityNameOrEntityNameExpression, forDecoratorMetadata bool) {
		if !typeName {
			return
		}
		rootName := getFirstIdentifier(typeName)
		meaning := ( /* TODO(ConditionalExpression): typeName.kind === SyntaxKind.Identifier ? SymbolFlags.Type : SymbolFlags.Namespace */ TODO) | SymbolFlagsAlias
		rootSymbol := resolveName(rootName, rootName.escapedText, meaning, nil, true)
		if rootSymbol && rootSymbol.flags&SymbolFlagsAlias {
			if canCollectSymbolAliasAccessabilityData && symbolIsValue(rootSymbol) && !isConstEnumOrConstEnumOnlyModule(resolveAlias(rootSymbol)) && !getTypeOnlyAliasDeclaration(rootSymbol) {
				markAliasSymbolAsReferenced(rootSymbol)
			} else if forDecoratorMetadata && getIsolatedModules(compilerOptions) && getEmitModuleKind(compilerOptions) >= ModuleKindES2015 && !symbolIsValue(rootSymbol) && !some(rootSymbol.declarations, isTypeOnlyImportOrExportDeclaration) {
				diag := error(typeName, Diagnostics.A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled)
				aliasDeclaration := find(rootSymbol.declarations || emptyArray, isAliasSymbolDeclaration)
				if aliasDeclaration {
					addRelatedInfo(diag, createDiagnosticForNode(aliasDeclaration, Diagnostics._0_was_imported_here, idText(rootName)))
				}
			}
		}
	}
	markTypeNodeAsReferenced := func(node *TypeNode) {
		markEntityNameOrEntityExpressionAsReference(node && getEntityNameFromTypeNode(node), false)
	}
	markDecoratorMedataDataTypeNodeAsReferenced := func(node *TypeNode) {
		entityName := getEntityNameForDecoratorMetadata(node)
		if entityName && isEntityName(entityName) {
			markEntityNameOrEntityExpressionAsReference(entityName, true)
		}
	}
	getNarrowedTypeOfSymbol := func(symbol Symbol, location Identifier) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		type_ := getTypeOfSymbol(symbol)
		declaration := symbol.valueDeclaration
		if declaration {
			if isBindingElement(declaration) && !declaration.initializer && !declaration.dotDotDotToken && declaration.parent.elements.length >= 2 {
				parent := declaration.parent.parent
				rootDeclaration := getRootDeclaration(parent)
				if rootDeclaration.kind == SyntaxKindVariableDeclaration && getCombinedNodeFlagsCached(rootDeclaration)&NodeFlagsConstant || rootDeclaration.kind == SyntaxKindParameter {
					links := getNodeLinks(parent)
					if !(links.flags & NodeCheckFlagsInCheckIdentifier) {
						links.flags |= NodeCheckFlagsInCheckIdentifier
						parentType := getTypeForBindingElementParent(parent, CheckModeNormal)
						parentTypeConstraint := parentType && mapType(parentType, getBaseConstraintOrType)
						links.flags &= ~NodeCheckFlagsInCheckIdentifier
						if parentTypeConstraint && parentTypeConstraint.flags&TypeFlagsUnion && !(rootDeclaration.kind == SyntaxKindParameter && isSomeSymbolAssigned(rootDeclaration)) {
							pattern := declaration.parent
							narrowedType := getFlowTypeOfReference(pattern, parentTypeConstraint, parentTypeConstraint, nil, location.flowNode)
							if narrowedType.flags & TypeFlagsNever {
								return neverType
							}
							return getBindingElementTypeFromParentType(declaration, narrowedType, true)
						}
					}
				}
			}
			if isParameter(declaration) && !declaration.type_ && !declaration.initializer && !declaration.dotDotDotToken {
				func_ := declaration.parent
				if func_.parameters.length >= 2 && isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
					contextualSignature := getContextualSignature(func_)
					if contextualSignature && contextualSignature.parameters.length == 1 && signatureHasRestParameter(contextualSignature) {
						restType := getReducedApparentType(instantiateType(getTypeOfSymbol( /* TODO(ElementAccessExpression): contextualSignature.parameters[0] */ TODO), getInferenceContext(func_).nonFixingMapper))
						if restType.flags&TypeFlagsUnion && everyType(restType, isTupleType) && !some(func_.parameters, isSomeSymbolAssigned) {
							narrowedType := getFlowTypeOfReference(func_, restType, restType, nil, location.flowNode)
							index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): func.parameters.indexOf(declaration) - (getThisParameter(func) ? 1 : 0) */ TODO
							return getIndexedAccessType(narrowedType, getNumberLiteralType(index))
						}
					}
				}
			}
		}
		return type_
	}
	checkIdentifierCalculateNodeCheckFlags := func(node Identifier, symbol Symbol) {
		if isThisInTypeQuery(node) {
			return
		}
		if symbol == argumentsSymbol {
			if isInPropertyInitializerOrClassStaticBlock(node) {
				error(node, Diagnostics.arguments_cannot_be_referenced_in_property_initializers)
				return
			}
			container := getContainingFunction(node)
			if container {
				if languageVersion < ScriptTargetES2015 {
					if container.kind == SyntaxKindArrowFunction {
						error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES5_Consider_using_a_standard_function_expression)
					} else if hasSyntacticModifier(container, ModifierFlagsAsync) {
						error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES5_Consider_using_a_standard_function_or_method)
					}
				}
				getNodeLinks(container).flags |= NodeCheckFlagsCaptureArguments
				for container && isArrowFunction(container) {
					container = getContainingFunction(container)
					if container {
						getNodeLinks(container).flags |= NodeCheckFlagsCaptureArguments
					}
				}
			}
			return
		}
		localOrExportSymbol := getExportSymbolOfValueSymbolIfExported(symbol)
		targetSymbol := resolveAliasWithDeprecationCheck(localOrExportSymbol, node)
		if isDeprecatedSymbol(targetSymbol) && isUncalledFunctionReference(node, targetSymbol) && targetSymbol.declarations {
			addDeprecatedSuggestion(node, targetSymbol.declarations, node.escapedText)
		}
		declaration := localOrExportSymbol.valueDeclaration
		if declaration && localOrExportSymbol.flags&SymbolFlagsClass {
			if isClassLike(declaration) && declaration.name != node {
				container := getThisContainer(node, false, false)
				for container.kind != SyntaxKindSourceFile && container.parent != declaration {
					container = getThisContainer(container, false, false)
				}
				if container.kind != SyntaxKindSourceFile {
					getNodeLinks(declaration).flags |= NodeCheckFlagsContainsConstructorReference
					getNodeLinks(container).flags |= NodeCheckFlagsContainsConstructorReference
					getNodeLinks(node).flags |= NodeCheckFlagsConstructorReference
				}
			}
		}
		checkNestedBlockScopedBinding(node, symbol)
	}
	checkIdentifier := func(node Identifier, checkMode *CheckMode) Type {
		if isThisInTypeQuery(node) {
			return checkThisExpression(node)
		}
		symbol := getResolvedSymbol(node)
		if symbol == unknownSymbol {
			return errorType
		}
		checkIdentifierCalculateNodeCheckFlags(node, symbol)
		if symbol == argumentsSymbol {
			if isInPropertyInitializerOrClassStaticBlock(node) {
				return errorType
			}
			return getTypeOfSymbol(symbol)
		}
		if shouldMarkIdentifierAliasReferenced(node) {
			markLinkedReferences(node, ReferenceHintIdentifier)
		}
		localOrExportSymbol := getExportSymbolOfValueSymbolIfExported(symbol)
		declaration := localOrExportSymbol.valueDeclaration
		immediateDeclaration := declaration
		if declaration && declaration.kind == SyntaxKindBindingElement && contains(contextualBindingPatterns, declaration.parent) && findAncestor(node, func(parent /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
			return parent == declaration.parent
		}) {
			return nonInferrableAnyType
		}
		type_ := getNarrowedTypeOfSymbol(localOrExportSymbol, node)
		assignmentKind := getAssignmentTargetKind(node)
		if assignmentKind {
			if !(localOrExportSymbol.flags & SymbolFlagsVariable) && !(isInJSFile(node) && localOrExportSymbol.flags&SymbolFlagsValueModule) {
				assignmentError := /* TODO(ConditionalExpression): localOrExportSymbol.flags & SymbolFlags.Enum ? Diagnostics.Cannot_assign_to_0_because_it_is_an_enum                     : localOrExportSymbol.flags & SymbolFlags.Class ? Diagnostics.Cannot_assign_to_0_because_it_is_a_class                     : localOrExportSymbol.flags & SymbolFlags.Module ? Diagnostics.Cannot_assign_to_0_because_it_is_a_namespace                     : localOrExportSymbol.flags & SymbolFlags.Function ? Diagnostics.Cannot_assign_to_0_because_it_is_a_function                     : localOrExportSymbol.flags & SymbolFlags.Alias ? Diagnostics.Cannot_assign_to_0_because_it_is_an_import                     : Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable */ TODO
				error(node, assignmentError, symbolToString(symbol))
				return errorType
			}
			if isReadonlySymbol(localOrExportSymbol) {
				if localOrExportSymbol.flags & SymbolFlagsVariable {
					error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_constant, symbolToString(symbol))
				} else {
					error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(symbol))
				}
				return errorType
			}
		}
		isAlias := localOrExportSymbol.flags & SymbolFlagsAlias
		if localOrExportSymbol.flags & SymbolFlagsVariable {
			if assignmentKind == AssignmentKindDefinite {
				return /* TODO(ConditionalExpression): isInCompoundLikeAssignment(node) ? getBaseTypeOfLiteralType(type) : type */ TODO
			}
		} else if isAlias {
			declaration = getDeclarationOfAliasSymbol(symbol)
		} else {
			return type_
		}
		if !declaration {
			return type_
		}
		type_ = getNarrowableTypeForReference(type_, node, checkMode)
		isParameter := getRootDeclaration(declaration).kind == SyntaxKindParameter
		declarationContainer := getControlFlowContainer(declaration)
		flowContainer := getControlFlowContainer(node)
		isOuterVariable := flowContainer != declarationContainer
		isSpreadDestructuringAssignmentTarget := node.parent && node.parent.parent && isSpreadAssignment(node.parent) && isDestructuringAssignmentTarget(node.parent.parent)
		isModuleExports := symbol.flags & SymbolFlagsModuleExports
		typeIsAutomatic := type_ == autoType || type_ == autoArrayType
		isAutomaticTypeInNonNull := typeIsAutomatic && node.parent.kind == SyntaxKindNonNullExpression
		for flowContainer != declarationContainer && (flowContainer.kind == SyntaxKindFunctionExpression || flowContainer.kind == SyntaxKindArrowFunction || isObjectLiteralOrClassExpressionMethodOrAccessor(flowContainer)) && (isConstantVariable(localOrExportSymbol) && type_ != autoArrayType || isParameterOrMutableLocalVariable(localOrExportSymbol) && isPastLastAssignment(localOrExportSymbol, node)) {
			flowContainer = getControlFlowContainer(flowContainer)
		}
		isNeverInitialized := immediateDeclaration && isVariableDeclaration(immediateDeclaration) && !immediateDeclaration.initializer && !immediateDeclaration.exclamationToken && isMutableLocalVariableDeclaration(immediateDeclaration) && !isSymbolAssignedDefinitely(symbol)
		assumeInitialized := isParameter || isAlias || (isOuterVariable && !isNeverInitialized) || isSpreadDestructuringAssignmentTarget || isModuleExports || isSameScopedBindingElement(node, declaration) || type_ != autoType && type_ != autoArrayType && (!strictNullChecks || (type_.flags&(TypeFlagsAnyOrUnknown|TypeFlagsVoid)) != 0 || isInTypeQuery(node) || isInAmbientOrTypeNode(node) || node.parent.kind == SyntaxKindExportSpecifier) || node.parent.kind == SyntaxKindNonNullExpression || declaration.kind == SyntaxKindVariableDeclaration && (declaration).exclamationToken || declaration.flags&NodeFlagsAmbient
		initialType := /* TODO(ConditionalExpression): isAutomaticTypeInNonNull ? undefinedType :             assumeInitialized ? (isParameter ? removeOptionalityFromDeclaredType(type, declaration as VariableLikeDeclaration) : type) :             typeIsAutomatic ? undefinedType : getOptionalType(type) */ TODO
		flowType := /* TODO(ConditionalExpression): isAutomaticTypeInNonNull ? getNonNullableType(getFlowTypeOfReference(node, type, initialType, flowContainer)) :             getFlowTypeOfReference(node, type, initialType, flowContainer) */ TODO
		if !isEvolvingArrayOperationTarget(node) && (type_ == autoType || type_ == autoArrayType) {
			if flowType == autoType || flowType == autoArrayType {
				if noImplicitAny {
					error(getNameOfDeclaration(declaration), Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined, symbolToString(symbol), typeToString(flowType))
					error(node, Diagnostics.Variable_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType))
				}
				return convertAutoToAny(flowType)
			}
		} else if !assumeInitialized && !containsUndefinedType(type_) && containsUndefinedType(flowType) {
			error(node, Diagnostics.Variable_0_is_used_before_being_assigned, symbolToString(symbol))
			return type_
		}
		return /* TODO(ConditionalExpression): assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType */ TODO
	}
	isSameScopedBindingElement := func(node Identifier, declaration Declaration) /* TODO inferred type boolean | undefined */ TODO {
		if isBindingElement(declaration) {
			bindingElement := findAncestor(node, isBindingElement)
			return bindingElement && getRootDeclaration(bindingElement) == getRootDeclaration(declaration)
		}
	}
	shouldMarkIdentifierAliasReferenced := func(node Identifier) bool {
		parent := node.parent
		if parent {
			if isPropertyAccessExpression(parent) && parent.expression == node {
				return false
			}
			if isExportSpecifier(parent) && parent.isTypeOnly {
				return false
			}
			greatGrandparent := parent.parent.parent
			if greatGrandparent && isExportDeclaration(greatGrandparent) && greatGrandparent.isTypeOnly {
				return false
			}
		}
		return true
	}
	isInsideFunctionOrInstancePropertyInitializer := func(node Node, threshold Node) bool {
		return !!findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
			return /* TODO(ConditionalExpression): n === threshold ? "quit" : isFunctionLike(n) || (                 n.parent && isPropertyDeclaration(n.parent) && !hasStaticModifier(n.parent) && n.parent.initializer === n             ) */ TODO
		})
	}
	getPartOfForStatementContainingNode := func(node Node, container ForStatement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO {
		return findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
			return /* TODO(ConditionalExpression): n === container ? "quit" : n === container.initializer || n === container.condition || n === container.incrementor || n === container.statement */ TODO
		})
	}
	getEnclosingIterationStatement := func(node Node) Node {
		return findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
			return /* TODO(ConditionalExpression): (!n || nodeStartsNewLexicalEnvironment(n)) ? "quit" : isIterationStatement(n, /*lookInLabeledStatements* / false) */ TODO
		})
	}
	checkNestedBlockScopedBinding := func(node Identifier, symbol Symbol) {
		if languageVersion >= ScriptTargetES2015 || (symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsClass)) == 0 || !symbol.valueDeclaration || isSourceFile(symbol.valueDeclaration) || symbol.valueDeclaration.parent.kind == SyntaxKindCatchClause {
			return
		}
		container := getEnclosingBlockScopeContainer(symbol.valueDeclaration)
		isCaptured := isInsideFunctionOrInstancePropertyInitializer(node, container)
		enclosingIterationStatement := getEnclosingIterationStatement(container)
		if enclosingIterationStatement {
			if isCaptured {
				capturesBlockScopeBindingInLoopBody := true
				if isForStatement(container) {
					varDeclList := getAncestor(symbol.valueDeclaration, SyntaxKindVariableDeclarationList)
					if varDeclList && varDeclList.parent == container {
						part := getPartOfForStatementContainingNode(node.parent, container)
						if part {
							links := getNodeLinks(part)
							links.flags |= NodeCheckFlagsContainsCapturedBlockScopeBinding
							capturedBindings := links.capturedBlockScopeBindings || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.capturedBlockScopeBindings = [] */ TODO)
							pushIfUnique(capturedBindings, symbol)
							if part == container.initializer {
								capturesBlockScopeBindingInLoopBody = false
							}
						}
					}
				}
				if capturesBlockScopeBindingInLoopBody {
					getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
				}
			}
			if isForStatement(container) {
				varDeclList := getAncestor(symbol.valueDeclaration, SyntaxKindVariableDeclarationList)
				if varDeclList && varDeclList.parent == container && isAssignedInBodyOfForStatement(node, container) {
					getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsNeedsLoopOutParameter
				}
			}
			getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsBlockScopedBindingInLoop
		}
		if isCaptured {
			getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsCapturedBlockScopedBinding
		}
	}
	isBindingCapturedByNode := func(node Node, decl /* TODO(UnionType): VariableDeclaration | BindingElement */ any) /* TODO inferred type boolean */ TODO {
		links := getNodeLinks(node)
		return !!links && contains(links.capturedBlockScopeBindings, getSymbolOfDeclaration(decl))
	}
	isAssignedInBodyOfForStatement := func(node Identifier, container ForStatement) bool {
		var current Node = node
		for current.parent.kind == SyntaxKindParenthesizedExpression {
			current = current.parent
		}
		isAssigned := false
		if isAssignmentTarget(current) {
			isAssigned = true
		} else if current.parent.kind == SyntaxKindPrefixUnaryExpression || current.parent.kind == SyntaxKindPostfixUnaryExpression {
			expr := current.parent
			isAssigned = expr.operator == SyntaxKindPlusPlusToken || expr.operator == SyntaxKindMinusMinusToken
		}
		if !isAssigned {
			return false
		}
		return !!findAncestor(current, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
			return /* TODO(ConditionalExpression): n === container ? "quit" : n === container.statement */ TODO
		})
	}
	captureLexicalThis := func(node Node, container Node) {
		getNodeLinks(node).flags |= NodeCheckFlagsLexicalThis
		if container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindConstructor {
			classNode := container.parent
			getNodeLinks(classNode).flags |= NodeCheckFlagsCaptureThis
		} else {
			getNodeLinks(container).flags |= NodeCheckFlagsCaptureThis
		}
	}
	findFirstSuperCall := func(node Node) *SuperCall {
		return /* TODO(ConditionalExpression): isSuperCall(node) ? node :             isFunctionLike(node) ? undefined :             forEachChild(node, findFirstSuperCall) */ TODO
	}
	classDeclarationExtendsNull := func(classDecl ClassLikeDeclaration) bool {
		classSymbol := getSymbolOfDeclaration(classDecl)
		classInstanceType := getDeclaredTypeOfSymbol(classSymbol)
		baseConstructorType := getBaseConstructorTypeOfClass(classInstanceType)
		return baseConstructorType == nullWideningType
	}
	checkThisBeforeSuper := func(node Node, container Node, diagnosticMessage DiagnosticMessage) {
		containingClassDecl := container.parent
		baseTypeNode := getClassExtendsHeritageElement(containingClassDecl)
		if baseTypeNode && !classDeclarationExtendsNull(containingClassDecl) {
			if canHaveFlowNode(node) && node.flowNode && !isPostSuperFlowNode(node.flowNode, false) {
				error(node, diagnosticMessage)
			}
		}
	}
	checkThisInStaticClassFieldInitializerInDecoratedClass := func(thisExpression Node, container Node) {
		if isPropertyDeclaration(container) && hasStaticModifier(container) && legacyDecorators && container.initializer && textRangeContainsPositionInclusive(container.initializer, thisExpression.pos) && hasDecorators(container.parent) {
			error(thisExpression, Diagnostics.Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class)
		}
	}
	checkThisExpression := func(node Node) Type {
		isNodeInTypeQuery := isInTypeQuery(node)
		container := getThisContainer(node, true, true)
		capturedByArrowFunction := false
		thisInComputedPropertyName := false
		if container.kind == SyntaxKindConstructor {
			checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class)
		}
		for true {
			if container.kind == SyntaxKindArrowFunction {
				container = getThisContainer(container, false, !thisInComputedPropertyName)
				capturedByArrowFunction = true
			}
			if container.kind == SyntaxKindComputedPropertyName {
				container = getThisContainer(container, !capturedByArrowFunction, false)
				thisInComputedPropertyName = true
				continue
			}
			break
		}
		checkThisInStaticClassFieldInitializerInDecoratedClass(node, container)
		if thisInComputedPropertyName {
			error(node, Diagnostics.this_cannot_be_referenced_in_a_computed_property_name)
		} else {
			switch container.kind {
			case SyntaxKindModuleDeclaration:
				error(node, Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body)
				break
			case SyntaxKindEnumDeclaration:
				error(node, Diagnostics.this_cannot_be_referenced_in_current_location)
				break
			}
		}
		if !isNodeInTypeQuery && capturedByArrowFunction && languageVersion < ScriptTargetES2015 {
			captureLexicalThis(node, container)
		}
		type_ := tryGetThisTypeAt(node, true, container)
		if noImplicitThis {
			globalThisType := getTypeOfSymbol(globalThisSymbol)
			if type_ == globalThisType && capturedByArrowFunction {
				error(node, Diagnostics.The_containing_arrow_function_captures_the_global_value_of_this)
			} else if !type_ {
				diag := error(node, Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation)
				if !isSourceFile(container) {
					outsideThis := tryGetThisTypeAt(container)
					if outsideThis && outsideThis != globalThisType {
						addRelatedInfo(diag, createDiagnosticForNode(container, Diagnostics.An_outer_value_of_this_is_shadowed_by_this_container))
					}
				}
			}
		}
		return type_ || anyType
	}
	tryGetThisTypeAt := func(node Node, includeGlobalThis /* TODO inferred type boolean */ TODO /*  = true */, container /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/utilities").ThisContainer */ TODO /*  = getThisContainer(node, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false) */) *Type {
		isInJS := isInJSFile(node)
		if isFunctionLike(container) && (!isInParameterInitializerBeforeContainingFunction(node) || getThisParameter(container)) {
			thisType := getThisTypeOfDeclaration(container) || isInJS && getTypeForThisExpressionFromJSDoc(container)
			if !thisType {
				className := getClassNameFromPrototypeMethod(container)
				if isInJS && className {
					classSymbol := checkExpression(className).symbol
					if classSymbol && classSymbol.members && (classSymbol.flags & SymbolFlagsFunction) {
						thisType = (getDeclaredTypeOfSymbol(classSymbol)).thisType
					}
				} else if isJSConstructor(container) {
					thisType = (getDeclaredTypeOfSymbol(getMergedSymbol(container.symbol))).thisType
				}
				/* TODO(ExpressionStatement): thisType ||= getContextualThisParameterType(container); */
			}
			if thisType {
				return getFlowTypeOfReference(node, thisType)
			}
		}
		if isClassLike(container.parent) {
			symbol := getSymbolOfDeclaration(container.parent)
			type_ := /* TODO(ConditionalExpression): isStatic(container) ? getTypeOfSymbol(symbol) : (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType! */ TODO
			return getFlowTypeOfReference(node, type_)
		}
		if isSourceFile(container) {
			if container.commonJsModuleIndicator {
				fileSymbol := getSymbolOfDeclaration(container)
				return fileSymbol && getTypeOfSymbol(fileSymbol)
			} else if container.externalModuleIndicator {
				return undefinedType
			} else if includeGlobalThis {
				return getTypeOfSymbol(globalThisSymbol)
			}
		}
	}
	getExplicitThisType := func(node Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		container := getThisContainer(node, false, false)
		if isFunctionLike(container) {
			signature := getSignatureFromDeclaration(container)
			if signature.thisParameter {
				return getExplicitTypeOfSymbol(signature.thisParameter)
			}
		}
		if isClassLike(container.parent) {
			symbol := getSymbolOfDeclaration(container.parent)
			return /* TODO(ConditionalExpression): isStatic(container) ? getTypeOfSymbol(symbol) : (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType! */ TODO
		}
	}
	getClassNameFromPrototypeMethod := func(container Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").LeftHandSideExpression | undefined */ TODO {
		if container.kind == SyntaxKindFunctionExpression && isBinaryExpression(container.parent) && getAssignmentDeclarationKind(container.parent) == AssignmentDeclarationKindPrototypeProperty {
			return ((container.parent.left).expression).expression
		} else if container.kind == SyntaxKindMethodDeclaration && container.parent.kind == SyntaxKindObjectLiteralExpression && isBinaryExpression(container.parent.parent) && getAssignmentDeclarationKind(container.parent.parent) == AssignmentDeclarationKindPrototype {
			return (container.parent.parent.left).expression
		} else if container.kind == SyntaxKindFunctionExpression && container.parent.kind == SyntaxKindPropertyAssignment && container.parent.parent.kind == SyntaxKindObjectLiteralExpression && isBinaryExpression(container.parent.parent.parent) && getAssignmentDeclarationKind(container.parent.parent.parent) == AssignmentDeclarationKindPrototype {
			return (container.parent.parent.parent.left).expression
		} else if container.kind == SyntaxKindFunctionExpression && isPropertyAssignment(container.parent) && isIdentifier(container.parent.name) && (container.parent.name.escapedText == "value" || container.parent.name.escapedText == "get" || container.parent.name.escapedText == "set") && isObjectLiteralExpression(container.parent.parent) && isCallExpression(container.parent.parent.parent) && /* TODO(ElementAccessExpression): container.parent.parent.parent.arguments[2] */ TODO == container.parent.parent && getAssignmentDeclarationKind(container.parent.parent.parent) == AssignmentDeclarationKindObjectDefinePrototypeProperty {
			return ( /* TODO(ElementAccessExpression): container.parent.parent.parent.arguments[0] */ TODO).expression
		} else if isMethodDeclaration(container) && isIdentifier(container.name) && (container.name.escapedText == "value" || container.name.escapedText == "get" || container.name.escapedText == "set") && isObjectLiteralExpression(container.parent) && isCallExpression(container.parent.parent) && /* TODO(ElementAccessExpression): container.parent.parent.arguments[2] */ TODO == container.parent && getAssignmentDeclarationKind(container.parent.parent) == AssignmentDeclarationKindObjectDefinePrototypeProperty {
			return ( /* TODO(ElementAccessExpression): container.parent.parent.arguments[0] */ TODO).expression
		}
	}
	getTypeForThisExpressionFromJSDoc := func(node SignatureDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		thisTag := getJSDocThisTag(node)
		if thisTag && thisTag.typeExpression {
			return getTypeFromTypeNode(thisTag.typeExpression)
		}
		signature := getSignatureOfTypeTag(node)
		if signature {
			return getThisTypeOfSignature(signature)
		}
	}
	isInConstructorArgumentInitializer := func(node Node, constructorDecl Node) bool {
		return !!findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
			return /* TODO(ConditionalExpression): isFunctionLikeDeclaration(n) ? "quit" : n.kind === SyntaxKind.Parameter && n.parent === constructorDecl */ TODO
		})
	}
	checkSuperExpression := func(node Node) Type {
		isCallExpression := node.parent.kind == SyntaxKindCallExpression && (node.parent).expression == node
		immediateContainer := getSuperContainer(node, true)
		container := immediateContainer
		needToCaptureLexicalThis := false
		inAsyncFunction := false
		if !isCallExpression {
			for container && container.kind == SyntaxKindArrowFunction {
				if hasSyntacticModifier(container, ModifierFlagsAsync) {
					inAsyncFunction = true
				}
				container = getSuperContainer(container, true)
				needToCaptureLexicalThis = languageVersion < ScriptTargetES2015
			}
			if container && hasSyntacticModifier(container, ModifierFlagsAsync) {
				inAsyncFunction = true
			}
		}
		var nodeCheckFlag NodeCheckFlags = 0
		if !container || !isLegalUsageOfSuperExpression(container) {
			current := findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
				return /* TODO(ConditionalExpression): n === container ? "quit" : n.kind === SyntaxKind.ComputedPropertyName */ TODO
			})
			if current && current.kind == SyntaxKindComputedPropertyName {
				error(node, Diagnostics.super_cannot_be_referenced_in_a_computed_property_name)
			} else if isCallExpression {
				error(node, Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors)
			} else if !container || !container.parent || !(isClassLike(container.parent) || container.parent.kind == SyntaxKindObjectLiteralExpression) {
				error(node, Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions)
			} else {
				error(node, Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class)
			}
			return errorType
		}
		if !isCallExpression && immediateContainer.kind == SyntaxKindConstructor {
			checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class)
		}
		if isStatic(container) || isCallExpression {
			nodeCheckFlag = NodeCheckFlagsSuperStatic
			if !isCallExpression && languageVersion >= ScriptTargetES2015 && languageVersion <= ScriptTargetES2021 && (isPropertyDeclaration(container) || isClassStaticBlockDeclaration(container)) {
				forEachEnclosingBlockScopeContainer(node.parent, func(current /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) {
					if !isSourceFile(current) || isExternalOrCommonJsModule(current) {
						getNodeLinks(current).flags |= NodeCheckFlagsContainsSuperPropertyInStaticInitializer
					}
				})
			}
		} else {
			nodeCheckFlag = NodeCheckFlagsSuperInstance
		}
		getNodeLinks(node).flags |= nodeCheckFlag
		if container.kind == SyntaxKindMethodDeclaration && inAsyncFunction {
			if isSuperProperty(node.parent) && isAssignmentTarget(node.parent) {
				getNodeLinks(container).flags |= NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync
			} else {
				getNodeLinks(container).flags |= NodeCheckFlagsMethodWithSuperPropertyAccessInAsync
			}
		}
		if needToCaptureLexicalThis {
			captureLexicalThis(node.parent, container)
		}
		if container.parent.kind == SyntaxKindObjectLiteralExpression {
			if languageVersion < ScriptTargetES2015 {
				error(node, Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher)
				return errorType
			} else {
				return anyType
			}
		}
		classLikeDeclaration := container.parent
		if !getClassExtendsHeritageElement(classLikeDeclaration) {
			error(node, Diagnostics.super_can_only_be_referenced_in_a_derived_class)
			return errorType
		}
		if classDeclarationExtendsNull(classLikeDeclaration) {
			return /* TODO(ConditionalExpression): isCallExpression ? errorType : nullWideningType */ TODO
		}
		classType := getDeclaredTypeOfSymbol(getSymbolOfDeclaration(classLikeDeclaration))
		baseClassType := classType && /* TODO(ElementAccessExpression): getBaseTypes(classType)[0] */ TODO
		if !baseClassType {
			return errorType
		}
		if container.kind == SyntaxKindConstructor && isInConstructorArgumentInitializer(node, container) {
			error(node, Diagnostics.super_cannot_be_referenced_in_constructor_arguments)
			return errorType
		}
		return /* TODO(ConditionalExpression): nodeCheckFlag === NodeCheckFlags.SuperStatic             ? getBaseConstructorTypeOfClass(classType)             : getTypeWithThisArgument(baseClassType, classType.thisType) */ TODO
		isLegalUsageOfSuperExpression := func(container Node) bool {
			if isCallExpression {
				return container.kind == SyntaxKindConstructor
			} else {
				if isClassLike(container.parent) || container.parent.kind == SyntaxKindObjectLiteralExpression {
					if isStatic(container) {
						return container.kind == SyntaxKindMethodDeclaration || container.kind == SyntaxKindMethodSignature || container.kind == SyntaxKindGetAccessor || container.kind == SyntaxKindSetAccessor || container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindClassStaticBlockDeclaration
					} else {
						return container.kind == SyntaxKindMethodDeclaration || container.kind == SyntaxKindMethodSignature || container.kind == SyntaxKindGetAccessor || container.kind == SyntaxKindSetAccessor || container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindPropertySignature || container.kind == SyntaxKindConstructor
					}
				}
			}
			return false
		}
	}
	getContainingObjectLiteral := func(func_ SignatureDeclaration) *ObjectLiteralExpression {
		return /* TODO(ConditionalExpression): (func.kind === SyntaxKind.MethodDeclaration ||                 func.kind === SyntaxKind.GetAccessor ||                 func.kind === SyntaxKind.SetAccessor) && func.parent.kind === SyntaxKind.ObjectLiteralExpression ? func.parent :             func.kind === SyntaxKind.FunctionExpression && func.parent.kind === SyntaxKind.PropertyAssignment ? func.parent.parent as ObjectLiteralExpression :             undefined */ TODO
	}
	getThisTypeArgument := func(type_ Type) *Type {
		return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference).target === globalThisType ? getTypeArguments(type as TypeReference)[0] : undefined */ TODO
	}
	getThisTypeFromContextualType := func(type_ Type) *Type {
		return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			return /* TODO(ConditionalExpression): t.flags & TypeFlags.Intersection ? forEach((t as IntersectionType).types, getThisTypeArgument) : getThisTypeArgument(t) */ TODO
		})
	}
	getThisTypeOfObjectLiteralFromContextualType := func(containingLiteral ObjectLiteralExpression, contextualType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		literal := containingLiteral
		type_ := contextualType
		for type_ {
			thisType := getThisTypeFromContextualType(type_)
			if thisType {
				return thisType
			}
			if literal.parent.kind != SyntaxKindPropertyAssignment {
				break
			}
			literal = literal.parent.parent
			type_ = getApparentTypeOfContextualType(literal, nil)
		}
	}
	getContextualThisParameterType := func(func_ SignatureDeclaration) *Type {
		if func_.kind == SyntaxKindArrowFunction {
			return nil
		}
		if isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
			contextualSignature := getContextualSignature(func_)
			if contextualSignature {
				thisParameter := contextualSignature.thisParameter
				if thisParameter {
					return getTypeOfSymbol(thisParameter)
				}
			}
		}
		inJs := isInJSFile(func_)
		if noImplicitThis || inJs {
			containingLiteral := getContainingObjectLiteral(func_)
			if containingLiteral {
				contextualType := getApparentTypeOfContextualType(containingLiteral, nil)
				thisType := getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
				if thisType {
					return instantiateType(thisType, getMapperFromContext(getInferenceContext(containingLiteral)))
				}
				return getWidenedType( /* TODO(ConditionalExpression): contextualType ? getNonNullableType(contextualType) : checkExpressionCached(containingLiteral) */ TODO)
			}
			parent := walkUpParenthesizedExpressions(func_.parent)
			if isAssignmentExpression(parent) {
				target := parent.left
				if isAccessExpression(target) {
					TODO_IDENTIFIER := target
					if inJs && isIdentifier(expression) {
						sourceFile := getSourceFileOfNode(parent)
						if sourceFile.commonJsModuleIndicator && getResolvedSymbol(expression) == sourceFile.symbol {
							return nil
						}
					}
					return getWidenedType(checkExpressionCached(expression))
				}
			}
		}
		return nil
	}
	getContextuallyTypedParameterType := func(parameter ParameterDeclaration) *Type {
		func_ := parameter.parent
		if !isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
			return nil
		}
		iife := getImmediatelyInvokedFunctionExpression(func_)
		if iife && iife.arguments {
			args := getEffectiveCallArguments(iife)
			indexOfParameter := func_.parameters.indexOf(parameter)
			if parameter.dotDotDotToken {
				return getSpreadArgumentType(args, indexOfParameter, args.length, anyType, nil, CheckModeNormal)
			}
			links := getNodeLinks(iife)
			cached := links.resolvedSignature
			links.resolvedSignature = anySignature
			type_ := /* TODO(ConditionalExpression): indexOfParameter < args.length ?                 getWidenedLiteralType(checkExpression(args[indexOfParameter])) :                 parameter.initializer ? undefined : undefinedWideningType */ TODO
			links.resolvedSignature = cached
			return type_
		}
		contextualSignature := getContextualSignature(func_)
		if contextualSignature {
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): func.parameters.indexOf(parameter) - (getThisParameter(func) ? 1 : 0) */ TODO
			return /* TODO(ConditionalExpression): parameter.dotDotDotToken && lastOrUndefined(func.parameters) === parameter ?                 getRestTypeAtPosition(contextualSignature, index) :                 tryGetTypeAtPosition(contextualSignature, index) */ TODO
		}
	}
	getContextualTypeForVariableLikeDeclaration := func(declaration VariableLikeDeclaration, contextFlags *ContextFlags) *Type {
		typeNode := getEffectiveTypeAnnotationNode(declaration) || ( /* TODO(ConditionalExpression): isInJSFile(declaration) ? tryGetJSDocSatisfiesTypeNode(declaration) : undefined */ TODO)
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
		switch declaration.kind {
		case SyntaxKindParameter:
			return getContextuallyTypedParameterType(declaration)
		case SyntaxKindBindingElement:
			return getContextualTypeForBindingElement(declaration, contextFlags)
		case SyntaxKindPropertyDeclaration:
			if isStatic(declaration) {
				return getContextualTypeForStaticPropertyDeclaration(declaration, contextFlags)
			}
		}
	}
	getContextualTypeForBindingElement := func(declaration BindingElement, contextFlags *ContextFlags) *Type {
		parent := declaration.parent.parent
		name := declaration.propertyName || declaration.name
		parentType := getContextualTypeForVariableLikeDeclaration(parent, contextFlags) || parent.kind != SyntaxKindBindingElement && parent.initializer && checkDeclarationInitializer(parent /* TODO(ConditionalExpression): declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */, TODO)
		if !parentType || isBindingPattern(name) || isComputedNonLiteralName(name) {
			return nil
		}
		if parent.name.kind == SyntaxKindArrayBindingPattern {
			index := indexOfNode(declaration.parent.elements, declaration)
			if index < 0 {
				return nil
			}
			return getContextualTypeForElementExpression(parentType, index)
		}
		nameType := getLiteralTypeFromPropertyName(name)
		if isTypeUsableAsPropertyName(nameType) {
			text := getPropertyNameFromType(nameType)
			return getTypeOfPropertyOfType(parentType, text)
		}
	}
	getContextualTypeForStaticPropertyDeclaration := func(declaration PropertyDeclaration, contextFlags *ContextFlags) *Type {
		parentType := isExpression(declaration.parent) && getContextualType(declaration.parent, contextFlags)
		if !parentType {
			return nil
		}
		return getTypeOfPropertyOfContextualType(parentType, getSymbolOfDeclaration(declaration).escapedName)
	}
	getContextualTypeForInitializerExpression := func(node Expression, contextFlags *ContextFlags) *Type {
		declaration := node.parent
		if hasInitializer(declaration) && node == declaration.initializer {
			result := getContextualTypeForVariableLikeDeclaration(declaration, contextFlags)
			if result {
				return result
			}
			if !(contextFlags & ContextFlagsSkipBindingPatterns) && isBindingPattern(declaration.name) && declaration.name.elements.length > 0 {
				return getTypeFromBindingPattern(declaration.name, true, false)
			}
		}
		return nil
	}
	getContextualTypeForReturnExpression := func(node Expression, contextFlags *ContextFlags) *Type {
		func_ := getContainingFunction(node)
		if func_ {
			contextualReturnType := getContextualReturnType(func_, contextFlags)
			if contextualReturnType {
				functionFlags := getFunctionFlags(func_)
				if functionFlags & FunctionFlagsGenerator {
					isAsyncGenerator := (functionFlags & FunctionFlagsAsync) != 0
					if contextualReturnType.flags & TypeFlagsUnion {
						contextualReturnType = filterType(contextualReturnType, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
							return !!getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, type_, isAsyncGenerator)
						})
					}
					iterationReturnType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, contextualReturnType, (functionFlags&FunctionFlagsAsync) != 0)
					if !iterationReturnType {
						return nil
					}
					contextualReturnType = iterationReturnType
				}
				if functionFlags & FunctionFlagsAsync {
					contextualAwaitedType := mapType(contextualReturnType, getAwaitedTypeNoAlias)
					return contextualAwaitedType && getUnionType( /* TODO(ArrayLiteralExpression): [contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)] */ TODO)
				}
				return contextualReturnType
			}
		}
		return nil
	}
	getContextualTypeForAwaitOperand := func(node AwaitExpression, contextFlags *ContextFlags) *Type {
		contextualType := getContextualType(node, contextFlags)
		if contextualType {
			contextualAwaitedType := getAwaitedTypeNoAlias(contextualType)
			return contextualAwaitedType && getUnionType( /* TODO(ArrayLiteralExpression): [contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)] */ TODO)
		}
		return nil
	}
	getContextualTypeForYieldOperand := func(node YieldExpression, contextFlags *ContextFlags) *Type {
		func_ := getContainingFunction(node)
		if func_ {
			functionFlags := getFunctionFlags(func_)
			contextualReturnType := getContextualReturnType(func_, contextFlags)
			if contextualReturnType {
				isAsyncGenerator := (functionFlags & FunctionFlagsAsync) != 0
				if !node.asteriskToken && contextualReturnType.flags&TypeFlagsUnion {
					contextualReturnType = filterType(contextualReturnType, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
						return !!getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, type_, isAsyncGenerator)
					})
				}
				if node.asteriskToken {
					iterationTypes := getIterationTypesOfGeneratorFunctionReturnType(contextualReturnType, isAsyncGenerator)
					yieldType := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): iterationTypes?.yieldType ?? silentNeverType */ TODO
					returnType := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getContextualType(node, contextFlags) ?? silentNeverType */ TODO
					nextType := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): iterationTypes?.nextType ?? unknownType */ TODO
					generatorType := createGeneratorType(yieldType, returnType, nextType, false)
					if isAsyncGenerator {
						asyncGeneratorType := createGeneratorType(yieldType, returnType, nextType, true)
						return getUnionType( /* TODO(ArrayLiteralExpression): [generatorType, asyncGeneratorType] */ TODO)
					}
					return generatorType
				}
				return getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindYield, contextualReturnType, isAsyncGenerator)
			}
		}
		return nil
	}
	isInParameterInitializerBeforeContainingFunction := func(node Node) /* TODO inferred type boolean */ TODO {
		inBindingInitializer := false
		for node.parent && !isFunctionLike(node.parent) {
			if isParameter(node.parent) && (inBindingInitializer || node.parent.initializer == node) {
				return true
			}
			if isBindingElement(node.parent) && node.parent.initializer == node {
				inBindingInitializer = true
			}
			node = node.parent
		}
		return false
	}
	getContextualIterationType := func(kind IterationTypeKind, functionDecl SignatureDeclaration) *Type {
		isAsync := !!(getFunctionFlags(functionDecl) & FunctionFlagsAsync)
		contextualReturnType := getContextualReturnType(functionDecl, nil)
		if contextualReturnType {
			return getIterationTypeOfGeneratorFunctionReturnType(kind, contextualReturnType, isAsync) || nil
		}
		return nil
	}
	getContextualReturnType := func(functionDecl SignatureDeclaration, contextFlags *ContextFlags) *Type {
		returnType := getReturnTypeFromAnnotation(functionDecl)
		if returnType {
			return returnType
		}
		signature := getContextualSignatureForFunctionLikeDeclaration(functionDecl)
		if signature && !isResolvingReturnTypeOfSignature(signature) {
			returnType := getReturnTypeOfSignature(signature)
			functionFlags := getFunctionFlags(functionDecl)
			if functionFlags & FunctionFlagsGenerator {
				return filterType(returnType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !!(t.flags & (TypeFlagsAnyOrUnknown | TypeFlagsVoid | TypeFlagsInstantiableNonPrimitive)) || checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags, nil)
				})
			}
			if functionFlags & FunctionFlagsAsync {
				return filterType(returnType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !!(t.flags & (TypeFlagsAnyOrUnknown | TypeFlagsVoid | TypeFlagsInstantiableNonPrimitive)) || !!getAwaitedTypeOfPromise(t)
				})
			}
			return returnType
		}
		iife := getImmediatelyInvokedFunctionExpression(functionDecl)
		if iife {
			return getContextualType(iife, contextFlags)
		}
		return nil
	}
	getContextualTypeForArgument := func(callTarget CallLikeExpression, arg Expression) *Type {
		args := getEffectiveCallArguments(callTarget)
		argIndex := args.indexOf(arg)
		return /* TODO(ConditionalExpression): argIndex === -1 ? undefined : getContextualTypeForArgumentAtIndex(callTarget, argIndex) */ TODO
	}
	getContextualTypeForArgumentAtIndex := func(callTarget CallLikeExpression, argIndex number) Type {
		if isImportCall(callTarget) {
			return /* TODO(ConditionalExpression): argIndex === 0 ? stringType :                 argIndex === 1 ? getGlobalImportCallOptionsType(/*reportErrors* / false) :                 anyType */ TODO
		}
		signature := /* TODO(ConditionalExpression): getNodeLinks(callTarget).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(callTarget) */ TODO
		if isJsxOpeningLikeElement(callTarget) && argIndex == 0 {
			return getEffectiveFirstArgumentForJsxSignature(signature, callTarget)
		}
		restIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - 1 */ TODO
		return /* TODO(ConditionalExpression): signatureHasRestParameter(signature) && argIndex >= restIndex ?             getIndexedAccessType(getTypeOfSymbol(signature.parameters[restIndex]), getNumberLiteralType(argIndex - restIndex), AccessFlags.Contextual) :             getTypeAtPosition(signature, argIndex) */ TODO
	}
	getContextualTypeForDecorator := func(decorator Decorator) *Type {
		signature := getDecoratorCallSignature(decorator)
		return /* TODO(ConditionalExpression): signature ? getOrCreateTypeFromSignature(signature) : undefined */ TODO
	}
	getContextualTypeForSubstitutionExpression := func(template TemplateExpression, substitutionExpression Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if template.parent.kind == SyntaxKindTaggedTemplateExpression {
			return getContextualTypeForArgument(template.parent, substitutionExpression)
		}
		return nil
	}
	getContextualTypeForBinaryOperand := func(node Expression, contextFlags *ContextFlags) *Type {
		binaryExpression := node.parent
		TODO_IDENTIFIER := binaryExpression
		switch operatorToken.kind {
		case SyntaxKindEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAmpersandAmpersandEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindBarBarEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindQuestionQuestionEqualsToken:
			return /* TODO(ConditionalExpression): node === right ? getContextualTypeForAssignmentDeclaration(binaryExpression) : undefined */ TODO
		case SyntaxKindBarBarToken:
			fallthrough // TODO: merge cases
		case SyntaxKindQuestionQuestionToken:
			type_ := getContextualType(binaryExpression, contextFlags)
			return /* TODO(ConditionalExpression): node === right && (type && type.pattern || !type && !isDefaultedExpandoInitializer(binaryExpression)) ?                     getTypeOfExpression(left) : type */ TODO
		case SyntaxKindAmpersandAmpersandToken:
			fallthrough // TODO: merge cases
		case SyntaxKindCommaToken:
			return /* TODO(ConditionalExpression): node === right ? getContextualType(binaryExpression, contextFlags) : undefined */ TODO
		default:
			return nil
		}
	}
	getSymbolForExpression := func(e Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if canHaveSymbol(e) && e.symbol {
			return e.symbol
		}
		if isIdentifier(e) {
			return getResolvedSymbol(e)
		}
		if isPropertyAccessExpression(e) {
			lhsType := getTypeOfExpression(e.expression)
			return /* TODO(ConditionalExpression): isPrivateIdentifier(e.name) ? tryGetPrivateIdentifierPropertyOfType(lhsType, e.name) : getPropertyOfType(lhsType, e.name.escapedText) */ TODO
		}
		if isElementAccessExpression(e) {
			propType := checkExpressionCached(e.argumentExpression)
			if !isTypeUsableAsPropertyName(propType) {
				return nil
			}
			lhsType := getTypeOfExpression(e.expression)
			return getPropertyOfType(lhsType, getPropertyNameFromType(propType))
		}
		return nil
		tryGetPrivateIdentifierPropertyOfType := func(type_ Type, id PrivateIdentifier) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			lexicallyScopedSymbol := lookupSymbolForPrivateIdentifierDeclaration(id.escapedText, id)
			return lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(type_, lexicallyScopedSymbol)
		}
	}
	getContextualTypeForAssignmentDeclaration := func(binaryExpression BinaryExpression) *Type {
		kind := getAssignmentDeclarationKind(binaryExpression)
		switch kind {
		case AssignmentDeclarationKindNone:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindThisProperty:
			lhsSymbol := getSymbolForExpression(binaryExpression.left)
			decl := lhsSymbol && lhsSymbol.valueDeclaration
			if decl && (isPropertyDeclaration(decl) || isPropertySignature(decl)) {
				overallAnnotation := getEffectiveTypeAnnotationNode(decl)
				return (overallAnnotation && instantiateType(getTypeFromTypeNode(overallAnnotation), getSymbolLinks(lhsSymbol).mapper)) || ( /* TODO(ConditionalExpression): isPropertyDeclaration(decl) ? decl.initializer && getTypeOfExpression(binaryExpression.left) : undefined */ TODO)
			}
			if kind == AssignmentDeclarationKindNone {
				return getTypeOfExpression(binaryExpression.left)
			}
			return getContextualTypeForThisPropertyAssignment(binaryExpression)
		case AssignmentDeclarationKindProperty:
			if isPossiblyAliasedThisProperty(binaryExpression, kind) {
				return getContextualTypeForThisPropertyAssignment(binaryExpression)
			} else if !canHaveSymbol(binaryExpression.left) || !binaryExpression.left.symbol {
				return getTypeOfExpression(binaryExpression.left)
			} else {
				decl := binaryExpression.left.symbol.valueDeclaration
				if !decl {
					return nil
				}
				lhs := cast(binaryExpression.left, isAccessExpression)
				overallAnnotation := getEffectiveTypeAnnotationNode(decl)
				if overallAnnotation {
					return getTypeFromTypeNode(overallAnnotation)
				} else if isIdentifier(lhs.expression) {
					id := lhs.expression
					parentSymbol := resolveName(id, id.escapedText, SymbolFlagsValue, nil, true)
					if parentSymbol {
						annotated := parentSymbol.valueDeclaration && getEffectiveTypeAnnotationNode(parentSymbol.valueDeclaration)
						if annotated {
							nameStr := getElementOrPropertyAccessName(lhs)
							if nameStr != nil {
								return getTypeOfPropertyOfContextualType(getTypeFromTypeNode(annotated), nameStr)
							}
						}
						return nil
					}
				}
				return /* TODO(ConditionalExpression): isInJSFile(decl) || decl === binaryExpression.left ? undefined : getTypeOfExpression(binaryExpression.left) */ TODO
			}
			fallthrough
		case AssignmentDeclarationKindExportsProperty:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindPrototype:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindPrototypeProperty:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindModuleExports:
			var valueDeclaration Declaration
			if kind != AssignmentDeclarationKindModuleExports {
				valueDeclaration = /* TODO(ConditionalExpression): canHaveSymbol(binaryExpression.left) ? binaryExpression.left.symbol?.valueDeclaration : undefined */ TODO
			}
			/* TODO(ExpressionStatement): valueDeclaration ||= binaryExpression.symbol?.valueDeclaration; */
			annotated := valueDeclaration && getEffectiveTypeAnnotationNode(valueDeclaration)
			return /* TODO(ConditionalExpression): annotated ? getTypeFromTypeNode(annotated) : undefined */ TODO
		case AssignmentDeclarationKindObjectDefinePropertyValue:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindObjectDefinePropertyExports:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindObjectDefinePrototypeProperty:
			return Debug.fail("Does not apply")
		default:
			return Debug.assertNever(kind)
		}
	}
	isPossiblyAliasedThisProperty := func(declaration BinaryExpression, kind /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").AssignmentDeclarationKind */ TODO /*  = getAssignmentDeclarationKind(declaration) */) /* TODO inferred type boolean */ TODO {
		if kind == AssignmentDeclarationKindThisProperty {
			return true
		}
		if !isInJSFile(declaration) || kind != AssignmentDeclarationKindProperty || !isIdentifier((declaration.left).expression) {
			return false
		}
		name := ((declaration.left).expression).escapedText
		symbol := resolveName(declaration.left, name, SymbolFlagsValue, nil, true, true)
		return isThisInitializedDeclaration(symbol.valueDeclaration)
	}
	getContextualTypeForThisPropertyAssignment := func(binaryExpression BinaryExpression) *Type {
		if !binaryExpression.symbol {
			return getTypeOfExpression(binaryExpression.left)
		}
		if binaryExpression.symbol.valueDeclaration {
			annotated := getEffectiveTypeAnnotationNode(binaryExpression.symbol.valueDeclaration)
			if annotated {
				type_ := getTypeFromTypeNode(annotated)
				if type_ {
					return type_
				}
			}
		}
		thisAccess := cast(binaryExpression.left, isAccessExpression)
		if !isObjectLiteralMethod(getThisContainer(thisAccess.expression, false, false)) {
			return nil
		}
		thisType := checkThisExpression(thisAccess.expression)
		nameStr := getElementOrPropertyAccessName(thisAccess)
		return nameStr != nil && getTypeOfPropertyOfContextualType(thisType, nameStr) || nil
	}
	isCircularMappedProperty := func(symbol Symbol) /* TODO inferred type boolean */ TODO {
		return !!(getCheckFlags(symbol)&CheckFlagsMapped && !(symbol).links.type_ && findResolutionCycleStartIndex(symbol, TypeSystemPropertyNameType) >= 0)
	}
	isExcludedMappedPropertyName := func(constraint Type, propertyNameType Type) bool {
		if constraint.flags & TypeFlagsConditional {
			type_ := constraint
			return !!(getReducedType(getTrueTypeFromConditionalType(type_)).flags & TypeFlagsNever) && getActualTypeVariable(getFalseTypeFromConditionalType(type_)) == getActualTypeVariable(type_.checkType) && isTypeAssignableTo(propertyNameType, type_.extendsType)
		}
		if constraint.flags & TypeFlagsIntersection {
			return some((constraint).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return isExcludedMappedPropertyName(t, propertyNameType)
			})
		}
		return false
	}
	getTypeOfPropertyOfContextualType := func(type_ Type, name __String, nameType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			if t.flags & TypeFlagsIntersection {
				var types /* TODO(ArrayType): Type[] */ any
				var indexInfoCandidates /* TODO(ArrayType): Type[] */ any
				ignoreIndexInfos := false
				for _, constituentType := range (t).types {
					if !(constituentType.flags & TypeFlagsObject) {
						continue
					}
					if isGenericMappedType(constituentType) && getMappedTypeNameTypeKind(constituentType) != MappedTypeNameTypeKindRemapping {
						substitutedType := getIndexedMappedTypeSubstitutedTypeOfContextualType(constituentType, name, nameType)
						types = appendContextualPropertyTypeConstituent(types, substitutedType)
						continue
					}
					propertyType := getTypeOfConcretePropertyOfContextualType(constituentType, name)
					if !propertyType {
						if !ignoreIndexInfos {
							indexInfoCandidates = append(indexInfoCandidates, constituentType)
						}
						continue
					}
					ignoreIndexInfos = true
					indexInfoCandidates = nil
					types = appendContextualPropertyTypeConstituent(types, propertyType)
				}
				if indexInfoCandidates {
					for _, candidate := range indexInfoCandidates {
						indexInfoType := getTypeFromIndexInfosOfContextualType(candidate, name, nameType)
						types = appendContextualPropertyTypeConstituent(types, indexInfoType)
					}
				}
				if !types {
					return
				}
				if types.length == 1 {
					return /* TODO(ElementAccessExpression): types[0] */ TODO
				}
				return getIntersectionType(types)
			}
			if !(t.flags & TypeFlagsObject) {
				return
			}
			return /* TODO(ConditionalExpression): isGenericMappedType(t) && getMappedTypeNameTypeKind(t) !== MappedTypeNameTypeKind.Remapping                 ? getIndexedMappedTypeSubstitutedTypeOfContextualType(t, name, nameType)                 : getTypeOfConcretePropertyOfContextualType(t, name) ?? getTypeFromIndexInfosOfContextualType(t, name, nameType) */ TODO
		}, true)
	}
	appendContextualPropertyTypeConstituent := func(types /* TODO(ArrayType): Type[] */ any, type_ *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ TODO {
		return /* TODO(ConditionalExpression): type ? append(types, type.flags & TypeFlags.Any ? unknownType : type) : types */ TODO
	}
	getIndexedMappedTypeSubstitutedTypeOfContextualType := func(type_ MappedType, name __String, nameType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		propertyNameType := nameType || getStringLiteralType(unescapeLeadingUnderscores(name))
		constraint := getConstraintTypeFromMappedType(type_)
		if type_.nameType && isExcludedMappedPropertyName(type_.nameType, propertyNameType) || isExcludedMappedPropertyName(constraint, propertyNameType) {
			return
		}
		constraintOfConstraint := getBaseConstraintOfType(constraint) || constraint
		if !isTypeAssignableTo(propertyNameType, constraintOfConstraint) {
			return
		}
		return substituteIndexedMappedType(type_, propertyNameType)
	}
	getTypeOfConcretePropertyOfContextualType := func(type_ Type, name __String) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		prop := getPropertyOfType(type_, name)
		if !prop || isCircularMappedProperty(prop) {
			return
		}
		return removeMissingType(getTypeOfSymbol(prop), !!(prop.flags & SymbolFlagsOptional))
	}
	getTypeFromIndexInfosOfContextualType := func(type_ Type, name __String, nameType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if isTupleType(type_) && isNumericLiteralName(name) && +name >= 0 {
			restType := getElementTypeOfSliceOfTupleType(type_, type_.target.fixedLength, 0, false, true)
			if restType {
				return restType
			}
		}
		return findApplicableIndexInfo(getIndexInfosOfStructuredType(type_), nameType || getStringLiteralType(unescapeLeadingUnderscores(name))).type_
	}
	getContextualTypeForObjectLiteralMethod := func(node MethodDeclaration, contextFlags *ContextFlags) *Type {
		Debug.assert(isObjectLiteralMethod(node))
		if node.flags & NodeFlagsInWithStatement {
			return nil
		}
		return getContextualTypeForObjectLiteralElement(node, contextFlags)
	}
	getContextualTypeForObjectLiteralElement := func(element ObjectLiteralElementLike, contextFlags *ContextFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		objectLiteral := element.parent
		propertyAssignmentType := isPropertyAssignment(element) && getContextualTypeForVariableLikeDeclaration(element, contextFlags)
		if propertyAssignmentType {
			return propertyAssignmentType
		}
		type_ := getApparentTypeOfContextualType(objectLiteral, contextFlags)
		if type_ {
			if hasBindableName(element) {
				symbol := getSymbolOfDeclaration(element)
				return getTypeOfPropertyOfContextualType(type_, symbol.escapedName, getSymbolLinks(symbol).nameType)
			}
			if hasDynamicName(element) {
				name := getNameOfDeclaration(element)
				if name && isComputedPropertyName(name) {
					exprType := checkExpression(name.expression)
					propType := isTypeUsableAsPropertyName(exprType) && getTypeOfPropertyOfContextualType(type_, getPropertyNameFromType(exprType))
					if propType {
						return propType
					}
				}
			}
			if element.name {
				nameType := getLiteralTypeFromPropertyName(element.name)
				return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
					return findApplicableIndexInfo(getIndexInfosOfStructuredType(t), nameType).type_
				}, true)
			}
		}
		return nil
	}
	getSpreadIndices := func(elements []Node) /* TODO inferred type { first: number | undefined; last: number | undefined; } */ TODO {
		var first TODO
		var last TODO
		/* TODO(ForStatement): for (let i = 0; i < elements.length; i++) {             if (isSpreadElement(elements[i])) {                 first ??= i;                 last = i;             }         } */
		return /* TODO(ObjectLiteralExpression): { first, last } */ TODO
	}
	getContextualTypeForElementExpression := func(type_ *Type, index number, length number, firstSpreadIndex number, lastSpreadIndex number) *Type {
		return type_ && mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			if isTupleType(t) {
				if (firstSpreadIndex == nil || index < firstSpreadIndex) && index < t.target.fixedLength {
					return removeMissingType( /* TODO(ElementAccessExpression): getTypeArguments(t)[index] */ TODO, !!( /* TODO(ElementAccessExpression): t.target.elementFlags[index] */ TODO && ElementFlagsOptional))
				}
				offset := /* TODO(ConditionalExpression): length !== undefined && (lastSpreadIndex === undefined || index > lastSpreadIndex) ? length - index : 0 */ TODO
				fixedEndLength := /* TODO(ConditionalExpression): offset > 0 && (t.target.combinedFlags & ElementFlags.Variable) ? getEndElementCount(t.target, ElementFlags.Fixed) : 0 */ TODO
				if offset > 0 && offset <= fixedEndLength {
					return /* TODO(ElementAccessExpression): getTypeArguments(t)[getTypeReferenceArity(t) - offset] */ TODO
				}
				return getElementTypeOfSliceOfTupleType(t /* TODO(ConditionalExpression): firstSpreadIndex === undefined ? t.target.fixedLength : Math.min(t.target.fixedLength, firstSpreadIndex) */, TODO /* TODO(ConditionalExpression): length === undefined || lastSpreadIndex === undefined ? fixedEndLength : Math.min(fixedEndLength, length - lastSpreadIndex) */, TODO, false, true)
			}
			return (!firstSpreadIndex || index < firstSpreadIndex) && getTypeOfPropertyOfContextualType(t /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + index */, TODO) || getIteratedTypeOrElementType(IterationUseElement, t, undefinedType, nil, false)
		}, true)
	}
	getContextualTypeForConditionalOperand := func(node Expression, contextFlags *ContextFlags) *Type {
		conditional := node.parent
		return /* TODO(ConditionalExpression): node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional, contextFlags) : undefined */ TODO
	}
	getContextualTypeForChildJsxExpression := func(node JsxElement, child JsxChild, contextFlags *ContextFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		attributesType := getApparentTypeOfContextualType(node.openingElement.attributes, contextFlags)
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
		if !(attributesType && !isTypeAny(attributesType) && jsxChildrenPropertyName && jsxChildrenPropertyName != "") {
			return nil
		}
		realChildren := getSemanticJsxChildren(node.children)
		childIndex := realChildren.indexOf(child)
		childFieldType := getTypeOfPropertyOfContextualType(attributesType, jsxChildrenPropertyName)
		return childFieldType && ( /* TODO(ConditionalExpression): realChildren.length === 1 ? childFieldType : mapType(childFieldType, t => {             if (isArrayLikeType(t)) {                 return getIndexedAccessType(t, getNumberLiteralType(childIndex));             }             else {                 return t;             }         }, /*noReductions* / true) */ TODO)
	}
	getContextualTypeForJsxExpression := func(node JsxExpression, contextFlags *ContextFlags) *Type {
		exprParent := node.parent
		return /* TODO(ConditionalExpression): isJsxAttributeLike(exprParent)             ? getContextualType(node, contextFlags)             : isJsxElement(exprParent)             ? getContextualTypeForChildJsxExpression(exprParent, node, contextFlags)             : undefined */ TODO
	}
	getContextualTypeForJsxAttribute := func(attribute /* TODO(UnionType): JsxAttribute | JsxSpreadAttribute */ any, contextFlags *ContextFlags) *Type {
		if isJsxAttribute(attribute) {
			attributesType := getApparentTypeOfContextualType(attribute.parent, contextFlags)
			if !attributesType || isTypeAny(attributesType) {
				return nil
			}
			return getTypeOfPropertyOfContextualType(attributesType, getEscapedTextOfJsxAttributeName(attribute.name))
		} else {
			return getContextualType(attribute.parent, contextFlags)
		}
	}
	isPossiblyDiscriminantValue := func(node Expression) bool {
		switch node.kind {
		case SyntaxKindStringLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindNumericLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindBigIntLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindTemplateExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTrueKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindFalseKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindNullKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindUndefinedKeyword:
			return true
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindParenthesizedExpression:
			return isPossiblyDiscriminantValue((node).expression)
		case SyntaxKindJsxExpression:
			return !(node).expression || isPossiblyDiscriminantValue((node).expression)
		}
		return false
	}
	discriminateContextualTypeByObjectMembers := func(node ObjectLiteralExpression, contextualType UnionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		key := /* TODO(TemplateExpression): `D${getNodeId(node)},${getTypeId(contextualType)}` */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(             key,             getMatchingUnionConstituentForObjectLiteral(contextualType, node) ?? discriminateTypeByDiscriminableItems(                 contextualType,                 concatenate(                     map(                         filter(node.properties, (p): p is PropertyAssignment | ShorthandPropertyAssignment => {                             if (!p.symbol) {                                 return false;                             }                             if (p.kind === SyntaxKind.PropertyAssignment) {                                 return isPossiblyDiscriminantValue(p.initializer) && isDiscriminantProperty(contextualType, p.symbol.escapedName);                             }                             if (p.kind === SyntaxKind.ShorthandPropertyAssignment) {                                 return isDiscriminantProperty(contextualType, p.symbol.escapedName);                             }                             return false;                         }),                         prop => ([() => getContextFreeTypeOfExpression(prop.kind === SyntaxKind.PropertyAssignment ? prop.initializer : prop.name), prop.symbol.escapedName] as const),                     ),                     map(                         filter(getPropertiesOfType(contextualType), s => !!(s.flags & SymbolFlags.Optional) && !!node?.symbol?.members && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)),                         s => [() => undefinedType, s.escapedName] as const,                     ),                 ),                 isTypeAssignableTo,             ),         ) */ TODO
	}
	discriminateContextualTypeByJSXAttributes := func(node JsxAttributes, contextualType UnionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		key := /* TODO(TemplateExpression): `D${getNodeId(node)},${getTypeId(contextualType)}` */ TODO
		cached := getCachedType(key)
		if cached {
			return cached
		}
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
		return setCachedType(key, discriminateTypeByDiscriminableItems(contextualType, concatenate(map_(filter(node.properties, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttribute | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSpreadAttribute */ TODO) /* TODO inferred type boolean */ TODO {
			return !!p.symbol && p.kind == SyntaxKindJsxAttribute && isDiscriminantProperty(contextualType, p.symbol.escapedName) && (!p.initializer || isPossiblyDiscriminantValue(p.initializer))
		}), func(prop /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttribute | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSpreadAttribute */ TODO) /* TODO inferred type readonly [() => import("/home/jabaile/work/TypeScript/src/compiler/types").Type, import("/home/jabaile/work/TypeScript/src/compiler/types").__String] */ TODO {
			return ( /* TODO(ArrayLiteralExpression): [!(prop as JsxAttribute).initializer ? (() => trueType) : (() => getContextFreeTypeOfExpression((prop as JsxAttribute).initializer!)), prop.symbol.escapedName] */ TODO)
		}), map_(filter(getPropertiesOfType(contextualType), func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
			if !(s.flags & SymbolFlagsOptional) || !node.symbol.members {
				return false
			}
			element := node.parent.parent
			if s.escapedName == jsxChildrenPropertyName && isJsxElement(element) && getSemanticJsxChildren(element.children).length {
				return false
			}
			return !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)
		}), func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type readonly [() => import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType, import("/home/jabaile/work/TypeScript/src/compiler/types").__String] */ TODO {
			return /* TODO(ArrayLiteralExpression): [() => undefinedType, s.escapedName] */ TODO
		})), isTypeAssignableTo))
	}
	getApparentTypeOfContextualType := func(node /* TODO(UnionType): Expression | MethodDeclaration */ any, contextFlags *ContextFlags) *Type {
		contextualType := /* TODO(ConditionalExpression): isObjectLiteralMethod(node) ?             getContextualTypeForObjectLiteralMethod(node, contextFlags) :             getContextualType(node, contextFlags) */ TODO
		instantiatedType := instantiateContextualType(contextualType, node, contextFlags)
		if instantiatedType && !(contextFlags && contextFlags&ContextFlagsNoConstraints && instantiatedType.flags&TypeFlagsTypeVariable) {
			apparentType := mapType(instantiatedType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return /* TODO(ConditionalExpression): getObjectFlags(t) & ObjectFlags.Mapped ? t : getApparentType(t) */ TODO
			}, true)
			return /* TODO(ConditionalExpression): apparentType.flags & TypeFlags.Union && isObjectLiteralExpression(node) ? discriminateContextualTypeByObjectMembers(node, apparentType as UnionType) :                 apparentType.flags & TypeFlags.Union && isJsxAttributes(node) ? discriminateContextualTypeByJSXAttributes(node, apparentType as UnionType) :                 apparentType */ TODO
		}
	}
	instantiateContextualType := func(contextualType *Type, node Node, contextFlags *ContextFlags) *Type {
		if contextualType && maybeTypeOfKind(contextualType, TypeFlagsInstantiable) {
			inferenceContext := getInferenceContext(node)
			if inferenceContext && contextFlags&ContextFlagsSignature && some(inferenceContext.inferences, hasInferenceCandidatesOrDefault) {
				return instantiateInstantiableTypes(contextualType, inferenceContext.nonFixingMapper)
			}
			if inferenceContext.returnMapper {
				type_ := instantiateInstantiableTypes(contextualType, inferenceContext.returnMapper)
				return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union && containsType((type as UnionType).types, regularFalseType) && containsType((type as UnionType).types, regularTrueType) ?                     filterType(type, t => t !== regularFalseType && t !== regularTrueType) :                     type */ TODO
			}
		}
		return contextualType
	}
	instantiateInstantiableTypes := func(type_ Type, mapper TypeMapper) Type {
		if type_.flags & TypeFlagsInstantiable {
			return instantiateType(type_, mapper)
		}
		if type_.flags & TypeFlagsUnion {
			return getUnionType(map_((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return instantiateInstantiableTypes(t, mapper)
			}), UnionReductionNone)
		}
		if type_.flags & TypeFlagsIntersection {
			return getIntersectionType(map_((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return instantiateInstantiableTypes(t, mapper)
			}))
		}
		return type_
	}
	getContextualType := func(node Expression, contextFlags *ContextFlags) *Type {
		if node.flags & NodeFlagsInWithStatement {
			return nil
		}
		index := findContextualNode(node, !contextFlags)
		if index >= 0 {
			return /* TODO(ElementAccessExpression): contextualTypes[index] */ TODO
		}
		TODO_IDENTIFIER := node
		switch parent.kind {
		case SyntaxKindVariableDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindParameter:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertySignature:
			fallthrough // TODO: merge cases
		case SyntaxKindBindingElement:
			return getContextualTypeForInitializerExpression(node, contextFlags)
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindReturnStatement:
			return getContextualTypeForReturnExpression(node, contextFlags)
		case SyntaxKindYieldExpression:
			return getContextualTypeForYieldOperand(parent, contextFlags)
		case SyntaxKindAwaitExpression:
			return getContextualTypeForAwaitOperand(parent, contextFlags)
		case SyntaxKindCallExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNewExpression:
			return getContextualTypeForArgument(parent, node)
		case SyntaxKindDecorator:
			return getContextualTypeForDecorator(parent)
		case SyntaxKindTypeAssertionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindAsExpression:
			return /* TODO(ConditionalExpression): isConstTypeReference((parent as AssertionExpression).type) ? getContextualType(parent as AssertionExpression, contextFlags) : getTypeFromTypeNode((parent as AssertionExpression).type) */ TODO
		case SyntaxKindBinaryExpression:
			return getContextualTypeForBinaryOperand(node, contextFlags)
		case SyntaxKindPropertyAssignment:
			fallthrough // TODO: merge cases
		case SyntaxKindShorthandPropertyAssignment:
			return getContextualTypeForObjectLiteralElement(parent, contextFlags)
		case SyntaxKindSpreadAssignment:
			return getContextualType(parent.parent, contextFlags)
		case SyntaxKindArrayLiteralExpression:
			arrayLiteral := parent
			type_ := getApparentTypeOfContextualType(arrayLiteral, contextFlags)
			elementIndex := indexOfNode(arrayLiteral.elements, node)
			spreadIndices := /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): getNodeLinks(arrayLiteral).spreadIndices ??= getSpreadIndices(arrayLiteral.elements) */ TODO
			return getContextualTypeForElementExpression(type_, elementIndex, arrayLiteral.elements.length, spreadIndices.first, spreadIndices.last)
			fallthrough
		case SyntaxKindConditionalExpression:
			return getContextualTypeForConditionalOperand(node, contextFlags)
		case SyntaxKindTemplateSpan:
			Debug.assert(parent.parent.kind == SyntaxKindTemplateExpression)
			return getContextualTypeForSubstitutionExpression(parent.parent, node)
		case SyntaxKindParenthesizedExpression:
			if isInJSFile(parent) {
				if isJSDocSatisfiesExpression(parent) {
					return getTypeFromTypeNode(getJSDocSatisfiesExpressionType(parent))
				}
				typeTag := getJSDocTypeTag(parent)
				if typeTag && !isConstTypeReference(typeTag.typeExpression.type_) {
					return getTypeFromTypeNode(typeTag.typeExpression.type_)
				}
			}
			return getContextualType(parent, contextFlags)
			fallthrough
		case SyntaxKindNonNullExpression:
			return getContextualType(parent, contextFlags)
		case SyntaxKindSatisfiesExpression:
			return getTypeFromTypeNode((parent).type_)
		case SyntaxKindExportAssignment:
			return tryGetTypeFromEffectiveTypeNode(parent)
		case SyntaxKindJsxExpression:
			return getContextualTypeForJsxExpression(parent, contextFlags)
		case SyntaxKindJsxAttribute:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSpreadAttribute:
			return getContextualTypeForJsxAttribute(parent, contextFlags)
		case SyntaxKindJsxOpeningElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSelfClosingElement:
			return getContextualJsxElementAttributesType(parent, contextFlags)
		case SyntaxKindImportAttribute:
			return getContextualImportAttributeType(parent)
		}
		return nil
	}
	pushCachedContextualType := func(node Expression) {
		pushContextualType(node, getContextualType(node, nil), true)
	}
	pushContextualType := func(node Expression, type_ *Type, isCache bool) {
		/* TODO(ElementAccessExpression): contextualTypeNodes[contextualTypeCount] */ TODO = node
		/* TODO(ElementAccessExpression): contextualTypes[contextualTypeCount] */ TODO = type_
		/* TODO(ElementAccessExpression): contextualIsCache[contextualTypeCount] */ TODO = isCache
		contextualTypeCount++
	}
	popContextualType := func() {
		contextualTypeCount--
	}
	findContextualNode := func(node Node, includeCaches bool) /* TODO inferred type number */ TODO {
		/* TODO(ForStatement): for (let i = contextualTypeCount - 1; i >= 0; i--) {             if (node === contextualTypeNodes[i] && (includeCaches || !contextualIsCache[i])) {                 return i;             }         } */
		return -1
	}
	pushInferenceContext := func(node Node, inferenceContext *InferenceContext) {
		/* TODO(ElementAccessExpression): inferenceContextNodes[inferenceContextCount] */ TODO = node
		/* TODO(ElementAccessExpression): inferenceContexts[inferenceContextCount] */ TODO = inferenceContext
		inferenceContextCount++
	}
	popInferenceContext := func() {
		inferenceContextCount--
	}
	getInferenceContext := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceContext | undefined */ TODO {
		/* TODO(ForStatement): for (let i = inferenceContextCount - 1; i >= 0; i--) {             if (isNodeDescendantOf(node, inferenceContextNodes[i])) {                 return inferenceContexts[i];             }         } */
	}
	getContextualImportAttributeType := func(node ImportAttribute) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return getTypeOfPropertyOfContextualType(getGlobalImportAttributesType(false), getNameFromImportAttribute(node))
	}
	getContextualJsxElementAttributesType := func(node JsxOpeningLikeElement, contextFlags *ContextFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if isJsxOpeningElement(node) && contextFlags != ContextFlagsCompletions {
			index := findContextualNode(node.parent, !contextFlags)
			if index >= 0 {
				return /* TODO(ElementAccessExpression): contextualTypes[index] */ TODO
			}
		}
		return getContextualTypeForArgumentAtIndex(node, 0)
	}
	getEffectiveFirstArgumentForJsxSignature := func(signature Signature, node JsxOpeningLikeElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): getJsxReferenceKind(node) !== JsxReferenceKind.Component             ? getJsxPropsTypeFromCallSignature(signature, node)             : getJsxPropsTypeFromClassType(signature, node) */ TODO
	}
	getJsxPropsTypeFromCallSignature := func(sig Signature, context JsxOpeningLikeElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		propsType := getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)
		propsType = getJsxManagedAttributesFromLocatedAttributes(context, getJsxNamespaceAt(context), propsType)
		intrinsicAttribs := getJsxType(JsxNames.IntrinsicAttributes, context)
		if !isErrorType(intrinsicAttribs) {
			propsType = intersectTypes(intrinsicAttribs, propsType)
		}
		return propsType
	}
	getJsxPropsTypeForSignatureFromMember := func(sig Signature, forcedLookupLocation __String) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if sig.compositeSignatures {
			var results []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, signature := range sig.compositeSignatures {
				instance := getReturnTypeOfSignature(signature)
				if isTypeAny(instance) {
					return instance
				}
				propType := getTypeOfPropertyOfType(instance, forcedLookupLocation)
				if !propType {
					return
				}
				results.push(propType)
			}
			return getIntersectionType(results)
		}
		instanceType := getReturnTypeOfSignature(sig)
		return /* TODO(ConditionalExpression): isTypeAny(instanceType) ? instanceType : getTypeOfPropertyOfType(instanceType, forcedLookupLocation) */ TODO
	}
	getStaticTypeOfReferencedJsxConstructor := func(context JsxOpeningLikeElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isJsxIntrinsicTagName(context.tagName) {
			result := getIntrinsicAttributesTypeFromJsxOpeningLikeElement(context)
			fakeSignature := createSignatureForJSXIntrinsic(context, result)
			return getOrCreateTypeFromSignature(fakeSignature)
		}
		tagType := checkExpressionCached(context.tagName)
		if tagType.flags & TypeFlagsStringLiteral {
			result := getIntrinsicAttributesTypeFromStringLiteralType(tagType, context)
			if !result {
				return errorType
			}
			fakeSignature := createSignatureForJSXIntrinsic(context, result)
			return getOrCreateTypeFromSignature(fakeSignature)
		}
		return tagType
	}
	getJsxManagedAttributesFromLocatedAttributes := func(context JsxOpeningLikeElement, ns Symbol, attributesType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		managedSym := getJsxLibraryManagedAttributes(ns)
		if managedSym {
			ctorType := getStaticTypeOfReferencedJsxConstructor(context)
			result := instantiateAliasOrInterfaceWithDefaults(managedSym, isInJSFile(context), ctorType, attributesType)
			if result {
				return result
			}
		}
		return attributesType
	}
	getJsxPropsTypeFromClassType := func(sig Signature, context JsxOpeningLikeElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		ns := getJsxNamespaceAt(context)
		forcedLookupLocation := getJsxElementPropertiesName(ns)
		attributesType := /* TODO(ConditionalExpression): forcedLookupLocation === undefined             // If there is no type ElementAttributesProperty, return the type of the first parameter of the signature, which should be the props type             ? getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)             : forcedLookupLocation === ""             // If there is no e.g. 'props' member in ElementAttributesProperty, use the element class type instead             ? getReturnTypeOfSignature(sig)             // Otherwise get the type of the property on the signature return type             : getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation) */ TODO
		if !attributesType {
			if !!forcedLookupLocation && !!length(context.attributes.properties) {
				error(context, Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property, unescapeLeadingUnderscores(forcedLookupLocation))
			}
			return unknownType
		}
		attributesType = getJsxManagedAttributesFromLocatedAttributes(context, ns, attributesType)
		if isTypeAny(attributesType) {
			return attributesType
		} else {
			apparentAttributesType := attributesType
			intrinsicClassAttribs := getJsxType(JsxNames.IntrinsicClassAttributes, context)
			if !isErrorType(intrinsicClassAttribs) {
				typeParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(intrinsicClassAttribs.symbol)
				hostClassType := getReturnTypeOfSignature(sig)
				var libraryManagedAttributeType Type
				if typeParams {
					inferredArgs := fillMissingTypeArguments( /* TODO(ArrayLiteralExpression): [hostClassType] */ TODO, typeParams, getMinTypeArgumentCount(typeParams), isInJSFile(context))
					libraryManagedAttributeType = instantiateType(intrinsicClassAttribs, createTypeMapper(typeParams, inferredArgs))
				} else {
					libraryManagedAttributeType = intrinsicClassAttribs
				}
				apparentAttributesType = intersectTypes(libraryManagedAttributeType, apparentAttributesType)
			}
			intrinsicAttribs := getJsxType(JsxNames.IntrinsicAttributes, context)
			if !isErrorType(intrinsicAttribs) {
				apparentAttributesType = intersectTypes(intrinsicAttribs, apparentAttributesType)
			}
			return apparentAttributesType
		}
	}
	getIntersectedSignatures := func(signatures []Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		return /* TODO(ConditionalExpression): getStrictOptionValue(compilerOptions, "noImplicitAny")             ? reduceLeft(                 signatures,                 (left: Signature | undefined, right) =>                     left === right || !left ? left                         : compareTypeParametersIdentical(left.typeParameters, right!.typeParameters) ? combineSignaturesOfIntersectionMembers(left, right!)                         : undefined,             )             : undefined */ TODO
	}
	combineIntersectionThisParam := func(left *Symbol, right *Symbol, mapper *TypeMapper) *Symbol {
		if !left || !right {
			return left || right
		}
		thisType := getUnionType( /* TODO(ArrayLiteralExpression): [getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)] */ TODO)
		return createSymbolWithType(left, thisType)
	}
	combineIntersectionParameters := func(left Signature, right Signature, mapper *TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		leftCount := getParameterCount(left)
		rightCount := getParameterCount(right)
		longest := /* TODO(ConditionalExpression): leftCount >= rightCount ? left : right */ TODO
		shorter := /* TODO(ConditionalExpression): longest === left ? right : left */ TODO
		longestCount := /* TODO(ConditionalExpression): longest === left ? leftCount : rightCount */ TODO
		eitherHasEffectiveRest := hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right)
		needsExtraRestElement := eitherHasEffectiveRest && !hasEffectiveRestParameter(longest)
		params := /* TODO(NewExpression): new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0)) */ TODO
		/* TODO(ForStatement): for (let i = 0; i < longestCount; i++) {             let longestParamType = tryGetTypeAtPosition(longest, i)!;             if (longest === right) {                 longestParamType = instantiateType(longestParamType, mapper);             }             let shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;             if (shorter === right) {                 shorterParamType = instantiateType(shorterParamType, mapper);             }             const unionParamType = getUnionType([longestParamType, shorterParamType]);             const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);             const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);             const leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);             const rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);              const paramName = leftName === rightName ? leftName :                 !leftName ? rightName :                 !rightName ? leftName :                 undefined;             const paramSymbol = createSymbol(                 SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0),                 paramName || `arg${i}` as __String,             );             paramSymbol.links.type = isRestParam ? createArrayType(unionParamType) : unionParamType;             params[i] = paramSymbol;         } */
		if needsExtraRestElement {
			restParamSymbol := createSymbol(SymbolFlagsFunctionScopedVariable, "args")
			restParamSymbol.links.type_ = createArrayType(getTypeAtPosition(shorter, longestCount))
			if shorter == right {
				restParamSymbol.links.type_ = instantiateType(restParamSymbol.links.type_, mapper)
			}
			/* TODO(ElementAccessExpression): params[longestCount] */ TODO = restParamSymbol
		}
		return params
	}
	combineSignaturesOfIntersectionMembers := func(left Signature, right Signature) Signature {
		typeParams := left.typeParameters || right.typeParameters
		var paramMapper *TypeMapper
		if left.typeParameters && right.typeParameters {
			paramMapper = createTypeMapper(right.typeParameters, left.typeParameters)
		}
		declaration := left.declaration
		params := combineIntersectionParameters(left, right, paramMapper)
		thisParam := combineIntersectionThisParam(left.thisParameter, right.thisParameter, paramMapper)
		minArgCount := Math.max(left.minArgumentCount, right.minArgumentCount)
		result := createSignature(declaration, typeParams, thisParam, params, nil, nil, minArgCount, (left.flags|right.flags)&SignatureFlagsPropagatingFlags)
		result.compositeKind = TypeFlagsIntersection
		result.compositeSignatures = concatenate(left.compositeKind == TypeFlagsIntersection && left.compositeSignatures || /* TODO(ArrayLiteralExpression): [left] */ TODO /* TODO(ArrayLiteralExpression): [right] */, TODO)
		if paramMapper {
			result.mapper = /* TODO(ConditionalExpression): left.compositeKind === TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper */ TODO
		}
		return result
	}
	getContextualCallSignature := func(type_ Type, node SignatureDeclaration) *Signature {
		signatures := getSignaturesOfType(type_, SignatureKindCall)
		applicableByArity := filter(signatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
			return !isAritySmaller(s, node)
		})
		return /* TODO(ConditionalExpression): applicableByArity.length === 1 ? applicableByArity[0] : getIntersectedSignatures(applicableByArity) */ TODO
	}
	isAritySmaller := func(signature Signature, target SignatureDeclaration) /* TODO inferred type boolean */ TODO {
		targetParameterCount := 0
		/* TODO(ForStatement): for (; targetParameterCount < target.parameters.length; targetParameterCount++) {             const param = target.parameters[targetParameterCount];             if (param.initializer || param.questionToken || param.dotDotDotToken || isJSDocOptionalParameter(param)) {                 break;             }         } */
		if target.parameters.length && parameterIsThisKeyword( /* TODO(ElementAccessExpression): target.parameters[0] */ TODO) {
			targetParameterCount--
		}
		return !hasEffectiveRestParameter(signature) && getParameterCount(signature) < targetParameterCount
	}
	getContextualSignatureForFunctionLikeDeclaration := func(node FunctionLikeDeclaration) *Signature {
		return /* TODO(ConditionalExpression): isFunctionExpressionOrArrowFunction(node) || isObjectLiteralMethod(node)             ? getContextualSignature(node as FunctionExpression)             : undefined */ TODO
	}
	getContextualSignature := func(node /* TODO(UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any) *Signature {
		Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
		typeTagSignature := getSignatureOfTypeTag(node)
		if typeTagSignature {
			return typeTagSignature
		}
		type_ := getApparentTypeOfContextualType(node, ContextFlagsSignature)
		if !type_ {
			return nil
		}
		if !(type_.flags & TypeFlagsUnion) {
			return getContextualCallSignature(type_, node)
		}
		var signatureList /* TODO(ArrayType): Signature[] */ any
		types := (type_).types
		for _, current := range types {
			signature := getContextualCallSignature(current, node)
			if signature {
				if !signatureList {
					signatureList = /* TODO(ArrayLiteralExpression): [signature] */ TODO
				} else if !compareSignaturesIdentical( /* TODO(ElementAccessExpression): signatureList[0] */ TODO, signature, false, true, true, compareTypesIdentical) {
					return nil
				} else {
					signatureList.push(signature)
				}
			}
		}
		if signatureList {
			return /* TODO(ConditionalExpression): signatureList.length === 1 ? signatureList[0] : createUnionSignature(signatureList[0], signatureList) */ TODO
		}
	}
	checkGrammarRegularExpressionLiteral := func(node RegularExpressionLiteral) /* TODO inferred type boolean */ TODO {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) && !node.isUnterminated {
			var lastError *DiagnosticWithLocation
			/* TODO(ExpressionStatement): scanner ??= createScanner(ScriptTarget.ESNext, /*skipTrivia* / true); */
			scanner.setScriptTarget(sourceFile.languageVersion)
			scanner.setLanguageVariant(sourceFile.languageVariant)
			scanner.setOnError(func(message /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO, length /* TODO inferred type number */ TODO, arg0 /* TODO inferred type any */ TODO) {
				start := scanner.getTokenEnd()
				if message.category == DiagnosticCategoryMessage && lastError && start == lastError.start && length == lastError.length {
					error := createDetachedDiagnostic(sourceFile.fileName, sourceFile.text, start, length, message, arg0)
					addRelatedInfo(lastError, error)
				} else if !lastError || start != lastError.start {
					lastError = createFileDiagnostic(sourceFile, start, length, message, arg0)
					diagnostics.add(lastError)
				}
			})
			scanner.setText(sourceFile.text, node.pos /* TODO(MinusToken): - */ /* TODO(BinaryExpression): node.end - node.pos */, TODO)
			/* TODO(TryStatement): try {                 scanner.scan();                 Debug.assert(scanner.reScanSlashToken(/*reportErrors* / true) === SyntaxKind.RegularExpressionLiteral, "Expected scanner to rescan RegularExpressionLiteral");                 return !!lastError;             }             finally {                 scanner.setText("");                 scanner.setOnError(/*onError* / undefined);             } */
		}
		return false
	}
	checkRegularExpressionLiteral := func(node RegularExpressionLiteral) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		nodeLinks := getNodeLinks(node)
		if !(nodeLinks.flags & NodeCheckFlagsTypeChecked) {
			nodeLinks.flags |= NodeCheckFlagsTypeChecked
			addLazyDiagnostic(func() /* TODO inferred type boolean */ TODO {
				return checkGrammarRegularExpressionLiteral(node)
			})
		}
		return globalRegExpType
	}
	checkSpreadExpression := func(node SpreadElement, checkMode CheckMode) Type {
		if languageVersion < LanguageFeatureMinimumTargetSpreadElements {
			checkExternalEmitHelpers(node /* TODO(ConditionalExpression): compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray */, TODO)
		}
		arrayOrIterableType := checkExpression(node.expression, checkMode)
		return checkIteratedTypeOrElementType(IterationUseSpread, arrayOrIterableType, undefinedType, node.expression)
	}
	checkSyntheticExpression := func(node SyntheticExpression) Type {
		return /* TODO(ConditionalExpression): node.isSpread ? getIndexedAccessType(node.type, numberType) : node.type */ TODO
	}
	hasDefaultValue := func(node /* TODO(UnionType): BindingElement | ObjectLiteralElementLike | Expression */ any) bool {
		return node.kind == SyntaxKindBindingElement && !!(node).initializer || node.kind == SyntaxKindPropertyAssignment && hasDefaultValue((node).initializer) || node.kind == SyntaxKindShorthandPropertyAssignment && !!(node).objectAssignmentInitializer || node.kind == SyntaxKindBinaryExpression && (node).operatorToken.kind == SyntaxKindEqualsToken
	}
	isSpreadIntoCallOrNew := func(node ArrayLiteralExpression) /* TODO inferred type boolean */ TODO {
		parent := walkUpParenthesizedExpressions(node.parent)
		return isSpreadElement(parent) && isCallOrNewExpression(parent.parent)
	}
	checkArrayLiteral := func(node ArrayLiteralExpression, checkMode *CheckMode, forceTuple /* TODO(BooleanKeyword): boolean */ any) Type {
		elements := node.elements
		elementCount := elements.length
		var elementTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var elementFlags []ElementFlags = /* TODO(ArrayLiteralExpression): [] */ TODO
		pushCachedContextualType(node)
		inDestructuringPattern := isAssignmentTarget(node)
		inConstContext := isConstContext(node)
		contextualType := getApparentTypeOfContextualType(node, nil)
		inTupleContext := isSpreadIntoCallOrNew(node) || !!contextualType && someType(contextualType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return isTupleLikeType(t) || isGenericMappedType(t) && !t.nameType && !!getHomomorphicTypeVariable(t.target || t)
		})
		hasOmittedExpression := false
		/* TODO(ForStatement): for (let i = 0; i < elementCount; i++) {             const e = elements[i];             if (e.kind === SyntaxKind.SpreadElement) {                 if (languageVersion < LanguageFeatureMinimumTarget.SpreadElements) {                     checkExternalEmitHelpers(e, compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray);                 }                 const spreadType = checkExpression((e as SpreadElement).expression, checkMode, forceTuple);                 if (isArrayLikeType(spreadType)) {                     elementTypes.push(spreadType);                     elementFlags.push(ElementFlags.Variadic);                 }                 else if (inDestructuringPattern) {                     // Given the following situation:                     //    var c: {};                     //    [...c] = ["", 0];                     //                     // c is represented in the tree as a spread element in an array literal.                     // But c really functions as a rest element, and its purpose is to provide                     // a contextual type for the right hand side of the assignment. Therefore,                     // instead of calling checkExpression on "...c", which will give an error                     // if c is not iterable/array-like, we need to act as if we are trying to                     // get the contextual element type from it. So we do something similar to                     // getContextualTypeForElementExpression, which will crucially not error                     // if there is no index type / iterated type.                     const restElementType = getIndexTypeOfType(spreadType, numberType) ||                         getIteratedTypeOrElementType(IterationUse.Destructuring, spreadType, undefinedType, /*errorNode* / undefined, /*checkAssignability* / false) ||                         unknownType;                     elementTypes.push(restElementType);                     elementFlags.push(ElementFlags.Rest);                 }                 else {                     elementTypes.push(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, (e as SpreadElement).expression));                     elementFlags.push(ElementFlags.Rest);                 }             }             else if (exactOptionalPropertyTypes && e.kind === SyntaxKind.OmittedExpression) {                 hasOmittedExpression = true;                 elementTypes.push(undefinedOrMissingType);                 elementFlags.push(ElementFlags.Optional);             }             else {                 const type = checkExpressionForMutableLocation(e, checkMode, forceTuple);                 elementTypes.push(addOptionality(type, /*isProperty* / true, hasOmittedExpression));                 elementFlags.push(hasOmittedExpression ? ElementFlags.Optional : ElementFlags.Required);                 if (inTupleContext && checkMode && checkMode & CheckMode.Inferential && !(checkMode & CheckMode.SkipContextSensitive) && isContextSensitive(e)) {                     const inferenceContext = getInferenceContext(node);                     Debug.assert(inferenceContext); // In CheckMode.Inferential we should always have an inference context                     addIntraExpressionInferenceSite(inferenceContext, e, type);                 }             }         } */
		popContextualType()
		if inDestructuringPattern {
			return createTupleType(elementTypes, elementFlags)
		}
		if forceTuple || inConstContext || inTupleContext {
			return createArrayLiteralType(createTupleType(elementTypes, elementFlags, inConstContext && !(contextualType && someType(contextualType, isMutableArrayLikeType))))
		}
		return createArrayLiteralType(createArrayType( /* TODO(ConditionalExpression): elementTypes.length ?                 getUnionType(sameMap(elementTypes, (t, i) => elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessTypeOrUndefined(t, numberType) || anyType : t), UnionReduction.Subtype) :                 strictNullChecks ? implicitNeverType : undefinedWideningType */ TODO, inConstContext))
	}
	createArrayLiteralType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !(getObjectFlags(type_) & ObjectFlagsReference) {
			return type_
		}
		literalType := (type_).literalType
		if !literalType {
			literalType = /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): (type as TypeReference).literalType = cloneTypeReference(type as TypeReference) */ TODO
			literalType.objectFlags |= ObjectFlagsArrayLiteral | ObjectFlagsContainsObjectOrArrayLiteral
		}
		return literalType
	}
	isNumericName := func(name DeclarationName) bool {
		switch name.kind {
		case SyntaxKindComputedPropertyName:
			return isNumericComputedName(name)
		case SyntaxKindIdentifier:
			return isNumericLiteralName(name.escapedText)
		case SyntaxKindNumericLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindStringLiteral:
			return isNumericLiteralName(name.text)
		default:
			return false
		}
	}
	isNumericComputedName := func(name ComputedPropertyName) bool {
		return isTypeAssignableToKind(checkComputedPropertyName(name), TypeFlagsNumberLike)
	}
	checkComputedPropertyName := func(node ComputedPropertyName) Type {
		links := getNodeLinks(node.expression)
		if !links.resolvedType {
			if (isTypeLiteralNode(node.parent.parent) || isClassLike(node.parent.parent) || isInterfaceDeclaration(node.parent.parent)) && isBinaryExpression(node.expression) && node.expression.operatorToken.kind == SyntaxKindInKeyword && node.parent.kind != SyntaxKindGetAccessor && node.parent.kind != SyntaxKindSetAccessor {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = errorType */ TODO
			}
			links.resolvedType = checkExpression(node.expression)
			if isPropertyDeclaration(node.parent) && !hasStaticModifier(node.parent) && isClassExpression(node.parent.parent) {
				container := getEnclosingBlockScopeContainer(node.parent.parent)
				enclosingIterationStatement := getEnclosingIterationStatement(container)
				if enclosingIterationStatement {
					getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
					getNodeLinks(node).flags |= NodeCheckFlagsBlockScopedBindingInLoop
					getNodeLinks(node.parent.parent).flags |= NodeCheckFlagsBlockScopedBindingInLoop
				}
			}
			if links.resolvedType.flags&TypeFlagsNullable || !isTypeAssignableToKind(links.resolvedType, TypeFlagsStringLike|TypeFlagsNumberLike|TypeFlagsESSymbolLike) && !isTypeAssignableTo(links.resolvedType, stringNumberSymbolType) {
				error(node, Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any)
			}
		}
		return links.resolvedType
	}
	isSymbolWithNumericName := func(symbol Symbol) /* TODO inferred type boolean | undefined */ TODO {
		firstDecl := /* TODO(ElementAccessExpression): symbol.declarations?.[0] */ TODO
		return isNumericLiteralName(symbol.escapedName) || (firstDecl && isNamedDeclaration(firstDecl) && isNumericName(firstDecl.name))
	}
	isSymbolWithSymbolName := func(symbol Symbol) /* TODO inferred type boolean | undefined */ TODO {
		firstDecl := /* TODO(ElementAccessExpression): symbol.declarations?.[0] */ TODO
		return isKnownSymbol(symbol) || (firstDecl && isNamedDeclaration(firstDecl) && isComputedPropertyName(firstDecl.name) && isTypeAssignableToKind(checkComputedPropertyName(firstDecl.name), TypeFlagsESSymbol))
	}
	getObjectLiteralIndexInfo := func(node ObjectLiteralExpression, offset number, properties []Symbol, keyType Type) IndexInfo {
		var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = offset; i < properties.length; i++) {             const prop = properties[i];             if (                 keyType === stringType && !isSymbolWithSymbolName(prop) ||                 keyType === numberType && isSymbolWithNumericName(prop) ||                 keyType === esSymbolType && isSymbolWithSymbolName(prop)             ) {                 propTypes.push(getTypeOfSymbol(properties[i]));             }         } */
		unionType := /* TODO(ConditionalExpression): propTypes.length ? getUnionType(propTypes, UnionReduction.Subtype) : undefinedType */ TODO
		return createIndexInfo(keyType, unionType, isConstContext(node))
	}
	getImmediateAliasedSymbol := func(symbol Symbol) *Symbol {
		Debug.assert((symbol.flags&SymbolFlagsAlias) != 0, "Should only get Alias here.")
		links := getSymbolLinks(symbol)
		if !links.immediateTarget {
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				return Debug.fail()
			}
			links.immediateTarget = getTargetOfAliasDeclaration(node, true)
		}
		return links.immediateTarget
	}
	checkObjectLiteral := func(node ObjectLiteralExpression, checkMode CheckMode /*  = CheckMode.Normal */) Type {
		inDestructuringPattern := isAssignmentTarget(node)
		checkGrammarObjectLiteralExpression(node, inDestructuringPattern)
		allPropertiesTable := /* TODO(ConditionalExpression): strictNullChecks ? createSymbolTable() : undefined */ TODO
		propertiesTable := createSymbolTable()
		var propertiesArray []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		var spread Type = emptyObjectType
		pushCachedContextualType(node)
		contextualType := getApparentTypeOfContextualType(node, nil)
		contextualTypeHasPattern := contextualType && contextualType.pattern && (contextualType.pattern.kind == SyntaxKindObjectBindingPattern || contextualType.pattern.kind == SyntaxKindObjectLiteralExpression)
		inConstContext := isConstContext(node)
		checkFlags := /* TODO(ConditionalExpression): inConstContext ? CheckFlags.Readonly : 0 */ TODO
		isInJavascript := isInJSFile(node) && !isInJsonFile(node)
		enumTag := /* TODO(ConditionalExpression): isInJavascript ? getJSDocEnumTag(node) : undefined */ TODO
		isJSObjectLiteral := !contextualType && isInJavascript && !enumTag
		var objectFlags ObjectFlags = ObjectFlagsFreshLiteral
		patternWithComputedProperties := false
		hasComputedStringProperty := false
		hasComputedNumberProperty := false
		hasComputedSymbolProperty := false
		for _, elem := range node.properties {
			if elem.name && isComputedPropertyName(elem.name) {
				checkComputedPropertyName(elem.name)
			}
		}
		offset := 0
		for _, memberDecl := range node.properties {
			member := getSymbolOfDeclaration(memberDecl)
			computedNameType := /* TODO(ConditionalExpression): memberDecl.name && memberDecl.name.kind === SyntaxKind.ComputedPropertyName ?                 checkComputedPropertyName(memberDecl.name) : undefined */ TODO
			if memberDecl.kind == SyntaxKindPropertyAssignment || memberDecl.kind == SyntaxKindShorthandPropertyAssignment || isObjectLiteralMethod(memberDecl) {
				type_ := /* TODO(ConditionalExpression): memberDecl.kind === SyntaxKind.PropertyAssignment ? checkPropertyAssignment(memberDecl, checkMode) :                     // avoid resolving the left side of the ShorthandPropertyAssignment outside of the destructuring                     // for error recovery purposes. For example, if a user wrote `{ a = 100 }` instead of `{ a: 100 }`.                     // we don't want to say "could not find 'a'".                     memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment ? checkExpressionForMutableLocation(!inDestructuringPattern && memberDecl.objectAssignmentInitializer ? memberDecl.objectAssignmentInitializer : memberDecl.name, checkMode) :                     checkObjectLiteralMethod(memberDecl, checkMode) */ TODO
				if isInJavascript {
					jsDocType := getTypeForDeclarationFromJSDocComment(memberDecl)
					if jsDocType {
						checkTypeAssignableTo(type_, jsDocType, memberDecl)
						type_ = jsDocType
					} else if enumTag && enumTag.typeExpression {
						checkTypeAssignableTo(type_, getTypeFromTypeNode(enumTag.typeExpression), memberDecl)
					}
				}
				objectFlags |= getObjectFlags(type_) & ObjectFlagsPropagatingFlags
				nameType := /* TODO(ConditionalExpression): computedNameType && isTypeUsableAsPropertyName(computedNameType) ? computedNameType : undefined */ TODO
				prop := /* TODO(ConditionalExpression): nameType ?                     createSymbol(SymbolFlags.Property | member.flags, getPropertyNameFromType(nameType), checkFlags | CheckFlags.Late) :                     createSymbol(SymbolFlags.Property | member.flags, member.escapedName, checkFlags) */ TODO
				if nameType {
					prop.links.nameType = nameType
				}
				if inDestructuringPattern && hasDefaultValue(memberDecl) {
					prop.flags |= SymbolFlagsOptional
				} else if contextualTypeHasPattern && !(getObjectFlags(contextualType) & ObjectFlagsObjectLiteralPatternWithComputedProperties) {
					impliedProp := getPropertyOfType(contextualType, member.escapedName)
					if impliedProp {
						prop.flags |= impliedProp.flags & SymbolFlagsOptional
					} else if !getIndexInfoOfType(contextualType, stringType) {
						error(memberDecl.name, Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(member), typeToString(contextualType))
					}
				}
				prop.declarations = member.declarations
				prop.parent = member.parent
				if member.valueDeclaration {
					prop.valueDeclaration = member.valueDeclaration
				}
				prop.links.type_ = type_
				prop.links.target = member
				member = prop
				allPropertiesTable.set(prop.escapedName, prop)
				if contextualType && checkMode&CheckModeInferential && !(checkMode & CheckModeSkipContextSensitive) && (memberDecl.kind == SyntaxKindPropertyAssignment || memberDecl.kind == SyntaxKindMethodDeclaration) && isContextSensitive(memberDecl) {
					inferenceContext := getInferenceContext(node)
					Debug.assert(inferenceContext)
					inferenceNode := /* TODO(ConditionalExpression): memberDecl.kind === SyntaxKind.PropertyAssignment ? memberDecl.initializer : memberDecl */ TODO
					addIntraExpressionInferenceSite(inferenceContext, inferenceNode, type_)
				}
			} else if memberDecl.kind == SyntaxKindSpreadAssignment {
				if languageVersion < LanguageFeatureMinimumTargetObjectAssign {
					checkExternalEmitHelpers(memberDecl, ExternalEmitHelpersAssign)
				}
				if propertiesArray.length > 0 {
					spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext)
					propertiesArray = /* TODO(ArrayLiteralExpression): [] */ TODO
					propertiesTable = createSymbolTable()
					hasComputedStringProperty = false
					hasComputedNumberProperty = false
					hasComputedSymbolProperty = false
				}
				type_ := getReducedType(checkExpression(memberDecl.expression, checkMode&CheckModeInferential))
				if isValidSpreadType(type_) {
					mergedType := tryMergeUnionOfObjectTypeAndEmptyObject(type_, inConstContext)
					if allPropertiesTable {
						checkSpreadPropOverrides(mergedType, allPropertiesTable, memberDecl)
					}
					offset = propertiesArray.length
					if isErrorType(spread) {
						continue
					}
					spread = getSpreadType(spread, mergedType, node.symbol, objectFlags, inConstContext)
				} else {
					error(memberDecl, Diagnostics.Spread_types_may_only_be_created_from_object_types)
					spread = errorType
				}
				continue
			} else {
				Debug.assert(memberDecl.kind == SyntaxKindGetAccessor || memberDecl.kind == SyntaxKindSetAccessor)
				checkNodeDeferred(memberDecl)
			}
			if computedNameType && !(computedNameType.flags & TypeFlagsStringOrNumberLiteralOrUnique) {
				if isTypeAssignableTo(computedNameType, stringNumberSymbolType) {
					if isTypeAssignableTo(computedNameType, numberType) {
						hasComputedNumberProperty = true
					} else if isTypeAssignableTo(computedNameType, esSymbolType) {
						hasComputedSymbolProperty = true
					} else {
						hasComputedStringProperty = true
					}
					if inDestructuringPattern {
						patternWithComputedProperties = true
					}
				}
			} else {
				propertiesTable.set(member.escapedName, member)
			}
			propertiesArray.push(member)
		}
		popContextualType()
		if isErrorType(spread) {
			return errorType
		}
		if spread != emptyObjectType {
			if propertiesArray.length > 0 {
				spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext)
				propertiesArray = /* TODO(ArrayLiteralExpression): [] */ TODO
				propertiesTable = createSymbolTable()
				hasComputedStringProperty = false
				hasComputedNumberProperty = false
			}
			return mapType(spread, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				return /* TODO(ConditionalExpression): t === emptyObjectType ? createObjectLiteralType() : t */ TODO
			})
		}
		return createObjectLiteralType()
		createObjectLiteralType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
			indexInfos := /* TODO(ArrayLiteralExpression): [] */ TODO
			if hasComputedStringProperty {
				indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, stringType))
			}
			if hasComputedNumberProperty {
				indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, numberType))
			}
			if hasComputedSymbolProperty {
				indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, esSymbolType))
			}
			result := createAnonymousType(node.symbol, propertiesTable, emptyArray, emptyArray, indexInfos)
			result.objectFlags |= objectFlags | ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
			if isJSObjectLiteral {
				result.objectFlags |= ObjectFlagsJSLiteral
			}
			if patternWithComputedProperties {
				result.objectFlags |= ObjectFlagsObjectLiteralPatternWithComputedProperties
			}
			if inDestructuringPattern {
				result.pattern = node
			}
			return result
		}
	}
	isValidSpreadType := func(type_ Type) bool {
		t := removeDefinitelyFalsyTypes(mapType(type_, getBaseConstraintOrType))
		return !!(t.flags&(TypeFlagsAny|TypeFlagsNonPrimitive|TypeFlagsObject|TypeFlagsInstantiableNonPrimitive) || t.flags&TypeFlagsUnionOrIntersection && every((t).types, isValidSpreadType))
	}
	checkJsxSelfClosingElementDeferred := func(node JsxSelfClosingElement) {
		checkJsxOpeningLikeElementOrOpeningFragment(node)
	}
	checkJsxSelfClosingElement := func(node JsxSelfClosingElement, _checkMode *CheckMode) Type {
		checkNodeDeferred(node)
		return getJsxElementTypeAt(node) || anyType
	}
	checkJsxElementDeferred := func(node JsxElement) {
		checkJsxOpeningLikeElementOrOpeningFragment(node.openingElement)
		if isJsxIntrinsicTagName(node.closingElement.tagName) {
			getIntrinsicTagSymbol(node.closingElement)
		} else {
			checkExpression(node.closingElement.tagName)
		}
		checkJsxChildren(node)
	}
	checkJsxElement := func(node JsxElement, _checkMode *CheckMode) Type {
		checkNodeDeferred(node)
		return getJsxElementTypeAt(node) || anyType
	}
	checkJsxFragment := func(node JsxFragment) Type {
		checkJsxOpeningLikeElementOrOpeningFragment(node.openingFragment)
		nodeSourceFile := getSourceFileOfNode(node)
		if getJSXTransformEnabled(compilerOptions) && (compilerOptions.jsxFactory || nodeSourceFile.pragmas.has("jsx")) && !compilerOptions.jsxFragmentFactory && !nodeSourceFile.pragmas.has("jsxfrag") {
			error(node /* TODO(ConditionalExpression): compilerOptions.jsxFactory                     ? Diagnostics.The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option                     : Diagnostics.An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments */, TODO)
		}
		checkJsxChildren(node)
		return getJsxElementTypeAt(node) || anyType
	}
	isHyphenatedJsxName := func(name /* TODO(UnionType): string | __String */ any) /* TODO inferred type boolean */ TODO {
		return (name).includes("-")
	}
	isJsxIntrinsicTagName := func(tagName Node) /* TODO(TypePredicate): tagName is Identifier | JsxNamespacedName */ any {
		return isIdentifier(tagName) && isIntrinsicJsxName(tagName.escapedText) || isJsxNamespacedName(tagName)
	}
	checkJsxAttribute := func(node JsxAttribute, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): node.initializer             ? checkExpressionForMutableLocation(node.initializer, checkMode)             : trueType */ TODO
	}
	createJsxAttributesTypeFromAttributesProperty := func(openingLikeElement JsxOpeningLikeElement, checkMode CheckMode /*  = CheckMode.Normal */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		attributes := openingLikeElement.attributes
		contextualType := getContextualType(attributes, ContextFlagsNone)
		allAttributesTable := /* TODO(ConditionalExpression): strictNullChecks ? createSymbolTable() : undefined */ TODO
		attributesTable := createSymbolTable()
		var spread Type = emptyJsxObjectType
		hasSpreadAnyType := false
		var typeToIntersect *Type
		explicitlySpecifyChildrenAttribute := false
		var objectFlags ObjectFlags = ObjectFlagsJsxAttributes
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(openingLikeElement))
		for _, attributeDecl := range attributes.properties {
			member := attributeDecl.symbol
			if isJsxAttribute(attributeDecl) {
				exprType := checkJsxAttribute(attributeDecl, checkMode)
				objectFlags |= getObjectFlags(exprType) & ObjectFlagsPropagatingFlags
				attributeSymbol := createSymbol(SymbolFlagsProperty|member.flags, member.escapedName)
				attributeSymbol.declarations = member.declarations
				attributeSymbol.parent = member.parent
				if member.valueDeclaration {
					attributeSymbol.valueDeclaration = member.valueDeclaration
				}
				attributeSymbol.links.type_ = exprType
				attributeSymbol.links.target = member
				attributesTable.set(attributeSymbol.escapedName, attributeSymbol)
				allAttributesTable.set(attributeSymbol.escapedName, attributeSymbol)
				if getEscapedTextOfJsxAttributeName(attributeDecl.name) == jsxChildrenPropertyName {
					explicitlySpecifyChildrenAttribute = true
				}
				if contextualType {
					prop := getPropertyOfType(contextualType, member.escapedName)
					if prop && prop.declarations && isDeprecatedSymbol(prop) && isIdentifier(attributeDecl.name) {
						addDeprecatedSuggestion(attributeDecl.name, prop.declarations, attributeDecl.name.escapedText)
					}
				}
				if contextualType && checkMode&CheckModeInferential && !(checkMode & CheckModeSkipContextSensitive) && isContextSensitive(attributeDecl) {
					inferenceContext := getInferenceContext(attributes)
					Debug.assert(inferenceContext)
					inferenceNode := (attributeDecl.initializer).expression
					addIntraExpressionInferenceSite(inferenceContext, inferenceNode, exprType)
				}
			} else {
				Debug.assert(attributeDecl.kind == SyntaxKindJsxSpreadAttribute)
				if attributesTable.size > 0 {
					spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, false)
					attributesTable = createSymbolTable()
				}
				exprType := getReducedType(checkExpression(attributeDecl.expression, checkMode&CheckModeInferential))
				if isTypeAny(exprType) {
					hasSpreadAnyType = true
				}
				if isValidSpreadType(exprType) {
					spread = getSpreadType(spread, exprType, attributes.symbol, objectFlags, false)
					if allAttributesTable {
						checkSpreadPropOverrides(exprType, allAttributesTable, attributeDecl)
					}
				} else {
					error(attributeDecl.expression, Diagnostics.Spread_types_may_only_be_created_from_object_types)
					typeToIntersect = /* TODO(ConditionalExpression): typeToIntersect ? getIntersectionType([typeToIntersect, exprType]) : exprType */ TODO
				}
			}
		}
		if !hasSpreadAnyType {
			if attributesTable.size > 0 {
				spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, false)
			}
		}
		parent := /* TODO(ConditionalExpression): openingLikeElement.parent.kind === SyntaxKind.JsxElement ? openingLikeElement.parent as JsxElement : undefined */ TODO
		if parent && parent.openingElement == openingLikeElement && getSemanticJsxChildren(parent.children).length > 0 {
			var childrenTypes []Type = checkJsxChildren(parent, checkMode)
			if !hasSpreadAnyType && jsxChildrenPropertyName && jsxChildrenPropertyName != "" {
				if explicitlySpecifyChildrenAttribute {
					error(attributes, Diagnostics._0_are_specified_twice_The_attribute_named_0_will_be_overwritten, unescapeLeadingUnderscores(jsxChildrenPropertyName))
				}
				contextualType := getApparentTypeOfContextualType(openingLikeElement.attributes, nil)
				childrenContextualType := contextualType && getTypeOfPropertyOfContextualType(contextualType, jsxChildrenPropertyName)
				childrenPropSymbol := createSymbol(SymbolFlagsProperty, jsxChildrenPropertyName)
				childrenPropSymbol.links.type_ = /* TODO(ConditionalExpression): childrenTypes.length === 1 ? childrenTypes[0] :                     childrenContextualType && someType(childrenContextualType, isTupleLikeType) ? createTupleType(childrenTypes) :                     createArrayType(getUnionType(childrenTypes)) */ TODO
				childrenPropSymbol.valueDeclaration = factory.createPropertySignature(nil, unescapeLeadingUnderscores(jsxChildrenPropertyName), nil, nil)
				setParent(childrenPropSymbol.valueDeclaration, attributes)
				childrenPropSymbol.valueDeclaration.symbol = childrenPropSymbol
				childPropMap := createSymbolTable()
				childPropMap.set(jsxChildrenPropertyName, childrenPropSymbol)
				spread = getSpreadType(spread, createAnonymousType(attributes.symbol, childPropMap, emptyArray, emptyArray, emptyArray), attributes.symbol, objectFlags, false)
			}
		}
		if hasSpreadAnyType {
			return anyType
		}
		if typeToIntersect && spread != emptyJsxObjectType {
			return getIntersectionType( /* TODO(ArrayLiteralExpression): [typeToIntersect, spread] */ TODO)
		}
		return typeToIntersect || ( /* TODO(ConditionalExpression): spread === emptyJsxObjectType ? createJsxAttributesType() : spread */ TODO)
		createJsxAttributesType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
			objectFlags |= ObjectFlagsFreshLiteral
			result := createAnonymousType(attributes.symbol, attributesTable, emptyArray, emptyArray, emptyArray)
			result.objectFlags |= objectFlags | ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
			return result
		}
	}
	checkJsxChildren := func(node /* TODO(UnionType): JsxElement | JsxFragment */ any, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
		var childrenTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, child := range node.children {
			if child.kind == SyntaxKindJsxText {
				if !child.containsOnlyTriviaWhiteSpaces {
					childrenTypes.push(stringType)
				}
			} else if child.kind == SyntaxKindJsxExpression && !child.expression {
				continue
			} else {
				childrenTypes.push(checkExpressionForMutableLocation(child, checkMode))
			}
		}
		return childrenTypes
	}
	checkSpreadPropOverrides := func(type_ Type, props SymbolTable, spread /* TODO(UnionType): SpreadAssignment | JsxSpreadAttribute */ any) {
		for _, right := range getPropertiesOfType(type_) {
			if !(right.flags & SymbolFlagsOptional) {
				left := props.get(right.escapedName)
				if left {
					diagnostic := error(left.valueDeclaration, Diagnostics._0_is_specified_more_than_once_so_this_usage_will_be_overwritten, unescapeLeadingUnderscores(left.escapedName))
					addRelatedInfo(diagnostic, createDiagnosticForNode(spread, Diagnostics.This_spread_always_overwrites_this_property))
				}
			}
		}
	}
	checkJsxAttributes := func(node JsxAttributes, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return createJsxAttributesTypeFromAttributesProperty(node.parent, checkMode)
	}
	getJsxType := func(name __String, location Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		namespace := getJsxNamespaceAt(location)
		exports := namespace && getExportsOfSymbol(namespace)
		typeSymbol := exports && getSymbol(exports, name, SymbolFlagsType)
		return /* TODO(ConditionalExpression): typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType */ TODO
	}
	getIntrinsicTagSymbol := func(node /* TODO(UnionType): JsxOpeningLikeElement | JsxClosingElement */ any) Symbol {
		links := getNodeLinks(node)
		if !links.resolvedSymbol {
			intrinsicElementsType := getJsxType(JsxNames.IntrinsicElements, node)
			if !isErrorType(intrinsicElementsType) {
				if !isIdentifier(node.tagName) && !isJsxNamespacedName(node.tagName) {
					return Debug.fail()
				}
				propName := /* TODO(ConditionalExpression): isJsxNamespacedName(node.tagName) ? getEscapedTextOfJsxNamespacedName(node.tagName) : node.tagName.escapedText */ TODO
				intrinsicProp := getPropertyOfType(intrinsicElementsType, propName)
				if intrinsicProp {
					links.jsxFlags |= JsxFlagsIntrinsicNamedElement
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = intrinsicProp */ TODO
				}
				indexSymbol := getApplicableIndexSymbol(intrinsicElementsType, getStringLiteralType(unescapeLeadingUnderscores(propName)))
				if indexSymbol {
					links.jsxFlags |= JsxFlagsIntrinsicIndexedElement
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = indexSymbol */ TODO
				}
				if getTypeOfPropertyOrIndexSignatureOfType(intrinsicElementsType, propName) {
					links.jsxFlags |= JsxFlagsIntrinsicIndexedElement
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = intrinsicElementsType.symbol */ TODO
				}
				error(node, Diagnostics.Property_0_does_not_exist_on_type_1, intrinsicTagNameToString(node.tagName) /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "JSX." + JsxNames.IntrinsicElements */, TODO)
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = unknownSymbol */ TODO
			} else {
				if noImplicitAny {
					error(node, Diagnostics.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists, unescapeLeadingUnderscores(JsxNames.IntrinsicElements))
				}
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = unknownSymbol */ TODO
			}
		}
		return links.resolvedSymbol
	}
	getJsxNamespaceContainerForImplicitImport := func(location Node) *Symbol {
		file := location && getSourceFileOfNode(location)
		links := file && getNodeLinks(file)
		if links && links.jsxImplicitImportContainer == false {
			return nil
		}
		if links && links.jsxImplicitImportContainer {
			return links.jsxImplicitImportContainer
		}
		runtimeImportSpecifier := getJSXRuntimeImport(getJSXImplicitImportBase(compilerOptions, file), compilerOptions)
		if !runtimeImportSpecifier {
			return nil
		}
		isClassic := getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindClassic
		errorMessage := /* TODO(ConditionalExpression): isClassic             ? Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option             : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations */ TODO
		specifier := getJSXRuntimeImportSpecifier(file, runtimeImportSpecifier)
		mod := resolveExternalModule(specifier || location, runtimeImportSpecifier, errorMessage, location)
		result := /* TODO(ConditionalExpression): mod && mod !== unknownSymbol ? getMergedSymbol(resolveSymbol(mod)) : undefined */ TODO
		if links {
			links.jsxImplicitImportContainer = result || false
		}
		return result
	}
	getJsxNamespaceAt := func(location Node) Symbol {
		links := location && getNodeLinks(location)
		if links && links.jsxNamespace {
			return links.jsxNamespace
		}
		if !links || links.jsxNamespace != false {
			resolvedNamespace := getJsxNamespaceContainerForImplicitImport(location)
			if !resolvedNamespace || resolvedNamespace == unknownSymbol {
				namespaceName := getJsxNamespace(location)
				resolvedNamespace = resolveName(location, namespaceName, SymbolFlagsNamespace, nil, false)
			}
			if resolvedNamespace {
				candidate := resolveSymbol(getSymbol(getExportsOfSymbol(resolveSymbol(resolvedNamespace)), JsxNames.JSX, SymbolFlagsNamespace))
				if candidate && candidate != unknownSymbol {
					if links {
						links.jsxNamespace = candidate
					}
					return candidate
				}
			}
			if links {
				links.jsxNamespace = false
			}
		}
		s := resolveSymbol(getGlobalSymbol(JsxNames.JSX, SymbolFlagsNamespace, nil))
		if s == unknownSymbol {
			return nil
		}
		return s
	}
	getNameFromJsxElementAttributesContainer := func(nameOfAttribPropContainer __String, jsxNamespace Symbol) *__String {
		jsxElementAttribPropInterfaceSym := jsxNamespace && getSymbol(jsxNamespace.exports, nameOfAttribPropContainer, SymbolFlagsType)
		jsxElementAttribPropInterfaceType := jsxElementAttribPropInterfaceSym && getDeclaredTypeOfSymbol(jsxElementAttribPropInterfaceSym)
		propertiesOfJsxElementAttribPropInterface := jsxElementAttribPropInterfaceType && getPropertiesOfType(jsxElementAttribPropInterfaceType)
		if propertiesOfJsxElementAttribPropInterface {
			if propertiesOfJsxElementAttribPropInterface.length == 0 {
				return ""
			} else if propertiesOfJsxElementAttribPropInterface.length == 1 {
				return /* TODO(ElementAccessExpression): propertiesOfJsxElementAttribPropInterface[0] */ TODO.escapedName
			} else if propertiesOfJsxElementAttribPropInterface.length > 1 && jsxElementAttribPropInterfaceSym.declarations {
				error( /* TODO(ElementAccessExpression): jsxElementAttribPropInterfaceSym.declarations[0] */ TODO, Diagnostics.The_global_type_JSX_0_may_not_have_more_than_one_property, unescapeLeadingUnderscores(nameOfAttribPropContainer))
			}
		}
		return nil
	}
	getJsxLibraryManagedAttributes := func(jsxNamespace Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		return jsxNamespace && getSymbol(jsxNamespace.exports, JsxNames.LibraryManagedAttributes, SymbolFlagsType)
	}
	getJsxElementTypeSymbol := func(jsxNamespace Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		return jsxNamespace && getSymbol(jsxNamespace.exports, JsxNames.ElementType, SymbolFlagsType)
	}
	getJsxElementPropertiesName := func(jsxNamespace Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		return getNameFromJsxElementAttributesContainer(JsxNames.ElementAttributesPropertyNameContainer, jsxNamespace)
	}
	getJsxElementChildrenPropertyName := func(jsxNamespace Symbol) *__String {
		return getNameFromJsxElementAttributesContainer(JsxNames.ElementChildrenAttributeNameContainer, jsxNamespace)
	}
	getUninstantiatedJsxSignaturesOfType := func(elementType Type, caller JsxOpeningLikeElement) []Signature {
		if elementType.flags & TypeFlagsString {
			return /* TODO(ArrayLiteralExpression): [anySignature] */ TODO
		} else if elementType.flags & TypeFlagsStringLiteral {
			intrinsicType := getIntrinsicAttributesTypeFromStringLiteralType(elementType, caller)
			if !intrinsicType {
				error(caller, Diagnostics.Property_0_does_not_exist_on_type_1, (elementType).value /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "JSX." + JsxNames.IntrinsicElements */, TODO)
				return emptyArray
			} else {
				fakeSignature := createSignatureForJSXIntrinsic(caller, intrinsicType)
				return /* TODO(ArrayLiteralExpression): [fakeSignature] */ TODO
			}
		}
		apparentElemType := getApparentType(elementType)
		signatures := getSignaturesOfType(apparentElemType, SignatureKindConstruct)
		if signatures.length == 0 {
			signatures = getSignaturesOfType(apparentElemType, SignatureKindCall)
		}
		if signatures.length == 0 && apparentElemType.flags&TypeFlagsUnion {
			signatures = getUnionSignatures(map_((apparentElemType).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
				return getUninstantiatedJsxSignaturesOfType(t, caller)
			}))
		}
		return signatures
	}
	getIntrinsicAttributesTypeFromStringLiteralType := func(type_ StringLiteralType, location Node) *Type {
		intrinsicElementsType := getJsxType(JsxNames.IntrinsicElements, location)
		if !isErrorType(intrinsicElementsType) {
			stringLiteralTypeName := type_.value
			intrinsicProp := getPropertyOfType(intrinsicElementsType, escapeLeadingUnderscores(stringLiteralTypeName))
			if intrinsicProp {
				return getTypeOfSymbol(intrinsicProp)
			}
			indexSignatureType := getIndexTypeOfType(intrinsicElementsType, stringType)
			if indexSignatureType {
				return indexSignatureType
			}
			return nil
		}
		return anyType
	}
	checkJsxReturnAssignableToAppropriateBound := func(refKind JsxReferenceKind, elemInstanceType Type, openingLikeElement JsxOpeningLikeElement) {
		if refKind == JsxReferenceKindFunction {
			sfcReturnConstraint := getJsxStatelessElementTypeAt(openingLikeElement)
			if sfcReturnConstraint {
				checkTypeRelatedTo(elemInstanceType, sfcReturnConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_return_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
			}
		} else if refKind == JsxReferenceKindComponent {
			classConstraint := getJsxElementClassTypeAt(openingLikeElement)
			if classConstraint {
				checkTypeRelatedTo(elemInstanceType, classConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_instance_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
			}
		} else {
			sfcReturnConstraint := getJsxStatelessElementTypeAt(openingLikeElement)
			classConstraint := getJsxElementClassTypeAt(openingLikeElement)
			if !sfcReturnConstraint || !classConstraint {
				return
			}
			combined := getUnionType( /* TODO(ArrayLiteralExpression): [sfcReturnConstraint, classConstraint] */ TODO)
			checkTypeRelatedTo(elemInstanceType, combined, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_element_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
		}
		generateInitialErrorChain := func() DiagnosticMessageChain {
			componentName := getTextOfNode(openingLikeElement.tagName)
			return chainDiagnosticMessages(nil, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName)
		}
	}
	getIntrinsicAttributesTypeFromJsxOpeningLikeElement := func(node JsxOpeningLikeElement) Type {
		Debug.assert(isJsxIntrinsicTagName(node.tagName))
		links := getNodeLinks(node)
		if !links.resolvedJsxElementAttributesType {
			symbol := getIntrinsicTagSymbol(node)
			if links.jsxFlags & JsxFlagsIntrinsicNamedElement {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedJsxElementAttributesType = getTypeOfSymbol(symbol) || errorType */ TODO
			} else if links.jsxFlags & JsxFlagsIntrinsicIndexedElement {
				propName := /* TODO(ConditionalExpression): isJsxNamespacedName(node.tagName) ? getEscapedTextOfJsxNamespacedName(node.tagName) : node.tagName.escapedText */ TODO
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedJsxElementAttributesType = getApplicableIndexInfoForName(getJsxType(JsxNames.IntrinsicElements, node), propName)?.type || errorType */ TODO
			} else {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedJsxElementAttributesType = errorType */ TODO
			}
		}
		return links.resolvedJsxElementAttributesType
	}
	getJsxElementClassTypeAt := func(location Node) *Type {
		type_ := getJsxType(JsxNames.ElementClass, location)
		if isErrorType(type_) {
			return nil
		}
		return type_
	}
	getJsxElementTypeAt := func(location Node) Type {
		return getJsxType(JsxNames.Element, location)
	}
	getJsxStatelessElementTypeAt := func(location Node) *Type {
		jsxElementType := getJsxElementTypeAt(location)
		if jsxElementType {
			return getUnionType( /* TODO(ArrayLiteralExpression): [jsxElementType, nullType] */ TODO)
		}
	}
	getJsxElementTypeTypeAt := func(location Node) *Type {
		ns := getJsxNamespaceAt(location)
		if !ns {
			return nil
		}
		sym := getJsxElementTypeSymbol(ns)
		if !sym {
			return nil
		}
		type_ := instantiateAliasOrInterfaceWithDefaults(sym, isInJSFile(location))
		if !type_ || isErrorType(type_) {
			return nil
		}
		return type_
	}
	instantiateAliasOrInterfaceWithDefaults := func(managedSym Symbol, inJs bool, typeArguments []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		declaredManagedType := getDeclaredTypeOfSymbol(managedSym)
		if managedSym.flags & SymbolFlagsTypeAlias {
			params := getSymbolLinks(managedSym).typeParameters
			if length(params) >= typeArguments.length {
				args := fillMissingTypeArguments(typeArguments, params, typeArguments.length, inJs)
				return /* TODO(ConditionalExpression): length(args) === 0 ? declaredManagedType : getTypeAliasInstantiation(managedSym, args) */ TODO
			}
		}
		if length((declaredManagedType).typeParameters) >= typeArguments.length {
			args := fillMissingTypeArguments(typeArguments, (declaredManagedType).typeParameters, typeArguments.length, inJs)
			return createTypeReference(declaredManagedType, args)
		}
		return nil
	}
	getJsxIntrinsicTagNamesAt := func(location Node) []Symbol {
		intrinsics := getJsxType(JsxNames.IntrinsicElements, location)
		return /* TODO(ConditionalExpression): intrinsics ? getPropertiesOfType(intrinsics) : emptyArray */ TODO
	}
	checkJsxPreconditions := func(errorNode Node) {
		if (compilerOptions.jsx || JsxEmitNone) == JsxEmitNone {
			error(errorNode, Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided)
		}
		if getJsxElementTypeAt(errorNode) == nil {
			if noImplicitAny {
				error(errorNode, Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist)
			}
		}
	}
	checkJsxOpeningLikeElementOrOpeningFragment := func(node /* TODO(UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any) {
		isNodeOpeningLikeElement := isJsxOpeningLikeElement(node)
		if isNodeOpeningLikeElement {
			checkGrammarJsxElement(node)
		}
		checkJsxPreconditions(node)
		markJsxAliasReferenced(node)
		if isNodeOpeningLikeElement {
			jsxOpeningLikeNode := node
			sig := getResolvedSignature(jsxOpeningLikeNode)
			checkDeprecatedSignature(sig, node)
			elementTypeConstraint := getJsxElementTypeTypeAt(jsxOpeningLikeNode)
			if elementTypeConstraint != nil {
				tagName := jsxOpeningLikeNode.tagName
				tagType := /* TODO(ConditionalExpression): isJsxIntrinsicTagName(tagName)                     ? getStringLiteralType(intrinsicTagNameToString(tagName))                     : checkExpression(tagName) */ TODO
				checkTypeRelatedTo(tagType, elementTypeConstraint, assignableRelation, tagName, Diagnostics.Its_type_0_is_not_a_valid_JSX_element_type, func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ TODO {
					componentName := getTextOfNode(tagName)
					return chainDiagnosticMessages(nil, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName)
				})
			} else {
				checkJsxReturnAssignableToAppropriateBound(getJsxReferenceKind(jsxOpeningLikeNode), getReturnTypeOfSignature(sig), jsxOpeningLikeNode)
			}
		}
	}
	isKnownProperty := func(targetType Type, name __String, isComparingJsxAttributes bool) bool {
		if targetType.flags & TypeFlagsObject {
			if getPropertyOfObjectType(targetType, name) || getApplicableIndexInfoForName(targetType, name) || isLateBoundName(name) && getIndexInfoOfType(targetType, stringType) || isComparingJsxAttributes && isHyphenatedJsxName(name) {
				return true
			}
		}
		if targetType.flags & TypeFlagsSubstitution {
			return isKnownProperty((targetType).baseType, name, isComparingJsxAttributes)
		}
		if targetType.flags&TypeFlagsUnionOrIntersection && isExcessPropertyCheckTarget(targetType) {
			for _, t := range (targetType).types {
				if isKnownProperty(t, name, isComparingJsxAttributes) {
					return true
				}
			}
		}
		return false
	}
	isExcessPropertyCheckTarget := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsObject && !(getObjectFlags(type_)&ObjectFlagsObjectLiteralPatternWithComputedProperties) || type_.flags&TypeFlagsNonPrimitive || type_.flags&TypeFlagsSubstitution && isExcessPropertyCheckTarget((type_).baseType) || type_.flags&TypeFlagsUnion && some((type_).types, isExcessPropertyCheckTarget) || type_.flags&TypeFlagsIntersection && every((type_).types, isExcessPropertyCheckTarget))
	}
	checkJsxExpression := func(node JsxExpression, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		checkGrammarJsxExpression(node)
		if node.expression {
			type_ := checkExpression(node.expression, checkMode)
			if node.dotDotDotToken && type_ != anyType && !isArrayType(type_) {
				error(node, Diagnostics.JSX_spread_child_must_be_an_array_type)
			}
			return type_
		} else {
			return errorType
		}
	}
	getDeclarationNodeFlagsFromSymbol := func(s Symbol) NodeFlags {
		return /* TODO(ConditionalExpression): s.valueDeclaration ? getCombinedNodeFlagsCached(s.valueDeclaration) : 0 */ TODO
	}
	isPrototypeProperty := func(symbol Symbol) /* TODO inferred type boolean | undefined */ TODO {
		if symbol.flags&SymbolFlagsMethod || getCheckFlags(symbol)&CheckFlagsSyntheticMethod {
			return true
		}
		if isInJSFile(symbol.valueDeclaration) {
			parent := symbol.valueDeclaration.parent
			return parent && isBinaryExpression(parent) && getAssignmentDeclarationKind(parent) == AssignmentDeclarationKindPrototypeProperty
		}
	}
	checkPropertyAccessibility := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName | PropertyAccessExpression | VariableDeclaration | ParameterDeclaration | ImportTypeNode | PropertyAssignment | ShorthandPropertyAssignment | BindingElement */ any, isSuper bool, writing bool, type_ Type, prop Symbol, reportError /* TODO inferred type boolean */ TODO /*  = true */) bool {
		errorNode := /* TODO(ConditionalExpression): !reportError ? undefined :             node.kind === SyntaxKind.QualifiedName ? node.right :             node.kind === SyntaxKind.ImportType ? node :             node.kind === SyntaxKind.BindingElement && node.propertyName ? node.propertyName : node.name */ TODO
		return checkPropertyAccessibilityAtLocation(node, isSuper, writing, type_, prop, errorNode)
	}
	checkPropertyAccessibilityAtLocation := func(location Node, isSuper bool, writing bool, containingType Type, prop Symbol, errorNode Node) bool {
		flags := getDeclarationModifierFlagsFromSymbol(prop, writing)
		if isSuper {
			if languageVersion < ScriptTargetES2015 {
				if symbolHasNonMethodDeclaration(prop) {
					if errorNode {
						error(errorNode, Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword)
					}
					return false
				}
			}
			if flags & ModifierFlagsAbstract {
				if errorNode {
					error(errorNode, Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, symbolToString(prop), typeToString(getDeclaringClass(prop)))
				}
				return false
			}
			if !(flags & ModifierFlagsStatic) && prop.declarations.some(isClassInstanceProperty) {
				if errorNode {
					error(errorNode, Diagnostics.Class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super, symbolToString(prop))
				}
				return false
			}
		}
		if (flags & ModifierFlagsAbstract) && symbolHasNonMethodDeclaration(prop) && (isThisProperty(location) || isThisInitializedObjectBindingExpression(location) || isObjectBindingPattern(location.parent) && isThisInitializedDeclaration(location.parent.parent)) {
			declaringClassDeclaration := getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop))
			if declaringClassDeclaration && isNodeUsedDuringClassInitialization(location) {
				if errorNode {
					error(errorNode, Diagnostics.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor, symbolToString(prop), getTextOfIdentifierOrLiteral(declaringClassDeclaration.name))
				}
				return false
			}
		}
		if !(flags & ModifierFlagsNonPublicAccessibilityModifier) {
			return true
		}
		if flags & ModifierFlagsPrivate {
			declaringClassDeclaration := getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop))
			if !isNodeWithinClass(location, declaringClassDeclaration) {
				if errorNode {
					error(errorNode, Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(getDeclaringClass(prop)))
				}
				return false
			}
			return true
		}
		if isSuper {
			return true
		}
		enclosingClass := forEachEnclosingClass(location, func(enclosingDeclaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ClassLikeDeclaration */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceType | undefined */ TODO {
			enclosingClass := getDeclaredTypeOfSymbol(getSymbolOfDeclaration(enclosingDeclaration))
			return isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing)
		})
		if !enclosingClass {
			enclosingClass = getEnclosingClassFromThisParameter(location)
			enclosingClass = enclosingClass && isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing)
			if flags&ModifierFlagsStatic || !enclosingClass {
				if errorNode {
					error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(getDeclaringClass(prop) || containingType))
				}
				return false
			}
		}
		if flags & ModifierFlagsStatic {
			return true
		}
		if containingType.flags & TypeFlagsTypeParameter {
			containingType = /* TODO(ConditionalExpression): (containingType as TypeParameter).isThisType ? getConstraintOfTypeParameter(containingType as TypeParameter)! : getBaseConstraintOfType(containingType as TypeParameter)! */ TODO
		}
		if !containingType || !hasBaseType(containingType, enclosingClass) {
			if errorNode {
				error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2, symbolToString(prop), typeToString(enclosingClass), typeToString(containingType))
			}
			return false
		}
		return true
	}
	getEnclosingClassFromThisParameter := func(node Node) *InterfaceType {
		thisParameter := getThisParameterFromNodeContext(node)
		thisType := thisParameter.type_ && getTypeFromTypeNode(thisParameter.type_)
		if thisType {
			if thisType.flags & TypeFlagsTypeParameter {
				thisType = getConstraintOfTypeParameter(thisType)
			}
		} else {
			thisContainer := getThisContainer(node, false, false)
			if isFunctionLike(thisContainer) {
				thisType = getContextualThisParameterType(thisContainer)
			}
		}
		if thisType && getObjectFlags(thisType)&(ObjectFlagsClassOrInterface|ObjectFlagsReference) {
			return getTargetType(thisType)
		}
		return nil
	}
	getThisParameterFromNodeContext := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined */ TODO {
		thisContainer := getThisContainer(node, false, false)
		return /* TODO(ConditionalExpression): thisContainer && isFunctionLike(thisContainer) ? getThisParameter(thisContainer) : undefined */ TODO
	}
	symbolHasNonMethodDeclaration := func(symbol Symbol) /* TODO inferred type boolean */ TODO {
		return !!forEachProperty(symbol, func(prop /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
			return !(prop.flags & SymbolFlagsMethod)
		})
	}
	checkNonNullExpression := func(node /* TODO(UnionType): Expression | QualifiedName */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return checkNonNullType(checkExpression(node), node)
	}
	isNullableType := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return hasTypeFacts(type_, TypeFactsIsUndefinedOrNull)
	}
	getNonNullableTypeIfNeeded := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): isNullableType(type) ? getNonNullableType(type) : type */ TODO
	}
	reportObjectPossiblyNullOrUndefinedError := func(node Node, facts TypeFacts) {
		nodeText := /* TODO(ConditionalExpression): isEntityNameExpression(node) ? entityNameToString(node) : undefined */ TODO
		if node.kind == SyntaxKindNullKeyword {
			error(node, Diagnostics.The_value_0_cannot_be_used_here, "null")
			return
		}
		if nodeText != nil && nodeText.length < 100 {
			if isIdentifier(node) && nodeText == "undefined" {
				error(node, Diagnostics.The_value_0_cannot_be_used_here, "undefined")
				return
			}
			error(node /* TODO(ConditionalExpression): facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?                     Diagnostics._0_is_possibly_null_or_undefined :                     Diagnostics._0_is_possibly_undefined :                     Diagnostics._0_is_possibly_null */, TODO, nodeText)
		} else {
			error(node /* TODO(ConditionalExpression): facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?                     Diagnostics.Object_is_possibly_null_or_undefined :                     Diagnostics.Object_is_possibly_undefined :                     Diagnostics.Object_is_possibly_null */, TODO)
		}
	}
	reportCannotInvokePossiblyNullOrUndefinedError := func(node Node, facts TypeFacts) {
		error(node /* TODO(ConditionalExpression): facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?                 Diagnostics.Cannot_invoke_an_object_which_is_possibly_null_or_undefined :                 Diagnostics.Cannot_invoke_an_object_which_is_possibly_undefined :                 Diagnostics.Cannot_invoke_an_object_which_is_possibly_null */, TODO)
	}
	checkNonNullTypeWithReporter := func(type_ Type, node Node, reportError func(node Node, facts TypeFacts)) Type {
		if strictNullChecks && type_.flags&TypeFlagsUnknown {
			if isEntityNameExpression(node) {
				nodeText := entityNameToString(node)
				if nodeText.length < 100 {
					error(node, Diagnostics._0_is_of_type_unknown, nodeText)
					return errorType
				}
			}
			error(node, Diagnostics.Object_is_of_type_unknown)
			return errorType
		}
		facts := getTypeFacts(type_, TypeFactsIsUndefinedOrNull)
		if facts & TypeFactsIsUndefinedOrNull {
			reportError(node, facts)
			t := getNonNullableType(type_)
			return /* TODO(ConditionalExpression): t.flags & (TypeFlags.Nullable | TypeFlags.Never) ? errorType : t */ TODO
		}
		return type_
	}
	checkNonNullType := func(type_ Type, node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return checkNonNullTypeWithReporter(type_, node, reportObjectPossiblyNullOrUndefinedError)
	}
	checkNonNullNonVoidType := func(type_ Type, node Node) Type {
		nonNullType := checkNonNullType(type_, node)
		if nonNullType.flags & TypeFlagsVoid {
			if isEntityNameExpression(node) {
				nodeText := entityNameToString(node)
				if isIdentifier(node) && nodeText == "undefined" {
					error(node, Diagnostics.The_value_0_cannot_be_used_here, nodeText)
					return nonNullType
				}
				if nodeText.length < 100 {
					error(node, Diagnostics._0_is_possibly_undefined, nodeText)
					return nonNullType
				}
			}
			error(node, Diagnostics.Object_is_possibly_undefined)
		}
		return nonNullType
	}
	checkPropertyAccessExpression := func(node PropertyAccessExpression, checkMode *CheckMode, writeOnly bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): node.flags & NodeFlags.OptionalChain ? checkPropertyAccessChain(node as PropertyAccessChain, checkMode) :             checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullExpression(node.expression), node.name, checkMode, writeOnly) */ TODO
	}
	checkPropertyAccessChain := func(node PropertyAccessChain, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		leftType := checkExpression(node.expression)
		nonOptionalType := getOptionalExpressionType(leftType, node.expression)
		return propagateOptionalTypeMarker(checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullType(nonOptionalType, node.expression), node.name, checkMode), node, nonOptionalType != leftType)
	}
	checkQualifiedName := func(node QualifiedName, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		leftType := /* TODO(ConditionalExpression): isPartOfTypeQuery(node) && isThisIdentifier(node.left) ? checkNonNullType(checkThisExpression(node.left), node.left) : checkNonNullExpression(node.left) */ TODO
		return checkPropertyAccessExpressionOrQualifiedName(node, node.left, leftType, node.right, checkMode)
	}
	isMethodAccessForCall := func(node Node) /* TODO inferred type boolean */ TODO {
		for node.parent.kind == SyntaxKindParenthesizedExpression {
			node = node.parent
		}
		return isCallOrNewExpression(node.parent) && node.parent.expression == node
	}
	lookupSymbolForPrivateIdentifierDeclaration := func(propName __String, location Node) *Symbol {
		/* TODO(ForStatement): for (let containingClass = getContainingClassExcludingClassDecorators(location); !!containingClass; containingClass = getContainingClass(containingClass)) {             const { symbol } = containingClass;             const name = getSymbolNameForPrivateIdentifier(symbol, propName);             const prop = (symbol.members && symbol.members.get(name)) || (symbol.exports && symbol.exports.get(name));             if (prop) {                 return prop;             }         } */
	}
	checkGrammarPrivateIdentifierExpression := func(privId PrivateIdentifier) bool {
		if !getContainingClass(privId) {
			return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		}
		if !isForInStatement(privId.parent) {
			if !isExpressionNode(privId) {
				return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression)
			}
			isInOperation := isBinaryExpression(privId.parent) && privId.parent.operatorToken.kind == SyntaxKindInKeyword
			if !getSymbolForPrivateIdentifierExpression(privId) && !isInOperation {
				return grammarErrorOnNode(privId, Diagnostics.Cannot_find_name_0, idText(privId))
			}
		}
		return false
	}
	checkPrivateIdentifierExpression := func(privId PrivateIdentifier) Type {
		checkGrammarPrivateIdentifierExpression(privId)
		symbol := getSymbolForPrivateIdentifierExpression(privId)
		if symbol {
			markPropertyAsReferenced(symbol, nil, false)
		}
		return anyType
	}
	getSymbolForPrivateIdentifierExpression := func(privId PrivateIdentifier) *Symbol {
		if !isExpressionNode(privId) {
			return nil
		}
		links := getNodeLinks(privId)
		if links.resolvedSymbol == nil {
			links.resolvedSymbol = lookupSymbolForPrivateIdentifierDeclaration(privId.escapedText, privId)
		}
		return links.resolvedSymbol
	}
	getPrivateIdentifierPropertyOfType := func(leftType Type, lexicallyScopedIdentifier Symbol) *Symbol {
		return getPropertyOfType(leftType, lexicallyScopedIdentifier.escapedName)
	}
	checkPrivateIdentifierPropertyAccess := func(leftType Type, right PrivateIdentifier, lexicallyScopedIdentifier *Symbol) bool {
		var propertyOnType *Symbol
		properties := getPropertiesOfType(leftType)
		if properties {
			forEach(properties, func(symbol Symbol) /* TODO inferred type true | undefined */ TODO {
				decl := symbol.valueDeclaration
				if decl && isNamedDeclaration(decl) && isPrivateIdentifier(decl.name) && decl.name.escapedText == right.escapedText {
					propertyOnType = symbol
					return true
				}
			})
		}
		diagName := diagnosticName(right)
		if propertyOnType {
			typeValueDecl := Debug.checkDefined(propertyOnType.valueDeclaration)
			typeClass := Debug.checkDefined(getContainingClass(typeValueDecl))
			if lexicallyScopedIdentifier.valueDeclaration {
				lexicalValueDecl := lexicallyScopedIdentifier.valueDeclaration
				lexicalClass := getContainingClass(lexicalValueDecl)
				Debug.assert(!!lexicalClass)
				if findAncestor(lexicalClass, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
					return typeClass == n
				}) {
					diagnostic := error(right, Diagnostics.The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling, diagName, typeToString(leftType))
					addRelatedInfo(diagnostic, createDiagnosticForNode(lexicalValueDecl, Diagnostics.The_shadowing_declaration_of_0_is_defined_here, diagName), createDiagnosticForNode(typeValueDecl, Diagnostics.The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here, diagName))
					return true
				}
			}
			error(right, Diagnostics.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier, diagName, diagnosticName(typeClass.name || anon))
			return true
		}
		return false
	}
	isThisPropertyAccessInConstructor := func(node /* TODO(UnionType): ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop Symbol) /* TODO inferred type boolean | undefined */ TODO {
		return (isConstructorDeclaredProperty(prop) || isThisProperty(node) && isAutoTypedProperty(prop)) && getThisContainer(node, true, false) == getDeclaringConstructor(prop)
	}
	checkPropertyAccessExpressionOrQualifiedName := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, left /* TODO(UnionType): Expression | QualifiedName */ any, leftType Type, right /* TODO(UnionType): Identifier | PrivateIdentifier */ any, checkMode *CheckMode, writeOnly bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		parentSymbol := getNodeLinks(left).resolvedSymbol
		assignmentKind := getAssignmentTargetKind(node)
		apparentType := getApparentType( /* TODO(ConditionalExpression): assignmentKind !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(leftType) : leftType */ TODO)
		isAnyLike := isTypeAny(apparentType) || apparentType == silentNeverType
		var prop *Symbol
		if isPrivateIdentifier(right) {
			if languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !useDefineForClassFields {
				if assignmentKind != AssignmentKindNone {
					checkExternalEmitHelpers(node, ExternalEmitHelpersClassPrivateFieldSet)
				}
				if assignmentKind != AssignmentKindDefinite {
					checkExternalEmitHelpers(node, ExternalEmitHelpersClassPrivateFieldGet)
				}
			}
			lexicallyScopedSymbol := lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right)
			if assignmentKind && lexicallyScopedSymbol && lexicallyScopedSymbol.valueDeclaration && isMethodDeclaration(lexicallyScopedSymbol.valueDeclaration) {
				grammarErrorOnNode(right, Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable, idText(right))
			}
			if isAnyLike {
				if lexicallyScopedSymbol {
					return /* TODO(ConditionalExpression): isErrorType(apparentType) ? errorType : apparentType */ TODO
				}
				if getContainingClassExcludingClassDecorators(right) == nil {
					grammarErrorOnNode(right, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
					return anyType
				}
			}
			prop = lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedSymbol)
			if prop == nil {
				if checkPrivateIdentifierPropertyAccess(leftType, right, lexicallyScopedSymbol) {
					return errorType
				}
				containingClass := getContainingClassExcludingClassDecorators(right)
				if containingClass && isPlainJsFile(getSourceFileOfNode(containingClass), compilerOptions.checkJs) {
					grammarErrorOnNode(right, Diagnostics.Private_field_0_must_be_declared_in_an_enclosing_class, idText(right))
				}
			} else {
				isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
				if isSetonlyAccessor && assignmentKind != AssignmentKindDefinite {
					error(node, Diagnostics.Private_accessor_was_defined_without_a_getter)
				}
			}
		} else {
			if isAnyLike {
				if isIdentifier(left) && parentSymbol {
					markLinkedReferences(node, ReferenceHintProperty, nil, leftType)
				}
				return /* TODO(ConditionalExpression): isErrorType(apparentType) ? errorType : apparentType */ TODO
			}
			prop = getPropertyOfType(apparentType, right.escapedText, isConstEnumObjectType(apparentType), node.kind == SyntaxKindQualifiedName)
		}
		markLinkedReferences(node, ReferenceHintProperty, prop, leftType)
		var propType Type
		if !prop {
			indexInfo := /* TODO(ConditionalExpression): !isPrivateIdentifier(right) && (assignmentKind === AssignmentKind.None || !isGenericObjectType(leftType) || isThisTypeParameter(leftType)) ?                 getApplicableIndexInfoForName(apparentType, right.escapedText) : undefined */ TODO
			if !(indexInfo && indexInfo.type_) {
				isUncheckedJS := isUncheckedJSSuggestion(node, leftType.symbol, true)
				if !isUncheckedJS && isJSLiteralType(leftType) {
					return anyType
				}
				if leftType.symbol == globalThisSymbol {
					if globalThisSymbol.exports.has(right.escapedText) && (globalThisSymbol.exports.get(right.escapedText).flags & SymbolFlagsBlockScoped) {
						error(right, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(right.escapedText), typeToString(leftType))
					} else if noImplicitAny {
						error(right, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature, typeToString(leftType))
					}
					return anyType
				}
				if right.escapedText && !checkAndReportErrorForExtendingInterface(node) {
					reportNonexistentProperty(right /* TODO(ConditionalExpression): isThisTypeParameter(leftType) ? apparentType : leftType */, TODO, isUncheckedJS)
				}
				return errorType
			}
			if indexInfo.isReadonly && (isAssignmentTarget(node) || isDeleteTarget(node)) {
				error(node, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(apparentType))
			}
			propType = indexInfo.type_
			if compilerOptions.noUncheckedIndexedAccess && getAssignmentTargetKind(node) != AssignmentKindDefinite {
				propType = getUnionType( /* TODO(ArrayLiteralExpression): [propType, missingType] */ TODO)
			}
			if compilerOptions.noPropertyAccessFromIndexSignature && isPropertyAccessExpression(node) {
				error(right, Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0, unescapeLeadingUnderscores(right.escapedText))
			}
			if indexInfo.declaration && isDeprecatedDeclaration(indexInfo.declaration) {
				addDeprecatedSuggestion(right /* TODO(ArrayLiteralExpression): [indexInfo.declaration] */, TODO, right.escapedText)
			}
		} else {
			targetPropSymbol := resolveAliasWithDeprecationCheck(prop, right)
			if isDeprecatedSymbol(targetPropSymbol) && isUncalledFunctionReference(node, targetPropSymbol) && targetPropSymbol.declarations {
				addDeprecatedSuggestion(right, targetPropSymbol.declarations, right.escapedText)
			}
			checkPropertyNotUsedBeforeDeclaration(prop, node, right)
			markPropertyAsReferenced(prop, node, isSelfTypeAccess(left, parentSymbol))
			getNodeLinks(node).resolvedSymbol = prop
			checkPropertyAccessibility(node, left.kind == SyntaxKindSuperKeyword, isWriteAccess(node), apparentType, prop)
			if isAssignmentToReadonlyEntity(node, prop, assignmentKind) {
				error(right, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, idText(right))
				return errorType
			}
			propType = /* TODO(ConditionalExpression): isThisPropertyAccessInConstructor(node, prop) ? autoType : writeOnly || isWriteOnlyAccess(node) ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop) */ TODO
		}
		return getFlowTypeOfAccessExpression(node, prop, propType, right, checkMode)
	}
	isUncheckedJSSuggestion := func(node Node, suggestion *Symbol, excludeClasses bool) bool {
		file := getSourceFileOfNode(node)
		if file {
			if compilerOptions.checkJs == nil && file.checkJsDirective == nil && (file.scriptKind == ScriptKindJS || file.scriptKind == ScriptKindJSX) {
				declarationFile := forEach(suggestion.declarations, getSourceFileOfNode)
				suggestionHasNoExtendsOrDecorators := !suggestion.valueDeclaration || !isClassLike(suggestion.valueDeclaration) || suggestion.valueDeclaration.heritageClauses.length || classOrConstructorParameterIsDecorated(false, suggestion.valueDeclaration)
				return !(file != declarationFile && !!declarationFile && isGlobalSourceFile(declarationFile)) && !(excludeClasses && suggestion && suggestion.flags&SymbolFlagsClass && suggestionHasNoExtendsOrDecorators) && !(!!node && excludeClasses && isPropertyAccessExpression(node) && node.expression.kind == SyntaxKindThisKeyword && suggestionHasNoExtendsOrDecorators)
			}
		}
		return false
	}
	getFlowTypeOfAccessExpression := func(node /* TODO(UnionType): ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop *Symbol, propType Type, errorNode Node, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		assignmentKind := getAssignmentTargetKind(node)
		if assignmentKind == AssignmentKindDefinite {
			return removeMissingType(propType, !!(prop && prop.flags&SymbolFlagsOptional))
		}
		if prop && !(prop.flags & (SymbolFlagsVariable | SymbolFlagsProperty | SymbolFlagsAccessor)) && !(prop.flags&SymbolFlagsMethod && propType.flags&TypeFlagsUnion) && !isDuplicatedCommonJSExport(prop.declarations) {
			return propType
		}
		if propType == autoType {
			return getFlowTypeOfProperty(node, prop)
		}
		propType = getNarrowableTypeForReference(propType, node, checkMode)
		assumeUninitialized := false
		if strictNullChecks && strictPropertyInitialization && isAccessExpression(node) && node.expression.kind == SyntaxKindThisKeyword {
			declaration := prop && prop.valueDeclaration
			if declaration && isPropertyWithoutInitializer(declaration) {
				if !isStatic(declaration) {
					flowContainer := getControlFlowContainer(node)
					if flowContainer.kind == SyntaxKindConstructor && flowContainer.parent == declaration.parent && !(declaration.flags & NodeFlagsAmbient) {
						assumeUninitialized = true
					}
				}
			}
		} else if strictNullChecks && prop && prop.valueDeclaration && isPropertyAccessExpression(prop.valueDeclaration) && getAssignmentDeclarationPropertyAccessKind(prop.valueDeclaration) && getControlFlowContainer(node) == getControlFlowContainer(prop.valueDeclaration) {
			assumeUninitialized = true
		}
		flowType := getFlowTypeOfReference(node, propType /* TODO(ConditionalExpression): assumeUninitialized ? getOptionalType(propType) : propType */, TODO)
		if assumeUninitialized && !containsUndefinedType(propType) && containsUndefinedType(flowType) {
			error(errorNode, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(prop))
			return propType
		}
		return /* TODO(ConditionalExpression): assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType */ TODO
	}
	checkPropertyNotUsedBeforeDeclaration := func(prop Symbol, node /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, right /* TODO(UnionType): Identifier | PrivateIdentifier */ any) {
		TODO_IDENTIFIER := prop
		if !valueDeclaration || getSourceFileOfNode(node).isDeclarationFile {
			return
		}
		var diagnosticMessage TODO
		declarationName := idText(right)
		if isInPropertyInitializerOrClassStaticBlock(node) && !isOptionalPropertyDeclaration(valueDeclaration) && !(isAccessExpression(node) && isAccessExpression(node.expression)) && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) && !(isMethodDeclaration(valueDeclaration) && getCombinedModifierFlagsCached(valueDeclaration)&ModifierFlagsStatic) && (useDefineForClassFields || !isPropertyDeclaredInAncestorClass(prop)) {
			diagnosticMessage = error(right, Diagnostics.Property_0_is_used_before_its_initialization, declarationName)
		} else if valueDeclaration.kind == SyntaxKindClassDeclaration && node.parent.kind != SyntaxKindTypeReference && !(valueDeclaration.flags & NodeFlagsAmbient) && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) {
			diagnosticMessage = error(right, Diagnostics.Class_0_used_before_its_declaration, declarationName)
		}
		if diagnosticMessage {
			addRelatedInfo(diagnosticMessage, createDiagnosticForNode(valueDeclaration, Diagnostics._0_is_declared_here, declarationName))
		}
	}
	isInPropertyInitializerOrClassStaticBlock := func(node Node) bool {
		return !!findAncestor(node, func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
			switch node.kind {
			case SyntaxKindPropertyDeclaration:
				return true
			case SyntaxKindPropertyAssignment:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSpreadAssignment:
				fallthrough // TODO: merge cases
			case SyntaxKindComputedPropertyName:
				fallthrough // TODO: merge cases
			case SyntaxKindTemplateSpan:
				fallthrough // TODO: merge cases
			case SyntaxKindJsxExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindJsxAttribute:
				fallthrough // TODO: merge cases
			case SyntaxKindJsxAttributes:
				fallthrough // TODO: merge cases
			case SyntaxKindJsxSpreadAttribute:
				fallthrough // TODO: merge cases
			case SyntaxKindJsxOpeningElement:
				fallthrough // TODO: merge cases
			case SyntaxKindExpressionWithTypeArguments:
				fallthrough // TODO: merge cases
			case SyntaxKindHeritageClause:
				return false
			case SyntaxKindArrowFunction:
				fallthrough // TODO: merge cases
			case SyntaxKindExpressionStatement:
				return /* TODO(ConditionalExpression): isBlock(node.parent) && isClassStaticBlockDeclaration(node.parent.parent) ? true : "quit" */ TODO
			default:
				return /* TODO(ConditionalExpression): isExpressionNode(node) ? false : "quit" */ TODO
			}
		})
	}
	isPropertyDeclaredInAncestorClass := func(prop Symbol) bool {
		if !(prop.parent.flags & SymbolFlagsClass) {
			return false
		}
		var classType *InterfaceType = getTypeOfSymbol(prop.parent)
		for true {
			classType = classType.symbol && getSuperClass(classType)
			if !classType {
				return false
			}
			superProperty := getPropertyOfType(classType, prop.escapedName)
			if superProperty && superProperty.valueDeclaration {
				return true
			}
		}
	}
	getSuperClass := func(classType InterfaceType) *Type {
		x := getBaseTypes(classType)
		if x.length == 0 {
			return nil
		}
		return getIntersectionType(x)
	}
	reportNonexistentProperty := func(propNode /* TODO(UnionType): Identifier | PrivateIdentifier */ any, containingType Type, isUncheckedJS bool) {
		var errorInfo *DiagnosticMessageChain
		var relatedInfo *Diagnostic
		if !isPrivateIdentifier(propNode) && containingType.flags&TypeFlagsUnion && !(containingType.flags & TypeFlagsPrimitive) {
			for _, subtype := range (containingType).types {
				if !getPropertyOfType(subtype, propNode.escapedText) && !getApplicableIndexInfoForName(subtype, propNode.escapedText) {
					errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(subtype))
					break
				}
			}
		}
		if typeHasStaticProperty(propNode.escapedText, containingType) {
			propName := declarationNameToString(propNode)
			typeName := typeToString(containingType)
			errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName /* TODO(PlusToken): + */ /* TODO(BinaryExpression): typeName + "." + propName */, TODO)
		} else {
			promisedType := getPromisedTypeOfPromise(containingType)
			if promisedType && getPropertyOfType(promisedType, propNode.escapedText) {
				errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(containingType))
				relatedInfo = createDiagnosticForNode(propNode, Diagnostics.Did_you_forget_to_use_await)
			} else {
				missingProperty := declarationNameToString(propNode)
				container := typeToString(containingType)
				libSuggestion := getSuggestedLibForNonExistentProperty(missingProperty, containingType)
				if libSuggestion != nil {
					errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later, missingProperty, container, libSuggestion)
				} else {
					suggestion := getSuggestedSymbolForNonexistentProperty(propNode, containingType)
					if suggestion != nil {
						suggestedName := symbolName(suggestion)
						message := /* TODO(ConditionalExpression): isUncheckedJS ? Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2 : Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2 */ TODO
						errorInfo = chainDiagnosticMessages(errorInfo, message, missingProperty, container, suggestedName)
						relatedInfo = suggestion.valueDeclaration && createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestedName)
					} else {
						diagnostic := /* TODO(ConditionalExpression): containerSeemsToBeEmptyDomElement(containingType)                             ? Diagnostics.Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom                             : Diagnostics.Property_0_does_not_exist_on_type_1 */ TODO
						errorInfo = chainDiagnosticMessages(elaborateNeverIntersection(errorInfo, containingType), diagnostic, missingProperty, container)
					}
				}
			}
		}
		resultDiagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(propNode), propNode, errorInfo)
		if relatedInfo {
			addRelatedInfo(resultDiagnostic, relatedInfo)
		}
		addErrorOrSuggestion(!isUncheckedJS || errorInfo.code != Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2.code, resultDiagnostic)
	}
	containerSeemsToBeEmptyDomElement := func(containingType Type) /* TODO inferred type boolean | undefined */ TODO {
		return (compilerOptions.lib && !compilerOptions.lib.includes("dom")) && everyContainedType(containingType, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return type_.symbol && regexp.MustParse(`^(?:EventTarget|Node|(?:HTML[a-zA-Z]*)?Element)$`).test(unescapeLeadingUnderscores(type_.symbol.escapedName))
		}) && isEmptyObjectType(containingType)
	}
	typeHasStaticProperty := func(propName __String, containingType Type) bool {
		prop := containingType.symbol && getPropertyOfType(getTypeOfSymbol(containingType.symbol), propName)
		return prop != nil && !!prop.valueDeclaration && isStatic(prop.valueDeclaration)
	}
	getSuggestedLibForNonExistentName := func(name /* TODO(UnionType): __String | Identifier */ any) /* TODO inferred type string | undefined */ TODO {
		missingName := diagnosticName(name)
		allFeatures := getScriptTargetFeatures()
		typeFeatures := allFeatures.get(missingName)
		return typeFeatures && firstIterator(typeFeatures.keys())
	}
	getSuggestedLibForNonExistentProperty := func(missingProperty string, containingType Type) /* TODO inferred type string | undefined */ TODO {
		container := getApparentType(containingType).symbol
		if !container {
			return nil
		}
		containingTypeName := symbolName(container)
		allFeatures := getScriptTargetFeatures()
		typeFeatures := allFeatures.get(containingTypeName)
		if typeFeatures {
			for _, TODO_IDENTIFIER := range typeFeatures {
				if contains(featuresOfType, missingProperty) {
					return libTarget
				}
			}
		}
	}
	getSuggestedSymbolForNonexistentClassMember := func(name string, baseType Type) *Symbol {
		return getSpellingSuggestionForName(name, getPropertiesOfType(baseType), SymbolFlagsClassMember)
	}
	getSuggestedSymbolForNonexistentProperty := func(name /* TODO(UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) *Symbol {
		props := getPropertiesOfType(containingType)
		if /* TODO(TypeOfExpression): typeof name */ TODO != "string" {
			parent := name.parent
			if isPropertyAccessExpression(parent) {
				props = filter(props, func(prop /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean */ TODO {
					return isValidPropertyAccessForCompletions(parent, containingType, prop)
				})
			}
			name = idText(name)
		}
		return getSpellingSuggestionForName(name, props, SymbolFlagsValue)
	}
	getSuggestedSymbolForNonexistentJSXAttribute := func(name /* TODO(UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) *Symbol {
		strName := /* TODO(ConditionalExpression): isString(name) ? name : idText(name) */ TODO
		properties := getPropertiesOfType(containingType)
		jsxSpecific := /* TODO(ConditionalExpression): strName === "for" ? find(properties, x => symbolName(x) === "htmlFor")             : strName === "class" ? find(properties, x => symbolName(x) === "className")             : undefined */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): jsxSpecific ?? getSpellingSuggestionForName(strName, properties, SymbolFlags.Value) */ TODO
	}
	getSuggestionForNonexistentProperty := func(name /* TODO(UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) /* TODO(StringKeyword): string */ any {
		suggestion := getSuggestedSymbolForNonexistentProperty(name, containingType)
		return suggestion && symbolName(suggestion)
	}
	getSuggestionForSymbolNameLookup := func(symbols SymbolTable, name __String, meaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		symbol := getSymbol(symbols, name, meaning)
		if symbol {
			return symbol
		}
		var candidates []Symbol
		if symbols == globals {
			primitives := mapDefined( /* TODO(ArrayLiteralExpression): ["string", "number", "boolean", "object", "bigint", "symbol"] */ TODO, func(s /* TODO inferred type string */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
				return /* TODO(ConditionalExpression): symbols.has((s.charAt(0).toUpperCase() + s.slice(1)) as __String)                     ? createSymbol(SymbolFlags.TypeAlias, s as __String) as Symbol                     : undefined */ TODO
			})
			candidates = primitives.concat(arrayFrom(symbols.values()))
		} else {
			candidates = arrayFrom(symbols.values())
		}
		return getSpellingSuggestionForName(unescapeLeadingUnderscores(name), candidates, meaning)
	}
	getSuggestedSymbolForNonexistentSymbol := func(location Node, outerName __String, meaning SymbolFlags) *Symbol {
		Debug.assert(outerName != nil, "outername should always be defined")
		result := resolveNameForSymbolSuggestion(location, outerName, meaning, nil, false, false)
		return result
	}
	getSuggestedSymbolForNonexistentModule := func(name Identifier, targetModule Symbol) *Symbol {
		return targetModule.exports && getSpellingSuggestionForName(idText(name), getExportsOfModuleAsArray(targetModule), SymbolFlagsModuleMember)
	}
	getSuggestionForNonexistentIndexSignature := func(objectType Type, expr ElementAccessExpression, keyedType Type) /* TODO(StringKeyword): string */ any {
		hasProp := func(name /* TODO(UnionType): "set" | "get" */ any) /* TODO inferred type boolean */ TODO {
			prop := getPropertyOfObjectType(objectType, name)
			if prop {
				s := getSingleCallSignature(getTypeOfSymbol(prop))
				return !!s && getMinArgumentCount(s) >= 1 && isTypeAssignableTo(keyedType, getTypeAtPosition(s, 0))
			}
			return false
		}
		suggestedMethod := /* TODO(ConditionalExpression): isAssignmentTarget(expr) ? "set" : "get" */ TODO
		if !hasProp(suggestedMethod) {
			return nil
		}
		suggestion := tryGetPropertyAccessOrIdentifierToString(expr.expression)
		if suggestion == nil {
			suggestion = suggestedMethod
		} else {
			suggestion += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "." + suggestedMethod */ TODO
		}
		return suggestion
	}
	getSuggestedTypeForNonexistentStringLiteralType := func(source StringLiteralType, target UnionType) *StringLiteralType {
		candidates := target.types.filter(func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(TypePredicate): type is StringLiteralType */ any {
			return !!(type_.flags & TypeFlagsStringLiteral)
		})
		return getSpellingSuggestion(source.value, candidates, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralType */ TODO) /* TODO inferred type string */ TODO {
			return type_.value
		})
	}
	getSpellingSuggestionForName := func(name string, symbols []Symbol, meaning SymbolFlags) *Symbol {
		return getSpellingSuggestion(name, symbols, getCandidateName)
		getCandidateName := func(candidate Symbol) /* TODO inferred type string | undefined */ TODO {
			candidateName := symbolName(candidate)
			if startsWith(candidateName, '"') {
				return nil
			}
			if candidate.flags & meaning {
				return candidateName
			}
			if candidate.flags & SymbolFlagsAlias {
				alias := tryResolveAlias(candidate)
				if alias && alias.flags&meaning {
					return candidateName
				}
			}
			return nil
		}
	}
	markPropertyAsReferenced := func(prop Symbol, nodeForCheckWriteOnly Node, isSelfTypeAccess bool) {
		valueDeclaration := prop && (prop.flags & SymbolFlagsClassMember) && prop.valueDeclaration
		if !valueDeclaration {
			return
		}
		hasPrivateModifier := hasEffectiveModifier(valueDeclaration, ModifierFlagsPrivate)
		hasPrivateIdentifier := prop.valueDeclaration && isNamedDeclaration(prop.valueDeclaration) && isPrivateIdentifier(prop.valueDeclaration.name)
		if !hasPrivateModifier && !hasPrivateIdentifier {
			return
		}
		if nodeForCheckWriteOnly && isWriteOnlyAccess(nodeForCheckWriteOnly) && !(prop.flags & SymbolFlagsSetAccessor) {
			return
		}
		if isSelfTypeAccess {
			containingMethod := findAncestor(nodeForCheckWriteOnly, isFunctionLikeDeclaration)
			if containingMethod && containingMethod.symbol == prop {
				return
			}
		}
		( /* TODO(ConditionalExpression): getCheckFlags(prop) & CheckFlags.Instantiated ? getSymbolLinks(prop).target : prop */ TODO).isReferenced = SymbolFlagsAll
	}
	isSelfTypeAccess := func(name /* TODO(UnionType): Expression | QualifiedName */ any, parent *Symbol) /* TODO inferred type boolean */ TODO {
		return name.kind == SyntaxKindThisKeyword || !!parent && isEntityNameExpression(name) && parent == getResolvedSymbol(getFirstIdentifier(name))
	}
	isValidPropertyAccess := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, propertyName __String) bool {
		switch node.kind {
		case SyntaxKindPropertyAccessExpression:
			return isValidPropertyAccessWithType(node, node.expression.kind == SyntaxKindSuperKeyword, propertyName, getWidenedType(checkExpression(node.expression)))
		case SyntaxKindQualifiedName:
			return isValidPropertyAccessWithType(node, false, propertyName, getWidenedType(checkExpression(node.left)))
		case SyntaxKindImportType:
			return isValidPropertyAccessWithType(node, false, propertyName, getTypeFromTypeNode(node))
		}
	}
	isValidPropertyAccessForCompletions := func(node /* TODO(UnionType): PropertyAccessExpression | ImportTypeNode | QualifiedName */ any, type_ Type, property Symbol) bool {
		return isPropertyAccessible(node, node.kind == SyntaxKindPropertyAccessExpression && node.expression.kind == SyntaxKindSuperKeyword, false, type_, property)
	}
	isValidPropertyAccessWithType := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, isSuper bool, propertyName __String, type_ Type) bool {
		if isTypeAny(type_) {
			return true
		}
		prop := getPropertyOfType(type_, propertyName)
		return !!prop && isPropertyAccessible(node, isSuper, false, type_, prop)
	}
	isPropertyAccessible := func(node Node, isSuper bool, isWrite bool, containingType Type, property Symbol) bool {
		if isTypeAny(containingType) {
			return true
		}
		if property.valueDeclaration && isPrivateIdentifierClassElementDeclaration(property.valueDeclaration) {
			declClass := getContainingClass(property.valueDeclaration)
			return !isOptionalChain(node) && !!findAncestor(node, func(parent /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
				return parent == declClass
			})
		}
		return checkPropertyAccessibilityAtLocation(node, isSuper, isWrite, containingType, property)
	}
	getForInVariableSymbol := func(node ForInStatement) *Symbol {
		initializer := node.initializer
		if initializer.kind == SyntaxKindVariableDeclarationList {
			variable := /* TODO(ElementAccessExpression): (initializer as VariableDeclarationList).declarations[0] */ TODO
			if variable && !isBindingPattern(variable.name) {
				return getSymbolOfDeclaration(variable)
			}
		} else if initializer.kind == SyntaxKindIdentifier {
			return getResolvedSymbol(initializer)
		}
		return nil
	}
	hasNumericPropertyNames := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return getIndexInfosOfType(type_).length == 1 && !!getIndexInfoOfType(type_, numberType)
	}
	isForInVariableForNumericPropertyNames := func(expr Expression) /* TODO inferred type boolean */ TODO {
		e := skipParentheses(expr)
		if e.kind == SyntaxKindIdentifier {
			symbol := getResolvedSymbol(e)
			if symbol.flags & SymbolFlagsVariable {
				var child Node = expr
				node := expr.parent
				for node {
					if node.kind == SyntaxKindForInStatement && child == (node).statement && getForInVariableSymbol(node) == symbol && hasNumericPropertyNames(getTypeOfExpression((node).expression)) {
						return true
					}
					child = node
					node = node.parent
				}
			}
		}
		return false
	}
	checkIndexedAccess := func(node ElementAccessExpression, checkMode *CheckMode) Type {
		return /* TODO(ConditionalExpression): node.flags & NodeFlags.OptionalChain ? checkElementAccessChain(node as ElementAccessChain, checkMode) :             checkElementAccessExpression(node, checkNonNullExpression(node.expression), checkMode) */ TODO
	}
	checkElementAccessChain := func(node ElementAccessChain, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		exprType := checkExpression(node.expression)
		nonOptionalType := getOptionalExpressionType(exprType, node.expression)
		return propagateOptionalTypeMarker(checkElementAccessExpression(node, checkNonNullType(nonOptionalType, node.expression), checkMode), node, nonOptionalType != exprType)
	}
	checkElementAccessExpression := func(node ElementAccessExpression, exprType Type, checkMode *CheckMode) Type {
		objectType := /* TODO(ConditionalExpression): getAssignmentTargetKind(node) !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(exprType) : exprType */ TODO
		indexExpression := node.argumentExpression
		indexType := checkExpression(indexExpression)
		if isErrorType(objectType) || objectType == silentNeverType {
			return objectType
		}
		if isConstEnumObjectType(objectType) && !isStringLiteralLike(indexExpression) {
			error(indexExpression, Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal)
			return errorType
		}
		effectiveIndexType := /* TODO(ConditionalExpression): isForInVariableForNumericPropertyNames(indexExpression) ? numberType : indexType */ TODO
		assignmentTargetKind := getAssignmentTargetKind(node)
		var accessFlags AccessFlags
		if assignmentTargetKind == AssignmentKindNone {
			accessFlags = AccessFlagsExpressionPosition
		} else {
			accessFlags = AccessFlagsWriting | ( /* TODO(ConditionalExpression): isGenericObjectType(objectType) && !isThisTypeParameter(objectType) ? AccessFlags.NoIndexSignatures : 0 */ TODO)
			if assignmentTargetKind == AssignmentKindCompound {
				accessFlags |= AccessFlagsExpressionPosition
			}
		}
		indexedAccessType := getIndexedAccessTypeOrUndefined(objectType, effectiveIndexType, accessFlags, node) || errorType
		return checkIndexedAccessIndexType(getFlowTypeOfAccessExpression(node, getNodeLinks(node).resolvedSymbol, indexedAccessType, indexExpression, checkMode), node)
	}
	callLikeExpressionMayHaveTypeArguments := func(node CallLikeExpression) /* TODO(TypePredicate): node is CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement */ any {
		return isCallOrNewExpression(node) || isTaggedTemplateExpression(node) || isJsxOpeningLikeElement(node)
	}
	resolveUntypedCall := func(node CallLikeExpression) Signature {
		if callLikeExpressionMayHaveTypeArguments(node) {
			forEach(node.typeArguments, checkSourceElement)
		}
		if node.kind == SyntaxKindTaggedTemplateExpression {
			checkExpression(node.template)
		} else if isJsxOpeningLikeElement(node) {
			checkExpression(node.attributes)
		} else if isBinaryExpression(node) {
			checkExpression(node.left)
		} else if isCallOrNewExpression(node) {
			forEach(node.arguments, func(argument /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ TODO) {
				checkExpression(argument)
			})
		}
		return anySignature
	}
	resolveErrorCall := func(node CallLikeExpression) Signature {
		resolveUntypedCall(node)
		return unknownSignature
	}
	reorderCandidates := func(signatures []Signature, result []Signature, callChainFlags SignatureFlags) {
		var lastParent Node
		var lastSymbol *Symbol
		cutoffIndex := 0
		var index /* TODO(NumberKeyword): number */ any
		specializedIndex := -1
		var spliceIndex number
		Debug.assert(!result.length)
		for _, signature := range signatures {
			symbol := signature.declaration && getSymbolOfDeclaration(signature.declaration)
			parent := signature.declaration && signature.declaration.parent
			if !lastSymbol || symbol == lastSymbol {
				if lastParent && parent == lastParent {
					index = /* TODO(PlusToken): + */ /* TODO(BinaryExpression): index! + 1 */ TODO
				} else {
					lastParent = parent
					index = cutoffIndex
				}
			} else {
				index = /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): cutoffIndex = result.length */ TODO
				lastParent = parent
			}
			lastSymbol = symbol
			if signatureHasLiteralTypes(signature) {
				specializedIndex++
				spliceIndex = specializedIndex
				cutoffIndex++
			} else {
				spliceIndex = index
			}
			result.splice(spliceIndex, 0 /* TODO(ConditionalExpression): callChainFlags ? getOptionalCallSignature(signature, callChainFlags) : signature */, TODO)
		}
	}
	isSpreadArgument := func(arg *Expression) /* TODO(TypePredicate): arg is Expression */ any {
		return !!arg && (arg.kind == SyntaxKindSpreadElement || arg.kind == SyntaxKindSyntheticExpression && (arg).isSpread)
	}
	getSpreadArgumentIndex := func(args []Expression) number {
		return findIndex(args, isSpreadArgument)
	}
	acceptsVoid := func(t Type) bool {
		return !!(t.flags & TypeFlagsVoid)
	}
	acceptsVoidUndefinedUnknownOrAny := func(t Type) bool {
		return !!(t.flags & (TypeFlagsVoid | TypeFlagsUndefined | TypeFlagsUnknown | TypeFlagsAny))
	}
	hasCorrectArity := func(node CallLikeExpression, args []Expression, signature Signature, signatureHelpTrailingComma /* TODO inferred type boolean */ TODO /*  = false */) /* TODO inferred type boolean */ TODO {
		var argCount number
		callIsIncomplete := false
		effectiveParameterCount := getParameterCount(signature)
		effectiveMinimumArguments := getMinArgumentCount(signature)
		if node.kind == SyntaxKindTaggedTemplateExpression {
			argCount = args.length
			if node.template.kind == SyntaxKindTemplateExpression {
				lastSpan := last(node.template.templateSpans)
				callIsIncomplete = nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated
			} else {
				templateLiteral := node.template
				Debug.assert(templateLiteral.kind == SyntaxKindNoSubstitutionTemplateLiteral)
				callIsIncomplete = !!templateLiteral.isUnterminated
			}
		} else if node.kind == SyntaxKindDecorator {
			argCount = getDecoratorArgumentCount(node, signature)
		} else if node.kind == SyntaxKindBinaryExpression {
			argCount = 1
		} else if isJsxOpeningLikeElement(node) {
			callIsIncomplete = node.attributes.end == node.end
			if callIsIncomplete {
				return true
			}
			argCount = /* TODO(ConditionalExpression): effectiveMinimumArguments === 0 ? args.length : 1 */ TODO
			effectiveParameterCount = /* TODO(ConditionalExpression): args.length === 0 ? effectiveParameterCount : 1 */ TODO
			effectiveMinimumArguments = Math.min(effectiveMinimumArguments, 1)
		} else if !node.arguments {
			Debug.assert(node.kind == SyntaxKindNewExpression)
			return getMinArgumentCount(signature) == 0
		} else {
			argCount = /* TODO(ConditionalExpression): signatureHelpTrailingComma ? args.length + 1 : args.length */ TODO
			callIsIncomplete = node.arguments.end == node.end
			spreadArgIndex := getSpreadArgumentIndex(args)
			if spreadArgIndex >= 0 {
				return spreadArgIndex >= getMinArgumentCount(signature) && (hasEffectiveRestParameter(signature) || spreadArgIndex < getParameterCount(signature))
			}
		}
		if !hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount {
			return false
		}
		if callIsIncomplete || argCount >= effectiveMinimumArguments {
			return true
		}
		/* TODO(ForStatement): for (let i = argCount; i < effectiveMinimumArguments; i++) {             const type = getTypeAtPosition(signature, i);             if (filterType(type, isInJSFile(node) && !strictNullChecks ? acceptsVoidUndefinedUnknownOrAny : acceptsVoid).flags & TypeFlags.Never) {                 return false;             }         } */
		return true
	}
	hasCorrectTypeArgumentArity := func(signature Signature, typeArguments *NodeArray[TypeNode]) /* TODO inferred type boolean */ TODO {
		numTypeParameters := length(signature.typeParameters)
		minTypeArgumentCount := getMinTypeArgumentCount(signature.typeParameters)
		return !some(typeArguments) || (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters)
	}
	isInstantiatedGenericParameter := func(signature Signature, pos number) /* TODO inferred type boolean */ TODO {
		var type_ TODO
		return !!(signature.target && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type = tryGetTypeAtPosition(signature.target, pos) */ TODO) && isGenericType(type_))
	}
	getSingleCallSignature := func(type_ Type) *Signature {
		return getSingleSignature(type_, SignatureKindCall, false)
	}
	getSingleCallOrConstructSignature := func(type_ Type) *Signature {
		return getSingleSignature(type_, SignatureKindCall, false) || getSingleSignature(type_, SignatureKindConstruct, false)
	}
	getSingleSignature := func(type_ Type, kind SignatureKind, allowMembers bool) *Signature {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_)
			if allowMembers || resolved.properties.length == 0 && resolved.indexInfos.length == 0 {
				if kind == SignatureKindCall && resolved.callSignatures.length == 1 && resolved.constructSignatures.length == 0 {
					return /* TODO(ElementAccessExpression): resolved.callSignatures[0] */ TODO
				}
				if kind == SignatureKindConstruct && resolved.constructSignatures.length == 1 && resolved.callSignatures.length == 0 {
					return /* TODO(ElementAccessExpression): resolved.constructSignatures[0] */ TODO
				}
			}
		}
		return nil
	}
	instantiateSignatureInContextOf := func(signature Signature, contextualSignature Signature, inferenceContext InferenceContext, compareTypes TypeComparer) Signature {
		context := createInferenceContext(getTypeParametersForMapper(signature), signature, InferenceFlagsNone, compareTypes)
		restType := getEffectiveRestType(contextualSignature)
		mapper := inferenceContext && ( /* TODO(ConditionalExpression): restType && restType.flags & TypeFlags.TypeParameter ? inferenceContext.nonFixingMapper : inferenceContext.mapper */ TODO)
		sourceSignature := /* TODO(ConditionalExpression): mapper ? instantiateSignature(contextualSignature, mapper) : contextualSignature */ TODO
		applyToParameterTypes(sourceSignature, signature, func(source /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, target /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
			inferTypes(context.inferences, source, target)
		})
		if !inferenceContext {
			applyToReturnTypes(contextualSignature, signature, func(source /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, target /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
				inferTypes(context.inferences, source, target, InferencePriorityReturnType)
			})
		}
		return getSignatureInstantiation(signature, getInferredTypes(context), isInJSFile(contextualSignature.declaration))
	}
	inferJsxTypeArguments := func(node JsxOpeningLikeElement, signature Signature, checkMode CheckMode, context InferenceContext) []Type {
		paramType := getEffectiveFirstArgumentForJsxSignature(signature, node)
		checkAttrType := checkExpressionWithContextualType(node.attributes, paramType, context, checkMode)
		inferTypes(context.inferences, checkAttrType, paramType)
		return getInferredTypes(context)
	}
	getThisArgumentType := func(thisArgumentNode *Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !thisArgumentNode {
			return voidType
		}
		thisArgumentType := checkExpression(thisArgumentNode)
		return /* TODO(ConditionalExpression): isRightSideOfInstanceofExpression(thisArgumentNode) ? thisArgumentType :             isOptionalChainRoot(thisArgumentNode.parent) ? getNonNullableType(thisArgumentType) :             isOptionalChain(thisArgumentNode.parent) ? removeOptionalTypeMarker(thisArgumentType) :             thisArgumentType */ TODO
	}
	inferTypeArguments := func(node CallLikeExpression, signature Signature, args []Expression, checkMode CheckMode, context InferenceContext) []Type {
		if isJsxOpeningLikeElement(node) {
			return inferJsxTypeArguments(node, signature, checkMode, context)
		}
		if node.kind != SyntaxKindDecorator && node.kind != SyntaxKindBinaryExpression {
			skipBindingPatterns := every(signature.typeParameters, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type boolean */ TODO {
				return !!getDefaultFromTypeParameter(p)
			})
			contextualType := getContextualType(node /* TODO(ConditionalExpression): skipBindingPatterns ? ContextFlags.SkipBindingPatterns : ContextFlags.None */, TODO)
			if contextualType {
				inferenceTargetType := getReturnTypeOfSignature(signature)
				if couldContainTypeVariables(inferenceTargetType) {
					outerContext := getInferenceContext(node)
					isFromBindingPattern := !skipBindingPatterns && getContextualType(node, ContextFlagsSkipBindingPatterns) != contextualType
					if !isFromBindingPattern {
						outerMapper := getMapperFromContext(cloneInferenceContext(outerContext, InferenceFlagsNoDefault))
						instantiatedType := instantiateType(contextualType, outerMapper)
						contextualSignature := getSingleCallSignature(instantiatedType)
						inferenceSourceType := /* TODO(ConditionalExpression): contextualSignature && contextualSignature.typeParameters ?                             getOrCreateTypeFromSignature(getSignatureInstantiationWithoutFillingInTypeArguments(contextualSignature, contextualSignature.typeParameters)) :                             instantiatedType */ TODO
						inferTypes(context.inferences, inferenceSourceType, inferenceTargetType, InferencePriorityReturnType)
					}
					returnContext := createInferenceContext(signature.typeParameters, signature, context.flags)
					returnSourceType := instantiateType(contextualType, outerContext && outerContext.returnMapper)
					inferTypes(returnContext.inferences, returnSourceType, inferenceTargetType)
					context.returnMapper = /* TODO(ConditionalExpression): some(returnContext.inferences, hasInferenceCandidates) ? getMapperFromContext(cloneInferredPartOfContext(returnContext)) : undefined */ TODO
				}
			}
		}
		restType := getNonArrayRestType(signature)
		argCount := /* TODO(ConditionalExpression): restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length */ TODO
		if restType && restType.flags&TypeFlagsTypeParameter {
			info := find(context.inferences, func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO) /* TODO inferred type boolean */ TODO {
				return info.typeParameter == restType
			})
			if info {
				info.impliedArity = /* TODO(ConditionalExpression): findIndex(args, isSpreadArgument, argCount) < 0 ? args.length - argCount : undefined */ TODO
			}
		}
		thisType := getThisTypeOfSignature(signature)
		if thisType && couldContainTypeVariables(thisType) {
			thisArgumentNode := getThisArgumentOfCall(node)
			inferTypes(context.inferences, getThisArgumentType(thisArgumentNode), thisType)
		}
		/* TODO(ForStatement): for (let i = 0; i < argCount; i++) {             const arg = args[i];             if (arg.kind !== SyntaxKind.OmittedExpression) {                 const paramType = getTypeAtPosition(signature, i);                 if (couldContainTypeVariables(paramType)) {                     const argType = checkExpressionWithContextualType(arg, paramType, context, checkMode);                     inferTypes(context.inferences, argType, paramType);                 }             }         } */
		if restType && couldContainTypeVariables(restType) {
			spreadType := getSpreadArgumentType(args, argCount, args.length, restType, context, checkMode)
			inferTypes(context.inferences, spreadType, restType)
		}
		return getInferredTypes(context)
	}
	getMutableArrayOrTupleType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? mapType(type, getMutableArrayOrTupleType) :             type.flags & TypeFlags.Any || isMutableArrayOrTuple(getBaseConstraintOfType(type) || type) ? type :             isTupleType(type) ? createTupleType(getElementTypes(type), type.target.elementFlags, /*readonly* / false, type.target.labeledElementDeclarations) :             createTupleType([type], [ElementFlags.Variadic]) */ TODO
	}
	getSpreadArgumentType := func(args []Expression, index number, argCount number, restType Type, context *InferenceContext, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		inConstContext := isConstTypeVariable(restType)
		if index >= /* TODO(MinusToken): - */ /* TODO(BinaryExpression): argCount - 1 */ TODO {
			arg := /* TODO(ElementAccessExpression): args[argCount - 1] */ TODO
			if isSpreadArgument(arg) {
				spreadType := /* TODO(ConditionalExpression): arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type :                     checkExpressionWithContextualType((arg as SpreadElement).expression, restType, context, checkMode) */ TODO
				if isArrayLikeType(spreadType) {
					return getMutableArrayOrTupleType(spreadType)
				}
				return createArrayType(checkIteratedTypeOrElementType(IterationUseSpread, spreadType, undefinedType /* TODO(ConditionalExpression): arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg */, TODO), inConstContext)
			}
		}
		types := /* TODO(ArrayLiteralExpression): [] */ TODO
		flags := /* TODO(ArrayLiteralExpression): [] */ TODO
		names := /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = index; i < argCount; i++) {             const arg = args[i];             if (isSpreadArgument(arg)) {                 const spreadType = arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type : checkExpression((arg as SpreadElement).expression);                 if (isArrayLikeType(spreadType)) {                     types.push(spreadType);                     flags.push(ElementFlags.Variadic);                 }                 else {                     types.push(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg));                     flags.push(ElementFlags.Rest);                 }             }             else {                 const contextualType = isTupleType(restType) ?                     getContextualTypeForElementExpression(restType, i - index, argCount - index) || unknownType :                     getIndexedAccessType(restType, getNumberLiteralType(i - index), AccessFlags.Contextual);                 const argType = checkExpressionWithContextualType(arg, contextualType, context, checkMode);                 const hasPrimitiveContextualType = inConstContext || maybeTypeOfKind(contextualType, TypeFlags.Primitive | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping);                 types.push(hasPrimitiveContextualType ? getRegularTypeOfLiteralType(argType) : getWidenedLiteralType(argType));                 flags.push(ElementFlags.Required);             }             if (arg.kind === SyntaxKind.SyntheticExpression && (arg as SyntheticExpression).tupleNameSource) {                 names.push((arg as SyntheticExpression).tupleNameSource!);             }             else {                 names.push(undefined);             }         } */
		return createTupleType(types, flags, inConstContext && !someType(restType, isMutableArrayLikeType), names)
	}
	checkTypeArguments := func(signature Signature, typeArgumentNodes []TypeNode, reportErrors bool, headMessage DiagnosticMessage) /* TODO(ArrayType): Type[] */ any {
		isJavascript := isInJSFile(signature.declaration)
		typeParameters := signature.typeParameters
		typeArgumentTypes := fillMissingTypeArguments(map_(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript)
		var mapper *TypeMapper
		/* TODO(ForStatement): for (let i = 0; i < typeArgumentNodes.length; i++) {             Debug.assert(typeParameters[i] !== undefined, "Should not call checkTypeArguments with too many type arguments");             const constraint = getConstraintOfTypeParameter(typeParameters[i]);             if (constraint) {                 const errorInfo = reportErrors && headMessage ? (() => chainDiagnosticMessages(/*details* / undefined, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)) : undefined;                 const typeArgumentHeadMessage = headMessage || Diagnostics.Type_0_does_not_satisfy_the_constraint_1;                 if (!mapper) {                     mapper = createTypeMapper(typeParameters, typeArgumentTypes);                 }                 const typeArgument = typeArgumentTypes[i];                 if (                     !checkTypeAssignableTo(                         typeArgument,                         getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument),                         reportErrors ? typeArgumentNodes[i] : undefined,                         typeArgumentHeadMessage,                         errorInfo,                     )                 ) {                     return undefined;                 }             }         } */
		return typeArgumentTypes
	}
	getJsxReferenceKind := func(node JsxOpeningLikeElement) JsxReferenceKind {
		if isJsxIntrinsicTagName(node.tagName) {
			return JsxReferenceKindMixed
		}
		tagType := getApparentType(checkExpression(node.tagName))
		if length(getSignaturesOfType(tagType, SignatureKindConstruct)) {
			return JsxReferenceKindComponent
		}
		if length(getSignaturesOfType(tagType, SignatureKindCall)) {
			return JsxReferenceKindFunction
		}
		return JsxReferenceKindMixed
	}
	checkApplicableSignatureForJsxOpeningLikeElement := func(node JsxOpeningLikeElement, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO inferred type boolean */ TODO {
		paramType := getEffectiveFirstArgumentForJsxSignature(signature, node)
		attributesType := checkExpressionWithContextualType(node.attributes, paramType, nil, checkMode)
		checkAttributesType := /* TODO(ConditionalExpression): checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(attributesType) : attributesType */ TODO
		return checkTagNameDoesNotExpectTooManyArguments() && checkTypeRelatedToAndOptionallyElaborate(checkAttributesType, paramType, relation /* TODO(ConditionalExpression): reportErrors ? node.tagName : undefined */, TODO, node.attributes, nil, containingMessageChain, errorOutputContainer)
		checkTagNameDoesNotExpectTooManyArguments := func() bool {
			if getJsxNamespaceContainerForImplicitImport(node) {
				return true
			}
			tagType := /* TODO(ConditionalExpression): (isJsxOpeningElement(node) || isJsxSelfClosingElement(node)) && !(isJsxIntrinsicTagName(node.tagName) || isJsxNamespacedName(node.tagName)) ? checkExpression(node.tagName) : undefined */ TODO
			if !tagType {
				return true
			}
			tagCallSignatures := getSignaturesOfType(tagType, SignatureKindCall)
			if !length(tagCallSignatures) {
				return true
			}
			factory := getJsxFactoryEntity(node)
			if !factory {
				return true
			}
			factorySymbol := resolveEntityName(factory, SymbolFlagsValue, true, false, node)
			if !factorySymbol {
				return true
			}
			factoryType := getTypeOfSymbol(factorySymbol)
			callSignatures := getSignaturesOfType(factoryType, SignatureKindCall)
			if !length(callSignatures) {
				return true
			}
			hasFirstParamSignatures := false
			maxParamCount := 0
			for _, sig := range callSignatures {
				firstparam := getTypeAtPosition(sig, 0)
				signaturesOfParam := getSignaturesOfType(firstparam, SignatureKindCall)
				if !length(signaturesOfParam) {
					continue
				}
				for _, paramSig := range signaturesOfParam {
					hasFirstParamSignatures = true
					if hasEffectiveRestParameter(paramSig) {
						return true
					}
					paramCount := getParameterCount(paramSig)
					if paramCount > maxParamCount {
						maxParamCount = paramCount
					}
				}
			}
			if !hasFirstParamSignatures {
				return true
			}
			absoluteMinArgCount := Infinity
			for _, tagSig := range tagCallSignatures {
				tagRequiredArgCount := getMinArgumentCount(tagSig)
				if tagRequiredArgCount < absoluteMinArgCount {
					absoluteMinArgCount = tagRequiredArgCount
				}
			}
			if absoluteMinArgCount <= maxParamCount {
				return true
			}
			if reportErrors {
				diag := createDiagnosticForNode(node.tagName, Diagnostics.Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3, entityNameToString(node.tagName), absoluteMinArgCount, entityNameToString(factory), maxParamCount)
				tagNameDeclaration := getSymbolAtLocation(node.tagName).valueDeclaration
				if tagNameDeclaration {
					addRelatedInfo(diag, createDiagnosticForNode(tagNameDeclaration, Diagnostics._0_is_declared_here, entityNameToString(node.tagName)))
				}
				if errorOutputContainer && errorOutputContainer.skipLogging {
					(errorOutputContainer.errors || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
				}
				if !errorOutputContainer.skipLogging {
					diagnostics.add(diag)
				}
			}
			return false
		}
	}
	getEffectiveCheckNode := func(argument Expression) Expression {
		argument = skipParentheses(argument)
		return /* TODO(ConditionalExpression): isSatisfiesExpression(argument) ? skipParentheses(argument.expression) : argument */ TODO
	}
	getSignatureApplicabilityError := func(node CallLikeExpression, args []Expression, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, inferenceContext *InferenceContext) /* TODO(TypeOperator): readonly Diagnostic[] */ any {
		var errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any = /* TODO(ObjectLiteralExpression): { errors: undefined, skipLogging: true } */ TODO
		if isJsxOpeningLikeElement(node) {
			if !checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors, containingMessageChain, errorOutputContainer) {
				Debug.assert(!reportErrors || !!errorOutputContainer.errors, "jsx should have errors when reporting errors")
				return errorOutputContainer.errors || emptyArray
			}
			return nil
		}
		thisType := getThisTypeOfSignature(signature)
		if thisType && thisType != voidType && !(isNewExpression(node) || isCallExpression(node) && isSuperProperty(node.expression)) {
			thisArgumentNode := getThisArgumentOfCall(node)
			thisArgumentType := getThisArgumentType(thisArgumentNode)
			errorNode := /* TODO(ConditionalExpression): reportErrors ? (thisArgumentNode || node) : undefined */ TODO
			headMessage := Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1
			if !checkTypeRelatedTo(thisArgumentType, thisType, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer) {
				Debug.assert(!reportErrors || !!errorOutputContainer.errors, "this parameter should have errors when reporting errors")
				return errorOutputContainer.errors || emptyArray
			}
		}
		headMessage := Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1
		restType := getNonArrayRestType(signature)
		argCount := /* TODO(ConditionalExpression): restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length */ TODO
		/* TODO(ForStatement): for (let i = 0; i < argCount; i++) {             const arg = args[i];             if (arg.kind !== SyntaxKind.OmittedExpression) {                 const paramType = getTypeAtPosition(signature, i);                 const argType = checkExpressionWithContextualType(arg, paramType, /*inferenceContext* / undefined, checkMode);                 // If one or more arguments are still excluded (as indicated by CheckMode.SkipContextSensitive),                 // we obtain the regular type of any object literal arguments because we may not have inferred complete                 // parameter types yet and therefore excess property checks may yield false positives (see #17041).                 const regularArgType = checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(argType) : argType;                 // If this was inferred under a given inference context, we may need to instantiate the expression type to finish resolving                 // the type variables in the expression.                 const checkArgType = inferenceContext ? instantiateType(regularArgType, inferenceContext.nonFixingMapper) : regularArgType;                 const effectiveCheckArgumentNode = getEffectiveCheckNode(arg);                 if (!checkTypeRelatedToAndOptionallyElaborate(checkArgType, paramType, relation, reportErrors ? effectiveCheckArgumentNode : undefined, effectiveCheckArgumentNode, headMessage, containingMessageChain, errorOutputContainer)) {                     Debug.assert(!reportErrors || !!errorOutputContainer.errors, "parameter should have errors when reporting errors");                     maybeAddMissingAwaitInfo(arg, checkArgType, paramType);                     return errorOutputContainer.errors || emptyArray;                 }             }         } */
		if restType {
			spreadType := getSpreadArgumentType(args, argCount, args.length, restType, nil, checkMode)
			restArgCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): args.length - argCount */ TODO
			errorNode := /* TODO(ConditionalExpression): !reportErrors ? undefined :                 restArgCount === 0 ? node :                 restArgCount === 1 ? getEffectiveCheckNode(args[argCount]) :                 setTextRangePosEnd(createSyntheticExpression(node, spreadType), args[argCount].pos, args[args.length - 1].end) */ TODO
			if !checkTypeRelatedTo(spreadType, restType, relation, errorNode, headMessage, nil, errorOutputContainer) {
				Debug.assert(!reportErrors || !!errorOutputContainer.errors, "rest parameter should have errors when reporting errors")
				maybeAddMissingAwaitInfo(errorNode, spreadType, restType)
				return errorOutputContainer.errors || emptyArray
			}
		}
		return nil
		maybeAddMissingAwaitInfo := func(errorNode Node, source Type, target Type) {
			if errorNode && reportErrors && errorOutputContainer.errors && errorOutputContainer.errors.length {
				if getAwaitedTypeOfPromise(target) {
					return
				}
				awaitedTypeOfSource := getAwaitedTypeOfPromise(source)
				if awaitedTypeOfSource && isTypeRelatedTo(awaitedTypeOfSource, target, relation) {
					addRelatedInfo( /* TODO(ElementAccessExpression): errorOutputContainer.errors[0] */ TODO, createDiagnosticForNode(errorNode, Diagnostics.Did_you_forget_to_use_await))
				}
			}
		}
	}
	getThisArgumentOfCall := func(node CallLikeExpression) *Expression {
		if node.kind == SyntaxKindBinaryExpression {
			return node.right
		}
		expression := /* TODO(ConditionalExpression): node.kind === SyntaxKind.CallExpression ? node.expression :             node.kind === SyntaxKind.TaggedTemplateExpression ? node.tag :             node.kind === SyntaxKind.Decorator && !legacyDecorators ? node.expression :             undefined */ TODO
		if expression {
			callee := skipOuterExpressions(expression)
			if isAccessExpression(callee) {
				return callee.expression
			}
		}
	}
	createSyntheticExpression := func(parent Node, type_ Type, isSpread bool, tupleNameSource /* TODO(UnionType): ParameterDeclaration | NamedTupleMember */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SyntheticExpression */ TODO {
		result := parseNodeFactory.createSyntheticExpression(type_, isSpread, tupleNameSource)
		setTextRangeWorker(result, parent)
		setParent(result, parent)
		return result
	}
	getEffectiveCallArguments := func(node CallLikeExpression) []Expression {
		if node.kind == SyntaxKindTaggedTemplateExpression {
			template := node.template
			var args []Expression = /* TODO(ArrayLiteralExpression): [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())] */ TODO
			if template.kind == SyntaxKindTemplateExpression {
				forEach(template.templateSpans, func(span /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateSpan */ TODO) {
					args.push(span.expression)
				})
			}
			return args
		}
		if node.kind == SyntaxKindDecorator {
			return getEffectiveDecoratorArguments(node)
		}
		if node.kind == SyntaxKindBinaryExpression {
			return /* TODO(ArrayLiteralExpression): [node.left] */ TODO
		}
		if isJsxOpeningLikeElement(node) {
			return /* TODO(ConditionalExpression): node.attributes.properties.length > 0 || (isJsxOpeningElement(node) && node.parent.children.length > 0) ? [node.attributes] : emptyArray */ TODO
		}
		args := node.arguments || emptyArray
		spreadIndex := getSpreadArgumentIndex(args)
		if spreadIndex >= 0 {
			effectiveArgs := args.slice(0, spreadIndex)
			/* TODO(ForStatement): for (let i = spreadIndex; i < args.length; i++) {                 const arg = args[i];                 // We can call checkExpressionCached because spread expressions never have a contextual type.                 const spreadType = arg.kind === SyntaxKind.SpreadElement && (flowLoopCount ? checkExpression((arg as SpreadElement).expression) : checkExpressionCached((arg as SpreadElement).expression));                 if (spreadType && isTupleType(spreadType)) {                     forEach(getElementTypes(spreadType), (t, i) => {                         const flags = spreadType.target.elementFlags[i];                         const syntheticArg = createSyntheticExpression(arg, flags & ElementFlags.Rest ? createArrayType(t) : t, !!(flags & ElementFlags.Variable), spreadType.target.labeledElementDeclarations?.[i]);                         effectiveArgs.push(syntheticArg);                     });                 }                 else {                     effectiveArgs.push(arg);                 }             } */
			return effectiveArgs
		}
		return args
	}
	getEffectiveDecoratorArguments := func(node Decorator) []Expression {
		expr := node.expression
		signature := getDecoratorCallSignature(node)
		if signature {
			var args []Expression = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, param := range signature.parameters {
				type_ := getTypeOfSymbol(param)
				args.push(createSyntheticExpression(expr, type_))
			}
			return args
		}
		return Debug.fail()
	}
	getDecoratorArgumentCount := func(node Decorator, signature Signature) /* TODO inferred type number */ TODO {
		return /* TODO(ConditionalExpression): compilerOptions.experimentalDecorators ?             getLegacyDecoratorArgumentCount(node, signature) :             // Allow the runtime to oversupply arguments to an ES decorator as long as there's at least one parameter.             Math.min(Math.max(getParameterCount(signature), 1), 2) */ TODO
	}
	getLegacyDecoratorArgumentCount := func(node Decorator, signature Signature) /* TODO inferred type 1 | 2 | 3 */ TODO {
		switch node.parent.kind {
		case SyntaxKindClassDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindClassExpression:
			return 1
		case SyntaxKindPropertyDeclaration:
			return /* TODO(ConditionalExpression): hasAccessorModifier(node.parent) ? 3 : 2 */ TODO
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			return /* TODO(ConditionalExpression): signature.parameters.length <= 2 ? 2 : 3 */ TODO
		case SyntaxKindParameter:
			return 3
		default:
			return Debug.fail()
		}
	}
	getDiagnosticSpanForCallNode := func(node CallExpression) /* TODO inferred type { start: number; length: number; sourceFile: import("/home/jabaile/work/TypeScript/src/compiler/types").SourceFile; } */ TODO {
		sourceFile := getSourceFileOfNode(node)
		TODO_IDENTIFIER := getErrorSpanForNode(sourceFile /* TODO(ConditionalExpression): isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression */, TODO)
		return /* TODO(ObjectLiteralExpression): { start, length, sourceFile } */ TODO
	}
	getDiagnosticForCallNode := func(node CallLikeExpression, message /* TODO(UnionType): DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) DiagnosticWithLocation {
		if isCallExpression(node) {
			TODO_IDENTIFIER := getDiagnosticSpanForCallNode(node)
			if /* TODO(InKeyword): in */ /* TODO(BinaryExpression): "message" in message */ TODO {
				return createFileDiagnostic(sourceFile, start, length, message /* TODO(SpreadElement): ...args */, TODO)
			}
			return createDiagnosticForFileFromMessageChain(sourceFile, message)
		} else {
			if /* TODO(InKeyword): in */ /* TODO(BinaryExpression): "message" in message */ TODO {
				return createDiagnosticForNode(node, message /* TODO(SpreadElement): ...args */, TODO)
			}
			return createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), node, message)
		}
	}
	getErrorNodeForCallNode := func(callLike CallLikeExpression) Node {
		if isCallOrNewExpression(callLike) {
			return /* TODO(ConditionalExpression): isPropertyAccessExpression(callLike.expression) ? callLike.expression.name : callLike.expression */ TODO
		}
		if isTaggedTemplateExpression(callLike) {
			return /* TODO(ConditionalExpression): isPropertyAccessExpression(callLike.tag) ? callLike.tag.name : callLike.tag */ TODO
		}
		if isJsxOpeningLikeElement(callLike) {
			return callLike.tagName
		}
		return callLike
	}
	isPromiseResolveArityError := func(node CallLikeExpression) /* TODO inferred type boolean */ TODO {
		if !isCallExpression(node) || !isIdentifier(node.expression) {
			return false
		}
		symbol := resolveName(node.expression, node.expression.escapedText, SymbolFlagsValue, nil, false)
		decl := symbol.valueDeclaration
		if !decl || !isParameter(decl) || !isFunctionExpressionOrArrowFunction(decl.parent) || !isNewExpression(decl.parent.parent) || !isIdentifier(decl.parent.parent.expression) {
			return false
		}
		globalPromiseSymbol := getGlobalPromiseConstructorSymbol(false)
		if !globalPromiseSymbol {
			return false
		}
		constructorSymbol := getSymbolAtLocation(decl.parent.parent.expression, true)
		return constructorSymbol == globalPromiseSymbol
	}
	getArgumentArityError := func(node CallLikeExpression, signatures []Signature, args []Expression, headMessage DiagnosticMessage) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic */ TODO {
		spreadIndex := getSpreadArgumentIndex(args)
		if spreadIndex > -1 {
			return createDiagnosticForNode( /* TODO(ElementAccessExpression): args[spreadIndex] */ TODO, Diagnostics.A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter)
		}
		min := Number.POSITIVE_INFINITY
		max := Number.NEGATIVE_INFINITY
		maxBelow := Number.NEGATIVE_INFINITY
		minAbove := Number.POSITIVE_INFINITY
		var closestSignature *Signature
		for _, sig := range signatures {
			minParameter := getMinArgumentCount(sig)
			maxParameter := getParameterCount(sig)
			if minParameter < min {
				min = minParameter
				closestSignature = sig
			}
			max = Math.max(max, maxParameter)
			if minParameter < args.length && minParameter > maxBelow {
				maxBelow = minParameter
			}
			if args.length < maxParameter && maxParameter < minAbove {
				minAbove = maxParameter
			}
		}
		hasRestParameter := some(signatures, hasEffectiveRestParameter)
		parameterRange := /* TODO(ConditionalExpression): hasRestParameter ? min             : min < max ? min + "-" + max             : min */ TODO
		isVoidPromiseError := !hasRestParameter && parameterRange == 1 && args.length == 0 && isPromiseResolveArityError(node)
		if isVoidPromiseError && isInJSFile(node) {
			return getDiagnosticForCallNode(node, Diagnostics.Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments)
		}
		error := /* TODO(ConditionalExpression): isDecorator(node) ?             hasRestParameter ? Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0 :                 Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0 :             hasRestParameter ? Diagnostics.Expected_at_least_0_arguments_but_got_1 :             isVoidPromiseError ? Diagnostics.Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise :             Diagnostics.Expected_0_arguments_but_got_1 */ TODO
		if min < args.length && args.length < max {
			if headMessage {
				chain := chainDiagnosticMessages(nil, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove)
				chain = chainDiagnosticMessages(chain, headMessage)
				return getDiagnosticForCallNode(node, chain)
			}
			return getDiagnosticForCallNode(node, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove)
		} else if args.length < min {
			var diagnostic Diagnostic
			if headMessage {
				chain := chainDiagnosticMessages(nil, error, parameterRange, args.length)
				chain = chainDiagnosticMessages(chain, headMessage)
				diagnostic = getDiagnosticForCallNode(node, chain)
			} else {
				diagnostic = getDiagnosticForCallNode(node, error, parameterRange, args.length)
			}
			parameter := /* TODO(ElementAccessExpression): closestSignature?.declaration?.parameters[closestSignature.thisParameter ? args.length + 1 : args.length] */ TODO
			if parameter {
				var messageAndArgs DiagnosticAndArguments = /* TODO(ConditionalExpression): isBindingPattern(parameter.name) ? [Diagnostics.An_argument_matching_this_binding_pattern_was_not_provided]                     : isRestParameter(parameter) ? [Diagnostics.Arguments_for_the_rest_parameter_0_were_not_provided, idText(getFirstIdentifier(parameter.name))]                     : [Diagnostics.An_argument_for_0_was_not_provided, !parameter.name ? args.length : idText(getFirstIdentifier(parameter.name))] */ TODO
				parameterError := createDiagnosticForNode(parameter /* TODO(SpreadElement): ...messageAndArgs */, TODO)
				return addRelatedInfo(diagnostic, parameterError)
			}
			return diagnostic
		} else {
			errorSpan := factory.createNodeArray(args.slice(max))
			pos := first(errorSpan).pos
			end := last(errorSpan).end
			if end == pos {
				end++
			}
			setTextRangePosEnd(errorSpan, pos, end)
			if headMessage {
				chain := chainDiagnosticMessages(nil, error, parameterRange, args.length)
				chain = chainDiagnosticMessages(chain, headMessage)
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), errorSpan, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), errorSpan, error, parameterRange, args.length)
		}
	}
	getTypeArgumentArityError := func(node Node, signatures []Signature, typeArguments NodeArray[TypeNode], headMessage DiagnosticMessage) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
		argCount := typeArguments.length
		if signatures.length == 1 {
			sig := /* TODO(ElementAccessExpression): signatures[0] */ TODO
			min := getMinTypeArgumentCount(sig.typeParameters)
			max := length(sig.typeParameters)
			if headMessage {
				chain := chainDiagnosticMessages(nil, Diagnostics.Expected_0_type_arguments_but_got_1 /* TODO(ConditionalExpression): min < max ? min + "-" + max : min */, TODO, argCount)
				chain = chainDiagnosticMessages(chain, headMessage)
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1 /* TODO(ConditionalExpression): min < max ? min + "-" + max : min */, TODO, argCount)
		}
		belowArgCount := -Infinity
		aboveArgCount := Infinity
		for _, sig := range signatures {
			min := getMinTypeArgumentCount(sig.typeParameters)
			max := length(sig.typeParameters)
			if min > argCount {
				aboveArgCount = Math.min(aboveArgCount, min)
			} else if max < argCount {
				belowArgCount = Math.max(belowArgCount, max)
			}
		}
		if belowArgCount != -Infinity && aboveArgCount != Infinity {
			if headMessage {
				chain := chainDiagnosticMessages(nil, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount)
				chain = chainDiagnosticMessages(chain, headMessage)
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount)
		}
		if headMessage {
			chain := chainDiagnosticMessages(nil, Diagnostics.Expected_0_type_arguments_but_got_1 /* TODO(ConditionalExpression): belowArgCount === -Infinity ? aboveArgCount : belowArgCount */, TODO, argCount)
			chain = chainDiagnosticMessages(chain, headMessage)
			return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
		}
		return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1 /* TODO(ConditionalExpression): belowArgCount === -Infinity ? aboveArgCount : belowArgCount */, TODO, argCount)
	}
	resolveCall := func(node CallLikeExpression, signatures []Signature, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode, callChainFlags SignatureFlags, headMessage DiagnosticMessage) Signature {
		isTaggedTemplate := node.kind == SyntaxKindTaggedTemplateExpression
		isDecorator := node.kind == SyntaxKindDecorator
		isJsxOpeningOrSelfClosingElement := isJsxOpeningLikeElement(node)
		isInstanceof := node.kind == SyntaxKindBinaryExpression
		reportErrors := !isInferencePartiallyBlocked && !candidatesOutArray
		var typeArguments *NodeArray[TypeNode]
		if !isDecorator && !isInstanceof && !isSuperCall(node) {
			typeArguments = (node).typeArguments
			if isTaggedTemplate || isJsxOpeningOrSelfClosingElement || (node).expression.kind != SyntaxKindSuperKeyword {
				forEach(typeArguments, checkSourceElement)
			}
		}
		candidates := candidatesOutArray || /* TODO(ArrayLiteralExpression): [] */ TODO
		reorderCandidates(signatures, candidates, callChainFlags)
		Debug.assert(candidates.length, "Revert #54442 and add a testcase with whatever triggered this")
		args := getEffectiveCallArguments(node)
		isSingleNonGenericCandidate := candidates.length == 1 && ! /* TODO(ElementAccessExpression): candidates[0] */ TODO.typeParameters
		argCheckMode := /* TODO(ConditionalExpression): !isDecorator && !isSingleNonGenericCandidate && some(args, isContextSensitive) ? CheckMode.SkipContextSensitive : CheckMode.Normal */ TODO
		var candidatesForArgumentError /* TODO(ArrayType): Signature[] */ any
		var candidateForArgumentArityError *Signature
		var candidateForTypeArgumentError *Signature
		var result *Signature
		signatureHelpTrailingComma := !!(checkMode & CheckModeIsForSignatureHelp) && node.kind == SyntaxKindCallExpression && node.arguments.hasTrailingComma
		if candidates.length > 1 {
			result = chooseOverload(candidates, subtypeRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma)
		}
		if !result {
			result = chooseOverload(candidates, assignableRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma)
		}
		if result {
			return result
		}
		result = getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray, checkMode)
		getNodeLinks(node).resolvedSignature = result
		if reportErrors {
			if !headMessage && isInstanceof {
				headMessage = Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_hand_side_s_Symbol_hasInstance_method
			}
			if candidatesForArgumentError {
				if candidatesForArgumentError.length == 1 || candidatesForArgumentError.length > 3 {
					last := /* TODO(ElementAccessExpression): candidatesForArgumentError[candidatesForArgumentError.length - 1] */ TODO
					var chain *DiagnosticMessageChain
					if candidatesForArgumentError.length > 3 {
						chain = chainDiagnosticMessages(chain, Diagnostics.The_last_overload_gave_the_following_error)
						chain = chainDiagnosticMessages(chain, Diagnostics.No_overload_matches_this_call)
					}
					if headMessage {
						chain = chainDiagnosticMessages(chain, headMessage)
					}
					diags := getSignatureApplicabilityError(node, args, last, assignableRelation, CheckModeNormal, true, func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined */ TODO {
						return chain
					}, nil)
					if diags {
						for _, d := range diags {
							if last.declaration && candidatesForArgumentError.length > 3 {
								addRelatedInfo(d, createDiagnosticForNode(last.declaration, Diagnostics.The_last_overload_is_declared_here))
							}
							addImplementationSuccessElaboration(last, d)
							diagnostics.add(d)
						}
					} else {
						Debug.fail("No error for last overload signature")
					}
				} else {
					var allDiagnostics [][]DiagnosticRelatedInformation = /* TODO(ArrayLiteralExpression): [] */ TODO
					max := 0
					min := Number.MAX_VALUE
					minIndex := 0
					i := 0
					for _, c := range candidatesForArgumentError {
						chain := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ TODO {
							return chainDiagnosticMessages(nil, Diagnostics.Overload_0_of_1_2_gave_the_following_error /* TODO(PlusToken): + */ /* TODO(BinaryExpression): i + 1 */, TODO, candidates.length, signatureToString(c))
						}
						diags := getSignatureApplicabilityError(node, args, c, assignableRelation, CheckModeNormal, true, chain, nil)
						if diags {
							if diags.length <= min {
								min = diags.length
								minIndex = i
							}
							max = Math.max(max, diags.length)
							allDiagnostics.push(diags)
						} else {
							Debug.fail("No error for 3 or fewer overload signatures")
						}
						i++
					}
					diags := /* TODO(ConditionalExpression): max > 1 ? allDiagnostics[minIndex] : flatten(allDiagnostics) */ TODO
					Debug.assert(diags.length > 0, "No errors reported for 3 or fewer overload signatures")
					chain := chainDiagnosticMessages(map_(diags, createDiagnosticMessageChainFromDiagnostic), Diagnostics.No_overload_matches_this_call)
					if headMessage {
						chain = chainDiagnosticMessages(chain, headMessage)
					}
					related := /* TODO(ArrayLiteralExpression): [...flatMap(diags, d => (d as Diagnostic).relatedInformation) as DiagnosticRelatedInformation[]] */ TODO
					var diag Diagnostic
					if every(diags, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticRelatedInformation */ TODO) /* TODO inferred type boolean */ TODO {
						return d.start == /* TODO(ElementAccessExpression): diags[0] */ TODO.start && d.length == /* TODO(ElementAccessExpression): diags[0] */ TODO.length && d.file == /* TODO(ElementAccessExpression): diags[0] */ TODO.file
					}) {
						TODO_IDENTIFIER := /* TODO(ElementAccessExpression): diags[0] */ TODO
						diag = /* TODO(ObjectLiteralExpression): { file, start, length, code: chain.code, category: chain.category, messageText: chain, relatedInformation: related } */ TODO
					} else {
						diag = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), getErrorNodeForCallNode(node), chain, related)
					}
					addImplementationSuccessElaboration( /* TODO(ElementAccessExpression): candidatesForArgumentError[0] */ TODO, diag)
					diagnostics.add(diag)
				}
			} else if candidateForArgumentArityError {
				diagnostics.add(getArgumentArityError(node /* TODO(ArrayLiteralExpression): [candidateForArgumentArityError] */, TODO, args, headMessage))
			} else if candidateForTypeArgumentError {
				checkTypeArguments(candidateForTypeArgumentError, (node).typeArguments, true, headMessage)
			} else {
				signaturesWithCorrectTypeArgumentArity := filter(signatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
					return hasCorrectTypeArgumentArity(s, typeArguments)
				})
				if signaturesWithCorrectTypeArgumentArity.length == 0 {
					diagnostics.add(getTypeArgumentArityError(node, signatures, typeArguments, headMessage))
				} else {
					diagnostics.add(getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args, headMessage))
				}
			}
		}
		return result
		addImplementationSuccessElaboration := func(failed Signature, diagnostic Diagnostic) {
			oldCandidatesForArgumentError := candidatesForArgumentError
			oldCandidateForArgumentArityError := candidateForArgumentArityError
			oldCandidateForTypeArgumentError := candidateForTypeArgumentError
			failedSignatureDeclarations := failed.declaration.symbol.declarations || emptyArray
			isOverload := failedSignatureDeclarations.length > 1
			implDecl := /* TODO(ConditionalExpression): isOverload ? find(failedSignatureDeclarations, d => isFunctionLikeDeclaration(d) && nodeIsPresent(d.body)) : undefined */ TODO
			if implDecl {
				candidate := getSignatureFromDeclaration(implDecl)
				isSingleNonGenericCandidate := !candidate.typeParameters
				if chooseOverload( /* TODO(ArrayLiteralExpression): [candidate] */ TODO, assignableRelation, isSingleNonGenericCandidate) {
					addRelatedInfo(diagnostic, createDiagnosticForNode(implDecl, Diagnostics.The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible))
				}
			}
			candidatesForArgumentError = oldCandidatesForArgumentError
			candidateForArgumentArityError = oldCandidateForArgumentArityError
			candidateForTypeArgumentError = oldCandidateForTypeArgumentError
		}
		chooseOverload := func(candidates []Signature, relation Map[string, RelationComparisonResult], isSingleNonGenericCandidate bool, signatureHelpTrailingComma /* TODO inferred type boolean */ TODO /*  = false */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
			candidatesForArgumentError = nil
			candidateForArgumentArityError = nil
			candidateForTypeArgumentError = nil
			if isSingleNonGenericCandidate {
				candidate := /* TODO(ElementAccessExpression): candidates[0] */ TODO
				if some(typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma) {
					return nil
				}
				if getSignatureApplicabilityError(node, args, candidate, relation, CheckModeNormal, false, nil, nil) {
					candidatesForArgumentError = /* TODO(ArrayLiteralExpression): [candidate] */ TODO
					return nil
				}
				return candidate
			}
			/* TODO(ForStatement): for (let candidateIndex = 0; candidateIndex < candidates.length; candidateIndex++) {                 let candidate = candidates[candidateIndex];                 if (!hasCorrectTypeArgumentArity(candidate, typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) {                     continue;                 }                  let checkCandidate: Signature;                 let inferenceContext: InferenceContext | undefined;                  if (candidate.typeParameters) {                     // If we are *inside the body of candidate*, we need to create a clone of `candidate` with differing type parameter identities,                     // so our inference results for this call doesn't pollute expression types referencing the outer type parameter!                     const paramLocation = candidate.typeParameters[0].symbol.declarations?.[0]?.parent;                     const candidateParameterContext = paramLocation || (candidate.declaration && isConstructorDeclaration(candidate.declaration) ? candidate.declaration.parent : candidate.declaration);                     if (candidateParameterContext && findAncestor(node, a => a === candidateParameterContext)) {                         candidate = getImplementationSignature(candidate);                     }                     let typeArgumentTypes: readonly Type[] | undefined;                     if (some(typeArguments)) {                         typeArgumentTypes = checkTypeArguments(candidate, typeArguments, /*reportErrors* / false);                         if (!typeArgumentTypes) {                             candidateForTypeArgumentError = candidate;                             continue;                         }                     }                     else {                         inferenceContext = createInferenceContext(candidate.typeParameters!, candidate, /*flags* / isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None);                         // The resulting type arguments are instantiated with the inference context mapper, as the inferred types may still contain references to the inference context's                         //  type variables via contextual projection. These are kept generic until all inferences are locked in, so the dependencies expressed can pass constraint checks.                         typeArgumentTypes = instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode | CheckMode.SkipGenericFunctions, inferenceContext), inferenceContext.nonFixingMapper);                         argCheckMode |= inferenceContext.flags & InferenceFlags.SkippedGenericFunction ? CheckMode.SkipGenericFunctions : CheckMode.Normal;                     }                     checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters);                     // If the original signature has a generic rest type, instantiation may produce a                     // signature with different arity and we need to perform another arity check.                     if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {                         candidateForArgumentArityError = checkCandidate;                         continue;                     }                 }                 else {                     checkCandidate = candidate;                 }                 if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors* / false, /*containingMessageChain* / undefined, inferenceContext)) {                     // Give preference to error candidates that have no rest parameters (as they are more specific)                     (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);                     continue;                 }                 if (argCheckMode) {                     // If one or more context sensitive arguments were excluded, we start including                     // them now (and keeping do so for any subsequent candidates) and perform a second                     // round of type inference and applicability checking for this particular candidate.                     argCheckMode = CheckMode.Normal;                     if (inferenceContext) {                         const typeArgumentTypes = instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode, inferenceContext), inferenceContext.mapper);                         checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext.inferredTypeParameters);                         // If the original signature has a generic rest type, instantiation may produce a                         // signature with different arity and we need to perform another arity check.                         if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {                             candidateForArgumentArityError = checkCandidate;                             continue;                         }                     }                     if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors* / false, /*containingMessageChain* / undefined, inferenceContext)) {                         // Give preference to error candidates that have no rest parameters (as they are more specific)                         (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);                         continue;                     }                 }                 candidates[candidateIndex] = checkCandidate;                 return checkCandidate;             } */
			return nil
		}
	}
	getCandidateForOverloadFailure := func(node CallLikeExpression, candidates []Signature, args []Expression, hasCandidatesOutArray bool, checkMode CheckMode) Signature {
		Debug.assert(candidates.length > 0)
		checkNodeDeferred(node)
		return /* TODO(ConditionalExpression): hasCandidatesOutArray || candidates.length === 1 || candidates.some(c => !!c.typeParameters)             ? pickLongestCandidateSignature(node, candidates, args, checkMode)             : createUnionOfSignaturesForOverloadFailure(candidates) */ TODO
	}
	createUnionOfSignaturesForOverloadFailure := func(candidates []Signature) Signature {
		thisParameters := mapDefined(candidates, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			return c.thisParameter
		})
		var thisParameter *Symbol
		if thisParameters.length {
			thisParameter = createCombinedSymbolFromTypes(thisParameters, thisParameters.map_(getTypeOfParameter))
		}
		TODO_IDENTIFIER := minAndMax(candidates, getNumNonRestParameters)
		var parameters []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < maxNonRestParam; i++) {             const symbols = mapDefined(candidates, s =>                 signatureHasRestParameter(s) ?                     i < s.parameters.length - 1 ? s.parameters[i] : last(s.parameters) :                     i < s.parameters.length ? s.parameters[i] : undefined);             Debug.assert(symbols.length !== 0);             parameters.push(createCombinedSymbolFromTypes(symbols, mapDefined(candidates, candidate => tryGetTypeAtPosition(candidate, i))));         } */
		restParameterSymbols := mapDefined(candidates, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			return /* TODO(ConditionalExpression): signatureHasRestParameter(c) ? last(c.parameters) : undefined */ TODO
		})
		flags := SignatureFlagsIsSignatureCandidateForOverloadFailure
		if restParameterSymbols.length != 0 {
			type_ := createArrayType(getUnionType(mapDefined(candidates, tryGetRestTypeOfSignature), UnionReductionSubtype))
			parameters.push(createCombinedSymbolForOverloadFailure(restParameterSymbols, type_))
			flags |= SignatureFlagsHasRestParameter
		}
		if candidates.some(signatureHasLiteralTypes) {
			flags |= SignatureFlagsHasLiteralTypes
		}
		return createSignature( /* TODO(ElementAccessExpression): candidates[0] */ TODO.declaration, nil, thisParameter, parameters, getIntersectionType(candidates.map_(getReturnTypeOfSignature)), nil, minArgumentCount, flags)
	}
	getNumNonRestParameters := func(signature Signature) number {
		numParams := signature.parameters.length
		return /* TODO(ConditionalExpression): signatureHasRestParameter(signature) ? numParams - 1 : numParams */ TODO
	}
	createCombinedSymbolFromTypes := func(sources []Symbol, types []Type) Symbol {
		return createCombinedSymbolForOverloadFailure(sources, getUnionType(types, UnionReductionSubtype))
	}
	createCombinedSymbolForOverloadFailure := func(sources []Symbol, type_ Type) Symbol {
		return createSymbolWithType(first(sources), type_)
	}
	pickLongestCandidateSignature := func(node CallLikeExpression, candidates []Signature, args []Expression, checkMode CheckMode) Signature {
		bestIndex := getLongestCandidateIndex(candidates /* TODO(ConditionalExpression): apparentArgumentCount === undefined ? args.length : apparentArgumentCount */, TODO)
		candidate := /* TODO(ElementAccessExpression): candidates[bestIndex] */ TODO
		TODO_IDENTIFIER := candidate
		if !typeParameters {
			return candidate
		}
		var typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any = /* TODO(ConditionalExpression): callLikeExpressionMayHaveTypeArguments(node) ? node.typeArguments : undefined */ TODO
		instantiated := /* TODO(ConditionalExpression): typeArgumentNodes             ? createSignatureInstantiation(candidate, getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isInJSFile(node)))             : inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args, checkMode) */ TODO
		/* TODO(ElementAccessExpression): candidates[bestIndex] */ TODO = instantiated
		return instantiated
	}
	getTypeArgumentsFromNodes := func(typeArgumentNodes []TypeNode, typeParameters []TypeParameter, isJs bool) []Type {
		typeArguments := typeArgumentNodes.map_(getTypeOfNode)
		for typeArguments.length > typeParameters.length {
			typeArguments.pop()
		}
		for typeArguments.length < typeParameters.length {
			typeArguments.push(getDefaultFromTypeParameter( /* TODO(ElementAccessExpression): typeParameters[typeArguments.length] */ TODO) || getConstraintOfTypeParameter( /* TODO(ElementAccessExpression): typeParameters[typeArguments.length] */ TODO) || getDefaultTypeArgumentType(isJs))
		}
		return typeArguments
	}
	inferSignatureInstantiationForOverloadFailure := func(node CallLikeExpression, typeParameters []TypeParameter, candidate Signature, args []Expression, checkMode CheckMode) Signature {
		inferenceContext := createInferenceContext(typeParameters, candidate /* TODO(ConditionalExpression): isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None */, TODO)
		typeArgumentTypes := inferTypeArguments(node, candidate, args, checkMode|CheckModeSkipContextSensitive|CheckModeSkipGenericFunctions, inferenceContext)
		return createSignatureInstantiation(candidate, typeArgumentTypes)
	}
	getLongestCandidateIndex := func(candidates []Signature, argsCount number) number {
		maxParamsIndex := -1
		maxParams := -1
		/* TODO(ForStatement): for (let i = 0; i < candidates.length; i++) {             const candidate = candidates[i];             const paramCount = getParameterCount(candidate);             if (hasEffectiveRestParameter(candidate) || paramCount >= argsCount) {                 return i;             }             if (paramCount > maxParams) {                 maxParams = paramCount;                 maxParamsIndex = i;             }         } */
		return maxParamsIndex
	}
	resolveCallExpression := func(node CallExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		if node.expression.kind == SyntaxKindSuperKeyword {
			superType := checkSuperExpression(node.expression)
			if isTypeAny(superType) {
				for _, arg := range node.arguments {
					checkExpression(arg)
				}
				return anySignature
			}
			if !isErrorType(superType) {
				baseTypeNode := getEffectiveBaseTypeNode(getContainingClass(node))
				if baseTypeNode {
					baseConstructors := getInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.typeArguments, baseTypeNode)
					return resolveCall(node, baseConstructors, candidatesOutArray, checkMode, SignatureFlagsNone)
				}
			}
			return resolveUntypedCall(node)
		}
		var callChainFlags SignatureFlags
		funcType := checkExpression(node.expression)
		if isCallChain(node) {
			nonOptionalType := getOptionalExpressionType(funcType, node.expression)
			callChainFlags = /* TODO(ConditionalExpression): nonOptionalType === funcType ? SignatureFlags.None :                 isOutermostOptionalChain(node) ? SignatureFlags.IsOuterCallChain :                 SignatureFlags.IsInnerCallChain */ TODO
			funcType = nonOptionalType
		} else {
			callChainFlags = SignatureFlagsNone
		}
		funcType = checkNonNullTypeWithReporter(funcType, node.expression, reportCannotInvokePossiblyNullOrUndefinedError)
		if funcType == silentNeverType {
			return silentNeverSignature
		}
		apparentType := getApparentType(funcType)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
		numConstructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct).length
		if isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures) {
			if !isErrorType(funcType) && node.typeArguments {
				error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments)
			}
			return resolveUntypedCall(node)
		}
		if !callSignatures.length {
			if numConstructSignatures {
				error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType))
			} else {
				var relatedInformation *DiagnosticRelatedInformation
				if node.arguments.length == 1 {
					text := getSourceFileOfNode(node).text
					if isLineBreak(text.charCodeAt( /* TODO(MinusToken): - */ /* TODO(BinaryExpression): skipTrivia(text, node.expression.end, /*stopAfterLineBreak* / true) - 1 */ TODO)) {
						relatedInformation = createDiagnosticForNode(node.expression, Diagnostics.Are_you_missing_a_semicolon)
					}
				}
				invocationError(node.expression, apparentType, SignatureKindCall, relatedInformation)
			}
			return resolveErrorCall(node)
		}
		if checkMode&CheckModeSkipGenericFunctions && !node.typeArguments && callSignatures.some(isGenericFunctionReturningFunction) {
			skippedGenericFunction(node, checkMode)
			return resolvingSignature
		}
		if callSignatures.some(func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
			return isInJSFile(sig.declaration) && !!getJSDocClassTag(sig.declaration)
		}) {
			error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType))
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode, callChainFlags)
	}
	isGenericFunctionReturningFunction := func(signature Signature) /* TODO inferred type boolean */ TODO {
		return !!(signature.typeParameters && isFunctionType(getReturnTypeOfSignature(signature)))
	}
	isUntypedFunctionCall := func(funcType Type, apparentFuncType Type, numCallSignatures number, numConstructSignatures number) bool {
		return isTypeAny(funcType) || isTypeAny(apparentFuncType) && !!(funcType.flags&TypeFlagsTypeParameter) || !numCallSignatures && !numConstructSignatures && !(apparentFuncType.flags&TypeFlagsUnion) && !(getReducedType(apparentFuncType).flags&TypeFlagsNever) && isTypeAssignableTo(funcType, globalFunctionType)
	}
	resolveNewExpression := func(node NewExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		expressionType := checkNonNullExpression(node.expression)
		if expressionType == silentNeverType {
			return silentNeverSignature
		}
		expressionType = getApparentType(expressionType)
		if isErrorType(expressionType) {
			return resolveErrorCall(node)
		}
		if isTypeAny(expressionType) {
			if node.typeArguments {
				error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments)
			}
			return resolveUntypedCall(node)
		}
		constructSignatures := getSignaturesOfType(expressionType, SignatureKindConstruct)
		if constructSignatures.length {
			if !isConstructorAccessible(node /* TODO(ElementAccessExpression): constructSignatures[0] */, TODO) {
				return resolveErrorCall(node)
			}
			if someSignature(constructSignatures, func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
				return !!(signature.flags & SignatureFlagsAbstract)
			}) {
				error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class)
				return resolveErrorCall(node)
			}
			valueDecl := expressionType.symbol && getClassLikeDeclarationOfSymbol(expressionType.symbol)
			if valueDecl && hasSyntacticModifier(valueDecl, ModifierFlagsAbstract) {
				error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class)
				return resolveErrorCall(node)
			}
			return resolveCall(node, constructSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
		}
		callSignatures := getSignaturesOfType(expressionType, SignatureKindCall)
		if callSignatures.length {
			signature := resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
			if !noImplicitAny {
				if signature.declaration && !isJSConstructor(signature.declaration) && getReturnTypeOfSignature(signature) != voidType {
					error(node, Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword)
				}
				if getThisTypeOfSignature(signature) == voidType {
					error(node, Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void)
				}
			}
			return signature
		}
		invocationError(node.expression, expressionType, SignatureKindConstruct)
		return resolveErrorCall(node)
	}
	someSignature := func(signatures /* TODO(UnionType): Signature | readonly Signature[] */ any, f func(s Signature) bool) bool {
		if isArray(signatures) {
			return some(signatures, func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
				return someSignature(signature, f)
			})
		}
		return /* TODO(ConditionalExpression): signatures.compositeKind === TypeFlags.Union ? some(signatures.compositeSignatures, f) : f(signatures) */ TODO
	}
	typeHasProtectedAccessibleBase := func(target Symbol, type_ InterfaceType) bool {
		baseTypes := getBaseTypes(type_)
		if !length(baseTypes) {
			return false
		}
		firstBase := /* TODO(ElementAccessExpression): baseTypes[0] */ TODO
		if firstBase.flags & TypeFlagsIntersection {
			types := (firstBase).types
			mixinFlags := findMixins(types)
			i := 0
			for _, intersectionMember := range (firstBase).types {
				if ! /* TODO(ElementAccessExpression): mixinFlags[i] */ TODO {
					if getObjectFlags(intersectionMember) & (ObjectFlagsClass | ObjectFlagsInterface) {
						if intersectionMember.symbol == target {
							return true
						}
						if typeHasProtectedAccessibleBase(target, intersectionMember) {
							return true
						}
					}
				}
				i++
			}
			return false
		}
		if firstBase.symbol == target {
			return true
		}
		return typeHasProtectedAccessibleBase(target, firstBase)
	}
	isConstructorAccessible := func(node NewExpression, signature Signature) /* TODO inferred type boolean */ TODO {
		if !signature || !signature.declaration {
			return true
		}
		declaration := signature.declaration
		modifiers := getSelectedEffectiveModifierFlags(declaration, ModifierFlagsNonPublicAccessibilityModifier)
		if !modifiers || declaration.kind != SyntaxKindConstructor {
			return true
		}
		declaringClassDeclaration := getClassLikeDeclarationOfSymbol(declaration.parent.symbol)
		declaringClass := getDeclaredTypeOfSymbol(declaration.parent.symbol)
		if !isNodeWithinClass(node, declaringClassDeclaration) {
			containingClass := getContainingClass(node)
			if containingClass && modifiers&ModifierFlagsProtected {
				containingType := getTypeOfNode(containingClass)
				if typeHasProtectedAccessibleBase(declaration.parent.symbol, containingType) {
					return true
				}
			}
			if modifiers & ModifierFlagsPrivate {
				error(node, Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, typeToString(declaringClass))
			}
			if modifiers & ModifierFlagsProtected {
				error(node, Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, typeToString(declaringClass))
			}
			return false
		}
		return true
	}
	invocationErrorDetails := func(errorTarget Node, apparentType Type, kind SignatureKind) /* TODO(TypeLiteral): { messageChain: DiagnosticMessageChain; relatedMessage: DiagnosticMessage | undefined; } */ any {
		var errorInfo *DiagnosticMessageChain
		isCall := kind == SignatureKindCall
		awaitedType := getAwaitedType(apparentType)
		maybeMissingAwait := awaitedType && getSignaturesOfType(awaitedType, kind).length > 0
		if apparentType.flags & TypeFlagsUnion {
			types := (apparentType).types
			hasSignatures := false
			for _, constituent := range types {
				signatures := getSignaturesOfType(constituent, kind)
				if signatures.length != 0 {
					hasSignatures = true
					if errorInfo {
						break
					}
				} else {
					if !errorInfo {
						errorInfo = chainDiagnosticMessages(errorInfo /* TODO(ConditionalExpression): isCall ?                                 Diagnostics.Type_0_has_no_call_signatures :                                 Diagnostics.Type_0_has_no_construct_signatures */, TODO, typeToString(constituent))
						errorInfo = chainDiagnosticMessages(errorInfo /* TODO(ConditionalExpression): isCall ?                                 Diagnostics.Not_all_constituents_of_type_0_are_callable :                                 Diagnostics.Not_all_constituents_of_type_0_are_constructable */, TODO, typeToString(apparentType))
					}
					if hasSignatures {
						break
					}
				}
			}
			if !hasSignatures {
				errorInfo = chainDiagnosticMessages(nil /* TODO(ConditionalExpression): isCall ?                         Diagnostics.No_constituent_of_type_0_is_callable :                         Diagnostics.No_constituent_of_type_0_is_constructable */, TODO, typeToString(apparentType))
			}
			if !errorInfo {
				errorInfo = chainDiagnosticMessages(errorInfo /* TODO(ConditionalExpression): isCall ?                         Diagnostics.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other :                         Diagnostics.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other */, TODO, typeToString(apparentType))
			}
		} else {
			errorInfo = chainDiagnosticMessages(errorInfo /* TODO(ConditionalExpression): isCall ?                     Diagnostics.Type_0_has_no_call_signatures :                     Diagnostics.Type_0_has_no_construct_signatures */, TODO, typeToString(apparentType))
		}
		headMessage := /* TODO(ConditionalExpression): isCall ? Diagnostics.This_expression_is_not_callable : Diagnostics.This_expression_is_not_constructable */ TODO
		if isCallExpression(errorTarget.parent) && errorTarget.parent.arguments.length == 0 {
			TODO_IDENTIFIER := getNodeLinks(errorTarget)
			if resolvedSymbol && resolvedSymbol.flags&SymbolFlagsGetAccessor {
				headMessage = Diagnostics.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without
			}
		}
		return /* TODO(ObjectLiteralExpression): {             messageChain: chainDiagnosticMessages(errorInfo, headMessage),             relatedMessage: maybeMissingAwait ? Diagnostics.Did_you_forget_to_use_await : undefined,         } */ TODO
	}
	invocationError := func(errorTarget Node, apparentType Type, kind SignatureKind, relatedInformation DiagnosticRelatedInformation) {
		TODO_IDENTIFIER := invocationErrorDetails(errorTarget, apparentType, kind)
		diagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorTarget), errorTarget, messageChain)
		if relatedInfo {
			addRelatedInfo(diagnostic, createDiagnosticForNode(errorTarget, relatedInfo))
		}
		if isCallExpression(errorTarget.parent) {
			TODO_IDENTIFIER := getDiagnosticSpanForCallNode(errorTarget.parent)
			diagnostic.start = start
			diagnostic.length = length
		}
		diagnostics.add(diagnostic)
		invocationErrorRecovery(apparentType, kind /* TODO(ConditionalExpression): relatedInformation ? addRelatedInfo(diagnostic, relatedInformation) : diagnostic */, TODO)
	}
	invocationErrorRecovery := func(apparentType Type, kind SignatureKind, diagnostic Diagnostic) {
		if !apparentType.symbol {
			return
		}
		importNode := getSymbolLinks(apparentType.symbol).originatingImport
		if importNode && !isImportCall(importNode) {
			sigs := getSignaturesOfType(getTypeOfSymbol(getSymbolLinks(apparentType.symbol).target), kind)
			if !sigs || !sigs.length {
				return
			}
			addRelatedInfo(diagnostic, createDiagnosticForNode(importNode, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead))
		}
	}
	resolveTaggedTemplateExpression := func(node TaggedTemplateExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		tagType := checkExpression(node.tag)
		apparentType := getApparentType(tagType)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
		numConstructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct).length
		if isUntypedFunctionCall(tagType, apparentType, callSignatures.length, numConstructSignatures) {
			return resolveUntypedCall(node)
		}
		if !callSignatures.length {
			if isArrayLiteralExpression(node.parent) {
				diagnostic := createDiagnosticForNode(node.tag, Diagnostics.It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked)
				diagnostics.add(diagnostic)
				return resolveErrorCall(node)
			}
			invocationError(node.tag, apparentType, SignatureKindCall)
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
	}
	getDiagnosticHeadMessageForDecoratorResolution := func(node Decorator) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO {
		switch node.parent.kind {
		case SyntaxKindClassDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindClassExpression:
			return Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression
		case SyntaxKindParameter:
			return Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression
		case SyntaxKindPropertyDeclaration:
			return Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			return Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression
		default:
			return Debug.fail()
		}
	}
	resolveDecorator := func(node Decorator, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		funcType := checkExpression(node.expression)
		apparentType := getApparentType(funcType)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
		numConstructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct).length
		if isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures) {
			return resolveUntypedCall(node)
		}
		if isPotentiallyUncalledDecorator(node, callSignatures) && !isParenthesizedExpression(node.expression) {
			nodeStr := getTextOfNode(node.expression, false)
			error(node, Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0, nodeStr)
			return resolveErrorCall(node)
		}
		headMessage := getDiagnosticHeadMessageForDecoratorResolution(node)
		if !callSignatures.length {
			errorDetails := invocationErrorDetails(node.expression, apparentType, SignatureKindCall)
			messageChain := chainDiagnosticMessages(errorDetails.messageChain, headMessage)
			diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node.expression), node.expression, messageChain)
			if errorDetails.relatedMessage {
				addRelatedInfo(diag, createDiagnosticForNode(node.expression, errorDetails.relatedMessage))
			}
			diagnostics.add(diag)
			invocationErrorRecovery(apparentType, SignatureKindCall, diag)
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone, headMessage)
	}
	createSignatureForJSXIntrinsic := func(node JsxOpeningLikeElement, result Type) Signature {
		namespace := getJsxNamespaceAt(node)
		exports := namespace && getExportsOfSymbol(namespace)
		typeSymbol := exports && getSymbol(exports, JsxNames.Element, SymbolFlagsType)
		returnNode := typeSymbol && nodeBuilder.symbolToEntityName(typeSymbol, SymbolFlagsType, node)
		declaration := factory.createFunctionTypeNode(nil /* TODO(ArrayLiteralExpression): [factory.createParameterDeclaration(/*modifiers* / undefined, /*dotDotDotToken* / undefined, "props", /*questionToken* / undefined, nodeBuilder.typeToTypeNode(result, node))] */, TODO /* TODO(ConditionalExpression): returnNode ? factory.createTypeReferenceNode(returnNode, /*typeArguments* / undefined) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword) */, TODO)
		parameterSymbol := createSymbol(SymbolFlagsFunctionScopedVariable, "props")
		parameterSymbol.links.type_ = result
		return createSignature(declaration, nil, nil /* TODO(ArrayLiteralExpression): [parameterSymbol] */, TODO /* TODO(ConditionalExpression): typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType */, TODO, nil, 1, SignatureFlagsNone)
	}
	resolveJsxOpeningLikeElement := func(node JsxOpeningLikeElement, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		if isJsxIntrinsicTagName(node.tagName) {
			result := getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node)
			fakeSignature := createSignatureForJSXIntrinsic(node, result)
			checkTypeAssignableToAndOptionallyElaborate(checkExpressionWithContextualType(node.attributes, getEffectiveFirstArgumentForJsxSignature(fakeSignature, node), nil, CheckModeNormal), result, node.tagName, node.attributes)
			if length(node.typeArguments) {
				forEach(node.typeArguments, checkSourceElement)
				diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), node.typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, 0, length(node.typeArguments)))
			}
			return fakeSignature
		}
		exprTypes := checkExpression(node.tagName)
		apparentType := getApparentType(exprTypes)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		signatures := getUninstantiatedJsxSignaturesOfType(exprTypes, node)
		if isUntypedFunctionCall(exprTypes, apparentType, signatures.length, 0) {
			return resolveUntypedCall(node)
		}
		if signatures.length == 0 {
			error(node.tagName, Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, getTextOfNode(node.tagName))
			return resolveErrorCall(node)
		}
		return resolveCall(node, signatures, candidatesOutArray, checkMode, SignatureFlagsNone)
	}
	resolveInstanceofExpression := func(node InstanceofExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		rightType := checkExpression(node.right)
		if !isTypeAny(rightType) {
			hasInstanceMethodType := getSymbolHasInstanceMethodOfObjectType(rightType)
			if hasInstanceMethodType {
				apparentType := getApparentType(hasInstanceMethodType)
				if isErrorType(apparentType) {
					return resolveErrorCall(node)
				}
				callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
				constructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct)
				if isUntypedFunctionCall(hasInstanceMethodType, apparentType, callSignatures.length, constructSignatures.length) {
					return resolveUntypedCall(node)
				}
				if callSignatures.length {
					return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
				}
			} else if !(typeHasCallOrConstructSignatures(rightType) || isTypeSubtypeOf(rightType, globalFunctionType)) {
				error(node.right, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_either_of_type_any_a_class_function_or_other_type_assignable_to_the_Function_interface_type_or_an_object_type_with_a_Symbol_hasInstance_method)
				return resolveErrorCall(node)
			}
		}
		return anySignature
	}
	isPotentiallyUncalledDecorator := func(decorator Decorator, signatures []Signature) /* TODO inferred type boolean | 0 */ TODO {
		return signatures.length && every(signatures, func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
			return signature.minArgumentCount == 0 && !signatureHasRestParameter(signature) && signature.parameters.length < getDecoratorArgumentCount(decorator, signature)
		})
	}
	resolveSignature := func(node CallLikeExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		switch node.kind {
		case SyntaxKindCallExpression:
			return resolveCallExpression(node, candidatesOutArray, checkMode)
		case SyntaxKindNewExpression:
			return resolveNewExpression(node, candidatesOutArray, checkMode)
		case SyntaxKindTaggedTemplateExpression:
			return resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode)
		case SyntaxKindDecorator:
			return resolveDecorator(node, candidatesOutArray, checkMode)
		case SyntaxKindJsxOpeningElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSelfClosingElement:
			return resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode)
		case SyntaxKindBinaryExpression:
			return resolveInstanceofExpression(node, candidatesOutArray, checkMode)
		}
		Debug.assertNever(node, "Branch in 'resolveSignature' should be unreachable.")
	}
	getResolvedSignature := func(node CallLikeExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		links := getNodeLinks(node)
		cached := links.resolvedSignature
		if cached && cached != resolvingSignature && !candidatesOutArray {
			return cached
		}
		saveResolutionStart := resolutionStart
		if !cached {
			resolutionStart = resolutionTargets.length
		}
		links.resolvedSignature = resolvingSignature
		result := resolveSignature(node, candidatesOutArray, checkMode || CheckModeNormal)
		resolutionStart = saveResolutionStart
		if result != resolvingSignature {
			if links.resolvedSignature != resolvingSignature {
				result = links.resolvedSignature
			}
			links.resolvedSignature = /* TODO(ConditionalExpression): flowLoopStart === flowLoopCount ? result : cached */ TODO
		}
		return result
	}
	isJSConstructor := func(node Node) /* TODO(TypePredicate): node is FunctionDeclaration | FunctionExpression */ any {
		if !node || !isInJSFile(node) {
			return false
		}
		func_ := /* TODO(ConditionalExpression): isFunctionDeclaration(node) || isFunctionExpression(node) ? node :             (isVariableDeclaration(node) || isPropertyAssignment(node)) && node.initializer && isFunctionExpression(node.initializer) ? node.initializer :             undefined */ TODO
		if func_ {
			if getJSDocClassTag(node) {
				return true
			}
			if isPropertyAssignment(walkUpParenthesizedExpressions(func_.parent)) {
				return false
			}
			symbol := getSymbolOfDeclaration(func_)
			return !!symbol.members.size
		}
		return false
	}
	mergeJSSymbols := func(target Symbol, source *Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol | undefined */ TODO {
		if source {
			links := getSymbolLinks(source)
			if !links.inferredClassSymbol || !links.inferredClassSymbol.has(getSymbolId(target)) {
				inferred := /* TODO(ConditionalExpression): isTransientSymbol(target) ? target : cloneSymbol(target) */ TODO
				inferred.exports = inferred.exports || createSymbolTable()
				inferred.members = inferred.members || createSymbolTable()
				inferred.flags |= source.flags & SymbolFlagsClass
				if source.exports.size {
					mergeSymbolTable(inferred.exports, source.exports)
				}
				if source.members.size {
					mergeSymbolTable(inferred.members, source.members)
				}
				(links.inferredClassSymbol || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.inferredClassSymbol = new Map() */ TODO)).set(getSymbolId(inferred), inferred)
				return inferred
			}
			return links.inferredClassSymbol.get(getSymbolId(target))
		}
	}
	getAssignedClassSymbol := func(decl Declaration) *Symbol {
		assignmentSymbol := decl && getSymbolOfExpando(decl, true)
		prototype := assignmentSymbol.exports.get("prototype")
		init := prototype.valueDeclaration && getAssignedJSPrototype(prototype.valueDeclaration)
		return /* TODO(ConditionalExpression): init ? getSymbolOfDeclaration(init) : undefined */ TODO
	}
	getSymbolOfExpando := func(node Node, allowDeclaration bool) *Symbol {
		if !node.parent {
			return nil
		}
		var name /* TODO(UnionType): Expression | BindingName | undefined */ any
		var decl Node
		if isVariableDeclaration(node.parent) && node.parent.initializer == node {
			if !isInJSFile(node) && !(isVarConstLike(node.parent) && isFunctionLikeDeclaration(node)) {
				return nil
			}
			name = node.parent.name
			decl = node.parent
		} else if isBinaryExpression(node.parent) {
			parentNode := node.parent
			parentNodeOperator := node.parent.operatorToken.kind
			if parentNodeOperator == SyntaxKindEqualsToken && (allowDeclaration || parentNode.right == node) {
				name = parentNode.left
				decl = name
			} else if parentNodeOperator == SyntaxKindBarBarToken || parentNodeOperator == SyntaxKindQuestionQuestionToken {
				if isVariableDeclaration(parentNode.parent) && parentNode.parent.initializer == parentNode {
					name = parentNode.parent.name
					decl = parentNode.parent
				} else if isBinaryExpression(parentNode.parent) && parentNode.parent.operatorToken.kind == SyntaxKindEqualsToken && (allowDeclaration || parentNode.parent.right == parentNode) {
					name = parentNode.parent.left
					decl = name
				}
				if !name || !isBindableStaticNameExpression(name) || !isSameEntityName(name, parentNode.left) {
					return nil
				}
			}
		} else if allowDeclaration && isFunctionDeclaration(node) {
			name = node.name
			decl = node
		}
		if !decl || !name || (!allowDeclaration && !getExpandoInitializer(node, isPrototypeAccess(name))) {
			return nil
		}
		return getSymbolOfNode(decl)
	}
	getAssignedJSPrototype := func(node Node) /* TODO inferred type false | import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectLiteralExpression | undefined */ TODO {
		if !node.parent {
			return false
		}
		var parent Node = node.parent
		for parent && parent.kind == SyntaxKindPropertyAccessExpression {
			parent = parent.parent
		}
		if parent && isBinaryExpression(parent) && isPrototypeAccess(parent.left) && parent.operatorToken.kind == SyntaxKindEqualsToken {
			right := getInitializerOfBinaryExpression(parent)
			return isObjectLiteralExpression(right) && right
		}
	}
	checkCallExpression := func(node /* TODO(UnionType): CallExpression | NewExpression */ any, checkMode CheckMode) Type {
		checkGrammarTypeArguments(node, node.typeArguments)
		signature := getResolvedSignature(node, nil, checkMode)
		if signature == resolvingSignature {
			return silentNeverType
		}
		checkDeprecatedSignature(signature, node)
		if node.expression.kind == SyntaxKindSuperKeyword {
			return voidType
		}
		if node.kind == SyntaxKindNewExpression {
			declaration := signature.declaration
			if declaration && declaration.kind != SyntaxKindConstructor && declaration.kind != SyntaxKindConstructSignature && declaration.kind != SyntaxKindConstructorType && !(isJSDocSignature(declaration) && getJSDocRoot(declaration).parent.kind == SyntaxKindConstructor) && !isJSDocConstructSignature(declaration) && !isJSConstructor(declaration) {
				if noImplicitAny {
					error(node, Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type)
				}
				return anyType
			}
		}
		if isInJSFile(node) && isCommonJsRequire(node) {
			return resolveExternalModuleTypeByLiteral( /* TODO(ElementAccessExpression): node.arguments![0] */ TODO)
		}
		returnType := getReturnTypeOfSignature(signature)
		if returnType.flags&TypeFlagsESSymbolLike && isSymbolOrSymbolForCall(node) {
			return getESSymbolLikeTypeForNode(walkUpParenthesizedExpressions(node.parent))
		}
		if node.kind == SyntaxKindCallExpression && !node.questionDotToken && node.parent.kind == SyntaxKindExpressionStatement && returnType.flags&TypeFlagsVoid && getTypePredicateOfSignature(signature) {
			if !isDottedName(node.expression) {
				error(node.expression, Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name)
			} else if !getEffectsSignature(node) {
				diagnostic := error(node.expression, Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation)
				getTypeOfDottedName(node.expression, diagnostic)
			}
		}
		if isInJSFile(node) {
			jsSymbol := getSymbolOfExpando(node, false)
			if jsSymbol.exports.size {
				jsAssignmentType := createAnonymousType(jsSymbol, jsSymbol.exports, emptyArray, emptyArray, emptyArray)
				jsAssignmentType.objectFlags |= ObjectFlagsJSLiteral
				return getIntersectionType( /* TODO(ArrayLiteralExpression): [returnType, jsAssignmentType] */ TODO)
			}
		}
		return returnType
	}
	checkDeprecatedSignature := func(signature Signature, node CallLikeExpression) {
		if signature.flags & SignatureFlagsIsSignatureCandidateForOverloadFailure {
			return
		}
		if signature.declaration && signature.declaration.flags&NodeFlagsDeprecated {
			suggestionNode := getDeprecatedSuggestionNode(node)
			name := tryGetPropertyAccessOrIdentifierToString(getInvokedExpression(node))
			addDeprecatedSuggestionWithSignature(suggestionNode, signature.declaration, name, signatureToString(signature))
		}
	}
	getDeprecatedSuggestionNode := func(node Node) Node {
		node = skipParentheses(node)
		switch node.kind {
		case SyntaxKindCallExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindDecorator:
			fallthrough // TODO: merge cases
		case SyntaxKindNewExpression:
			return getDeprecatedSuggestionNode((node).expression)
		case SyntaxKindTaggedTemplateExpression:
			return getDeprecatedSuggestionNode((node).tag)
		case SyntaxKindJsxOpeningElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSelfClosingElement:
			return getDeprecatedSuggestionNode((node).tagName)
		case SyntaxKindElementAccessExpression:
			return (node).argumentExpression
		case SyntaxKindPropertyAccessExpression:
			return (node).name
		case SyntaxKindTypeReference:
			typeReference := node
			return /* TODO(ConditionalExpression): isQualifiedName(typeReference.typeName) ? typeReference.typeName.right : typeReference */ TODO
		default:
			return node
		}
	}
	isSymbolOrSymbolForCall := func(node Node) /* TODO inferred type boolean */ TODO {
		if !isCallExpression(node) {
			return false
		}
		left := node.expression
		if isPropertyAccessExpression(left) && left.name.escapedText == "for" {
			left = left.expression
		}
		if !isIdentifier(left) || left.escapedText != "Symbol" {
			return false
		}
		globalESSymbol := getGlobalESSymbolConstructorSymbol(false)
		if !globalESSymbol {
			return false
		}
		return globalESSymbol == resolveName(left, "Symbol", SymbolFlagsValue, nil, false)
	}
	checkImportCallExpression := func(node ImportCall) Type {
		checkGrammarImportCallExpression(node)
		if node.arguments.length == 0 {
			return createPromiseReturnType(node, anyType)
		}
		specifier := /* TODO(ElementAccessExpression): node.arguments[0] */ TODO
		specifierType := checkExpressionCached(specifier)
		optionsType := /* TODO(ConditionalExpression): node.arguments.length > 1 ? checkExpressionCached(node.arguments[1]) : undefined */ TODO
		/* TODO(ForStatement): for (let i = 2; i < node.arguments.length; ++i) {             checkExpressionCached(node.arguments[i]);         } */
		if specifierType.flags&TypeFlagsUndefined || specifierType.flags&TypeFlagsNull || !isTypeAssignableTo(specifierType, stringType) {
			error(specifier, Diagnostics.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0, typeToString(specifierType))
		}
		if optionsType {
			importCallOptionsType := getGlobalImportCallOptionsType(true)
			if importCallOptionsType != emptyObjectType {
				checkTypeAssignableTo(optionsType, getNullableType(importCallOptionsType, TypeFlagsUndefined) /* TODO(ElementAccessExpression): node.arguments[1] */, TODO)
			}
		}
		moduleSymbol := resolveExternalModuleName(node, specifier)
		if moduleSymbol {
			esModuleSymbol := resolveESModuleSymbol(moduleSymbol, specifier, true, false)
			if esModuleSymbol {
				return createPromiseReturnType(node, getTypeWithSyntheticDefaultOnly(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier) || getTypeWithSyntheticDefaultImportType(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier))
			}
		}
		return createPromiseReturnType(node, anyType)
	}
	createDefaultPropertyWrapperForModule := func(symbol Symbol, originalSymbol *Symbol, anonymousSymbol *Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
		memberTable := createSymbolTable()
		newSymbol := createSymbol(SymbolFlagsAlias, InternalSymbolNameDefault)
		newSymbol.parent = originalSymbol
		newSymbol.links.nameType = getStringLiteralType("default")
		newSymbol.links.aliasTarget = resolveSymbol(symbol)
		memberTable.set(InternalSymbolNameDefault, newSymbol)
		return createAnonymousType(anonymousSymbol, memberTable, emptyArray, emptyArray, emptyArray)
	}
	getTypeWithSyntheticDefaultOnly := func(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		hasDefaultOnly := isOnlyImportableAsDefault(moduleSpecifier)
		if hasDefaultOnly && type_ && !isErrorType(type_) {
			synthType := type_
			if !synthType.defaultOnlyType {
				type_ := createDefaultPropertyWrapperForModule(symbol, originalSymbol)
				synthType.defaultOnlyType = type_
			}
			return synthType.defaultOnlyType
		}
		return nil
	}
	getTypeWithSyntheticDefaultImportType := func(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) Type {
		if allowSyntheticDefaultImports && type_ && !isErrorType(type_) {
			synthType := type_
			if !synthType.syntheticType {
				file := originalSymbol.declarations.find(isSourceFile)
				hasSyntheticDefault := canHaveSyntheticDefault(file, originalSymbol, false, moduleSpecifier)
				if hasSyntheticDefault {
					anonymousSymbol := createSymbol(SymbolFlagsTypeLiteral, InternalSymbolNameType)
					defaultContainingObject := createDefaultPropertyWrapperForModule(symbol, originalSymbol, anonymousSymbol)
					anonymousSymbol.links.type_ = defaultContainingObject
					synthType.syntheticType = /* TODO(ConditionalExpression): isValidSpreadType(type) ? getSpreadType(type, defaultContainingObject, anonymousSymbol, /*objectFlags* / 0, /*readonly* / false) : defaultContainingObject */ TODO
				} else {
					synthType.syntheticType = type_
				}
			}
			return synthType.syntheticType
		}
		return type_
	}
	isCommonJsRequire := func(node Node) bool {
		if !isRequireCall(node, true) {
			return false
		}
		if !isIdentifier(node.expression) {
			return Debug.fail()
		}
		resolvedRequire := resolveName(node.expression, node.expression.escapedText, SymbolFlagsValue, nil, true)
		if resolvedRequire == requireSymbol {
			return true
		}
		if resolvedRequire.flags & SymbolFlagsAlias {
			return false
		}
		targetDeclarationKind := /* TODO(ConditionalExpression): resolvedRequire.flags & SymbolFlags.Function             ? SyntaxKind.FunctionDeclaration             : resolvedRequire.flags & SymbolFlags.Variable             ? SyntaxKind.VariableDeclaration             : SyntaxKind.Unknown */ TODO
		if targetDeclarationKind != SyntaxKindUnknown {
			decl := getDeclarationOfKind(resolvedRequire, targetDeclarationKind)
			return !!decl && !!(decl.flags & NodeFlagsAmbient)
		}
		return false
	}
	checkTaggedTemplateExpression := func(node TaggedTemplateExpression) Type {
		if !checkGrammarTaggedTemplateChain(node) {
			checkGrammarTypeArguments(node, node.typeArguments)
		}
		if languageVersion < LanguageFeatureMinimumTargetTaggedTemplates {
			checkExternalEmitHelpers(node, ExternalEmitHelpersMakeTemplateObject)
		}
		signature := getResolvedSignature(node)
		checkDeprecatedSignature(signature, node)
		return getReturnTypeOfSignature(signature)
	}
	checkAssertion := func(node AssertionExpression, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if node.kind == SyntaxKindTypeAssertionExpression {
			file := getSourceFileOfNode(node)
			if file && fileExtensionIsOneOf(file.fileName /* TODO(ArrayLiteralExpression): [Extension.Cts, Extension.Mts] */, TODO) {
				grammarErrorOnNode(node, Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead)
			}
		}
		return checkAssertionWorker(node, checkMode)
	}
	isValidConstAssertionArgument := func(node Node) bool {
		switch node.kind {
		case SyntaxKindStringLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindNumericLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindBigIntLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindTrueKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindFalseKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindArrayLiteralExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindObjectLiteralExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTemplateExpression:
			return true
		case SyntaxKindParenthesizedExpression:
			return isValidConstAssertionArgument((node).expression)
		case SyntaxKindPrefixUnaryExpression:
			op := (node).operator
			arg := (node).operand
			return op == SyntaxKindMinusToken && (arg.kind == SyntaxKindNumericLiteral || arg.kind == SyntaxKindBigIntLiteral) || op == SyntaxKindPlusToken && arg.kind == SyntaxKindNumericLiteral
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindElementAccessExpression:
			expr := skipParentheses((node).expression)
			symbol := /* TODO(ConditionalExpression): isEntityNameExpression(expr) ? resolveEntityName(expr, SymbolFlags.Value, /*ignoreErrors* / true) : undefined */ TODO
			return !!(symbol && symbol.flags&SymbolFlagsEnum)
		}
		return false
	}
	checkAssertionWorker := func(node /* TODO(UnionType): JSDocTypeAssertion | AssertionExpression */ any, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		TODO_IDENTIFIER := getAssertionTypeAndExpression(node)
		exprType := checkExpression(expression, checkMode)
		if isConstTypeReference(type_) {
			if !isValidConstAssertionArgument(expression) {
				error(expression, Diagnostics.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals)
			}
			return getRegularTypeOfLiteralType(exprType)
		}
		links := getNodeLinks(node)
		links.assertionExpressionType = exprType
		checkSourceElement(type_)
		checkNodeDeferred(node)
		return getTypeFromTypeNode(type_)
	}
	getAssertionTypeAndExpression := func(node /* TODO(UnionType): JSDocTypeAssertion | AssertionExpression */ any) /* TODO inferred type { type: import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode; expression: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; } */ TODO {
		var type_ TypeNode
		var expression Expression
		switch node.kind {
		case SyntaxKindAsExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeAssertionExpression:
			type_ = node.type_
			expression = node.expression
			break
		case SyntaxKindParenthesizedExpression:
			type_ = getJSDocTypeAssertionType(node)
			expression = node.expression
			break
		}
		return /* TODO(ObjectLiteralExpression): { type, expression } */ TODO
	}
	checkAssertionDeferred := func(node /* TODO(UnionType): JSDocTypeAssertion | AssertionExpression */ any) {
		TODO_IDENTIFIER := getAssertionTypeAndExpression(node)
		errNode := /* TODO(ConditionalExpression): isParenthesizedExpression(node) ? type : node */ TODO
		links := getNodeLinks(node)
		Debug.assertIsDefined(links.assertionExpressionType)
		exprType := getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(links.assertionExpressionType))
		targetType := getTypeFromTypeNode(type_)
		if !isErrorType(targetType) {
			addLazyDiagnostic(func() {
				widenedType := getWidenedType(exprType)
				if !isTypeComparableTo(targetType, widenedType) {
					checkTypeComparableTo(exprType, targetType, errNode, Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first)
				}
			})
		}
	}
	checkNonNullChain := func(node NonNullChain) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		leftType := checkExpression(node.expression)
		nonOptionalType := getOptionalExpressionType(leftType, node.expression)
		return propagateOptionalTypeMarker(getNonNullableType(nonOptionalType), node, nonOptionalType != leftType)
	}
	checkNonNullAssertion := func(node NonNullExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): node.flags & NodeFlags.OptionalChain ? checkNonNullChain(node as NonNullChain) :             getNonNullableType(checkExpression(node.expression)) */ TODO
	}
	checkExpressionWithTypeArguments := func(node /* TODO(UnionType): ExpressionWithTypeArguments | TypeQueryNode */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		checkGrammarExpressionWithTypeArguments(node)
		forEach(node.typeArguments, checkSourceElement)
		if node.kind == SyntaxKindExpressionWithTypeArguments {
			parent := walkUpParenthesizedExpressions(node.parent)
			if parent.kind == SyntaxKindBinaryExpression && (parent).operatorToken.kind == SyntaxKindInstanceOfKeyword && isNodeDescendantOf(node, (parent).right) {
				error(node, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_not_be_an_instantiation_expression)
			}
		}
		exprType := /* TODO(ConditionalExpression): node.kind === SyntaxKind.ExpressionWithTypeArguments ? checkExpression(node.expression) :             isThisIdentifier(node.exprName) ? checkThisExpression(node.exprName) :             checkExpression(node.exprName) */ TODO
		return getInstantiationExpressionType(exprType, node)
	}
	getInstantiationExpressionType := func(exprType Type, node NodeWithTypeArguments) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		typeArguments := node.typeArguments
		if exprType == silentNeverType || isErrorType(exprType) || !some(typeArguments) {
			return exprType
		}
		hasSomeApplicableSignature := false
		var nonApplicableType *Type
		result := getInstantiatedType(exprType)
		errorType := /* TODO(ConditionalExpression): hasSomeApplicableSignature ? nonApplicableType : exprType */ TODO
		if errorType {
			diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable, typeToString(errorType)))
		}
		return result
		getInstantiatedType := func(type_ Type) Type {
			hasSignatures := false
			hasApplicableSignature := false
			result := getInstantiatedTypePart(type_)
			/* TODO(ExpressionStatement): hasSomeApplicableSignature ||= hasApplicableSignature; */
			if hasSignatures && !hasApplicableSignature {
				/* TODO(ExpressionStatement): nonApplicableType ??= type; */
			}
			return result
			getInstantiatedTypePart := func(type_ Type) Type {
				if type_.flags & TypeFlagsObject {
					resolved := resolveStructuredTypeMembers(type_)
					callSignatures := getInstantiatedSignatures(resolved.callSignatures)
					constructSignatures := getInstantiatedSignatures(resolved.constructSignatures)
					/* TODO(ExpressionStatement): hasSignatures ||= resolved.callSignatures.length !== 0 || resolved.constructSignatures.length !== 0; */
					/* TODO(ExpressionStatement): hasApplicableSignature ||= callSignatures.length !== 0 || constructSignatures.length !== 0; */
					if callSignatures != resolved.callSignatures || constructSignatures != resolved.constructSignatures {
						result := createAnonymousType(createSymbol(SymbolFlagsNone, InternalSymbolNameInstantiationExpression), resolved.members, callSignatures, constructSignatures, resolved.indexInfos)
						result.objectFlags |= ObjectFlagsInstantiationExpressionType
						result.node = node
						return result
					}
				} else if type_.flags & TypeFlagsInstantiableNonPrimitive {
					constraint := getBaseConstraintOfType(type_)
					if constraint {
						instantiated := getInstantiatedTypePart(constraint)
						if instantiated != constraint {
							return instantiated
						}
					}
				} else if type_.flags & TypeFlagsUnion {
					return mapType(type_, getInstantiatedType)
				} else if type_.flags & TypeFlagsIntersection {
					return getIntersectionType(sameMap((type_).types, getInstantiatedTypePart))
				}
				return type_
			}
		}
		getInstantiatedSignatures := func(signatures []Signature) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
			applicableSignatures := filter(signatures, func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
				return !!sig.typeParameters && hasCorrectTypeArgumentArity(sig, typeArguments)
			})
			return sameMap(applicableSignatures, func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
				typeArgumentTypes := checkTypeArguments(sig, typeArguments, true)
				return /* TODO(ConditionalExpression): typeArgumentTypes ? getSignatureInstantiation(sig, typeArgumentTypes, isInJSFile(sig.declaration)) : sig */ TODO
			})
		}
	}
	checkSatisfiesExpression := func(node SatisfiesExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		checkSourceElement(node.type_)
		return checkSatisfiesExpressionWorker(node.expression, node.type_)
	}
	checkSatisfiesExpressionWorker := func(expression Expression, target TypeNode, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		exprType := checkExpression(expression, checkMode)
		targetType := getTypeFromTypeNode(target)
		if isErrorType(targetType) {
			return targetType
		}
		errorNode := findAncestor(target.parent, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
			return n.kind == SyntaxKindSatisfiesExpression || n.kind == SyntaxKindJSDocSatisfiesTag
		})
		checkTypeAssignableToAndOptionallyElaborate(exprType, targetType, errorNode, expression, Diagnostics.Type_0_does_not_satisfy_the_expected_type_1)
		return exprType
	}
	checkMetaProperty := func(node MetaProperty) Type {
		checkGrammarMetaProperty(node)
		if node.keywordToken == SyntaxKindNewKeyword {
			return checkNewTargetMetaProperty(node)
		}
		if node.keywordToken == SyntaxKindImportKeyword {
			return checkImportMetaProperty(node)
		}
		return Debug.assertNever(node.keywordToken)
	}
	checkMetaPropertyKeyword := func(node MetaProperty) Type {
		switch node.keywordToken {
		case SyntaxKindImportKeyword:
			return getGlobalImportMetaExpressionType()
		case SyntaxKindNewKeyword:
			type_ := checkNewTargetMetaProperty(node)
			return /* TODO(ConditionalExpression): isErrorType(type) ? errorType : createNewTargetExpressionType(type) */ TODO
		default:
			Debug.assertNever(node.keywordToken)
		}
	}
	checkNewTargetMetaProperty := func(node MetaProperty) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		container := getNewTargetContainer(node)
		if !container {
			error(node, Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor, "new.target")
			return errorType
		} else if container.kind == SyntaxKindConstructor {
			symbol := getSymbolOfDeclaration(container.parent)
			return getTypeOfSymbol(symbol)
		} else {
			symbol := getSymbolOfDeclaration(container)
			return getTypeOfSymbol(symbol)
		}
	}
	checkImportMetaProperty := func(node MetaProperty) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType | import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		if moduleKind == ModuleKindNode16 || moduleKind == ModuleKindNodeNext {
			if getSourceFileOfNode(node).impliedNodeFormat != ModuleKindESNext {
				error(node, Diagnostics.The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output)
			}
		} else if moduleKind < ModuleKindES2020 && moduleKind != ModuleKindSystem {
			error(node, Diagnostics.The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext)
		}
		file := getSourceFileOfNode(node)
		Debug.assert(!!(file.flags & NodeFlagsPossiblyContainsImportMeta), "Containing file is missing import meta node flag.")
		return /* TODO(ConditionalExpression): node.name.escapedText === "meta" ? getGlobalImportMetaType() : errorType */ TODO
	}
	getTypeOfParameter := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		declaration := symbol.valueDeclaration
		return addOptionality(getTypeOfSymbol(symbol), false, !!declaration && (hasInitializer(declaration) || isOptionalDeclaration(declaration)))
	}
	getTupleElementLabelFromBindingElement := func(node /* TODO(UnionType): BindingElement | ParameterDeclaration */ any, index number, elementFlags ElementFlags) __String {
		switch node.name.kind {
		case SyntaxKindIdentifier:
			name := node.name.escapedText
			if node.dotDotDotToken {
				return /* TODO(ConditionalExpression): elementFlags & ElementFlags.Variable ? name : `${name}_${index}` as __String */ TODO
			} else {
				return /* TODO(ConditionalExpression): elementFlags & ElementFlags.Fixed ? name : `${name}_n` as __String */ TODO
			}
			fallthrough
		case SyntaxKindArrayBindingPattern:
			if node.dotDotDotToken {
				elements := node.name.elements
				lastElement := tryCast(lastOrUndefined(elements), isBindingElement)
				elementCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): elements.length - (lastElement?.dotDotDotToken ? 1 : 0) */ TODO
				if index < elementCount {
					element := /* TODO(ElementAccessExpression): elements[index] */ TODO
					if isBindingElement(element) {
						return getTupleElementLabelFromBindingElement(element, index, elementFlags)
					}
				} else if lastElement.dotDotDotToken {
					return getTupleElementLabelFromBindingElement(lastElement /* TODO(MinusToken): - */ /* TODO(BinaryExpression): index - elementCount */, TODO, elementFlags)
				}
			}
			break
		}
		return /* TODO(TemplateExpression): `arg_${index}` */ TODO
	}
	// OVERLOAD: getTupleElementLabel := func(d /* TODO(UnionType): ParameterDeclaration | NamedTupleMember */ any) __String
	// OVERLOAD: getTupleElementLabel := func(d /* TODO(UnionType): ParameterDeclaration | NamedTupleMember | undefined */ any, index number, elementFlags ElementFlags, restSymbol Symbol) __String
	getTupleElementLabel := func(d /* TODO(UnionType): ParameterDeclaration | NamedTupleMember | undefined */ any, index /* TODO inferred type number */ TODO /*  = 0 */, elementFlags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ TODO /*  = ElementFlags.Fixed */, restSymbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
		if !d {
			restParameter := tryCast(restSymbol.valueDeclaration, isParameter)
			return /* TODO(ConditionalExpression): restParameter ? getTupleElementLabelFromBindingElement(restParameter, index, elementFlags) :                 `${restSymbol?.escapedName ?? "arg"}_${index}` as __String */ TODO
		}
		Debug.assert(isIdentifier(d.name))
		return d.name.escapedText
	}
	getParameterNameAtPosition := func(signature Signature, pos number, overrideRestType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
		paramCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		if pos < paramCount {
			return /* TODO(ElementAccessExpression): signature.parameters[pos] */ TODO.escapedName
		}
		restParameter := /* TODO(ElementAccessExpression): signature.parameters[paramCount] */ TODO || unknownSymbol
		restType := overrideRestType || getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			tupleType := (restType).target
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): pos - paramCount */ TODO
			associatedName := /* TODO(ElementAccessExpression): tupleType.labeledElementDeclarations?.[index] */ TODO
			elementFlags := /* TODO(ElementAccessExpression): tupleType.elementFlags[index] */ TODO
			return getTupleElementLabel(associatedName, index, elementFlags, restParameter)
		}
		return restParameter.escapedName
	}
	getParameterIdentifierInfoAtPosition := func(signature Signature, pos number) /* TODO(TypeLiteral): { parameter: Identifier; parameterName: __String; isRestParameter: boolean; } */ any {
		if signature.declaration.kind == SyntaxKindJSDocFunctionType {
			return nil
		}
		paramCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		if pos < paramCount {
			param := /* TODO(ElementAccessExpression): signature.parameters[pos] */ TODO
			paramIdent := getParameterDeclarationIdentifier(param)
			return /* TODO(ConditionalExpression): paramIdent ? {                 parameter: paramIdent,                 parameterName: param.escapedName,                 isRestParameter: false,             } : undefined */ TODO
		}
		restParameter := /* TODO(ElementAccessExpression): signature.parameters[paramCount] */ TODO || unknownSymbol
		restIdent := getParameterDeclarationIdentifier(restParameter)
		if !restIdent {
			return nil
		}
		restType := getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			associatedNames := ((restType).target).labeledElementDeclarations
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): pos - paramCount */ TODO
			associatedName := /* TODO(ElementAccessExpression): associatedNames?.[index] */ TODO
			isRestTupleElement := !!associatedName.dotDotDotToken
			if associatedName {
				Debug.assert(isIdentifier(associatedName.name))
				return /* TODO(ObjectLiteralExpression): { parameter: associatedName.name, parameterName: associatedName.name.escapedText, isRestParameter: isRestTupleElement } */ TODO
			}
			return nil
		}
		if pos == paramCount {
			return /* TODO(ObjectLiteralExpression): { parameter: restIdent, parameterName: restParameter.escapedName, isRestParameter: true } */ TODO
		}
		return nil
	}
	getParameterDeclarationIdentifier := func(symbol Symbol) /* TODO inferred type false | import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | undefined */ TODO {
		return symbol.valueDeclaration && isParameter(symbol.valueDeclaration) && isIdentifier(symbol.valueDeclaration.name) && symbol.valueDeclaration.name
	}
	isValidDeclarationForTupleLabel := func(d Declaration) /* TODO(TypePredicate): d is NamedTupleMember | (ParameterDeclaration & { name: Identifier; }) */ any {
		return d.kind == SyntaxKindNamedTupleMember || (isParameter(d) && d.name && isIdentifier(d.name))
	}
	getNameableDeclarationAtPosition := func(signature Signature, pos number) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember | undefined */ TODO {
		paramCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		if pos < paramCount {
			decl := /* TODO(ElementAccessExpression): signature.parameters[pos] */ TODO.valueDeclaration
			return /* TODO(ConditionalExpression): decl && isValidDeclarationForTupleLabel(decl) ? decl : undefined */ TODO
		}
		restParameter := /* TODO(ElementAccessExpression): signature.parameters[paramCount] */ TODO || unknownSymbol
		restType := getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			associatedNames := ((restType).target).labeledElementDeclarations
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): pos - paramCount */ TODO
			return associatedNames && /* TODO(ElementAccessExpression): associatedNames[index] */ TODO
		}
		return /* TODO(ConditionalExpression): restParameter.valueDeclaration && isValidDeclarationForTupleLabel(restParameter.valueDeclaration) ? restParameter.valueDeclaration : undefined */ TODO
	}
	getTypeAtPosition := func(signature Signature, pos number) Type {
		return tryGetTypeAtPosition(signature, pos) || anyType
	}
	tryGetTypeAtPosition := func(signature Signature, pos number) *Type {
		paramCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		if pos < paramCount {
			return getTypeOfParameter( /* TODO(ElementAccessExpression): signature.parameters[pos] */ TODO)
		}
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[paramCount] */ TODO)
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): pos - paramCount */ TODO
			if !isTupleType(restType) || restType.target.combinedFlags&ElementFlagsVariable || index < restType.target.fixedLength {
				return getIndexedAccessType(restType, getNumberLiteralType(index))
			}
		}
		return nil
	}
	getRestTypeAtPosition := func(source Signature, pos number, readonly bool) Type {
		parameterCount := getParameterCount(source)
		minArgumentCount := getMinArgumentCount(source)
		restType := getEffectiveRestType(source)
		if restType && pos >= /* TODO(MinusToken): - */ /* TODO(BinaryExpression): parameterCount - 1 */ TODO {
			return /* TODO(ConditionalExpression): pos === parameterCount - 1 ? restType : createArrayType(getIndexedAccessType(restType, numberType)) */ TODO
		}
		types := /* TODO(ArrayLiteralExpression): [] */ TODO
		flags := /* TODO(ArrayLiteralExpression): [] */ TODO
		names := /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = pos; i < parameterCount; i++) {             if (!restType || i < parameterCount - 1) {                 types.push(getTypeAtPosition(source, i));                 flags.push(i < minArgumentCount ? ElementFlags.Required : ElementFlags.Optional);             }             else {                 types.push(restType);                 flags.push(ElementFlags.Variadic);             }             names.push(getNameableDeclarationAtPosition(source, i));         } */
		return createTupleType(types, flags, readonly, names)
	}
	getRestOrAnyTypeAtPosition := func(source Signature, pos number) Type {
		restType := getRestTypeAtPosition(source, pos)
		elementType := restType && getElementTypeOfArrayType(restType)
		return /* TODO(ConditionalExpression): elementType && isTypeAny(elementType) ? anyType : restType */ TODO
	}
	getParameterCount := func(signature Signature) /* TODO inferred type number */ TODO {
		length := signature.parameters.length
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[length - 1] */ TODO)
			if isTupleType(restType) {
				return /* TODO(MinusToken): - */ /* TODO(BinaryExpression): length + restType.target.fixedLength - (restType.target.combinedFlags & ElementFlags.Variable ? 0 : 1) */ TODO
			}
		}
		return length
	}
	getMinArgumentCount := func(signature Signature, flags MinArgumentCountFlags) /* TODO inferred type number */ TODO {
		strongArityForUntypedJS := flags & MinArgumentCountFlagsStrongArityForUntypedJS
		voidIsNonOptional := flags & MinArgumentCountFlagsVoidIsNonOptional
		if voidIsNonOptional || signature.resolvedMinArgumentCount == nil {
			var minArgumentCount /* TODO(NumberKeyword): number */ any
			if signatureHasRestParameter(signature) {
				restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
				if isTupleType(restType) {
					firstOptionalIndex := findIndex(restType.target.elementFlags, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ TODO) /* TODO inferred type boolean */ TODO {
						return !(f & ElementFlagsRequired)
					})
					requiredCount := /* TODO(ConditionalExpression): firstOptionalIndex < 0 ? restType.target.fixedLength : firstOptionalIndex */ TODO
					if requiredCount > 0 {
						minArgumentCount = /* TODO(PlusToken): + */ /* TODO(BinaryExpression): signature.parameters.length - 1 + requiredCount */ TODO
					}
				}
			}
			if minArgumentCount == nil {
				if !strongArityForUntypedJS && signature.flags&SignatureFlagsIsUntypedSignatureInJSFile {
					return 0
				}
				minArgumentCount = signature.minArgumentCount
			}
			if voidIsNonOptional {
				return minArgumentCount
			}
			/* TODO(ForStatement): for (let i = minArgumentCount - 1; i >= 0; i--) {                 const type = getTypeAtPosition(signature, i);                 if (filterType(type, acceptsVoid).flags & TypeFlags.Never) {                     break;                 }                 minArgumentCount = i;             } */
			signature.resolvedMinArgumentCount = minArgumentCount
		}
		return signature.resolvedMinArgumentCount
	}
	hasEffectiveRestParameter := func(signature Signature) /* TODO inferred type boolean */ TODO {
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
			return !isTupleType(restType) || !!(restType.target.combinedFlags & ElementFlagsVariable)
		}
		return false
	}
	getEffectiveRestType := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
			if !isTupleType(restType) {
				return /* TODO(ConditionalExpression): isTypeAny(restType) ? anyArrayType : restType */ TODO
			}
			if restType.target.combinedFlags & ElementFlagsVariable {
				return sliceTupleType(restType, restType.target.fixedLength)
			}
		}
		return nil
	}
	getNonArrayRestType := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		restType := getEffectiveRestType(signature)
		return /* TODO(ConditionalExpression): restType && !isArrayType(restType) && !isTypeAny(restType) ? restType : undefined */ TODO
	}
	getTypeOfFirstParameterOfSignature := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getTypeOfFirstParameterOfSignatureWithFallback(signature, neverType)
	}
	getTypeOfFirstParameterOfSignatureWithFallback := func(signature Signature, fallbackType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): signature.parameters.length > 0 ? getTypeAtPosition(signature, 0) : fallbackType */ TODO
	}
	inferFromAnnotatedParameters := func(signature Signature, context Signature, inferenceContext InferenceContext) {
		len := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		/* TODO(ForStatement): for (let i = 0; i < len; i++) {             const declaration = signature.parameters[i].valueDeclaration as ParameterDeclaration;             const typeNode = getEffectiveTypeAnnotationNode(declaration);             if (typeNode) {                 const source = addOptionality(getTypeFromTypeNode(typeNode), /*isProperty* / false, isOptionalDeclaration(declaration));                 const target = getTypeAtPosition(context, i);                 inferTypes(inferenceContext.inferences, source, target);             }         } */
	}
	assignContextualParameterTypes := func(signature Signature, context Signature) {
		if context.typeParameters {
			if !signature.typeParameters {
				signature.typeParameters = context.typeParameters
			} else {
				return
			}
		}
		if context.thisParameter {
			parameter := signature.thisParameter
			if !parameter || parameter.valueDeclaration && !(parameter.valueDeclaration).type_ {
				if !parameter {
					signature.thisParameter = createSymbolWithType(context.thisParameter, nil)
				}
				assignParameterType(signature.thisParameter, getTypeOfSymbol(context.thisParameter))
			}
		}
		len := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		/* TODO(ForStatement): for (let i = 0; i < len; i++) {             const parameter = signature.parameters[i];             const declaration = parameter.valueDeclaration as ParameterDeclaration;             if (!getEffectiveTypeAnnotationNode(declaration)) {                 let type = tryGetTypeAtPosition(context, i);                 if (type && declaration.initializer) {                     let initializerType = checkDeclarationInitializer(declaration, CheckMode.Normal);                     if (!isTypeAssignableTo(initializerType, type) && isTypeAssignableTo(type, initializerType = widenTypeInferredFromInitializer(declaration, initializerType))) {                         type = initializerType;                     }                 }                 assignParameterType(parameter, type);             }         } */
		if signatureHasRestParameter(signature) {
			parameter := last(signature.parameters)
			if /* TODO(ConditionalExpression): parameter.valueDeclaration                     ? !getEffectiveTypeAnnotationNode(parameter.valueDeclaration as ParameterDeclaration)                     // a declarationless parameter may still have a `.type` already set by its construction logic                     // (which may pull a type from a jsdoc) - only allow fixing on `DeferredType` parameters with a fallback type                     : !!(getCheckFlags(parameter) & CheckFlags.DeferredType) */ TODO {
				contextualParameterType := getRestTypeAtPosition(context, len)
				assignParameterType(parameter, contextualParameterType)
			}
		}
	}
	assignNonContextualParameterTypes := func(signature Signature) {
		if signature.thisParameter {
			assignParameterType(signature.thisParameter)
		}
		for _, parameter := range signature.parameters {
			assignParameterType(parameter)
		}
	}
	assignParameterType := func(parameter Symbol, contextualType Type) {
		links := getSymbolLinks(parameter)
		if !links.type_ {
			declaration := parameter.valueDeclaration
			links.type_ = addOptionality(contextualType || ( /* TODO(ConditionalExpression): declaration ? getWidenedTypeForVariableLikeDeclaration(declaration, /*reportErrors* / true) : getTypeOfSymbol(parameter) */ TODO), false, !!declaration && !declaration.initializer && isOptionalDeclaration(declaration))
			if declaration && declaration.name.kind != SyntaxKindIdentifier {
				if links.type_ == unknownType {
					links.type_ = getTypeFromBindingPattern(declaration.name)
				}
				assignBindingElementTypes(declaration.name, links.type_)
			}
		} else if contextualType {
			Debug.assertEqual(links.type_, contextualType, "Parameter symbol already has a cached type which differs from newly assigned type")
		}
	}
	assignBindingElementTypes := func(pattern BindingPattern, parentType Type) {
		for _, element := range pattern.elements {
			if !isOmittedExpression(element) {
				type_ := getBindingElementTypeFromParentType(element, parentType, false)
				if element.name.kind == SyntaxKindIdentifier {
					getSymbolLinks(getSymbolOfDeclaration(element)).type_ = type_
				} else {
					assignBindingElementTypes(element.name, type_)
				}
			}
		}
	}
	createClassDecoratorContextType := func(classType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassDecoratorContextType(true) /* TODO(ArrayLiteralExpression): [classType] */, TODO)
	}
	createClassMethodDecoratorContextType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassMethodDecoratorContextType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassGetterDecoratorContextType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassGetterDecoratorContextType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassSetterDecoratorContextType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassSetterDecoratorContextType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassAccessorDecoratorContextType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorContextType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassFieldDecoratorContextType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassFieldDecoratorContextType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	getClassMemberDecoratorContextOverrideType := func(nameType Type, isPrivate bool, isStatic bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		key := /* TODO(TemplateExpression): `${isPrivate ? "p" : "P"}${isStatic ? "s" : "S"}${nameType.id}` */ TODO
		overrideType := decoratorContextOverrideTypeCache.get(key)
		if !overrideType {
			members := createSymbolTable()
			members.set("name", createProperty("name", nameType))
			members.set("private", createProperty("private" /* TODO(ConditionalExpression): isPrivate ? trueType : falseType */, TODO))
			members.set("static", createProperty("static" /* TODO(ConditionalExpression): isStatic ? trueType : falseType */, TODO))
			overrideType = createAnonymousType(nil, members, emptyArray, emptyArray, emptyArray)
			decoratorContextOverrideTypeCache.set(key, overrideType)
		}
		return overrideType
	}
	createClassMemberDecoratorContextTypeForNode := func(node /* TODO(UnionType): MethodDeclaration | AccessorDeclaration | PropertyDeclaration */ any, thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		isStatic := hasStaticModifier(node)
		isPrivate := isPrivateIdentifier(node.name)
		nameType := /* TODO(ConditionalExpression): isPrivate ? getStringLiteralType(idText(node.name)) : getLiteralTypeFromPropertyName(node.name) */ TODO
		contextType := /* TODO(ConditionalExpression): isMethodDeclaration(node) ? createClassMethodDecoratorContextType(thisType, valueType) :             isGetAccessorDeclaration(node) ? createClassGetterDecoratorContextType(thisType, valueType) :             isSetAccessorDeclaration(node) ? createClassSetterDecoratorContextType(thisType, valueType) :             isAutoAccessorPropertyDeclaration(node) ? createClassAccessorDecoratorContextType(thisType, valueType) :             isPropertyDeclaration(node) ? createClassFieldDecoratorContextType(thisType, valueType) :             Debug.failBadSyntaxKind(node) */ TODO
		overrideType := getClassMemberDecoratorContextOverrideType(nameType, isPrivate, isStatic)
		return getIntersectionType( /* TODO(ArrayLiteralExpression): [contextType, overrideType] */ TODO)
	}
	createClassAccessorDecoratorTargetType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorTargetType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassAccessorDecoratorResultType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorResultType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassFieldDecoratorInitializerMutatorType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		thisParam := createParameter("this", thisType)
		valueParam := createParameter("value", valueType)
		return createFunctionType(nil, thisParam /* TODO(ArrayLiteralExpression): [valueParam] */, TODO, valueType, nil, 1)
	}
	createESDecoratorCallSignature := func(targetType Type, contextType Type, nonOptionalReturnType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		targetParam := createParameter("target", targetType)
		contextParam := createParameter("context", contextType)
		returnType := getUnionType( /* TODO(ArrayLiteralExpression): [nonOptionalReturnType, voidType] */ TODO)
		return createCallSignature(nil, nil /* TODO(ArrayLiteralExpression): [targetParam, contextParam] */, TODO, returnType)
	}
	getESDecoratorCallSignature := func(decorator Decorator) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		TODO_IDENTIFIER := decorator
		links := getNodeLinks(parent)
		if !links.decoratorSignature {
			links.decoratorSignature = anySignature
			switch parent.kind {
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindClassExpression:
				node := parent
				targetType := getTypeOfSymbol(getSymbolOfDeclaration(node))
				contextType := createClassDecoratorContextType(targetType)
				links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, targetType)
				break
				fallthrough
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				node := parent
				if !isClassLike(node.parent) {
					break
				}
				valueType := /* TODO(ConditionalExpression): isMethodDeclaration(node) ? getOrCreateTypeFromSignature(getSignatureFromDeclaration(node)) :                         getTypeOfNode(node) */ TODO
				thisType := /* TODO(ConditionalExpression): hasStaticModifier(node) ?                         getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) :                         getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent)) */ TODO
				targetType := /* TODO(ConditionalExpression): isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) :                         isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) :                         valueType */ TODO
				contextType := createClassMemberDecoratorContextTypeForNode(node, thisType, valueType)
				returnType := /* TODO(ConditionalExpression): isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) :                         isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) :                         valueType */ TODO
				links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType)
				break
				fallthrough
			case SyntaxKindPropertyDeclaration:
				node := parent
				if !isClassLike(node.parent) {
					break
				}
				valueType := getTypeOfNode(node)
				thisType := /* TODO(ConditionalExpression): hasStaticModifier(node) ?                         getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) :                         getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent)) */ TODO
				targetType := /* TODO(ConditionalExpression): hasAccessorModifier(node) ? createClassAccessorDecoratorTargetType(thisType, valueType) :                         undefinedType */ TODO
				contextType := createClassMemberDecoratorContextTypeForNode(node, thisType, valueType)
				returnType := /* TODO(ConditionalExpression): hasAccessorModifier(node) ? createClassAccessorDecoratorResultType(thisType, valueType) :                         createClassFieldDecoratorInitializerMutatorType(thisType, valueType) */ TODO
				links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType)
				break
			}
		}
		return /* TODO(ConditionalExpression): links.decoratorSignature === anySignature ? undefined : links.decoratorSignature */ TODO
	}
	getLegacyDecoratorCallSignature := func(decorator Decorator) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		TODO_IDENTIFIER := decorator
		links := getNodeLinks(parent)
		if !links.decoratorSignature {
			links.decoratorSignature = anySignature
			switch parent.kind {
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindClassExpression:
				node := parent
				targetType := getTypeOfSymbol(getSymbolOfDeclaration(node))
				targetParam := createParameter("target", targetType)
				links.decoratorSignature = createCallSignature(nil, nil /* TODO(ArrayLiteralExpression): [targetParam] */, TODO, getUnionType( /* TODO(ArrayLiteralExpression): [targetType, voidType] */ TODO))
				break
				fallthrough
			case SyntaxKindParameter:
				node := parent
				if !isConstructorDeclaration(node.parent) && !(isMethodDeclaration(node.parent) || isSetAccessorDeclaration(node.parent) && isClassLike(node.parent.parent)) {
					break
				}
				if getThisParameter(node.parent) == node {
					break
				}
				index := /* TODO(ConditionalExpression): getThisParameter(node.parent) ?                         node.parent.parameters.indexOf(node) - 1 :                         node.parent.parameters.indexOf(node) */ TODO
				Debug.assert(index >= 0)
				targetType := /* TODO(ConditionalExpression): isConstructorDeclaration(node.parent) ? getTypeOfSymbol(getSymbolOfDeclaration(node.parent.parent)) :                         getParentTypeOfClassElement(node.parent) */ TODO
				keyType := /* TODO(ConditionalExpression): isConstructorDeclaration(node.parent) ? undefinedType :                         getClassElementPropertyKeyType(node.parent) */ TODO
				indexType := getNumberLiteralType(index)
				targetParam := createParameter("target", targetType)
				keyParam := createParameter("propertyKey", keyType)
				indexParam := createParameter("parameterIndex", indexType)
				links.decoratorSignature = createCallSignature(nil, nil /* TODO(ArrayLiteralExpression): [targetParam, keyParam, indexParam] */, TODO, voidType)
				break
				fallthrough
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindPropertyDeclaration:
				node := parent
				if !isClassLike(node.parent) {
					break
				}
				targetType := getParentTypeOfClassElement(node)
				targetParam := createParameter("target", targetType)
				keyType := getClassElementPropertyKeyType(node)
				keyParam := createParameter("propertyKey", keyType)
				returnType := /* TODO(ConditionalExpression): isPropertyDeclaration(node) ? voidType :                         createTypedPropertyDescriptorType(getTypeOfNode(node)) */ TODO
				hasPropDesc := !isPropertyDeclaration(parent) || hasAccessorModifier(parent)
				if hasPropDesc {
					descriptorType := createTypedPropertyDescriptorType(getTypeOfNode(node))
					descriptorParam := createParameter("descriptor", descriptorType)
					links.decoratorSignature = createCallSignature(nil, nil /* TODO(ArrayLiteralExpression): [targetParam, keyParam, descriptorParam] */, TODO, getUnionType( /* TODO(ArrayLiteralExpression): [returnType, voidType] */ TODO))
				} else {
					links.decoratorSignature = createCallSignature(nil, nil /* TODO(ArrayLiteralExpression): [targetParam, keyParam] */, TODO, getUnionType( /* TODO(ArrayLiteralExpression): [returnType, voidType] */ TODO))
				}
				break
			}
		}
		return /* TODO(ConditionalExpression): links.decoratorSignature === anySignature ? undefined : links.decoratorSignature */ TODO
	}
	getDecoratorCallSignature := func(decorator Decorator) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		return /* TODO(ConditionalExpression): legacyDecorators ? getLegacyDecoratorCallSignature(decorator) :             getESDecoratorCallSignature(decorator) */ TODO
	}
	createPromiseType := func(promisedType Type) Type {
		globalPromiseType := getGlobalPromiseType(true)
		if globalPromiseType != emptyGenericType {
			promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType
			return createTypeReference(globalPromiseType /* TODO(ArrayLiteralExpression): [promisedType] */, TODO)
		}
		return unknownType
	}
	createPromiseLikeType := func(promisedType Type) Type {
		globalPromiseLikeType := getGlobalPromiseLikeType(true)
		if globalPromiseLikeType != emptyGenericType {
			promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType
			return createTypeReference(globalPromiseLikeType /* TODO(ArrayLiteralExpression): [promisedType] */, TODO)
		}
		return unknownType
	}
	createPromiseReturnType := func(func_ /* TODO(UnionType): FunctionLikeDeclaration | ImportCall */ any, promisedType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		promiseType := createPromiseType(promisedType)
		if promiseType == unknownType {
			error(func_ /* TODO(ConditionalExpression): isImportCall(func) ?                     Diagnostics.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option :                     Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option */, TODO)
			return errorType
		} else if !getGlobalPromiseConstructorSymbol(true) {
			error(func_ /* TODO(ConditionalExpression): isImportCall(func) ?                     Diagnostics.A_dynamic_import_call_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option :                     Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option */, TODO)
		}
		return promiseType
	}
	createNewTargetExpressionType := func(targetType Type) Type {
		symbol := createSymbol(SymbolFlagsNone, "NewTargetExpression")
		targetPropertySymbol := createSymbol(SymbolFlagsProperty, "target", CheckFlagsReadonly)
		targetPropertySymbol.parent = symbol
		targetPropertySymbol.links.type_ = targetType
		members := createSymbolTable( /* TODO(ArrayLiteralExpression): [targetPropertySymbol] */ TODO)
		symbol.members = members
		return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
	}
	getReturnTypeFromBody := func(func_ FunctionLikeDeclaration, checkMode CheckMode) Type {
		if !func_.body {
			return errorType
		}
		functionFlags := getFunctionFlags(func_)
		isAsync := (functionFlags & FunctionFlagsAsync) != 0
		isGenerator := (functionFlags & FunctionFlagsGenerator) != 0
		var returnType *Type
		var yieldType *Type
		var nextType *Type
		var fallbackReturnType Type = voidType
		if func_.body.kind != SyntaxKindBlock {
			returnType = checkExpressionCached(func_.body, checkMode && checkMode&~CheckModeSkipGenericFunctions)
			if isAsync {
				returnType = unwrapAwaitedType(checkAwaitedType(returnType, false, func_, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member))
			}
		} else if isGenerator {
			returnTypes := checkAndAggregateReturnExpressionTypes(func_, checkMode)
			if !returnTypes {
				fallbackReturnType = neverType
			} else if returnTypes.length > 0 {
				returnType = getUnionType(returnTypes, UnionReductionSubtype)
			}
			TODO_IDENTIFIER := checkAndAggregateYieldOperandTypes(func_, checkMode)
			yieldType = /* TODO(ConditionalExpression): some(yieldTypes) ? getUnionType(yieldTypes, UnionReduction.Subtype) : undefined */ TODO
			nextType = /* TODO(ConditionalExpression): some(nextTypes) ? getIntersectionType(nextTypes) : undefined */ TODO
		} else {
			types := checkAndAggregateReturnExpressionTypes(func_, checkMode)
			if !types {
				return /* TODO(ConditionalExpression): functionFlags & FunctionFlags.Async                     ? createPromiseReturnType(func, neverType) // Async function                     : neverType */ TODO
			}
			if types.length == 0 {
				contextualReturnType := getContextualReturnType(func_, nil)
				returnType := /* TODO(ConditionalExpression): contextualReturnType && (unwrapReturnType(contextualReturnType, functionFlags) || voidType).flags & TypeFlags.Undefined ? undefinedType : voidType */ TODO
				return /* TODO(ConditionalExpression): functionFlags & FunctionFlags.Async ? createPromiseReturnType(func, returnType) : // Async function                     returnType */ TODO
			}
			returnType = getUnionType(types, UnionReductionSubtype)
		}
		if returnType || yieldType || nextType {
			if yieldType {
				reportErrorsFromWidening(func_, yieldType, WideningKindGeneratorYield)
			}
			if returnType {
				reportErrorsFromWidening(func_, returnType, WideningKindFunctionReturn)
			}
			if nextType {
				reportErrorsFromWidening(func_, nextType, WideningKindGeneratorNext)
			}
			if returnType && isUnitType(returnType) || yieldType && isUnitType(yieldType) || nextType && isUnitType(nextType) {
				contextualSignature := getContextualSignatureForFunctionLikeDeclaration(func_)
				contextualType := /* TODO(ConditionalExpression): !contextualSignature ? undefined :                     contextualSignature === getSignatureFromDeclaration(func) ? isGenerator ? undefined : returnType :                     instantiateContextualType(getReturnTypeOfSignature(contextualSignature), func, /*contextFlags* / undefined) */ TODO
				if isGenerator {
					yieldType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(yieldType, contextualType, IterationTypeKindYield, isAsync)
					returnType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(returnType, contextualType, IterationTypeKindReturn, isAsync)
					nextType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(nextType, contextualType, IterationTypeKindNext, isAsync)
				} else {
					returnType = getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(returnType, contextualType, isAsync)
				}
			}
			if yieldType {
				yieldType = getWidenedType(yieldType)
			}
			if returnType {
				returnType = getWidenedType(returnType)
			}
			if nextType {
				nextType = getWidenedType(nextType)
			}
		}
		if isGenerator {
			return createGeneratorType(yieldType || neverType, returnType || fallbackReturnType, nextType || getContextualIterationType(IterationTypeKindNext, func_) || unknownType, isAsync)
		} else {
			return /* TODO(ConditionalExpression): isAsync                 ? createPromiseType(returnType || fallbackReturnType)                 : returnType || fallbackReturnType */ TODO
		}
	}
	createGeneratorType := func(yieldType Type, returnType Type, nextType Type, isAsyncGenerator bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		resolver := /* TODO(ConditionalExpression): isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver */ TODO
		globalGeneratorType := resolver.getGlobalGeneratorType(false)
		yieldType = resolver.resolveIterationType(yieldType, nil) || unknownType
		returnType = resolver.resolveIterationType(returnType, nil) || unknownType
		if globalGeneratorType == emptyGenericType {
			globalIterableIteratorType := resolver.getGlobalIterableIteratorType(false)
			if globalIterableIteratorType != emptyGenericType {
				return createTypeFromGenericGlobalType(globalIterableIteratorType /* TODO(ArrayLiteralExpression): [yieldType, returnType, nextType] */, TODO)
			}
			resolver.getGlobalIterableIteratorType(true)
			return emptyObjectType
		}
		return createTypeFromGenericGlobalType(globalGeneratorType /* TODO(ArrayLiteralExpression): [yieldType, returnType, nextType] */, TODO)
	}
	checkAndAggregateYieldOperandTypes := func(func_ FunctionLikeDeclaration, checkMode *CheckMode) /* TODO inferred type { yieldTypes: import("/home/jabaile/work/TypeScript/src/compiler/types").Type[]; nextTypes: import("/home/jabaile/work/TypeScript/src/compiler/types").Type[]; } */ TODO {
		var yieldTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var nextTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		isAsync := (getFunctionFlags(func_) & FunctionFlagsAsync) != 0
		forEachYieldExpression(func_.body, func(yieldExpression /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").YieldExpression */ TODO) {
			yieldExpressionType := /* TODO(ConditionalExpression): yieldExpression.expression ? checkExpression(yieldExpression.expression, checkMode) : undefinedWideningType */ TODO
			pushIfUnique(yieldTypes, getYieldedTypeOfYieldExpression(yieldExpression, yieldExpressionType, anyType, isAsync))
			var nextType *Type
			if yieldExpression.asteriskToken {
				iterationTypes := getIterationTypesOfIterable(yieldExpressionType /* TODO(ConditionalExpression): isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar */, TODO, yieldExpression.expression)
				nextType = iterationTypes && iterationTypes.nextType
			} else {
				nextType = getContextualType(yieldExpression, nil)
			}
			if nextType {
				pushIfUnique(nextTypes, nextType)
			}
		})
		return /* TODO(ObjectLiteralExpression): { yieldTypes, nextTypes } */ TODO
	}
	getYieldedTypeOfYieldExpression := func(node YieldExpression, expressionType Type, sentType Type, isAsync bool) *Type {
		errorNode := node.expression || node
		yieldedType := /* TODO(ConditionalExpression): node.asteriskToken ? checkIteratedTypeOrElementType(isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar, expressionType, sentType, errorNode) : expressionType */ TODO
		return /* TODO(ConditionalExpression): !isAsync ? yieldedType : getAwaitedType(             yieldedType,             errorNode,             node.asteriskToken                 ? Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member                 : Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,         ) */ TODO
	}
	getNotEqualFactsFromTypeofSwitch := func(start number, end number, witnesses [] /* TODO(StringKeyword): string */ any) TypeFacts {
		var facts TypeFacts = TypeFactsNone
		/* TODO(ForStatement): for (let i = 0; i < witnesses.length; i++) {             const witness = i < start || i >= end ? witnesses[i] : undefined;             facts |= witness !== undefined ? typeofNEFacts.get(witness) || TypeFacts.TypeofNEHostObject : 0;         } */
		return facts
	}
	isExhaustiveSwitchStatement := func(node SwitchStatement) bool {
		links := getNodeLinks(node)
		if links.isExhaustive == nil {
			links.isExhaustive = 0
			exhaustive := computeExhaustiveSwitchStatement(node)
			if links.isExhaustive == 0 {
				links.isExhaustive = exhaustive
			}
		} else if links.isExhaustive == 0 {
			links.isExhaustive = false
		}
		return links.isExhaustive
	}
	computeExhaustiveSwitchStatement := func(node SwitchStatement) bool {
		if node.expression.kind == SyntaxKindTypeOfExpression {
			witnesses := getSwitchClauseTypeOfWitnesses(node)
			if !witnesses {
				return false
			}
			operandConstraint := getBaseConstraintOrType(checkExpressionCached((node.expression).expression))
			notEqualFacts := getNotEqualFactsFromTypeofSwitch(0, 0, witnesses)
			if operandConstraint.flags & TypeFlagsAnyOrUnknown {
				return (TypeFactsAllTypeofNE & notEqualFacts) == TypeFactsAllTypeofNE
			}
			return !someType(operandConstraint, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return getTypeFacts(t, notEqualFacts) == notEqualFacts
			})
		}
		type_ := checkExpressionCached(node.expression)
		if !isLiteralType(type_) {
			return false
		}
		switchTypes := getSwitchClauseTypes(node)
		if !switchTypes.length || some(switchTypes, isNeitherUnitTypeNorNever) {
			return false
		}
		return eachTypeContainedIn(mapType(type_, getRegularTypeOfLiteralType), switchTypes)
	}
	functionHasImplicitReturn := func(func_ FunctionLikeDeclaration) /* TODO inferred type boolean | undefined */ TODO {
		return func_.endFlowNode && isReachableFlowNode(func_.endFlowNode)
	}
	checkAndAggregateReturnExpressionTypes := func(func_ FunctionLikeDeclaration, checkMode *CheckMode) /* TODO(ArrayType): Type[] */ any {
		functionFlags := getFunctionFlags(func_)
		var aggregatedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		hasReturnWithNoExpression := functionHasImplicitReturn(func_)
		hasReturnOfTypeNever := false
		forEachReturnStatement(func_.body, func(returnStatement /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ReturnStatement */ TODO) {
			expr := returnStatement.expression
			if expr {
				expr = skipParentheses(expr, true)
				if functionFlags&FunctionFlagsAsync && expr.kind == SyntaxKindAwaitExpression {
					expr = skipParentheses((expr).expression, true)
				}
				if expr.kind == SyntaxKindCallExpression && (expr).expression.kind == SyntaxKindIdentifier && checkExpressionCached((expr).expression).symbol == getMergedSymbol(func_.symbol) && (!isFunctionExpressionOrArrowFunction(func_.symbol.valueDeclaration) || isConstantReference((expr).expression)) {
					hasReturnOfTypeNever = true
					return
				}
				type_ := checkExpressionCached(expr, checkMode && checkMode&~CheckModeSkipGenericFunctions)
				if functionFlags & FunctionFlagsAsync {
					type_ = unwrapAwaitedType(checkAwaitedType(type_, false, func_, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member))
				}
				if type_.flags & TypeFlagsNever {
					hasReturnOfTypeNever = true
				}
				pushIfUnique(aggregatedTypes, type_)
			} else {
				hasReturnWithNoExpression = true
			}
		})
		if aggregatedTypes.length == 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever || mayReturnNever(func_)) {
			return nil
		}
		if strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression && !(isJSConstructor(func_) && aggregatedTypes.some(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return t.symbol == func_.symbol
		})) {
			pushIfUnique(aggregatedTypes, undefinedType)
		}
		return aggregatedTypes
	}
	mayReturnNever := func(func_ FunctionLikeDeclaration) bool {
		switch func_.kind {
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			return true
		case SyntaxKindMethodDeclaration:
			return func_.parent.kind == SyntaxKindObjectLiteralExpression
		default:
			return false
		}
	}
	getTypePredicateFromBody := func(func_ FunctionLikeDeclaration) *TypePredicate {
		switch func_.kind {
		case SyntaxKindConstructor:
			fallthrough // TODO: merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			return nil
		}
		functionFlags := getFunctionFlags(func_)
		if functionFlags != FunctionFlagsNormal {
			return nil
		}
		var singleReturn *Expression
		if func_.body && func_.body.kind != SyntaxKindBlock {
			singleReturn = func_.body
		} else {
			bailedEarly := forEachReturnStatement(func_.body, func(returnStatement /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ReturnStatement */ TODO) /* TODO inferred type true | undefined */ TODO {
				if singleReturn || !returnStatement.expression {
					return true
				}
				singleReturn = returnStatement.expression
			})
			if bailedEarly || !singleReturn || functionHasImplicitReturn(func_) {
				return nil
			}
		}
		return checkIfExpressionRefinesAnyParameter(func_, singleReturn)
	}
	checkIfExpressionRefinesAnyParameter := func(func_ FunctionLikeDeclaration, expr Expression) *TypePredicate {
		expr = skipParentheses(expr, true)
		returnType := checkExpressionCached(expr)
		if !(returnType.flags & TypeFlagsBoolean) {
			return nil
		}
		return forEach(func_.parameters, func(param /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO, i /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypePredicate | undefined */ TODO {
			initType := getTypeOfSymbol(param.symbol)
			if !initType || initType.flags&TypeFlagsBoolean || !isIdentifier(param.name) || isSymbolAssigned(param.symbol) || isRestParameter(param) {
				return
			}
			trueType := checkIfExpressionRefinesParameter(func_, expr, param, initType)
			if trueType {
				return createTypePredicate(TypePredicateKindIdentifier, unescapeLeadingUnderscores(param.name.escapedText), i, trueType)
			}
		})
	}
	checkIfExpressionRefinesParameter := func(func_ FunctionLikeDeclaration, expr Expression, param ParameterDeclaration, initType Type) *Type {
		antecedent := (expr).flowNode || expr.parent.kind == SyntaxKindReturnStatement && (expr.parent).flowNode || createFlowNode(FlowFlagsStart, nil, nil)
		trueCondition := createFlowNode(FlowFlagsTrueCondition, expr, antecedent)
		trueType := getFlowTypeOfReference(param.name, initType, initType, func_, trueCondition)
		if trueType == initType {
			return nil
		}
		falseCondition := createFlowNode(FlowFlagsFalseCondition, expr, antecedent)
		falseSubtype := getFlowTypeOfReference(param.name, initType, trueType, func_, falseCondition)
		return /* TODO(ConditionalExpression): falseSubtype.flags & TypeFlags.Never ? trueType : undefined */ TODO
	}
	checkAllCodePathsInNonVoidFunctionReturnOrThrow := func(func_ /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any, returnType *Type) {
		addLazyDiagnostic(checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics)
		return
		checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics := func() {
			functionFlags := getFunctionFlags(func_)
			type_ := returnType && unwrapReturnType(returnType, functionFlags)
			if type_ && (maybeTypeOfKind(type_, TypeFlagsVoid) || type_.flags&(TypeFlagsAny|TypeFlagsUndefined)) {
				return
			}
			if func_.kind == SyntaxKindMethodSignature || nodeIsMissing(func_.body) || func_.body.kind != SyntaxKindBlock || !functionHasImplicitReturn(func_) {
				return
			}
			hasExplicitReturn := func_.flags & NodeFlagsHasExplicitReturn
			errorNode := getEffectiveReturnTypeNode(func_) || func_
			if type_ && type_.flags&TypeFlagsNever {
				error(errorNode, Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point)
			} else if type_ && !hasExplicitReturn {
				error(errorNode, Diagnostics.A_function_whose_declared_type_is_neither_undefined_void_nor_any_must_return_a_value)
			} else if type_ && strictNullChecks && !isTypeAssignableTo(undefinedType, type_) {
				error(errorNode, Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined)
			} else if compilerOptions.noImplicitReturns {
				if !type_ {
					if !hasExplicitReturn {
						return
					}
					inferredReturnType := getReturnTypeOfSignature(getSignatureFromDeclaration(func_))
					if isUnwrappedReturnTypeUndefinedVoidOrAny(func_, inferredReturnType) {
						return
					}
				}
				error(errorNode, Diagnostics.Not_all_code_paths_return_a_value)
			}
		}
	}
	checkFunctionExpressionOrObjectLiteralMethod := func(node /* TODO(UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) Type {
		Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
		checkNodeDeferred(node)
		if isFunctionExpression(node) {
			checkCollisionsForDeclarationName(node, node.name)
		}
		if checkMode && checkMode&CheckModeSkipContextSensitive && isContextSensitive(node) {
			if !getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(node) {
				contextualSignature := getContextualSignature(node)
				if contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature)) {
					links := getNodeLinks(node)
					if links.contextFreeType {
						return links.contextFreeType
					}
					returnType := getReturnTypeFromBody(node, checkMode)
					returnOnlySignature := createSignature(nil, nil, nil, emptyArray, returnType, nil, 0, SignatureFlagsIsNonInferrable)
					returnOnlyType := createAnonymousType(node.symbol, emptySymbols /* TODO(ArrayLiteralExpression): [returnOnlySignature] */, TODO, emptyArray, emptyArray)
					returnOnlyType.objectFlags |= ObjectFlagsNonInferrableType
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.contextFreeType = returnOnlyType */ TODO
				}
			}
			return anyFunctionType
		}
		hasGrammarError := checkGrammarFunctionLikeDeclaration(node)
		if !hasGrammarError && node.kind == SyntaxKindFunctionExpression {
			checkGrammarForGenerator(node)
		}
		contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode)
		return getTypeOfSymbol(getSymbolOfDeclaration(node))
	}
	contextuallyCheckFunctionExpressionOrObjectLiteralMethod := func(node /* TODO(UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) {
		links := getNodeLinks(node)
		if !(links.flags & NodeCheckFlagsContextChecked) {
			contextualSignature := getContextualSignature(node)
			if !(links.flags & NodeCheckFlagsContextChecked) {
				links.flags |= NodeCheckFlagsContextChecked
				signature := firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node)), SignatureKindCall))
				if !signature {
					return
				}
				if isContextSensitive(node) {
					if contextualSignature {
						inferenceContext := getInferenceContext(node)
						var instantiatedContextualSignature *Signature
						if checkMode && checkMode&CheckModeInferential {
							inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext)
							restType := getEffectiveRestType(contextualSignature)
							if restType && restType.flags&TypeFlagsTypeParameter {
								instantiatedContextualSignature = instantiateSignature(contextualSignature, inferenceContext.nonFixingMapper)
							}
						}
						/* TODO(ExpressionStatement): instantiatedContextualSignature ||= inferenceContext ?                             instantiateSignature(contextualSignature, inferenceContext.mapper) : contextualSignature; */
						assignContextualParameterTypes(signature, instantiatedContextualSignature)
					} else {
						assignNonContextualParameterTypes(signature)
					}
				} else if contextualSignature && !node.typeParameters && contextualSignature.parameters.length > node.parameters.length {
					inferenceContext := getInferenceContext(node)
					if checkMode && checkMode&CheckModeInferential {
						inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext)
					}
				}
				if contextualSignature && !getReturnTypeFromAnnotation(node) && !signature.resolvedReturnType {
					returnType := getReturnTypeFromBody(node, checkMode)
					if !signature.resolvedReturnType {
						signature.resolvedReturnType = returnType
					}
				}
				checkSignatureDeclaration(node)
			}
		}
	}
	checkFunctionExpressionOrObjectLiteralMethodDeferred := func(node /* TODO(UnionType): ArrowFunction | FunctionExpression | MethodDeclaration */ any) {
		Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
		functionFlags := getFunctionFlags(node)
		returnType := getReturnTypeFromAnnotation(node)
		checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType)
		if node.body {
			if !getEffectiveReturnTypeNode(node) {
				getReturnTypeOfSignature(getSignatureFromDeclaration(node))
			}
			if node.body.kind == SyntaxKindBlock {
				checkSourceElement(node.body)
			} else {
				exprType := checkExpression(node.body)
				returnOrPromisedType := returnType && unwrapReturnType(returnType, functionFlags)
				if returnOrPromisedType {
					effectiveCheckNode := getEffectiveCheckNode(node.body)
					if (functionFlags & FunctionFlagsAsyncGenerator) == FunctionFlagsAsync {
						awaitedType := checkAwaitedType(exprType, false, effectiveCheckNode, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
						checkTypeAssignableToAndOptionallyElaborate(awaitedType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode)
					} else {
						checkTypeAssignableToAndOptionallyElaborate(exprType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode)
					}
				}
			}
		}
	}
	checkArithmeticOperandType := func(operand Node, type_ Type, diagnostic DiagnosticMessage, isAwaitValid /* TODO inferred type boolean */ TODO /*  = false */) bool {
		if !isTypeAssignableTo(type_, numberOrBigIntType) {
			awaitedType := isAwaitValid && getAwaitedTypeOfPromise(type_)
			errorAndMaybeSuggestAwait(operand, !!awaitedType && isTypeAssignableTo(awaitedType, numberOrBigIntType), diagnostic)
			return false
		}
		return true
	}
	isReadonlyAssignmentDeclaration := func(d Declaration) /* TODO inferred type boolean */ TODO {
		if !isCallExpression(d) {
			return false
		}
		if !isBindableObjectDefinePropertyCall(d) {
			return false
		}
		objectLitType := checkExpressionCached( /* TODO(ElementAccessExpression): d.arguments[2] */ TODO)
		valueType := getTypeOfPropertyOfType(objectLitType, "value")
		if valueType {
			writableProp := getPropertyOfType(objectLitType, "writable")
			writableType := writableProp && getTypeOfSymbol(writableProp)
			if !writableType || writableType == falseType || writableType == regularFalseType {
				return true
			}
			if writableProp && writableProp.valueDeclaration && isPropertyAssignment(writableProp.valueDeclaration) {
				initializer := writableProp.valueDeclaration.initializer
				rawOriginalType := checkExpression(initializer)
				if rawOriginalType == falseType || rawOriginalType == regularFalseType {
					return true
				}
			}
			return false
		}
		setProp := getPropertyOfType(objectLitType, "set")
		return !setProp
	}
	isReadonlySymbol := func(symbol Symbol) bool {
		return !!(getCheckFlags(symbol)&CheckFlagsReadonly || symbol.flags&SymbolFlagsProperty && getDeclarationModifierFlagsFromSymbol(symbol)&ModifierFlagsReadonly || symbol.flags&SymbolFlagsVariable && getDeclarationNodeFlagsFromSymbol(symbol)&NodeFlagsConstant || symbol.flags&SymbolFlagsAccessor && !(symbol.flags&SymbolFlagsSetAccessor) || symbol.flags&SymbolFlagsEnumMember || some(symbol.declarations, isReadonlyAssignmentDeclaration))
	}
	isAssignmentToReadonlyEntity := func(expr Expression, symbol Symbol, assignmentKind AssignmentKind) /* TODO inferred type boolean */ TODO {
		if assignmentKind == AssignmentKindNone {
			return false
		}
		if isReadonlySymbol(symbol) {
			if symbol.flags&SymbolFlagsProperty && isAccessExpression(expr) && expr.expression.kind == SyntaxKindThisKeyword {
				ctor := getContainingFunction(expr)
				if !(ctor && (ctor.kind == SyntaxKindConstructor || isJSConstructor(ctor))) {
					return true
				}
				if symbol.valueDeclaration {
					isAssignmentDeclaration := isBinaryExpression(symbol.valueDeclaration)
					isLocalPropertyDeclaration := ctor.parent == symbol.valueDeclaration.parent
					isLocalParameterProperty := ctor == symbol.valueDeclaration.parent
					isLocalThisPropertyAssignment := isAssignmentDeclaration && symbol.parent.valueDeclaration == ctor.parent
					isLocalThisPropertyAssignmentConstructorFunction := isAssignmentDeclaration && symbol.parent.valueDeclaration == ctor
					isWriteableSymbol := isLocalPropertyDeclaration || isLocalParameterProperty || isLocalThisPropertyAssignment || isLocalThisPropertyAssignmentConstructorFunction
					return !isWriteableSymbol
				}
			}
			return true
		}
		if isAccessExpression(expr) {
			node := skipParentheses(expr.expression)
			if node.kind == SyntaxKindIdentifier {
				symbol := getNodeLinks(node).resolvedSymbol
				if symbol.flags & SymbolFlagsAlias {
					declaration := getDeclarationOfAliasSymbol(symbol)
					return !!declaration && declaration.kind == SyntaxKindNamespaceImport
				}
			}
		}
		return false
	}
	checkReferenceExpression := func(expr Expression, invalidReferenceMessage DiagnosticMessage, invalidOptionalChainMessage DiagnosticMessage) bool {
		node := skipOuterExpressions(expr, OuterExpressionKindsAssertions|OuterExpressionKindsParentheses)
		if node.kind != SyntaxKindIdentifier && !isAccessExpression(node) {
			error(expr, invalidReferenceMessage)
			return false
		}
		if node.flags & NodeFlagsOptionalChain {
			error(expr, invalidOptionalChainMessage)
			return false
		}
		return true
	}
	checkDeleteExpression := func(node DeleteExpression) Type {
		checkExpression(node.expression)
		expr := skipParentheses(node.expression)
		if !isAccessExpression(expr) {
			error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference)
			return booleanType
		}
		if isPropertyAccessExpression(expr) && isPrivateIdentifier(expr.name) {
			error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_private_identifier)
		}
		links := getNodeLinks(expr)
		symbol := getExportSymbolOfValueSymbolIfExported(links.resolvedSymbol)
		if symbol {
			if isReadonlySymbol(symbol) {
				error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property)
			} else {
				checkDeleteExpressionMustBeOptional(expr, symbol)
			}
		}
		return booleanType
	}
	checkDeleteExpressionMustBeOptional := func(expr AccessExpression, symbol Symbol) {
		type_ := getTypeOfSymbol(symbol)
		if strictNullChecks && !(type_.flags & (TypeFlagsAnyOrUnknown | TypeFlagsNever)) && !( /* TODO(ConditionalExpression): exactOptionalPropertyTypes ? symbol.flags & SymbolFlags.Optional : hasTypeFacts(type, TypeFacts.IsUndefined) */ TODO) {
			error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_optional)
		}
	}
	checkTypeOfExpression := func(node TypeOfExpression) Type {
		checkExpression(node.expression)
		return typeofType
	}
	checkVoidExpression := func(node VoidExpression) Type {
		checkNodeDeferred(node)
		return undefinedWideningType
	}
	checkAwaitGrammar := func(node /* TODO(UnionType): AwaitExpression | VariableDeclarationList */ any) bool {
		hasError := false
		container := getContainingFunctionOrClassStaticBlock(node)
		if container && isClassStaticBlockDeclaration(container) {
			message := /* TODO(ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expression_cannot_be_used_inside_a_class_static_block :                 Diagnostics.await_using_statements_cannot_be_used_inside_a_class_static_block */ TODO
			error(node, message)
			hasError = true
		} else if !(node.flags & NodeFlagsAwaitContext) {
			if isInTopLevelContext(node) {
				sourceFile := getSourceFileOfNode(node)
				if !hasParseDiagnostics(sourceFile) {
					var span *TextSpan
					if !isEffectiveExternalModule(sourceFile, compilerOptions) {
						/* TODO(ExpressionStatement): span ??= getSpanOfTokenAtPosition(sourceFile, node.pos); */
						message := /* TODO(ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module :                             Diagnostics.await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module */ TODO
						diagnostic := createFileDiagnostic(sourceFile, span.start, span.length, message)
						diagnostics.add(diagnostic)
						hasError = true
					}
					switch moduleKind {
					case ModuleKindNode16:
						fallthrough // TODO: merge cases
					case ModuleKindNodeNext:
						if sourceFile.impliedNodeFormat == ModuleKindCommonJS {
							/* TODO(ExpressionStatement): span ??= getSpanOfTokenAtPosition(sourceFile, node.pos); */
							diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level))
							hasError = true
							break
						}
						fallthrough
					case ModuleKindES2022:
						fallthrough // TODO: merge cases
					case ModuleKindESNext:
						fallthrough // TODO: merge cases
					case ModuleKindPreserve:
						fallthrough // TODO: merge cases
					case ModuleKindSystem:
						if languageVersion >= ScriptTargetES2017 {
							break
						}
						fallthrough
					default:
						/* TODO(ExpressionStatement): span ??= getSpanOfTokenAtPosition(sourceFile, node.pos); */
						message := /* TODO(ConditionalExpression): isAwaitExpression(node) ? Diagnostics.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher :                                 Diagnostics.Top_level_await_using_statements_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher */ TODO
						diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message))
						hasError = true
						break
					}
				}
			} else {
				sourceFile := getSourceFileOfNode(node)
				if !hasParseDiagnostics(sourceFile) {
					span := getSpanOfTokenAtPosition(sourceFile, node.pos)
					message := /* TODO(ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules :                         Diagnostics.await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules */ TODO
					diagnostic := createFileDiagnostic(sourceFile, span.start, span.length, message)
					if container && container.kind != SyntaxKindConstructor && (getFunctionFlags(container)&FunctionFlagsAsync) == 0 {
						relatedInfo := createDiagnosticForNode(container, Diagnostics.Did_you_mean_to_mark_this_function_as_async)
						addRelatedInfo(diagnostic, relatedInfo)
					}
					diagnostics.add(diagnostic)
					hasError = true
				}
			}
		}
		if isAwaitExpression(node) && isInParameterInitializerBeforeContainingFunction(node) {
			error(node, Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer)
			hasError = true
		}
		return hasError
	}
	checkAwaitExpression := func(node AwaitExpression) Type {
		addLazyDiagnostic(func() /* TODO inferred type boolean */ TODO {
			return checkAwaitGrammar(node)
		})
		operandType := checkExpression(node.expression)
		awaitedType := checkAwaitedType(operandType, true, node, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
		if awaitedType == operandType && !isErrorType(awaitedType) && !(operandType.flags & TypeFlagsAnyOrUnknown) {
			addErrorOrSuggestion(false, createDiagnosticForNode(node, Diagnostics.await_has_no_effect_on_the_type_of_this_expression))
		}
		return awaitedType
	}
	checkPrefixUnaryExpression := func(node PrefixUnaryExpression) Type {
		operandType := checkExpression(node.operand)
		if operandType == silentNeverType {
			return silentNeverType
		}
		switch node.operand.kind {
		case SyntaxKindNumericLiteral:
			switch node.operator {
			case SyntaxKindMinusToken:
				return getFreshTypeOfLiteralType(getNumberLiteralType(-(node.operand).text))
			case SyntaxKindPlusToken:
				return getFreshTypeOfLiteralType(getNumberLiteralType(+(node.operand).text))
			}
			break
		case SyntaxKindBigIntLiteral:
			if node.operator == SyntaxKindMinusToken {
				return getFreshTypeOfLiteralType(getBigIntLiteralType( /* TODO(ObjectLiteralExpression): {                         negative: true,                         base10Value: parsePseudoBigInt((node.operand as BigIntLiteral).text),                     } */ TODO))
			}
		}
		switch node.operator {
		case SyntaxKindPlusToken:
			fallthrough // TODO: merge cases
		case SyntaxKindMinusToken:
			fallthrough // TODO: merge cases
		case SyntaxKindTildeToken:
			checkNonNullType(operandType, node.operand)
			if maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlagsESSymbolLike) {
				error(node.operand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(node.operator))
			}
			if node.operator == SyntaxKindPlusToken {
				if maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlagsBigIntLike) {
					error(node.operand, Diagnostics.Operator_0_cannot_be_applied_to_type_1, tokenToString(node.operator), typeToString(getBaseTypeOfLiteralType(operandType)))
				}
				return numberType
			}
			return getUnaryResultType(operandType)
		case SyntaxKindExclamationToken:
			checkTruthinessOfType(operandType, node.operand)
			facts := getTypeFacts(operandType, TypeFactsTruthy|TypeFactsFalsy)
			return /* TODO(ConditionalExpression): facts === TypeFacts.Truthy ? falseType :                     facts === TypeFacts.Falsy ? trueType :                     booleanType */ TODO
		case SyntaxKindPlusPlusToken:
			fallthrough // TODO: merge cases
		case SyntaxKindMinusMinusToken:
			ok := checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type)
			if ok {
				checkReferenceExpression(node.operand, Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access)
			}
			return getUnaryResultType(operandType)
		}
		return errorType
	}
	checkPostfixUnaryExpression := func(node PostfixUnaryExpression) Type {
		operandType := checkExpression(node.operand)
		if operandType == silentNeverType {
			return silentNeverType
		}
		ok := checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type)
		if ok {
			checkReferenceExpression(node.operand, Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access)
		}
		return getUnaryResultType(operandType)
	}
	getUnaryResultType := func(operandType Type) Type {
		if maybeTypeOfKind(operandType, TypeFlagsBigIntLike) {
			return /* TODO(ConditionalExpression): isTypeAssignableToKind(operandType, TypeFlags.AnyOrUnknown) || maybeTypeOfKind(operandType, TypeFlags.NumberLike)                 ? numberOrBigIntType                 : bigintType */ TODO
		}
		return numberType
	}
	maybeTypeOfKindConsideringBaseConstraint := func(type_ Type, kind TypeFlags) bool {
		if maybeTypeOfKind(type_, kind) {
			return true
		}
		baseConstraint := getBaseConstraintOrType(type_)
		return !!baseConstraint && maybeTypeOfKind(baseConstraint, kind)
	}
	maybeTypeOfKind := func(type_ Type, kind TypeFlags) bool {
		if type_.flags & kind {
			return true
		}
		if type_.flags & TypeFlagsUnionOrIntersection {
			types := (type_).types
			for _, t := range types {
				if maybeTypeOfKind(t, kind) {
					return true
				}
			}
		}
		return false
	}
	isTypeAssignableToKind := func(source Type, kind TypeFlags, strict bool) bool {
		if source.flags & kind {
			return true
		}
		if strict && source.flags&(TypeFlagsAnyOrUnknown|TypeFlagsVoid|TypeFlagsUndefined|TypeFlagsNull) {
			return false
		}
		return !!(kind&TypeFlagsNumberLike) && isTypeAssignableTo(source, numberType) || !!(kind&TypeFlagsBigIntLike) && isTypeAssignableTo(source, bigintType) || !!(kind&TypeFlagsStringLike) && isTypeAssignableTo(source, stringType) || !!(kind&TypeFlagsBooleanLike) && isTypeAssignableTo(source, booleanType) || !!(kind&TypeFlagsVoid) && isTypeAssignableTo(source, voidType) || !!(kind&TypeFlagsNever) && isTypeAssignableTo(source, neverType) || !!(kind&TypeFlagsNull) && isTypeAssignableTo(source, nullType) || !!(kind&TypeFlagsUndefined) && isTypeAssignableTo(source, undefinedType) || !!(kind&TypeFlagsESSymbol) && isTypeAssignableTo(source, esSymbolType) || !!(kind&TypeFlagsNonPrimitive) && isTypeAssignableTo(source, nonPrimitiveType)
	}
	allTypesAssignableToKind := func(source Type, kind TypeFlags, strict bool) bool {
		return /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ?             every((source as UnionType).types, subType => allTypesAssignableToKind(subType, kind, strict)) :             isTypeAssignableToKind(source, kind, strict) */ TODO
	}
	isConstEnumObjectType := func(type_ Type) bool {
		return !!(getObjectFlags(type_) & ObjectFlagsAnonymous) && !!type_.symbol && isConstEnumSymbol(type_.symbol)
	}
	isConstEnumSymbol := func(symbol Symbol) bool {
		return (symbol.flags & SymbolFlagsConstEnum) != 0
	}
	getSymbolHasInstanceMethodOfObjectType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		hasInstancePropertyName := getPropertyNameForKnownSymbolName("hasInstance")
		if allTypesAssignableToKind(type_, TypeFlagsNonPrimitive) {
			hasInstanceProperty := getPropertyOfType(type_, hasInstancePropertyName)
			if hasInstanceProperty {
				hasInstancePropertyType := getTypeOfSymbol(hasInstanceProperty)
				if hasInstancePropertyType && getSignaturesOfType(hasInstancePropertyType, SignatureKindCall).length != 0 {
					return hasInstancePropertyType
				}
			}
		}
	}
	checkInstanceOfExpression := func(left Expression, right Expression, leftType Type, rightType Type, checkMode CheckMode) Type {
		if leftType == silentNeverType || rightType == silentNeverType {
			return silentNeverType
		}
		if !isTypeAny(leftType) && allTypesAssignableToKind(leftType, TypeFlagsPrimitive) {
			error(left, Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter)
		}
		Debug.assert(isInstanceOfExpression(left.parent))
		signature := getResolvedSignature(left.parent, nil, checkMode)
		if signature == resolvingSignature {
			return silentNeverType
		}
		returnType := getReturnTypeOfSignature(signature)
		checkTypeAssignableTo(returnType, booleanType, right, Diagnostics.An_object_s_Symbol_hasInstance_method_must_return_a_boolean_value_for_it_to_be_used_on_the_right_hand_side_of_an_instanceof_expression)
		return booleanType
	}
	hasEmptyObjectIntersection := func(type_ Type) bool {
		return someType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return t == unknownEmptyObjectType || !!(t.flags&TypeFlagsIntersection) && isEmptyAnonymousObjectType(getBaseConstraintOrType(t))
		})
	}
	checkInExpression := func(left Expression, right Expression, leftType Type, rightType Type) Type {
		if leftType == silentNeverType || rightType == silentNeverType {
			return silentNeverType
		}
		if isPrivateIdentifier(left) {
			if languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !useDefineForClassFields {
				checkExternalEmitHelpers(left, ExternalEmitHelpersClassPrivateFieldIn)
			}
			if !getNodeLinks(left).resolvedSymbol && getContainingClass(left) {
				isUncheckedJS := isUncheckedJSSuggestion(left, rightType.symbol, true)
				reportNonexistentProperty(left, rightType, isUncheckedJS)
			}
		} else {
			checkTypeAssignableTo(checkNonNullType(leftType, left), stringNumberSymbolType, left)
		}
		if checkTypeAssignableTo(checkNonNullType(rightType, right), nonPrimitiveType, right) {
			if hasEmptyObjectIntersection(rightType) {
				error(right, Diagnostics.Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator, typeToString(rightType))
			}
		}
		return booleanType
	}
	checkObjectLiteralAssignment := func(node ObjectLiteralExpression, sourceType Type, rightIsThis bool) Type {
		properties := node.properties
		if strictNullChecks && properties.length == 0 {
			return checkNonNullType(sourceType, node)
		}
		/* TODO(ForStatement): for (let i = 0; i < properties.length; i++) {             checkObjectLiteralDestructuringPropertyAssignment(node, sourceType, i, properties, rightIsThis);         } */
		return sourceType
	}
	checkObjectLiteralDestructuringPropertyAssignment := func(node ObjectLiteralExpression, objectLiteralType Type, propertyIndex number, allProperties NodeArray[ObjectLiteralElementLike], rightIsThis /* TODO inferred type boolean */ TODO /*  = false */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		properties := node.properties
		property := /* TODO(ElementAccessExpression): properties[propertyIndex] */ TODO
		if property.kind == SyntaxKindPropertyAssignment || property.kind == SyntaxKindShorthandPropertyAssignment {
			name := property.name
			exprType := getLiteralTypeFromPropertyName(name)
			if isTypeUsableAsPropertyName(exprType) {
				text := getPropertyNameFromType(exprType)
				prop := getPropertyOfType(objectLiteralType, text)
				if prop {
					markPropertyAsReferenced(prop, property, rightIsThis)
					checkPropertyAccessibility(property, false, true, objectLiteralType, prop)
				}
			}
			elementType := getIndexedAccessType(objectLiteralType, exprType, AccessFlagsExpressionPosition|( /* TODO(ConditionalExpression): hasDefaultValue(property) ? AccessFlags.AllowMissing : 0 */ TODO), name)
			type_ := getFlowTypeOfDestructuring(property, elementType)
			return checkDestructuringAssignment( /* TODO(ConditionalExpression): property.kind === SyntaxKind.ShorthandPropertyAssignment ? property : property.initializer */ TODO, type_)
		} else if property.kind == SyntaxKindSpreadAssignment {
			if propertyIndex < /* TODO(MinusToken): - */ /* TODO(BinaryExpression): properties.length - 1 */ TODO {
				error(property, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
			} else {
				if languageVersion < LanguageFeatureMinimumTargetObjectSpreadRest {
					checkExternalEmitHelpers(property, ExternalEmitHelpersRest)
				}
				var nonRestNames []PropertyName = /* TODO(ArrayLiteralExpression): [] */ TODO
				if allProperties {
					for _, otherProperty := range allProperties {
						if !isSpreadAssignment(otherProperty) {
							nonRestNames.push(otherProperty.name)
						}
					}
				}
				type_ := getRestType(objectLiteralType, nonRestNames, objectLiteralType.symbol)
				checkGrammarForDisallowedTrailingComma(allProperties, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
				return checkDestructuringAssignment(property.expression, type_)
			}
		} else {
			error(property, Diagnostics.Property_assignment_expected)
		}
	}
	checkArrayLiteralAssignment := func(node ArrayLiteralExpression, sourceType Type, checkMode CheckMode) Type {
		elements := node.elements
		if languageVersion < LanguageFeatureMinimumTargetDestructuringAssignment && compilerOptions.downlevelIteration {
			checkExternalEmitHelpers(node, ExternalEmitHelpersRead)
		}
		possiblyOutOfBoundsType := checkIteratedTypeOrElementType(IterationUseDestructuring|IterationUsePossiblyOutOfBounds, sourceType, undefinedType, node) || errorType
		var inBoundsType *Type = /* TODO(ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ? undefined : possiblyOutOfBoundsType */ TODO
		/* TODO(ForStatement): for (let i = 0; i < elements.length; i++) {             let type = possiblyOutOfBoundsType;             if (node.elements[i].kind === SyntaxKind.SpreadElement) {                 type = inBoundsType = inBoundsType ?? (checkIteratedTypeOrElementType(IterationUse.Destructuring, sourceType, undefinedType, node) || errorType);             }             checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, type, checkMode);         } */
		return sourceType
	}
	checkArrayLiteralDestructuringElementAssignment := func(node ArrayLiteralExpression, sourceType Type, elementIndex number, elementType Type, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		elements := node.elements
		element := /* TODO(ElementAccessExpression): elements[elementIndex] */ TODO
		if element.kind != SyntaxKindOmittedExpression {
			if element.kind != SyntaxKindSpreadElement {
				indexType := getNumberLiteralType(elementIndex)
				if isArrayLikeType(sourceType) {
					accessFlags := AccessFlagsExpressionPosition | ( /* TODO(ConditionalExpression): hasDefaultValue(element) ? AccessFlags.AllowMissing : 0 */ TODO)
					elementType := getIndexedAccessTypeOrUndefined(sourceType, indexType, accessFlags, createSyntheticExpression(element, indexType)) || errorType
					assignedType := /* TODO(ConditionalExpression): hasDefaultValue(element) ? getTypeWithFacts(elementType, TypeFacts.NEUndefined) : elementType */ TODO
					type_ := getFlowTypeOfDestructuring(element, assignedType)
					return checkDestructuringAssignment(element, type_, checkMode)
				}
				return checkDestructuringAssignment(element, elementType, checkMode)
			}
			if elementIndex < /* TODO(MinusToken): - */ /* TODO(BinaryExpression): elements.length - 1 */ TODO {
				error(element, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
			} else {
				restExpression := (element).expression
				if restExpression.kind == SyntaxKindBinaryExpression && (restExpression).operatorToken.kind == SyntaxKindEqualsToken {
					error((restExpression).operatorToken, Diagnostics.A_rest_element_cannot_have_an_initializer)
				} else {
					checkGrammarForDisallowedTrailingComma(node.elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
					type_ := /* TODO(ConditionalExpression): everyType(sourceType, isTupleType) ?                         mapType(sourceType, t => sliceTupleType(t as TupleTypeReference, elementIndex)) :                         createArrayType(elementType) */ TODO
					return checkDestructuringAssignment(restExpression, type_, checkMode)
				}
			}
		}
		return nil
	}
	checkDestructuringAssignment := func(exprOrAssignment /* TODO(UnionType): Expression | ShorthandPropertyAssignment */ any, sourceType Type, checkMode CheckMode, rightIsThis bool) Type {
		var target Expression
		if exprOrAssignment.kind == SyntaxKindShorthandPropertyAssignment {
			prop := exprOrAssignment
			if prop.objectAssignmentInitializer {
				if strictNullChecks && !(hasTypeFacts(checkExpression(prop.objectAssignmentInitializer), TypeFactsIsUndefined)) {
					sourceType = getTypeWithFacts(sourceType, TypeFactsNEUndefined)
				}
				checkBinaryLikeExpression(prop.name, prop.equalsToken, prop.objectAssignmentInitializer, checkMode)
			}
			target = (exprOrAssignment).name
		} else {
			target = exprOrAssignment
		}
		if target.kind == SyntaxKindBinaryExpression && (target).operatorToken.kind == SyntaxKindEqualsToken {
			checkBinaryExpression(target, checkMode)
			target = (target).left
			if strictNullChecks {
				sourceType = getTypeWithFacts(sourceType, TypeFactsNEUndefined)
			}
		}
		if target.kind == SyntaxKindObjectLiteralExpression {
			return checkObjectLiteralAssignment(target, sourceType, rightIsThis)
		}
		if target.kind == SyntaxKindArrayLiteralExpression {
			return checkArrayLiteralAssignment(target, sourceType, checkMode)
		}
		return checkReferenceAssignment(target, sourceType, checkMode)
	}
	checkReferenceAssignment := func(target Expression, sourceType Type, checkMode CheckMode) Type {
		targetType := checkExpression(target, checkMode)
		error := /* TODO(ConditionalExpression): target.parent.kind === SyntaxKind.SpreadAssignment ?             Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access :             Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access */ TODO
		optionalError := /* TODO(ConditionalExpression): target.parent.kind === SyntaxKind.SpreadAssignment ?             Diagnostics.The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access :             Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access */ TODO
		if checkReferenceExpression(target, error, optionalError) {
			checkTypeAssignableToAndOptionallyElaborate(sourceType, targetType, target, target)
		}
		if isPrivateIdentifierPropertyAccessExpression(target) {
			checkExternalEmitHelpers(target.parent, ExternalEmitHelpersClassPrivateFieldSet)
		}
		return sourceType
	}
	isSideEffectFree := func(node Node) bool {
		node = skipParentheses(node)
		switch node.kind {
		case SyntaxKindIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindStringLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindRegularExpressionLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindTaggedTemplateExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTemplateExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindNumericLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindBigIntLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindTrueKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindFalseKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindNullKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindUndefinedKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindClassExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindArrayLiteralExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindObjectLiteralExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeOfExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNonNullExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSelfClosingElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxElement:
			return true
		case SyntaxKindConditionalExpression:
			return isSideEffectFree((node).whenTrue) && isSideEffectFree((node).whenFalse)
		case SyntaxKindBinaryExpression:
			if isAssignmentOperator((node).operatorToken.kind) {
				return false
			}
			return isSideEffectFree((node).left) && isSideEffectFree((node).right)
		case SyntaxKindPrefixUnaryExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindPostfixUnaryExpression:
			switch (node).operator {
			case SyntaxKindExclamationToken:
				fallthrough // TODO: merge cases
			case SyntaxKindPlusToken:
				fallthrough // TODO: merge cases
			case SyntaxKindMinusToken:
				fallthrough // TODO: merge cases
			case SyntaxKindTildeToken:
				return true
			}
			return false
		case SyntaxKindVoidExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeAssertionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindAsExpression:
			fallthrough // TODO: merge cases
		default:
			return false
		}
	}
	isTypeEqualityComparableTo := func(source Type, target Type) /* TODO inferred type boolean */ TODO {
		return (target.flags&TypeFlagsNullable) != 0 || isTypeComparableTo(source, target)
	}
	createCheckBinaryExpression := func() /* TODO inferred type (node: import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression, checkMode: import("/home/jabaile/work/TypeScript/src/compiler/checker").CheckMode | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		type WorkArea struct {
			checkMode  *CheckMode
			skip       bool
			stackIndex number
			typeStack  []*Type
		}
		trampoline := createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState)
		return func(node BinaryExpression, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			result := trampoline(node, checkMode)
			Debug.assertIsDefined(result)
			return result
		}
		onEnter := func(node BinaryExpression, state *WorkArea, checkMode *CheckMode) /* TODO inferred type WorkArea */ TODO {
			if state {
				state.stackIndex++
				state.skip = false
				setLeftType(state, nil)
				setLastResult(state, nil)
			} else {
				state = /* TODO(ObjectLiteralExpression): {                     checkMode,                     skip: false,                     stackIndex: 0,                     typeStack: [undefined, undefined],                 } */ TODO
			}
			if isInJSFile(node) && getAssignedExpandoInitializer(node) {
				state.skip = true
				setLastResult(state, checkExpression(node.right, checkMode))
				return state
			}
			checkNullishCoalesceOperands(node)
			operator := node.operatorToken.kind
			if operator == SyntaxKindEqualsToken && (node.left.kind == SyntaxKindObjectLiteralExpression || node.left.kind == SyntaxKindArrayLiteralExpression) {
				state.skip = true
				setLastResult(state, checkDestructuringAssignment(node.left, checkExpression(node.right, checkMode), checkMode, node.right.kind == SyntaxKindThisKeyword))
				return state
			}
			return state
		}
		onLeft := func(left Expression, state WorkArea, _node BinaryExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | undefined */ TODO {
			if !state.skip {
				return maybeCheckExpression(state, left)
			}
		}
		onOperator := func(operatorToken BinaryOperatorToken, state WorkArea, node BinaryExpression) {
			if !state.skip {
				leftType := getLastResult(state)
				Debug.assertIsDefined(leftType)
				setLeftType(state, leftType)
				setLastResult(state, nil)
				operator := operatorToken.kind
				if isLogicalOrCoalescingBinaryOperator(operator) {
					parent := node.parent
					for parent.kind == SyntaxKindParenthesizedExpression || isLogicalOrCoalescingBinaryExpression(parent) {
						parent = parent.parent
					}
					if operator == SyntaxKindAmpersandAmpersandToken || isIfStatement(parent) {
						checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.left, leftType /* TODO(ConditionalExpression): isIfStatement(parent) ? parent.thenStatement : undefined */, TODO)
					}
					if isBinaryLogicalOperator(operator) {
						checkTruthinessOfType(leftType, node.left)
					}
				}
			}
		}
		onRight := func(right Expression, state WorkArea, _node BinaryExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | undefined */ TODO {
			if !state.skip {
				return maybeCheckExpression(state, right)
			}
		}
		onExit := func(node BinaryExpression, state WorkArea) *Type {
			var result *Type
			if state.skip {
				result = getLastResult(state)
			} else {
				leftType := getLeftType(state)
				Debug.assertIsDefined(leftType)
				rightType := getLastResult(state)
				Debug.assertIsDefined(rightType)
				result = checkBinaryLikeExpressionWorker(node.left, node.operatorToken, node.right, leftType, rightType, state.checkMode, node)
			}
			state.skip = false
			setLeftType(state, nil)
			setLastResult(state, nil)
			state.stackIndex--
			return result
		}
		foldState := func(state WorkArea, result *Type, _side /* TODO(UnionType): "left" | "right" */ any) /* TODO inferred type WorkArea */ TODO {
			setLastResult(state, result)
			return state
		}
		maybeCheckExpression := func(state WorkArea, node Expression) *BinaryExpression {
			if isBinaryExpression(node) {
				return node
			}
			setLastResult(state, checkExpression(node, state.checkMode))
		}
		getLeftType := func(state WorkArea) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			return /* TODO(ElementAccessExpression): state.typeStack[state.stackIndex] */ TODO
		}
		setLeftType := func(state WorkArea, type_ *Type) {
			/* TODO(ElementAccessExpression): state.typeStack[state.stackIndex] */ TODO = type_
		}
		getLastResult := func(state WorkArea) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			return /* TODO(ElementAccessExpression): state.typeStack[state.stackIndex + 1] */ TODO
		}
		setLastResult := func(state WorkArea, type_ *Type) {
			/* TODO(ElementAccessExpression): state.typeStack[state.stackIndex + 1] */ TODO = type_
		}
	}
	checkNullishCoalesceOperands := func(node BinaryExpression) {
		TODO_IDENTIFIER := node
		if operatorToken.kind == SyntaxKindQuestionQuestionToken {
			if isBinaryExpression(left) && (left.operatorToken.kind == SyntaxKindBarBarToken || left.operatorToken.kind == SyntaxKindAmpersandAmpersandToken) {
				grammarErrorOnNode(left, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(left.operatorToken.kind), tokenToString(operatorToken.kind))
			}
			if isBinaryExpression(right) && (right.operatorToken.kind == SyntaxKindBarBarToken || right.operatorToken.kind == SyntaxKindAmpersandAmpersandToken) {
				grammarErrorOnNode(right, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(right.operatorToken.kind), tokenToString(operatorToken.kind))
			}
			leftTarget := skipOuterExpressions(left, OuterExpressionKindsAll)
			nullishSemantics := getSyntacticNullishnessSemantics(leftTarget)
			if nullishSemantics != PredicateSemanticsSometimes {
				if node.parent.kind == SyntaxKindBinaryExpression {
					error(leftTarget, Diagnostics.This_binary_expression_is_never_nullish_Are_you_missing_parentheses)
				} else {
					if nullishSemantics == PredicateSemanticsAlways {
						error(leftTarget, Diagnostics.This_expression_is_always_nullish)
					} else {
						error(leftTarget, Diagnostics.Right_operand_of_is_unreachable_because_the_left_operand_is_never_nullish)
					}
				}
			}
		}
	}
	getSyntacticNullishnessSemantics := func(node Node) PredicateSemantics {
		node = skipOuterExpressions(node)
		switch node.kind {
		case SyntaxKindAwaitExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindCallExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindElementAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNewExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindYieldExpression:
			return PredicateSemanticsSometimes
		case SyntaxKindBinaryExpression:
			switch (node).operatorToken.kind {
			case SyntaxKindEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindQuestionQuestionToken:
				fallthrough // TODO: merge cases
			case SyntaxKindQuestionQuestionEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindBarBarToken:
				fallthrough // TODO: merge cases
			case SyntaxKindBarBarEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindAmpersandAmpersandToken:
				fallthrough // TODO: merge cases
			case SyntaxKindAmpersandAmpersandEqualsToken:
				return PredicateSemanticsSometimes
			}
			return PredicateSemanticsNever
		case SyntaxKindConditionalExpression:
			return getSyntacticNullishnessSemantics((node).whenTrue) | getSyntacticNullishnessSemantics((node).whenFalse)
		case SyntaxKindNullKeyword:
			return PredicateSemanticsAlways
		case SyntaxKindIdentifier:
			if getResolvedSymbol(node) == undefinedSymbol {
				return PredicateSemanticsAlways
			}
			return PredicateSemanticsSometimes
		}
		return PredicateSemanticsNever
	}
	checkBinaryLikeExpression := func(left Expression, operatorToken BinaryOperatorToken, right Expression, checkMode CheckMode, errorNode Node) Type {
		operator := operatorToken.kind
		if operator == SyntaxKindEqualsToken && (left.kind == SyntaxKindObjectLiteralExpression || left.kind == SyntaxKindArrayLiteralExpression) {
			return checkDestructuringAssignment(left, checkExpression(right, checkMode), checkMode, right.kind == SyntaxKindThisKeyword)
		}
		var leftType Type
		if isBinaryLogicalOperator(operator) {
			leftType = checkTruthinessExpression(left, checkMode)
		} else {
			leftType = checkExpression(left, checkMode)
		}
		rightType := checkExpression(right, checkMode)
		return checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, checkMode, errorNode)
	}
	checkBinaryLikeExpressionWorker := func(left Expression, operatorToken BinaryOperatorToken, right Expression, leftType Type, rightType Type, checkMode CheckMode, errorNode Node) Type {
		operator := operatorToken.kind
		switch operator {
		case SyntaxKindAsteriskToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAsteriskAsteriskToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAsteriskEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAsteriskAsteriskEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindSlashToken:
			fallthrough // TODO: merge cases
		case SyntaxKindSlashEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindPercentToken:
			fallthrough // TODO: merge cases
		case SyntaxKindPercentEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindMinusToken:
			fallthrough // TODO: merge cases
		case SyntaxKindMinusEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindLessThanLessThanToken:
			fallthrough // TODO: merge cases
		case SyntaxKindLessThanLessThanEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindGreaterThanGreaterThanToken:
			fallthrough // TODO: merge cases
		case SyntaxKindGreaterThanGreaterThanEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindGreaterThanGreaterThanGreaterThanToken:
			fallthrough // TODO: merge cases
		case SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindBarToken:
			fallthrough // TODO: merge cases
		case SyntaxKindBarEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindCaretToken:
			fallthrough // TODO: merge cases
		case SyntaxKindCaretEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAmpersandToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAmpersandEqualsToken:
			if leftType == silentNeverType || rightType == silentNeverType {
				return silentNeverType
			}
			leftType = checkNonNullType(leftType, left)
			rightType = checkNonNullType(rightType, right)
			var suggestedOperator *PunctuationSyntaxKind
			if (leftType.flags & TypeFlagsBooleanLike) && (rightType.flags & TypeFlagsBooleanLike) && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind) */ TODO) != nil {
				error(errorNode || operatorToken, Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, tokenToString(operatorToken.kind), tokenToString(suggestedOperator))
				return numberType
			} else {
				leftOk := checkArithmeticOperandType(left, leftType, Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, true)
				rightOk := checkArithmeticOperandType(right, rightType, Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, true)
				var resultType Type
				if (isTypeAssignableToKind(leftType, TypeFlagsAnyOrUnknown) && isTypeAssignableToKind(rightType, TypeFlagsAnyOrUnknown)) || !(maybeTypeOfKind(leftType, TypeFlagsBigIntLike) || maybeTypeOfKind(rightType, TypeFlagsBigIntLike)) {
					resultType = numberType
				} else if bothAreBigIntLike(leftType, rightType) {
					switch operator {
					case SyntaxKindGreaterThanGreaterThanGreaterThanToken:
						fallthrough // TODO: merge cases
					case SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken:
						reportOperatorError()
						break
					case SyntaxKindAsteriskAsteriskToken:
						fallthrough // TODO: merge cases
					case SyntaxKindAsteriskAsteriskEqualsToken:
						if languageVersion < ScriptTargetES2016 {
							error(errorNode, Diagnostics.Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later)
						}
					}
					resultType = bigintType
				} else {
					reportOperatorError(bothAreBigIntLike)
					resultType = errorType
				}
				if leftOk && rightOk {
					checkAssignmentOperator(resultType)
					switch operator {
					case SyntaxKindLessThanLessThanToken:
						fallthrough // TODO: merge cases
					case SyntaxKindLessThanLessThanEqualsToken:
						fallthrough // TODO: merge cases
					case SyntaxKindGreaterThanGreaterThanToken:
						fallthrough // TODO: merge cases
					case SyntaxKindGreaterThanGreaterThanEqualsToken:
						fallthrough // TODO: merge cases
					case SyntaxKindGreaterThanGreaterThanGreaterThanToken:
						fallthrough // TODO: merge cases
					case SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken:
						rhsEval := evaluate(right)
						if /* TODO(TypeOfExpression): typeof rhsEval.value */ TODO == "number" && Math.abs(rhsEval.value) >= 32 {
							errorOrSuggestion(isEnumMember(walkUpParenthesizedExpressions(right.parent.parent)), errorNode || operatorToken, Diagnostics.This_operation_can_be_simplified_This_shift_is_identical_to_0_1_2, getTextOfNode(left), tokenToString(operator) /* TODO(PercentToken): % */ /* TODO(BinaryExpression): rhsEval.value % 32 */, TODO)
						}
						break
					default:
						break
					}
				}
				return resultType
			}
			fallthrough
		case SyntaxKindPlusToken:
			fallthrough // TODO: merge cases
		case SyntaxKindPlusEqualsToken:
			if leftType == silentNeverType || rightType == silentNeverType {
				return silentNeverType
			}
			if !isTypeAssignableToKind(leftType, TypeFlagsStringLike) && !isTypeAssignableToKind(rightType, TypeFlagsStringLike) {
				leftType = checkNonNullType(leftType, left)
				rightType = checkNonNullType(rightType, right)
			}
			var resultType *Type
			if isTypeAssignableToKind(leftType, TypeFlagsNumberLike, true) && isTypeAssignableToKind(rightType, TypeFlagsNumberLike, true) {
				resultType = numberType
			} else if isTypeAssignableToKind(leftType, TypeFlagsBigIntLike, true) && isTypeAssignableToKind(rightType, TypeFlagsBigIntLike, true) {
				resultType = bigintType
			} else if isTypeAssignableToKind(leftType, TypeFlagsStringLike, true) || isTypeAssignableToKind(rightType, TypeFlagsStringLike, true) {
				resultType = stringType
			} else if isTypeAny(leftType) || isTypeAny(rightType) {
				resultType = /* TODO(ConditionalExpression): isErrorType(leftType) || isErrorType(rightType) ? errorType : anyType */ TODO
			}
			if resultType && !checkForDisallowedESSymbolOperand(operator) {
				return resultType
			}
			if !resultType {
				closeEnoughKind := TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsAnyOrUnknown
				reportOperatorError(func(left /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, right /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return isTypeAssignableToKind(left, closeEnoughKind) && isTypeAssignableToKind(right, closeEnoughKind)
				})
				return anyType
			}
			if operator == SyntaxKindPlusEqualsToken {
				checkAssignmentOperator(resultType)
			}
			return resultType
		case SyntaxKindLessThanToken:
			fallthrough // TODO: merge cases
		case SyntaxKindGreaterThanToken:
			fallthrough // TODO: merge cases
		case SyntaxKindLessThanEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindGreaterThanEqualsToken:
			if checkForDisallowedESSymbolOperand(operator) {
				leftType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(leftType, left))
				rightType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(rightType, right))
				reportOperatorErrorUnless(func(left /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, right /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					if isTypeAny(left) || isTypeAny(right) {
						return true
					}
					leftAssignableToNumber := isTypeAssignableTo(left, numberOrBigIntType)
					rightAssignableToNumber := isTypeAssignableTo(right, numberOrBigIntType)
					return leftAssignableToNumber && rightAssignableToNumber || !leftAssignableToNumber && !rightAssignableToNumber && areTypesComparable(left, right)
				})
			}
			return booleanType
		case SyntaxKindEqualsEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindExclamationEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindEqualsEqualsEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindExclamationEqualsEqualsToken:
			if !(checkMode && checkMode&CheckModeTypeOnly) {
				if (isLiteralExpressionOfObject(left) || isLiteralExpressionOfObject(right)) && (!isInJSFile(left) || (operator == SyntaxKindEqualsEqualsEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken)) {
					eqType := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindEqualsEqualsEqualsToken
					error(errorNode, Diagnostics.This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value /* TODO(ConditionalExpression): eqType ? "false" : "true" */, TODO)
				}
				checkNaNEquality(errorNode, operator, left, right)
				reportOperatorErrorUnless(func(left /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, right /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return isTypeEqualityComparableTo(left, right) || isTypeEqualityComparableTo(right, left)
				})
			}
			return booleanType
		case SyntaxKindInstanceOfKeyword:
			return checkInstanceOfExpression(left, right, leftType, rightType, checkMode)
		case SyntaxKindInKeyword:
			return checkInExpression(left, right, leftType, rightType)
		case SyntaxKindAmpersandAmpersandToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAmpersandAmpersandEqualsToken:
			resultType := /* TODO(ConditionalExpression): hasTypeFacts(leftType, TypeFacts.Truthy) ?                     getUnionType([extractDefinitelyFalsyTypes(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType)), rightType]) :                     leftType */ TODO
			if operator == SyntaxKindAmpersandAmpersandEqualsToken {
				checkAssignmentOperator(rightType)
			}
			return resultType
			fallthrough
		case SyntaxKindBarBarToken:
			fallthrough // TODO: merge cases
		case SyntaxKindBarBarEqualsToken:
			resultType := /* TODO(ConditionalExpression): hasTypeFacts(leftType, TypeFacts.Falsy) ?                     getUnionType([getNonNullableType(removeDefinitelyFalsyTypes(leftType)), rightType], UnionReduction.Subtype) :                     leftType */ TODO
			if operator == SyntaxKindBarBarEqualsToken {
				checkAssignmentOperator(rightType)
			}
			return resultType
			fallthrough
		case SyntaxKindQuestionQuestionToken:
			fallthrough // TODO: merge cases
		case SyntaxKindQuestionQuestionEqualsToken:
			resultType := /* TODO(ConditionalExpression): hasTypeFacts(leftType, TypeFacts.EQUndefinedOrNull) ?                     getUnionType([getNonNullableType(leftType), rightType], UnionReduction.Subtype) :                     leftType */ TODO
			if operator == SyntaxKindQuestionQuestionEqualsToken {
				checkAssignmentOperator(rightType)
			}
			return resultType
			fallthrough
		case SyntaxKindEqualsToken:
			declKind := /* TODO(ConditionalExpression): isBinaryExpression(left.parent) ? getAssignmentDeclarationKind(left.parent) : AssignmentDeclarationKind.None */ TODO
			checkAssignmentDeclaration(declKind, rightType)
			if isAssignmentDeclaration(declKind) {
				if !(rightType.flags & TypeFlagsObject) || declKind != AssignmentDeclarationKindModuleExports && declKind != AssignmentDeclarationKindPrototype && !isEmptyObjectType(rightType) && !isFunctionObjectType(rightType) && !(getObjectFlags(rightType)&ObjectFlagsClass) {
					checkAssignmentOperator(rightType)
				}
				return leftType
			} else {
				checkAssignmentOperator(rightType)
				return rightType
			}
			fallthrough
		case SyntaxKindCommaToken:
			if !compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isIndirectCall(left.parent) {
				sf := getSourceFileOfNode(left)
				sourceText := sf.text
				start := skipTrivia(sourceText, left.pos)
				isInDiag2657 := sf.parseDiagnostics.some(func(diag /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO) /* TODO inferred type boolean */ TODO {
					if diag.code != Diagnostics.JSX_expressions_must_have_one_parent_element.code {
						return false
					}
					return textSpanContainsPosition(diag, start)
				})
				if !isInDiag2657 {
					error(left, Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects)
				}
			}
			return rightType
		default:
			return Debug.fail()
		}
		bothAreBigIntLike := func(left Type, right Type) bool {
			return isTypeAssignableToKind(left, TypeFlagsBigIntLike) && isTypeAssignableToKind(right, TypeFlagsBigIntLike)
		}
		checkAssignmentDeclaration := func(kind AssignmentDeclarationKind, rightType Type) {
			if kind == AssignmentDeclarationKindModuleExports {
				for _, prop := range getPropertiesOfObjectType(rightType) {
					propType := getTypeOfSymbol(prop)
					if propType.symbol && propType.symbol.flags&SymbolFlagsClass {
						name := prop.escapedName
						symbol := resolveName(prop.valueDeclaration, name, SymbolFlagsType, nil, false)
						if symbol.declarations && symbol.declarations.some(isJSDocTypedefTag) {
							addDuplicateDeclarationErrorsForSymbols(symbol, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), prop)
							addDuplicateDeclarationErrorsForSymbols(prop, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), symbol)
						}
					}
				}
			}
		}
		isIndirectCall := func(node BinaryExpression) bool {
			return node.parent.kind == SyntaxKindParenthesizedExpression && isNumericLiteral(node.left) && node.left.text == "0" && (isCallExpression(node.parent.parent) && node.parent.parent.expression == node.parent || node.parent.parent.kind == SyntaxKindTaggedTemplateExpression) && (isAccessExpression(node.right) || isIdentifier(node.right) && node.right.escapedText == "eval")
		}
		checkForDisallowedESSymbolOperand := func(operator PunctuationSyntaxKind) bool {
			offendingSymbolOperand := /* TODO(ConditionalExpression): maybeTypeOfKindConsideringBaseConstraint(leftType, TypeFlags.ESSymbolLike) ? left :                 maybeTypeOfKindConsideringBaseConstraint(rightType, TypeFlags.ESSymbolLike) ? right :                 undefined */ TODO
			if offendingSymbolOperand {
				error(offendingSymbolOperand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(operator))
				return false
			}
			return true
		}
		getSuggestedBooleanOperator := func(operator SyntaxKind) *PunctuationSyntaxKind {
			switch operator {
			case SyntaxKindBarToken:
				fallthrough // TODO: merge cases
			case SyntaxKindBarEqualsToken:
				return SyntaxKindBarBarToken
			case SyntaxKindCaretToken:
				fallthrough // TODO: merge cases
			case SyntaxKindCaretEqualsToken:
				return SyntaxKindExclamationEqualsEqualsToken
			case SyntaxKindAmpersandToken:
				fallthrough // TODO: merge cases
			case SyntaxKindAmpersandEqualsToken:
				return SyntaxKindAmpersandAmpersandToken
			default:
				return nil
			}
		}
		checkAssignmentOperator := func(valueType Type) {
			if isAssignmentOperator(operator) {
				addLazyDiagnostic(checkAssignmentOperatorWorker)
			}
			checkAssignmentOperatorWorker := func() {
				assigneeType := leftType
				if isCompoundAssignment(operatorToken.kind) && left.kind == SyntaxKindPropertyAccessExpression {
					assigneeType = checkPropertyAccessExpression(left, nil, true)
				}
				if checkReferenceExpression(left, Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access) {
					var headMessage *DiagnosticMessage
					if exactOptionalPropertyTypes && isPropertyAccessExpression(left) && maybeTypeOfKind(valueType, TypeFlagsUndefined) {
						target := getTypeOfPropertyOfType(getTypeOfExpression(left.expression), left.name.escapedText)
						if isExactOptionalPropertyMismatch(valueType, target) {
							headMessage = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target
						}
					}
					checkTypeAssignableToAndOptionallyElaborate(valueType, assigneeType, left, right, headMessage)
				}
			}
		}
		isAssignmentDeclaration := func(kind AssignmentDeclarationKind) /* TODO inferred type boolean */ TODO {
			switch kind {
			case AssignmentDeclarationKindModuleExports:
				return true
			case AssignmentDeclarationKindExportsProperty:
				fallthrough // TODO: merge cases
			case AssignmentDeclarationKindProperty:
				fallthrough // TODO: merge cases
			case AssignmentDeclarationKindPrototype:
				fallthrough // TODO: merge cases
			case AssignmentDeclarationKindPrototypeProperty:
				fallthrough // TODO: merge cases
			case AssignmentDeclarationKindThisProperty:
				symbol := getSymbolOfNode(left)
				init := getAssignedExpandoInitializer(right)
				return !!init && isObjectLiteralExpression(init) && !!symbol.exports.size
			default:
				return false
			}
		}
		reportOperatorErrorUnless := func(typesAreCompatible func(left Type, right Type) bool) bool {
			if !typesAreCompatible(leftType, rightType) {
				reportOperatorError(typesAreCompatible)
				return true
			}
			return false
		}
		reportOperatorError := func(isRelated func(left Type, right Type) bool) {
			wouldWorkWithAwait := false
			errNode := errorNode || operatorToken
			if isRelated {
				awaitedLeftType := getAwaitedTypeNoAlias(leftType)
				awaitedRightType := getAwaitedTypeNoAlias(rightType)
				wouldWorkWithAwait = !(awaitedLeftType == leftType && awaitedRightType == rightType) && !!(awaitedLeftType && awaitedRightType) && isRelated(awaitedLeftType, awaitedRightType)
			}
			effectiveLeft := leftType
			effectiveRight := rightType
			if !wouldWorkWithAwait && isRelated {
				/* TODO(ArrayLiteralExpression): [effectiveLeft, effectiveRight] */ TODO = getBaseTypesIfUnrelated(leftType, rightType, isRelated)
			}
			TODO_IDENTIFIER := getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight)
			if !tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr) {
				errorAndMaybeSuggestAwait(errNode, wouldWorkWithAwait, Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, tokenToString(operatorToken.kind), leftStr, rightStr)
			}
		}
		tryGiveBetterPrimaryError := func(errNode Node, maybeMissingAwait bool, leftStr string, rightStr string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic | undefined */ TODO {
			switch operatorToken.kind {
			case SyntaxKindEqualsEqualsEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindEqualsEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindExclamationEqualsEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindExclamationEqualsToken:
				return errorAndMaybeSuggestAwait(errNode, maybeMissingAwait, Diagnostics.This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap, leftStr, rightStr)
			default:
				return nil
			}
		}
		checkNaNEquality := func(errorNode Node, operator SyntaxKind, left Expression, right Expression) {
			isLeftNaN := isGlobalNaN(skipParentheses(left))
			isRightNaN := isGlobalNaN(skipParentheses(right))
			if isLeftNaN || isRightNaN {
				err := error(errorNode, Diagnostics.This_condition_will_always_return_0, tokenToString( /* TODO(ConditionalExpression): operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.EqualsEqualsToken ? SyntaxKind.FalseKeyword : SyntaxKind.TrueKeyword */ TODO))
				if isLeftNaN && isRightNaN {
					return
				}
				operatorString := /* TODO(ConditionalExpression): operator === SyntaxKind.ExclamationEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? tokenToString(SyntaxKind.ExclamationToken) : "" */ TODO
				location := /* TODO(ConditionalExpression): isLeftNaN ? right : left */ TODO
				expression := skipParentheses(location)
				addRelatedInfo(err, createDiagnosticForNode(location, Diagnostics.Did_you_mean_0 /* TODO(TemplateExpression): `${operatorString}Number.isNaN(${isEntityNameExpression(expression) ? entityNameToString(expression) : "..."})` */, TODO))
			}
		}
		isGlobalNaN := func(expr Expression) bool {
			if isIdentifier(expr) && expr.escapedText == "NaN" {
				globalNaNSymbol := getGlobalNaNSymbol()
				return !!globalNaNSymbol && globalNaNSymbol == getResolvedSymbol(expr)
			}
			return false
		}
	}
	getBaseTypesIfUnrelated := func(leftType Type, rightType Type, isRelated func(left Type, right Type) bool) /* TODO(TupleType): [Type, Type] */ any {
		effectiveLeft := leftType
		effectiveRight := rightType
		leftBase := getBaseTypeOfLiteralType(leftType)
		rightBase := getBaseTypeOfLiteralType(rightType)
		if !isRelated(leftBase, rightBase) {
			effectiveLeft = leftBase
			effectiveRight = rightBase
		}
		return /* TODO(ArrayLiteralExpression): [effectiveLeft, effectiveRight] */ TODO
	}
	checkYieldExpression := func(node YieldExpression) Type {
		addLazyDiagnostic(checkYieldExpressionGrammar)
		func_ := getContainingFunction(node)
		if !func_ {
			return anyType
		}
		functionFlags := getFunctionFlags(func_)
		if !(functionFlags & FunctionFlagsGenerator) {
			return anyType
		}
		isAsync := (functionFlags & FunctionFlagsAsync) != 0
		if node.asteriskToken {
			if isAsync && languageVersion < LanguageFeatureMinimumTargetAsyncGenerators {
				checkExternalEmitHelpers(node, ExternalEmitHelpersAsyncDelegatorIncludes)
			}
			if !isAsync && languageVersion < LanguageFeatureMinimumTargetGenerators && compilerOptions.downlevelIteration {
				checkExternalEmitHelpers(node, ExternalEmitHelpersValues)
			}
		}
		returnType := getReturnTypeFromAnnotation(func_)
		if returnType && returnType.flags&TypeFlagsUnion {
			returnType = filterType(returnType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags, nil)
			})
		}
		iterationTypes := returnType && getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsync)
		signatureYieldType := iterationTypes && iterationTypes.yieldType || anyType
		signatureNextType := iterationTypes && iterationTypes.nextType || anyType
		yieldExpressionType := /* TODO(ConditionalExpression): node.expression ? checkExpression(node.expression) : undefinedWideningType */ TODO
		yieldedType := getYieldedTypeOfYieldExpression(node, yieldExpressionType, signatureNextType, isAsync)
		if returnType && yieldedType {
			checkTypeAssignableToAndOptionallyElaborate(yieldedType, signatureYieldType, node.expression || node, node.expression)
		}
		if node.asteriskToken {
			use := /* TODO(ConditionalExpression): isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar */ TODO
			return getIterationTypeOfIterable(use, IterationTypeKindReturn, yieldExpressionType, node.expression) || anyType
		} else if returnType {
			return getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindNext, returnType, isAsync) || anyType
		}
		type_ := getContextualIterationType(IterationTypeKindNext, func_)
		if !type_ {
			type_ = anyType
			addLazyDiagnostic(func() {
				if noImplicitAny && !expressionResultIsUnused(node) {
					contextualType := getContextualType(node, nil)
					if !contextualType || isTypeAny(contextualType) {
						error(node, Diagnostics.yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation)
					}
				}
			})
		}
		return type_
		checkYieldExpressionGrammar := func() {
			if !(node.flags & NodeFlagsYieldContext) {
				grammarErrorOnFirstToken(node, Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body)
			}
			if isInParameterInitializerBeforeContainingFunction(node) {
				error(node, Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer)
			}
		}
	}
	checkConditionalExpression := func(node ConditionalExpression, checkMode CheckMode) Type {
		type_ := checkTruthinessExpression(node.condition, checkMode)
		checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.condition, type_, node.whenTrue)
		type1 := checkExpression(node.whenTrue, checkMode)
		type2 := checkExpression(node.whenFalse, checkMode)
		return getUnionType( /* TODO(ArrayLiteralExpression): [type1, type2] */ TODO, UnionReductionSubtype)
	}
	isTemplateLiteralContext := func(node Node) bool {
		parent := node.parent
		return isParenthesizedExpression(parent) && isTemplateLiteralContext(parent) || isElementAccessExpression(parent) && parent.argumentExpression == node
	}
	checkTemplateExpression := func(node TemplateExpression) Type {
		texts := /* TODO(ArrayLiteralExpression): [node.head.text] */ TODO
		types := /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, span := range node.templateSpans {
			type_ := checkExpression(span.expression)
			if maybeTypeOfKindConsideringBaseConstraint(type_, TypeFlagsESSymbolLike) {
				error(span.expression, Diagnostics.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String)
			}
			texts.push(span.literal.text)
			types.push( /* TODO(ConditionalExpression): isTypeAssignableTo(type, templateConstraintType) ? type : stringType */ TODO)
		}
		evaluated := node.parent.kind != SyntaxKindTaggedTemplateExpression && evaluate(node).value
		if evaluated {
			return getFreshTypeOfLiteralType(getStringLiteralType(evaluated))
		}
		if isConstContext(node) || isTemplateLiteralContext(node) || someType(getContextualType(node, nil) || unknownType, isTemplateLiteralContextualType) {
			return getTemplateLiteralType(texts, types)
		}
		return stringType
	}
	isTemplateLiteralContextualType := func(type_ Type) bool {
		return !!(type_.flags&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral) || type_.flags&TypeFlagsInstantiableNonPrimitive && maybeTypeOfKind(getBaseConstraintOfType(type_) || unknownType, TypeFlagsStringLike))
	}
	getContextNode := func(node Expression) Expression {
		if isJsxAttributes(node) && !isJsxSelfClosingElement(node.parent) {
			return node.parent.parent
		}
		return node
	}
	checkExpressionWithContextualType := func(node Expression, contextualType Type, inferenceContext *InferenceContext, checkMode CheckMode) Type {
		contextNode := getContextNode(node)
		pushContextualType(contextNode, contextualType, false)
		pushInferenceContext(contextNode, inferenceContext)
		type_ := checkExpression(node, checkMode|CheckModeContextual|( /* TODO(ConditionalExpression): inferenceContext ? CheckMode.Inferential : 0 */ TODO))
		if inferenceContext && inferenceContext.intraExpressionInferenceSites {
			inferenceContext.intraExpressionInferenceSites = nil
		}
		result := /* TODO(ConditionalExpression): maybeTypeOfKind(type, TypeFlags.Literal) && isLiteralOfContextualType(type, instantiateContextualType(contextualType, node, /*contextFlags* / undefined)) ?             getRegularTypeOfLiteralType(type) : type */ TODO
		popInferenceContext()
		popContextualType()
		return result
	}
	checkExpressionCached := func(node /* TODO(UnionType): Expression | QualifiedName */ any, checkMode CheckMode) Type {
		if checkMode {
			return checkExpression(node, checkMode)
		}
		links := getNodeLinks(node)
		if !links.resolvedType {
			saveFlowLoopStart := flowLoopStart
			saveFlowTypeCache := flowTypeCache
			flowLoopStart = flowLoopCount
			flowTypeCache = nil
			links.resolvedType = checkExpression(node, checkMode)
			flowTypeCache = saveFlowTypeCache
			flowLoopStart = saveFlowLoopStart
		}
		return links.resolvedType
	}
	isTypeAssertion := func(node Expression) /* TODO inferred type boolean */ TODO {
		node = skipParentheses(node, true)
		return node.kind == SyntaxKindTypeAssertionExpression || node.kind == SyntaxKindAsExpression || isJSDocTypeAssertion(node)
	}
	checkDeclarationInitializer := func(declaration HasExpressionInitializer, checkMode CheckMode, contextualType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		initializer := getEffectiveInitializer(declaration)
		if isInJSFile(declaration) {
			typeNode := tryGetJSDocSatisfiesTypeNode(declaration)
			if typeNode {
				return checkSatisfiesExpressionWorker(initializer, typeNode, checkMode)
			}
		}
		type_ := getQuickTypeOfExpression(initializer) || ( /* TODO(ConditionalExpression): contextualType ?             checkExpressionWithContextualType(initializer, contextualType, /*inferenceContext* / undefined, checkMode || CheckMode.Normal) :             checkExpressionCached(initializer, checkMode) */ TODO)
		if isParameter( /* TODO(ConditionalExpression): isBindingElement(declaration) ? walkUpBindingElementsAndPatterns(declaration) : declaration */ TODO) {
			if declaration.name.kind == SyntaxKindObjectBindingPattern && isObjectLiteralType(type_) {
				return padObjectLiteralType(type_, declaration.name)
			}
			if declaration.name.kind == SyntaxKindArrayBindingPattern && isTupleType(type_) {
				return padTupleType(type_, declaration.name)
			}
		}
		return type_
	}
	padObjectLiteralType := func(type_ ObjectType, pattern ObjectBindingPattern) Type {
		var missingElements /* TODO(ArrayType): BindingElement[] */ any
		for _, e := range pattern.elements {
			if e.initializer {
				name := getPropertyNameFromBindingElement(e)
				if name && !getPropertyOfType(type_, name) {
					missingElements = append(missingElements, e)
				}
			}
		}
		if !missingElements {
			return type_
		}
		members := createSymbolTable()
		for _, prop := range getPropertiesOfObjectType(type_) {
			members.set(prop.escapedName, prop)
		}
		for _, e := range missingElements {
			symbol := createSymbol(SymbolFlagsProperty|SymbolFlagsOptional, getPropertyNameFromBindingElement(e))
			symbol.links.type_ = getTypeFromBindingElement(e, false, false)
			members.set(symbol.escapedName, symbol)
		}
		result := createAnonymousType(type_.symbol, members, emptyArray, emptyArray, getIndexInfosOfType(type_))
		result.objectFlags = type_.objectFlags
		return result
	}
	getPropertyNameFromBindingElement := func(e BindingElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		exprType := getLiteralTypeFromPropertyName(e.propertyName || e.name)
		return /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(exprType) ? getPropertyNameFromType(exprType) : undefined */ TODO
	}
	padTupleType := func(type_ TupleTypeReference, pattern ArrayBindingPattern) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if type_.target.combinedFlags&ElementFlagsVariable || getTypeReferenceArity(type_) >= pattern.elements.length {
			return type_
		}
		patternElements := pattern.elements
		elementTypes := getElementTypes(type_).slice()
		elementFlags := type_.target.elementFlags.slice()
		/* TODO(ForStatement): for (let i = getTypeReferenceArity(type); i < patternElements.length; i++) {             const e = patternElements[i];             if (i < patternElements.length - 1 || !(e.kind === SyntaxKind.BindingElement && e.dotDotDotToken)) {                 elementTypes.push(!isOmittedExpression(e) && hasDefaultValue(e) ? getTypeFromBindingElement(e, /*includePatternInType* / false, /*reportErrors* / false) : anyType);                 elementFlags.push(ElementFlags.Optional);                 if (!isOmittedExpression(e) && !hasDefaultValue(e)) {                     reportImplicitAny(e, anyType);                 }             }         } */
		return createTupleType(elementTypes, elementFlags, type_.target.readonly)
	}
	widenTypeInferredFromInitializer := func(declaration HasExpressionInitializer, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		widened := /* TODO(ConditionalExpression): getCombinedNodeFlagsCached(declaration) & NodeFlags.Constant || isDeclarationReadonly(declaration) ? type : getWidenedLiteralType(type) */ TODO
		if isInJSFile(declaration) {
			if isEmptyLiteralType(widened) {
				reportImplicitAny(declaration, anyType)
				return anyType
			} else if isEmptyArrayLiteralType(widened) {
				reportImplicitAny(declaration, anyArrayType)
				return anyArrayType
			}
		}
		return widened
	}
	isLiteralOfContextualType := func(candidateType Type, contextualType *Type) bool {
		if contextualType {
			if contextualType.flags & TypeFlagsUnionOrIntersection {
				types := (contextualType).types
				return some(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return isLiteralOfContextualType(candidateType, t)
				})
			}
			if contextualType.flags & TypeFlagsInstantiableNonPrimitive {
				constraint := getBaseConstraintOfType(contextualType) || unknownType
				return maybeTypeOfKind(constraint, TypeFlagsString) && maybeTypeOfKind(candidateType, TypeFlagsStringLiteral) || maybeTypeOfKind(constraint, TypeFlagsNumber) && maybeTypeOfKind(candidateType, TypeFlagsNumberLiteral) || maybeTypeOfKind(constraint, TypeFlagsBigInt) && maybeTypeOfKind(candidateType, TypeFlagsBigIntLiteral) || maybeTypeOfKind(constraint, TypeFlagsESSymbol) && maybeTypeOfKind(candidateType, TypeFlagsUniqueESSymbol) || isLiteralOfContextualType(candidateType, constraint)
			}
			return !!(contextualType.flags&(TypeFlagsStringLiteral|TypeFlagsIndex|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && maybeTypeOfKind(candidateType, TypeFlagsStringLiteral) || contextualType.flags&TypeFlagsNumberLiteral && maybeTypeOfKind(candidateType, TypeFlagsNumberLiteral) || contextualType.flags&TypeFlagsBigIntLiteral && maybeTypeOfKind(candidateType, TypeFlagsBigIntLiteral) || contextualType.flags&TypeFlagsBooleanLiteral && maybeTypeOfKind(candidateType, TypeFlagsBooleanLiteral) || contextualType.flags&TypeFlagsUniqueESSymbol && maybeTypeOfKind(candidateType, TypeFlagsUniqueESSymbol))
		}
		return false
	}
	isConstContext := func(node Expression) bool {
		parent := node.parent
		return isAssertionExpression(parent) && isConstTypeReference(parent.type_) || isJSDocTypeAssertion(parent) && isConstTypeReference(getJSDocTypeAssertionType(parent)) || isValidConstAssertionArgument(node) && isConstTypeVariable(getContextualType(node, ContextFlagsNone)) || (isParenthesizedExpression(parent) || isArrayLiteralExpression(parent) || isSpreadElement(parent)) && isConstContext(parent) || (isPropertyAssignment(parent) || isShorthandPropertyAssignment(parent) || isTemplateSpan(parent)) && isConstContext(parent.parent)
	}
	checkExpressionForMutableLocation := func(node Expression, checkMode *CheckMode, forceTuple bool) Type {
		type_ := checkExpression(node, checkMode, forceTuple)
		return /* TODO(ConditionalExpression): isConstContext(node) || isCommonJsExportedExpression(node) ? getRegularTypeOfLiteralType(type) :             isTypeAssertion(node) ? type :             getWidenedLiteralLikeTypeForContextualType(type, instantiateContextualType(getContextualType(node, /*contextFlags* / undefined), node, /*contextFlags* / undefined)) */ TODO
	}
	checkPropertyAssignment := func(node PropertyAssignment, checkMode CheckMode) Type {
		if node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
		}
		return checkExpressionForMutableLocation(node.initializer, checkMode)
	}
	checkObjectLiteralMethod := func(node MethodDeclaration, checkMode CheckMode) Type {
		checkGrammarMethod(node)
		if node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
		}
		uninstantiatedType := checkFunctionExpressionOrObjectLiteralMethod(node, checkMode)
		return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
	}
	instantiateTypeWithSingleGenericCallSignature := func(node /* TODO(UnionType): Expression | MethodDeclaration | QualifiedName */ any, type_ Type, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if checkMode && checkMode&(CheckModeInferential|CheckModeSkipGenericFunctions) {
			callSignature := getSingleSignature(type_, SignatureKindCall, true)
			constructSignature := getSingleSignature(type_, SignatureKindConstruct, true)
			signature := callSignature || constructSignature
			if signature && signature.typeParameters {
				contextualType := getApparentTypeOfContextualType(node, ContextFlagsNoConstraints)
				if contextualType {
					contextualSignature := getSingleSignature(getNonNullableType(contextualType) /* TODO(ConditionalExpression): callSignature ? SignatureKind.Call : SignatureKind.Construct */, TODO, false)
					if contextualSignature && !contextualSignature.typeParameters {
						if checkMode & CheckModeSkipGenericFunctions {
							skippedGenericFunction(node, checkMode)
							return anyFunctionType
						}
						context := getInferenceContext(node)
						returnType := context.signature && getReturnTypeOfSignature(context.signature)
						returnSignature := returnType && getSingleCallOrConstructSignature(returnType)
						if returnSignature && !returnSignature.typeParameters && !every(context.inferences, hasInferenceCandidates) {
							uniqueTypeParameters := getUniqueTypeParameters(context, signature.typeParameters)
							instantiatedSignature := getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters)
							inferences := map_(context.inferences, func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO {
								return createInferenceInfo(info.typeParameter)
							})
							applyToParameterTypes(instantiatedSignature, contextualSignature, func(source /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, target /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
								inferTypes(inferences, source, target, 0, true)
							})
							if some(inferences, hasInferenceCandidates) {
								applyToReturnTypes(instantiatedSignature, contextualSignature, func(source /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, target /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
									inferTypes(inferences, source, target)
								})
								if !hasOverlappingInferences(context.inferences, inferences) {
									mergeInferences(context.inferences, inferences)
									context.inferredTypeParameters = concatenate(context.inferredTypeParameters, uniqueTypeParameters)
									return getOrCreateTypeFromSignature(instantiatedSignature)
								}
							}
						}
						return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context), flatMap(inferenceContexts, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceContext | undefined */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
							return c && map_(c.inferences, func(i /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
								return i.typeParameter
							})
						}).slice())
					}
				}
			}
		}
		return type_
	}
	skippedGenericFunction := func(node Node, checkMode CheckMode) {
		if checkMode & CheckModeInferential {
			context := getInferenceContext(node)
			context.flags |= InferenceFlagsSkippedGenericFunction
		}
	}
	hasInferenceCandidates := func(info InferenceInfo) /* TODO inferred type boolean */ TODO {
		return !!(info.candidates || info.contraCandidates)
	}
	hasInferenceCandidatesOrDefault := func(info InferenceInfo) /* TODO inferred type boolean */ TODO {
		return !!(info.candidates || info.contraCandidates || hasTypeParameterDefault(info.typeParameter))
	}
	hasOverlappingInferences := func(a []InferenceInfo, b []InferenceInfo) /* TODO inferred type boolean */ TODO {
		/* TODO(ForStatement): for (let i = 0; i < a.length; i++) {             if (hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i])) {                 return true;             }         } */
		return false
	}
	mergeInferences := func(target []InferenceInfo, source []InferenceInfo) {
		/* TODO(ForStatement): for (let i = 0; i < target.length; i++) {             if (!hasInferenceCandidates(target[i]) && hasInferenceCandidates(source[i])) {                 target[i] = source[i];             }         } */
	}
	getUniqueTypeParameters := func(context InferenceContext, typeParameters []TypeParameter) []TypeParameter {
		var result []TypeParameter = /* TODO(ArrayLiteralExpression): [] */ TODO
		var oldTypeParameters /* TODO(ArrayType): TypeParameter[] */ any
		var newTypeParameters /* TODO(ArrayType): TypeParameter[] */ any
		for _, tp := range typeParameters {
			name := tp.symbol.escapedName
			if hasTypeParameterByName(context.inferredTypeParameters, name) || hasTypeParameterByName(result, name) {
				newName := getUniqueTypeParameterName(concatenate(context.inferredTypeParameters, result), name)
				symbol := createSymbol(SymbolFlagsTypeParameter, newName)
				newTypeParameter := createTypeParameter(symbol)
				newTypeParameter.target = tp
				oldTypeParameters = append(oldTypeParameters, tp)
				newTypeParameters = append(newTypeParameters, newTypeParameter)
				result.push(newTypeParameter)
			} else {
				result.push(tp)
			}
		}
		if newTypeParameters {
			mapper := createTypeMapper(oldTypeParameters, newTypeParameters)
			for _, tp := range newTypeParameters {
				tp.mapper = mapper
			}
		}
		return result
	}
	hasTypeParameterByName := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, name __String) /* TODO inferred type boolean */ TODO {
		return some(typeParameters, func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO inferred type boolean */ TODO {
			return tp.symbol.escapedName == name
		})
	}
	getUniqueTypeParameterName := func(typeParameters []TypeParameter, baseName __String) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
		len := (baseName).length
		for len > 1 && (baseName).charCodeAt( /* TODO(MinusToken): - */ /* TODO(BinaryExpression): len - 1 */ TODO) >= CharacterCodes_0 && (baseName).charCodeAt( /* TODO(MinusToken): - */ /* TODO(BinaryExpression): len - 1 */ TODO) <= CharacterCodes_9 {
			len--
		}
		s := (baseName).slice(0, len)
		/* TODO(ForStatement): for (let index = 1; true; index++) {             const augmentedName = s + index as __String;             if (!hasTypeParameterByName(typeParameters, augmentedName)) {                 return augmentedName;             }         } */
	}
	getReturnTypeOfSingleNonGenericCallSignature := func(funcType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		signature := getSingleCallSignature(funcType)
		if signature && !signature.typeParameters {
			return getReturnTypeOfSignature(signature)
		}
	}
	getReturnTypeOfSingleNonGenericSignatureOfCallChain := func(expr CallChain) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		funcType := checkExpression(expr.expression)
		nonOptionalType := getOptionalExpressionType(funcType, expr.expression)
		returnType := getReturnTypeOfSingleNonGenericCallSignature(funcType)
		return returnType && propagateOptionalTypeMarker(returnType, expr, nonOptionalType != funcType)
	}
	getTypeOfExpression := func(node Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		quickType := getQuickTypeOfExpression(node)
		if quickType {
			return quickType
		}
		if node.flags&NodeFlagsTypeCached && flowTypeCache {
			cachedType := /* TODO(ElementAccessExpression): flowTypeCache[getNodeId(node)] */ TODO
			if cachedType {
				return cachedType
			}
		}
		startInvocationCount := flowInvocationCount
		type_ := checkExpression(node, CheckModeTypeOnly)
		if flowInvocationCount != startInvocationCount {
			cache := flowTypeCache || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): flowTypeCache = [] */ TODO)
			/* TODO(ElementAccessExpression): cache[getNodeId(node)] */ TODO = type_
			setNodeFlags(node, node.flags|NodeFlagsTypeCached)
		}
		return type_
	}
	getQuickTypeOfExpression := func(node Expression) *Type {
		expr := skipParentheses(node, true)
		if isJSDocTypeAssertion(expr) {
			type_ := getJSDocTypeAssertionType(expr)
			if !isConstTypeReference(type_) {
				return getTypeFromTypeNode(type_)
			}
		}
		expr = skipParentheses(node)
		if isAwaitExpression(expr) {
			type_ := getQuickTypeOfExpression(expr.expression)
			return /* TODO(ConditionalExpression): type ? getAwaitedType(type) : undefined */ TODO
		}
		if isCallExpression(expr) && expr.expression.kind != SyntaxKindSuperKeyword && !isRequireCall(expr, true) && !isSymbolOrSymbolForCall(expr) {
			return /* TODO(ConditionalExpression): isCallChain(expr) ? getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) :                 getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(expr.expression)) */ TODO
		} else if isAssertionExpression(expr) && !isConstTypeReference(expr.type_) {
			return getTypeFromTypeNode((expr).type_)
		} else if isLiteralExpression(node) || isBooleanLiteral(node) {
			return checkExpression(node)
		}
		return nil
	}
	getContextFreeTypeOfExpression := func(node Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getNodeLinks(node)
		if links.contextFreeType {
			return links.contextFreeType
		}
		pushContextualType(node, anyType, false)
		type_ := /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.contextFreeType = checkExpression(node, CheckMode.SkipContextSensitive) */ TODO
		popContextualType()
		return type_
	}
	checkExpression := func(node /* TODO(UnionType): Expression | QualifiedName */ any, checkMode CheckMode, forceTuple bool) Type {
		tracing.push(tracing.Phase.Check, "checkExpression" /* TODO(ObjectLiteralExpression): { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath } */, TODO)
		saveCurrentNode := currentNode
		currentNode = node
		instantiationCount = 0
		uninstantiatedType := checkExpressionWorker(node, checkMode, forceTuple)
		type_ := instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
		if isConstEnumObjectType(type_) {
			checkConstEnumAccess(node, type_)
		}
		currentNode = saveCurrentNode
		tracing.pop()
		return type_
	}
	checkConstEnumAccess := func(node /* TODO(UnionType): Expression | QualifiedName */ any, type_ Type) {
		ok := (node.parent.kind == SyntaxKindPropertyAccessExpression && (node.parent).expression == node) || (node.parent.kind == SyntaxKindElementAccessExpression && (node.parent).expression == node) || ((node.kind == SyntaxKindIdentifier || node.kind == SyntaxKindQualifiedName) && isInRightSideOfImportOrExportAssignment(node) || (node.parent.kind == SyntaxKindTypeQuery && (node.parent).exprName == node)) || (node.parent.kind == SyntaxKindExportSpecifier)
		if !ok {
			error(node, Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query)
		}
		if compilerOptions.isolatedModules || compilerOptions.verbatimModuleSyntax && ok && !resolveName(node, getFirstIdentifier(node), SymbolFlagsAlias, nil, false, true) {
			Debug.assert(!!(type_.symbol.flags & SymbolFlagsConstEnum))
			constEnumDeclaration := type_.symbol.valueDeclaration
			redirect := host.getRedirectReferenceForResolutionFromSourceOfProject(getSourceFileOfNode(constEnumDeclaration).resolvedPath)
			if constEnumDeclaration.flags&NodeFlagsAmbient && !isValidTypeOnlyAliasUseSite(node) && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) {
				error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName)
			}
		}
	}
	checkParenthesizedExpression := func(node ParenthesizedExpression, checkMode CheckMode) Type {
		if hasJSDocNodes(node) {
			if isJSDocSatisfiesExpression(node) {
				return checkSatisfiesExpressionWorker(node.expression, getJSDocSatisfiesExpressionType(node), checkMode)
			}
			if isJSDocTypeAssertion(node) {
				return checkAssertionWorker(node, checkMode)
			}
		}
		return checkExpression(node.expression, checkMode)
	}
	checkExpressionWorker := func(node /* TODO(UnionType): Expression | QualifiedName */ any, checkMode *CheckMode, forceTuple bool) Type {
		kind := node.kind
		if cancellationToken {
			switch kind {
			case SyntaxKindClassExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindArrowFunction:
				cancellationToken.throwIfCancellationRequested()
			}
		}
		switch kind {
		case SyntaxKindIdentifier:
			return checkIdentifier(node, checkMode)
		case SyntaxKindPrivateIdentifier:
			return checkPrivateIdentifierExpression(node)
		case SyntaxKindThisKeyword:
			return checkThisExpression(node)
		case SyntaxKindSuperKeyword:
			return checkSuperExpression(node)
		case SyntaxKindNullKeyword:
			return nullWideningType
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindStringLiteral:
			return /* TODO(ConditionalExpression): hasSkipDirectInferenceFlag(node) ?                     blockedStringType :                     getFreshTypeOfLiteralType(getStringLiteralType((node as StringLiteralLike).text)) */ TODO
		case SyntaxKindNumericLiteral:
			checkGrammarNumericLiteral(node)
			return getFreshTypeOfLiteralType(getNumberLiteralType(+(node).text))
		case SyntaxKindBigIntLiteral:
			checkGrammarBigIntLiteral(node)
			return getFreshTypeOfLiteralType(getBigIntLiteralType( /* TODO(ObjectLiteralExpression): {                     negative: false,                     base10Value: parsePseudoBigInt((node as BigIntLiteral).text),                 } */ TODO))
		case SyntaxKindTrueKeyword:
			return trueType
		case SyntaxKindFalseKeyword:
			return falseType
		case SyntaxKindTemplateExpression:
			return checkTemplateExpression(node)
		case SyntaxKindRegularExpressionLiteral:
			return checkRegularExpressionLiteral(node)
		case SyntaxKindArrayLiteralExpression:
			return checkArrayLiteral(node, checkMode, forceTuple)
		case SyntaxKindObjectLiteralExpression:
			return checkObjectLiteral(node, checkMode)
		case SyntaxKindPropertyAccessExpression:
			return checkPropertyAccessExpression(node, checkMode)
		case SyntaxKindQualifiedName:
			return checkQualifiedName(node, checkMode)
		case SyntaxKindElementAccessExpression:
			return checkIndexedAccess(node, checkMode)
		case SyntaxKindCallExpression:
			if (node).expression.kind == SyntaxKindImportKeyword {
				return checkImportCallExpression(node)
			}
			fallthrough
		case SyntaxKindNewExpression:
			return checkCallExpression(node, checkMode)
		case SyntaxKindTaggedTemplateExpression:
			return checkTaggedTemplateExpression(node)
		case SyntaxKindParenthesizedExpression:
			return checkParenthesizedExpression(node, checkMode)
		case SyntaxKindClassExpression:
			return checkClassExpression(node)
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			return checkFunctionExpressionOrObjectLiteralMethod(node, checkMode)
		case SyntaxKindTypeOfExpression:
			return checkTypeOfExpression(node)
		case SyntaxKindTypeAssertionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindAsExpression:
			return checkAssertion(node, checkMode)
		case SyntaxKindNonNullExpression:
			return checkNonNullAssertion(node)
		case SyntaxKindExpressionWithTypeArguments:
			return checkExpressionWithTypeArguments(node)
		case SyntaxKindSatisfiesExpression:
			return checkSatisfiesExpression(node)
		case SyntaxKindMetaProperty:
			return checkMetaProperty(node)
		case SyntaxKindDeleteExpression:
			return checkDeleteExpression(node)
		case SyntaxKindVoidExpression:
			return checkVoidExpression(node)
		case SyntaxKindAwaitExpression:
			return checkAwaitExpression(node)
		case SyntaxKindPrefixUnaryExpression:
			return checkPrefixUnaryExpression(node)
		case SyntaxKindPostfixUnaryExpression:
			return checkPostfixUnaryExpression(node)
		case SyntaxKindBinaryExpression:
			return checkBinaryExpression(node, checkMode)
		case SyntaxKindConditionalExpression:
			return checkConditionalExpression(node, checkMode)
		case SyntaxKindSpreadElement:
			return checkSpreadExpression(node, checkMode)
		case SyntaxKindOmittedExpression:
			return undefinedWideningType
		case SyntaxKindYieldExpression:
			return checkYieldExpression(node)
		case SyntaxKindSyntheticExpression:
			return checkSyntheticExpression(node)
		case SyntaxKindJsxExpression:
			return checkJsxExpression(node, checkMode)
		case SyntaxKindJsxElement:
			return checkJsxElement(node, checkMode)
		case SyntaxKindJsxSelfClosingElement:
			return checkJsxSelfClosingElement(node, checkMode)
		case SyntaxKindJsxFragment:
			return checkJsxFragment(node)
		case SyntaxKindJsxAttributes:
			return checkJsxAttributes(node, checkMode)
		case SyntaxKindJsxOpeningElement:
			Debug.fail("Shouldn't ever directly check a JsxOpeningElement")
		}
		return errorType
	}
	checkTypeParameter := func(node TypeParameterDeclaration) {
		checkGrammarModifiers(node)
		if node.expression {
			grammarErrorOnFirstToken(node.expression, Diagnostics.Type_expected)
		}
		checkSourceElement(node.constraint)
		checkSourceElement(node.default_)
		typeParameter := getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node))
		getBaseConstraintOfType(typeParameter)
		if !hasNonCircularTypeParameterDefault(typeParameter) {
			error(node.default_, Diagnostics.Type_parameter_0_has_a_circular_default, typeToString(typeParameter))
		}
		constraintType := getConstraintOfTypeParameter(typeParameter)
		defaultType := getDefaultFromTypeParameter(typeParameter)
		if constraintType && defaultType {
			checkTypeAssignableTo(defaultType, getTypeWithThisArgument(instantiateType(constraintType, makeUnaryTypeMapper(typeParameter, defaultType)), defaultType), node.default_, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)
		}
		checkNodeDeferred(node)
		addLazyDiagnostic(func() {
			return checkTypeNameIsReserved(node.name, Diagnostics.Type_parameter_name_cannot_be_0)
		})
	}
	checkTypeParameterDeferred := func(node TypeParameterDeclaration) {
		if isInterfaceDeclaration(node.parent) || isClassLike(node.parent) || isTypeAliasDeclaration(node.parent) {
			typeParameter := getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node))
			modifiers := getTypeParameterModifiers(typeParameter) & (ModifierFlagsIn | ModifierFlagsOut)
			if modifiers {
				symbol := getSymbolOfDeclaration(node.parent)
				if isTypeAliasDeclaration(node.parent) && !(getObjectFlags(getDeclaredTypeOfSymbol(symbol)) & (ObjectFlagsReference | ObjectFlagsAnonymous | ObjectFlagsMapped)) {
					error(node, Diagnostics.Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types)
				} else if modifiers == ModifierFlagsIn || modifiers == ModifierFlagsOut {
					tracing.push(tracing.Phase.CheckTypes, "checkTypeParameterDeferred" /* TODO(ObjectLiteralExpression): { parent: getTypeId(getDeclaredTypeOfSymbol(symbol)), id: getTypeId(typeParameter) } */, TODO)
					source := createMarkerType(symbol, typeParameter /* TODO(ConditionalExpression): modifiers === ModifierFlags.Out ? markerSubTypeForCheck : markerSuperTypeForCheck */, TODO)
					target := createMarkerType(symbol, typeParameter /* TODO(ConditionalExpression): modifiers === ModifierFlags.Out ? markerSuperTypeForCheck : markerSubTypeForCheck */, TODO)
					saveVarianceTypeParameter := typeParameter
					varianceTypeParameter = typeParameter
					checkTypeAssignableTo(source, target, node, Diagnostics.Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation)
					varianceTypeParameter = saveVarianceTypeParameter
					tracing.pop()
				}
			}
		}
	}
	checkParameter := func(node ParameterDeclaration) {
		checkGrammarModifiers(node)
		checkVariableLikeDeclaration(node)
		func_ := getContainingFunction(node)
		if hasSyntacticModifier(node, ModifierFlagsParameterPropertyModifier) {
			if !(func_.kind == SyntaxKindConstructor && nodeIsPresent(func_.body)) {
				error(node, Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation)
			}
			if func_.kind == SyntaxKindConstructor && isIdentifier(node.name) && node.name.escapedText == "constructor" {
				error(node.name, Diagnostics.constructor_cannot_be_used_as_a_parameter_property_name)
			}
		}
		if !node.initializer && isOptionalDeclaration(node) && isBindingPattern(node.name) && (func_).body {
			error(node, Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature)
		}
		if node.name && isIdentifier(node.name) && (node.name.escapedText == "this" || node.name.escapedText == "new") {
			if func_.parameters.indexOf(node) != 0 {
				error(node, Diagnostics.A_0_parameter_must_be_the_first_parameter, node.name.escapedText)
			}
			if func_.kind == SyntaxKindConstructor || func_.kind == SyntaxKindConstructSignature || func_.kind == SyntaxKindConstructorType {
				error(node, Diagnostics.A_constructor_cannot_have_a_this_parameter)
			}
			if func_.kind == SyntaxKindArrowFunction {
				error(node, Diagnostics.An_arrow_function_cannot_have_a_this_parameter)
			}
			if func_.kind == SyntaxKindGetAccessor || func_.kind == SyntaxKindSetAccessor {
				error(node, Diagnostics.get_and_set_accessors_cannot_declare_this_parameters)
			}
		}
		if node.dotDotDotToken && !isBindingPattern(node.name) && !isTypeAssignableTo(getReducedType(getTypeOfSymbol(node.symbol)), anyReadonlyArrayType) {
			error(node, Diagnostics.A_rest_parameter_must_be_of_an_array_type)
		}
	}
	checkTypePredicate := func(node TypePredicateNode) {
		parent := getTypePredicateParent(node)
		if !parent {
			error(node, Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods)
			return
		}
		signature := getSignatureFromDeclaration(parent)
		typePredicate := getTypePredicateOfSignature(signature)
		if !typePredicate {
			return
		}
		checkSourceElement(node.type_)
		TODO_IDENTIFIER := node
		if typePredicate.kind != TypePredicateKindThis && typePredicate.kind != TypePredicateKindAssertsThis {
			if typePredicate.parameterIndex >= 0 {
				if signatureHasRestParameter(signature) && typePredicate.parameterIndex == /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - 1 */ TODO {
					error(parameterName, Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter)
				} else {
					if typePredicate.type_ {
						leadingError := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ TODO {
							return chainDiagnosticMessages(nil, Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type)
						}
						checkTypeAssignableTo(typePredicate.type_, getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[typePredicate.parameterIndex] */ TODO), node.type_, nil, leadingError)
					}
				}
			} else if parameterName {
				hasReportedError := false
				for _, TODO_IDENTIFIER := range parent.parameters {
					if isBindingPattern(name) && checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName) {
						hasReportedError = true
						break
					}
				}
				if !hasReportedError {
					error(node.parameterName, Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName)
				}
			}
		}
	}
	getTypePredicateParent := func(node Node) *SignatureDeclaration {
		switch node.parent.kind {
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindCallSignature:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionType:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodSignature:
			parent := node.parent
			if node == parent.type_ {
				return parent
			}
		}
	}
	checkIfTypePredicateVariableIsDeclaredInBindingPattern := func(pattern BindingPattern, predicateVariableNode Node, predicateVariableName string) /* TODO inferred type true | undefined */ TODO {
		for _, element := range pattern.elements {
			if isOmittedExpression(element) {
				continue
			}
			name := element.name
			if name.kind == SyntaxKindIdentifier && name.escapedText == predicateVariableName {
				error(predicateVariableNode, Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName)
				return true
			} else if name.kind == SyntaxKindArrayBindingPattern || name.kind == SyntaxKindObjectBindingPattern {
				if checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, predicateVariableNode, predicateVariableName) {
					return true
				}
			}
		}
	}
	checkSignatureDeclaration := func(node SignatureDeclaration) {
		if node.kind == SyntaxKindIndexSignature {
			checkGrammarIndexSignature(node)
		} else if node.kind == SyntaxKindFunctionType || node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindConstructorType || node.kind == SyntaxKindCallSignature || node.kind == SyntaxKindConstructor || node.kind == SyntaxKindConstructSignature {
			checkGrammarFunctionLikeDeclaration(node)
		}
		functionFlags := getFunctionFlags(node)
		if !(functionFlags & FunctionFlagsInvalid) {
			if (functionFlags&FunctionFlagsAsyncGenerator) == FunctionFlagsAsyncGenerator && languageVersion < LanguageFeatureMinimumTargetAsyncGenerators {
				checkExternalEmitHelpers(node, ExternalEmitHelpersAsyncGeneratorIncludes)
			}
			if (functionFlags&FunctionFlagsAsyncGenerator) == FunctionFlagsAsync && languageVersion < LanguageFeatureMinimumTargetAsyncFunctions {
				checkExternalEmitHelpers(node, ExternalEmitHelpersAwaiter)
			}
			if (functionFlags&FunctionFlagsAsyncGenerator) != FunctionFlagsNormal && languageVersion < LanguageFeatureMinimumTargetGenerators {
				checkExternalEmitHelpers(node, ExternalEmitHelpersGenerator)
			}
		}
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
		checkUnmatchedJSDocParameters(node)
		forEach(node.parameters, checkParameter)
		if node.type_ {
			checkSourceElement(node.type_)
		}
		addLazyDiagnostic(checkSignatureDeclarationDiagnostics)
		checkSignatureDeclarationDiagnostics := func() {
			checkCollisionWithArgumentsInGeneratedCode(node)
			returnTypeNode := getEffectiveReturnTypeNode(node)
			returnTypeErrorLocation := returnTypeNode
			if isInJSFile(node) {
				typeTag := getJSDocTypeTag(node)
				if typeTag && typeTag.typeExpression && isTypeReferenceNode(typeTag.typeExpression.type_) {
					signature := getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression))
					if signature && signature.declaration {
						returnTypeNode = getEffectiveReturnTypeNode(signature.declaration)
						returnTypeErrorLocation = typeTag.typeExpression.type_
					}
				}
			}
			if noImplicitAny && !returnTypeNode {
				switch node.kind {
				case SyntaxKindConstructSignature:
					error(node, Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type)
					break
				case SyntaxKindCallSignature:
					error(node, Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type)
					break
				}
			}
			if returnTypeNode && returnTypeErrorLocation {
				functionFlags := getFunctionFlags(node)
				if (functionFlags & (FunctionFlagsInvalid | FunctionFlagsGenerator)) == FunctionFlagsGenerator {
					returnType := getTypeFromTypeNode(returnTypeNode)
					if returnType == voidType {
						error(returnTypeErrorLocation, Diagnostics.A_generator_cannot_have_a_void_type_annotation)
					} else {
						checkGeneratorInstantiationAssignabilityToReturnType(returnType, functionFlags, returnTypeErrorLocation)
					}
				} else if (functionFlags & FunctionFlagsAsyncGenerator) == FunctionFlagsAsync {
					checkAsyncFunctionReturnType(node, returnTypeNode, returnTypeErrorLocation)
				}
			}
			if node.kind != SyntaxKindIndexSignature && node.kind != SyntaxKindJSDocFunctionType {
				registerForUnusedIdentifiersCheck(node)
			}
		}
	}
	checkGeneratorInstantiationAssignabilityToReturnType := func(returnType Type, functionFlags FunctionFlags, errorNode TypeNode) /* TODO inferred type boolean */ TODO {
		generatorYieldType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindYield, returnType, (functionFlags&FunctionFlagsAsync) != 0) || anyType
		generatorReturnType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, returnType, (functionFlags&FunctionFlagsAsync) != 0) || generatorYieldType
		generatorNextType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindNext, returnType, (functionFlags&FunctionFlagsAsync) != 0) || unknownType
		generatorInstantiation := createGeneratorType(generatorYieldType, generatorReturnType, generatorNextType, !!(functionFlags & FunctionFlagsAsync))
		return checkTypeAssignableTo(generatorInstantiation, returnType, errorNode)
	}
	checkClassForDuplicateDeclarations := func(node ClassLikeDeclaration) {
		instanceNames := make(map[__String]DeclarationMeaning)
		staticNames := make(map[__String]DeclarationMeaning)
		privateIdentifiers := make(map[__String]DeclarationMeaning)
		for _, member := range node.members {
			if member.kind == SyntaxKindConstructor {
				for _, param := range (member).parameters {
					if isParameterPropertyDeclaration(param, member) && !isBindingPattern(param.name) {
						addName(instanceNames, param.name, param.name.escapedText, DeclarationMeaningGetOrSetAccessor)
					}
				}
			} else {
				isStaticMember := isStatic(member)
				name := member.name
				if !name {
					continue
				}
				isPrivate := isPrivateIdentifier(name)
				privateStaticFlags := /* TODO(ConditionalExpression): isPrivate && isStaticMember ? DeclarationMeaning.PrivateStatic : 0 */ TODO
				names := /* TODO(ConditionalExpression): isPrivate ? privateIdentifiers :                     isStaticMember ? staticNames :                     instanceNames */ TODO
				memberName := name && getEffectivePropertyNameForPropertyNameNode(name)
				if memberName {
					switch member.kind {
					case SyntaxKindGetAccessor:
						addName(names, name, memberName, DeclarationMeaningGetAccessor|privateStaticFlags)
						break
					case SyntaxKindSetAccessor:
						addName(names, name, memberName, DeclarationMeaningSetAccessor|privateStaticFlags)
						break
					case SyntaxKindPropertyDeclaration:
						addName(names, name, memberName, DeclarationMeaningGetOrSetAccessor|privateStaticFlags)
						break
					case SyntaxKindMethodDeclaration:
						addName(names, name, memberName, DeclarationMeaningMethod|privateStaticFlags)
						break
					}
				}
			}
		}
		addName := func(names Map[__String, DeclarationMeaning], location Node, name __String, meaning DeclarationMeaning) {
			prev := names.get(name)
			if prev {
				if (prev & DeclarationMeaningPrivateStatic) != (meaning & DeclarationMeaningPrivateStatic) {
					error(location, Diagnostics.Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name, getTextOfNode(location))
				} else {
					prevIsMethod := !!(prev & DeclarationMeaningMethod)
					isMethod := !!(meaning & DeclarationMeaningMethod)
					if prevIsMethod || isMethod {
						if prevIsMethod != isMethod {
							error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location))
						}
					} else if prev & meaning & ~DeclarationMeaningPrivateStatic {
						error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location))
					} else {
						names.set(name, prev|meaning)
					}
				}
			} else {
				names.set(name, meaning)
			}
		}
	}
	checkClassForStaticPropertyNameConflicts := func(node ClassLikeDeclaration) {
		for _, member := range node.members {
			memberNameNode := member.name
			isStaticMember := isStatic(member)
			if isStaticMember && memberNameNode {
				memberName := getEffectivePropertyNameForPropertyNameNode(memberNameNode)
				switch memberName {
				case "name":
					fallthrough // TODO: merge cases
				case "length":
					fallthrough // TODO: merge cases
				case "caller":
					fallthrough // TODO: merge cases
				case "arguments":
					if useDefineForClassFields {
						break
					}
					fallthrough
				case "prototype":
					message := Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1
					className := getNameOfSymbolAsWritten(getSymbolOfDeclaration(node))
					error(memberNameNode, message, memberName, className)
					break
				}
			}
		}
	}
	checkObjectTypeForDuplicateDeclarations := func(node /* TODO(UnionType): TypeLiteralNode | InterfaceDeclaration */ any) {
		names := make(map[string]bool)
		for _, member := range node.members {
			if member.kind == SyntaxKindPropertySignature {
				var memberName string
				name := member.name
				switch name.kind {
				case SyntaxKindStringLiteral:
					fallthrough // TODO: merge cases
				case SyntaxKindNumericLiteral:
					memberName = name.text
					break
				case SyntaxKindIdentifier:
					memberName = idText(name)
					break
				default:
					continue
				}
				if names.get(memberName) {
					error(getNameOfDeclaration(member.symbol.valueDeclaration), Diagnostics.Duplicate_identifier_0, memberName)
					error(member.name, Diagnostics.Duplicate_identifier_0, memberName)
				} else {
					names.set(memberName, true)
				}
			}
		}
	}
	checkTypeForDuplicateIndexSignatures := func(node /* TODO(UnionType): ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode */ any) {
		if node.kind == SyntaxKindInterfaceDeclaration {
			nodeSymbol := getSymbolOfDeclaration(node)
			if nodeSymbol.declarations && nodeSymbol.declarations.length > 0 && /* TODO(ElementAccessExpression): nodeSymbol.declarations[0] */ TODO != node {
				return
			}
		}
		indexSymbol := getIndexSymbol(getSymbolOfDeclaration(node))
		if indexSymbol.declarations {
			indexSignatureMap := make(map[TypeId] /* TODO(TypeLiteral): { type: Type; declarations: IndexSignatureDeclaration[]; } */ any)
			for _, declaration := range indexSymbol.declarations {
				if declaration.parameters.length == 1 && /* TODO(ElementAccessExpression): declaration.parameters[0] */ TODO.type_ {
					forEachType(getTypeFromTypeNode( /* TODO(ElementAccessExpression): declaration.parameters[0] */ TODO.type_), func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
						entry := indexSignatureMap.get(getTypeId(type_))
						if entry {
							entry.declarations.push(declaration)
						} else {
							indexSignatureMap.set(getTypeId(type_) /* TODO(ObjectLiteralExpression): { type, declarations: [declaration] } */, TODO)
						}
					})
				}
			}
			indexSignatureMap.forEach(func(entry /* TODO inferred type { type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type; declarations: import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration[]; } */ TODO) {
				if entry.declarations.length > 1 {
					for _, declaration := range entry.declarations {
						error(declaration, Diagnostics.Duplicate_index_signature_for_type_0, typeToString(entry.type_))
					}
				}
			})
		}
	}
	checkPropertyDeclaration := func(node /* TODO(UnionType): PropertyDeclaration | PropertySignature */ any) {
		if !checkGrammarModifiers(node) && !checkGrammarProperty(node) {
			checkGrammarComputedPropertyName(node.name)
		}
		checkVariableLikeDeclaration(node)
		setNodeLinksForPrivateIdentifierScope(node)
		if hasSyntacticModifier(node, ModifierFlagsAbstract) && node.kind == SyntaxKindPropertyDeclaration && node.initializer {
			error(node, Diagnostics.Property_0_cannot_have_an_initializer_because_it_is_marked_abstract, declarationNameToString(node.name))
		}
	}
	checkPropertySignature := func(node PropertySignature) {
		if isPrivateIdentifier(node.name) {
			error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		}
		return checkPropertyDeclaration(node)
	}
	checkMethodDeclaration := func(node /* TODO(UnionType): MethodDeclaration | MethodSignature */ any) {
		if !checkGrammarMethod(node) {
			checkGrammarComputedPropertyName(node.name)
		}
		if isMethodDeclaration(node) && node.asteriskToken && isIdentifier(node.name) && idText(node.name) == "constructor" {
			error(node.name, Diagnostics.Class_constructor_may_not_be_a_generator)
		}
		checkFunctionOrMethodDeclaration(node)
		if hasSyntacticModifier(node, ModifierFlagsAbstract) && node.kind == SyntaxKindMethodDeclaration && node.body {
			error(node, Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, declarationNameToString(node.name))
		}
		if isPrivateIdentifier(node.name) && !getContainingClass(node) {
			error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		}
		setNodeLinksForPrivateIdentifierScope(node)
	}
	setNodeLinksForPrivateIdentifierScope := func(node /* TODO(UnionType): PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration */ any) {
		if isPrivateIdentifier(node.name) {
			if languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !useDefineForClassFields {
				/* TODO(ForStatement): for (let lexicalScope = getEnclosingBlockScopeContainer(node); !!lexicalScope; lexicalScope = getEnclosingBlockScopeContainer(lexicalScope)) {                     getNodeLinks(lexicalScope).flags |= NodeCheckFlags.ContainsClassWithPrivateIdentifiers;                 } */
				if isClassExpression(node.parent) {
					enclosingIterationStatement := getEnclosingIterationStatement(node.parent)
					if enclosingIterationStatement {
						getNodeLinks(node.name).flags |= NodeCheckFlagsBlockScopedBindingInLoop
						getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
					}
				}
			}
		}
	}
	checkClassStaticBlockDeclaration := func(node ClassStaticBlockDeclaration) {
		checkGrammarModifiers(node)
		forEachChild(node, checkSourceElement)
	}
	checkConstructorDeclaration := func(node ConstructorDeclaration) {
		checkSignatureDeclaration(node)
		if !checkGrammarConstructorTypeParameters(node) {
			checkGrammarConstructorTypeAnnotation(node)
		}
		checkSourceElement(node.body)
		symbol := getSymbolOfDeclaration(node)
		firstDeclaration := getDeclarationOfKind(symbol, node.kind)
		if node == firstDeclaration {
			checkFunctionOrConstructorSymbol(symbol)
		}
		if nodeIsMissing(node.body) {
			return
		}
		addLazyDiagnostic(checkConstructorDeclarationDiagnostics)
		return
		isInstancePropertyWithInitializerOrPrivateIdentifierProperty := func(n Node) bool {
			if isPrivateIdentifierClassElementDeclaration(n) {
				return true
			}
			return n.kind == SyntaxKindPropertyDeclaration && !isStatic(n) && !!(n).initializer
		}
		checkConstructorDeclarationDiagnostics := func() {
			containingClassDecl := node.parent
			if getClassExtendsHeritageElement(containingClassDecl) {
				captureLexicalThis(node.parent, containingClassDecl)
				classExtendsNull := classDeclarationExtendsNull(containingClassDecl)
				superCall := findFirstSuperCall(node.body)
				if superCall {
					if classExtendsNull {
						error(superCall, Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null)
					}
					superCallShouldBeRootLevel := !emitStandardClassFields && (some(node.parent.members, isInstancePropertyWithInitializerOrPrivateIdentifierProperty) || some(node.parameters, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO) /* TODO inferred type boolean */ TODO {
						return hasSyntacticModifier(p, ModifierFlagsParameterPropertyModifier)
					}))
					if superCallShouldBeRootLevel {
						if !superCallIsRootLevelInConstructor(superCall, node.body) {
							error(superCall, Diagnostics.A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers)
						} else {
							var superCallStatement *ExpressionStatement
							for _, statement := range node.body.statements {
								if isExpressionStatement(statement) && isSuperCall(skipOuterExpressions(statement.expression)) {
									superCallStatement = statement
									break
								}
								if nodeImmediatelyReferencesSuperOrThis(statement) {
									break
								}
							}
							if superCallStatement == nil {
								error(node, Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers)
							}
						}
					}
				} else if !classExtendsNull {
					error(node, Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call)
				}
			}
		}
	}
	superCallIsRootLevelInConstructor := func(superCall Node, body Block) /* TODO inferred type boolean */ TODO {
		superCallParent := walkUpParenthesizedExpressions(superCall.parent)
		return isExpressionStatement(superCallParent) && superCallParent.parent == body
	}
	nodeImmediatelyReferencesSuperOrThis := func(node Node) bool {
		if node.kind == SyntaxKindSuperKeyword || node.kind == SyntaxKindThisKeyword {
			return true
		}
		if isThisContainerOrFunctionBlock(node) {
			return false
		}
		return !!forEachChild(node, nodeImmediatelyReferencesSuperOrThis)
	}
	checkAccessorDeclaration := func(node AccessorDeclaration) {
		if isIdentifier(node.name) && idText(node.name) == "constructor" && isClassLike(node.parent) {
			error(node.name, Diagnostics.Class_constructor_may_not_be_an_accessor)
		}
		addLazyDiagnostic(checkAccessorDeclarationDiagnostics)
		checkSourceElement(node.body)
		setNodeLinksForPrivateIdentifierScope(node)
		checkAccessorDeclarationDiagnostics := func() {
			if !checkGrammarFunctionLikeDeclaration(node) && !checkGrammarAccessor(node) {
				checkGrammarComputedPropertyName(node.name)
			}
			checkDecorators(node)
			checkSignatureDeclaration(node)
			if node.kind == SyntaxKindGetAccessor {
				if !(node.flags & NodeFlagsAmbient) && nodeIsPresent(node.body) && (node.flags & NodeFlagsHasImplicitReturn) {
					if !(node.flags & NodeFlagsHasExplicitReturn) {
						error(node.name, Diagnostics.A_get_accessor_must_return_a_value)
					}
				}
			}
			if node.name.kind == SyntaxKindComputedPropertyName {
				checkComputedPropertyName(node.name)
			}
			if hasBindableName(node) {
				symbol := getSymbolOfDeclaration(node)
				getter := getDeclarationOfKind(symbol, SyntaxKindGetAccessor)
				setter := getDeclarationOfKind(symbol, SyntaxKindSetAccessor)
				if getter && setter && !(getNodeCheckFlags(getter) & NodeCheckFlagsTypeChecked) {
					getNodeLinks(getter).flags |= NodeCheckFlagsTypeChecked
					getterFlags := getEffectiveModifierFlags(getter)
					setterFlags := getEffectiveModifierFlags(setter)
					if (getterFlags & ModifierFlagsAbstract) != (setterFlags & ModifierFlagsAbstract) {
						error(getter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract)
						error(setter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract)
					}
					if ((getterFlags & ModifierFlagsProtected) && !(setterFlags & (ModifierFlagsProtected | ModifierFlagsPrivate))) || ((getterFlags & ModifierFlagsPrivate) && !(setterFlags & ModifierFlagsPrivate)) {
						error(getter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter)
						error(setter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter)
					}
				}
			}
			returnType := getTypeOfAccessors(getSymbolOfDeclaration(node))
			if node.kind == SyntaxKindGetAccessor {
				checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType)
			}
		}
	}
	checkMissingDeclaration := func(node Node) {
		checkDecorators(node)
	}
	getEffectiveTypeArgumentAtIndex := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments */ any, typeParameters []TypeParameter, index number) Type {
		if node.typeArguments && index < node.typeArguments.length {
			return getTypeFromTypeNode( /* TODO(ElementAccessExpression): node.typeArguments[index] */ TODO)
		}
		return /* TODO(ElementAccessExpression): getEffectiveTypeArguments(node, typeParameters)[index] */ TODO
	}
	getEffectiveTypeArguments := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) []Type {
		return fillMissingTypeArguments(map_(node.typeArguments, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(node))
	}
	checkTypeArgumentConstraints := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) bool {
		var typeArguments /* TODO(ArrayType): Type[] */ any
		var mapper *TypeMapper
		result := true
		/* TODO(ForStatement): for (let i = 0; i < typeParameters.length; i++) {             const constraint = getConstraintOfTypeParameter(typeParameters[i]);             if (constraint) {                 if (!typeArguments) {                     typeArguments = getEffectiveTypeArguments(node, typeParameters);                     mapper = createTypeMapper(typeParameters, typeArguments);                 }                 result = result && checkTypeAssignableTo(                     typeArguments[i],                     instantiateType(constraint, mapper),                     node.typeArguments![i],                     Diagnostics.Type_0_does_not_satisfy_the_constraint_1,                 );             }         } */
		return result
	}
	getTypeParametersForTypeAndSymbol := func(type_ Type, symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
		if !isErrorType(type_) {
			return symbol.flags&SymbolFlagsTypeAlias && getSymbolLinks(symbol).typeParameters || ( /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).target.localTypeParameters : undefined */ TODO)
		}
		return nil
	}
	getTypeParametersForTypeReferenceOrImport := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
		type_ := getTypeFromTypeNode(node)
		if !isErrorType(type_) {
			symbol := getNodeLinks(node).resolvedSymbol
			if symbol {
				return getTypeParametersForTypeAndSymbol(type_, symbol)
			}
		}
		return nil
	}
	checkTypeReferenceNode := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments */ any) {
		checkGrammarTypeArguments(node, node.typeArguments)
		if node.kind == SyntaxKindTypeReference && !isInJSFile(node) && !isInJSDoc(node) && node.typeArguments && node.typeName.end != node.typeArguments.pos {
			sourceFile := getSourceFileOfNode(node)
			if scanTokenAtPosition(sourceFile, node.typeName.end) == SyntaxKindDotToken {
				grammarErrorAtPos(node, skipTrivia(sourceFile.text, node.typeName.end), 1, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments)
			}
		}
		forEach(node.typeArguments, checkSourceElement)
		checkTypeReferenceOrImport(node)
	}
	checkTypeReferenceOrImport := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) {
		type_ := getTypeFromTypeNode(node)
		if !isErrorType(type_) {
			if node.typeArguments {
				addLazyDiagnostic(func() {
					typeParameters := getTypeParametersForTypeReferenceOrImport(node)
					if typeParameters {
						checkTypeArgumentConstraints(node, typeParameters)
					}
				})
			}
			symbol := getNodeLinks(node).resolvedSymbol
			if symbol {
				if some(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
					return isTypeDeclaration(d) && !!(d.flags & NodeFlagsDeprecated)
				}) {
					addDeprecatedSuggestion(getDeprecatedSuggestionNode(node), symbol.declarations, symbol.escapedName)
				}
			}
		}
	}
	getTypeArgumentConstraint := func(node TypeNode) *Type {
		typeReferenceNode := tryCast(node.parent, isTypeReferenceType)
		if !typeReferenceNode {
			return nil
		}
		typeParameters := getTypeParametersForTypeReferenceOrImport(typeReferenceNode)
		if !typeParameters {
			return nil
		}
		constraint := getConstraintOfTypeParameter( /* TODO(ElementAccessExpression): typeParameters[typeReferenceNode.typeArguments!.indexOf(node)] */ TODO)
		return constraint && instantiateType(constraint, createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReferenceNode, typeParameters)))
	}
	checkTypeQuery := func(node TypeQueryNode) {
		getTypeFromTypeQueryNode(node)
	}
	checkTypeLiteral := func(node TypeLiteralNode) {
		forEach(node.members, checkSourceElement)
		addLazyDiagnostic(checkTypeLiteralDiagnostics)
		checkTypeLiteralDiagnostics := func() {
			type_ := getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node)
			checkIndexConstraints(type_, type_.symbol)
			checkTypeForDuplicateIndexSignatures(node)
			checkObjectTypeForDuplicateDeclarations(node)
		}
	}
	checkArrayType := func(node ArrayTypeNode) {
		checkSourceElement(node.elementType)
	}
	checkTupleType := func(node TupleTypeNode) {
		seenOptionalElement := false
		seenRestElement := false
		for _, e := range node.elements {
			flags := getTupleElementFlags(e)
			if flags & ElementFlagsVariadic {
				type_ := getTypeFromTypeNode((e).type_)
				if !isArrayLikeType(type_) {
					error(e, Diagnostics.A_rest_element_type_must_be_an_array_type)
					break
				}
				if isArrayType(type_) || isTupleType(type_) && type_.target.combinedFlags&ElementFlagsRest {
					flags |= ElementFlagsRest
				}
			}
			if flags & ElementFlagsRest {
				if seenRestElement {
					grammarErrorOnNode(e, Diagnostics.A_rest_element_cannot_follow_another_rest_element)
					break
				}
				seenRestElement = true
			} else if flags & ElementFlagsOptional {
				if seenRestElement {
					grammarErrorOnNode(e, Diagnostics.An_optional_element_cannot_follow_a_rest_element)
					break
				}
				seenOptionalElement = true
			} else if flags&ElementFlagsRequired && seenOptionalElement {
				grammarErrorOnNode(e, Diagnostics.A_required_element_cannot_follow_an_optional_element)
				break
			}
		}
		forEach(node.elements, checkSourceElement)
		getTypeFromTypeNode(node)
	}
	checkUnionOrIntersectionType := func(node UnionOrIntersectionTypeNode) {
		forEach(node.types, checkSourceElement)
		getTypeFromTypeNode(node)
	}
	checkIndexedAccessIndexType := func(type_ Type, accessNode /* TODO(UnionType): IndexedAccessTypeNode | ElementAccessExpression */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !(type_.flags & TypeFlagsIndexedAccess) {
			return type_
		}
		objectType := (type_).objectType
		indexType := (type_).indexType
		objectIndexType := /* TODO(ConditionalExpression): isGenericMappedType(objectType) && getMappedTypeNameTypeKind(objectType) === MappedTypeNameTypeKind.Remapping             ? getIndexTypeForMappedType(objectType, IndexFlags.None)             : getIndexType(objectType, IndexFlags.None) */ TODO
		hasNumberIndexInfo := !!getIndexInfoOfType(objectType, numberType)
		if everyType(indexType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return isTypeAssignableTo(t, objectIndexType) || hasNumberIndexInfo && isApplicableIndexType(t, numberType)
		}) {
			if accessNode.kind == SyntaxKindElementAccessExpression && isAssignmentTarget(accessNode) && getObjectFlags(objectType)&ObjectFlagsMapped && getMappedTypeModifiers(objectType)&MappedTypeModifiersIncludeReadonly {
				error(accessNode, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType))
			}
			return type_
		}
		if isGenericObjectType(objectType) {
			propertyName := getPropertyNameFromIndex(indexType, accessNode)
			if propertyName {
				propertySymbol := forEachType(getApparentType(objectType), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
					return getPropertyOfType(t, propertyName)
				})
				if propertySymbol && getDeclarationModifierFlagsFromSymbol(propertySymbol)&ModifierFlagsNonPublicAccessibilityModifier {
					error(accessNode, Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, unescapeLeadingUnderscores(propertyName))
					return errorType
				}
			}
		}
		error(accessNode, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType))
		return errorType
	}
	checkIndexedAccessType := func(node IndexedAccessTypeNode) {
		checkSourceElement(node.objectType)
		checkSourceElement(node.indexType)
		checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node)
	}
	checkMappedType := func(node MappedTypeNode) {
		checkGrammarMappedType(node)
		checkSourceElement(node.typeParameter)
		checkSourceElement(node.nameType)
		checkSourceElement(node.type_)
		if !node.type_ {
			reportImplicitAny(node, anyType)
		}
		type_ := getTypeFromMappedTypeNode(node)
		nameType := getNameTypeFromMappedType(type_)
		if nameType {
			checkTypeAssignableTo(nameType, stringNumberSymbolType, node.nameType)
		} else {
			constraintType := getConstraintTypeFromMappedType(type_)
			checkTypeAssignableTo(constraintType, stringNumberSymbolType, getEffectiveConstraintOfTypeParameter(node.typeParameter))
		}
	}
	checkGrammarMappedType := func(node MappedTypeNode) /* TODO inferred type boolean | undefined */ TODO {
		if node.members.length {
			return grammarErrorOnNode( /* TODO(ElementAccessExpression): node.members[0] */ TODO, Diagnostics.A_mapped_type_may_not_declare_properties_or_methods)
		}
	}
	checkThisType := func(node ThisTypeNode) {
		getTypeFromThisTypeNode(node)
	}
	checkTypeOperator := func(node TypeOperatorNode) {
		checkGrammarTypeOperatorNode(node)
		checkSourceElement(node.type_)
	}
	checkConditionalType := func(node ConditionalTypeNode) {
		forEachChild(node, checkSourceElement)
	}
	checkInferType := func(node InferTypeNode) {
		if !findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
			return n.parent && n.parent.kind == SyntaxKindConditionalType && (n.parent).extendsType == n
		}) {
			grammarErrorOnNode(node, Diagnostics.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type)
		}
		checkSourceElement(node.typeParameter)
		symbol := getSymbolOfDeclaration(node.typeParameter)
		if symbol.declarations && symbol.declarations.length > 1 {
			links := getSymbolLinks(symbol)
			if !links.typeParametersChecked {
				links.typeParametersChecked = true
				typeParameter := getDeclaredTypeOfTypeParameter(symbol)
				var declarations []TypeParameterDeclaration = getDeclarationsOfKind(symbol, SyntaxKindTypeParameter)
				if !areTypeParametersIdentical(declarations /* TODO(ArrayLiteralExpression): [typeParameter] */, TODO, func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration[] */ TODO {
					return /* TODO(ArrayLiteralExpression): [decl] */ TODO
				}) {
					name := symbolToString(symbol)
					for _, declaration := range declarations {
						error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_constraints, name)
					}
				}
			}
		}
		registerForUnusedIdentifiersCheck(node)
	}
	checkTemplateLiteralType := func(node TemplateLiteralTypeNode) {
		for _, span := range node.templateSpans {
			checkSourceElement(span.type_)
			type_ := getTypeFromTypeNode(span.type_)
			checkTypeAssignableTo(type_, templateConstraintType, span.type_)
		}
		getTypeFromTypeNode(node)
	}
	checkImportType := func(node ImportTypeNode) {
		checkSourceElement(node.argument)
		if node.attributes {
			getResolutionModeOverride(node.attributes, grammarErrorOnNode)
		}
		checkTypeReferenceOrImport(node)
	}
	checkNamedTupleMember := func(node NamedTupleMember) {
		if node.dotDotDotToken && node.questionToken {
			grammarErrorOnNode(node, Diagnostics.A_tuple_member_cannot_be_both_optional_and_rest)
		}
		if node.type_.kind == SyntaxKindOptionalType {
			grammarErrorOnNode(node.type_, Diagnostics.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type)
		}
		if node.type_.kind == SyntaxKindRestType {
			grammarErrorOnNode(node.type_, Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type)
		}
		checkSourceElement(node.type_)
		getTypeFromTypeNode(node)
	}
	isPrivateWithinAmbient := func(node Node) bool {
		return (hasEffectiveModifier(node, ModifierFlagsPrivate) || isPrivateIdentifierClassElementDeclaration(node)) && !!(node.flags & NodeFlagsAmbient)
	}
	getEffectiveDeclarationFlags := func(n Declaration, flagsToCheck ModifierFlags) ModifierFlags {
		flags := getCombinedModifierFlagsCached(n)
		if n.parent.kind != SyntaxKindInterfaceDeclaration && n.parent.kind != SyntaxKindClassDeclaration && n.parent.kind != SyntaxKindClassExpression && n.flags&NodeFlagsAmbient {
			container := getEnclosingContainer(n)
			if (container && container.flags&NodeFlagsExportContext) && !(flags & ModifierFlagsAmbient) && !(isModuleBlock(n.parent) && isModuleDeclaration(n.parent.parent) && isGlobalScopeAugmentation(n.parent.parent)) {
				flags |= ModifierFlagsExport
			}
			flags |= ModifierFlagsAmbient
		}
		return flags & flagsToCheck
	}
	checkFunctionOrConstructorSymbol := func(symbol Symbol) {
		addLazyDiagnostic(func() {
			return checkFunctionOrConstructorSymbolWorker(symbol)
		})
	}
	checkFunctionOrConstructorSymbolWorker := func(symbol Symbol) {
		getCanonicalOverload := func(overloads []Declaration, implementation *FunctionLikeDeclaration) Declaration {
			implementationSharesContainerWithFirstOverload := implementation != nil && implementation.parent == /* TODO(ElementAccessExpression): overloads[0] */ TODO.parent
			return /* TODO(ConditionalExpression): implementationSharesContainerWithFirstOverload ? implementation : overloads[0] */ TODO
		}
		checkFlagAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, flagsToCheck ModifierFlags, someOverloadFlags ModifierFlags, allOverloadFlags ModifierFlags) {
			someButNotAllOverloadFlags := /* TODO(CaretToken): ^ */ /* TODO(BinaryExpression): someOverloadFlags ^ allOverloadFlags */ TODO
			if someButNotAllOverloadFlags != 0 {
				canonicalFlags := getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck)
				group(overloads, func(o /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type string */ TODO {
					return getSourceFileOfNode(o).fileName
				}).forEach(func(overloadsInFile /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration[] */ TODO) {
					canonicalFlagsForFile := getEffectiveDeclarationFlags(getCanonicalOverload(overloadsInFile, implementation), flagsToCheck)
					for _, o := range overloadsInFile {
						deviation := /* TODO(CaretToken): ^ */ /* TODO(BinaryExpression): getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags */ TODO
						deviationInFile := /* TODO(CaretToken): ^ */ /* TODO(BinaryExpression): getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlagsForFile */ TODO
						if deviationInFile & ModifierFlagsExport {
							error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported)
						} else if deviationInFile & ModifierFlagsAmbient {
							error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient)
						} else if deviation & (ModifierFlagsPrivate | ModifierFlagsProtected) {
							error(getNameOfDeclaration(o) || o, Diagnostics.Overload_signatures_must_all_be_public_private_or_protected)
						} else if deviation & ModifierFlagsAbstract {
							error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract)
						}
					}
				})
			}
		}
		checkQuestionTokenAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, someHaveQuestionToken bool, allHaveQuestionToken bool) {
			if someHaveQuestionToken != allHaveQuestionToken {
				canonicalHasQuestionToken := hasQuestionToken(getCanonicalOverload(overloads, implementation))
				forEach(overloads, func(o /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
					deviation := hasQuestionToken(o) != canonicalHasQuestionToken
					if deviation {
						error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_optional_or_required)
					}
				})
			}
		}
		var flagsToCheck ModifierFlags = ModifierFlagsExport | ModifierFlagsAmbient | ModifierFlagsPrivate | ModifierFlagsProtected | ModifierFlagsAbstract
		var someNodeFlags ModifierFlags = ModifierFlagsNone
		allNodeFlags := flagsToCheck
		someHaveQuestionToken := false
		allHaveQuestionToken := true
		hasOverloads := false
		var bodyDeclaration *FunctionLikeDeclaration
		var lastSeenNonAmbientDeclaration *FunctionLikeDeclaration
		var previousDeclaration *SignatureDeclaration
		declarations := symbol.declarations
		isConstructor := (symbol.flags & SymbolFlagsConstructor) != 0
		reportImplementationExpectedError := func(node SignatureDeclaration) {
			if node.name && nodeIsMissing(node.name) {
				return
			}
			seen := false
			subsequentNode := forEachChild(node.parent, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO {
				if seen {
					return c
				} else {
					seen = c == node
				}
			})
			if subsequentNode && subsequentNode.pos == node.end {
				if subsequentNode.kind == node.kind {
					var errorNode Node = (subsequentNode).name || subsequentNode
					subsequentName := (subsequentNode).name
					if node.name && subsequentName && (isPrivateIdentifier(node.name) && isPrivateIdentifier(subsequentName) && node.name.escapedText == subsequentName.escapedText || isComputedPropertyName(node.name) && isComputedPropertyName(subsequentName) && isTypeIdenticalTo(checkComputedPropertyName(node.name), checkComputedPropertyName(subsequentName)) || isPropertyNameLiteral(node.name) && isPropertyNameLiteral(subsequentName) && getEscapedTextOfIdentifierOrLiteral(node.name) == getEscapedTextOfIdentifierOrLiteral(subsequentName)) {
						reportError := (node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature) && isStatic(node) != isStatic(subsequentNode)
						if reportError {
							diagnostic := /* TODO(ConditionalExpression): isStatic(node) ? Diagnostics.Function_overload_must_be_static : Diagnostics.Function_overload_must_not_be_static */ TODO
							error(errorNode, diagnostic)
						}
						return
					}
					if nodeIsPresent((subsequentNode).body) {
						error(errorNode, Diagnostics.Function_implementation_name_must_be_0, declarationNameToString(node.name))
						return
					}
				}
			}
			var errorNode Node = node.name || node
			if isConstructor {
				error(errorNode, Diagnostics.Constructor_implementation_is_missing)
			} else {
				if hasSyntacticModifier(node, ModifierFlagsAbstract) {
					error(errorNode, Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive)
				} else {
					error(errorNode, Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration)
				}
			}
		}
		duplicateFunctionDeclaration := false
		multipleConstructorImplementation := false
		hasNonAmbientClass := false
		functionDeclarations := /* TODO(ArrayLiteralExpression): [] */ TODO
		if declarations {
			for _, current := range declarations {
				node := current
				inAmbientContext := node.flags & NodeFlagsAmbient
				inAmbientContextOrInterface := node.parent && (node.parent.kind == SyntaxKindInterfaceDeclaration || node.parent.kind == SyntaxKindTypeLiteral) || inAmbientContext
				if inAmbientContextOrInterface {
					previousDeclaration = nil
				}
				if (node.kind == SyntaxKindClassDeclaration || node.kind == SyntaxKindClassExpression) && !inAmbientContext {
					hasNonAmbientClass = true
				}
				if node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature || node.kind == SyntaxKindConstructor {
					functionDeclarations.push(node)
					currentNodeFlags := getEffectiveDeclarationFlags(node, flagsToCheck)
					someNodeFlags |= currentNodeFlags
					allNodeFlags &= currentNodeFlags
					someHaveQuestionToken = someHaveQuestionToken || hasQuestionToken(node)
					allHaveQuestionToken = allHaveQuestionToken && hasQuestionToken(node)
					bodyIsPresent := nodeIsPresent((node).body)
					if bodyIsPresent && bodyDeclaration {
						if isConstructor {
							multipleConstructorImplementation = true
						} else {
							duplicateFunctionDeclaration = true
						}
					} else if previousDeclaration.parent == node.parent && previousDeclaration.end != node.pos {
						reportImplementationExpectedError(previousDeclaration)
					}
					if bodyIsPresent {
						if !bodyDeclaration {
							bodyDeclaration = node
						}
					} else {
						hasOverloads = true
					}
					previousDeclaration = node
					if !inAmbientContextOrInterface {
						lastSeenNonAmbientDeclaration = node
					}
				}
				if isInJSFile(current) && isFunctionLike(current) && current.jsDoc {
					hasOverloads = length(getJSDocOverloadTags(current)) > 0
				}
			}
		}
		if multipleConstructorImplementation {
			forEach(functionDeclarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
				error(declaration, Diagnostics.Multiple_constructor_implementations_are_not_allowed)
			})
		}
		if duplicateFunctionDeclaration {
			forEach(functionDeclarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
				error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Duplicate_function_implementation)
			})
		}
		if hasNonAmbientClass && !isConstructor && symbol.flags&SymbolFlagsFunction && declarations {
			relatedDiagnostics := filter(declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
				return d.kind == SyntaxKindClassDeclaration
			}).map_(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
				return createDiagnosticForNode(d, Diagnostics.Consider_adding_a_declare_modifier_to_this_class)
			})
			forEach(declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
				diagnostic := /* TODO(ConditionalExpression): declaration.kind === SyntaxKind.ClassDeclaration                     ? Diagnostics.Class_declaration_cannot_implement_overload_list_for_0                     : declaration.kind === SyntaxKind.FunctionDeclaration                     ? Diagnostics.Function_with_bodies_can_only_merge_with_classes_that_are_ambient                     : undefined */ TODO
				if diagnostic {
					addRelatedInfo(error(getNameOfDeclaration(declaration) || declaration, diagnostic, symbolName(symbol)) /* TODO(SpreadElement): ...relatedDiagnostics */, TODO)
				}
			})
		}
		if lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body && !hasSyntacticModifier(lastSeenNonAmbientDeclaration, ModifierFlagsAbstract) && !lastSeenNonAmbientDeclaration.questionToken {
			reportImplementationExpectedError(lastSeenNonAmbientDeclaration)
		}
		if hasOverloads {
			if declarations {
				checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags)
				checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken)
			}
			if bodyDeclaration {
				signatures := getSignaturesOfSymbol(symbol)
				bodySignature := getSignatureFromDeclaration(bodyDeclaration)
				for _, signature := range signatures {
					if !isImplementationCompatibleWithOverload(bodySignature, signature) {
						errorNode := /* TODO(ConditionalExpression): signature.declaration && isJSDocSignature(signature.declaration)                             ? (signature.declaration.parent as JSDocOverloadTag | JSDocCallbackTag).tagName                             : signature.declaration */ TODO
						addRelatedInfo(error(errorNode, Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature), createDiagnosticForNode(bodyDeclaration, Diagnostics.The_implementation_signature_is_declared_here))
						break
					}
				}
			}
		}
	}
	checkExportsOnMergedDeclarations := func(node Declaration) {
		addLazyDiagnostic(func() {
			return checkExportsOnMergedDeclarationsWorker(node)
		})
	}
	checkExportsOnMergedDeclarationsWorker := func(node Declaration) {
		symbol := node.localSymbol
		if !symbol {
			symbol = getSymbolOfDeclaration(node)
			if !symbol.exportSymbol {
				return
			}
		}
		if getDeclarationOfKind(symbol, node.kind) != node {
			return
		}
		exportedDeclarationSpaces := DeclarationSpacesNone
		nonExportedDeclarationSpaces := DeclarationSpacesNone
		defaultExportedDeclarationSpaces := DeclarationSpacesNone
		for _, d := range symbol.declarations {
			declarationSpaces := getDeclarationSpaces(d)
			effectiveDeclarationFlags := getEffectiveDeclarationFlags(d, ModifierFlagsExport|ModifierFlagsDefault)
			if effectiveDeclarationFlags & ModifierFlagsExport {
				if effectiveDeclarationFlags & ModifierFlagsDefault {
					defaultExportedDeclarationSpaces |= declarationSpaces
				} else {
					exportedDeclarationSpaces |= declarationSpaces
				}
			} else {
				nonExportedDeclarationSpaces |= declarationSpaces
			}
		}
		nonDefaultExportedDeclarationSpaces := exportedDeclarationSpaces | nonExportedDeclarationSpaces
		commonDeclarationSpacesForExportsAndLocals := exportedDeclarationSpaces & nonExportedDeclarationSpaces
		commonDeclarationSpacesForDefaultAndNonDefault := defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces
		if commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault {
			for _, d := range symbol.declarations {
				declarationSpaces := getDeclarationSpaces(d)
				name := getNameOfDeclaration(d)
				if declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault {
					error(name, Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, declarationNameToString(name))
				} else if declarationSpaces & commonDeclarationSpacesForExportsAndLocals {
					error(name, Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, declarationNameToString(name))
				}
			}
		}
		getDeclarationSpaces := func(decl Declaration) DeclarationSpaces {
			d := decl
			switch d.kind {
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeAliasDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocTypedefTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocCallbackTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocEnumTag:
				return DeclarationSpacesExportType
			case SyntaxKindModuleDeclaration:
				return /* TODO(ConditionalExpression): isAmbientModule(d as ModuleDeclaration) || getModuleInstanceState(d as ModuleDeclaration) !== ModuleInstanceState.NonInstantiated                         ? DeclarationSpaces.ExportNamespace | DeclarationSpaces.ExportValue                         : DeclarationSpaces.ExportNamespace */ TODO
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindEnumDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindEnumMember:
				return DeclarationSpacesExportType | DeclarationSpacesExportValue
			case SyntaxKindSourceFile:
				return DeclarationSpacesExportType | DeclarationSpacesExportValue | DeclarationSpacesExportNamespace
			case SyntaxKindExportAssignment:
				fallthrough // TODO: merge cases
			case SyntaxKindBinaryExpression:
				node := d
				expression := /* TODO(ConditionalExpression): isExportAssignment(node) ? node.expression : node.right */ TODO
				if !isEntityNameExpression(expression) {
					return DeclarationSpacesExportValue
				}
				d = expression
				fallthrough
			case SyntaxKindImportEqualsDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindNamespaceImport:
				fallthrough // TODO: merge cases
			case SyntaxKindImportClause:
				result := DeclarationSpacesNone
				target := resolveAlias(getSymbolOfDeclaration(d))
				forEach(target.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
					result |= getDeclarationSpaces(d)
				})
				return result
			case SyntaxKindVariableDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindBindingElement:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindImportSpecifier:
				fallthrough // TODO: merge cases
			case SyntaxKindIdentifier:
				return DeclarationSpacesExportValue
			case SyntaxKindMethodSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindPropertySignature:
				return DeclarationSpacesExportType
			default:
				return Debug.failBadSyntaxKind(d)
			}
		}
	}
	getAwaitedTypeOfPromise := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
		promisedType := getPromisedTypeOfPromise(type_, errorNode)
		return promisedType && getAwaitedType(promisedType, errorNode, diagnosticMessage /* TODO(SpreadElement): ...args */, TODO)
	}
	getPromisedTypeOfPromise := func(type_ Type, errorNode Node, thisTypeForErrorOut /* TODO(TypeLiteral): { value?: Type; } */ any) *Type {
		if isTypeAny(type_) {
			return nil
		}
		typeAsPromise := type_
		if typeAsPromise.promisedTypeOfPromise {
			return typeAsPromise.promisedTypeOfPromise
		}
		if isReferenceToType(type_, getGlobalPromiseType(false)) {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsPromise.promisedTypeOfPromise = getTypeArguments(type as GenericType)[0] */ TODO
		}
		if allTypesAssignableToKind(getBaseConstraintOrType(type_), TypeFlagsPrimitive|TypeFlagsNever) {
			return nil
		}
		thenFunction := getTypeOfPropertyOfType(type_, "then")
		if isTypeAny(thenFunction) {
			return nil
		}
		thenSignatures := /* TODO(ConditionalExpression): thenFunction ? getSignaturesOfType(thenFunction, SignatureKind.Call) : emptyArray */ TODO
		if thenSignatures.length == 0 {
			if errorNode {
				error(errorNode, Diagnostics.A_promise_must_have_a_then_method)
			}
			return nil
		}
		var thisTypeForError *Type
		var candidates /* TODO(ArrayType): Signature[] */ any
		for _, thenSignature := range thenSignatures {
			thisType := getThisTypeOfSignature(thenSignature)
			if thisType && thisType != voidType && !isTypeRelatedTo(type_, thisType, subtypeRelation) {
				thisTypeForError = thisType
			} else {
				candidates = append(candidates, thenSignature)
			}
		}
		if !candidates {
			Debug.assertIsDefined(thisTypeForError)
			if thisTypeForErrorOut {
				thisTypeForErrorOut.value = thisTypeForError
			}
			if errorNode {
				error(errorNode, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type_), typeToString(thisTypeForError))
			}
			return nil
		}
		onfulfilledParameterType := getTypeWithFacts(getUnionType(map_(candidates, getTypeOfFirstParameterOfSignature)), TypeFactsNEUndefinedOrNull)
		if isTypeAny(onfulfilledParameterType) {
			return nil
		}
		onfulfilledParameterSignatures := getSignaturesOfType(onfulfilledParameterType, SignatureKindCall)
		if onfulfilledParameterSignatures.length == 0 {
			if errorNode {
				error(errorNode, Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback)
			}
			return nil
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsPromise.promisedTypeOfPromise = getUnionType(map(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature), UnionReduction.Subtype) */ TODO
	}
	checkAwaitedType := func(type_ Type, withAlias bool, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) Type {
		awaitedType := /* TODO(ConditionalExpression): withAlias ?             getAwaitedType(type, errorNode, diagnosticMessage, ...args) :             getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, ...args) */ TODO
		return awaitedType || errorType
	}
	isThenableType := func(type_ Type) bool {
		if allTypesAssignableToKind(getBaseConstraintOrType(type_), TypeFlagsPrimitive|TypeFlagsNever) {
			return false
		}
		thenFunction := getTypeOfPropertyOfType(type_, "then")
		return !!thenFunction && getSignaturesOfType(getTypeWithFacts(thenFunction, TypeFactsNEUndefinedOrNull), SignatureKindCall).length > 0
	}
	type AwaitedTypeInstantiation struct {
		_awaitedTypeBrand/* TODO(NeverKeyword): never */ any
		aliasSymbol        Symbol
		aliasTypeArguments []Type
	}
	isAwaitedTypeInstantiation := func(type_ Type) /* TODO(TypePredicate): type is AwaitedTypeInstantiation */ any {
		if type_.flags & TypeFlagsConditional {
			awaitedSymbol := getGlobalAwaitedSymbol(false)
			return !!awaitedSymbol && type_.aliasSymbol == awaitedSymbol && type_.aliasTypeArguments.length == 1
		}
		return false
	}
	unwrapAwaitedType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? mapType(type, unwrapAwaitedType) :             isAwaitedTypeInstantiation(type) ? type.aliasTypeArguments[0] :             type */ TODO
	}
	isAwaitedTypeNeeded := func(type_ Type) /* TODO inferred type boolean */ TODO {
		if isTypeAny(type_) || isAwaitedTypeInstantiation(type_) {
			return false
		}
		if isGenericObjectType(type_) {
			baseConstraint := getBaseConstraintOfType(type_)
			if /* TODO(ConditionalExpression): baseConstraint ?                     baseConstraint.flags & TypeFlags.AnyOrUnknown || isEmptyObjectType(baseConstraint) || someType(baseConstraint, isThenableType) :                     maybeTypeOfKind(type, TypeFlags.TypeVariable) */ TODO {
				return true
			}
		}
		return false
	}
	tryCreateAwaitedType := func(type_ Type) *Type {
		awaitedSymbol := getGlobalAwaitedSymbol(true)
		if awaitedSymbol {
			return getTypeAliasInstantiation(awaitedSymbol /* TODO(ArrayLiteralExpression): [unwrapAwaitedType(type)] */, TODO)
		}
		return nil
	}
	createAwaitedTypeIfNeeded := func(type_ Type) Type {
		if isAwaitedTypeNeeded(type_) {
			return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): tryCreateAwaitedType(type) ?? type */ TODO
		}
		Debug.assert(isAwaitedTypeInstantiation(type_) || getPromisedTypeOfPromise(type_) == nil, "type provided should not be a non-generic 'promise'-like.")
		return type_
	}
	getAwaitedType := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
		awaitedType := getAwaitedTypeNoAlias(type_, errorNode, diagnosticMessage /* TODO(SpreadElement): ...args */, TODO)
		return awaitedType && createAwaitedTypeIfNeeded(awaitedType)
	}
	getAwaitedTypeNoAlias := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
		if isTypeAny(type_) {
			return type_
		}
		if isAwaitedTypeInstantiation(type_) {
			return type_
		}
		typeAsAwaitable := type_
		if typeAsAwaitable.awaitedTypeOfType {
			return typeAsAwaitable.awaitedTypeOfType
		}
		if type_.flags & TypeFlagsUnion {
			if awaitedTypeStack.lastIndexOf(type_.id) >= 0 {
				if errorNode {
					error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method)
				}
				return nil
			}
			mapper := /* TODO(ConditionalExpression): errorNode ? (constituentType: Type) => getAwaitedTypeNoAlias(constituentType, errorNode, diagnosticMessage, ...args) : getAwaitedTypeNoAlias */ TODO
			awaitedTypeStack.push(type_.id)
			mapped := mapType(type_, mapper)
			awaitedTypeStack.pop()
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = mapped */ TODO
		}
		if isAwaitedTypeNeeded(type_) {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = type */ TODO
		}
		var thisTypeForErrorOut /* TODO(TypeLiteral): { value: Type | undefined; } */ any = /* TODO(ObjectLiteralExpression): { value: undefined } */ TODO
		promisedType := getPromisedTypeOfPromise(type_, nil, thisTypeForErrorOut)
		if promisedType {
			if type_.id == promisedType.id || awaitedTypeStack.lastIndexOf(promisedType.id) >= 0 {
				if errorNode {
					error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method)
				}
				return nil
			}
			awaitedTypeStack.push(type_.id)
			awaitedType := getAwaitedTypeNoAlias(promisedType, errorNode, diagnosticMessage /* TODO(SpreadElement): ...args */, TODO)
			awaitedTypeStack.pop()
			if !awaitedType {
				return nil
			}
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = awaitedType */ TODO
		}
		if isThenableType(type_) {
			if errorNode {
				Debug.assertIsDefined(diagnosticMessage)
				var chain *DiagnosticMessageChain
				if thisTypeForErrorOut.value {
					chain = chainDiagnosticMessages(chain, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type_), typeToString(thisTypeForErrorOut.value))
				}
				chain = chainDiagnosticMessages(chain, diagnosticMessage /* TODO(SpreadElement): ...args */, TODO)
				diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chain))
			}
			return nil
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = type */ TODO
	}
	checkAsyncFunctionReturnType := func(node /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode) {
		returnType := getTypeFromTypeNode(returnTypeNode)
		if languageVersion >= ScriptTargetES2015 {
			if isErrorType(returnType) {
				return
			}
			globalPromiseType := getGlobalPromiseType(true)
			if globalPromiseType != emptyGenericType && !isReferenceToType(returnType, globalPromiseType) {
				reportErrorForInvalidReturnType(Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0, returnTypeNode, returnTypeErrorLocation, typeToString(getAwaitedTypeNoAlias(returnType) || voidType))
				return
			}
		} else {
			markLinkedReferences(node, ReferenceHintAsyncFunction)
			if isErrorType(returnType) {
				return
			}
			promiseConstructorName := getEntityNameFromTypeNode(returnTypeNode)
			if promiseConstructorName == nil {
				reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, typeToString(returnType))
				return
			}
			promiseConstructorSymbol := resolveEntityName(promiseConstructorName, SymbolFlagsValue, true)
			promiseConstructorType := /* TODO(ConditionalExpression): promiseConstructorSymbol ? getTypeOfSymbol(promiseConstructorSymbol) : errorType */ TODO
			if isErrorType(promiseConstructorType) {
				if promiseConstructorName.kind == SyntaxKindIdentifier && promiseConstructorName.escapedText == "Promise" && getTargetType(returnType) == getGlobalPromiseType(false) {
					error(returnTypeErrorLocation, Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option)
				} else {
					reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName))
				}
				return
			}
			globalPromiseConstructorLikeType := getGlobalPromiseConstructorLikeType(true)
			if globalPromiseConstructorLikeType == emptyObjectType {
				reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName))
				return
			}
			headMessage := Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value
			errorInfo := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined */ TODO {
				return /* TODO(ConditionalExpression): returnTypeNode === returnTypeErrorLocation ? undefined : chainDiagnosticMessages(/*details* / undefined, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type) */ TODO
			}
			if !checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, returnTypeErrorLocation, headMessage, errorInfo) {
				return
			}
			rootName := promiseConstructorName && getFirstIdentifier(promiseConstructorName)
			collidingSymbol := getSymbol(node.locals, rootName.escapedText, SymbolFlagsValue)
			if collidingSymbol {
				error(collidingSymbol.valueDeclaration, Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions, idText(rootName), entityNameToString(promiseConstructorName))
				return
			}
		}
		checkAwaitedType(returnType, false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
		reportErrorForInvalidReturnType := func(message DiagnosticMessage, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode, typeName string) {
			if returnTypeNode == returnTypeErrorLocation {
				error(returnTypeErrorLocation, message, typeName)
			} else {
				diag := error(returnTypeErrorLocation, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type)
				addRelatedInfo(diag, createDiagnosticForNode(returnTypeNode, message, typeName))
			}
		}
	}
	checkGrammarDecorator := func(decorator Decorator) bool {
		sourceFile := getSourceFileOfNode(decorator)
		if !hasParseDiagnostics(sourceFile) {
			var node Expression = decorator.expression
			if isParenthesizedExpression(node) {
				return false
			}
			canHaveCallExpression := true
			var errorNode Node
			for true {
				if isExpressionWithTypeArguments(node) || isNonNullExpression(node) {
					node = node.expression
					continue
				}
				if isCallExpression(node) {
					if !canHaveCallExpression {
						errorNode = node
					}
					if node.questionDotToken {
						errorNode = node.questionDotToken
					}
					node = node.expression
					canHaveCallExpression = false
					continue
				}
				if isPropertyAccessExpression(node) {
					if node.questionDotToken {
						errorNode = node.questionDotToken
					}
					node = node.expression
					canHaveCallExpression = false
					continue
				}
				if !isIdentifier(node) {
					errorNode = node
				}
				break
			}
			if errorNode {
				addRelatedInfo(error(decorator.expression, Diagnostics.Expression_must_be_enclosed_in_parentheses_to_be_used_as_a_decorator), createDiagnosticForNode(errorNode, Diagnostics.Invalid_syntax_in_decorator))
				return true
			}
		}
		return false
	}
	checkDecorator := func(node Decorator) {
		checkGrammarDecorator(node)
		signature := getResolvedSignature(node)
		checkDeprecatedSignature(signature, node)
		returnType := getReturnTypeOfSignature(signature)
		if returnType.flags & TypeFlagsAny {
			return
		}
		decoratorSignature := getDecoratorCallSignature(node)
		if !decoratorSignature.resolvedReturnType {
			return
		}
		var headMessage DiagnosticMessage
		expectedReturnType := decoratorSignature.resolvedReturnType
		switch node.parent.kind {
		case SyntaxKindClassDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindClassExpression:
			headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1
			break
		case SyntaxKindPropertyDeclaration:
			if !legacyDecorators {
				headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1
				break
			}
			fallthrough
		case SyntaxKindParameter:
			headMessage = Diagnostics.Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any
			break
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1
			break
		default:
			return Debug.failBadSyntaxKind(node.parent)
		}
		checkTypeAssignableTo(returnType, expectedReturnType, node.expression, headMessage)
	}
	createCallSignature := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, thisParameter *Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number /*  = parameters.length */, flags SignatureFlags /*  = SignatureFlags.None */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		decl := factory.createFunctionTypeNode(nil, emptyArray, factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
		return createSignature(decl, typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
	}
	createFunctionType := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, thisParameter *Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number, flags SignatureFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		signature := createCallSignature(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
		return getOrCreateTypeFromSignature(signature)
	}
	createGetterFunctionType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return createFunctionType(nil, nil, emptyArray, type_)
	}
	createSetterFunctionType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		valueParam := createParameter("value", type_)
		return createFunctionType(nil, nil /* TODO(ArrayLiteralExpression): [valueParam] */, TODO, voidType)
	}
	getEntityNameForDecoratorMetadata := func(node *TypeNode) *EntityName {
		if node {
			switch node.kind {
			case SyntaxKindIntersectionType:
				fallthrough // TODO: merge cases
			case SyntaxKindUnionType:
				return getEntityNameForDecoratorMetadataFromTypeList((node).types)
			case SyntaxKindConditionalType:
				return getEntityNameForDecoratorMetadataFromTypeList( /* TODO(ArrayLiteralExpression): [(node as ConditionalTypeNode).trueType, (node as ConditionalTypeNode).falseType] */ TODO)
			case SyntaxKindParenthesizedType:
				fallthrough // TODO: merge cases
			case SyntaxKindNamedTupleMember:
				return getEntityNameForDecoratorMetadata((node).type_)
			case SyntaxKindTypeReference:
				return (node).typeName
			}
		}
	}
	getEntityNameForDecoratorMetadataFromTypeList := func(types []TypeNode) *EntityName {
		var commonEntityName *EntityName
		for _, typeNode := range types {
			for typeNode.kind == SyntaxKindParenthesizedType || typeNode.kind == SyntaxKindNamedTupleMember {
				typeNode = (typeNode).type_
			}
			if typeNode.kind == SyntaxKindNeverKeyword {
				continue
			}
			if !strictNullChecks && (typeNode.kind == SyntaxKindLiteralType && (typeNode).literal.kind == SyntaxKindNullKeyword || typeNode.kind == SyntaxKindUndefinedKeyword) {
				continue
			}
			individualEntityName := getEntityNameForDecoratorMetadata(typeNode)
			if !individualEntityName {
				return nil
			}
			if commonEntityName {
				if !isIdentifier(commonEntityName) || !isIdentifier(individualEntityName) || commonEntityName.escapedText != individualEntityName.escapedText {
					return nil
				}
			} else {
				commonEntityName = individualEntityName
			}
		}
		return commonEntityName
	}
	getParameterTypeNodeForDecoratorCheck := func(node ParameterDeclaration) *TypeNode {
		typeNode := getEffectiveTypeAnnotationNode(node)
		return /* TODO(ConditionalExpression): isRestParameter(node) ? getRestParameterElementType(typeNode) : typeNode */ TODO
	}
	checkDecorators := func(node Node) {
		if !canHaveDecorators(node) || !hasDecorators(node) || !node.modifiers || !nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent) {
			return
		}
		firstDecorator := find(node.modifiers, isDecorator)
		if !firstDecorator {
			return
		}
		if legacyDecorators {
			checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersDecorate)
			if node.kind == SyntaxKindParameter {
				checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersParam)
			}
		} else if languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators {
			checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersESDecorateAndRunInitializers)
			if isClassDeclaration(node) {
				if !node.name {
					checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
				} else {
					member := getFirstTransformableStaticClassElement(node)
					if member {
						checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
					}
				}
			} else if !isClassExpression(node) {
				if isPrivateIdentifier(node.name) && (isMethodDeclaration(node) || isAccessor(node) || isAutoAccessorPropertyDeclaration(node)) {
					checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
				}
				if isComputedPropertyName(node.name) {
					checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersPropKey)
				}
			}
		}
		markLinkedReferences(node, ReferenceHintDecorator)
		for _, modifier := range node.modifiers {
			if isDecorator(modifier) {
				checkDecorator(modifier)
			}
		}
	}
	checkFunctionDeclaration := func(node FunctionDeclaration) {
		addLazyDiagnostic(checkFunctionDeclarationDiagnostics)
		checkFunctionDeclarationDiagnostics := func() {
			checkFunctionOrMethodDeclaration(node)
			checkGrammarForGenerator(node)
			checkCollisionsForDeclarationName(node, node.name)
		}
	}
	checkJSDocTypeAliasTag := func(node /* TODO(UnionType): JSDocTypedefTag | JSDocCallbackTag */ any) {
		if !node.typeExpression {
			error(node.name, Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags)
		}
		if node.name {
			checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0)
		}
		checkSourceElement(node.typeExpression)
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
	}
	checkJSDocTemplateTag := func(node JSDocTemplateTag) {
		checkSourceElement(node.constraint)
		for _, tp := range node.typeParameters {
			checkSourceElement(tp)
		}
	}
	checkJSDocTypeTag := func(node JSDocTypeTag) {
		checkSourceElement(node.typeExpression)
	}
	checkJSDocSatisfiesTag := func(node JSDocSatisfiesTag) {
		checkSourceElement(node.typeExpression)
		host := getEffectiveJSDocHost(node)
		if host {
			tags := getAllJSDocTags(host, isJSDocSatisfiesTag)
			if length(tags) > 1 {
				/* TODO(ForStatement): for (let i = 1; i < length(tags); i++) {                     const tagName = tags[i].tagName;                     error(tagName, Diagnostics._0_tag_already_specified, idText(tagName));                 } */
			}
		}
	}
	checkJSDocLinkLikeTag := func(node /* TODO(UnionType): JSDocLink | JSDocLinkCode | JSDocLinkPlain */ any) {
		if node.name {
			resolveJSDocMemberName(node.name, true)
		}
	}
	checkJSDocParameterTag := func(node JSDocParameterTag) {
		checkSourceElement(node.typeExpression)
	}
	checkJSDocPropertyTag := func(node JSDocPropertyTag) {
		checkSourceElement(node.typeExpression)
	}
	checkJSDocFunctionType := func(node JSDocFunctionType) {
		addLazyDiagnostic(checkJSDocFunctionTypeImplicitAny)
		checkSignatureDeclaration(node)
		checkJSDocFunctionTypeImplicitAny := func() {
			if !node.type_ && !isJSDocConstructSignature(node) {
				reportImplicitAny(node, anyType)
			}
		}
	}
	checkJSDocThisTag := func(node JSDocThisTag) {
		host := getEffectiveJSDocHost(node)
		if host && isArrowFunction(host) {
			error(node.tagName, Diagnostics.An_arrow_function_cannot_have_a_this_parameter)
		}
	}
	checkJSDocImportTag := func(node JSDocImportTag) {
		checkImportAttributes(node)
	}
	checkJSDocImplementsTag := func(node JSDocImplementsTag) {
		classLike := getEffectiveJSDocHost(node)
		if !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) {
			error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName))
		}
	}
	checkJSDocAugmentsTag := func(node JSDocAugmentsTag) {
		classLike := getEffectiveJSDocHost(node)
		if !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) {
			error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName))
			return
		}
		augmentsTags := getJSDocTags(classLike).filter(isJSDocAugmentsTag)
		Debug.assert(augmentsTags.length > 0)
		if augmentsTags.length > 1 {
			error( /* TODO(ElementAccessExpression): augmentsTags[1] */ TODO, Diagnostics.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag)
		}
		name := getIdentifierFromEntityNameExpression(node.class.expression)
		extend := getClassExtendsHeritageElement(classLike)
		if extend {
			className := getIdentifierFromEntityNameExpression(extend.expression)
			if className && name.escapedText != className.escapedText {
				error(name, Diagnostics.JSDoc_0_1_does_not_match_the_extends_2_clause, idText(node.tagName), idText(name), idText(className))
			}
		}
	}
	checkJSDocAccessibilityModifiers := func(node /* TODO(UnionType): JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag */ any) {
		host := getJSDocHost(node)
		if host && isPrivateIdentifierClassElementDeclaration(host) {
			error(node, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier)
		}
	}
	// OVERLOAD: getIdentifierFromEntityNameExpression := func(node /* TODO(UnionType): Identifier | PropertyAccessExpression */ any) /* TODO(UnionType): Identifier | PrivateIdentifier */ any
	// OVERLOAD: getIdentifierFromEntityNameExpression := func(node Expression) /* TODO(UnionType): Identifier | PrivateIdentifier | undefined */ any
	getIdentifierFromEntityNameExpression := func(node Expression) /* TODO(UnionType): Identifier | PrivateIdentifier | undefined */ any {
		switch node.kind {
		case SyntaxKindIdentifier:
			return node
		case SyntaxKindPropertyAccessExpression:
			return (node).name
		default:
			return nil
		}
	}
	checkFunctionOrMethodDeclaration := func(node /* TODO(UnionType): FunctionDeclaration | MethodDeclaration | MethodSignature */ any) {
		checkDecorators(node)
		checkSignatureDeclaration(node)
		functionFlags := getFunctionFlags(node)
		if node.name && node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
		}
		if hasBindableName(node) {
			symbol := getSymbolOfDeclaration(node)
			localSymbol := node.localSymbol || symbol
			firstDeclaration := localSymbol.declarations.find(func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
				return declaration.kind == node.kind && !(declaration.flags & NodeFlagsJavaScriptFile)
			})
			if node == firstDeclaration {
				checkFunctionOrConstructorSymbol(localSymbol)
			}
			if symbol.parent {
				checkFunctionOrConstructorSymbol(symbol)
			}
		}
		body := /* TODO(ConditionalExpression): node.kind === SyntaxKind.MethodSignature ? undefined : node.body */ TODO
		checkSourceElement(body)
		checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, getReturnTypeFromAnnotation(node))
		addLazyDiagnostic(checkFunctionOrMethodDeclarationDiagnostics)
		if isInJSFile(node) {
			typeTag := getJSDocTypeTag(node)
			if typeTag && typeTag.typeExpression && !getContextualCallSignature(getTypeFromTypeNode(typeTag.typeExpression), node) {
				error(typeTag.typeExpression.type_, Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature)
			}
		}
		checkFunctionOrMethodDeclarationDiagnostics := func() {
			if !getEffectiveReturnTypeNode(node) {
				if nodeIsMissing(body) && !isPrivateWithinAmbient(node) {
					reportImplicitAny(node, anyType)
				}
				if functionFlags&FunctionFlagsGenerator && nodeIsPresent(body) {
					getReturnTypeOfSignature(getSignatureFromDeclaration(node))
				}
			}
		}
	}
	registerForUnusedIdentifiersCheck := func(node PotentiallyUnusedIdentifier) {
		addLazyDiagnostic(registerForUnusedIdentifiersCheckDiagnostics)
		registerForUnusedIdentifiersCheckDiagnostics := func() {
			sourceFile := getSourceFileOfNode(node)
			potentiallyUnusedIdentifiers := allPotentiallyUnusedIdentifiers.get(sourceFile.path)
			if !potentiallyUnusedIdentifiers {
				potentiallyUnusedIdentifiers = /* TODO(ArrayLiteralExpression): [] */ TODO
				allPotentiallyUnusedIdentifiers.set(sourceFile.path, potentiallyUnusedIdentifiers)
			}
			potentiallyUnusedIdentifiers.push(node)
		}
	}
	type PotentiallyUnusedIdentifier /* TODO(UnionType): SourceFile | ModuleDeclaration | ClassLikeDeclaration | InterfaceDeclaration | Block | CaseBlock | ForStatement | ForInStatement | ForOfStatement | Exclude<SignatureDeclaration, IndexSignatureDeclaration | JSDocFunctionType> | TypeAliasDeclaration | InferTypeNode */ any
	checkUnusedIdentifiers := func(potentiallyUnusedIdentifiers []PotentiallyUnusedIdentifier, addDiagnostic AddUnusedDiagnostic) {
		for _, node := range potentiallyUnusedIdentifiers {
			switch node.kind {
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindClassExpression:
				checkUnusedClassMembers(node, addDiagnostic)
				checkUnusedTypeParameters(node, addDiagnostic)
				break
			case SyntaxKindSourceFile:
				fallthrough // TODO: merge cases
			case SyntaxKindModuleDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindBlock:
				fallthrough // TODO: merge cases
			case SyntaxKindCaseBlock:
				fallthrough // TODO: merge cases
			case SyntaxKindForStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForInStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForOfStatement:
				checkUnusedLocalsAndParameters(node, addDiagnostic)
				break
			case SyntaxKindConstructor:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindArrowFunction:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				if node.body {
					checkUnusedLocalsAndParameters(node, addDiagnostic)
				}
				checkUnusedTypeParameters(node, addDiagnostic)
				break
			case SyntaxKindMethodSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindCallSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionType:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructorType:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeAliasDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindInterfaceDeclaration:
				checkUnusedTypeParameters(node, addDiagnostic)
				break
			case SyntaxKindInferType:
				checkUnusedInferTypeParameter(node, addDiagnostic)
				break
			default:
				Debug.assertNever(node, "Node should not have been registered for unused identifiers check")
			}
		}
	}
	errorUnusedLocal := func(declaration Declaration, name string, addDiagnostic AddUnusedDiagnostic) {
		node := getNameOfDeclaration(declaration) || declaration
		message := /* TODO(ConditionalExpression): isTypeDeclaration(declaration) ? Diagnostics._0_is_declared_but_never_used : Diagnostics._0_is_declared_but_its_value_is_never_read */ TODO
		addDiagnostic(declaration, UnusedKindLocal, createDiagnosticForNode(node, message, name))
	}
	isIdentifierThatStartsWithUnderscore := func(node Node) /* TODO inferred type boolean */ TODO {
		return isIdentifier(node) && idText(node).charCodeAt(0) == CharacterCodes_
	}
	checkUnusedClassMembers := func(node /* TODO(UnionType): ClassDeclaration | ClassExpression */ any, addDiagnostic AddUnusedDiagnostic) {
		for _, member := range node.members {
			switch member.kind {
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindPropertyDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				if member.kind == SyntaxKindSetAccessor && member.symbol.flags&SymbolFlagsGetAccessor {
					break
				}
				symbol := getSymbolOfDeclaration(member)
				if !symbol.isReferenced && (hasEffectiveModifier(member, ModifierFlagsPrivate) || isNamedDeclaration(member) && isPrivateIdentifier(member.name)) && !(member.flags & NodeFlagsAmbient) {
					addDiagnostic(member, UnusedKindLocal, createDiagnosticForNode(member.name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolToString(symbol)))
				}
				break
			case SyntaxKindConstructor:
				for _, parameter := range (member).parameters {
					if !parameter.symbol.isReferenced && hasSyntacticModifier(parameter, ModifierFlagsPrivate) {
						addDiagnostic(parameter, UnusedKindLocal, createDiagnosticForNode(parameter.name, Diagnostics.Property_0_is_declared_but_its_value_is_never_read, symbolName(parameter.symbol)))
					}
				}
				break
			case SyntaxKindIndexSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindSemicolonClassElement:
				fallthrough // TODO: merge cases
			case SyntaxKindClassStaticBlockDeclaration:
				break
			default:
				Debug.fail("Unexpected class member")
			}
		}
	}
	checkUnusedInferTypeParameter := func(node InferTypeNode, addDiagnostic AddUnusedDiagnostic) {
		TODO_IDENTIFIER := node
		if isTypeParameterUnused(typeParameter) {
			addDiagnostic(node, UnusedKindParameter, createDiagnosticForNode(node, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(typeParameter.name)))
		}
	}
	checkUnusedTypeParameters := func(node /* TODO(UnionType): ClassLikeDeclaration | SignatureDeclaration | InterfaceDeclaration | TypeAliasDeclaration */ any, addDiagnostic AddUnusedDiagnostic) {
		declarations := getSymbolOfDeclaration(node).declarations
		if !declarations || last(declarations) != node {
			return
		}
		typeParameters := getEffectiveTypeParameterDeclarations(node)
		seenParentsWithEveryUnused := make(map[DeclarationWithTypeParameterChildren]struct{})
		for _, typeParameter := range typeParameters {
			if !isTypeParameterUnused(typeParameter) {
				continue
			}
			name := idText(typeParameter.name)
			TODO_IDENTIFIER := typeParameter
			if parent.kind != SyntaxKindInferType && parent.typeParameters.every(isTypeParameterUnused) {
				if tryAddToSet(seenParentsWithEveryUnused, parent) {
					sourceFile := getSourceFileOfNode(parent)
					range_ := /* TODO(ConditionalExpression): isJSDocTemplateTag(parent)                         // Whole @template tag                         ? rangeOfNode(parent)                         // Include the `<>` in the error message                         : rangeOfTypeParameters(sourceFile, parent.typeParameters!) */ TODO
					only := parent.typeParameters.length == 1
					var messageAndArg DiagnosticAndArguments = /* TODO(ConditionalExpression): only                         ? [Diagnostics._0_is_declared_but_its_value_is_never_read, name]                         : [Diagnostics.All_type_parameters_are_unused] */ TODO
					addDiagnostic(typeParameter, UnusedKindParameter, createFileDiagnostic(sourceFile, range_.pos /* TODO(MinusToken): - */ /* TODO(BinaryExpression): range.end - range.pos */, TODO /* TODO(SpreadElement): ...messageAndArg */, TODO))
				}
			} else {
				addDiagnostic(typeParameter, UnusedKindParameter, createDiagnosticForNode(typeParameter, Diagnostics._0_is_declared_but_its_value_is_never_read, name))
			}
		}
	}
	isTypeParameterUnused := func(typeParameter TypeParameterDeclaration) bool {
		return !(getMergedSymbol(typeParameter.symbol).isReferenced & SymbolFlagsTypeParameter) && !isIdentifierThatStartsWithUnderscore(typeParameter.name)
	}
	addToGroup := func(map_ Map[string /* TODO(TupleType): [K, V[]] */, any], key K, value V, getKey func(key K) /* TODO(UnionType): number | string */ any) {
		keyString := String(getKey(key))
		group := map_.get(keyString)
		if group {
			/* TODO(ElementAccessExpression): group[1] */ TODO.push(value)
		} else {
			map_.set(keyString /* TODO(ArrayLiteralExpression): [key, [value]] */, TODO)
		}
	}
	tryGetRootParameterDeclaration := func(node Node) *ParameterDeclaration {
		return tryCast(getRootDeclaration(node), isParameter)
	}
	isValidUnusedLocalDeclaration := func(declaration Declaration) bool {
		if isBindingElement(declaration) {
			if isObjectBindingPattern(declaration.parent) {
				return !!(declaration.propertyName && isIdentifierThatStartsWithUnderscore(declaration.name))
			}
			return isIdentifierThatStartsWithUnderscore(declaration.name)
		}
		return isAmbientModule(declaration) || (isVariableDeclaration(declaration) && isForInOrOfStatement(declaration.parent.parent) || isImportedDeclaration(declaration)) && isIdentifierThatStartsWithUnderscore(declaration.name)
	}
	checkUnusedLocalsAndParameters := func(nodeWithLocals HasLocals, addDiagnostic AddUnusedDiagnostic) {
		unusedImports := make(map[string] /* TODO(TupleType): [ImportClause, ImportedDeclaration[]] */ any)
		unusedDestructures := make(map[string] /* TODO(TupleType): [BindingPattern, BindingElement[]] */ any)
		unusedVariables := make(map[string] /* TODO(TupleType): [VariableDeclarationList, VariableDeclaration[]] */ any)
		nodeWithLocals.locals.forEach(func(local /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
			if /* TODO(ConditionalExpression): local.flags & SymbolFlags.TypeParameter ? !(local.flags & SymbolFlags.Variable && !(local.isReferenced! & SymbolFlags.Variable)) : local.isReferenced || local.exportSymbol */ TODO {
				return
			}
			if local.declarations {
				for _, declaration := range local.declarations {
					if isValidUnusedLocalDeclaration(declaration) {
						continue
					}
					if isImportedDeclaration(declaration) {
						addToGroup(unusedImports, importClauseFromImported(declaration), declaration, getNodeId)
					} else if isBindingElement(declaration) && isObjectBindingPattern(declaration.parent) {
						lastElement := last(declaration.parent.elements)
						if declaration == lastElement || !last(declaration.parent.elements).dotDotDotToken {
							addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId)
						}
					} else if isVariableDeclaration(declaration) {
						blockScopeKind := getCombinedNodeFlagsCached(declaration) & NodeFlagsBlockScoped
						name := getNameOfDeclaration(declaration)
						if blockScopeKind != NodeFlagsUsing && blockScopeKind != NodeFlagsAwaitUsing || !name || !isIdentifierThatStartsWithUnderscore(name) {
							addToGroup(unusedVariables, declaration.parent, declaration, getNodeId)
						}
					} else {
						parameter := local.valueDeclaration && tryGetRootParameterDeclaration(local.valueDeclaration)
						name := local.valueDeclaration && getNameOfDeclaration(local.valueDeclaration)
						if parameter && name {
							if !isParameterPropertyDeclaration(parameter, parameter.parent) && !parameterIsThisKeyword(parameter) && !isIdentifierThatStartsWithUnderscore(name) {
								if isBindingElement(declaration) && isArrayBindingPattern(declaration.parent) {
									addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId)
								} else {
									addDiagnostic(parameter, UnusedKindParameter, createDiagnosticForNode(name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolName(local)))
								}
							}
						} else {
							errorUnusedLocal(declaration, symbolName(local), addDiagnostic)
						}
					}
				}
			}
		})
		unusedImports.forEach(func(TODO_IDENTIFIER /* TODO inferred type [import("/home/jabaile/work/TypeScript/src/compiler/types").ImportClause, ImportedDeclaration[]] */ TODO) {
			importDecl := importClause.parent
			nDeclarations := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (importClause.name ? 1 : 0) +                 (importClause.namedBindings ?                     (importClause.namedBindings.kind === SyntaxKind.NamespaceImport ? 1 : importClause.namedBindings.elements.length)                     : 0) */ TODO
			if nDeclarations == unuseds.length {
				addDiagnostic(importDecl, UnusedKindLocal /* TODO(ConditionalExpression): unuseds.length === 1                         ? createDiagnosticForNode(importDecl, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(first(unuseds).name!))                         : createDiagnosticForNode(importDecl, Diagnostics.All_imports_in_import_declaration_are_unused) */, TODO)
			} else {
				for _, unused := range unuseds {
					errorUnusedLocal(unused, idText(unused.name), addDiagnostic)
				}
			}
		})
		unusedDestructures.forEach(func(TODO_IDENTIFIER /* TODO inferred type [import("/home/jabaile/work/TypeScript/src/compiler/types").BindingPattern, import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement[]] */ TODO) {
			kind := /* TODO(ConditionalExpression): tryGetRootParameterDeclaration(bindingPattern.parent) ? UnusedKind.Parameter : UnusedKind.Local */ TODO
			if bindingPattern.elements.length == bindingElements.length {
				if bindingElements.length == 1 && bindingPattern.parent.kind == SyntaxKindVariableDeclaration && bindingPattern.parent.parent.kind == SyntaxKindVariableDeclarationList {
					addToGroup(unusedVariables, bindingPattern.parent.parent, bindingPattern.parent, getNodeId)
				} else {
					addDiagnostic(bindingPattern, kind /* TODO(ConditionalExpression): bindingElements.length === 1                             ? createDiagnosticForNode(bindingPattern, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(bindingElements).name))                             : createDiagnosticForNode(bindingPattern, Diagnostics.All_destructured_elements_are_unused) */, TODO)
				}
			} else {
				for _, e := range bindingElements {
					addDiagnostic(e, kind, createDiagnosticForNode(e, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(e.name)))
				}
			}
		})
		unusedVariables.forEach(func(TODO_IDENTIFIER /* TODO inferred type [import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclarationList, import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclaration[]] */ TODO) {
			if declarationList.declarations.length == declarations.length {
				addDiagnostic(declarationList, UnusedKindLocal /* TODO(ConditionalExpression): declarations.length === 1                         ? createDiagnosticForNode(first(declarations).name, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(declarations).name))                         : createDiagnosticForNode(declarationList.parent.kind === SyntaxKind.VariableStatement ? declarationList.parent : declarationList, Diagnostics.All_variables_are_unused) */, TODO)
			} else {
				for _, decl := range declarations {
					addDiagnostic(decl, UnusedKindLocal, createDiagnosticForNode(decl, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(decl.name)))
				}
			}
		})
	}
	checkPotentialUncheckedRenamedBindingElementsInTypes := func() {
		for _, node := range potentialUnusedRenamedBindingElementsInTypes {
			if !getSymbolOfDeclaration(node).isReferenced {
				wrappingDeclaration := walkUpBindingElementsAndPatterns(node)
				Debug.assert(isPartOfParameterDeclaration(wrappingDeclaration), "Only parameter declaration should be checked here")
				diagnostic := createDiagnosticForNode(node.name, Diagnostics._0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation, declarationNameToString(node.name), declarationNameToString(node.propertyName))
				if !wrappingDeclaration.type_ {
					addRelatedInfo(diagnostic, createFileDiagnostic(getSourceFileOfNode(wrappingDeclaration), wrappingDeclaration.end, 0, Diagnostics.We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here, declarationNameToString(node.propertyName)))
				}
				diagnostics.add(diagnostic)
			}
		}
	}
	bindingNameText := func(name BindingName) string {
		switch name.kind {
		case SyntaxKindIdentifier:
			return idText(name)
		case SyntaxKindArrayBindingPattern:
			fallthrough // TODO: merge cases
		case SyntaxKindObjectBindingPattern:
			return bindingNameText(cast(first(name.elements), isBindingElement).name)
		default:
			return Debug.assertNever(name)
		}
	}
	type ImportedDeclaration /* TODO(UnionType): ImportClause | ImportSpecifier | NamespaceImport */ any
	isImportedDeclaration := func(node Node) /* TODO(TypePredicate): node is ImportedDeclaration */ any {
		return node.kind == SyntaxKindImportClause || node.kind == SyntaxKindImportSpecifier || node.kind == SyntaxKindNamespaceImport
	}
	importClauseFromImported := func(decl ImportedDeclaration) ImportClause {
		return /* TODO(ConditionalExpression): decl.kind === SyntaxKind.ImportClause ? decl : decl.kind === SyntaxKind.NamespaceImport ? decl.parent : decl.parent.parent */ TODO
	}
	checkBlock := func(node Block) {
		if node.kind == SyntaxKindBlock {
			checkGrammarStatementInAmbientContext(node)
		}
		if isFunctionOrModuleBlock(node) {
			saveFlowAnalysisDisabled := flowAnalysisDisabled
			forEach(node.statements, checkSourceElement)
			flowAnalysisDisabled = saveFlowAnalysisDisabled
		} else {
			forEach(node.statements, checkSourceElement)
		}
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkCollisionWithArgumentsInGeneratedCode := func(node SignatureDeclaration) {
		if languageVersion >= ScriptTargetES2015 || !hasRestParameter(node) || node.flags&NodeFlagsAmbient || nodeIsMissing((node).body) {
			return
		}
		forEach(node.parameters, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO) {
			if p.name && !isBindingPattern(p.name) && p.name.escapedText == argumentsSymbol.escapedName {
				errorSkippedOn("noEmit", p, Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters)
			}
		})
	}
	needCollisionCheckForIdentifier := func(node Node, identifier *Identifier, name string) bool {
		if identifier.escapedText != name {
			return false
		}
		if node.kind == SyntaxKindPropertyDeclaration || node.kind == SyntaxKindPropertySignature || node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature || node.kind == SyntaxKindGetAccessor || node.kind == SyntaxKindSetAccessor || node.kind == SyntaxKindPropertyAssignment {
			return false
		}
		if node.flags & NodeFlagsAmbient {
			return false
		}
		if isImportClause(node) || isImportEqualsDeclaration(node) || isImportSpecifier(node) {
			if isTypeOnlyImportOrExportDeclaration(node) {
				return false
			}
		}
		root := getRootDeclaration(node)
		if isParameter(root) && nodeIsMissing((root.parent).body) {
			return false
		}
		return true
	}
	checkIfThisIsCapturedInEnclosingScope := func(node Node) {
		findAncestor(node, func(current /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
			if getNodeCheckFlags(current) & NodeCheckFlagsCaptureThis {
				isDeclaration := node.kind != SyntaxKindIdentifier
				if isDeclaration {
					error(getNameOfDeclaration(node), Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference)
				} else {
					error(node, Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference)
				}
				return true
			}
			return false
		})
	}
	checkIfNewTargetIsCapturedInEnclosingScope := func(node Node) {
		findAncestor(node, func(current /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
			if getNodeCheckFlags(current) & NodeCheckFlagsCaptureNewTarget {
				isDeclaration := node.kind != SyntaxKindIdentifier
				if isDeclaration {
					error(getNameOfDeclaration(node), Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference)
				} else {
					error(node, Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference)
				}
				return true
			}
			return false
		})
	}
	checkCollisionWithRequireExportsInGeneratedCode := func(node Node, name *Identifier) {
		if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) >= ModuleKindES2015 {
			return
		}
		if !name || !needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports") {
			return
		}
		if isModuleDeclaration(node) && getModuleInstanceState(node) != ModuleInstanceStateInstantiated {
			return
		}
		parent := getDeclarationContainer(node)
		if parent.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(parent) {
			errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, declarationNameToString(name), declarationNameToString(name))
		}
	}
	checkCollisionWithGlobalPromiseInGeneratedCode := func(node Node, name *Identifier) {
		if !name || languageVersion >= ScriptTargetES2017 || !needCollisionCheckForIdentifier(node, name, "Promise") {
			return
		}
		if isModuleDeclaration(node) && getModuleInstanceState(node) != ModuleInstanceStateInstantiated {
			return
		}
		parent := getDeclarationContainer(node)
		if parent.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(parent) && parent.flags&NodeFlagsHasAsyncFunctions {
			errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions, declarationNameToString(name), declarationNameToString(name))
		}
	}
	recordPotentialCollisionWithWeakMapSetInGeneratedCode := func(node Node, name Identifier) {
		if languageVersion <= ScriptTargetES2021 && (needCollisionCheckForIdentifier(node, name, "WeakMap") || needCollisionCheckForIdentifier(node, name, "WeakSet")) {
			potentialWeakMapSetCollisions.push(node)
		}
	}
	checkWeakMapSetCollision := func(node Node) {
		enclosingBlockScope := getEnclosingBlockScopeContainer(node)
		if getNodeCheckFlags(enclosingBlockScope) & NodeCheckFlagsContainsClassWithPrivateIdentifiers {
			Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name) && /* TODO(TypeOfExpression): typeof node.name.escapedText */ TODO == "string", "The target of a WeakMap/WeakSet collision check should be an identifier")
			errorSkippedOn("noEmit", node, Diagnostics.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel, node.name.escapedText)
		}
	}
	recordPotentialCollisionWithReflectInGeneratedCode := func(node Node, name *Identifier) {
		if name && languageVersion >= ScriptTargetES2015 && languageVersion <= ScriptTargetES2021 && needCollisionCheckForIdentifier(node, name, "Reflect") {
			potentialReflectCollisions.push(node)
		}
	}
	checkReflectCollision := func(node Node) {
		hasCollision := false
		if isClassExpression(node) {
			for _, member := range node.members {
				if getNodeCheckFlags(member) & NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
					hasCollision = true
					break
				}
			}
		} else if isFunctionExpression(node) {
			if getNodeCheckFlags(node) & NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
				hasCollision = true
			}
		} else {
			container := getEnclosingBlockScopeContainer(node)
			if container && getNodeCheckFlags(container)&NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
				hasCollision = true
			}
		}
		if hasCollision {
			Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name), "The target of a Reflect collision check should be an identifier")
			errorSkippedOn("noEmit", node, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers, declarationNameToString(node.name), "Reflect")
		}
	}
	checkCollisionsForDeclarationName := func(node Node, name *Identifier) {
		if !name {
			return
		}
		checkCollisionWithRequireExportsInGeneratedCode(node, name)
		checkCollisionWithGlobalPromiseInGeneratedCode(node, name)
		recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name)
		recordPotentialCollisionWithReflectInGeneratedCode(node, name)
		if isClassLike(node) {
			checkTypeNameIsReserved(name, Diagnostics.Class_name_cannot_be_0)
			if !(node.flags & NodeFlagsAmbient) {
				checkClassNameCollisionWithObject(name)
			}
		} else if isEnumDeclaration(node) {
			checkTypeNameIsReserved(name, Diagnostics.Enum_name_cannot_be_0)
		}
	}
	checkVarDeclaredNamesNotShadowed := func(node /* TODO(UnionType): VariableDeclaration | BindingElement */ any) /* TODO inferred type undefined */ TODO {
		if (getCombinedNodeFlagsCached(node)&NodeFlagsBlockScoped) != 0 || isPartOfParameterDeclaration(node) {
			return
		}
		symbol := getSymbolOfDeclaration(node)
		if symbol.flags & SymbolFlagsFunctionScopedVariable {
			if !isIdentifier(node.name) {
				return Debug.fail()
			}
			localDeclarationSymbol := resolveName(node, node.name.escapedText, SymbolFlagsVariable, nil, false)
			if localDeclarationSymbol && localDeclarationSymbol != symbol && localDeclarationSymbol.flags&SymbolFlagsBlockScopedVariable {
				if getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & NodeFlagsBlockScoped {
					varDeclList := getAncestor(localDeclarationSymbol.valueDeclaration, SyntaxKindVariableDeclarationList)
					container := /* TODO(ConditionalExpression): varDeclList.parent.kind === SyntaxKind.VariableStatement && varDeclList.parent.parent                         ? varDeclList.parent.parent                         : undefined */ TODO
					namesShareScope := container && (container.kind == SyntaxKindBlock && isFunctionLike(container.parent) || container.kind == SyntaxKindModuleBlock || container.kind == SyntaxKindModuleDeclaration || container.kind == SyntaxKindSourceFile)
					if !namesShareScope {
						name := symbolToString(localDeclarationSymbol)
						error(node, Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name)
					}
				}
			}
		}
	}
	convertAutoToAny := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type === autoType ? anyType : type === autoArrayType ? anyArrayType : type */ TODO
	}
	checkVariableLikeDeclaration := func(node /* TODO(UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement */ any) {
		checkDecorators(node)
		if !isBindingElement(node) {
			checkSourceElement(node.type_)
		}
		if !node.name {
			return
		}
		if node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
			if hasOnlyExpressionInitializer(node) && node.initializer {
				checkExpressionCached(node.initializer)
			}
		}
		if isBindingElement(node) {
			if node.propertyName && isIdentifier(node.name) && isPartOfParameterDeclaration(node) && nodeIsMissing((getContainingFunction(node)).body) {
				potentialUnusedRenamedBindingElementsInTypes.push(node)
				return
			}
			if isObjectBindingPattern(node.parent) && node.dotDotDotToken && languageVersion < LanguageFeatureMinimumTargetObjectSpreadRest {
				checkExternalEmitHelpers(node, ExternalEmitHelpersRest)
			}
			if node.propertyName && node.propertyName.kind == SyntaxKindComputedPropertyName {
				checkComputedPropertyName(node.propertyName)
			}
			parent := node.parent.parent
			parentCheckMode := /* TODO(ConditionalExpression): node.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */ TODO
			parentType := getTypeForBindingElementParent(parent, parentCheckMode)
			name := node.propertyName || node.name
			if parentType && !isBindingPattern(name) {
				exprType := getLiteralTypeFromPropertyName(name)
				if isTypeUsableAsPropertyName(exprType) {
					nameText := getPropertyNameFromType(exprType)
					property := getPropertyOfType(parentType, nameText)
					if property {
						markPropertyAsReferenced(property, nil, false)
						checkPropertyAccessibility(node, !!parent.initializer && parent.initializer.kind == SyntaxKindSuperKeyword, false, parentType, property)
					}
				}
			}
		}
		if isBindingPattern(node.name) {
			if node.name.kind == SyntaxKindArrayBindingPattern && languageVersion < LanguageFeatureMinimumTargetBindingPatterns && compilerOptions.downlevelIteration {
				checkExternalEmitHelpers(node, ExternalEmitHelpersRead)
			}
			forEach(node.name.elements, checkSourceElement)
		}
		if node.initializer && isPartOfParameterDeclaration(node) && nodeIsMissing((getContainingFunction(node)).body) {
			error(node, Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation)
			return
		}
		if isBindingPattern(node.name) {
			if isInAmbientOrTypeNode(node) {
				return
			}
			needCheckInitializer := hasOnlyExpressionInitializer(node) && node.initializer && node.parent.parent.kind != SyntaxKindForInStatement
			needCheckWidenedType := !some(node.name.elements, not(isOmittedExpression))
			if needCheckInitializer || needCheckWidenedType {
				widenedType := getWidenedTypeForVariableLikeDeclaration(node)
				if needCheckInitializer {
					initializerType := checkExpressionCached(node.initializer)
					if strictNullChecks && needCheckWidenedType {
						checkNonNullNonVoidType(initializerType, node)
					} else {
						checkTypeAssignableToAndOptionallyElaborate(initializerType, getWidenedTypeForVariableLikeDeclaration(node), node, node.initializer)
					}
				}
				if needCheckWidenedType {
					if isArrayBindingPattern(node.name) {
						checkIteratedTypeOrElementType(IterationUseDestructuring, widenedType, undefinedType, node)
					} else if strictNullChecks {
						checkNonNullNonVoidType(widenedType, node)
					}
				}
			}
			return
		}
		symbol := getSymbolOfDeclaration(node)
		if symbol.flags&SymbolFlagsAlias && (isVariableDeclarationInitializedToBareOrAccessedRequire(node) || isBindingElementOfBareOrAccessedRequire(node)) {
			checkAliasSymbol(node)
			return
		}
		if node.name.kind == SyntaxKindBigIntLiteral {
			error(node.name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name)
		}
		type_ := convertAutoToAny(getTypeOfSymbol(symbol))
		if node == symbol.valueDeclaration {
			initializer := hasOnlyExpressionInitializer(node) && getEffectiveInitializer(node)
			if initializer {
				isJSObjectLiteralInitializer := isInJSFile(node) && isObjectLiteralExpression(initializer) && (initializer.properties.length == 0 || isPrototypeAccess(node.name)) && !!symbol.exports.size
				if !isJSObjectLiteralInitializer && node.parent.parent.kind != SyntaxKindForInStatement {
					initializerType := checkExpressionCached(initializer)
					checkTypeAssignableToAndOptionallyElaborate(initializerType, type_, node, initializer, nil)
					blockScopeKind := getCombinedNodeFlagsCached(node) & NodeFlagsBlockScoped
					if blockScopeKind == NodeFlagsAwaitUsing {
						globalAsyncDisposableType := getGlobalAsyncDisposableType(true)
						globalDisposableType := getGlobalDisposableType(true)
						if globalAsyncDisposableType != emptyObjectType && globalDisposableType != emptyObjectType {
							optionalDisposableType := getUnionType( /* TODO(ArrayLiteralExpression): [globalAsyncDisposableType, globalDisposableType, nullType, undefinedType] */ TODO)
							checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_Symbol_dispose_method_or_be_null_or_undefined)
						}
					} else if blockScopeKind == NodeFlagsUsing {
						globalDisposableType := getGlobalDisposableType(true)
						if globalDisposableType != emptyObjectType {
							optionalDisposableType := getUnionType( /* TODO(ArrayLiteralExpression): [globalDisposableType, nullType, undefinedType] */ TODO)
							checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_a_using_declaration_must_be_either_an_object_with_a_Symbol_dispose_method_or_be_null_or_undefined)
						}
					}
				}
			}
			if symbol.declarations && symbol.declarations.length > 1 {
				if some(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
					return d != node && isVariableLike(d) && !areDeclarationFlagsIdentical(d, node)
				}) {
					error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name))
				}
			}
		} else {
			declarationType := convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node))
			if !isErrorType(type_) && !isErrorType(declarationType) && !isTypeIdenticalTo(type_, declarationType) && !(symbol.flags & SymbolFlagsAssignment) {
				errorNextVariableOrPropertyDeclarationMustHaveSameType(symbol.valueDeclaration, type_, node, declarationType)
			}
			if hasOnlyExpressionInitializer(node) && node.initializer {
				checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(node.initializer), declarationType, node, node.initializer, nil)
			}
			if symbol.valueDeclaration && !areDeclarationFlagsIdentical(node, symbol.valueDeclaration) {
				error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name))
			}
		}
		if node.kind != SyntaxKindPropertyDeclaration && node.kind != SyntaxKindPropertySignature {
			checkExportsOnMergedDeclarations(node)
			if node.kind == SyntaxKindVariableDeclaration || node.kind == SyntaxKindBindingElement {
				checkVarDeclaredNamesNotShadowed(node)
			}
			checkCollisionsForDeclarationName(node, node.name)
		}
	}
	errorNextVariableOrPropertyDeclarationMustHaveSameType := func(firstDeclaration Declaration, firstType Type, nextDeclaration Declaration, nextType Type) {
		nextDeclarationName := getNameOfDeclaration(nextDeclaration)
		message := /* TODO(ConditionalExpression): nextDeclaration.kind === SyntaxKind.PropertyDeclaration || nextDeclaration.kind === SyntaxKind.PropertySignature             ? Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2             : Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2 */ TODO
		declName := declarationNameToString(nextDeclarationName)
		err := error(nextDeclarationName, message, declName, typeToString(firstType), typeToString(nextType))
		if firstDeclaration {
			addRelatedInfo(err, createDiagnosticForNode(firstDeclaration, Diagnostics._0_was_also_declared_here, declName))
		}
	}
	areDeclarationFlagsIdentical := func(left Declaration, right Declaration) /* TODO inferred type boolean */ TODO {
		if (left.kind == SyntaxKindParameter && right.kind == SyntaxKindVariableDeclaration) || (left.kind == SyntaxKindVariableDeclaration && right.kind == SyntaxKindParameter) {
			return true
		}
		if hasQuestionToken(left) != hasQuestionToken(right) {
			return false
		}
		interestingFlags := ModifierFlagsPrivate | ModifierFlagsProtected | ModifierFlagsAsync | ModifierFlagsAbstract | ModifierFlagsReadonly | ModifierFlagsStatic
		return getSelectedEffectiveModifierFlags(left, interestingFlags) == getSelectedEffectiveModifierFlags(right, interestingFlags)
	}
	checkVariableDeclaration := func(node VariableDeclaration) {
		tracing.push(tracing.Phase.Check, "checkVariableDeclaration" /* TODO(ObjectLiteralExpression): { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath } */, TODO)
		checkGrammarVariableDeclaration(node)
		checkVariableLikeDeclaration(node)
		tracing.pop()
	}
	checkBindingElement := func(node BindingElement) {
		checkGrammarBindingElement(node)
		return checkVariableLikeDeclaration(node)
	}
	checkVariableDeclarationList := func(node VariableDeclarationList) {
		blockScopeKind := getCombinedNodeFlags(node) & NodeFlagsBlockScoped
		if (blockScopeKind == NodeFlagsUsing || blockScopeKind == NodeFlagsAwaitUsing) && languageVersion < LanguageFeatureMinimumTargetUsingAndAwaitUsing {
			checkExternalEmitHelpers(node, ExternalEmitHelpersAddDisposableResourceAndDisposeResources)
		}
		forEach(node.declarations, checkSourceElement)
	}
	checkVariableStatement := func(node VariableStatement) {
		if !checkGrammarModifiers(node) && !checkGrammarVariableDeclarationList(node.declarationList) {
			checkGrammarForDisallowedBlockScopedVariableStatement(node)
		}
		checkVariableDeclarationList(node.declarationList)
	}
	checkExpressionStatement := func(node ExpressionStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkExpression(node.expression)
	}
	checkIfStatement := func(node IfStatement) {
		checkGrammarStatementInAmbientContext(node)
		type_ := checkTruthinessExpression(node.expression)
		checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.expression, type_, node.thenStatement)
		checkSourceElement(node.thenStatement)
		if node.thenStatement.kind == SyntaxKindEmptyStatement {
			error(node.thenStatement, Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement)
		}
		checkSourceElement(node.elseStatement)
	}
	checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType := func(condExpr Expression, condType Type, body /* TODO(UnionType): Statement | Expression */ any) {
		if !strictNullChecks {
			return
		}
		bothHelper(condExpr, body)
		bothHelper := func(condExpr Expression, body /* TODO(UnionType): Expression | Statement | undefined */ any) {
			condExpr = skipParentheses(condExpr)
			helper(condExpr, body)
			for isBinaryExpression(condExpr) && (condExpr.operatorToken.kind == SyntaxKindBarBarToken || condExpr.operatorToken.kind == SyntaxKindQuestionQuestionToken) {
				condExpr = skipParentheses(condExpr.left)
				helper(condExpr, body)
			}
		}
		helper := func(condExpr Expression, body /* TODO(UnionType): Expression | Statement | undefined */ any) {
			location := /* TODO(ConditionalExpression): isLogicalOrCoalescingBinaryExpression(condExpr) ? skipParentheses(condExpr.right) : condExpr */ TODO
			if isModuleExportsAccessExpression(location) {
				return
			}
			if isLogicalOrCoalescingBinaryExpression(location) {
				bothHelper(location, body)
				return
			}
			type_ := /* TODO(ConditionalExpression): location === condExpr ? condType : checkExpression(location) */ TODO
			if type_.flags&TypeFlagsEnumLiteral && isPropertyAccessExpression(location) && ( /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getNodeLinks(location.expression).resolvedSymbol ?? unknownSymbol */ TODO).flags&SymbolFlagsEnum {
				error(location, Diagnostics.This_condition_will_always_return_0 /* TODO(ConditionalExpression): !!(type as LiteralType).value ? "true" : "false" */, TODO)
				return
			}
			isPropertyExpressionCast := isPropertyAccessExpression(location) && isTypeAssertion(location.expression)
			if !hasTypeFacts(type_, TypeFactsTruthy) || isPropertyExpressionCast {
				return
			}
			callSignatures := getSignaturesOfType(type_, SignatureKindCall)
			isPromise := !!getAwaitedTypeOfPromise(type_)
			if callSignatures.length == 0 && !isPromise {
				return
			}
			testedNode := /* TODO(ConditionalExpression): isIdentifier(location) ? location                 : isPropertyAccessExpression(location) ? location.name                 : undefined */ TODO
			testedSymbol := testedNode && getSymbolAtLocation(testedNode)
			if !testedSymbol && !isPromise {
				return
			}
			isUsed := testedSymbol && isBinaryExpression(condExpr.parent) && isSymbolUsedInBinaryExpressionChain(condExpr.parent, testedSymbol) || testedSymbol && body && isSymbolUsedInConditionBody(condExpr, body, testedNode, testedSymbol)
			if !isUsed {
				if isPromise {
					errorAndMaybeSuggestAwait(location, true, Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined, getTypeNameForErrorDisplay(type_))
				} else {
					error(location, Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead)
				}
			}
		}
	}
	isSymbolUsedInConditionBody := func(expr Expression, body /* TODO(UnionType): Statement | Expression */ any, testedNode Node, testedSymbol Symbol) bool {
		return !!forEachChild(body /* TODO(FunctionExpression): function check(childNode): boolean | undefined {             if (isIdentifier(childNode)) {                 const childSymbol = getSymbolAtLocation(childNode);                 if (childSymbol && childSymbol === testedSymbol) {                     // If the test was a simple identifier, the above check is sufficient                     if (isIdentifier(expr) || isIdentifier(testedNode) && isBinaryExpression(testedNode.parent)) {                         return true;                     }                     // Otherwise we need to ensure the symbol is called on the same target                     let testedExpression = testedNode.parent;                     let childExpression = childNode.parent;                     while (testedExpression && childExpression) {                         if (                             isIdentifier(testedExpression) && isIdentifier(childExpression) ||                             testedExpression.kind === SyntaxKind.ThisKeyword && childExpression.kind === SyntaxKind.ThisKeyword                         ) {                             return getSymbolAtLocation(testedExpression) === getSymbolAtLocation(childExpression);                         }                         else if (isPropertyAccessExpression(testedExpression) && isPropertyAccessExpression(childExpression)) {                             if (getSymbolAtLocation(testedExpression.name) !== getSymbolAtLocation(childExpression.name)) {                                 return false;                             }                             childExpression = childExpression.expression;                             testedExpression = testedExpression.expression;                         }                         else if (isCallExpression(testedExpression) && isCallExpression(childExpression)) {                             childExpression = childExpression.expression;                             testedExpression = testedExpression.expression;                         }                         else {                             return false;                         }                     }                 }             }             return forEachChild(childNode, check);         } */, TODO)
	}
	isSymbolUsedInBinaryExpressionChain := func(node Node, testedSymbol Symbol) bool {
		for isBinaryExpression(node) && node.operatorToken.kind == SyntaxKindAmpersandAmpersandToken {
			isUsed := forEachChild(node.right /* TODO(FunctionExpression): function visit(child): boolean | undefined {                 if (isIdentifier(child)) {                     const symbol = getSymbolAtLocation(child);                     if (symbol && symbol === testedSymbol) {                         return true;                     }                 }                 return forEachChild(child, visit);             } */, TODO)
			if isUsed {
				return true
			}
			node = node.parent
		}
		return false
	}
	checkDoStatement := func(node DoStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkSourceElement(node.statement)
		checkTruthinessExpression(node.expression)
	}
	checkWhileStatement := func(node WhileStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkTruthinessExpression(node.expression)
		checkSourceElement(node.statement)
	}
	checkTruthinessOfType := func(type_ Type, node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if type_.flags & TypeFlagsVoid {
			error(node, Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness)
		} else {
			semantics := getSyntacticTruthySemantics(node)
			if semantics != PredicateSemanticsSometimes {
				error(node /* TODO(ConditionalExpression): semantics === PredicateSemantics.Always ?                         Diagnostics.This_kind_of_expression_is_always_truthy :                         Diagnostics.This_kind_of_expression_is_always_falsy */, TODO)
			}
		}
		return type_
	}
	getSyntacticTruthySemantics := func(node Node) PredicateSemantics {
		node = skipOuterExpressions(node)
		switch node.kind {
		case SyntaxKindNumericLiteral:
			if (node).text == "0" || (node).text == "1" {
				return PredicateSemanticsSometimes
			}
			return PredicateSemanticsAlways
		case SyntaxKindArrayLiteralExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindBigIntLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindClassExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSelfClosingElement:
			fallthrough // TODO: merge cases
		case SyntaxKindObjectLiteralExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindRegularExpressionLiteral:
			return PredicateSemanticsAlways
		case SyntaxKindVoidExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNullKeyword:
			return PredicateSemanticsNever
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindStringLiteral:
			return /* TODO(ConditionalExpression): !!(node as StringLiteral | NoSubstitutionTemplateLiteral).text ? PredicateSemantics.Always : PredicateSemantics.Never */ TODO
		case SyntaxKindConditionalExpression:
			return getSyntacticTruthySemantics((node).whenTrue) | getSyntacticTruthySemantics((node).whenFalse)
		case SyntaxKindIdentifier:
			if getResolvedSymbol(node) == undefinedSymbol {
				return PredicateSemanticsNever
			}
			return PredicateSemanticsSometimes
		}
		return PredicateSemanticsSometimes
	}
	checkTruthinessExpression := func(node Expression, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return checkTruthinessOfType(checkExpression(node, checkMode), node)
	}
	checkForStatement := func(node ForStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			if node.initializer && node.initializer.kind == SyntaxKindVariableDeclarationList {
				checkGrammarVariableDeclarationList(node.initializer)
			}
		}
		if node.initializer {
			if node.initializer.kind == SyntaxKindVariableDeclarationList {
				checkVariableDeclarationList(node.initializer)
			} else {
				checkExpression(node.initializer)
			}
		}
		if node.condition {
			checkTruthinessExpression(node.condition)
		}
		if node.incrementor {
			checkExpression(node.incrementor)
		}
		checkSourceElement(node.statement)
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkForOfStatement := func(node ForOfStatement) {
		checkGrammarForInOrForOfStatement(node)
		container := getContainingFunctionOrClassStaticBlock(node)
		if node.awaitModifier {
			if container && isClassStaticBlockDeclaration(container) {
				grammarErrorOnNode(node.awaitModifier, Diagnostics.for_await_loops_cannot_be_used_inside_a_class_static_block)
			} else {
				functionFlags := getFunctionFlags(container)
				if (functionFlags&(FunctionFlagsInvalid|FunctionFlagsAsync)) == FunctionFlagsAsync && languageVersion < LanguageFeatureMinimumTargetForAwaitOf {
					checkExternalEmitHelpers(node, ExternalEmitHelpersForAwaitOfIncludes)
				}
			}
		} else if compilerOptions.downlevelIteration && languageVersion < LanguageFeatureMinimumTargetForOf {
			checkExternalEmitHelpers(node, ExternalEmitHelpersForOfIncludes)
		}
		if node.initializer.kind == SyntaxKindVariableDeclarationList {
			checkVariableDeclarationList(node.initializer)
		} else {
			varExpr := node.initializer
			iteratedType := checkRightHandSideOfForOf(node)
			if varExpr.kind == SyntaxKindArrayLiteralExpression || varExpr.kind == SyntaxKindObjectLiteralExpression {
				checkDestructuringAssignment(varExpr, iteratedType || errorType)
			} else {
				leftType := checkExpression(varExpr)
				checkReferenceExpression(varExpr, Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access)
				if iteratedType {
					checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr, node.expression)
				}
			}
		}
		checkSourceElement(node.statement)
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkForInStatement := func(node ForInStatement) {
		checkGrammarForInOrForOfStatement(node)
		rightType := getNonNullableTypeIfNeeded(checkExpression(node.expression))
		if node.initializer.kind == SyntaxKindVariableDeclarationList {
			variable := /* TODO(ElementAccessExpression): (node.initializer as VariableDeclarationList).declarations[0] */ TODO
			if variable && isBindingPattern(variable.name) {
				error(variable.name, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern)
			}
			checkVariableDeclarationList(node.initializer)
		} else {
			varExpr := node.initializer
			leftType := checkExpression(varExpr)
			if varExpr.kind == SyntaxKindArrayLiteralExpression || varExpr.kind == SyntaxKindObjectLiteralExpression {
				error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern)
			} else if !isTypeAssignableTo(getIndexTypeOrString(rightType), leftType) {
				error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any)
			} else {
				checkReferenceExpression(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access)
			}
		}
		if rightType == neverType || !isTypeAssignableToKind(rightType, TypeFlagsNonPrimitive|TypeFlagsInstantiableNonPrimitive) {
			error(node.expression, Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0, typeToString(rightType))
		}
		checkSourceElement(node.statement)
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkRightHandSideOfForOf := func(statement ForOfStatement) Type {
		use := /* TODO(ConditionalExpression): statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf */ TODO
		return checkIteratedTypeOrElementType(use, checkNonNullExpression(statement.expression), undefinedType, statement.expression)
	}
	checkIteratedTypeOrElementType := func(use IterationUse, inputType Type, sentType Type, errorNode Node) Type {
		if isTypeAny(inputType) {
			return inputType
		}
		return getIteratedTypeOrElementType(use, inputType, sentType, errorNode, true) || anyType
	}
	getIteratedTypeOrElementType := func(use IterationUse, inputType Type, sentType Type, errorNode Node, checkAssignability bool) *Type {
		allowAsyncIterables := (use & IterationUseAllowsAsyncIterablesFlag) != 0
		if inputType == neverType {
			if errorNode {
				reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables)
			}
			return nil
		}
		uplevelIteration := languageVersion >= ScriptTargetES2015
		downlevelIteration := !uplevelIteration && compilerOptions.downlevelIteration
		possibleOutOfBounds := compilerOptions.noUncheckedIndexedAccess && !!(use & IterationUsePossiblyOutOfBounds)
		if uplevelIteration || downlevelIteration || allowAsyncIterables {
			iterationTypes := getIterationTypesOfIterable(inputType, use /* TODO(ConditionalExpression): uplevelIteration ? errorNode : undefined */, TODO)
			if checkAssignability {
				if iterationTypes {
					diagnostic := /* TODO(ConditionalExpression): use & IterationUse.ForOfFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 :                         use & IterationUse.SpreadFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 :                         use & IterationUse.DestructuringFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 :                         use & IterationUse.YieldStarFlag ? Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 :                         undefined */ TODO
					if diagnostic {
						checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic)
					}
				}
			}
			if iterationTypes || uplevelIteration {
				return /* TODO(ConditionalExpression): possibleOutOfBounds ? includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType) : (iterationTypes && iterationTypes.yieldType) */ TODO
			}
		}
		arrayType := inputType
		hasStringConstituent := false
		if use & IterationUseAllowsStringInputFlag {
			if arrayType.flags & TypeFlagsUnion {
				arrayTypes := (inputType).types
				filteredTypes := filter(arrayTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
					return !(t.flags & TypeFlagsStringLike)
				})
				if filteredTypes != arrayTypes {
					arrayType = getUnionType(filteredTypes, UnionReductionSubtype)
				}
			} else if arrayType.flags & TypeFlagsStringLike {
				arrayType = neverType
			}
			hasStringConstituent = arrayType != inputType
			if hasStringConstituent {
				if arrayType.flags & TypeFlagsNever {
					return /* TODO(ConditionalExpression): possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType */ TODO
				}
			}
		}
		if !isArrayLikeType(arrayType) {
			if errorNode {
				allowsStrings := !!(use & IterationUseAllowsStringInputFlag) && !hasStringConstituent
				TODO_IDENTIFIER := getIterationDiagnosticDetails(allowsStrings, downlevelIteration)
				errorAndMaybeSuggestAwait(errorNode, maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType), defaultDiagnostic, typeToString(arrayType))
			}
			return /* TODO(ConditionalExpression): hasStringConstituent ? possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType : undefined */ TODO
		}
		arrayElementType := getIndexTypeOfType(arrayType, numberType)
		if hasStringConstituent && arrayElementType {
			if arrayElementType.flags&TypeFlagsStringLike && !compilerOptions.noUncheckedIndexedAccess {
				return stringType
			}
			return getUnionType( /* TODO(ConditionalExpression): possibleOutOfBounds ? [arrayElementType, stringType, undefinedType] : [arrayElementType, stringType] */ TODO, UnionReductionSubtype)
		}
		return /* TODO(ConditionalExpression): (use & IterationUse.PossiblyOutOfBounds) ? includeUndefinedInIndexSignature(arrayElementType) : arrayElementType */ TODO
		getIterationDiagnosticDetails := func(allowsStrings bool, downlevelIteration /* TODO(BooleanKeyword): boolean */ any) /* TODO(TupleType): [error: DiagnosticMessage, maybeMissingAwait: boolean] */ any {
			if downlevelIteration {
				return /* TODO(ConditionalExpression): allowsStrings                     ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true]                     : [Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true] */ TODO
			}
			yieldType := getIterationTypeOfIterable(use, IterationTypeKindYield, inputType, nil)
			if yieldType {
				return /* TODO(ArrayLiteralExpression): [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, false] */ TODO
			}
			if isES2015OrLaterIterable(inputType.symbol.escapedName) {
				return /* TODO(ArrayLiteralExpression): [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, true] */ TODO
			}
			return /* TODO(ConditionalExpression): allowsStrings                 ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true]                 : [Diagnostics.Type_0_is_not_an_array_type, true] */ TODO
		}
	}
	isES2015OrLaterIterable := func(n __String) /* TODO inferred type boolean */ TODO {
		switch n {
		case "Float32Array":
			fallthrough // TODO: merge cases
		case "Float64Array":
			fallthrough // TODO: merge cases
		case "Int16Array":
			fallthrough // TODO: merge cases
		case "Int32Array":
			fallthrough // TODO: merge cases
		case "Int8Array":
			fallthrough // TODO: merge cases
		case "NodeList":
			fallthrough // TODO: merge cases
		case "Uint16Array":
			fallthrough // TODO: merge cases
		case "Uint32Array":
			fallthrough // TODO: merge cases
		case "Uint8Array":
			fallthrough // TODO: merge cases
		case "Uint8ClampedArray":
			return true
		}
		return false
	}
	getIterationTypeOfIterable := func(use IterationUse, typeKind IterationTypeKind, inputType Type, errorNode Node) *Type {
		if isTypeAny(inputType) {
			return nil
		}
		iterationTypes := getIterationTypesOfIterable(inputType, use, errorNode)
		return iterationTypes && /* TODO(ElementAccessExpression): iterationTypes[getIterationTypesKeyFromIterationTypeKind(typeKind)] */ TODO
	}
	createIterationTypes := func(yieldType Type /*  = neverType */, returnType Type /*  = neverType */, nextType Type /*  = unknownType */) IterationTypes {
		if yieldType.flags&TypeFlagsIntrinsic && returnType.flags&(TypeFlagsAny|TypeFlagsNever|TypeFlagsUnknown|TypeFlagsVoid|TypeFlagsUndefined) && nextType.flags&(TypeFlagsAny|TypeFlagsNever|TypeFlagsUnknown|TypeFlagsVoid|TypeFlagsUndefined) {
			id := getTypeListId( /* TODO(ArrayLiteralExpression): [yieldType, returnType, nextType] */ TODO)
			iterationTypes := iterationTypesCache.get(id)
			if !iterationTypes {
				iterationTypes = /* TODO(ObjectLiteralExpression): { yieldType, returnType, nextType } */ TODO
				iterationTypesCache.set(id, iterationTypes)
			}
			return iterationTypes
		}
		return /* TODO(ObjectLiteralExpression): { yieldType, returnType, nextType } */ TODO
	}
	combineIterationTypes := func(array []*IterationTypes) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		var yieldTypes /* TODO(ArrayType): Type[] */ any
		var returnTypes /* TODO(ArrayType): Type[] */ any
		var nextTypes /* TODO(ArrayType): Type[] */ any
		for _, iterationTypes := range array {
			if iterationTypes == nil || iterationTypes == noIterationTypes {
				continue
			}
			if iterationTypes == anyIterationTypes {
				return anyIterationTypes
			}
			yieldTypes = append(yieldTypes, iterationTypes.yieldType)
			returnTypes = append(returnTypes, iterationTypes.returnType)
			nextTypes = append(nextTypes, iterationTypes.nextType)
		}
		if yieldTypes || returnTypes || nextTypes {
			return createIterationTypes(yieldTypes && getUnionType(yieldTypes), returnTypes && getUnionType(returnTypes), nextTypes && getIntersectionType(nextTypes))
		}
		return noIterationTypes
	}
	getCachedIterationTypes := func(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes]) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		return /* TODO(ElementAccessExpression): (type as IterableOrIteratorType)[cacheKey] */ TODO
	}
	setCachedIterationTypes := func(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes], cachedTypes IterationTypes) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): (type as IterableOrIteratorType)[cacheKey] = cachedTypes */ TODO
	}
	getIterationTypesOfIterable := func(type_ Type, use IterationUse, errorNode Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		if !(type_.flags & TypeFlagsUnion) {
			var errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any = /* TODO(ConditionalExpression): errorNode ? { errors: undefined } : undefined */ TODO
			iterationTypes := getIterationTypesOfIterableWorker(type_, use, errorNode, errorOutputContainer)
			if iterationTypes == noIterationTypes {
				if errorNode {
					rootDiag := reportTypeNotIterableError(errorNode, type_, !!(use & IterationUseAllowsAsyncIterablesFlag))
					if errorOutputContainer.errors {
						addRelatedInfo(rootDiag /* TODO(SpreadElement): ...errorOutputContainer.errors */, TODO)
					}
				}
				return nil
			} else if errorOutputContainer.errors.length {
				for _, diag := range errorOutputContainer.errors {
					diagnostics.add(diag)
				}
			}
			return iterationTypes
		}
		cacheKey := /* TODO(ConditionalExpression): use & IterationUse.AllowsAsyncIterablesFlag ? "iterationTypesOfAsyncIterable" : "iterationTypesOfIterable" */ TODO
		cachedTypes := getCachedIterationTypes(type_, cacheKey)
		if cachedTypes {
			return /* TODO(ConditionalExpression): cachedTypes === noIterationTypes ? undefined : cachedTypes */ TODO
		}
		var allIterationTypes /* TODO(ArrayType): IterationTypes[] */ any
		for _, constituent := range (type_).types {
			var errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any = /* TODO(ConditionalExpression): errorNode ? { errors: undefined } : undefined */ TODO
			iterationTypes := getIterationTypesOfIterableWorker(constituent, use, errorNode, errorOutputContainer)
			if iterationTypes == noIterationTypes {
				if errorNode {
					rootDiag := reportTypeNotIterableError(errorNode, type_, !!(use & IterationUseAllowsAsyncIterablesFlag))
					if errorOutputContainer.errors {
						addRelatedInfo(rootDiag /* TODO(SpreadElement): ...errorOutputContainer.errors */, TODO)
					}
				}
				setCachedIterationTypes(type_, cacheKey, noIterationTypes)
				return nil
			} else if errorOutputContainer.errors.length {
				for _, diag := range errorOutputContainer.errors {
					diagnostics.add(diag)
				}
			}
			allIterationTypes = append(allIterationTypes, iterationTypes)
		}
		iterationTypes := /* TODO(ConditionalExpression): allIterationTypes ? combineIterationTypes(allIterationTypes) : noIterationTypes */ TODO
		setCachedIterationTypes(type_, cacheKey, iterationTypes)
		return /* TODO(ConditionalExpression): iterationTypes === noIterationTypes ? undefined : iterationTypes */ TODO
	}
	getAsyncFromSyncIterationTypes := func(iterationTypes IterationTypes, errorNode Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		if iterationTypes == noIterationTypes {
			return noIterationTypes
		}
		if iterationTypes == anyIterationTypes {
			return anyIterationTypes
		}
		TODO_IDENTIFIER := iterationTypes
		if errorNode {
			getGlobalAwaitedSymbol(true)
		}
		return createIterationTypes(getAwaitedType(yieldType, errorNode) || anyType, getAwaitedType(returnType, errorNode) || anyType, nextType)
	}
	getIterationTypesOfIterableWorker := func(type_ Type, use IterationUse, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		noCache := false
		if use & IterationUseAllowsAsyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableCached(type_, asyncIterationTypesResolver) || getIterationTypesOfIterableFast(type_, asyncIterationTypesResolver)
			if iterationTypes {
				if iterationTypes == noIterationTypes && errorNode {
					noCache = true
				} else {
					return /* TODO(ConditionalExpression): use & IterationUse.ForOfFlag ?                         getAsyncFromSyncIterationTypes(iterationTypes, errorNode) :                         iterationTypes */ TODO
				}
			}
		}
		if use & IterationUseAllowsSyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableCached(type_, syncIterationTypesResolver) || getIterationTypesOfIterableFast(type_, syncIterationTypesResolver)
			if iterationTypes {
				if iterationTypes == noIterationTypes && errorNode {
					noCache = true
				} else {
					if use & IterationUseAllowsAsyncIterablesFlag {
						if iterationTypes != noIterationTypes {
							iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
							return /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes) */ TODO
						}
					} else {
						return iterationTypes
					}
				}
			}
		}
		if use & IterationUseAllowsAsyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableSlow(type_, asyncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
			if iterationTypes != noIterationTypes {
				return iterationTypes
			}
		}
		if use & IterationUseAllowsSyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableSlow(type_, syncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
			if iterationTypes != noIterationTypes {
				if use & IterationUseAllowsAsyncIterablesFlag {
					iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
					return /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes) */ TODO
				} else {
					return iterationTypes
				}
			}
		}
		return noIterationTypes
	}
	getIterationTypesOfIterableCached := func(type_ Type, resolver IterationTypesResolver) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		return getCachedIterationTypes(type_, resolver.iterableCacheKey)
	}
	getIterationTypesOfIterableFast := func(type_ Type, resolver IterationTypesResolver) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isReferenceToType(type_, resolver.getGlobalIterableType(false)) || isReferenceToType(type_, resolver.getGlobalIteratorObjectType(false)) || isReferenceToType(type_, resolver.getGlobalIterableIteratorType(false)) || isReferenceToType(type_, resolver.getGlobalGeneratorType(false)) {
			TODO_IDENTIFIER := getTypeArguments(type_)
			return setCachedIterationTypes(type_, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType, nil) || yieldType, resolver.resolveIterationType(returnType, nil) || returnType, nextType))
		}
		if isReferenceToSomeType(type_, resolver.getGlobalBuiltinIteratorTypes()) {
			TODO_IDENTIFIER := getTypeArguments(type_)
			returnType := getBuiltinIteratorReturnType()
			nextType := unknownType
			return setCachedIterationTypes(type_, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType, nil) || yieldType, resolver.resolveIterationType(returnType, nil) || returnType, nextType))
		}
	}
	getPropertyNameForKnownSymbolName := func(symbolName string) __String {
		ctorType := getGlobalESSymbolConstructorSymbol(false)
		uniqueType := ctorType && getTypeOfPropertyOfType(getTypeOfSymbol(ctorType), escapeLeadingUnderscores(symbolName))
		return /* TODO(ConditionalExpression): uniqueType && isTypeUsableAsPropertyName(uniqueType) ? getPropertyNameFromType(uniqueType) : `__@${symbolName}` as __String */ TODO
	}
	getIterationTypesOfIterableSlow := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		method := getPropertyOfType(type_, getPropertyNameForKnownSymbolName(resolver.iteratorSymbolName))
		methodType := /* TODO(ConditionalExpression): method && !(method.flags & SymbolFlags.Optional) ? getTypeOfSymbol(method) : undefined */ TODO
		if isTypeAny(methodType) {
			return /* TODO(ConditionalExpression): noCache ? anyIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, anyIterationTypes) */ TODO
		}
		signatures := /* TODO(ConditionalExpression): methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : undefined */ TODO
		if !some(signatures) {
			return /* TODO(ConditionalExpression): noCache ? noIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, noIterationTypes) */ TODO
		}
		iteratorType := getIntersectionType(map_(signatures, getReturnTypeOfSignature))
		iterationTypes := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getIterationTypesOfIteratorWorker(iteratorType, resolver, errorNode, errorOutputContainer, noCache) ?? noIterationTypes */ TODO
		return /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, iterationTypes) */ TODO
	}
	reportTypeNotIterableError := func(errorNode Node, type_ Type, allowAsyncIterables bool) Diagnostic {
		message := /* TODO(ConditionalExpression): allowAsyncIterables             ? Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator             : Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator */ TODO
		suggestAwait := !!getAwaitedTypeOfPromise(type_) || (!allowAsyncIterables && isForOfStatement(errorNode.parent) && errorNode.parent.expression == errorNode && getGlobalAsyncIterableType(false) != emptyGenericType && isTypeAssignableTo(type_, createTypeFromGenericGlobalType(getGlobalAsyncIterableType(false) /* TODO(ArrayLiteralExpression): [anyType, anyType, anyType] */, TODO)))
		return errorAndMaybeSuggestAwait(errorNode, suggestAwait, message, typeToString(type_))
	}
	getIterationTypesOfIterator := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		return getIterationTypesOfIteratorWorker(type_, resolver, errorNode, errorOutputContainer, false)
	}
	getIterationTypesOfIteratorWorker := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		iterationTypes := getIterationTypesOfIteratorCached(type_, resolver) || getIterationTypesOfIteratorFast(type_, resolver)
		if iterationTypes == noIterationTypes && errorNode {
			iterationTypes = nil
			noCache = true
		}
		/* TODO(ExpressionStatement): iterationTypes ??= getIterationTypesOfIteratorSlow(type, resolver, errorNode, errorOutputContainer, noCache); */
		return /* TODO(ConditionalExpression): iterationTypes === noIterationTypes ? undefined : iterationTypes */ TODO
	}
	getIterationTypesOfIteratorCached := func(type_ Type, resolver IterationTypesResolver) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		return getCachedIterationTypes(type_, resolver.iteratorCacheKey)
	}
	getIterationTypesOfIteratorFast := func(type_ Type, resolver IterationTypesResolver) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isReferenceToType(type_, resolver.getGlobalIterableIteratorType(false)) || isReferenceToType(type_, resolver.getGlobalIteratorType(false)) || isReferenceToType(type_, resolver.getGlobalIteratorObjectType(false)) || isReferenceToType(type_, resolver.getGlobalGeneratorType(false)) {
			TODO_IDENTIFIER := getTypeArguments(type_)
			return setCachedIterationTypes(type_, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType))
		}
		if isReferenceToSomeType(type_, resolver.getGlobalBuiltinIteratorTypes()) {
			TODO_IDENTIFIER := getTypeArguments(type_)
			returnType := getBuiltinIteratorReturnType()
			nextType := unknownType
			return setCachedIterationTypes(type_, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType))
		}
	}
	isIteratorResult := func(type_ Type, kind /* TODO(UnionType): IterationTypeKind.Yield | IterationTypeKind.Return */ any) /* TODO inferred type boolean */ TODO {
		doneType := getTypeOfPropertyOfType(type_, "done") || falseType
		return isTypeAssignableTo( /* TODO(ConditionalExpression): kind === IterationTypeKind.Yield ? falseType : trueType */ TODO, doneType)
	}
	isYieldIteratorResult := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return isIteratorResult(type_, IterationTypeKindYield)
	}
	isReturnIteratorResult := func(type_ Type) /* TODO inferred type boolean */ TODO {
		return isIteratorResult(type_, IterationTypeKindReturn)
	}
	getIterationTypesOfIteratorResult := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		cachedTypes := getCachedIterationTypes(type_, "iterationTypesOfIteratorResult")
		if cachedTypes {
			return cachedTypes
		}
		if isReferenceToType(type_, getGlobalIteratorYieldResultType(false)) {
			yieldType := /* TODO(ElementAccessExpression): getTypeArguments(type as GenericType)[0] */ TODO
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, nil, nil))
		}
		if isReferenceToType(type_, getGlobalIteratorReturnResultType(false)) {
			returnType := /* TODO(ElementAccessExpression): getTypeArguments(type as GenericType)[0] */ TODO
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(nil, returnType, nil))
		}
		yieldIteratorResult := filterType(type_, isYieldIteratorResult)
		yieldType := /* TODO(ConditionalExpression): yieldIteratorResult !== neverType ? getTypeOfPropertyOfType(yieldIteratorResult, "value" as __String) : undefined */ TODO
		returnIteratorResult := filterType(type_, isReturnIteratorResult)
		returnType := /* TODO(ConditionalExpression): returnIteratorResult !== neverType ? getTypeOfPropertyOfType(returnIteratorResult, "value" as __String) : undefined */ TODO
		if !yieldType && !returnType {
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", noIterationTypes)
		}
		return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, returnType || voidType, nil))
	}
	getIterationTypesOfMethod := func(type_ Type, resolver IterationTypesResolver, methodName /* TODO(UnionType): "next" | "return" | "throw" */ any, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) *IterationTypes {
		method := getPropertyOfType(type_, methodName)
		if !method && methodName != "next" {
			return nil
		}
		methodType := /* TODO(ConditionalExpression): method && !(methodName === "next" && (method.flags & SymbolFlags.Optional))             ? methodName === "next" ? getTypeOfSymbol(method) : getTypeWithFacts(getTypeOfSymbol(method), TypeFacts.NEUndefinedOrNull)             : undefined */ TODO
		if isTypeAny(methodType) {
			return anyIterationTypes
		}
		methodSignatures := /* TODO(ConditionalExpression): methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : emptyArray */ TODO
		if methodSignatures.length == 0 {
			if errorNode {
				diagnostic := /* TODO(ConditionalExpression): methodName === "next"                     ? resolver.mustHaveANextMethodDiagnostic                     : resolver.mustBeAMethodDiagnostic */ TODO
				if errorOutputContainer {
					/* TODO(ExpressionStatement): errorOutputContainer.errors ??= []; */
					errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, diagnostic, methodName))
				} else {
					error(errorNode, diagnostic, methodName)
				}
			}
			return /* TODO(ConditionalExpression): methodName === "next" ? noIterationTypes : undefined */ TODO
		}
		if methodType.symbol && methodSignatures.length == 1 {
			globalGeneratorType := resolver.getGlobalGeneratorType(false)
			globalIteratorType := resolver.getGlobalIteratorType(false)
			isGeneratorMethod := globalGeneratorType.symbol.members.get(methodName) == methodType.symbol
			isIteratorMethod := !isGeneratorMethod && globalIteratorType.symbol.members.get(methodName) == methodType.symbol
			if isGeneratorMethod || isIteratorMethod {
				globalType := /* TODO(ConditionalExpression): isGeneratorMethod ? globalGeneratorType : globalIteratorType */ TODO
				TODO_IDENTIFIER := methodType
				return createIterationTypes(getMappedType( /* TODO(ElementAccessExpression): globalType.typeParameters![0] */ TODO, mapper), getMappedType( /* TODO(ElementAccessExpression): globalType.typeParameters![1] */ TODO, mapper) /* TODO(ConditionalExpression): methodName === "next" ? getMappedType(globalType.typeParameters![2], mapper!) : undefined */, TODO)
			}
		}
		var methodParameterTypes /* TODO(ArrayType): Type[] */ any
		var methodReturnTypes /* TODO(ArrayType): Type[] */ any
		for _, signature := range methodSignatures {
			if methodName != "throw" && some(signature.parameters) {
				methodParameterTypes = append(methodParameterTypes, getTypeAtPosition(signature, 0))
			}
			methodReturnTypes = append(methodReturnTypes, getReturnTypeOfSignature(signature))
		}
		var returnTypes /* TODO(ArrayType): Type[] */ any
		var nextType *Type
		if methodName != "throw" {
			methodParameterType := /* TODO(ConditionalExpression): methodParameterTypes ? getUnionType(methodParameterTypes) : unknownType */ TODO
			if methodName == "next" {
				nextType = methodParameterType
			} else if methodName == "return" {
				resolvedMethodParameterType := resolver.resolveIterationType(methodParameterType, errorNode) || anyType
				returnTypes = append(returnTypes, resolvedMethodParameterType)
			}
		}
		var yieldType Type
		methodReturnType := /* TODO(ConditionalExpression): methodReturnTypes ? getIntersectionType(methodReturnTypes) : neverType */ TODO
		resolvedMethodReturnType := resolver.resolveIterationType(methodReturnType, errorNode) || anyType
		iterationTypes := getIterationTypesOfIteratorResult(resolvedMethodReturnType)
		if iterationTypes == noIterationTypes {
			if errorNode {
				if errorOutputContainer {
					/* TODO(ExpressionStatement): errorOutputContainer.errors ??= []; */
					errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, resolver.mustHaveAValueDiagnostic, methodName))
				} else {
					error(errorNode, resolver.mustHaveAValueDiagnostic, methodName)
				}
			}
			yieldType = anyType
			returnTypes = append(returnTypes, anyType)
		} else {
			yieldType = iterationTypes.yieldType
			returnTypes = append(returnTypes, iterationTypes.returnType)
		}
		return createIterationTypes(yieldType, getUnionType(returnTypes), nextType)
	}
	getIterationTypesOfIteratorSlow := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		iterationTypes := combineIterationTypes( /* TODO(ArrayLiteralExpression): [             getIterationTypesOfMethod(type, resolver, "next", errorNode, errorOutputContainer),             getIterationTypesOfMethod(type, resolver, "return", errorNode, errorOutputContainer),             getIterationTypesOfMethod(type, resolver, "throw", errorNode, errorOutputContainer),         ] */ TODO)
		return /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iteratorCacheKey, iterationTypes) */ TODO
	}
	getIterationTypeOfGeneratorFunctionReturnType := func(kind IterationTypeKind, returnType Type, isAsyncGenerator bool) *Type {
		if isTypeAny(returnType) {
			return nil
		}
		iterationTypes := getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsyncGenerator)
		return iterationTypes && /* TODO(ElementAccessExpression): iterationTypes[getIterationTypesKeyFromIterationTypeKind(kind)] */ TODO
	}
	getIterationTypesOfGeneratorFunctionReturnType := func(type_ Type, isAsyncGenerator bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		use := /* TODO(ConditionalExpression): isAsyncGenerator ? IterationUse.AsyncGeneratorReturnType : IterationUse.GeneratorReturnType */ TODO
		resolver := /* TODO(ConditionalExpression): isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver */ TODO
		return getIterationTypesOfIterable(type_, use, nil) || getIterationTypesOfIterator(type_, resolver, nil, nil)
	}
	checkBreakOrContinueStatement := func(node BreakOrContinueStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			checkGrammarBreakOrContinueStatement(node)
		}
	}
	unwrapReturnType := func(returnType Type, functionFlags FunctionFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		isGenerator := !!(functionFlags & FunctionFlagsGenerator)
		isAsync := !!(functionFlags & FunctionFlagsAsync)
		if isGenerator {
			returnIterationType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, returnType, isAsync)
			if !returnIterationType {
				return errorType
			}
			return /* TODO(ConditionalExpression): isAsync ? getAwaitedTypeNoAlias(unwrapAwaitedType(returnIterationType)) : returnIterationType */ TODO
		}
		return /* TODO(ConditionalExpression): isAsync ? getAwaitedTypeNoAlias(returnType) || errorType : returnType */ TODO
	}
	isUnwrappedReturnTypeUndefinedVoidOrAny := func(func_ SignatureDeclaration, returnType Type) bool {
		type_ := unwrapReturnType(returnType, getFunctionFlags(func_))
		return !!(type_ && (maybeTypeOfKind(type_, TypeFlagsVoid) || type_.flags&(TypeFlagsAny|TypeFlagsUndefined)))
	}
	checkReturnStatement := func(node ReturnStatement) {
		if checkGrammarStatementInAmbientContext(node) {
			return
		}
		container := getContainingFunctionOrClassStaticBlock(node)
		if container && isClassStaticBlockDeclaration(container) {
			grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block)
			return
		}
		if !container {
			grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_can_only_be_used_within_a_function_body)
			return
		}
		signature := getSignatureFromDeclaration(container)
		returnType := getReturnTypeOfSignature(signature)
		functionFlags := getFunctionFlags(container)
		if strictNullChecks || node.expression || returnType.flags&TypeFlagsNever {
			exprType := /* TODO(ConditionalExpression): node.expression ? checkExpressionCached(node.expression) : undefinedType */ TODO
			if container.kind == SyntaxKindSetAccessor {
				if node.expression {
					error(node, Diagnostics.Setters_cannot_return_a_value)
				}
			} else if container.kind == SyntaxKindConstructor {
				if node.expression && !checkTypeAssignableToAndOptionallyElaborate(exprType, returnType, node, node.expression) {
					error(node, Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class)
				}
			} else if getReturnTypeFromAnnotation(container) {
				unwrappedReturnType := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): unwrapReturnType(returnType, functionFlags) ?? returnType */ TODO
				unwrappedExprType := /* TODO(ConditionalExpression): functionFlags & FunctionFlags.Async                     ? checkAwaitedType(exprType, /*withAlias* / false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)                     : exprType */ TODO
				if unwrappedReturnType {
					checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, node, node.expression)
				}
			}
		} else if container.kind != SyntaxKindConstructor && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeUndefinedVoidOrAny(container, returnType) {
			error(node, Diagnostics.Not_all_code_paths_return_a_value)
		}
	}
	checkWithStatement := func(node WithStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			if node.flags & NodeFlagsAwaitContext {
				grammarErrorOnFirstToken(node, Diagnostics.with_statements_are_not_allowed_in_an_async_function_block)
			}
		}
		checkExpression(node.expression)
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			start := getSpanOfTokenAtPosition(sourceFile, node.pos).start
			end := node.statement.pos
			grammarErrorAtPos(sourceFile, start /* TODO(MinusToken): - */ /* TODO(BinaryExpression): end - start */, TODO, Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any)
		}
	}
	checkSwitchStatement := func(node SwitchStatement) {
		checkGrammarStatementInAmbientContext(node)
		var firstDefaultClause CaseOrDefaultClause
		hasDuplicateDefaultClause := false
		expressionType := checkExpression(node.expression)
		forEach(node.caseBlock.clauses, func(clause /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").CaseClause | import("/home/jabaile/work/TypeScript/src/compiler/types").DefaultClause */ TODO) {
			if clause.kind == SyntaxKindDefaultClause && !hasDuplicateDefaultClause {
				if firstDefaultClause == nil {
					firstDefaultClause = clause
				} else {
					grammarErrorOnNode(clause, Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement)
					hasDuplicateDefaultClause = true
				}
			}
			if clause.kind == SyntaxKindCaseClause {
				addLazyDiagnostic(createLazyCaseClauseDiagnostics(clause))
			}
			forEach(clause.statements, checkSourceElement)
			if compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(clause.fallthroughFlowNode) {
				error(clause, Diagnostics.Fallthrough_case_in_switch)
			}
			createLazyCaseClauseDiagnostics := func(clause CaseClause) /* TODO inferred type () => void */ TODO {
				return func() {
					caseType := checkExpression(clause.expression)
					if !isTypeEqualityComparableTo(expressionType, caseType) {
						checkTypeComparableTo(caseType, expressionType, clause.expression, nil)
					}
				}
			}
		})
		if node.caseBlock.locals {
			registerForUnusedIdentifiersCheck(node.caseBlock)
		}
	}
	checkLabeledStatement := func(node LabeledStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			findAncestor(node.parent, func(current /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
				if isFunctionLike(current) {
					return "quit"
				}
				if current.kind == SyntaxKindLabeledStatement && (current).label.escapedText == node.label.escapedText {
					grammarErrorOnNode(node.label, Diagnostics.Duplicate_label_0, getTextOfNode(node.label))
					return true
				}
				return false
			})
		}
		checkSourceElement(node.statement)
	}
	checkThrowStatement := func(node ThrowStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			if isIdentifier(node.expression) && !node.expression.escapedText {
				grammarErrorAfterFirstToken(node, Diagnostics.Line_break_not_permitted_here)
			}
		}
		if node.expression {
			checkExpression(node.expression)
		}
	}
	checkTryStatement := func(node TryStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkBlock(node.tryBlock)
		catchClause := node.catchClause
		if catchClause {
			if catchClause.variableDeclaration {
				declaration := catchClause.variableDeclaration
				checkVariableLikeDeclaration(declaration)
				typeNode := getEffectiveTypeAnnotationNode(declaration)
				if typeNode {
					type_ := getTypeFromTypeNode(typeNode)
					if type_ && !(type_.flags & TypeFlagsAnyOrUnknown) {
						grammarErrorOnFirstToken(typeNode, Diagnostics.Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified)
					}
				} else if declaration.initializer {
					grammarErrorOnFirstToken(declaration.initializer, Diagnostics.Catch_clause_variable_cannot_have_an_initializer)
				} else {
					blockLocals := catchClause.block.locals
					if blockLocals {
						forEachKey(catchClause.locals, func(caughtName /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
							blockLocal := blockLocals.get(caughtName)
							if blockLocal.valueDeclaration && (blockLocal.flags&SymbolFlagsBlockScopedVariable) != 0 {
								grammarErrorOnNode(blockLocal.valueDeclaration, Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, unescapeLeadingUnderscores(caughtName))
							}
						})
					}
				}
			}
			checkBlock(catchClause.block)
		}
		if node.finallyBlock {
			checkBlock(node.finallyBlock)
		}
	}
	checkIndexConstraints := func(type_ Type, symbol Symbol, isStaticIndex bool) {
		indexInfos := getIndexInfosOfType(type_)
		if indexInfos.length == 0 {
			return
		}
		for _, prop := range getPropertiesOfObjectType(type_) {
			if !(isStaticIndex && prop.flags&SymbolFlagsPrototype) {
				checkIndexConstraintForProperty(type_, prop, getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique, true), getNonMissingTypeOfSymbol(prop))
			}
		}
		typeDeclaration := symbol.valueDeclaration
		if typeDeclaration && isClassLike(typeDeclaration) {
			for _, member := range typeDeclaration.members {
				if !isStatic(member) && !hasBindableName(member) {
					symbol := getSymbolOfDeclaration(member)
					checkIndexConstraintForProperty(type_, symbol, getTypeOfExpression((member).name.expression), getNonMissingTypeOfSymbol(symbol))
				}
			}
		}
		if indexInfos.length > 1 {
			for _, info := range indexInfos {
				checkIndexConstraintForIndexSignature(type_, info)
			}
		}
	}
	checkIndexConstraintForProperty := func(type_ Type, prop Symbol, propNameType Type, propType Type) {
		declaration := prop.valueDeclaration
		name := getNameOfDeclaration(declaration)
		if name && isPrivateIdentifier(name) {
			return
		}
		indexInfos := getApplicableIndexInfos(type_, propNameType)
		interfaceDeclaration := /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined */ TODO
		propDeclaration := /* TODO(ConditionalExpression): declaration && declaration.kind === SyntaxKind.BinaryExpression ||                 name && name.kind === SyntaxKind.ComputedPropertyName ? declaration : undefined */ TODO
		localPropDeclaration := /* TODO(ConditionalExpression): getParentOfSymbol(prop) === type.symbol ? declaration : undefined */ TODO
		for _, info := range indexInfos {
			localIndexDeclaration := /* TODO(ConditionalExpression): info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined */ TODO
			errorNode := localPropDeclaration || localIndexDeclaration || ( /* TODO(ConditionalExpression): interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getPropertyOfObjectType(base, prop.escapedName) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined */ TODO)
			if errorNode && !isTypeAssignableTo(propType, info.type_) {
				diagnostic := createError(errorNode, Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3, symbolToString(prop), typeToString(propType), typeToString(info.keyType), typeToString(info.type_))
				if propDeclaration && errorNode != propDeclaration {
					addRelatedInfo(diagnostic, createDiagnosticForNode(propDeclaration, Diagnostics._0_is_declared_here, symbolToString(prop)))
				}
				diagnostics.add(diagnostic)
			}
		}
	}
	checkIndexConstraintForIndexSignature := func(type_ Type, checkInfo IndexInfo) {
		declaration := checkInfo.declaration
		indexInfos := getApplicableIndexInfos(type_, checkInfo.keyType)
		interfaceDeclaration := /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined */ TODO
		localCheckDeclaration := /* TODO(ConditionalExpression): declaration && getParentOfSymbol(getSymbolOfDeclaration(declaration)) === type.symbol ? declaration : undefined */ TODO
		for _, info := range indexInfos {
			if info == checkInfo {
				continue
			}
			localIndexDeclaration := /* TODO(ConditionalExpression): info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined */ TODO
			errorNode := localCheckDeclaration || localIndexDeclaration || ( /* TODO(ConditionalExpression): interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getIndexInfoOfType(base, checkInfo.keyType) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined */ TODO)
			if errorNode && !isTypeAssignableTo(checkInfo.type_, info.type_) {
				error(errorNode, Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3, typeToString(checkInfo.keyType), typeToString(checkInfo.type_), typeToString(info.keyType), typeToString(info.type_))
			}
		}
	}
	checkTypeNameIsReserved := func(name Identifier, message DiagnosticMessage) {
		switch name.escapedText {
		case "any":
			fallthrough // TODO: merge cases
		case "unknown":
			fallthrough // TODO: merge cases
		case "never":
			fallthrough // TODO: merge cases
		case "number":
			fallthrough // TODO: merge cases
		case "bigint":
			fallthrough // TODO: merge cases
		case "boolean":
			fallthrough // TODO: merge cases
		case "string":
			fallthrough // TODO: merge cases
		case "symbol":
			fallthrough // TODO: merge cases
		case "void":
			fallthrough // TODO: merge cases
		case "object":
			fallthrough // TODO: merge cases
		case "undefined":
			error(name, message, name.escapedText)
		}
	}
	checkClassNameCollisionWithObject := func(name Identifier) {
		if languageVersion >= ScriptTargetES5 && name.escapedText == "Object" && host.getEmitModuleFormatOfFile(getSourceFileOfNode(name)) < ModuleKindES2015 {
			error(name, Diagnostics.Class_name_cannot_be_Object_when_targeting_ES5_with_module_0 /* TODO(ElementAccessExpression): ModuleKind[moduleKind] */, TODO)
		}
	}
	checkUnmatchedJSDocParameters := func(node SignatureDeclaration) {
		jsdocParameters := filter(getJSDocTags(node), isJSDocParameterTag)
		if !length(jsdocParameters) {
			return
		}
		isJs := isInJSFile(node)
		parameters := make(map[__String]struct{})
		excludedParameters := make(map[number]struct{})
		forEach(node.parameters, func(TODO_IDENTIFIER /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO, index /* TODO inferred type number */ TODO) {
			if isIdentifier(name) {
				parameters.add(name.escapedText)
			}
			if isBindingPattern(name) {
				excludedParameters.add(index)
			}
		})
		containsArguments := containsArgumentsReference(node)
		if containsArguments {
			lastJSDocParamIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): jsdocParameters.length - 1 */ TODO
			lastJSDocParam := /* TODO(ElementAccessExpression): jsdocParameters[lastJSDocParamIndex] */ TODO
			if isJs && lastJSDocParam && isIdentifier(lastJSDocParam.name) && lastJSDocParam.typeExpression && lastJSDocParam.typeExpression.type_ && !parameters.has(lastJSDocParam.name.escapedText) && !excludedParameters.has(lastJSDocParamIndex) && !isArrayType(getTypeFromTypeNode(lastJSDocParam.typeExpression.type_)) {
				error(lastJSDocParam.name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type, idText(lastJSDocParam.name))
			}
		} else {
			forEach(jsdocParameters, func(TODO_IDENTIFIER /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocParameterTag */ TODO, index /* TODO inferred type number */ TODO) {
				if excludedParameters.has(index) || isIdentifier(name) && parameters.has(name.escapedText) {
					return
				}
				if isQualifiedName(name) {
					if isJs {
						error(name, Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, entityNameToString(name), entityNameToString(name.left))
					}
				} else {
					if !isNameFirst {
						errorOrSuggestion(isJs, name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, idText(name))
					}
				}
			})
		}
	}
	checkTypeParameters := func(typeParameterDeclarations /* TODO(TypeOperator): readonly TypeParameterDeclaration[] */ any) {
		seenDefault := false
		if typeParameterDeclarations {
			/* TODO(ForStatement): for (let i = 0; i < typeParameterDeclarations.length; i++) {                 const node = typeParameterDeclarations[i];                 checkTypeParameter(node);                  addLazyDiagnostic(createCheckTypeParameterDiagnostic(node, i));             } */
		}
		createCheckTypeParameterDiagnostic := func(node TypeParameterDeclaration, i number) /* TODO inferred type () => void */ TODO {
			return func() {
				if node.default_ {
					seenDefault = true
					checkTypeParametersNotReferenced(node.default_, typeParameterDeclarations, i)
				} else if seenDefault {
					error(node, Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters)
				}
				/* TODO(ForStatement): for (let j = 0; j < i; j++) {                     if (typeParameterDeclarations![j].symbol === node.symbol) {                         error(node.name, Diagnostics.Duplicate_identifier_0, declarationNameToString(node.name));                     }                 } */
			}
		}
	}
	checkTypeParametersNotReferenced := func(root TypeNode, typeParameters []TypeParameterDeclaration, index number) {
		visit(root)
		visit := func(node Node) {
			if node.kind == SyntaxKindTypeReference {
				type_ := getTypeFromTypeReference(node)
				if type_.flags & TypeFlagsTypeParameter {
					/* TODO(ForStatement): for (let i = index; i < typeParameters.length; i++) {                         if (type.symbol === getSymbolOfDeclaration(typeParameters[i])) {                             error(node, Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters);                         }                     } */
				}
			}
			forEachChild(node, visit)
		}
	}
	checkTypeParameterListsIdentical := func(symbol Symbol) {
		if symbol.declarations && symbol.declarations.length == 1 {
			return
		}
		links := getSymbolLinks(symbol)
		if !links.typeParametersChecked {
			links.typeParametersChecked = true
			declarations := getClassOrInterfaceDeclarationsOfSymbol(symbol)
			if !declarations || declarations.length <= 1 {
				return
			}
			type_ := getDeclaredTypeOfSymbol(symbol)
			if !areTypeParametersIdentical(declarations, type_.localTypeParameters, getEffectiveTypeParameterDeclarations) {
				name := symbolToString(symbol)
				for _, declaration := range declarations {
					error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, name)
				}
			}
		}
	}
	areTypeParametersIdentical := func(declarations []T, targetParameters []TypeParameter, getTypeParameterDeclarations func(node T) []TypeParameterDeclaration) /* TODO inferred type boolean */ TODO {
		maxTypeArgumentCount := length(targetParameters)
		minTypeArgumentCount := getMinTypeArgumentCount(targetParameters)
		for _, declaration := range declarations {
			sourceParameters := getTypeParameterDeclarations(declaration)
			numTypeParameters := sourceParameters.length
			if numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount {
				return false
			}
			/* TODO(ForStatement): for (let i = 0; i < numTypeParameters; i++) {                 const source = sourceParameters[i];                 const target = targetParameters[i];                  // If the type parameter node does not have the same as the resolved type                 // parameter at this position, we report an error.                 if (source.name.escapedText !== target.symbol.escapedName) {                     return false;                 }                  // If the type parameter node does not have an identical constraint as the resolved                 // type parameter at this position, we report an error.                 const constraint = getEffectiveConstraintOfTypeParameter(source);                 const sourceConstraint = constraint && getTypeFromTypeNode(constraint);                 const targetConstraint = getConstraintOfTypeParameter(target);                 // relax check if later interface augmentation has no constraint, it's more broad and is OK to merge with                 // a more constrained interface (this could be generalized to a full hierarchy check, but that's maybe overkill)                 if (sourceConstraint && targetConstraint && !isTypeIdenticalTo(sourceConstraint, targetConstraint)) {                     return false;                 }                  // If the type parameter node has a default and it is not identical to the default                 // for the type parameter at this position, we report an error.                 const sourceDefault = source.default && getTypeFromTypeNode(source.default);                 const targetDefault = getDefaultFromTypeParameter(target);                 if (sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault)) {                     return false;                 }             } */
		}
		return true
	}
	getFirstTransformableStaticClassElement := func(node ClassLikeDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Decorator | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassLikeDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassStaticBlockDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierPropertyDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierMethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierGetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierSetAccessorDeclaration | (import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyDeclaration & { initializer: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; }) | undefined */ TODO {
		willTransformStaticElementsOfDecoratedClass := !legacyDecorators && languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators && classOrConstructorParameterIsDecorated(false, node)
		willTransformPrivateElementsOrClassStaticBlocks := languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators
		willTransformInitializers := !emitStandardClassFields
		if willTransformStaticElementsOfDecoratedClass || willTransformPrivateElementsOrClassStaticBlocks {
			for _, member := range node.members {
				if willTransformStaticElementsOfDecoratedClass && classElementOrClassElementParameterIsDecorated(false, member, node) {
					return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): firstOrUndefined(getDecorators(node)) ?? node */ TODO
				} else if willTransformPrivateElementsOrClassStaticBlocks {
					if isClassStaticBlockDeclaration(member) {
						return member
					} else if isStatic(member) {
						if isPrivateIdentifierClassElementDeclaration(member) || willTransformInitializers && isInitializedProperty(member) {
							return member
						}
					}
				}
			}
		}
	}
	checkClassExpressionExternalHelpers := func(node ClassExpression) {
		if node.name {
			return
		}
		parent := walkUpOuterExpressions(node)
		if !isNamedEvaluationSource(parent) {
			return
		}
		willTransformESDecorators := !legacyDecorators && languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators
		var location Node
		if willTransformESDecorators && classOrConstructorParameterIsDecorated(false, node) {
			location = /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): firstOrUndefined(getDecorators(node)) ?? node */ TODO
		} else {
			location = getFirstTransformableStaticClassElement(node)
		}
		if location {
			checkExternalEmitHelpers(location, ExternalEmitHelpersSetFunctionName)
			if (isPropertyAssignment(parent) || isPropertyDeclaration(parent) || isBindingElement(parent)) && isComputedPropertyName(parent.name) {
				checkExternalEmitHelpers(location, ExternalEmitHelpersPropKey)
			}
		}
	}
	checkClassExpression := func(node ClassExpression) Type {
		checkClassLikeDeclaration(node)
		checkNodeDeferred(node)
		checkClassExpressionExternalHelpers(node)
		return getTypeOfSymbol(getSymbolOfDeclaration(node))
	}
	checkClassExpressionDeferred := func(node ClassExpression) {
		forEach(node.members, checkSourceElement)
		registerForUnusedIdentifiersCheck(node)
	}
	checkClassDeclaration := func(node ClassDeclaration) {
		firstDecorator := find(node.modifiers, isDecorator)
		if legacyDecorators && firstDecorator && some(node.members, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement */ TODO) /* TODO inferred type boolean */ TODO {
			return hasStaticModifier(p) && isPrivateIdentifierClassElementDeclaration(p)
		}) {
			grammarErrorOnNode(firstDecorator, Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator)
		}
		if !node.name && !hasSyntacticModifier(node, ModifierFlagsDefault) {
			grammarErrorOnFirstToken(node, Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name)
		}
		checkClassLikeDeclaration(node)
		forEach(node.members, checkSourceElement)
		registerForUnusedIdentifiersCheck(node)
	}
	checkClassLikeDeclaration := func(node ClassLikeDeclaration) {
		checkGrammarClassLikeDeclaration(node)
		checkDecorators(node)
		checkCollisionsForDeclarationName(node, node.name)
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
		checkExportsOnMergedDeclarations(node)
		symbol := getSymbolOfDeclaration(node)
		type_ := getDeclaredTypeOfSymbol(symbol)
		typeWithThis := getTypeWithThisArgument(type_)
		staticType := getTypeOfSymbol(symbol)
		checkTypeParameterListsIdentical(symbol)
		checkFunctionOrConstructorSymbol(symbol)
		checkClassForDuplicateDeclarations(node)
		nodeInAmbientContext := !!(node.flags & NodeFlagsAmbient)
		if !nodeInAmbientContext {
			checkClassForStaticPropertyNameConflicts(node)
		}
		baseTypeNode := getEffectiveBaseTypeNode(node)
		if baseTypeNode {
			forEach(baseTypeNode.typeArguments, checkSourceElement)
			if languageVersion < LanguageFeatureMinimumTargetClasses {
				checkExternalEmitHelpers(baseTypeNode.parent, ExternalEmitHelpersExtends)
			}
			extendsNode := getClassExtendsHeritageElement(node)
			if extendsNode && extendsNode != baseTypeNode {
				checkExpression(extendsNode.expression)
			}
			baseTypes := getBaseTypes(type_)
			if baseTypes.length {
				addLazyDiagnostic(func() {
					baseType := /* TODO(ElementAccessExpression): baseTypes[0] */ TODO
					baseConstructorType := getBaseConstructorTypeOfClass(type_)
					staticBaseType := getApparentType(baseConstructorType)
					checkBaseTypeAccessibility(staticBaseType, baseTypeNode)
					checkSourceElement(baseTypeNode.expression)
					if some(baseTypeNode.typeArguments) {
						forEach(baseTypeNode.typeArguments, checkSourceElement)
						for _, constructor := range getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode) {
							if !checkTypeArgumentConstraints(baseTypeNode, constructor.typeParameters) {
								break
							}
						}
					}
					baseWithThis := getTypeWithThisArgument(baseType, type_.thisType)
					if !checkTypeAssignableTo(typeWithThis, baseWithThis, nil) {
						issueMemberSpecificError(node, typeWithThis, baseWithThis, Diagnostics.Class_0_incorrectly_extends_base_class_1)
					} else {
						checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1)
					}
					if baseConstructorType.flags & TypeFlagsTypeVariable {
						if !isMixinConstructorType(staticType) {
							error(node.name || node, Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any)
						} else {
							constructSignatures := getSignaturesOfType(baseConstructorType, SignatureKindConstruct)
							if constructSignatures.some(func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type number */ TODO {
								return signature.flags & SignatureFlagsAbstract
							}) && !hasSyntacticModifier(node, ModifierFlagsAbstract) {
								error(node.name || node, Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract)
							}
						}
					}
					if !(staticBaseType.symbol && staticBaseType.symbol.flags&SymbolFlagsClass) && !(baseConstructorType.flags & TypeFlagsTypeVariable) {
						constructors := getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode)
						if forEach(constructors, func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO inferred type boolean */ TODO {
							return !isJSConstructor(sig.declaration) && !isTypeIdenticalTo(getReturnTypeOfSignature(sig), baseType)
						}) {
							error(baseTypeNode.expression, Diagnostics.Base_constructors_must_all_have_the_same_return_type)
						}
					}
					checkKindsOfPropertyMemberOverrides(type_, baseType)
				})
			}
		}
		checkMembersForOverrideModifier(node, type_, typeWithThis, staticType)
		implementedTypeNodes := getEffectiveImplementsTypeNodes(node)
		if implementedTypeNodes {
			for _, typeRefNode := range implementedTypeNodes {
				if !isEntityNameExpression(typeRefNode.expression) || isOptionalChain(typeRefNode.expression) {
					error(typeRefNode.expression, Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments)
				}
				checkTypeReferenceNode(typeRefNode)
				addLazyDiagnostic(createImplementsDiagnostics(typeRefNode))
			}
		}
		addLazyDiagnostic(func() {
			checkIndexConstraints(type_, symbol)
			checkIndexConstraints(staticType, symbol, true)
			checkTypeForDuplicateIndexSignatures(node)
			checkPropertyInitialization(node)
		})
		createImplementsDiagnostics := func(typeRefNode ExpressionWithTypeArguments) /* TODO inferred type () => void */ TODO {
			return func() {
				t := getReducedType(getTypeFromTypeNode(typeRefNode))
				if !isErrorType(t) {
					if isValidBaseType(t) {
						genericDiag := /* TODO(ConditionalExpression): t.symbol && t.symbol.flags & SymbolFlags.Class ?                             Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass :                             Diagnostics.Class_0_incorrectly_implements_interface_1 */ TODO
						baseWithThis := getTypeWithThisArgument(t, type_.thisType)
						if !checkTypeAssignableTo(typeWithThis, baseWithThis, nil) {
							issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag)
						}
					} else {
						error(typeRefNode, Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members)
					}
				}
			}
		}
	}
	checkMembersForOverrideModifier := func(node ClassLikeDeclaration, type_ InterfaceType, typeWithThis Type, staticType ObjectType) {
		baseTypeNode := getEffectiveBaseTypeNode(node)
		baseTypes := baseTypeNode && getBaseTypes(type_)
		baseWithThis := /* TODO(ConditionalExpression): baseTypes?.length ? getTypeWithThisArgument(first(baseTypes), type.thisType) : undefined */ TODO
		baseStaticType := getBaseConstructorTypeOfClass(type_)
		for _, member := range node.members {
			if hasAmbientModifier(member) {
				continue
			}
			if isConstructorDeclaration(member) {
				forEach(member.parameters, func(param /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO) {
					if isParameterPropertyDeclaration(param, member) {
						checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, param, true)
					}
				})
			}
			checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, member, false)
		}
	}
	checkExistingMemberForOverrideModifier := func(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis *Type, type_ InterfaceType, typeWithThis Type, member /* TODO(UnionType): ClassElement | ParameterPropertyDeclaration */ any, memberIsParameterProperty bool, reportErrors /* TODO inferred type boolean */ TODO /*  = true */) MemberOverrideStatus {
		declaredProp := member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member)
		if !declaredProp {
			return MemberOverrideStatusOk
		}
		return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, hasOverrideModifier(member), hasAbstractModifier(member), isStatic(member), memberIsParameterProperty, declaredProp /* TODO(ConditionalExpression): reportErrors ? member : undefined */, TODO)
	}
	checkMemberForOverrideModifier := func(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis *Type, type_ InterfaceType, typeWithThis Type, memberHasOverrideModifier bool, memberHasAbstractModifier bool, memberIsStatic bool, memberIsParameterProperty bool, member Symbol, errorNode Node) MemberOverrideStatus {
		isJs := isInJSFile(node)
		nodeInAmbientContext := !!(node.flags & NodeFlagsAmbient)
		if baseWithThis && (memberHasOverrideModifier || compilerOptions.noImplicitOverride) {
			thisType := /* TODO(ConditionalExpression): memberIsStatic ? staticType : typeWithThis */ TODO
			baseType := /* TODO(ConditionalExpression): memberIsStatic ? baseStaticType : baseWithThis */ TODO
			prop := getPropertyOfType(thisType, member.escapedName)
			baseProp := getPropertyOfType(baseType, member.escapedName)
			baseClassName := typeToString(baseWithThis)
			if prop && !baseProp && memberHasOverrideModifier {
				if errorNode {
					suggestion := getSuggestedSymbolForNonexistentClassMember(symbolName(member), baseType)
					/* TODO(ExpressionStatement): suggestion ?                         error(                             errorNode,                             isJs ?                                 Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1 :                                 Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1,                             baseClassName,                             symbolToString(suggestion),                         ) :                         error(                             errorNode,                             isJs ?                                 Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0 :                                 Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0,                             baseClassName,                         ); */
				}
				return MemberOverrideStatusHasInvalidOverride
			} else if prop && baseProp.declarations && compilerOptions.noImplicitOverride && !nodeInAmbientContext {
				baseHasAbstract := some(baseProp.declarations, hasAbstractModifier)
				if memberHasOverrideModifier {
					return MemberOverrideStatusOk
				}
				if !baseHasAbstract {
					if errorNode {
						diag := /* TODO(ConditionalExpression): memberIsParameterProperty ?                             isJs ?                                 Diagnostics.This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 :                                 Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0 :                             isJs ?                             Diagnostics.This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 :                             Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0 */ TODO
						error(errorNode, diag, baseClassName)
					}
					return MemberOverrideStatusNeedsOverride
				} else if memberHasAbstractModifier && baseHasAbstract {
					if errorNode {
						error(errorNode, Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0, baseClassName)
					}
					return MemberOverrideStatusNeedsOverride
				}
			}
		} else if memberHasOverrideModifier {
			if errorNode {
				className := typeToString(type_)
				error(errorNode /* TODO(ConditionalExpression): isJs ?                         Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class :                         Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class */, TODO, className)
			}
			return MemberOverrideStatusHasInvalidOverride
		}
		return MemberOverrideStatusOk
	}
	issueMemberSpecificError := func(node ClassLikeDeclaration, typeWithThis Type, baseWithThis Type, broadDiag DiagnosticMessage) {
		issuedMemberError := false
		for _, member := range node.members {
			if isStatic(member) {
				continue
			}
			declaredProp := member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member)
			if declaredProp {
				prop := getPropertyOfType(typeWithThis, declaredProp.escapedName)
				baseProp := getPropertyOfType(baseWithThis, declaredProp.escapedName)
				if prop && baseProp {
					rootChain := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ TODO {
						return chainDiagnosticMessages(nil, Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2, symbolToString(declaredProp), typeToString(typeWithThis), typeToString(baseWithThis))
					}
					if !checkTypeAssignableTo(getTypeOfSymbol(prop), getTypeOfSymbol(baseProp), member.name || member, nil, rootChain) {
						issuedMemberError = true
					}
				}
			}
		}
		if !issuedMemberError {
			checkTypeAssignableTo(typeWithThis, baseWithThis, node.name || node, broadDiag)
		}
	}
	checkBaseTypeAccessibility := func(type_ Type, node ExpressionWithTypeArguments) {
		signatures := getSignaturesOfType(type_, SignatureKindConstruct)
		if signatures.length {
			declaration := /* TODO(ElementAccessExpression): signatures[0] */ TODO.declaration
			if declaration && hasEffectiveModifier(declaration, ModifierFlagsPrivate) {
				typeClassDeclaration := getClassLikeDeclarationOfSymbol(type_.symbol)
				if !isNodeWithinClass(node, typeClassDeclaration) {
					error(node, Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, getFullyQualifiedName(type_.symbol))
				}
			}
		}
	}
	getMemberOverrideModifierStatus := func(node ClassLikeDeclaration, member ClassElement, memberSymbol Symbol) MemberOverrideStatus {
		if !member.name {
			return MemberOverrideStatusOk
		}
		classSymbol := getSymbolOfDeclaration(node)
		type_ := getDeclaredTypeOfSymbol(classSymbol)
		typeWithThis := getTypeWithThisArgument(type_)
		staticType := getTypeOfSymbol(classSymbol)
		baseTypeNode := getEffectiveBaseTypeNode(node)
		baseTypes := baseTypeNode && getBaseTypes(type_)
		baseWithThis := /* TODO(ConditionalExpression): baseTypes?.length ? getTypeWithThisArgument(first(baseTypes), type.thisType) : undefined */ TODO
		baseStaticType := getBaseConstructorTypeOfClass(type_)
		memberHasOverrideModifier := /* TODO(ConditionalExpression): member.parent             ? hasOverrideModifier(member)             : hasSyntacticModifier(member, ModifierFlags.Override) */ TODO
		return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, memberHasOverrideModifier, hasAbstractModifier(member), isStatic(member), false, memberSymbol)
	}
	getTargetSymbol := func(s Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		return /* TODO(ConditionalExpression): getCheckFlags(s) & CheckFlags.Instantiated ? (s as TransientSymbol).links.target! : s */ TODO
	}
	getClassOrInterfaceDeclarationsOfSymbol := func(symbol Symbol) /* TODO inferred type (import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration)[] | undefined */ TODO {
		return filter(symbol.declarations, func(d Declaration) /* TODO(TypePredicate): d is ClassDeclaration | InterfaceDeclaration */ any {
			return d.kind == SyntaxKindClassDeclaration || d.kind == SyntaxKindInterfaceDeclaration
		})
	}
	checkKindsOfPropertyMemberOverrides := func(type_ InterfaceType, baseType BaseType) {
		baseProperties := getPropertiesOfType(baseType)
		type MemberInfo struct {
			missedProperties []string
			baseTypeName     string
			typeName         string
		}
		notImplementedInfo := make(map[ClassLikeDeclaration]MemberInfo)
		/* TODO(LabeledStatement): basePropertyCheck: for (const baseProperty of baseProperties) {             const base = getTargetSymbol(baseProperty);              if (base.flags & SymbolFlags.Prototype) {                 continue;             }             const baseSymbol = getPropertyOfObjectType(type, base.escapedName);             if (!baseSymbol) {                 continue;             }             const derived = getTargetSymbol(baseSymbol);             const baseDeclarationFlags = getDeclarationModifierFlagsFromSymbol(base);              Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration.");              // In order to resolve whether the inherited method was overridden in the base class or not,             // we compare the Symbols obtained. Since getTargetSymbol returns the symbol on the *uninstantiated*             // type declaration, derived and base resolve to the same symbol even in the case of generic classes.             if (derived === base) {                 // derived class inherits base without override/redeclaration                 const derivedClassDecl = getClassLikeDeclarationOfSymbol(type.symbol)!;                  // It is an error to inherit an abstract member without implementing it or being declared abstract.                 // If there is no declaration for the derived class (as in the case of class expressions),                 // then the class cannot be declared abstract.                 if (baseDeclarationFlags & ModifierFlags.Abstract && (!derivedClassDecl || !hasSyntacticModifier(derivedClassDecl, ModifierFlags.Abstract))) {                     // Searches other base types for a declaration that would satisfy the inherited abstract member.                     // (The class may have more than one base type via declaration merging with an interface with the                     // same name.)                     for (const otherBaseType of getBaseTypes(type)) {                         if (otherBaseType === baseType) continue;                         const baseSymbol = getPropertyOfObjectType(otherBaseType, base.escapedName);                         const derivedElsewhere = baseSymbol && getTargetSymbol(baseSymbol);                         if (derivedElsewhere && derivedElsewhere !== base) {                             continue basePropertyCheck;                         }                     }                     const baseTypeName = typeToString(baseType);                     const typeName = typeToString(type);                     const basePropertyName = symbolToString(baseProperty);                     const missedProperties = append(notImplementedInfo.get(derivedClassDecl)?.missedProperties, basePropertyName);                     notImplementedInfo.set(derivedClassDecl, { baseTypeName, typeName, missedProperties });                 }             }             else {                 // derived overrides base.                 const derivedDeclarationFlags = getDeclarationModifierFlagsFromSymbol(derived);                 if (baseDeclarationFlags & ModifierFlags.Private || derivedDeclarationFlags & ModifierFlags.Private) {                     // either base or derived property is private - not override, skip it                     continue;                 }                  let errorMessage: DiagnosticMessage;                 const basePropertyFlags = base.flags & SymbolFlags.PropertyOrAccessor;                 const derivedPropertyFlags = derived.flags & SymbolFlags.PropertyOrAccessor;                 if (basePropertyFlags && derivedPropertyFlags) {                     // property/accessor is overridden with property/accessor                     if (                         (getCheckFlags(base) & CheckFlags.Synthetic                             ? base.declarations?.some(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags))                             : base.declarations?.every(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags)))                         || getCheckFlags(base) & CheckFlags.Mapped                         || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration)                     ) {                         // when the base property is abstract or from an interface, base/derived flags don't need to match                         // for intersection properties, this must be true of *any* of the declarations, for others it must be true of *all*                         // same when the derived property is from an assignment                         continue;                     }                      const overriddenInstanceProperty = basePropertyFlags !== SymbolFlags.Property && derivedPropertyFlags === SymbolFlags.Property;                     const overriddenInstanceAccessor = basePropertyFlags === SymbolFlags.Property && derivedPropertyFlags !== SymbolFlags.Property;                     if (overriddenInstanceProperty || overriddenInstanceAccessor) {                         const errorMessage = overriddenInstanceProperty ?                             Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property :                             Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor;                         error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType), typeToString(type));                     }                     else if (useDefineForClassFields) {                         const uninitialized = derived.declarations?.find(d => d.kind === SyntaxKind.PropertyDeclaration && !(d as PropertyDeclaration).initializer);                         if (                             uninitialized                             && !(derived.flags & SymbolFlags.Transient)                             && !(baseDeclarationFlags & ModifierFlags.Abstract)                             && !(derivedDeclarationFlags & ModifierFlags.Abstract)                             && !derived.declarations?.some(d => !!(d.flags & NodeFlags.Ambient))                         ) {                             const constructor = findConstructorDeclaration(getClassLikeDeclarationOfSymbol(type.symbol)!);                             const propName = (uninitialized as PropertyDeclaration).name;                             if (                                 (uninitialized as PropertyDeclaration).exclamationToken                                 || !constructor                                 || !isIdentifier(propName)                                 || !strictNullChecks                                 || !isPropertyInitializedInConstructor(propName, type, constructor)                             ) {                                 const errorMessage = Diagnostics.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration;                                 error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType));                             }                         }                     }                      // correct case                     continue;                 }                 else if (isPrototypeProperty(base)) {                     if (isPrototypeProperty(derived) || derived.flags & SymbolFlags.Property) {                         // method is overridden with method or property -- correct case                         continue;                     }                     else {                         Debug.assert(!!(derived.flags & SymbolFlags.Accessor));                         errorMessage = Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;                     }                 }                 else if (base.flags & SymbolFlags.Accessor) {                     errorMessage = Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;                 }                 else {                     errorMessage = Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;                 }                  error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));             }         } */
		for _, TODO_IDENTIFIER := range notImplementedInfo {
			if length(memberInfo.missedProperties) == 1 {
				if isClassExpression(errorNode) {
					error(errorNode, Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1, first(memberInfo.missedProperties), memberInfo.baseTypeName)
				} else {
					error(errorNode, Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2, memberInfo.typeName, first(memberInfo.missedProperties), memberInfo.baseTypeName)
				}
			} else if length(memberInfo.missedProperties) > 5 {
				missedProperties := map_(memberInfo.missedProperties.slice(0, 4), func(prop /* TODO inferred type string */ TODO) /* TODO inferred type string */ TODO {
					return /* TODO(TemplateExpression): `'${prop}'` */ TODO
				}).join(", ")
				remainingMissedProperties := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): length(memberInfo.missedProperties) - 4 */ TODO
				if isClassExpression(errorNode) {
					error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1_and_2_more, memberInfo.baseTypeName, missedProperties, remainingMissedProperties)
				} else {
					error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2_and_3_more, memberInfo.typeName, memberInfo.baseTypeName, missedProperties, remainingMissedProperties)
				}
			} else {
				missedProperties := map_(memberInfo.missedProperties, func(prop /* TODO inferred type string */ TODO) /* TODO inferred type string */ TODO {
					return /* TODO(TemplateExpression): `'${prop}'` */ TODO
				}).join(", ")
				if isClassExpression(errorNode) {
					error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1, memberInfo.baseTypeName, missedProperties)
				} else {
					error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2, memberInfo.typeName, memberInfo.baseTypeName, missedProperties)
				}
			}
		}
	}
	isPropertyAbstractOrInterface := func(declaration Declaration, baseDeclarationFlags ModifierFlags) /* TODO inferred type boolean */ TODO {
		return baseDeclarationFlags&ModifierFlagsAbstract && (!isPropertyDeclaration(declaration) || !declaration.initializer) || isInterfaceDeclaration(declaration.parent)
	}
	getNonInheritedProperties := func(type_ InterfaceType, baseTypes []BaseType, properties []Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		if !length(baseTypes) {
			return properties
		}
		seen := make(map[__String]Symbol)
		forEach(properties, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
			seen.set(p.escapedName, p)
		})
		for _, base := range baseTypes {
			properties := getPropertiesOfType(getTypeWithThisArgument(base, type_.thisType))
			for _, prop := range properties {
				existing := seen.get(prop.escapedName)
				if existing && prop.parent == existing.parent {
					seen.delete(prop.escapedName)
				}
			}
		}
		return arrayFrom(seen.values())
	}
	checkInheritedPropertiesAreIdentical := func(type_ InterfaceType, typeNode Node) bool {
		baseTypes := getBaseTypes(type_)
		if baseTypes.length < 2 {
			return true
		}
		type InheritanceInfoMap struct {
			prop           Symbol
			containingType Type
		}
		seen := make(map[__String]InheritanceInfoMap)
		forEach(resolveDeclaredMembers(type_).declaredProperties, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
			seen.set(p.escapedName /* TODO(ObjectLiteralExpression): { prop: p, containingType: type } */, TODO)
		})
		ok := true
		for _, base := range baseTypes {
			properties := getPropertiesOfType(getTypeWithThisArgument(base, type_.thisType))
			for _, prop := range properties {
				existing := seen.get(prop.escapedName)
				if !existing {
					seen.set(prop.escapedName /* TODO(ObjectLiteralExpression): { prop, containingType: base } */, TODO)
				} else {
					isInheritedProperty := existing.containingType != type_
					if isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop) {
						ok = false
						typeName1 := typeToString(existing.containingType)
						typeName2 := typeToString(base)
						errorInfo := chainDiagnosticMessages(nil, Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical, symbolToString(prop), typeName1, typeName2)
						errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type_), typeName1, typeName2)
						diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(typeNode), typeNode, errorInfo))
					}
				}
			}
		}
		return ok
	}
	checkPropertyInitialization := func(node ClassLikeDeclaration) {
		if !strictNullChecks || !strictPropertyInitialization || node.flags&NodeFlagsAmbient {
			return
		}
		constructor := findConstructorDeclaration(node)
		for _, member := range node.members {
			if getEffectiveModifierFlags(member) & ModifierFlagsAmbient {
				continue
			}
			if !isStatic(member) && isPropertyWithoutInitializer(member) {
				propName := (member).name
				if isIdentifier(propName) || isPrivateIdentifier(propName) || isComputedPropertyName(propName) {
					type_ := getTypeOfSymbol(getSymbolOfDeclaration(member))
					if !(type_.flags&TypeFlagsAnyOrUnknown || containsUndefinedType(type_)) {
						if !constructor || !isPropertyInitializedInConstructor(propName, type_, constructor) {
							error(member.name, Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor, declarationNameToString(propName))
						}
					}
				}
			}
		}
	}
	isPropertyWithoutInitializer := func(node Node) /* TODO inferred type boolean */ TODO {
		return node.kind == SyntaxKindPropertyDeclaration && !hasAbstractModifier(node) && !(node).exclamationToken && !(node).initializer
	}
	isPropertyInitializedInStaticBlocks := func(propName /* TODO(UnionType): Identifier | PrivateIdentifier */ any, propType Type, staticBlocks []ClassStaticBlockDeclaration, startPos number, endPos number) /* TODO inferred type boolean */ TODO {
		for _, staticBlock := range staticBlocks {
			if staticBlock.pos >= startPos && staticBlock.pos <= endPos {
				reference := factory.createPropertyAccessExpression(factory.createThis(), propName)
				setParent(reference.expression, reference)
				setParent(reference, staticBlock)
				reference.flowNode = staticBlock.returnFlowNode
				flowType := getFlowTypeOfReference(reference, propType, getOptionalType(propType))
				if !containsUndefinedType(flowType) {
					return true
				}
			}
		}
		return false
	}
	isPropertyInitializedInConstructor := func(propName /* TODO(UnionType): Identifier | PrivateIdentifier | ComputedPropertyName */ any, propType Type, constructor ConstructorDeclaration) /* TODO inferred type boolean */ TODO {
		reference := /* TODO(ConditionalExpression): isComputedPropertyName(propName)             ? factory.createElementAccessExpression(factory.createThis(), propName.expression)             : factory.createPropertyAccessExpression(factory.createThis(), propName) */ TODO
		setParent(reference.expression, reference)
		setParent(reference, constructor)
		reference.flowNode = constructor.returnFlowNode
		flowType := getFlowTypeOfReference(reference, propType, getOptionalType(propType))
		return !containsUndefinedType(flowType)
	}
	checkInterfaceDeclaration := func(node InterfaceDeclaration) {
		if !checkGrammarModifiers(node) {
			checkGrammarInterfaceDeclaration(node)
		}
		checkTypeParameters(node.typeParameters)
		addLazyDiagnostic(func() {
			checkTypeNameIsReserved(node.name, Diagnostics.Interface_name_cannot_be_0)
			checkExportsOnMergedDeclarations(node)
			symbol := getSymbolOfDeclaration(node)
			checkTypeParameterListsIdentical(symbol)
			firstInterfaceDecl := getDeclarationOfKind(symbol, SyntaxKindInterfaceDeclaration)
			if node == firstInterfaceDecl {
				type_ := getDeclaredTypeOfSymbol(symbol)
				typeWithThis := getTypeWithThisArgument(type_)
				if checkInheritedPropertiesAreIdentical(type_, node.name) {
					for _, baseType := range getBaseTypes(type_) {
						checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType, type_.thisType), node.name, Diagnostics.Interface_0_incorrectly_extends_interface_1)
					}
					checkIndexConstraints(type_, symbol)
				}
			}
			checkObjectTypeForDuplicateDeclarations(node)
		})
		forEach(getInterfaceBaseTypeNodes(node), func(heritageElement /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments */ TODO) {
			if !isEntityNameExpression(heritageElement.expression) || isOptionalChain(heritageElement.expression) {
				error(heritageElement.expression, Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments)
			}
			checkTypeReferenceNode(heritageElement)
		})
		forEach(node.members, checkSourceElement)
		addLazyDiagnostic(func() {
			checkTypeForDuplicateIndexSignatures(node)
			registerForUnusedIdentifiersCheck(node)
		})
	}
	checkTypeAliasDeclaration := func(node TypeAliasDeclaration) {
		checkGrammarModifiers(node)
		checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0)
		checkExportsOnMergedDeclarations(node)
		checkTypeParameters(node.typeParameters)
		if node.type_.kind == SyntaxKindIntrinsicKeyword {
			typeParameterCount := length(node.typeParameters)
			valid := /* TODO(ConditionalExpression): typeParameterCount === 0 ? node.name.escapedText === "BuiltinIteratorReturn" :                 typeParameterCount === 1 && intrinsicTypeKinds.has(node.name.escapedText as string) */ TODO
			if !valid {
				error(node.type_, Diagnostics.The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types)
			}
		} else {
			checkSourceElement(node.type_)
			registerForUnusedIdentifiersCheck(node)
		}
	}
	computeEnumMemberValues := func(node EnumDeclaration) {
		nodeLinks := getNodeLinks(node)
		if !(nodeLinks.flags & NodeCheckFlagsEnumValuesComputed) {
			nodeLinks.flags |= NodeCheckFlagsEnumValuesComputed
			var autoValue /* TODO(NumberKeyword): number */ any = 0
			var previous *EnumMember
			for _, member := range node.members {
				result := computeEnumMemberValue(member, autoValue, previous)
				getNodeLinks(member).enumMemberValue = result
				autoValue = /* TODO(ConditionalExpression): typeof result.value === "number" ? result.value + 1 : undefined */ TODO
				previous = member
			}
		}
	}
	computeEnumMemberValue := func(member EnumMember, autoValue /* TODO(NumberKeyword): number */ any, previous *EnumMember) EvaluatorResult {
		if isComputedNonLiteralName(member.name) {
			error(member.name, Diagnostics.Computed_property_names_are_not_allowed_in_enums)
		} else {
			text := getTextOfPropertyName(member.name)
			if isNumericLiteralName(text) && !isInfinityOrNaNString(text) {
				error(member.name, Diagnostics.An_enum_member_cannot_have_a_numeric_name)
			}
		}
		if member.initializer {
			return computeConstantEnumMemberValue(member)
		}
		if member.parent.flags&NodeFlagsAmbient && !isEnumConst(member.parent) {
			return evaluatorResult(nil)
		}
		if autoValue == nil {
			error(member.name, Diagnostics.Enum_member_must_have_initializer)
			return evaluatorResult(nil)
		}
		if getIsolatedModules(compilerOptions) && previous.initializer {
			prevValue := getEnumMemberValue(previous)
			if !( /* TODO(TypeOfExpression): typeof prevValue.value */ TODO == "number" && !prevValue.resolvedOtherFiles) {
				error(member.name, Diagnostics.Enum_member_following_a_non_literal_numeric_member_must_have_an_initializer_when_isolatedModules_is_enabled)
			}
		}
		return evaluatorResult(autoValue)
	}
	computeConstantEnumMemberValue := func(member EnumMember) EvaluatorResult {
		isConstEnum := isEnumConst(member.parent)
		initializer := member.initializer
		result := evaluate(initializer, member)
		if result.value != nil {
			if isConstEnum && /* TODO(TypeOfExpression): typeof result.value */ TODO == "number" && !isFinite(result.value) {
				error(initializer /* TODO(ConditionalExpression): isNaN(result.value) ?                         Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN :                         Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value */, TODO)
			} else if getIsolatedModules(compilerOptions) && /* TODO(TypeOfExpression): typeof result.value */ TODO == "string" && !result.isSyntacticallyString {
				error(initializer, Diagnostics._0_has_a_string_type_but_must_have_syntactically_recognizable_string_syntax_when_isolatedModules_is_enabled /* TODO(TemplateExpression): `${idText(member.parent.name)}.${getTextOfPropertyName(member.name)}` */, TODO)
			}
		} else if isConstEnum {
			error(initializer, Diagnostics.const_enum_member_initializers_must_be_constant_expressions)
		} else if member.parent.flags & NodeFlagsAmbient {
			error(initializer, Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression)
		} else {
			checkTypeAssignableTo(checkExpression(initializer), numberType, initializer, Diagnostics.Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values)
		}
		return result
	}
	evaluateEntityNameExpression := func(expr EntityNameExpression, location Declaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ TODO {
		symbol := resolveEntityName(expr, SymbolFlagsValue, true)
		if !symbol {
			return evaluatorResult(nil)
		}
		if expr.kind == SyntaxKindIdentifier {
			identifier := expr
			if isInfinityOrNaNString(identifier.escapedText) && (symbol == getGlobalSymbol(identifier.escapedText, SymbolFlagsValue, nil)) {
				return evaluatorResult(+(identifier.escapedText), false)
			}
		}
		if symbol.flags & SymbolFlagsEnumMember {
			return /* TODO(ConditionalExpression): location ? evaluateEnumMember(expr, symbol, location) : getEnumMemberValue(symbol.valueDeclaration as EnumMember) */ TODO
		}
		if isConstantVariable(symbol) {
			declaration := symbol.valueDeclaration
			if declaration && isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && (!location || declaration != location && isBlockScopedNameDeclaredBeforeUse(declaration, location)) {
				result := evaluate(declaration.initializer, declaration)
				if location && getSourceFileOfNode(location) != getSourceFileOfNode(declaration) {
					return evaluatorResult(result.value, false, true, true)
				}
				return evaluatorResult(result.value, result.isSyntacticallyString, result.resolvedOtherFiles, true)
			}
		}
		return evaluatorResult(nil)
	}
	evaluateElementAccessExpression := func(expr ElementAccessExpression, location Declaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ TODO {
		root := expr.expression
		if isEntityNameExpression(root) && isStringLiteralLike(expr.argumentExpression) {
			rootSymbol := resolveEntityName(root, SymbolFlagsValue, true)
			if rootSymbol && rootSymbol.flags&SymbolFlagsEnum {
				name := escapeLeadingUnderscores(expr.argumentExpression.text)
				member := rootSymbol.exports.get(name)
				if member {
					Debug.assert(getSourceFileOfNode(member.valueDeclaration) == getSourceFileOfNode(rootSymbol.valueDeclaration))
					return /* TODO(ConditionalExpression): location ? evaluateEnumMember(expr, member, location) : getEnumMemberValue(member.valueDeclaration as EnumMember) */ TODO
				}
			}
		}
		return evaluatorResult(nil)
	}
	evaluateEnumMember := func(expr Expression, symbol Symbol, location Declaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ TODO {
		declaration := symbol.valueDeclaration
		if !declaration || declaration == location {
			error(expr, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(symbol))
			return evaluatorResult(nil)
		}
		if !isBlockScopedNameDeclaredBeforeUse(declaration, location) {
			error(expr, Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums)
			return evaluatorResult(0)
		}
		value := getEnumMemberValue(declaration)
		if location.parent != declaration.parent {
			return evaluatorResult(value.value, value.isSyntacticallyString, value.resolvedOtherFiles, true)
		}
		return value
	}
	checkEnumDeclaration := func(node EnumDeclaration) {
		addLazyDiagnostic(func() {
			return checkEnumDeclarationWorker(node)
		})
	}
	checkEnumDeclarationWorker := func(node EnumDeclaration) {
		checkGrammarModifiers(node)
		checkCollisionsForDeclarationName(node, node.name)
		checkExportsOnMergedDeclarations(node)
		node.members.forEach(checkEnumMember)
		computeEnumMemberValues(node)
		enumSymbol := getSymbolOfDeclaration(node)
		firstDeclaration := getDeclarationOfKind(enumSymbol, node.kind)
		if node == firstDeclaration {
			if enumSymbol.declarations && enumSymbol.declarations.length > 1 {
				enumIsConst := isEnumConst(node)
				forEach(enumSymbol.declarations, func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
					if isEnumDeclaration(decl) && isEnumConst(decl) != enumIsConst {
						error(getNameOfDeclaration(decl), Diagnostics.Enum_declarations_must_all_be_const_or_non_const)
					}
				})
			}
			seenEnumMissingInitialInitializer := false
			forEach(enumSymbol.declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type false | undefined */ TODO {
				if declaration.kind != SyntaxKindEnumDeclaration {
					return false
				}
				enumDeclaration := declaration
				if !enumDeclaration.members.length {
					return false
				}
				firstEnumMember := /* TODO(ElementAccessExpression): enumDeclaration.members[0] */ TODO
				if !firstEnumMember.initializer {
					if seenEnumMissingInitialInitializer {
						error(firstEnumMember.name, Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element)
					} else {
						seenEnumMissingInitialInitializer = true
					}
				}
			})
		}
	}
	checkEnumMember := func(node EnumMember) {
		if isPrivateIdentifier(node.name) {
			error(node, Diagnostics.An_enum_member_cannot_be_named_with_a_private_identifier)
		}
		if node.initializer {
			checkExpression(node.initializer)
		}
	}
	getFirstNonAmbientClassOrFunctionDeclaration := func(symbol Symbol) Declaration {
		declarations := symbol.declarations
		if declarations {
			for _, declaration := range declarations {
				if (declaration.kind == SyntaxKindClassDeclaration || (declaration.kind == SyntaxKindFunctionDeclaration && nodeIsPresent((declaration).body))) && !(declaration.flags & NodeFlagsAmbient) {
					return declaration
				}
			}
		}
		return nil
	}
	inSameLexicalScope := func(node1 Node, node2 Node) /* TODO inferred type boolean */ TODO {
		container1 := getEnclosingBlockScopeContainer(node1)
		container2 := getEnclosingBlockScopeContainer(node2)
		if isGlobalSourceFile(container1) {
			return isGlobalSourceFile(container2)
		} else if isGlobalSourceFile(container2) {
			return false
		} else {
			return container1 == container2
		}
	}
	checkModuleDeclaration := func(node ModuleDeclaration) {
		if node.body {
			checkSourceElement(node.body)
			if !isGlobalScopeAugmentation(node) {
				registerForUnusedIdentifiersCheck(node)
			}
		}
		addLazyDiagnostic(checkModuleDeclarationDiagnostics)
		checkModuleDeclarationDiagnostics := func() {
			isGlobalAugmentation := isGlobalScopeAugmentation(node)
			inAmbientContext := node.flags & NodeFlagsAmbient
			if isGlobalAugmentation && !inAmbientContext {
				error(node.name, Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context)
			}
			var isAmbientExternalModule bool = isAmbientModule(node)
			contextErrorMessage := /* TODO(ConditionalExpression): isAmbientExternalModule                 ? Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file                 : Diagnostics.A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module */ TODO
			if checkGrammarModuleElementContext(node, contextErrorMessage) {
				return
			}
			if !checkGrammarModifiers(node) {
				if !inAmbientContext && node.name.kind == SyntaxKindStringLiteral {
					grammarErrorOnNode(node.name, Diagnostics.Only_ambient_modules_can_use_quoted_names)
				}
			}
			if isIdentifier(node.name) {
				checkCollisionsForDeclarationName(node, node.name)
				if !(node.flags & (NodeFlagsNamespace | NodeFlagsGlobalAugmentation)) {
					sourceFile := getSourceFileOfNode(node)
					pos := getNonModifierTokenPosOfNode(node)
					span := getSpanOfTokenAtPosition(sourceFile, pos)
					suggestionDiagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.A_namespace_declaration_should_not_be_declared_using_the_module_keyword_Please_use_the_namespace_keyword_instead))
				}
			}
			checkExportsOnMergedDeclarations(node)
			symbol := getSymbolOfDeclaration(node)
			if symbol.flags&SymbolFlagsValueModule && !inAmbientContext && isInstantiatedModule(node, shouldPreserveConstEnums(compilerOptions)) {
				if getIsolatedModules(compilerOptions) && !getSourceFileOfNode(node).externalModuleIndicator {
					error(node.name, Diagnostics.Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement, isolatedModulesLikeFlagName)
				}
				if symbol.declarations.length > 1 {
					firstNonAmbientClassOrFunc := getFirstNonAmbientClassOrFunctionDeclaration(symbol)
					if firstNonAmbientClassOrFunc {
						if getSourceFileOfNode(node) != getSourceFileOfNode(firstNonAmbientClassOrFunc) {
							error(node.name, Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged)
						} else if node.pos < firstNonAmbientClassOrFunc.pos {
							error(node.name, Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged)
						}
					}
					mergedClass := getDeclarationOfKind(symbol, SyntaxKindClassDeclaration)
					if mergedClass && inSameLexicalScope(node, mergedClass) {
						getNodeLinks(node).flags |= NodeCheckFlagsLexicalModuleMergesWithClass
					}
				}
				if compilerOptions.verbatimModuleSyntax && node.parent.kind == SyntaxKindSourceFile && host.getEmitModuleFormatOfFile(node.parent) == ModuleKindCommonJS {
					exportModifier := node.modifiers.find(func(m /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ModifierLike */ TODO) /* TODO inferred type boolean */ TODO {
						return m.kind == SyntaxKindExportKeyword
					})
					if exportModifier {
						error(exportModifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
					}
				}
			}
			if isAmbientExternalModule {
				if isExternalModuleAugmentation(node) {
					checkBody := isGlobalAugmentation || (getSymbolOfDeclaration(node).flags & SymbolFlagsTransient)
					if checkBody && node.body {
						for _, statement := range node.body.statements {
							checkModuleAugmentationElement(statement, isGlobalAugmentation)
						}
					}
				} else if isGlobalSourceFile(node.parent) {
					if isGlobalAugmentation {
						error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations)
					} else if isExternalModuleNameRelative(getTextOfIdentifierOrLiteral(node.name)) {
						error(node.name, Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name)
					}
				} else {
					if isGlobalAugmentation {
						error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations)
					} else {
						error(node.name, Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces)
					}
				}
			}
		}
	}
	checkModuleAugmentationElement := func(node Node, isGlobalAugmentation bool) {
		switch node.kind {
		case SyntaxKindVariableStatement:
			for _, decl := range (node).declarationList.declarations {
				checkModuleAugmentationElement(decl, isGlobalAugmentation)
			}
			break
		case SyntaxKindExportAssignment:
			fallthrough // TODO: merge cases
		case SyntaxKindExportDeclaration:
			grammarErrorOnFirstToken(node, Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations)
			break
		case SyntaxKindImportEqualsDeclaration:
			if isInternalModuleImportEqualsDeclaration(node) {
				break
			}
			fallthrough
		case SyntaxKindImportDeclaration:
			grammarErrorOnFirstToken(node, Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module)
			break
		case SyntaxKindBindingElement:
			fallthrough // TODO: merge cases
		case SyntaxKindVariableDeclaration:
			name := (node).name
			if isBindingPattern(name) {
				for _, el := range name.elements {
					checkModuleAugmentationElement(el, isGlobalAugmentation)
				}
				break
			}
			fallthrough
		case SyntaxKindClassDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindEnumDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindInterfaceDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindModuleDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeAliasDeclaration:
			if isGlobalAugmentation {
				return
			}
			break
		}
	}
	getFirstNonModuleExportsIdentifier := func(node EntityNameOrEntityNameExpression) Identifier {
		switch node.kind {
		case SyntaxKindIdentifier:
			return node
		case SyntaxKindQualifiedName:
			// TODO: refactor do-while loop approximation
			for ok := true; ok; ok = node.kind != SyntaxKindIdentifier {
				node = node.left
			}
			return node
		case SyntaxKindPropertyAccessExpression:
			// TODO: refactor do-while loop approximation
			for ok := true; ok; ok = node.kind != SyntaxKindIdentifier {
				if isModuleExportsAccessExpression(node.expression) && !isPrivateIdentifier(node.name) {
					return node.name
				}
				node = node.expression
			}
			return node
		}
	}
	checkExternalImportOrExportDeclaration := func(node /* TODO(UnionType): ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration */ any) bool {
		moduleName := getExternalModuleName(node)
		if !moduleName || nodeIsMissing(moduleName) {
			return false
		}
		if !isStringLiteral(moduleName) {
			error(moduleName, Diagnostics.String_literal_expected)
			return false
		}
		inAmbientExternalModule := node.parent.kind == SyntaxKindModuleBlock && isAmbientModule(node.parent.parent)
		if node.parent.kind != SyntaxKindSourceFile && !inAmbientExternalModule {
			error(moduleName /* TODO(ConditionalExpression): node.kind === SyntaxKind.ExportDeclaration ?                     Diagnostics.Export_declarations_are_not_permitted_in_a_namespace :                     Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module */, TODO)
			return false
		}
		if inAmbientExternalModule && isExternalModuleNameRelative(moduleName.text) {
			if !isTopLevelInExternalModuleAugmentation(node) {
				error(node, Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name)
				return false
			}
		}
		if !isImportEqualsDeclaration(node) && node.attributes {
			diagnostic := /* TODO(ConditionalExpression): node.attributes.token === SyntaxKind.WithKeyword ? Diagnostics.Import_attribute_values_must_be_string_literal_expressions : Diagnostics.Import_assertion_values_must_be_string_literal_expressions */ TODO
			hasError := false
			for _, attr := range node.attributes.elements {
				if !isStringLiteral(attr.value) {
					hasError = true
					error(attr.value, diagnostic)
				}
			}
			return !hasError
		}
		return true
	}
	checkModuleExportName := func(name *ModuleExportName, allowStringLiteral /* TODO inferred type boolean */ TODO /*  = true */) {
		if name == nil || name.kind != SyntaxKindStringLiteral {
			return
		}
		if !allowStringLiteral {
			grammarErrorOnNode(name, Diagnostics.Identifier_expected)
		} else if moduleKind == ModuleKindES2015 || moduleKind == ModuleKindES2020 {
			grammarErrorOnNode(name, Diagnostics.String_literal_import_and_export_names_are_not_supported_when_the_module_flag_is_set_to_es2015_or_es2020)
		}
	}
	checkAliasSymbol := func(node AliasDeclarationNode) {
		symbol := getSymbolOfDeclaration(node)
		target := resolveAlias(symbol)
		if target != unknownSymbol {
			symbol = getMergedSymbol(symbol.exportSymbol || symbol)
			if isInJSFile(node) && !(target.flags & SymbolFlagsValue) && !isTypeOnlyImportOrExportDeclaration(node) {
				errorNode := /* TODO(ConditionalExpression): isImportOrExportSpecifier(node) ? node.propertyName || node.name :                     isNamedDeclaration(node) ? node.name :                     node */ TODO
				Debug.assert(node.kind != SyntaxKindNamespaceExport)
				if node.kind == SyntaxKindExportSpecifier {
					diag := error(errorNode, Diagnostics.Types_cannot_appear_in_export_declarations_in_JavaScript_files)
					alreadyExportedSymbol := getSourceFileOfNode(node).symbol.exports.get(moduleExportNameTextEscaped(node.propertyName || node.name))
					if alreadyExportedSymbol == target {
						exportingDeclaration := alreadyExportedSymbol.declarations.find(isJSDocNode)
						if exportingDeclaration {
							addRelatedInfo(diag, createDiagnosticForNode(exportingDeclaration, Diagnostics._0_is_automatically_exported_here, unescapeLeadingUnderscores(alreadyExportedSymbol.escapedName)))
						}
					}
				} else {
					Debug.assert(node.kind != SyntaxKindVariableDeclaration)
					importDeclaration := findAncestor(node, or(isImportDeclaration, isImportEqualsDeclaration))
					moduleSpecifier := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (importDeclaration && tryGetModuleSpecifierFromDeclaration(importDeclaration)?.text) ?? "..." */ TODO
					importedIdentifier := unescapeLeadingUnderscores( /* TODO(ConditionalExpression): isIdentifier(errorNode) ? errorNode.escapedText : symbol.escapedName */ TODO)
					error(errorNode, Diagnostics._0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation, importedIdentifier /* TODO(TemplateExpression): `import("${moduleSpecifier}").${importedIdentifier}` */, TODO)
				}
				return
			}
			targetFlags := getSymbolFlags(target)
			excludedMeanings := ( /* TODO(ConditionalExpression): symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue) ? SymbolFlags.Value : 0 */ TODO) | ( /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Type ? SymbolFlags.Type : 0 */ TODO) | ( /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Namespace ? SymbolFlags.Namespace : 0 */ TODO)
			if targetFlags & excludedMeanings {
				message := /* TODO(ConditionalExpression): node.kind === SyntaxKind.ExportSpecifier ?                     Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0 :                     Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0 */ TODO
				error(node, message, symbolToString(symbol))
			} else if node.kind != SyntaxKindExportSpecifier {
				appearsValueyToTranspiler := compilerOptions.isolatedModules && !findAncestor(node, isTypeOnlyImportOrExportDeclaration)
				if appearsValueyToTranspiler && symbol.flags&(SymbolFlagsValue|SymbolFlagsExportValue) {
					error(node, Diagnostics.Import_0_conflicts_with_local_value_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, symbolToString(symbol), isolatedModulesLikeFlagName)
				}
			}
			if getIsolatedModules(compilerOptions) && !isTypeOnlyImportOrExportDeclaration(node) && !(node.flags & NodeFlagsAmbient) {
				typeOnlyAlias := getTypeOnlyAliasDeclaration(symbol)
				isType := !(targetFlags & SymbolFlagsValue)
				if isType || typeOnlyAlias {
					switch node.kind {
					case SyntaxKindImportClause:
						fallthrough // TODO: merge cases
					case SyntaxKindImportSpecifier:
						fallthrough // TODO: merge cases
					case SyntaxKindImportEqualsDeclaration:
						if compilerOptions.verbatimModuleSyntax {
							Debug.assertIsDefined(node.name, "An ImportClause with a symbol should have a name")
							message := /* TODO(ConditionalExpression): compilerOptions.verbatimModuleSyntax && isInternalModuleImportEqualsDeclaration(node)                                     ? Diagnostics.An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled                                     : isType                                     ? Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled                                     : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled */ TODO
							name := moduleExportNameTextUnescaped( /* TODO(ConditionalExpression): node.kind === SyntaxKind.ImportSpecifier ? node.propertyName || node.name : node.name */ TODO)
							addTypeOnlyDeclarationRelatedInfo(error(node, message, name) /* TODO(ConditionalExpression): isType ? undefined : typeOnlyAlias */, TODO, name)
						}
						if isType && node.kind == SyntaxKindImportEqualsDeclaration && hasEffectiveModifier(node, ModifierFlagsExport) {
							error(node, Diagnostics.Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled, isolatedModulesLikeFlagName)
						}
						break
						fallthrough
					case SyntaxKindExportSpecifier:
						if compilerOptions.verbatimModuleSyntax || getSourceFileOfNode(typeOnlyAlias) != getSourceFileOfNode(node) {
							name := moduleExportNameTextUnescaped(node.propertyName || node.name)
							diagnostic := /* TODO(ConditionalExpression): isType                                     ? error(node, Diagnostics.Re_exporting_a_type_when_0_is_enabled_requires_using_export_type, isolatedModulesLikeFlagName)                                     : error(node, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled, name, isolatedModulesLikeFlagName) */ TODO
							addTypeOnlyDeclarationRelatedInfo(diagnostic /* TODO(ConditionalExpression): isType ? undefined : typeOnlyAlias */, TODO, name)
							break
						}
					}
				}
				if compilerOptions.verbatimModuleSyntax && node.kind != SyntaxKindImportEqualsDeclaration && !isInJSFile(node) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
					error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
				} else if moduleKind == ModuleKindPreserve && node.kind != SyntaxKindImportEqualsDeclaration && node.kind != SyntaxKindVariableDeclaration && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
					error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_module_is_set_to_preserve)
				}
				if compilerOptions.verbatimModuleSyntax && !isTypeOnlyImportOrExportDeclaration(node) && !(node.flags & NodeFlagsAmbient) && targetFlags&SymbolFlagsConstEnum {
					constEnumDeclaration := target.valueDeclaration
					redirect := host.getRedirectReferenceForResolutionFromSourceOfProject(getSourceFileOfNode(constEnumDeclaration).resolvedPath)
					if constEnumDeclaration.flags&NodeFlagsAmbient && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) {
						error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName)
					}
				}
			}
			if isImportSpecifier(node) {
				targetSymbol := resolveAliasWithDeprecationCheck(symbol, node)
				if isDeprecatedSymbol(targetSymbol) && targetSymbol.declarations {
					addDeprecatedSuggestion(node, targetSymbol.declarations, targetSymbol.escapedName)
				}
			}
		}
	}
	resolveAliasWithDeprecationCheck := func(symbol Symbol, location Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		if !(symbol.flags & SymbolFlagsAlias) || isDeprecatedSymbol(symbol) || !getDeclarationOfAliasSymbol(symbol) {
			return symbol
		}
		targetSymbol := resolveAlias(symbol)
		if targetSymbol == unknownSymbol {
			return targetSymbol
		}
		for symbol.flags & SymbolFlagsAlias {
			target := getImmediateAliasedSymbol(symbol)
			if target {
				if target == targetSymbol {
					break
				}
				if target.declarations && length(target.declarations) {
					if isDeprecatedSymbol(target) {
						addDeprecatedSuggestion(location, target.declarations, target.escapedName)
						break
					} else {
						if symbol == targetSymbol {
							break
						}
						symbol = target
					}
				}
			} else {
				break
			}
		}
		return targetSymbol
	}
	checkImportBinding := func(node /* TODO(UnionType): ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportSpecifier */ any) {
		checkCollisionsForDeclarationName(node, node.name)
		checkAliasSymbol(node)
		if node.kind == SyntaxKindImportSpecifier {
			checkModuleExportName(node.propertyName)
			if moduleExportNameIsDefault(node.propertyName || node.name) && getESModuleInterop(compilerOptions) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem {
				checkExternalEmitHelpers(node, ExternalEmitHelpersImportDefault)
			}
		}
	}
	checkImportAttributes := func(declaration /* TODO(UnionType): ImportDeclaration | ExportDeclaration | JSDocImportTag */ any) /* TODO inferred type boolean | undefined */ TODO {
		node := declaration.attributes
		if node {
			importAttributesType := getGlobalImportAttributesType(true)
			if importAttributesType != emptyObjectType {
				checkTypeAssignableTo(getTypeFromImportAttributes(node), getNullableType(importAttributesType, TypeFlagsUndefined), node)
			}
			validForTypeAttributes := isExclusivelyTypeOnlyImportOrExport(declaration)
			override := getResolutionModeOverride(node /* TODO(ConditionalExpression): validForTypeAttributes ? grammarErrorOnNode : undefined */, TODO)
			isImportAttributes := declaration.attributes.token == SyntaxKindWithKeyword
			if validForTypeAttributes && override {
				return
			}
			mode := (moduleKind == ModuleKindNodeNext) && declaration.moduleSpecifier && getEmitSyntaxForModuleSpecifierExpression(declaration.moduleSpecifier)
			if mode != ModuleKindESNext && moduleKind != ModuleKindESNext && moduleKind != ModuleKindPreserve {
				message := /* TODO(ConditionalExpression): isImportAttributes                     ? moduleKind === ModuleKind.NodeNext                         ? Diagnostics.Import_attributes_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls                         : Diagnostics.Import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve                     : moduleKind === ModuleKind.NodeNext                     ? Diagnostics.Import_assertions_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls                     : Diagnostics.Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve */ TODO
				return grammarErrorOnNode(node, message)
			}
			isTypeOnly := isJSDocImportTag(declaration) || ( /* TODO(ConditionalExpression): isImportDeclaration(declaration) ? declaration.importClause?.isTypeOnly : declaration.isTypeOnly */ TODO)
			if isTypeOnly {
				return grammarErrorOnNode(node /* TODO(ConditionalExpression): isImportAttributes ? Diagnostics.Import_attributes_cannot_be_used_with_type_only_imports_or_exports : Diagnostics.Import_assertions_cannot_be_used_with_type_only_imports_or_exports */, TODO)
			}
			if override {
				return grammarErrorOnNode(node, Diagnostics.resolution_mode_can_only_be_set_for_type_only_imports)
			}
		}
	}
	checkImportAttribute := func(node ImportAttribute) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getRegularTypeOfLiteralType(checkExpressionCached(node.value))
	}
	checkImportDeclaration := func(node ImportDeclaration) {
		if checkGrammarModuleElementContext(node /* TODO(ConditionalExpression): isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */, TODO) {
			return
		}
		if !checkGrammarModifiers(node) && node.modifiers {
			grammarErrorOnFirstToken(node, Diagnostics.An_import_declaration_cannot_have_modifiers)
		}
		if checkExternalImportOrExportDeclaration(node) {
			importClause := node.importClause
			if importClause && !checkGrammarImportClause(importClause) {
				if importClause.name {
					checkImportBinding(importClause)
				}
				if importClause.namedBindings {
					if importClause.namedBindings.kind == SyntaxKindNamespaceImport {
						checkImportBinding(importClause.namedBindings)
						if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && getESModuleInterop(compilerOptions) {
							checkExternalEmitHelpers(node, ExternalEmitHelpersImportStar)
						}
					} else {
						moduleExisted := resolveExternalModuleName(node, node.moduleSpecifier)
						if moduleExisted {
							forEach(importClause.namedBindings.elements, checkImportBinding)
						}
					}
				}
			} else if noUncheckedSideEffectImports && !importClause {
				/* TODO(ExpressionStatement): void resolveExternalModuleName(node, node.moduleSpecifier); */
			}
		}
		checkImportAttributes(node)
	}
	checkImportEqualsDeclaration := func(node ImportEqualsDeclaration) {
		if checkGrammarModuleElementContext(node /* TODO(ConditionalExpression): isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */, TODO) {
			return
		}
		checkGrammarModifiers(node)
		if isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(node) {
			checkImportBinding(node)
			markLinkedReferences(node, ReferenceHintExportImportEquals)
			if node.moduleReference.kind != SyntaxKindExternalModuleReference {
				target := resolveAlias(getSymbolOfDeclaration(node))
				if target != unknownSymbol {
					targetFlags := getSymbolFlags(target)
					if targetFlags & SymbolFlagsValue {
						moduleName := getFirstIdentifier(node.moduleReference)
						if !(resolveEntityName(moduleName, SymbolFlagsValue|SymbolFlagsNamespace).flags & SymbolFlagsNamespace) {
							error(moduleName, Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, declarationNameToString(moduleName))
						}
					}
					if targetFlags & SymbolFlagsType {
						checkTypeNameIsReserved(node.name, Diagnostics.Import_name_cannot_be_0)
					}
				}
				if node.isTypeOnly {
					grammarErrorOnNode(node, Diagnostics.An_import_alias_cannot_use_import_type)
				}
			} else {
				if ModuleKindES2015 <= moduleKind && moduleKind <= ModuleKindESNext && !node.isTypeOnly && !(node.flags & NodeFlagsAmbient) {
					grammarErrorOnNode(node, Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead)
				}
			}
		}
	}
	checkExportDeclaration := func(node ExportDeclaration) {
		if checkGrammarModuleElementContext(node /* TODO(ConditionalExpression): isInJSFile(node) ? Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */, TODO) {
			return
		}
		if !checkGrammarModifiers(node) && hasSyntacticModifiers(node) {
			grammarErrorOnFirstToken(node, Diagnostics.An_export_declaration_cannot_have_modifiers)
		}
		checkGrammarExportDeclaration(node)
		if !node.moduleSpecifier || checkExternalImportOrExportDeclaration(node) {
			if node.exportClause && !isNamespaceExport(node.exportClause) {
				forEach(node.exportClause.elements, checkExportSpecifier)
				inAmbientExternalModule := node.parent.kind == SyntaxKindModuleBlock && isAmbientModule(node.parent.parent)
				inAmbientNamespaceDeclaration := !inAmbientExternalModule && node.parent.kind == SyntaxKindModuleBlock && !node.moduleSpecifier && node.flags&NodeFlagsAmbient
				if node.parent.kind != SyntaxKindSourceFile && !inAmbientExternalModule && !inAmbientNamespaceDeclaration {
					error(node, Diagnostics.Export_declarations_are_not_permitted_in_a_namespace)
				}
			} else {
				moduleSymbol := resolveExternalModuleName(node, node.moduleSpecifier)
				if moduleSymbol && hasExportAssignmentSymbol(moduleSymbol) {
					error(node.moduleSpecifier, Diagnostics.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk, symbolToString(moduleSymbol))
				} else if node.exportClause {
					checkAliasSymbol(node.exportClause)
					checkModuleExportName(node.exportClause.name)
				}
				if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem {
					if node.exportClause {
						if getESModuleInterop(compilerOptions) {
							checkExternalEmitHelpers(node, ExternalEmitHelpersImportStar)
						}
					} else {
						checkExternalEmitHelpers(node, ExternalEmitHelpersExportStar)
					}
				}
			}
		}
		checkImportAttributes(node)
	}
	checkGrammarExportDeclaration := func(node ExportDeclaration) bool {
		if node.isTypeOnly && node.exportClause.kind == SyntaxKindNamedExports {
			return checkGrammarNamedImportsOrExports(node.exportClause)
		}
		return false
	}
	checkGrammarModuleElementContext := func(node Statement, errorMessage DiagnosticMessage) bool {
		isInAppropriateContext := node.parent.kind == SyntaxKindSourceFile || node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindModuleDeclaration
		if !isInAppropriateContext {
			grammarErrorOnFirstToken(node, errorMessage)
		}
		return !isInAppropriateContext
	}
	checkExportSpecifier := func(node ExportSpecifier) {
		checkAliasSymbol(node)
		hasModuleSpecifier := node.parent.parent.moduleSpecifier != nil
		checkModuleExportName(node.propertyName, hasModuleSpecifier)
		checkModuleExportName(node.name)
		if getEmitDeclarations(compilerOptions) {
			collectLinkedAliases(node.propertyName || node.name, true)
		}
		if !hasModuleSpecifier {
			exportedName := node.propertyName || node.name
			if exportedName.kind == SyntaxKindStringLiteral {
				return
			}
			symbol := resolveName(exportedName, exportedName.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias, nil, true)
			if symbol && (symbol == undefinedSymbol || symbol == globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer( /* TODO(ElementAccessExpression): symbol.declarations[0] */ TODO))) {
				error(exportedName, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, idText(exportedName))
			} else {
				markLinkedReferences(node, ReferenceHintExportSpecifier)
			}
		} else {
			if getESModuleInterop(compilerOptions) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && moduleExportNameIsDefault(node.propertyName || node.name) {
				checkExternalEmitHelpers(node, ExternalEmitHelpersImportDefault)
			}
		}
	}
	checkExportAssignment := func(node ExportAssignment) {
		illegalContextMessage := /* TODO(ConditionalExpression): node.isExportEquals             ? Diagnostics.An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration             : Diagnostics.A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration */ TODO
		if checkGrammarModuleElementContext(node, illegalContextMessage) {
			return
		}
		container := /* TODO(ConditionalExpression): node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent as ModuleDeclaration */ TODO
		if container.kind == SyntaxKindModuleDeclaration && !isAmbientModule(container) {
			if node.isExportEquals {
				error(node, Diagnostics.An_export_assignment_cannot_be_used_in_a_namespace)
			} else {
				error(node, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module)
			}
			return
		}
		if !checkGrammarModifiers(node) && hasEffectiveModifiers(node) {
			grammarErrorOnFirstToken(node, Diagnostics.An_export_assignment_cannot_have_modifiers)
		}
		typeAnnotationNode := getEffectiveTypeAnnotationNode(node)
		if typeAnnotationNode {
			checkTypeAssignableTo(checkExpressionCached(node.expression), getTypeFromTypeNode(typeAnnotationNode), node.expression)
		}
		isIllegalExportDefaultInCJS := !node.isExportEquals && !(node.flags & NodeFlagsAmbient) && compilerOptions.verbatimModuleSyntax && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS
		if node.expression.kind == SyntaxKindIdentifier {
			id := node.expression
			sym := getExportSymbolOfValueSymbolIfExported(resolveEntityName(id, SymbolFlagsAll, true, true, node))
			if sym {
				markLinkedReferences(node, ReferenceHintExportAssignment)
				typeOnlyDeclaration := getTypeOnlyAliasDeclaration(sym, SymbolFlagsValue)
				if getSymbolFlags(sym) & SymbolFlagsValue {
					checkExpressionCached(id)
					if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && compilerOptions.verbatimModuleSyntax && typeOnlyDeclaration {
						error(id /* TODO(ConditionalExpression): node.isExportEquals                                 ? Diagnostics.An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration                                 : Diagnostics.An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration */, TODO, idText(id))
					}
				} else if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && compilerOptions.verbatimModuleSyntax {
					error(id /* TODO(ConditionalExpression): node.isExportEquals                             ? Diagnostics.An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type                             : Diagnostics.An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type */, TODO, idText(id))
				}
				if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && getIsolatedModules(compilerOptions) && !(sym.flags & SymbolFlagsValue) {
					nonLocalMeanings := getSymbolFlags(sym, false, true)
					if sym.flags&SymbolFlagsAlias && nonLocalMeanings&SymbolFlagsType && !(nonLocalMeanings & SymbolFlagsValue) && (!typeOnlyDeclaration || getSourceFileOfNode(typeOnlyDeclaration) != getSourceFileOfNode(node)) {
						error(id /* TODO(ConditionalExpression): node.isExportEquals ?                                 Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported                                 : Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default */, TODO, idText(id), isolatedModulesLikeFlagName)
					} else if typeOnlyDeclaration && getSourceFileOfNode(typeOnlyDeclaration) != getSourceFileOfNode(node) {
						addTypeOnlyDeclarationRelatedInfo(error(id /* TODO(ConditionalExpression): node.isExportEquals ?                                     Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported                                     : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default */, TODO, idText(id), isolatedModulesLikeFlagName), typeOnlyDeclaration, idText(id))
					}
				}
			} else {
				checkExpressionCached(id)
			}
			if getEmitDeclarations(compilerOptions) {
				collectLinkedAliases(id, true)
			}
		} else {
			checkExpressionCached(node.expression)
		}
		if isIllegalExportDefaultInCJS {
			error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
		}
		checkExternalModuleExports(container)
		if (node.flags & NodeFlagsAmbient) && !isEntityNameExpression(node.expression) {
			grammarErrorOnNode(node.expression, Diagnostics.The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context)
		}
		if node.isExportEquals {
			if moduleKind >= ModuleKindES2015 && moduleKind != ModuleKindPreserve && ((node.flags&NodeFlagsAmbient && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) == ModuleKindESNext) || (!(node.flags & NodeFlagsAmbient) && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) != ModuleKindCommonJS)) {
				grammarErrorOnNode(node, Diagnostics.Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead)
			} else if moduleKind == ModuleKindSystem && !(node.flags & NodeFlagsAmbient) {
				grammarErrorOnNode(node, Diagnostics.Export_assignment_is_not_supported_when_module_flag_is_system)
			}
		}
	}
	hasExportedMembers := func(moduleSymbol Symbol) /* TODO inferred type boolean | undefined */ TODO {
		return forEachEntry(moduleSymbol.exports, func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) /* TODO inferred type boolean */ TODO {
			return id != "export="
		})
	}
	checkExternalModuleExports := func(node /* TODO(UnionType): SourceFile | ModuleDeclaration */ any) {
		moduleSymbol := getSymbolOfDeclaration(node)
		links := getSymbolLinks(moduleSymbol)
		if !links.exportsChecked {
			exportEqualsSymbol := moduleSymbol.exports.get("export=")
			if exportEqualsSymbol && hasExportedMembers(moduleSymbol) {
				declaration := getDeclarationOfAliasSymbol(exportEqualsSymbol) || exportEqualsSymbol.valueDeclaration
				if declaration && !isTopLevelInExternalModuleAugmentation(declaration) && !isInJSFile(declaration) {
					error(declaration, Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements)
				}
			}
			exports := getExportsOfModule(moduleSymbol)
			if exports {
				exports.forEach(func(TODO_IDENTIFIER /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
					if id == "__export" {
						return
					}
					if flags & (SymbolFlagsNamespace | SymbolFlagsEnum) {
						return
					}
					exportedDeclarationsCount := countWhere(declarations, and(isNotOverloadAndNotAccessor, not(isInterfaceDeclaration)))
					if flags&SymbolFlagsTypeAlias && exportedDeclarationsCount <= 2 {
						return
					}
					if exportedDeclarationsCount > 1 {
						if !isDuplicatedCommonJSExport(declarations) {
							for _, declaration := range declarations {
								if isNotOverload(declaration) {
									diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Cannot_redeclare_exported_variable_0, unescapeLeadingUnderscores(id)))
								}
							}
						}
					}
				})
			}
			links.exportsChecked = true
		}
	}
	isDuplicatedCommonJSExport := func(declarations /* TODO(ArrayType): Declaration[] */ any) /* TODO inferred type boolean | undefined */ TODO {
		return declarations && declarations.length > 1 && declarations.every(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
			return isInJSFile(d) && isAccessExpression(d) && (isExportsIdentifier(d.expression) || isModuleExportsAccessExpression(d.expression))
		})
	}
	checkSourceElement := func(node Node) {
		if node {
			saveCurrentNode := currentNode
			currentNode = node
			instantiationCount = 0
			checkSourceElementWorker(node)
			currentNode = saveCurrentNode
		}
	}
	checkSourceElementWorker := func(node Node) {
		if getNodeCheckFlags(node) & NodeCheckFlagsPartiallyTypeChecked {
			return
		}
		if canHaveJSDoc(node) {
			forEach(node.jsDoc, func(TODO_IDENTIFIER /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDoc */ TODO) {
				checkJSDocCommentWorker(comment)
				forEach(tags, func(tag /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocTag */ TODO) {
					checkJSDocCommentWorker(tag.comment)
					if isInJSFile(node) {
						checkSourceElement(tag)
					}
				})
			})
		}
		kind := node.kind
		if cancellationToken {
			switch kind {
			case SyntaxKindModuleDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionDeclaration:
				cancellationToken.throwIfCancellationRequested()
			}
		}
		if kind >= SyntaxKindFirstStatement && kind <= SyntaxKindLastStatement && canHaveFlowNode(node) && node.flowNode && !isReachableFlowNode(node.flowNode) {
			errorOrSuggestion(compilerOptions.allowUnreachableCode == false, node, Diagnostics.Unreachable_code_detected)
		}
		switch kind {
		case SyntaxKindTypeParameter:
			return checkTypeParameter(node)
		case SyntaxKindParameter:
			return checkParameter(node)
		case SyntaxKindPropertyDeclaration:
			return checkPropertyDeclaration(node)
		case SyntaxKindPropertySignature:
			return checkPropertySignature(node)
		case SyntaxKindConstructorType:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionType:
			fallthrough // TODO: merge cases
		case SyntaxKindCallSignature:
			fallthrough // TODO: merge cases
		case SyntaxKindConstructSignature:
			fallthrough // TODO: merge cases
		case SyntaxKindIndexSignature:
			return checkSignatureDeclaration(node)
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodSignature:
			return checkMethodDeclaration(node)
		case SyntaxKindClassStaticBlockDeclaration:
			return checkClassStaticBlockDeclaration(node)
		case SyntaxKindConstructor:
			return checkConstructorDeclaration(node)
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			return checkAccessorDeclaration(node)
		case SyntaxKindTypeReference:
			return checkTypeReferenceNode(node)
		case SyntaxKindTypePredicate:
			return checkTypePredicate(node)
		case SyntaxKindTypeQuery:
			return checkTypeQuery(node)
		case SyntaxKindTypeLiteral:
			return checkTypeLiteral(node)
		case SyntaxKindArrayType:
			return checkArrayType(node)
		case SyntaxKindTupleType:
			return checkTupleType(node)
		case SyntaxKindUnionType:
			fallthrough // TODO: merge cases
		case SyntaxKindIntersectionType:
			return checkUnionOrIntersectionType(node)
		case SyntaxKindParenthesizedType:
			fallthrough // TODO: merge cases
		case SyntaxKindOptionalType:
			fallthrough // TODO: merge cases
		case SyntaxKindRestType:
			return checkSourceElement((node).type_)
		case SyntaxKindThisType:
			return checkThisType(node)
		case SyntaxKindTypeOperator:
			return checkTypeOperator(node)
		case SyntaxKindConditionalType:
			return checkConditionalType(node)
		case SyntaxKindInferType:
			return checkInferType(node)
		case SyntaxKindTemplateLiteralType:
			return checkTemplateLiteralType(node)
		case SyntaxKindImportType:
			return checkImportType(node)
		case SyntaxKindNamedTupleMember:
			return checkNamedTupleMember(node)
		case SyntaxKindJSDocAugmentsTag:
			return checkJSDocAugmentsTag(node)
		case SyntaxKindJSDocImplementsTag:
			return checkJSDocImplementsTag(node)
		case SyntaxKindJSDocTypedefTag:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocCallbackTag:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocEnumTag:
			return checkJSDocTypeAliasTag(node)
		case SyntaxKindJSDocTemplateTag:
			return checkJSDocTemplateTag(node)
		case SyntaxKindJSDocTypeTag:
			return checkJSDocTypeTag(node)
		case SyntaxKindJSDocLink:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocLinkCode:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocLinkPlain:
			return checkJSDocLinkLikeTag(node)
		case SyntaxKindJSDocParameterTag:
			return checkJSDocParameterTag(node)
		case SyntaxKindJSDocPropertyTag:
			return checkJSDocPropertyTag(node)
		case SyntaxKindJSDocFunctionType:
			checkJSDocFunctionType(node)
			fallthrough
		case SyntaxKindJSDocNonNullableType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocNullableType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocAllType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocUnknownType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocTypeLiteral:
			checkJSDocTypeIsInJsFile(node)
			forEachChild(node, checkSourceElement)
			return
		case SyntaxKindJSDocVariadicType:
			checkJSDocVariadicType(node)
			return
		case SyntaxKindJSDocTypeExpression:
			return checkSourceElement((node).type_)
		case SyntaxKindJSDocPublicTag:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocProtectedTag:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocPrivateTag:
			return checkJSDocAccessibilityModifiers(node)
		case SyntaxKindJSDocSatisfiesTag:
			return checkJSDocSatisfiesTag(node)
		case SyntaxKindJSDocThisTag:
			return checkJSDocThisTag(node)
		case SyntaxKindJSDocImportTag:
			return checkJSDocImportTag(node)
		case SyntaxKindIndexedAccessType:
			return checkIndexedAccessType(node)
		case SyntaxKindMappedType:
			return checkMappedType(node)
		case SyntaxKindFunctionDeclaration:
			return checkFunctionDeclaration(node)
		case SyntaxKindBlock:
			fallthrough // TODO: merge cases
		case SyntaxKindModuleBlock:
			return checkBlock(node)
		case SyntaxKindVariableStatement:
			return checkVariableStatement(node)
		case SyntaxKindExpressionStatement:
			return checkExpressionStatement(node)
		case SyntaxKindIfStatement:
			return checkIfStatement(node)
		case SyntaxKindDoStatement:
			return checkDoStatement(node)
		case SyntaxKindWhileStatement:
			return checkWhileStatement(node)
		case SyntaxKindForStatement:
			return checkForStatement(node)
		case SyntaxKindForInStatement:
			return checkForInStatement(node)
		case SyntaxKindForOfStatement:
			return checkForOfStatement(node)
		case SyntaxKindContinueStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindBreakStatement:
			return checkBreakOrContinueStatement(node)
		case SyntaxKindReturnStatement:
			return checkReturnStatement(node)
		case SyntaxKindWithStatement:
			return checkWithStatement(node)
		case SyntaxKindSwitchStatement:
			return checkSwitchStatement(node)
		case SyntaxKindLabeledStatement:
			return checkLabeledStatement(node)
		case SyntaxKindThrowStatement:
			return checkThrowStatement(node)
		case SyntaxKindTryStatement:
			return checkTryStatement(node)
		case SyntaxKindVariableDeclaration:
			return checkVariableDeclaration(node)
		case SyntaxKindBindingElement:
			return checkBindingElement(node)
		case SyntaxKindClassDeclaration:
			return checkClassDeclaration(node)
		case SyntaxKindInterfaceDeclaration:
			return checkInterfaceDeclaration(node)
		case SyntaxKindTypeAliasDeclaration:
			return checkTypeAliasDeclaration(node)
		case SyntaxKindEnumDeclaration:
			return checkEnumDeclaration(node)
		case SyntaxKindModuleDeclaration:
			return checkModuleDeclaration(node)
		case SyntaxKindImportDeclaration:
			return checkImportDeclaration(node)
		case SyntaxKindImportEqualsDeclaration:
			return checkImportEqualsDeclaration(node)
		case SyntaxKindExportDeclaration:
			return checkExportDeclaration(node)
		case SyntaxKindExportAssignment:
			return checkExportAssignment(node)
		case SyntaxKindEmptyStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindDebuggerStatement:
			checkGrammarStatementInAmbientContext(node)
			return
		case SyntaxKindMissingDeclaration:
			return checkMissingDeclaration(node)
		}
	}
	checkJSDocCommentWorker := func(node /* TODO(UnionType): string | readonly JSDocComment[] | undefined */ any) {
		if isArray(node) {
			forEach(node, func(tag /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocComment */ TODO) {
				if isJSDocLinkLike(tag) {
					checkSourceElement(tag)
				}
			})
		}
	}
	checkJSDocTypeIsInJsFile := func(node Node) {
		if !isInJSFile(node) {
			if isJSDocNonNullableType(node) || isJSDocNullableType(node) {
				token := tokenToString( /* TODO(ConditionalExpression): isJSDocNonNullableType(node) ? SyntaxKind.ExclamationToken : SyntaxKind.QuestionToken */ TODO)
				diagnostic := /* TODO(ConditionalExpression): node.postfix                     ? Diagnostics._0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1                     : Diagnostics._0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1 */ TODO
				typeNode := node.type_
				type_ := getTypeFromTypeNode(typeNode)
				grammarErrorOnNode(node, diagnostic, token, typeToString( /* TODO(ConditionalExpression): isJSDocNullableType(node) && !(type === neverType || type === voidType)                             ? getUnionType(append([type, undefinedType], node.postfix ? undefined : nullType)) : type */ TODO))
			} else {
				grammarErrorOnNode(node, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments)
			}
		}
	}
	checkJSDocVariadicType := func(node JSDocVariadicType) {
		checkJSDocTypeIsInJsFile(node)
		checkSourceElement(node.type_)
		TODO_IDENTIFIER := node
		if isParameter(parent) && isJSDocFunctionType(parent.parent) {
			if last(parent.parent.parameters) != parent {
				error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list)
			}
			return
		}
		if !isJSDocTypeExpression(parent) {
			error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature)
		}
		paramTag := node.parent.parent
		if !isJSDocParameterTag(paramTag) {
			error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature)
			return
		}
		param := getParameterSymbolFromJSDoc(paramTag)
		if !param {
			return
		}
		host := getHostSignatureFromJSDoc(paramTag)
		if !host || last(host.parameters).symbol != param {
			error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list)
		}
	}
	getTypeFromJSDocVariadicType := func(node JSDocVariadicType) Type {
		type_ := getTypeFromTypeNode(node.type_)
		TODO_IDENTIFIER := node
		paramTag := node.parent.parent
		if isJSDocTypeExpression(node.parent) && isJSDocParameterTag(paramTag) {
			host := getHostSignatureFromJSDoc(paramTag)
			isCallbackTag := isJSDocCallbackTag(paramTag.parent.parent)
			if host || isCallbackTag {
				lastParamDeclaration := /* TODO(ConditionalExpression): isCallbackTag                     ? lastOrUndefined((paramTag.parent.parent as unknown as JSDocCallbackTag).typeExpression.parameters)                     : lastOrUndefined(host!.parameters) */ TODO
				symbol := getParameterSymbolFromJSDoc(paramTag)
				if !lastParamDeclaration || symbol && lastParamDeclaration.symbol == symbol && isRestParameter(lastParamDeclaration) {
					return createArrayType(type_)
				}
			}
		}
		if isParameter(parent) && isJSDocFunctionType(parent.parent) {
			return createArrayType(type_)
		}
		return addOptionality(type_)
	}
	checkNodeDeferred := func(node Node) {
		enclosingFile := getSourceFileOfNode(node)
		links := getNodeLinks(enclosingFile)
		if !(links.flags & NodeCheckFlagsTypeChecked) {
			/* TODO(ExpressionStatement): links.deferredNodes ||= new Set(); */
			links.deferredNodes.add(node)
		} else {
			Debug.assert(!links.deferredNodes, "A type-checked file should have no deferred nodes.")
		}
	}
	checkDeferredNodes := func(context SourceFile) {
		links := getNodeLinks(context)
		if links.deferredNodes {
			links.deferredNodes.forEach(checkDeferredNode)
		}
		links.deferredNodes = nil
	}
	checkDeferredNode := func(node Node) {
		tracing.push(tracing.Phase.Check, "checkDeferredNode" /* TODO(ObjectLiteralExpression): { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath } */, TODO)
		saveCurrentNode := currentNode
		currentNode = node
		instantiationCount = 0
		switch node.kind {
		case SyntaxKindCallExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNewExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTaggedTemplateExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindDecorator:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxOpeningElement:
			resolveUntypedCall(node)
			break
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodSignature:
			checkFunctionExpressionOrObjectLiteralMethodDeferred(node)
			break
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			checkAccessorDeclaration(node)
			break
		case SyntaxKindClassExpression:
			checkClassExpressionDeferred(node)
			break
		case SyntaxKindTypeParameter:
			checkTypeParameterDeferred(node)
			break
		case SyntaxKindJsxSelfClosingElement:
			checkJsxSelfClosingElementDeferred(node)
			break
		case SyntaxKindJsxElement:
			checkJsxElementDeferred(node)
			break
		case SyntaxKindTypeAssertionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindAsExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindParenthesizedExpression:
			checkAssertionDeferred(node)
			break
		case SyntaxKindVoidExpression:
			checkExpression((node).expression)
			break
		case SyntaxKindBinaryExpression:
			if isInstanceOfExpression(node) {
				resolveUntypedCall(node)
			}
			break
		}
		currentNode = saveCurrentNode
		tracing.pop()
	}
	checkSourceFile := func(node SourceFile, nodesToCheck /* TODO(ArrayType): Node[] */ any) {
		tracing.push(tracing.Phase.Check /* TODO(ConditionalExpression): nodesToCheck ? "checkSourceFileNodes" : "checkSourceFile" */, TODO /* TODO(ObjectLiteralExpression): { path: node.path } */, TODO, true)
		beforeMark := /* TODO(ConditionalExpression): nodesToCheck ? "beforeCheckNodes" : "beforeCheck" */ TODO
		afterMark := /* TODO(ConditionalExpression): nodesToCheck ? "afterCheckNodes" : "afterCheck" */ TODO
		performance.mark(beforeMark)
		/* TODO(ExpressionStatement): nodesToCheck ? checkSourceFileNodesWorker(node, nodesToCheck) : checkSourceFileWorker(node); */
		performance.mark(afterMark)
		performance.measure("Check", beforeMark, afterMark)
		tracing.pop()
	}
	unusedIsError := func(kind UnusedKind, isAmbient bool) bool {
		if isAmbient {
			return false
		}
		switch kind {
		case UnusedKindLocal:
			return !!compilerOptions.noUnusedLocals
		case UnusedKindParameter:
			return !!compilerOptions.noUnusedParameters
		default:
			return Debug.assertNever(kind)
		}
	}
	getPotentiallyUnusedIdentifiers := func(sourceFile SourceFile) []PotentiallyUnusedIdentifier {
		return allPotentiallyUnusedIdentifiers.get(sourceFile.path) || emptyArray
	}
	checkSourceFileWorker := func(node SourceFile) {
		links := getNodeLinks(node)
		if !(links.flags & NodeCheckFlagsTypeChecked) {
			if skipTypeChecking(node, compilerOptions, host) {
				return
			}
			checkGrammarSourceFile(node)
			clear(potentialThisCollisions)
			clear(potentialNewTargetCollisions)
			clear(potentialWeakMapSetCollisions)
			clear(potentialReflectCollisions)
			clear(potentialUnusedRenamedBindingElementsInTypes)
			if links.flags & NodeCheckFlagsPartiallyTypeChecked {
				potentialThisCollisions = links.potentialThisCollisions
				potentialNewTargetCollisions = links.potentialNewTargetCollisions
				potentialWeakMapSetCollisions = links.potentialWeakMapSetCollisions
				potentialReflectCollisions = links.potentialReflectCollisions
				potentialUnusedRenamedBindingElementsInTypes = links.potentialUnusedRenamedBindingElementsInTypes
			}
			forEach(node.statements, checkSourceElement)
			checkSourceElement(node.endOfFileToken)
			checkDeferredNodes(node)
			if isExternalOrCommonJsModule(node) {
				registerForUnusedIdentifiersCheck(node)
			}
			addLazyDiagnostic(func() {
				if !node.isDeclarationFile && (compilerOptions.noUnusedLocals || compilerOptions.noUnusedParameters) {
					checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(node), func(containingNode /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO, kind /* TODO inferred type UnusedKind */ TODO, diag /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO) {
						if !containsParseError(containingNode) && unusedIsError(kind, !!(containingNode.flags&NodeFlagsAmbient)) {
							diagnostics.add(diag)
						}
					})
				}
				if !node.isDeclarationFile {
					checkPotentialUncheckedRenamedBindingElementsInTypes()
				}
			})
			if isExternalOrCommonJsModule(node) {
				checkExternalModuleExports(node)
			}
			if potentialThisCollisions.length {
				forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope)
				clear(potentialThisCollisions)
			}
			if potentialNewTargetCollisions.length {
				forEach(potentialNewTargetCollisions, checkIfNewTargetIsCapturedInEnclosingScope)
				clear(potentialNewTargetCollisions)
			}
			if potentialWeakMapSetCollisions.length {
				forEach(potentialWeakMapSetCollisions, checkWeakMapSetCollision)
				clear(potentialWeakMapSetCollisions)
			}
			if potentialReflectCollisions.length {
				forEach(potentialReflectCollisions, checkReflectCollision)
				clear(potentialReflectCollisions)
			}
			links.flags |= NodeCheckFlagsTypeChecked
		}
	}
	checkSourceFileNodesWorker := func(file SourceFile, nodes []Node) {
		links := getNodeLinks(file)
		if !(links.flags & NodeCheckFlagsTypeChecked) {
			if skipTypeChecking(file, compilerOptions, host) {
				return
			}
			checkGrammarSourceFile(file)
			clear(potentialThisCollisions)
			clear(potentialNewTargetCollisions)
			clear(potentialWeakMapSetCollisions)
			clear(potentialReflectCollisions)
			clear(potentialUnusedRenamedBindingElementsInTypes)
			forEach(nodes, checkSourceElement)
			checkDeferredNodes(file)
			(links.potentialThisCollisions || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.potentialThisCollisions = [] */ TODO)).push( /* TODO(SpreadElement): ...potentialThisCollisions */ TODO)
			(links.potentialNewTargetCollisions || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.potentialNewTargetCollisions = [] */ TODO)).push( /* TODO(SpreadElement): ...potentialNewTargetCollisions */ TODO)
			(links.potentialWeakMapSetCollisions || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.potentialWeakMapSetCollisions = [] */ TODO)).push( /* TODO(SpreadElement): ...potentialWeakMapSetCollisions */ TODO)
			(links.potentialReflectCollisions || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.potentialReflectCollisions = [] */ TODO)).push( /* TODO(SpreadElement): ...potentialReflectCollisions */ TODO)
			(links.potentialUnusedRenamedBindingElementsInTypes || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.potentialUnusedRenamedBindingElementsInTypes = [] */ TODO)).push( /* TODO(SpreadElement): ...potentialUnusedRenamedBindingElementsInTypes */ TODO)
			links.flags |= NodeCheckFlagsPartiallyTypeChecked
			for _, node := range nodes {
				nodeLinks := getNodeLinks(node)
				nodeLinks.flags |= NodeCheckFlagsPartiallyTypeChecked
			}
		}
	}
	getDiagnostics := func(sourceFile SourceFile, ct CancellationToken, nodesToCheck []Node) []Diagnostic {
		/* TODO(TryStatement): try {             // Record the cancellation token so it can be checked later on during checkSourceElement.             // Do this in a finally block so we can ensure that it gets reset back to nothing after             // this call is done.             cancellationToken = ct;             return getDiagnosticsWorker(sourceFile, nodesToCheck);         }         finally {             cancellationToken = undefined;         } */
	}
	ensurePendingDiagnosticWorkComplete := func() {
		for _, cb := range deferredDiagnosticsCallbacks {
			cb()
		}
		deferredDiagnosticsCallbacks = /* TODO(ArrayLiteralExpression): [] */ TODO
	}
	checkSourceFileWithEagerDiagnostics := func(sourceFile SourceFile, nodesToCheck []Node) {
		ensurePendingDiagnosticWorkComplete()
		oldAddLazyDiagnostics := addLazyDiagnostic
		addLazyDiagnostic = func(cb /* TODO inferred type () => void */ TODO) {
			return cb()
		}
		checkSourceFile(sourceFile, nodesToCheck)
		addLazyDiagnostic = oldAddLazyDiagnostics
	}
	getDiagnosticsWorker := func(sourceFile SourceFile, nodesToCheck /* TODO(ArrayType): Node[] */ any) []Diagnostic {
		if sourceFile {
			ensurePendingDiagnosticWorkComplete()
			previousGlobalDiagnostics := diagnostics.getGlobalDiagnostics()
			previousGlobalDiagnosticsSize := previousGlobalDiagnostics.length
			checkSourceFileWithEagerDiagnostics(sourceFile, nodesToCheck)
			semanticDiagnostics := diagnostics.getDiagnostics(sourceFile.fileName)
			if nodesToCheck {
				return semanticDiagnostics
			}
			currentGlobalDiagnostics := diagnostics.getGlobalDiagnostics()
			if currentGlobalDiagnostics != previousGlobalDiagnostics {
				deferredGlobalDiagnostics := relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, compareDiagnostics)
				return concatenate(deferredGlobalDiagnostics, semanticDiagnostics)
			} else if previousGlobalDiagnosticsSize == 0 && currentGlobalDiagnostics.length > 0 {
				return concatenate(currentGlobalDiagnostics, semanticDiagnostics)
			}
			return semanticDiagnostics
		}
		forEach(host.getSourceFiles(), func(file /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SourceFile */ TODO) {
			return checkSourceFileWithEagerDiagnostics(file)
		})
		return diagnostics.getDiagnostics()
	}
	getGlobalDiagnostics := func() []Diagnostic {
		ensurePendingDiagnosticWorkComplete()
		return diagnostics.getGlobalDiagnostics()
	}
	getSymbolsInScope := func(location Node, meaning SymbolFlags) []Symbol {
		if location.flags & NodeFlagsInWithStatement {
			return /* TODO(ArrayLiteralExpression): [] */ TODO
		}
		symbols := createSymbolTable()
		isStaticSymbol := false
		populateSymbols()
		symbols.delete(InternalSymbolNameThis)
		return symbolsToArray(symbols)
		populateSymbols := func() {
			for location {
				if canHaveLocals(location) && location.locals && !isGlobalSourceFile(location) {
					copySymbols(location.locals, meaning)
				}
				switch location.kind {
				case SyntaxKindSourceFile:
					if !isExternalModule(location) {
						break
					}
					fallthrough
				case SyntaxKindModuleDeclaration:
					copyLocallyVisibleExportSymbols(getSymbolOfDeclaration(location).exports, meaning&SymbolFlagsModuleMember)
					break
				case SyntaxKindEnumDeclaration:
					copySymbols(getSymbolOfDeclaration(location).exports, meaning&SymbolFlagsEnumMember)
					break
				case SyntaxKindClassExpression:
					className := (location).name
					if className {
						copySymbol((location).symbol, meaning)
					}
					fallthrough
				case SyntaxKindClassDeclaration:
					fallthrough // TODO: merge cases
				case SyntaxKindInterfaceDeclaration:
					if !isStaticSymbol {
						copySymbols(getMembersOfSymbol(getSymbolOfDeclaration(location)), meaning&SymbolFlagsType)
					}
					break
				case SyntaxKindFunctionExpression:
					funcName := (location).name
					if funcName {
						copySymbol((location).symbol, meaning)
					}
					break
				}
				if introducesArgumentsExoticObject(location) {
					copySymbol(argumentsSymbol, meaning)
				}
				isStaticSymbol = isStatic(location)
				location = location.parent
			}
			copySymbols(globals, meaning)
		}
		copySymbol := func(symbol Symbol, meaning SymbolFlags) {
			if getCombinedLocalAndExportSymbolFlags(symbol) & meaning {
				id := symbol.escapedName
				if !symbols.has(id) {
					symbols.set(id, symbol)
				}
			}
		}
		copySymbols := func(source SymbolTable, meaning SymbolFlags) {
			if meaning {
				source.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
					copySymbol(symbol, meaning)
				})
			}
		}
		copyLocallyVisibleExportSymbols := func(source SymbolTable, meaning SymbolFlags) {
			if meaning {
				source.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
					if !getDeclarationOfKind(symbol, SyntaxKindExportSpecifier) && !getDeclarationOfKind(symbol, SyntaxKindNamespaceExport) && symbol.escapedName != InternalSymbolNameDefault {
						copySymbol(symbol, meaning)
					}
				})
			}
		}
	}
	isTypeDeclarationName := func(name Node) bool {
		return name.kind == SyntaxKindIdentifier && isTypeDeclaration(name.parent) && getNameOfDeclaration(name.parent) == name
	}
	isTypeReferenceIdentifier := func(node EntityName) bool {
		for node.parent.kind == SyntaxKindQualifiedName {
			node = node.parent
		}
		return node.parent.kind == SyntaxKindTypeReference
	}
	isInNameOfExpressionWithTypeArguments := func(node Node) bool {
		for node.parent.kind == SyntaxKindPropertyAccessExpression {
			node = node.parent
		}
		return node.parent.kind == SyntaxKindExpressionWithTypeArguments
	}
	forEachEnclosingClass := func(node Node, callback func(node ClassLikeDeclaration) *T) *T {
		var result *T
		containingClass := getContainingClass(node)
		for containingClass {
			if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = callback(containingClass) */ TODO {
				break
			}
			containingClass = getContainingClass(containingClass)
		}
		return result
	}
	isNodeUsedDuringClassInitialization := func(node Node) /* TODO inferred type boolean */ TODO {
		return !!findAncestor(node, func(element /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean | "quit" */ TODO {
			if isConstructorDeclaration(element) && nodeIsPresent(element.body) || isPropertyDeclaration(element) {
				return true
			} else if isClassLike(element) || isFunctionLikeDeclaration(element) {
				return "quit"
			}
			return false
		})
	}
	isNodeWithinClass := func(node Node, classDeclaration ClassLikeDeclaration) /* TODO inferred type boolean */ TODO {
		return !!forEachEnclosingClass(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ClassLikeDeclaration */ TODO) /* TODO inferred type boolean */ TODO {
			return n == classDeclaration
		})
	}
	getLeftSideOfImportEqualsOrExportAssignment := func(nodeOnRightSide EntityName) /* TODO(UnionType): ImportEqualsDeclaration | ExportAssignment | undefined */ any {
		for nodeOnRightSide.parent.kind == SyntaxKindQualifiedName {
			nodeOnRightSide = nodeOnRightSide.parent
		}
		if nodeOnRightSide.parent.kind == SyntaxKindImportEqualsDeclaration {
			return /* TODO(ConditionalExpression): (nodeOnRightSide.parent as ImportEqualsDeclaration).moduleReference === nodeOnRightSide ? nodeOnRightSide.parent as ImportEqualsDeclaration : undefined */ TODO
		}
		if nodeOnRightSide.parent.kind == SyntaxKindExportAssignment {
			return /* TODO(ConditionalExpression): (nodeOnRightSide.parent as ExportAssignment).expression === nodeOnRightSide as Node ? nodeOnRightSide.parent as ExportAssignment : undefined */ TODO
		}
		return nil
	}
	isInRightSideOfImportOrExportAssignment := func(node EntityName) /* TODO inferred type boolean */ TODO {
		return getLeftSideOfImportEqualsOrExportAssignment(node) != nil
	}
	getSpecialPropertyAssignmentSymbolFromEntityName := func(entityName /* TODO(UnionType): EntityName | PropertyAccessExpression */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		specialPropertyAssignmentKind := getAssignmentDeclarationKind(entityName.parent.parent)
		switch specialPropertyAssignmentKind {
		case AssignmentDeclarationKindExportsProperty:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindPrototypeProperty:
			return getSymbolOfNode(entityName.parent)
		case AssignmentDeclarationKindProperty:
			if isPropertyAccessExpression(entityName.parent) && getLeftmostAccessExpression(entityName.parent) == entityName {
				return nil
			}
			fallthrough
		case AssignmentDeclarationKindThisProperty:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindModuleExports:
			return getSymbolOfDeclaration(entityName.parent.parent)
		}
	}
	isImportTypeQualifierPart := func(node EntityName) *ImportTypeNode {
		parent := node.parent
		for isQualifiedName(parent) {
			node = parent
			parent = parent.parent
		}
		if parent && parent.kind == SyntaxKindImportType && (parent).qualifier == node {
			return parent
		}
		return nil
	}
	isThisPropertyAndThisTyped := func(node PropertyAccessExpression) /* TODO inferred type boolean | undefined */ TODO {
		if node.expression.kind == SyntaxKindThisKeyword {
			container := getThisContainer(node, false, false)
			if isFunctionLike(container) {
				containingLiteral := getContainingObjectLiteral(container)
				if containingLiteral {
					contextualType := getApparentTypeOfContextualType(containingLiteral, nil)
					type_ := getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
					return type_ && !isTypeAny(type_)
				}
			}
		}
	}
	getSymbolOfNameOrPropertyAccessExpression := func(name /* TODO(UnionType): EntityName | PrivateIdentifier | PropertyAccessExpression | JSDocMemberName */ any) *Symbol {
		if isDeclarationName(name) {
			return getSymbolOfNode(name.parent)
		}
		if isInJSFile(name) && name.parent.kind == SyntaxKindPropertyAccessExpression && name.parent == (name.parent.parent).left {
			if !isPrivateIdentifier(name) && !isJSDocMemberName(name) && !isThisPropertyAndThisTyped(name.parent) {
				specialPropertyAssignmentSymbol := getSpecialPropertyAssignmentSymbolFromEntityName(name)
				if specialPropertyAssignmentSymbol {
					return specialPropertyAssignmentSymbol
				}
			}
		}
		if name.parent.kind == SyntaxKindExportAssignment && isEntityNameExpression(name) {
			success := resolveEntityName(name, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias, true)
			if success && success != unknownSymbol {
				return success
			}
		} else if isEntityName(name) && isInRightSideOfImportOrExportAssignment(name) {
			importEqualsDeclaration := getAncestor(name, SyntaxKindImportEqualsDeclaration)
			Debug.assert(importEqualsDeclaration != nil)
			return getSymbolOfPartOfRightHandSideOfImportEquals(name, true)
		}
		if isEntityName(name) {
			possibleImportNode := isImportTypeQualifierPart(name)
			if possibleImportNode {
				getTypeFromTypeNode(possibleImportNode)
				sym := getNodeLinks(name).resolvedSymbol
				return /* TODO(ConditionalExpression): sym === unknownSymbol ? undefined : sym */ TODO
			}
		}
		for isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(name) {
			name = name.parent
		}
		if isInNameOfExpressionWithTypeArguments(name) {
			meaning := SymbolFlagsNone
			if name.parent.kind == SyntaxKindExpressionWithTypeArguments {
				meaning = /* TODO(ConditionalExpression): isPartOfTypeNode(name) ? SymbolFlags.Type : SymbolFlags.Value */ TODO
				if isExpressionWithTypeArgumentsInClassExtendsClause(name.parent) {
					meaning |= SymbolFlagsValue
				}
			} else {
				meaning = SymbolFlagsNamespace
			}
			meaning |= SymbolFlagsAlias
			entityNameSymbol := /* TODO(ConditionalExpression): isEntityNameExpression(name) ? resolveEntityName(name, meaning, /*ignoreErrors* / true) : undefined */ TODO
			if entityNameSymbol {
				return entityNameSymbol
			}
		}
		if name.parent.kind == SyntaxKindJSDocParameterTag {
			return getParameterSymbolFromJSDoc(name.parent)
		}
		if name.parent.kind == SyntaxKindTypeParameter && name.parent.parent.kind == SyntaxKindJSDocTemplateTag {
			Debug.assert(!isInJSFile(name))
			typeParameter := getTypeParameterFromJsDoc(name.parent)
			return typeParameter && typeParameter.symbol
		}
		if isExpressionNode(name) {
			if nodeIsMissing(name) {
				return nil
			}
			isJSDoc := findAncestor(name, or(isJSDocLinkLike, isJSDocNameReference, isJSDocMemberName))
			meaning := /* TODO(ConditionalExpression): isJSDoc ? SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Value : SymbolFlags.Value */ TODO
			if name.kind == SyntaxKindIdentifier {
				if isJSXTagName(name) && isJsxIntrinsicTagName(name) {
					symbol := getIntrinsicTagSymbol(name.parent)
					return /* TODO(ConditionalExpression): symbol === unknownSymbol ? undefined : symbol */ TODO
				}
				result := resolveEntityName(name, meaning, true, true, getHostSignatureFromJSDoc(name))
				if !result && isJSDoc {
					container := findAncestor(name, or(isClassLike, isInterfaceDeclaration))
					if container {
						return resolveJSDocMemberName(name, true, getSymbolOfDeclaration(container))
					}
				}
				if result && isJSDoc {
					container := getJSDocHost(name)
					if container && isEnumMember(container) && container == result.valueDeclaration {
						return resolveEntityName(name, meaning, true, true, getSourceFileOfNode(container)) || result
					}
				}
				return result
			} else if isPrivateIdentifier(name) {
				return getSymbolForPrivateIdentifierExpression(name)
			} else if name.kind == SyntaxKindPropertyAccessExpression || name.kind == SyntaxKindQualifiedName {
				links := getNodeLinks(name)
				if links.resolvedSymbol {
					return links.resolvedSymbol
				}
				if name.kind == SyntaxKindPropertyAccessExpression {
					checkPropertyAccessExpression(name, CheckModeNormal)
					if !links.resolvedSymbol {
						links.resolvedSymbol = getApplicableIndexSymbol(checkExpressionCached(name.expression), getLiteralTypeFromPropertyName(name.name))
					}
				} else {
					checkQualifiedName(name, CheckModeNormal)
				}
				if !links.resolvedSymbol && isJSDoc && isQualifiedName(name) {
					return resolveJSDocMemberName(name)
				}
				return links.resolvedSymbol
			} else if isJSDocMemberName(name) {
				return resolveJSDocMemberName(name)
			}
		} else if isTypeReferenceIdentifier(name) {
			meaning := /* TODO(ConditionalExpression): name.parent.kind === SyntaxKind.TypeReference ? SymbolFlags.Type : SymbolFlags.Namespace */ TODO
			symbol := resolveEntityName(name, meaning, false, true)
			return /* TODO(ConditionalExpression): symbol && symbol !== unknownSymbol ? symbol : getUnresolvedSymbolForEntityName(name as EntityName) */ TODO
		}
		if name.parent.kind == SyntaxKindTypePredicate {
			return resolveEntityName(name, SymbolFlagsFunctionScopedVariable)
		}
		return nil
	}
	getApplicableIndexSymbol := func(type_ Type, keyType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		infos := getApplicableIndexInfos(type_, keyType)
		if infos.length && (type_).members {
			symbol := getIndexSymbolFromSymbolTable(resolveStructuredTypeMembers(type_).members)
			if infos == getIndexInfosOfType(type_) {
				return symbol
			} else if symbol {
				symbolLinks := getSymbolLinks(symbol)
				declarationList := mapDefined(infos, func(i /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | undefined */ TODO {
					return i.declaration
				})
				nodeListId := map_(declarationList, getNodeId).join(",")
				if !symbolLinks.filteredIndexSymbolCache {
					symbolLinks.filteredIndexSymbolCache = /* TODO(NewExpression): new Map() */ make(map[any]any)
				}
				if symbolLinks.filteredIndexSymbolCache.has(nodeListId) {
					return symbolLinks.filteredIndexSymbolCache.get(nodeListId)
				} else {
					copy := createSymbol(SymbolFlagsSignature, InternalSymbolNameIndex)
					copy.declarations = mapDefined(infos, func(i /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | undefined */ TODO {
						return i.declaration
					})
					copy.parent = /* TODO(ConditionalExpression): type.aliasSymbol ? type.aliasSymbol : type.symbol ? type.symbol : getSymbolAtLocation(copy.declarations[0].parent) */ TODO
					symbolLinks.filteredIndexSymbolCache.set(nodeListId, copy)
					return copy
				}
			}
		}
	}
	resolveJSDocMemberName := func(name /* TODO(UnionType): EntityName | JSDocMemberName */ any, ignoreErrors bool, container Symbol) *Symbol {
		if isEntityName(name) {
			meaning := SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsValue
			symbol := resolveEntityName(name, meaning, ignoreErrors, true, getHostSignatureFromJSDoc(name))
			if !symbol && isIdentifier(name) && container {
				symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(container), name.escapedText, meaning))
			}
			if symbol {
				return symbol
			}
		}
		left := /* TODO(ConditionalExpression): isIdentifier(name) ? container : resolveJSDocMemberName(name.left, ignoreErrors, container) */ TODO
		right := /* TODO(ConditionalExpression): isIdentifier(name) ? name.escapedText : name.right.escapedText */ TODO
		if left {
			proto := left.flags&SymbolFlagsValue && getPropertyOfType(getTypeOfSymbol(left), "prototype")
			t := /* TODO(ConditionalExpression): proto ? getTypeOfSymbol(proto) : getDeclaredTypeOfSymbol(left) */ TODO
			return getPropertyOfType(t, right)
		}
	}
	getSymbolAtLocation := func(node Node, ignoreErrors bool) *Symbol {
		if isSourceFile(node) {
			return /* TODO(ConditionalExpression): isExternalModule(node) ? getMergedSymbol(node.symbol) : undefined */ TODO
		}
		TODO_IDENTIFIER := node
		grandParent := parent.parent
		if node.flags & NodeFlagsInWithStatement {
			return nil
		}
		if isDeclarationNameOrImportPropertyName(node) {
			parentSymbol := getSymbolOfDeclaration(parent)
			return /* TODO(ConditionalExpression): isImportOrExportSpecifier(node.parent) && node.parent.propertyName === node                 ? getImmediateAliasedSymbol(parentSymbol)                 : parentSymbol */ TODO
		} else if isLiteralComputedPropertyDeclarationName(node) {
			return getSymbolOfDeclaration(parent.parent)
		}
		if node.kind == SyntaxKindIdentifier {
			if isInRightSideOfImportOrExportAssignment(node) {
				return getSymbolOfNameOrPropertyAccessExpression(node)
			} else if parent.kind == SyntaxKindBindingElement && grandParent.kind == SyntaxKindObjectBindingPattern && node == (parent).propertyName {
				typeOfPattern := getTypeOfNode(grandParent)
				propertyDeclaration := getPropertyOfType(typeOfPattern, (node).escapedText)
				if propertyDeclaration {
					return propertyDeclaration
				}
			} else if isMetaProperty(parent) && parent.name == node {
				if parent.keywordToken == SyntaxKindNewKeyword && idText(node) == "target" {
					return checkNewTargetMetaProperty(parent).symbol
				}
				if parent.keywordToken == SyntaxKindImportKeyword && idText(node) == "meta" {
					return getGlobalImportMetaExpressionType().members.get("meta")
				}
				return nil
			}
		}
		switch node.kind {
		case SyntaxKindIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindPrivateIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindQualifiedName:
			if !isThisInTypeQuery(node) {
				return getSymbolOfNameOrPropertyAccessExpression(node)
			}
			fallthrough
		case SyntaxKindThisKeyword:
			container := getThisContainer(node, false, false)
			if isFunctionLike(container) {
				sig := getSignatureFromDeclaration(container)
				if sig.thisParameter {
					return sig.thisParameter
				}
			}
			if isInExpressionContext(node) {
				return checkExpression(node).symbol
			}
			fallthrough
		case SyntaxKindThisType:
			return getTypeFromThisTypeNode(node).symbol
		case SyntaxKindSuperKeyword:
			return checkExpression(node).symbol
		case SyntaxKindConstructorKeyword:
			constructorDeclaration := node.parent
			if constructorDeclaration && constructorDeclaration.kind == SyntaxKindConstructor {
				return (constructorDeclaration.parent).symbol
			}
			return nil
		case SyntaxKindStringLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindNoSubstitutionTemplateLiteral:
			if (isExternalModuleImportEqualsDeclaration(node.parent.parent) && getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) == node) || ((node.parent.kind == SyntaxKindImportDeclaration || node.parent.kind == SyntaxKindExportDeclaration) && (node.parent).moduleSpecifier == node) || (isInJSFile(node) && isJSDocImportTag(node.parent) && node.parent.moduleSpecifier == node) || ((isInJSFile(node) && isRequireCall(node.parent, false)) || isImportCall(node.parent)) || (isLiteralTypeNode(node.parent) && isLiteralImportTypeNode(node.parent.parent) && node.parent.parent.argument == node.parent) {
				return resolveExternalModuleName(node, node, ignoreErrors)
			}
			if isCallExpression(parent) && isBindableObjectDefinePropertyCall(parent) && /* TODO(ElementAccessExpression): parent.arguments[1] */ TODO == node {
				return getSymbolOfDeclaration(parent)
			}
			fallthrough
		case SyntaxKindNumericLiteral:
			objectType := /* TODO(ConditionalExpression): isElementAccessExpression(parent)                     ? parent.argumentExpression === node ? getTypeOfExpression(parent.expression) : undefined                     : isLiteralTypeNode(parent) && isIndexedAccessTypeNode(grandParent)                     ? getTypeFromTypeNode(grandParent.objectType)                     : undefined */ TODO
			return objectType && getPropertyOfType(objectType, escapeLeadingUnderscores((node).text))
		case SyntaxKindDefaultKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindEqualsGreaterThanToken:
			fallthrough // TODO: merge cases
		case SyntaxKindClassKeyword:
			return getSymbolOfNode(node.parent)
		case SyntaxKindImportType:
			return /* TODO(ConditionalExpression): isLiteralImportTypeNode(node) ? getSymbolAtLocation(node.argument.literal, ignoreErrors) : undefined */ TODO
		case SyntaxKindExportKeyword:
			return /* TODO(ConditionalExpression): isExportAssignment(node.parent) ? Debug.checkDefined(node.parent.symbol) : undefined */ TODO
		case SyntaxKindImportKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindNewKeyword:
			return /* TODO(ConditionalExpression): isMetaProperty(node.parent) ? checkMetaPropertyKeyword(node.parent).symbol : undefined */ TODO
		case SyntaxKindInstanceOfKeyword:
			if isBinaryExpression(node.parent) {
				type_ := getTypeOfExpression(node.parent.right)
				hasInstanceMethodType := getSymbolHasInstanceMethodOfObjectType(type_)
				return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): hasInstanceMethodType?.symbol ?? type.symbol */ TODO
			}
			return nil
		case SyntaxKindMetaProperty:
			return checkExpression(node).symbol
		case SyntaxKindJsxNamespacedName:
			if isJSXTagName(node) && isJsxIntrinsicTagName(node) {
				symbol := getIntrinsicTagSymbol(node.parent)
				return /* TODO(ConditionalExpression): symbol === unknownSymbol ? undefined : symbol */ TODO
			}
			fallthrough
		default:
			return nil
		}
	}
	getIndexInfosAtLocation := func(node Node) /* TODO(TypeOperator): readonly IndexInfo[] */ any {
		if isIdentifier(node) && isPropertyAccessExpression(node.parent) && node.parent.name == node {
			keyType := getLiteralTypeFromPropertyName(node)
			objectType := getTypeOfExpression(node.parent.expression)
			objectTypes := /* TODO(ConditionalExpression): objectType.flags & TypeFlags.Union ? (objectType as UnionType).types : [objectType] */ TODO
			return flatMap(objectTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo[] */ TODO {
				return filter(getIndexInfosOfType(t), func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO inferred type boolean */ TODO {
					return isApplicableIndexType(keyType, info.keyType)
				})
			})
		}
		return nil
	}
	getShorthandAssignmentValueSymbol := func(location Node) *Symbol {
		if location && location.kind == SyntaxKindShorthandPropertyAssignment {
			return resolveEntityName((location).name, SymbolFlagsValue|SymbolFlagsAlias)
		}
		return nil
	}
	getExportSpecifierLocalTargetSymbol := func(node /* TODO(UnionType): ExportSpecifier | Identifier */ any) *Symbol {
		if isExportSpecifier(node) {
			name := node.propertyName || node.name
			return /* TODO(ConditionalExpression): node.parent.parent.moduleSpecifier ?                 getExternalModuleMember(node.parent.parent, node) :                 name.kind === SyntaxKind.StringLiteral ? undefined : // Skip for invalid syntax like this: export { "x" }                 resolveEntityName(name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias) */ TODO
		} else {
			return resolveEntityName(node, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias)
		}
	}
	getTypeOfNode := func(node Node) Type {
		if isSourceFile(node) && !isExternalModule(node) {
			return errorType
		}
		if node.flags & NodeFlagsInWithStatement {
			return errorType
		}
		classDecl := tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node)
		classType := classDecl && getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(classDecl.class))
		if isPartOfTypeNode(node) {
			typeFromTypeNode := getTypeFromTypeNode(node)
			return /* TODO(ConditionalExpression): classType ? getTypeWithThisArgument(typeFromTypeNode, classType.thisType) : typeFromTypeNode */ TODO
		}
		if isExpressionNode(node) {
			return getRegularTypeOfExpression(node)
		}
		if classType && !classDecl.isImplements {
			baseType := firstOrUndefined(getBaseTypes(classType))
			return /* TODO(ConditionalExpression): baseType ? getTypeWithThisArgument(baseType, classType.thisType) : errorType */ TODO
		}
		if isTypeDeclaration(node) {
			symbol := getSymbolOfDeclaration(node)
			return getDeclaredTypeOfSymbol(symbol)
		}
		if isTypeDeclarationName(node) {
			symbol := getSymbolAtLocation(node)
			return /* TODO(ConditionalExpression): symbol ? getDeclaredTypeOfSymbol(symbol) : errorType */ TODO
		}
		if isBindingElement(node) {
			return getTypeForVariableLikeDeclaration(node, true, CheckModeNormal) || errorType
		}
		if isDeclaration(node) {
			symbol := getSymbolOfDeclaration(node)
			return /* TODO(ConditionalExpression): symbol ? getTypeOfSymbol(symbol) : errorType */ TODO
		}
		if isDeclarationNameOrImportPropertyName(node) {
			symbol := getSymbolAtLocation(node)
			if symbol {
				return getTypeOfSymbol(symbol)
			}
			return errorType
		}
		if isBindingPattern(node) {
			return getTypeForVariableLikeDeclaration(node.parent, true, CheckModeNormal) || errorType
		}
		if isInRightSideOfImportOrExportAssignment(node) {
			symbol := getSymbolAtLocation(node)
			if symbol {
				declaredType := getDeclaredTypeOfSymbol(symbol)
				return /* TODO(ConditionalExpression): !isErrorType(declaredType) ? declaredType : getTypeOfSymbol(symbol) */ TODO
			}
		}
		if isMetaProperty(node.parent) && node.parent.keywordToken == node.kind {
			return checkMetaPropertyKeyword(node.parent)
		}
		if isImportAttributes(node) {
			return getGlobalImportAttributesType(false)
		}
		return errorType
	}
	getTypeOfAssignmentPattern := func(expr AssignmentPattern) *Type {
		Debug.assert(expr.kind == SyntaxKindObjectLiteralExpression || expr.kind == SyntaxKindArrayLiteralExpression)
		if expr.parent.kind == SyntaxKindForOfStatement {
			iteratedType := checkRightHandSideOfForOf(expr.parent)
			return checkDestructuringAssignment(expr, iteratedType || errorType)
		}
		if expr.parent.kind == SyntaxKindBinaryExpression {
			iteratedType := getTypeOfExpression((expr.parent).right)
			return checkDestructuringAssignment(expr, iteratedType || errorType)
		}
		if expr.parent.kind == SyntaxKindPropertyAssignment {
			node := cast(expr.parent.parent, isObjectLiteralExpression)
			typeOfParentObjectLiteral := getTypeOfAssignmentPattern(node) || errorType
			propertyIndex := indexOfNode(node.properties, expr.parent)
			return checkObjectLiteralDestructuringPropertyAssignment(node, typeOfParentObjectLiteral, propertyIndex)
		}
		node := cast(expr.parent, isArrayLiteralExpression)
		typeOfArrayLiteral := getTypeOfAssignmentPattern(node) || errorType
		elementType := checkIteratedTypeOrElementType(IterationUseDestructuring, typeOfArrayLiteral, undefinedType, expr.parent) || errorType
		return checkArrayLiteralDestructuringElementAssignment(node, typeOfArrayLiteral, node.elements.indexOf(expr), elementType)
	}
	getPropertySymbolOfDestructuringAssignment := func(location Identifier) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		typeOfObjectLiteral := getTypeOfAssignmentPattern(cast(location.parent.parent, isAssignmentPattern))
		return typeOfObjectLiteral && getPropertyOfType(typeOfObjectLiteral, location.escapedText)
	}
	getRegularTypeOfExpression := func(expr Expression) Type {
		if isRightSideOfQualifiedNameOrPropertyAccess(expr) {
			expr = expr.parent
		}
		return getRegularTypeOfLiteralType(getTypeOfExpression(expr))
	}
	getParentTypeOfClassElement := func(node ClassElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		classSymbol := getSymbolOfNode(node.parent)
		return /* TODO(ConditionalExpression): isStatic(node)             ? getTypeOfSymbol(classSymbol)             : getDeclaredTypeOfSymbol(classSymbol) */ TODO
	}
	getClassElementPropertyKeyType := func(element ClassElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		name := element.name
		switch name.kind {
		case SyntaxKindIdentifier:
			return getStringLiteralType(idText(name))
		case SyntaxKindNumericLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindStringLiteral:
			return getStringLiteralType(name.text)
		case SyntaxKindComputedPropertyName:
			nameType := checkComputedPropertyName(name)
			return /* TODO(ConditionalExpression): isTypeAssignableToKind(nameType, TypeFlags.ESSymbolLike) ? nameType : stringType */ TODO
		default:
			return Debug.fail("Unsupported property name.")
		}
	}
	getAugmentedPropertiesOfType := func(type_ Type) []Symbol {
		type_ = getApparentType(type_)
		propsByName := createSymbolTable(getPropertiesOfType(type_))
		functionType := /* TODO(ConditionalExpression): getSignaturesOfType(type, SignatureKind.Call).length ? globalCallableFunctionType :             getSignaturesOfType(type, SignatureKind.Construct).length ? globalNewableFunctionType :             undefined */ TODO
		if functionType {
			forEach(getPropertiesOfType(functionType), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
				if !propsByName.has(p.escapedName) {
					propsByName.set(p.escapedName, p)
				}
			})
		}
		return getNamedMembers(propsByName)
	}
	typeHasCallOrConstructSignatures := func(type_ Type) bool {
		return getSignaturesOfType(type_, SignatureKindCall).length != 0 || getSignaturesOfType(type_, SignatureKindConstruct).length != 0
	}
	getRootSymbols := func(symbol Symbol) []Symbol {
		roots := getImmediateRootSymbols(symbol)
		return /* TODO(ConditionalExpression): roots ? flatMap(roots, getRootSymbols) : [symbol] */ TODO
	}
	getImmediateRootSymbols := func(symbol Symbol) /* TODO(TypeOperator): readonly Symbol[] */ any {
		if getCheckFlags(symbol) & CheckFlagsSynthetic {
			return mapDefined(getSymbolLinks(symbol).containingType.types, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
				return getPropertyOfType(type_, symbol.escapedName)
			})
		} else if symbol.flags & SymbolFlagsTransient {
			TODO_IDENTIFIER := symbol
			return /* TODO(ConditionalExpression): leftSpread ? [leftSpread, rightSpread!]                 : syntheticOrigin ? [syntheticOrigin]                 : singleElementArray(tryGetTarget(symbol)) */ TODO
		}
		return nil
	}
	tryGetTarget := func(symbol Symbol) *Symbol {
		var target *Symbol
		var next *Symbol = symbol
		for /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): next = getSymbolLinks(next).target */ TODO {
			target = next
		}
		return target
	}
	isArgumentsLocalBinding := func(nodeIn Identifier) bool {
		if isGeneratedIdentifier(nodeIn) {
			return false
		}
		node := getParseTreeNode(nodeIn, isIdentifier)
		if !node {
			return false
		}
		parent := node.parent
		if !parent {
			return false
		}
		isPropertyName := (isPropertyAccessExpression(parent) || isPropertyAssignment(parent)) && parent.name == node
		return !isPropertyName && getReferencedValueSymbol(node) == argumentsSymbol
	}
	isNameOfModuleOrEnumDeclaration := func(node Identifier) /* TODO inferred type boolean */ TODO {
		return isModuleOrEnumDeclaration(node.parent) && node == node.parent.name
	}
	getReferencedExportContainer := func(nodeIn Identifier, prefixLocals bool) /* TODO(UnionType): SourceFile | ModuleDeclaration | EnumDeclaration | undefined */ any {
		node := getParseTreeNode(nodeIn, isIdentifier)
		if node {
			symbol := getReferencedValueSymbol(node, isNameOfModuleOrEnumDeclaration(node))
			if symbol {
				if symbol.flags & SymbolFlagsExportValue {
					exportSymbol := getMergedSymbol(symbol.exportSymbol)
					if !prefixLocals && exportSymbol.flags&SymbolFlagsExportHasLocal && !(exportSymbol.flags & SymbolFlagsVariable) {
						return nil
					}
					symbol = exportSymbol
				}
				parentSymbol := getParentOfSymbol(symbol)
				if parentSymbol {
					if parentSymbol.flags&SymbolFlagsValueModule && parentSymbol.valueDeclaration.kind == SyntaxKindSourceFile {
						symbolFile := parentSymbol.valueDeclaration
						referenceFile := getSourceFileOfNode(node)
						symbolIsUmdExport := symbolFile != referenceFile
						return /* TODO(ConditionalExpression): symbolIsUmdExport ? undefined : symbolFile */ TODO
					}
					return findAncestor(node.parent, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(TypePredicate): n is ModuleDeclaration | EnumDeclaration */ any {
						return isModuleOrEnumDeclaration(n) && getSymbolOfDeclaration(n) == parentSymbol
					})
				}
			}
		}
	}
	getReferencedImportDeclaration := func(nodeIn Identifier) Declaration {
		specifier := getIdentifierGeneratedImportReference(nodeIn)
		if specifier {
			return specifier
		}
		node := getParseTreeNode(nodeIn, isIdentifier)
		if node {
			symbol := getReferencedValueOrAliasSymbol(node)
			if isNonLocalAlias(symbol, SymbolFlagsValue) && !getTypeOnlyAliasDeclaration(symbol, SymbolFlagsValue) {
				return getDeclarationOfAliasSymbol(symbol)
			}
		}
		return nil
	}
	isSymbolOfDestructuredElementOfCatchBinding := func(symbol Symbol) /* TODO inferred type boolean | undefined */ TODO {
		return symbol.valueDeclaration && isBindingElement(symbol.valueDeclaration) && walkUpBindingElementsAndPatterns(symbol.valueDeclaration).parent.kind == SyntaxKindCatchClause
	}
	isSymbolOfDeclarationWithCollidingName := func(symbol Symbol) bool {
		if symbol.flags&SymbolFlagsBlockScoped && symbol.valueDeclaration && !isSourceFile(symbol.valueDeclaration) {
			links := getSymbolLinks(symbol)
			if links.isDeclarationWithCollidingName == nil {
				container := getEnclosingBlockScopeContainer(symbol.valueDeclaration)
				if isStatementWithLocals(container) || isSymbolOfDestructuredElementOfCatchBinding(symbol) {
					if resolveName(container.parent, symbol.escapedName, SymbolFlagsValue, nil, false) {
						links.isDeclarationWithCollidingName = true
					} else if hasNodeCheckFlag(symbol.valueDeclaration, NodeCheckFlagsCapturedBlockScopedBinding) {
						isDeclaredInLoop := hasNodeCheckFlag(symbol.valueDeclaration, NodeCheckFlagsBlockScopedBindingInLoop)
						inLoopInitializer := isIterationStatement(container, false)
						inLoopBodyBlock := container.kind == SyntaxKindBlock && isIterationStatement(container.parent, false)
						links.isDeclarationWithCollidingName = !isBlockScopedContainerTopLevel(container) && (!isDeclaredInLoop || (!inLoopInitializer && !inLoopBodyBlock))
					} else {
						links.isDeclarationWithCollidingName = false
					}
				}
			}
			return links.isDeclarationWithCollidingName
		}
		return false
	}
	getReferencedDeclarationWithCollidingName := func(nodeIn Identifier) Declaration {
		if !isGeneratedIdentifier(nodeIn) {
			node := getParseTreeNode(nodeIn, isIdentifier)
			if node {
				symbol := getReferencedValueSymbol(node)
				if symbol && isSymbolOfDeclarationWithCollidingName(symbol) {
					return symbol.valueDeclaration
				}
			}
		}
		return nil
	}
	isDeclarationWithCollidingName := func(nodeIn Declaration) bool {
		node := getParseTreeNode(nodeIn, isDeclaration)
		if node {
			symbol := getSymbolOfDeclaration(node)
			if symbol {
				return isSymbolOfDeclarationWithCollidingName(symbol)
			}
		}
		return false
	}
	isValueAliasDeclaration := func(node Node) bool {
		Debug.assert(canCollectSymbolAliasAccessabilityData)
		switch node.kind {
		case SyntaxKindImportEqualsDeclaration:
			return isAliasResolvedToValue(getSymbolOfDeclaration(node))
		case SyntaxKindImportClause:
			fallthrough // TODO: merge cases
		case SyntaxKindNamespaceImport:
			fallthrough // TODO: merge cases
		case SyntaxKindImportSpecifier:
			fallthrough // TODO: merge cases
		case SyntaxKindExportSpecifier:
			symbol := getSymbolOfDeclaration(node)
			return !!symbol && isAliasResolvedToValue(symbol, true)
		case SyntaxKindExportDeclaration:
			exportClause := (node).exportClause
			return !!exportClause && (isNamespaceExport(exportClause) || some(exportClause.elements, isValueAliasDeclaration))
		case SyntaxKindExportAssignment:
			return /* TODO(ConditionalExpression): (node as ExportAssignment).expression && (node as ExportAssignment).expression.kind === SyntaxKind.Identifier ?                     isAliasResolvedToValue(getSymbolOfDeclaration(node as ExportAssignment), /*excludeTypeOnlyValues* / true) :                     true */ TODO
		}
		return false
	}
	isTopLevelValueImportEqualsWithEntityName := func(nodeIn ImportEqualsDeclaration) bool {
		node := getParseTreeNode(nodeIn, isImportEqualsDeclaration)
		if node == nil || node.parent.kind != SyntaxKindSourceFile || !isInternalModuleImportEqualsDeclaration(node) {
			return false
		}
		isValue := isAliasResolvedToValue(getSymbolOfDeclaration(node))
		return isValue && node.moduleReference && !nodeIsMissing(node.moduleReference)
	}
	isAliasResolvedToValue := func(symbol *Symbol, excludeTypeOnlyValues bool) bool {
		if !symbol {
			return false
		}
		container := getSourceFileOfNode(symbol.valueDeclaration)
		fileSymbol := container && getSymbolOfDeclaration(container)
		/* TODO(ExpressionStatement): void resolveExternalModuleSymbol(fileSymbol); */
		target := getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol))
		if target == unknownSymbol {
			return !excludeTypeOnlyValues || !getTypeOnlyAliasDeclaration(symbol)
		}
		return !!(getSymbolFlags(symbol, excludeTypeOnlyValues, true) & SymbolFlagsValue) && (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target))
	}
	isConstEnumOrConstEnumOnlyModule := func(s Symbol) bool {
		return isConstEnumSymbol(s) || !!s.constEnumOnlyModule
	}
	isReferencedAliasDeclaration := func(node Node, checkChildren bool) bool {
		Debug.assert(canCollectSymbolAliasAccessabilityData)
		if isAliasSymbolDeclaration(node) {
			symbol := getSymbolOfDeclaration(node)
			links := symbol && getSymbolLinks(symbol)
			if links.referenced {
				return true
			}
			target := getSymbolLinks(symbol).aliasTarget
			if target && getEffectiveModifierFlags(node)&ModifierFlagsExport && getSymbolFlags(target)&SymbolFlagsValue && (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target)) {
				return true
			}
		}
		if checkChildren {
			return !!forEachChild(node, func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO inferred type boolean */ TODO {
				return isReferencedAliasDeclaration(node, checkChildren)
			})
		}
		return false
	}
	isImplementationOfOverload := func(node SignatureDeclaration) /* TODO inferred type boolean */ TODO {
		if nodeIsPresent((node).body) {
			if isGetAccessor(node) || isSetAccessor(node) {
				return false
			}
			symbol := getSymbolOfDeclaration(node)
			signaturesOfSymbol := getSignaturesOfSymbol(symbol)
			return signaturesOfSymbol.length > 1 || (signaturesOfSymbol.length == 1 && /* TODO(ElementAccessExpression): signaturesOfSymbol[0] */ TODO.declaration != node)
		}
		return false
	}
	declaredParameterTypeContainsUndefined := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any) /* TODO inferred type boolean */ TODO {
		typeNode := getNonlocalEffectiveTypeAnnotationNode(parameter)
		if !typeNode {
			return false
		}
		type_ := getTypeFromTypeNode(typeNode)
		return containsUndefinedType(type_)
	}
	requiresAddingImplicitUndefined := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) /* TODO inferred type boolean */ TODO {
		return (isRequiredInitializedParameter(parameter, enclosingDeclaration) || isOptionalUninitializedParameterProperty(parameter)) && !declaredParameterTypeContainsUndefined(parameter)
	}
	isRequiredInitializedParameter := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) bool {
		if !strictNullChecks || isOptionalParameter(parameter) || isJSDocParameterTag(parameter) || !parameter.initializer {
			return false
		}
		if hasSyntacticModifier(parameter, ModifierFlagsParameterPropertyModifier) {
			return !!enclosingDeclaration && isFunctionLikeDeclaration(enclosingDeclaration)
		}
		return true
	}
	isOptionalUninitializedParameterProperty := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any) /* TODO inferred type boolean */ TODO {
		return strictNullChecks && isOptionalParameter(parameter) && (isJSDocParameterTag(parameter) || !parameter.initializer) && hasSyntacticModifier(parameter, ModifierFlagsParameterPropertyModifier)
	}
	isExpandoFunctionDeclaration := func(node Declaration) bool {
		declaration := getParseTreeNode(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(TypePredicate): n is FunctionDeclaration | VariableDeclaration */ any {
			return isFunctionDeclaration(n) || isVariableDeclaration(n)
		})
		if !declaration {
			return false
		}
		var symbol *Symbol
		if isVariableDeclaration(declaration) {
			if declaration.type_ || (!isInJSFile(declaration) && !isVarConstLike(declaration)) {
				return false
			}
			initializer := getDeclaredExpandoInitializer(declaration)
			if !initializer || !canHaveSymbol(initializer) {
				return false
			}
			symbol = getSymbolOfDeclaration(initializer)
		} else {
			symbol = getSymbolOfDeclaration(declaration)
		}
		if !symbol || !(symbol.flags&SymbolFlagsFunction | SymbolFlagsVariable) {
			return false
		}
		return !!forEachEntry(getExportsOfSymbol(symbol), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type boolean | 0 */ TODO {
			return p.flags&SymbolFlagsValue && isExpandoPropertyDeclaration(p.valueDeclaration)
		})
	}
	getPropertiesOfContainerFunction := func(node Declaration) []Symbol {
		declaration := getParseTreeNode(node, isFunctionDeclaration)
		if !declaration {
			return emptyArray
		}
		symbol := getSymbolOfDeclaration(declaration)
		return symbol && getPropertiesOfType(getTypeOfSymbol(symbol)) || emptyArray
	}
	getNodeCheckFlags := func(node Node) NodeCheckFlags {
		nodeId := node.id || 0
		if nodeId < 0 || nodeId >= nodeLinks.length {
			return 0
		}
		return /* TODO(ElementAccessExpression): nodeLinks[nodeId] */ TODO.flags || 0
	}
	hasNodeCheckFlag := func(node Node, flag LazyNodeCheckFlags) /* TODO inferred type boolean */ TODO {
		calculateNodeCheckFlagWorker(node, flag)
		return !!(getNodeCheckFlags(node) & flag)
	}
	calculateNodeCheckFlagWorker := func(node Node, flag LazyNodeCheckFlags) {
		if !compilerOptions.noCheck && canIncludeBindAndCheckDiagnostics(getSourceFileOfNode(node), compilerOptions) {
			return
		}
		links := getNodeLinks(node)
		if links.calculatedFlags & flag {
			return
		}
		switch flag {
		case NodeCheckFlagsSuperInstance:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsSuperStatic:
			return checkSingleSuperExpression(node)
		case NodeCheckFlagsMethodWithSuperPropertyAccessInAsync:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsContainsSuperPropertyInStaticInitializer:
			return checkChildSuperExpressions(node)
		case NodeCheckFlagsCaptureArguments:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsContainsCapturedBlockScopeBinding:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsNeedsLoopOutParameter:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsContainsConstructorReference:
			return checkChildIdentifiers(node)
		case NodeCheckFlagsConstructorReference:
			return checkSingleIdentifier(node)
		case NodeCheckFlagsLoopWithCapturedBlockScopedBinding:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsBlockScopedBindingInLoop:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsCapturedBlockScopedBinding:
			return checkContainingBlockScopeBindingUses(node)
		default:
			return Debug.assertNever(flag /* TODO(TemplateExpression): `Unhandled node check flag calculation: ${Debug.formatNodeCheckFlags(flag)}` */, TODO)
		}
		forEachNodeRecursively := func(root Node, cb func(node Node, parent Node) /* TODO(UnionType): T | "skip" | undefined */ any) *T {
			rootResult := cb(root, root.parent)
			if rootResult == "skip" {
				return nil
			}
			if rootResult {
				return rootResult
			}
			return forEachChildRecursively(root, cb)
		}
		checkSuperExpressions := func(node Node) /* TODO inferred type "skip" | undefined */ TODO {
			links := getNodeLinks(node)
			if links.calculatedFlags & flag {
				return "skip"
			}
			links.calculatedFlags |= NodeCheckFlagsMethodWithSuperPropertyAccessInAsync | NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync | NodeCheckFlagsContainsSuperPropertyInStaticInitializer
			checkSingleSuperExpression(node)
			return nil
		}
		checkChildSuperExpressions := func(node Node) {
			forEachNodeRecursively(node, checkSuperExpressions)
		}
		checkSingleSuperExpression := func(node Node) {
			nodeLinks := getNodeLinks(node)
			nodeLinks.calculatedFlags |= NodeCheckFlagsSuperInstance | NodeCheckFlagsSuperStatic
			if node.kind == SyntaxKindSuperKeyword {
				checkSuperExpression(node)
			}
		}
		checkIdentifiers := func(node Node) /* TODO inferred type "skip" | undefined */ TODO {
			links := getNodeLinks(node)
			if links.calculatedFlags & flag {
				return "skip"
			}
			links.calculatedFlags |= NodeCheckFlagsCaptureArguments | NodeCheckFlagsContainsCapturedBlockScopeBinding | NodeCheckFlagsNeedsLoopOutParameter | NodeCheckFlagsContainsConstructorReference
			checkSingleIdentifier(node)
			return nil
		}
		checkChildIdentifiers := func(node Node) {
			forEachNodeRecursively(node, checkIdentifiers)
		}
		isExpressionNodeOrShorthandPropertyAssignmentName := func(node Identifier) /* TODO inferred type boolean */ TODO {
			return isExpressionNode(node) || isShorthandPropertyAssignment(node.parent) && ( /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): node.parent.objectAssignmentInitializer ?? node.parent.name */ TODO) == node
		}
		checkSingleIdentifier := func(node Node) {
			nodeLinks := getNodeLinks(node)
			nodeLinks.calculatedFlags |= NodeCheckFlagsConstructorReference
			if isIdentifier(node) {
				nodeLinks.calculatedFlags |= NodeCheckFlagsBlockScopedBindingInLoop | NodeCheckFlagsCapturedBlockScopedBinding
				if isExpressionNodeOrShorthandPropertyAssignmentName(node) && !(isPropertyAccessExpression(node.parent) && node.parent.name == node) {
					s := getResolvedSymbol(node)
					if s && s != unknownSymbol {
						checkIdentifierCalculateNodeCheckFlags(node, s)
					}
				}
			}
		}
		checkBlockScopeBindings := func(node Node) /* TODO inferred type "skip" | undefined */ TODO {
			links := getNodeLinks(node)
			if links.calculatedFlags & flag {
				return "skip"
			}
			links.calculatedFlags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding | NodeCheckFlagsBlockScopedBindingInLoop | NodeCheckFlagsCapturedBlockScopedBinding
			checkSingleBlockScopeBinding(node)
			return nil
		}
		checkContainingBlockScopeBindingUses := func(node Node) {
			scope := getEnclosingBlockScopeContainer( /* TODO(ConditionalExpression): isDeclarationName(node) ? node.parent : node */ TODO)
			forEachNodeRecursively(scope, checkBlockScopeBindings)
		}
		checkSingleBlockScopeBinding := func(node Node) {
			checkSingleIdentifier(node)
			if isComputedPropertyName(node) {
				checkComputedPropertyName(node)
			}
			if isPrivateIdentifier(node) && isClassElement(node.parent) {
				setNodeLinksForPrivateIdentifierScope(node.parent)
			}
		}
	}
	getEnumMemberValue := func(node EnumMember) EvaluatorResult {
		computeEnumMemberValues(node.parent)
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getNodeLinks(node).enumMemberValue ?? evaluatorResult(/*value* / undefined) */ TODO
	}
	canHaveConstantValue := func(node Node) /* TODO(TypePredicate): node is EnumMember | AccessExpression */ any {
		switch node.kind {
		case SyntaxKindEnumMember:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindElementAccessExpression:
			return true
		}
		return false
	}
	getConstantValue := func(node /* TODO(UnionType): EnumMember | AccessExpression */ any) /* TODO(UnionType): string | number | undefined */ any {
		if node.kind == SyntaxKindEnumMember {
			return getEnumMemberValue(node).value
		}
		if !getNodeLinks(node).resolvedSymbol {
			/* TODO(ExpressionStatement): void checkExpressionCached(node); */
		}
		symbol := getNodeLinks(node).resolvedSymbol || ( /* TODO(ConditionalExpression): isEntityNameExpression(node) ? resolveEntityName(node, SymbolFlags.Value, /*ignoreErrors* / true) : undefined */ TODO)
		if symbol && (symbol.flags & SymbolFlagsEnumMember) {
			member := symbol.valueDeclaration
			if isEnumConst(member.parent) {
				return getEnumMemberValue(member).value
			}
		}
		return nil
	}
	isFunctionType := func(type_ Type) bool {
		return !!(type_.flags & TypeFlagsObject) && getSignaturesOfType(type_, SignatureKindCall).length > 0
	}
	getTypeReferenceSerializationKind := func(typeNameIn EntityName, location Node) TypeReferenceSerializationKind {
		typeName := getParseTreeNode(typeNameIn, isEntityName)
		if !typeName {
			return TypeReferenceSerializationKindUnknown
		}
		if location {
			location = getParseTreeNode(location)
			if !location {
				return TypeReferenceSerializationKindUnknown
			}
		}
		isTypeOnly := false
		if isQualifiedName(typeName) {
			rootValueSymbol := resolveEntityName(getFirstIdentifier(typeName), SymbolFlagsValue, true, true, location)
			isTypeOnly = !!rootValueSymbol.declarations.every(isTypeOnlyImportOrExportDeclaration)
		}
		valueSymbol := resolveEntityName(typeName, SymbolFlagsValue, true, true, location)
		resolvedValueSymbol := /* TODO(ConditionalExpression): valueSymbol && valueSymbol.flags & SymbolFlags.Alias ? resolveAlias(valueSymbol) : valueSymbol */ TODO
		/* TODO(ExpressionStatement): isTypeOnly ||= !!(valueSymbol && getTypeOnlyAliasDeclaration(valueSymbol, SymbolFlags.Value)); */
		typeSymbol := resolveEntityName(typeName, SymbolFlagsType, true, true, location)
		resolvedTypeSymbol := /* TODO(ConditionalExpression): typeSymbol && typeSymbol.flags & SymbolFlags.Alias ? resolveAlias(typeSymbol) : typeSymbol */ TODO
		if !valueSymbol {
			/* TODO(ExpressionStatement): isTypeOnly ||= !!(typeSymbol && getTypeOnlyAliasDeclaration(typeSymbol, SymbolFlags.Type)); */
		}
		if resolvedValueSymbol && resolvedValueSymbol == resolvedTypeSymbol {
			globalPromiseSymbol := getGlobalPromiseConstructorSymbol(false)
			if globalPromiseSymbol && resolvedValueSymbol == globalPromiseSymbol {
				return TypeReferenceSerializationKindPromise
			}
			constructorType := getTypeOfSymbol(resolvedValueSymbol)
			if constructorType && isConstructorType(constructorType) {
				return /* TODO(ConditionalExpression): isTypeOnly ? TypeReferenceSerializationKind.TypeWithCallSignature : TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue */ TODO
			}
		}
		if !resolvedTypeSymbol {
			return /* TODO(ConditionalExpression): isTypeOnly ? TypeReferenceSerializationKind.ObjectType : TypeReferenceSerializationKind.Unknown */ TODO
		}
		type_ := getDeclaredTypeOfSymbol(resolvedTypeSymbol)
		if isErrorType(type_) {
			return /* TODO(ConditionalExpression): isTypeOnly ? TypeReferenceSerializationKind.ObjectType : TypeReferenceSerializationKind.Unknown */ TODO
		} else if type_.flags & TypeFlagsAnyOrUnknown {
			return TypeReferenceSerializationKindObjectType
		} else if isTypeAssignableToKind(type_, TypeFlagsVoid|TypeFlagsNullable|TypeFlagsNever) {
			return TypeReferenceSerializationKindVoidNullableOrNeverType
		} else if isTypeAssignableToKind(type_, TypeFlagsBooleanLike) {
			return TypeReferenceSerializationKindBooleanType
		} else if isTypeAssignableToKind(type_, TypeFlagsNumberLike) {
			return TypeReferenceSerializationKindNumberLikeType
		} else if isTypeAssignableToKind(type_, TypeFlagsBigIntLike) {
			return TypeReferenceSerializationKindBigIntLikeType
		} else if isTypeAssignableToKind(type_, TypeFlagsStringLike) {
			return TypeReferenceSerializationKindStringLikeType
		} else if isTupleType(type_) {
			return TypeReferenceSerializationKindArrayLikeType
		} else if isTypeAssignableToKind(type_, TypeFlagsESSymbolLike) {
			return TypeReferenceSerializationKindESSymbolType
		} else if isFunctionType(type_) {
			return TypeReferenceSerializationKindTypeWithCallSignature
		} else if isArrayType(type_) {
			return TypeReferenceSerializationKindArrayLikeType
		} else {
			return TypeReferenceSerializationKindObjectType
		}
	}
	createTypeOfDeclaration := func(declarationIn /* TODO(UnionType): AccessorDeclaration | VariableLikeDeclaration | PropertyAccessExpression */ any, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		declaration := getParseTreeNode(declarationIn, isVariableLikeOrAccessor)
		if !declaration {
			return factory.createToken(SyntaxKindAnyKeyword)
		}
		symbol := getSymbolOfDeclaration(declaration)
		type_ := /* TODO(ConditionalExpression): symbol && !(symbol.flags & (SymbolFlags.TypeLiteral | SymbolFlags.Signature))             ? getWidenedLiteralType(getTypeOfSymbol(symbol))             : errorType */ TODO
		return nodeBuilder.serializeTypeForDeclaration(declaration, type_, symbol, enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
	}
	type DeclarationWithPotentialInnerNodeReuse /* TODO(UnionType): | SignatureDeclaration         | JSDocSignature         | AccessorDeclaration         | VariableLikeDeclaration         | PropertyAccessExpression         | ExportAssignment */ any
	isDeclarationWithPossibleInnerTypeNodeReuse := func(declaration Declaration) /* TODO(TypePredicate): declaration is DeclarationWithPotentialInnerNodeReuse */ any {
		return isFunctionLike(declaration) || isExportAssignment(declaration) || isVariableLike(declaration)
	}
	getAllAccessorDeclarationsForDeclaration := func(accessor AccessorDeclaration) AllAccessorDeclarations {
		accessor = getParseTreeNode(accessor, isGetOrSetAccessorDeclaration)
		otherKind := /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.SetAccessor ? SyntaxKind.GetAccessor : SyntaxKind.SetAccessor */ TODO
		otherAccessor := getDeclarationOfKind(getSymbolOfDeclaration(accessor), otherKind)
		firstAccessor := /* TODO(ConditionalExpression): otherAccessor && (otherAccessor.pos < accessor.pos) ? otherAccessor : accessor */ TODO
		secondAccessor := /* TODO(ConditionalExpression): otherAccessor && (otherAccessor.pos < accessor.pos) ? accessor : otherAccessor */ TODO
		setAccessor := /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.SetAccessor ? accessor : otherAccessor as SetAccessorDeclaration */ TODO
		getAccessor := /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ? accessor : otherAccessor as GetAccessorDeclaration */ TODO
		return /* TODO(ObjectLiteralExpression): {             firstAccessor,             secondAccessor,             setAccessor,             getAccessor,         } */ TODO
	}
	getPossibleTypeNodeReuseExpression := func(declaration DeclarationWithPotentialInnerNodeReuse) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ TODO {
		return /* TODO(ConditionalExpression): isFunctionLike(declaration) && !isSetAccessor(declaration)             ? getSingleReturnExpression(declaration)             : isExportAssignment(declaration)             ? declaration.expression             : !!(declaration as HasInitializer).initializer             ? (declaration as HasInitializer & typeof declaration).initializer             : isParameter(declaration) && isSetAccessor(declaration.parent)             ? getSingleReturnExpression(getAllAccessorDeclarationsForDeclaration(declaration.parent).getAccessor)             : undefined */ TODO
	}
	getSingleReturnExpression := func(declaration *SignatureDeclaration) *Expression {
		var candidateExpr *Expression
		if declaration && !nodeIsMissing((declaration).body) {
			if getFunctionFlags(declaration) & FunctionFlagsAsyncGenerator {
				return nil
			}
			body := (declaration).body
			if body && isBlock(body) {
				forEachReturnStatement(body, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ReturnStatement */ TODO) /* TODO inferred type true | undefined */ TODO {
					if !candidateExpr {
						candidateExpr = s.expression
					} else {
						candidateExpr = nil
						return true
					}
				})
			} else {
				candidateExpr = body
			}
		}
		return candidateExpr
	}
	createReturnTypeOfSignatureDeclaration := func(signatureDeclarationIn SignatureDeclaration, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		signatureDeclaration := getParseTreeNode(signatureDeclarationIn, isFunctionLike)
		if !signatureDeclaration {
			return factory.createToken(SyntaxKindAnyKeyword)
		}
		return nodeBuilder.serializeReturnTypeForSignature(getSignatureFromDeclaration(signatureDeclaration), enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
	}
	createTypeOfExpression := func(exprIn Expression, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		expr := getParseTreeNode(exprIn, isExpression)
		if !expr {
			return factory.createToken(SyntaxKindAnyKeyword)
		}
		type_ := getWidenedType(getRegularTypeOfExpression(expr))
		return nodeBuilder.expressionOrTypeToTypeNode(expr, type_, nil, enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
	}
	hasGlobalName := func(name string) bool {
		return globals.has(escapeLeadingUnderscores(name))
	}
	getReferencedValueSymbol := func(reference Identifier, startInDeclarationContainer bool) *Symbol {
		resolvedSymbol := getNodeLinks(reference).resolvedSymbol
		if resolvedSymbol {
			return resolvedSymbol
		}
		var location Node = reference
		if startInDeclarationContainer {
			parent := reference.parent
			if isDeclaration(parent) && reference == parent.name {
				location = getDeclarationContainer(parent)
			}
		}
		return resolveName(location, reference.escapedText, SymbolFlagsValue|SymbolFlagsExportValue|SymbolFlagsAlias, nil, true)
	}
	getReferencedValueOrAliasSymbol := func(reference Identifier) *Symbol {
		resolvedSymbol := getNodeLinks(reference).resolvedSymbol
		if resolvedSymbol && resolvedSymbol != unknownSymbol {
			return resolvedSymbol
		}
		return resolveName(reference, reference.escapedText, SymbolFlagsValue|SymbolFlagsExportValue|SymbolFlagsAlias, nil, true, nil)
	}
	getReferencedValueDeclaration := func(referenceIn Identifier) Declaration {
		if !isGeneratedIdentifier(referenceIn) {
			reference := getParseTreeNode(referenceIn, isIdentifier)
			if reference {
				symbol := getReferencedValueSymbol(reference)
				if symbol {
					return getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration
				}
			}
		}
		return nil
	}
	getReferencedValueDeclarations := func(referenceIn Identifier) /* TODO(ArrayType): Declaration[] */ any {
		if !isGeneratedIdentifier(referenceIn) {
			reference := getParseTreeNode(referenceIn, isIdentifier)
			if reference {
				symbol := getReferencedValueSymbol(reference)
				if symbol {
					return filter(getExportSymbolOfValueSymbolIfExported(symbol).declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO inferred type boolean */ TODO {
						switch declaration.kind {
						case SyntaxKindVariableDeclaration:
							fallthrough // TODO: merge cases
						case SyntaxKindParameter:
							fallthrough // TODO: merge cases
						case SyntaxKindBindingElement:
							fallthrough // TODO: merge cases
						case SyntaxKindPropertyDeclaration:
							fallthrough // TODO: merge cases
						case SyntaxKindPropertyAssignment:
							fallthrough // TODO: merge cases
						case SyntaxKindShorthandPropertyAssignment:
							fallthrough // TODO: merge cases
						case SyntaxKindEnumMember:
							fallthrough // TODO: merge cases
						case SyntaxKindObjectLiteralExpression:
							fallthrough // TODO: merge cases
						case SyntaxKindFunctionDeclaration:
							fallthrough // TODO: merge cases
						case SyntaxKindFunctionExpression:
							fallthrough // TODO: merge cases
						case SyntaxKindArrowFunction:
							fallthrough // TODO: merge cases
						case SyntaxKindClassDeclaration:
							fallthrough // TODO: merge cases
						case SyntaxKindClassExpression:
							fallthrough // TODO: merge cases
						case SyntaxKindEnumDeclaration:
							fallthrough // TODO: merge cases
						case SyntaxKindMethodDeclaration:
							fallthrough // TODO: merge cases
						case SyntaxKindGetAccessor:
							fallthrough // TODO: merge cases
						case SyntaxKindSetAccessor:
							fallthrough // TODO: merge cases
						case SyntaxKindModuleDeclaration:
							return true
						}
						return false
					})
				}
			}
		}
		return nil
	}
	isLiteralConstDeclaration := func(node /* TODO(UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any) bool {
		if isDeclarationReadonly(node) || isVariableDeclaration(node) && isVarConstLike(node) {
			return isFreshLiteralType(getTypeOfSymbol(getSymbolOfDeclaration(node)))
		}
		return false
	}
	literalTypeToNode := func(type_ FreshableType, enclosing Node, tracker SymbolTracker) Expression {
		enumResult := /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike ? nodeBuilder.symbolToExpression(type.symbol, SymbolFlags.Value, enclosing, /*flags* / undefined, /*internalFlags* / undefined, tracker)             : type === trueType ? factory.createTrue() : type === falseType && factory.createFalse() */ TODO
		if enumResult {
			return enumResult
		}
		literalValue := (type_).value
		return /* TODO(ConditionalExpression): typeof literalValue === "object" ? factory.createBigIntLiteral(literalValue) :             typeof literalValue === "string" ? factory.createStringLiteral(literalValue) :             literalValue < 0 ? factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createNumericLiteral(-literalValue)) :             factory.createNumericLiteral(literalValue) */ TODO
	}
	createLiteralConstValue := func(node /* TODO(UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any, tracker SymbolTracker) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ TODO {
		type_ := getTypeOfSymbol(getSymbolOfDeclaration(node))
		return literalTypeToNode(type_, node, tracker)
	}
	getJsxFactoryEntity := func(location Node) *EntityName {
		return /* TODO(ConditionalExpression): location ? (getJsxNamespace(location), (getSourceFileOfNode(location).localJsxFactory || _jsxFactoryEntity)) : _jsxFactoryEntity */ TODO
	}
	getJsxFragmentFactoryEntity := func(location Node) *EntityName {
		if location {
			file := getSourceFileOfNode(location)
			if file {
				if file.localJsxFragmentFactory {
					return file.localJsxFragmentFactory
				}
				jsxFragPragmas := file.pragmas.get("jsxfrag")
				jsxFragPragma := /* TODO(ConditionalExpression): isArray(jsxFragPragmas) ? jsxFragPragmas[0] : jsxFragPragmas */ TODO
				if jsxFragPragma {
					file.localJsxFragmentFactory = parseIsolatedEntityName(jsxFragPragma.arguments.factory, languageVersion)
					return file.localJsxFragmentFactory
				}
			}
		}
		if compilerOptions.jsxFragmentFactory {
			return parseIsolatedEntityName(compilerOptions.jsxFragmentFactory, languageVersion)
		}
	}
	getNonlocalEffectiveTypeAnnotationNode := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		direct := getEffectiveTypeAnnotationNode(node)
		if direct {
			return direct
		}
		if node.kind == SyntaxKindParameter && node.parent.kind == SyntaxKindSetAccessor {
			other := getAllAccessorDeclarationsForDeclaration(node.parent).getAccessor
			if other {
				return getEffectiveReturnTypeNode(other)
			}
		}
		return nil
	}
	getNonlocalEffectiveReturnTypeAnnotationNode := func(node /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		direct := getEffectiveReturnTypeNode(node)
		if direct {
			return direct
		}
		if node.kind == SyntaxKindGetAccessor {
			other := getAllAccessorDeclarationsForDeclaration(node).setAccessor
			if other {
				param := getSetAccessorValueParameter(other)
				if param {
					return getEffectiveTypeAnnotationNode(param)
				}
			}
		}
		return nil
	}
	createResolver := func() EmitResolver {
		return /* TODO(ObjectLiteralExpression): {             getReferencedExportContainer,             getReferencedImportDeclaration,             getReferencedDeclarationWithCollidingName,             isDeclarationWithCollidingName,             isValueAliasDeclaration: nodeIn => {                 const node = getParseTreeNode(nodeIn);                 // Synthesized nodes are always treated like values.                 return node && canCollectSymbolAliasAccessabilityData ? isValueAliasDeclaration(node) : true;             },             hasGlobalName,             isReferencedAliasDeclaration: (nodeIn, checkChildren?) => {                 const node = getParseTreeNode(nodeIn);                 // Synthesized nodes are always treated as referenced.                 return node && canCollectSymbolAliasAccessabilityData ? isReferencedAliasDeclaration(node, checkChildren) : true;             },             hasNodeCheckFlag: (nodeIn, flag) => {                 const node = getParseTreeNode(nodeIn);                 if (!node) return false;                 return hasNodeCheckFlag(node, flag);             },             isTopLevelValueImportEqualsWithEntityName,             isDeclarationVisible,             isImplementationOfOverload,             requiresAddingImplicitUndefined,             isExpandoFunctionDeclaration,             getPropertiesOfContainerFunction,             createTypeOfDeclaration,             createReturnTypeOfSignatureDeclaration,             createTypeOfExpression,             createLiteralConstValue,             isSymbolAccessible,             isEntityNameVisible,             getConstantValue: nodeIn => {                 const node = getParseTreeNode(nodeIn, canHaveConstantValue);                 return node ? getConstantValue(node) : undefined;             },             getEnumMemberValue: nodeIn => {                 const node = getParseTreeNode(nodeIn, isEnumMember);                 return node ? getEnumMemberValue(node) : undefined;             },             collectLinkedAliases,             markLinkedReferences: nodeIn => {                 const node = getParseTreeNode(nodeIn);                 return node && markLinkedReferences(node, ReferenceHint.Unspecified);             },             getReferencedValueDeclaration,             getReferencedValueDeclarations,             getTypeReferenceSerializationKind,             isOptionalParameter,             isArgumentsLocalBinding,             getExternalModuleFileFromDeclaration: nodeIn => {                 const node = getParseTreeNode(nodeIn, hasPossibleExternalModuleReference);                 return node && getExternalModuleFileFromDeclaration(node);             },             isLiteralConstDeclaration,             isLateBound: (nodeIn: Declaration): nodeIn is LateBoundDeclaration => {                 const node = getParseTreeNode(nodeIn, isDeclaration);                 const symbol = node && getSymbolOfDeclaration(node);                 return !!(symbol && getCheckFlags(symbol) & CheckFlags.Late);             },             getJsxFactoryEntity,             getJsxFragmentFactoryEntity,             isBindingCapturedByNode: (node, decl) => {                 const parseNode = getParseTreeNode(node);                 const parseDecl = getParseTreeNode(decl);                 return !!parseNode && !!parseDecl && (isVariableDeclaration(parseDecl) || isBindingElement(parseDecl)) && isBindingCapturedByNode(parseNode, parseDecl);             },             getDeclarationStatementsForSourceFile: (node, flags, internalFlags, tracker) => {                 const n = getParseTreeNode(node) as SourceFile;                 Debug.assert(n && n.kind === SyntaxKind.SourceFile, "Non-sourcefile node passed into getDeclarationsForSourceFile");                 const sym = getSymbolOfDeclaration(node);                 if (!sym) {                     return !node.locals ? [] : nodeBuilder.symbolTableToDeclarationStatements(node.locals, node, flags, internalFlags, tracker);                 }                 resolveExternalModuleSymbol(sym); // ensures cjs export assignment is setup                 return !sym.exports ? [] : nodeBuilder.symbolTableToDeclarationStatements(sym.exports, node, flags, internalFlags, tracker);             },             isImportRequiredByAugmentation,             isDefinitelyReferenceToGlobalSymbolObject,         } */ TODO
		isImportRequiredByAugmentation := func(node ImportDeclaration) /* TODO inferred type boolean */ TODO {
			file := getSourceFileOfNode(node)
			if !file.symbol {
				return false
			}
			importTarget := getExternalModuleFileFromDeclaration(node)
			if !importTarget {
				return false
			}
			if importTarget == file {
				return false
			}
			exports := getExportsOfModule(file.symbol)
			for _, s := range arrayFrom(exports.values()) {
				if s.mergeId {
					merged := getMergedSymbol(s)
					if merged.declarations {
						for _, d := range merged.declarations {
							declFile := getSourceFileOfNode(d)
							if declFile == importTarget {
								return true
							}
						}
					}
				}
			}
			return false
		}
	}
	getExternalModuleFileFromDeclaration := func(declaration /* TODO(UnionType): AnyImportOrReExport | ModuleDeclaration | ImportTypeNode | ImportCall */ any) *SourceFile {
		specifier := /* TODO(ConditionalExpression): declaration.kind === SyntaxKind.ModuleDeclaration ? tryCast(declaration.name, isStringLiteral) : getExternalModuleName(declaration) */ TODO
		moduleSymbol := resolveExternalModuleNameWorker(specifier, specifier, nil)
		if !moduleSymbol {
			return nil
		}
		return getDeclarationOfKind(moduleSymbol, SyntaxKindSourceFile)
	}
	initializeTypeChecker := func() {
		for _, file := range host.getSourceFiles() {
			bindSourceFile(file, compilerOptions)
		}
		amalgamatedDuplicates = /* TODO(NewExpression): new Map() */ make(map[any]any)
		var augmentations /* TODO(ArrayType): (readonly (StringLiteral | Identifier)[])[] */ any
		for _, file := range host.getSourceFiles() {
			if file.redirectInfo {
				continue
			}
			if !isExternalOrCommonJsModule(file) {
				fileGlobalThisSymbol := file.locals.get("globalThis")
				if fileGlobalThisSymbol.declarations {
					for _, declaration := range fileGlobalThisSymbol.declarations {
						diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, "globalThis"))
					}
				}
				mergeSymbolTable(globals, file.locals)
			}
			if file.jsGlobalAugmentations {
				mergeSymbolTable(globals, file.jsGlobalAugmentations)
			}
			if file.patternAmbientModules && file.patternAmbientModules.length {
				patternAmbientModules = concatenate(patternAmbientModules, file.patternAmbientModules)
			}
			if file.moduleAugmentations.length {
				(augmentations || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): augmentations = [] */ TODO)).push(file.moduleAugmentations)
			}
			if file.symbol && file.symbol.globalExports {
				source := file.symbol.globalExports
				source.forEach(func(sourceSymbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
					if !globals.has(id) {
						globals.set(id, sourceSymbol)
					}
				})
			}
		}
		if augmentations {
			for _, list := range augmentations {
				for _, augmentation := range list {
					if !isGlobalScopeAugmentation(augmentation.parent) {
						continue
					}
					mergeModuleAugmentation(augmentation)
				}
			}
		}
		addUndefinedToGlobalsOrErrorOnRedeclaration()
		getSymbolLinks(undefinedSymbol).type_ = undefinedWideningType
		getSymbolLinks(argumentsSymbol).type_ = getGlobalType("IArguments", 0, true)
		getSymbolLinks(unknownSymbol).type_ = errorType
		getSymbolLinks(globalThisSymbol).type_ = createObjectType(ObjectFlagsAnonymous, globalThisSymbol)
		globalArrayType = getGlobalType("Array", 1, true)
		globalObjectType = getGlobalType("Object", 0, true)
		globalFunctionType = getGlobalType("Function", 0, true)
		globalCallableFunctionType = strictBindCallApply && getGlobalType("CallableFunction", 0, true) || globalFunctionType
		globalNewableFunctionType = strictBindCallApply && getGlobalType("NewableFunction", 0, true) || globalFunctionType
		globalStringType = getGlobalType("String", 0, true)
		globalNumberType = getGlobalType("Number", 0, true)
		globalBooleanType = getGlobalType("Boolean", 0, true)
		globalRegExpType = getGlobalType("RegExp", 0, true)
		anyArrayType = createArrayType(anyType)
		autoArrayType = createArrayType(autoType)
		if autoArrayType == emptyObjectType {
			autoArrayType = createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
		}
		globalReadonlyArrayType = getGlobalTypeOrUndefined("ReadonlyArray", 1) || globalArrayType
		anyReadonlyArrayType = /* TODO(ConditionalExpression): globalReadonlyArrayType ? createTypeFromGenericGlobalType(globalReadonlyArrayType, [anyType]) : anyArrayType */ TODO
		globalThisType = getGlobalTypeOrUndefined("ThisType", 1)
		if augmentations {
			for _, list := range augmentations {
				for _, augmentation := range list {
					if isGlobalScopeAugmentation(augmentation.parent) {
						continue
					}
					mergeModuleAugmentation(augmentation)
				}
			}
		}
		amalgamatedDuplicates.forEach(func(TODO_IDENTIFIER /* TODO inferred type DuplicateInfoForFiles */ TODO) {
			if conflictingSymbols.size < 8 {
				conflictingSymbols.forEach(func(TODO_IDENTIFIER /* TODO inferred type DuplicateInfoForSymbol */ TODO, symbolName /* TODO inferred type string */ TODO) {
					message := /* TODO(ConditionalExpression): isBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0 : Diagnostics.Duplicate_identifier_0 */ TODO
					for _, node := range firstFileLocations {
						addDuplicateDeclarationError(node, message, symbolName, secondFileLocations)
					}
					for _, node := range secondFileLocations {
						addDuplicateDeclarationError(node, message, symbolName, firstFileLocations)
					}
				})
			} else {
				list := arrayFrom(conflictingSymbols.keys()).join(", ")
				diagnostics.add(addRelatedInfo(createDiagnosticForNode(firstFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), createDiagnosticForNode(secondFile, Diagnostics.Conflicts_are_in_this_file)))
				diagnostics.add(addRelatedInfo(createDiagnosticForNode(secondFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), createDiagnosticForNode(firstFile, Diagnostics.Conflicts_are_in_this_file)))
			}
		})
		amalgamatedDuplicates = nil
	}
	checkExternalEmitHelpers := func(location Node, helpers ExternalEmitHelpers) {
		if compilerOptions.importHelpers {
			sourceFile := getSourceFileOfNode(location)
			if isEffectiveExternalModule(sourceFile, compilerOptions) && !(location.flags & NodeFlagsAmbient) {
				helpersModule := resolveHelpersModule(sourceFile, location)
				if helpersModule != unknownSymbol {
					links := getSymbolLinks(helpersModule)
					/* TODO(ExpressionStatement): links.requestedExternalEmitHelpers ??= 0 as ExternalEmitHelpers; */
					if (links.requestedExternalEmitHelpers & helpers) != helpers {
						uncheckedHelpers := helpers & ~links.requestedExternalEmitHelpers
						/* TODO(ForStatement): for (let helper = ExternalEmitHelpers.FirstEmitHelper; helper <= ExternalEmitHelpers.LastEmitHelper; helper <<= 1) {                             if (uncheckedHelpers & helper) {                                 for (const name of getHelperNames(helper)) {                                     const symbol = resolveSymbol(getSymbol(getExportsOfModule(helpersModule), escapeLeadingUnderscores(name), SymbolFlags.Value));                                     if (!symbol) {                                         error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name);                                     }                                     else if (helper & ExternalEmitHelpers.ClassPrivateFieldGet) {                                         if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 3)) {                                             error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 4);                                         }                                     }                                     else if (helper & ExternalEmitHelpers.ClassPrivateFieldSet) {                                         if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 4)) {                                             error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 5);                                         }                                     }                                     else if (helper & ExternalEmitHelpers.SpreadArray) {                                         if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 2)) {                                             error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 3);                                         }                                     }                                 }                             }                         } */
					}
					links.requestedExternalEmitHelpers |= helpers
				}
			}
		}
	}
	getHelperNames := func(helper ExternalEmitHelpers) /* TODO inferred type string[] */ TODO {
		switch helper {
		case ExternalEmitHelpersExtends:
			return /* TODO(ArrayLiteralExpression): ["__extends"] */ TODO
		case ExternalEmitHelpersAssign:
			return /* TODO(ArrayLiteralExpression): ["__assign"] */ TODO
		case ExternalEmitHelpersRest:
			return /* TODO(ArrayLiteralExpression): ["__rest"] */ TODO
		case ExternalEmitHelpersDecorate:
			return /* TODO(ConditionalExpression): legacyDecorators ? ["__decorate"] : ["__esDecorate", "__runInitializers"] */ TODO
		case ExternalEmitHelpersMetadata:
			return /* TODO(ArrayLiteralExpression): ["__metadata"] */ TODO
		case ExternalEmitHelpersParam:
			return /* TODO(ArrayLiteralExpression): ["__param"] */ TODO
		case ExternalEmitHelpersAwaiter:
			return /* TODO(ArrayLiteralExpression): ["__awaiter"] */ TODO
		case ExternalEmitHelpersGenerator:
			return /* TODO(ArrayLiteralExpression): ["__generator"] */ TODO
		case ExternalEmitHelpersValues:
			return /* TODO(ArrayLiteralExpression): ["__values"] */ TODO
		case ExternalEmitHelpersRead:
			return /* TODO(ArrayLiteralExpression): ["__read"] */ TODO
		case ExternalEmitHelpersSpreadArray:
			return /* TODO(ArrayLiteralExpression): ["__spreadArray"] */ TODO
		case ExternalEmitHelpersAwait:
			return /* TODO(ArrayLiteralExpression): ["__await"] */ TODO
		case ExternalEmitHelpersAsyncGenerator:
			return /* TODO(ArrayLiteralExpression): ["__asyncGenerator"] */ TODO
		case ExternalEmitHelpersAsyncDelegator:
			return /* TODO(ArrayLiteralExpression): ["__asyncDelegator"] */ TODO
		case ExternalEmitHelpersAsyncValues:
			return /* TODO(ArrayLiteralExpression): ["__asyncValues"] */ TODO
		case ExternalEmitHelpersExportStar:
			return /* TODO(ArrayLiteralExpression): ["__exportStar"] */ TODO
		case ExternalEmitHelpersImportStar:
			return /* TODO(ArrayLiteralExpression): ["__importStar"] */ TODO
		case ExternalEmitHelpersImportDefault:
			return /* TODO(ArrayLiteralExpression): ["__importDefault"] */ TODO
		case ExternalEmitHelpersMakeTemplateObject:
			return /* TODO(ArrayLiteralExpression): ["__makeTemplateObject"] */ TODO
		case ExternalEmitHelpersClassPrivateFieldGet:
			return /* TODO(ArrayLiteralExpression): ["__classPrivateFieldGet"] */ TODO
		case ExternalEmitHelpersClassPrivateFieldSet:
			return /* TODO(ArrayLiteralExpression): ["__classPrivateFieldSet"] */ TODO
		case ExternalEmitHelpersClassPrivateFieldIn:
			return /* TODO(ArrayLiteralExpression): ["__classPrivateFieldIn"] */ TODO
		case ExternalEmitHelpersSetFunctionName:
			return /* TODO(ArrayLiteralExpression): ["__setFunctionName"] */ TODO
		case ExternalEmitHelpersPropKey:
			return /* TODO(ArrayLiteralExpression): ["__propKey"] */ TODO
		case ExternalEmitHelpersAddDisposableResourceAndDisposeResources:
			return /* TODO(ArrayLiteralExpression): ["__addDisposableResource", "__disposeResources"] */ TODO
		default:
			return Debug.fail("Unrecognized helper")
		}
	}
	resolveHelpersModule := func(file SourceFile, errorNode Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		links := getNodeLinks(file)
		if !links.externalHelpersModule {
			links.externalHelpersModule = resolveExternalModule(getImportHelpersImportSpecifier(file), externalHelpersModuleNameText, Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || unknownSymbol
		}
		return links.externalHelpersModule
	}
	checkGrammarModifiers := func(node /* TODO(UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) bool {
		quickResult := reportObviousDecoratorErrors(node) || reportObviousModifierErrors(node)
		if quickResult != nil {
			return quickResult
		}
		if isParameter(node) && parameterIsThisKeyword(node) {
			return grammarErrorOnFirstToken(node, Diagnostics.Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters)
		}
		blockScopeKind := /* TODO(ConditionalExpression): isVariableStatement(node) ? node.declarationList.flags & NodeFlags.BlockScoped : NodeFlags.None */ TODO
		var lastStatic Node
		var lastDeclare Node
		var lastAsync Node
		var lastOverride Node
		var firstDecorator *Decorator
		flags := ModifierFlagsNone
		sawExportBeforeDecorators := false
		hasLeadingDecorators := false
		for _, modifier := range (node).modifiers {
			if isDecorator(modifier) {
				if !nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent) {
					if node.kind == SyntaxKindMethodDeclaration && !nodeIsPresent(node.body) {
						return grammarErrorOnFirstToken(node, Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload)
					} else {
						return grammarErrorOnFirstToken(node, Diagnostics.Decorators_are_not_valid_here)
					}
				} else if legacyDecorators && (node.kind == SyntaxKindGetAccessor || node.kind == SyntaxKindSetAccessor) {
					accessors := getAllAccessorDeclarationsForDeclaration(node)
					if hasDecorators(accessors.firstAccessor) && node == accessors.secondAccessor {
						return grammarErrorOnFirstToken(node, Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name)
					}
				}
				if flags & ~(ModifierFlagsExportDefault | ModifierFlagsDecorator) {
					return grammarErrorOnNode(modifier, Diagnostics.Decorators_are_not_valid_here)
				}
				if hasLeadingDecorators && flags&ModifierFlagsModifier {
					Debug.assertIsDefined(firstDecorator)
					sourceFile := getSourceFileOfNode(modifier)
					if !hasParseDiagnostics(sourceFile) {
						addRelatedInfo(error(modifier, Diagnostics.Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export), createDiagnosticForNode(firstDecorator, Diagnostics.Decorator_used_before_export_here))
						return true
					}
					return false
				}
				flags |= ModifierFlagsDecorator
				if !(flags & ModifierFlagsModifier) {
					hasLeadingDecorators = true
				} else if flags & ModifierFlagsExport {
					sawExportBeforeDecorators = true
				}
				/* TODO(ExpressionStatement): firstDecorator ??= modifier; */
			} else {
				if modifier.kind != SyntaxKindReadonlyKeyword {
					if node.kind == SyntaxKindPropertySignature || node.kind == SyntaxKindMethodSignature {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_member, tokenToString(modifier.kind))
					}
					if node.kind == SyntaxKindIndexSignature && (modifier.kind != SyntaxKindStaticKeyword || !isClassLike(node.parent)) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_index_signature, tokenToString(modifier.kind))
					}
				}
				if modifier.kind != SyntaxKindInKeyword && modifier.kind != SyntaxKindOutKeyword && modifier.kind != SyntaxKindConstKeyword {
					if node.kind == SyntaxKindTypeParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_parameter, tokenToString(modifier.kind))
					}
				}
				switch modifier.kind {
				case SyntaxKindConstKeyword:
					if node.kind != SyntaxKindEnumDeclaration && node.kind != SyntaxKindTypeParameter {
						return grammarErrorOnNode(node, Diagnostics.A_class_member_cannot_have_the_0_keyword, tokenToString(SyntaxKindConstKeyword))
					}
					parent := (isJSDocTemplateTag(node.parent) && getEffectiveJSDocHost(node.parent)) || node.parent
					if node.kind == SyntaxKindTypeParameter && !(isFunctionLikeDeclaration(parent) || isClassLike(parent) || isFunctionTypeNode(parent) || isConstructorTypeNode(parent) || isCallSignatureDeclaration(parent) || isConstructSignatureDeclaration(parent) || isMethodSignature(parent)) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class, tokenToString(modifier.kind))
					}
					break
					fallthrough
				case SyntaxKindOverrideKeyword:
					if flags & ModifierFlagsOverride {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "override")
					} else if flags & ModifierFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "override", "declare")
					} else if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "readonly")
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "accessor")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "async")
					}
					flags |= ModifierFlagsOverride
					lastOverride = modifier
					break
				case SyntaxKindPublicKeyword:
					fallthrough // TODO: merge cases
				case SyntaxKindProtectedKeyword:
					fallthrough // TODO: merge cases
				case SyntaxKindPrivateKeyword:
					text := visibilityToString(modifierToFlag(modifier.kind))
					if flags & ModifierFlagsAccessibilityModifier {
						return grammarErrorOnNode(modifier, Diagnostics.Accessibility_modifier_already_seen)
					} else if flags & ModifierFlagsOverride {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "override")
					} else if flags & ModifierFlagsStatic {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "static")
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "accessor")
					} else if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "async")
					} else if node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, text)
					} else if flags & ModifierFlagsAbstract {
						if modifier.kind == SyntaxKindPrivateKeyword {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, text, "abstract")
						} else {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "abstract")
						}
					} else if isPrivateIdentifierClassElementDeclaration(node) {
						return grammarErrorOnNode(modifier, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier)
					}
					flags |= modifierToFlag(modifier.kind)
					break
				case SyntaxKindStaticKeyword:
					if flags & ModifierFlagsStatic {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "static")
					} else if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "readonly")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "async")
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "accessor")
					} else if node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, "static")
					} else if node.kind == SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static")
					} else if flags & ModifierFlagsAbstract {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract")
					} else if flags & ModifierFlagsOverride {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "override")
					}
					flags |= ModifierFlagsStatic
					lastStatic = modifier
					break
				case SyntaxKindAccessorKeyword:
					if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "accessor")
					} else if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "readonly")
					} else if flags & ModifierFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "declare")
					} else if node.kind != SyntaxKindPropertyDeclaration {
						return grammarErrorOnNode(modifier, Diagnostics.accessor_modifier_can_only_appear_on_a_property_declaration)
					}
					flags |= ModifierFlagsAccessor
					break
				case SyntaxKindReadonlyKeyword:
					if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "readonly")
					} else if node.kind != SyntaxKindPropertyDeclaration && node.kind != SyntaxKindPropertySignature && node.kind != SyntaxKindIndexSignature && node.kind != SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature)
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "readonly", "accessor")
					}
					flags |= ModifierFlagsReadonly
					break
				case SyntaxKindExportKeyword:
					if compilerOptions.verbatimModuleSyntax && !(node.flags & NodeFlagsAmbient) && node.kind != SyntaxKindTypeAliasDeclaration && node.kind != SyntaxKindInterfaceDeclaration && node.kind != SyntaxKindModuleDeclaration && node.parent.kind == SyntaxKindSourceFile && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
						return grammarErrorOnNode(modifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
					}
					if flags & ModifierFlagsExport {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "export")
					} else if flags & ModifierFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare")
					} else if flags & ModifierFlagsAbstract {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "abstract")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "async")
					} else if isClassLike(node.parent) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "export")
					} else if node.kind == SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export")
					} else if blockScopeKind == NodeFlagsUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "export")
					} else if blockScopeKind == NodeFlagsAwaitUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "export")
					}
					flags |= ModifierFlagsExport
					break
				case SyntaxKindDefaultKeyword:
					container := /* TODO(ConditionalExpression): node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent */ TODO
					if container.kind == SyntaxKindModuleDeclaration && !isAmbientModule(container) {
						return grammarErrorOnNode(modifier, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module)
					} else if blockScopeKind == NodeFlagsUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "default")
					} else if blockScopeKind == NodeFlagsAwaitUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "default")
					} else if !(flags & ModifierFlagsExport) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "default")
					} else if sawExportBeforeDecorators {
						return grammarErrorOnNode(firstDecorator, Diagnostics.Decorators_are_not_valid_here)
					}
					flags |= ModifierFlagsDefault
					break
				case SyntaxKindDeclareKeyword:
					if flags & ModifierFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "declare")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async")
					} else if flags & ModifierFlagsOverride {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "override")
					} else if isClassLike(node.parent) && !isPropertyDeclaration(node) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "declare")
					} else if node.kind == SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare")
					} else if blockScopeKind == NodeFlagsUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "declare")
					} else if blockScopeKind == NodeFlagsAwaitUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "declare")
					} else if (node.parent.flags & NodeFlagsAmbient) && node.parent.kind == SyntaxKindModuleBlock {
						return grammarErrorOnNode(modifier, Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context)
					} else if isPrivateIdentifierClassElementDeclaration(node) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "declare")
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "declare", "accessor")
					}
					flags |= ModifierFlagsAmbient
					lastDeclare = modifier
					break
				case SyntaxKindAbstractKeyword:
					if flags & ModifierFlagsAbstract {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "abstract")
					}
					if node.kind != SyntaxKindClassDeclaration && node.kind != SyntaxKindConstructorType {
						if node.kind != SyntaxKindMethodDeclaration && node.kind != SyntaxKindPropertyDeclaration && node.kind != SyntaxKindGetAccessor && node.kind != SyntaxKindSetAccessor {
							return grammarErrorOnNode(modifier, Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration)
						}
						if !(node.parent.kind == SyntaxKindClassDeclaration && hasSyntacticModifier(node.parent, ModifierFlagsAbstract)) {
							message := /* TODO(ConditionalExpression): node.kind === SyntaxKind.PropertyDeclaration                                     ? Diagnostics.Abstract_properties_can_only_appear_within_an_abstract_class                                     : Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class */ TODO
							return grammarErrorOnNode(modifier, message)
						}
						if flags & ModifierFlagsStatic {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract")
						}
						if flags & ModifierFlagsPrivate {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "private", "abstract")
						}
						if flags&ModifierFlagsAsync && lastAsync {
							return grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract")
						}
						if flags & ModifierFlagsOverride {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "override")
						}
						if flags & ModifierFlagsAccessor {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "accessor")
						}
					}
					if isNamedDeclaration(node) && node.name.kind == SyntaxKindPrivateIdentifier {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "abstract")
					}
					flags |= ModifierFlagsAbstract
					break
				case SyntaxKindAsyncKeyword:
					if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "async")
					} else if flags&ModifierFlagsAmbient || node.parent.flags&NodeFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async")
					} else if node.kind == SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async")
					}
					if flags & ModifierFlagsAbstract {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract")
					}
					flags |= ModifierFlagsAsync
					lastAsync = modifier
					break
				case SyntaxKindInKeyword:
					fallthrough // TODO: merge cases
				case SyntaxKindOutKeyword:
					inOutFlag := /* TODO(ConditionalExpression): modifier.kind === SyntaxKind.InKeyword ? ModifierFlags.In : ModifierFlags.Out */ TODO
					inOutText := /* TODO(ConditionalExpression): modifier.kind === SyntaxKind.InKeyword ? "in" : "out" */ TODO
					parent := isJSDocTemplateTag(node.parent) && (getEffectiveJSDocHost(node.parent) || find(getJSDocRoot(node.parent).tags, isJSDocTypedefTag)) || node.parent
					if node.kind != SyntaxKindTypeParameter || parent && !(isInterfaceDeclaration(parent) || isClassLike(parent) || isTypeAliasDeclaration(parent) || isJSDocTypedefTag(parent)) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias, inOutText)
					}
					if flags & inOutFlag {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, inOutText)
					}
					if inOutFlag&ModifierFlagsIn && flags&ModifierFlagsOut {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "in", "out")
					}
					flags |= inOutFlag
					break
				}
			}
		}
		if node.kind == SyntaxKindConstructor {
			if flags & ModifierFlagsStatic {
				return grammarErrorOnNode(lastStatic, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static")
			}
			if flags & ModifierFlagsOverride {
				return grammarErrorOnNode(lastOverride, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "override")
			}
			if flags & ModifierFlagsAsync {
				return grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "async")
			}
			return false
		} else if (node.kind == SyntaxKindImportDeclaration || node.kind == SyntaxKindImportEqualsDeclaration) && flags&ModifierFlagsAmbient {
			return grammarErrorOnNode(lastDeclare, Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration, "declare")
		} else if node.kind == SyntaxKindParameter && (flags & ModifierFlagsParameterPropertyModifier) && isBindingPattern(node.name) {
			return grammarErrorOnNode(node, Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern)
		} else if node.kind == SyntaxKindParameter && (flags & ModifierFlagsParameterPropertyModifier) && node.dotDotDotToken {
			return grammarErrorOnNode(node, Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter)
		}
		if flags & ModifierFlagsAsync {
			return checkGrammarAsyncModifier(node, lastAsync)
		}
		return false
	}
	reportObviousModifierErrors := func(node /* TODO(UnionType): HasModifiers | HasIllegalModifiers */ any) /* TODO(BooleanKeyword): boolean */ any {
		if !node.modifiers {
			return false
		}
		modifier := findFirstIllegalModifier(node)
		return modifier && grammarErrorOnFirstToken(modifier, Diagnostics.Modifiers_cannot_appear_here)
	}
	findFirstModifierExcept := func(node HasModifiers, allowedModifier SyntaxKind) *Modifier {
		modifier := find(node.modifiers, isModifier)
		return /* TODO(ConditionalExpression): modifier && modifier.kind !== allowedModifier ? modifier : undefined */ TODO
	}
	findFirstIllegalModifier := func(node /* TODO(UnionType): HasModifiers | HasIllegalModifiers */ any) *Modifier {
		switch node.kind {
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindConstructor:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertySignature:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodSignature:
			fallthrough // TODO: merge cases
		case SyntaxKindIndexSignature:
			fallthrough // TODO: merge cases
		case SyntaxKindModuleDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindImportDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindImportEqualsDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindExportDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindExportAssignment:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindParameter:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeParameter:
			return nil
		case SyntaxKindClassStaticBlockDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAssignment:
			fallthrough // TODO: merge cases
		case SyntaxKindShorthandPropertyAssignment:
			fallthrough // TODO: merge cases
		case SyntaxKindNamespaceExportDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMissingDeclaration:
			return find(node.modifiers, isModifier)
		default:
			if node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
				return nil
			}
			switch node.kind {
			case SyntaxKindFunctionDeclaration:
				return findFirstModifierExcept(node, SyntaxKindAsyncKeyword)
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructorType:
				return findFirstModifierExcept(node, SyntaxKindAbstractKeyword)
			case SyntaxKindClassExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeAliasDeclaration:
				return find(node.modifiers, isModifier)
			case SyntaxKindVariableStatement:
				return /* TODO(ConditionalExpression): node.declarationList.flags & NodeFlags.Using ?                             findFirstModifierExcept(node, SyntaxKind.AwaitKeyword) :                             find(node.modifiers, isModifier) */ TODO
			case SyntaxKindEnumDeclaration:
				return findFirstModifierExcept(node, SyntaxKindConstKeyword)
			default:
				Debug.assertNever(node)
			}
		}
	}
	reportObviousDecoratorErrors := func(node /* TODO(UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) /* TODO inferred type boolean | undefined */ TODO {
		decorator := findFirstIllegalDecorator(node)
		return decorator && grammarErrorOnFirstToken(decorator, Diagnostics.Decorators_are_not_valid_here)
	}
	findFirstIllegalDecorator := func(node /* TODO(UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) *Decorator {
		return /* TODO(ConditionalExpression): canHaveIllegalDecorators(node) ? find(node.modifiers, isDecorator) : undefined */ TODO
	}
	checkGrammarAsyncModifier := func(node Node, asyncModifier Node) bool {
		switch node.kind {
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			return false
		}
		return grammarErrorOnNode(asyncModifier, Diagnostics._0_modifier_cannot_be_used_here, "async")
	}
	checkGrammarForDisallowedTrailingComma := func(list *NodeArray[Node], diag /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO /*  = Diagnostics.Trailing_comma_not_allowed */) bool {
		if list && list.hasTrailingComma {
			return grammarErrorAtPos( /* TODO(ElementAccessExpression): list[0] */ TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): list.end - ",".length */, TODO, ",".length, diag)
		}
		return false
	}
	checkGrammarTypeParameterList := func(typeParameters *NodeArray[TypeParameterDeclaration], file SourceFile) bool {
		if typeParameters && typeParameters.length == 0 {
			start := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): typeParameters.pos - "<".length */ TODO
			end := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): skipTrivia(file.text, typeParameters.end) + ">".length */ TODO
			return grammarErrorAtPos(file, start /* TODO(MinusToken): - */ /* TODO(BinaryExpression): end - start */, TODO, Diagnostics.Type_parameter_list_cannot_be_empty)
		}
		return false
	}
	checkGrammarParameterList := func(parameters NodeArray[ParameterDeclaration]) /* TODO inferred type boolean | undefined */ TODO {
		seenOptionalParameter := false
		parameterCount := parameters.length
		/* TODO(ForStatement): for (let i = 0; i < parameterCount; i++) {             const parameter = parameters[i];             if (parameter.dotDotDotToken) {                 if (i !== (parameterCount - 1)) {                     return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);                 }                 if (!(parameter.flags & NodeFlags.Ambient)) { // Allow `...foo,` in ambient declarations; see GH#23070                     checkGrammarForDisallowedTrailingComma(parameters, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);                 }                  if (parameter.questionToken) {                     return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_rest_parameter_cannot_be_optional);                 }                  if (parameter.initializer) {                     return grammarErrorOnNode(parameter.name, Diagnostics.A_rest_parameter_cannot_have_an_initializer);                 }             }             else if (hasEffectiveQuestionToken(parameter)) {                 seenOptionalParameter = true;                 if (parameter.questionToken && parameter.initializer) {                     return grammarErrorOnNode(parameter.name, Diagnostics.Parameter_cannot_have_question_mark_and_initializer);                 }             }             else if (seenOptionalParameter && !parameter.initializer) {                 return grammarErrorOnNode(parameter.name, Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);             }         } */
	}
	getNonSimpleParameters := func(parameters []ParameterDeclaration) []ParameterDeclaration {
		return filter(parameters, func(parameter /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO) /* TODO inferred type boolean */ TODO {
			return !!parameter.initializer || isBindingPattern(parameter.name) || isRestParameter(parameter)
		})
	}
	checkGrammarForUseStrictSimpleParameterList := func(node FunctionLikeDeclaration) bool {
		if languageVersion >= ScriptTargetES2016 {
			useStrictDirective := node.body && isBlock(node.body) && findUseStrictPrologue(node.body.statements)
			if useStrictDirective {
				nonSimpleParameters := getNonSimpleParameters(node.parameters)
				if length(nonSimpleParameters) {
					forEach(nonSimpleParameters, func(parameter /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO) {
						addRelatedInfo(error(parameter, Diagnostics.This_parameter_is_not_allowed_with_use_strict_directive), createDiagnosticForNode(useStrictDirective, Diagnostics.use_strict_directive_used_here))
					})
					diagnostics := nonSimpleParameters.map_(func(parameter /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO, index /* TODO inferred type number */ TODO) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
						return ( /* TODO(ConditionalExpression): index === 0 ? createDiagnosticForNode(parameter, Diagnostics.Non_simple_parameter_declared_here) : createDiagnosticForNode(parameter, Diagnostics.and_here) */ TODO)
					})
					addRelatedInfo(error(useStrictDirective, Diagnostics.use_strict_directive_cannot_be_used_with_non_simple_parameter_list) /* TODO(SpreadElement): ...diagnostics */, TODO)
					return true
				}
			}
		}
		return false
	}
	checkGrammarFunctionLikeDeclaration := func(node /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any) bool {
		file := getSourceFileOfNode(node)
		return checkGrammarModifiers(node) || checkGrammarTypeParameterList(node.typeParameters, file) || checkGrammarParameterList(node.parameters) || checkGrammarArrowFunction(node, file) || (isFunctionLikeDeclaration(node) && checkGrammarForUseStrictSimpleParameterList(node))
	}
	checkGrammarClassLikeDeclaration := func(node ClassLikeDeclaration) bool {
		file := getSourceFileOfNode(node)
		return checkGrammarClassDeclarationHeritageClauses(node) || checkGrammarTypeParameterList(node.typeParameters, file)
	}
	checkGrammarArrowFunction := func(node Node, file SourceFile) bool {
		if !isArrowFunction(node) {
			return false
		}
		if node.typeParameters && !(length(node.typeParameters) > 1 || node.typeParameters.hasTrailingComma || /* TODO(ElementAccessExpression): node.typeParameters[0] */ TODO.constraint) {
			if file && fileExtensionIsOneOf(file.fileName /* TODO(ArrayLiteralExpression): [Extension.Mts, Extension.Cts] */, TODO) {
				grammarErrorOnNode( /* TODO(ElementAccessExpression): node.typeParameters[0] */ TODO, Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint)
			}
		}
		TODO_IDENTIFIER := node
		startLine := getLineAndCharacterOfPosition(file, equalsGreaterThanToken.pos).line
		endLine := getLineAndCharacterOfPosition(file, equalsGreaterThanToken.end).line
		return startLine != endLine && grammarErrorOnNode(equalsGreaterThanToken, Diagnostics.Line_terminator_not_permitted_before_arrow)
	}
	checkGrammarIndexSignatureParameters := func(node SignatureDeclaration) bool {
		parameter := /* TODO(ElementAccessExpression): node.parameters[0] */ TODO
		if node.parameters.length != 1 {
			if parameter {
				return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_must_have_exactly_one_parameter)
			} else {
				return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_exactly_one_parameter)
			}
		}
		checkGrammarForDisallowedTrailingComma(node.parameters, Diagnostics.An_index_signature_cannot_have_a_trailing_comma)
		if parameter.dotDotDotToken {
			return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.An_index_signature_cannot_have_a_rest_parameter)
		}
		if hasEffectiveModifiers(parameter) {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier)
		}
		if parameter.questionToken {
			return grammarErrorOnNode(parameter.questionToken, Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark)
		}
		if parameter.initializer {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_initializer)
		}
		if !parameter.type_ {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_must_have_a_type_annotation)
		}
		type_ := getTypeFromTypeNode(parameter.type_)
		if someType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
			return !!(t.flags & TypeFlagsStringOrNumberLiteralOrUnique)
		}) || isGenericType(type_) {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead)
		}
		if !everyType(type_, isValidIndexKeyType) {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type)
		}
		if !node.type_ {
			return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_a_type_annotation)
		}
		return false
	}
	checkGrammarIndexSignature := func(node IndexSignatureDeclaration) /* TODO inferred type boolean */ TODO {
		return checkGrammarModifiers(node) || checkGrammarIndexSignatureParameters(node)
	}
	checkGrammarForAtLeastOneTypeArgument := func(node Node, typeArguments *NodeArray[TypeNode]) bool {
		if typeArguments && typeArguments.length == 0 {
			sourceFile := getSourceFileOfNode(node)
			start := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): typeArguments.pos - "<".length */ TODO
			end := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): skipTrivia(sourceFile.text, typeArguments.end) + ">".length */ TODO
			return grammarErrorAtPos(sourceFile, start /* TODO(MinusToken): - */ /* TODO(BinaryExpression): end - start */, TODO, Diagnostics.Type_argument_list_cannot_be_empty)
		}
		return false
	}
	checkGrammarTypeArguments := func(node Node, typeArguments *NodeArray[TypeNode]) bool {
		return checkGrammarForDisallowedTrailingComma(typeArguments) || checkGrammarForAtLeastOneTypeArgument(node, typeArguments)
	}
	checkGrammarTaggedTemplateChain := func(node TaggedTemplateExpression) bool {
		if node.questionDotToken || node.flags&NodeFlagsOptionalChain {
			return grammarErrorOnNode(node.template, Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain)
		}
		return false
	}
	checkGrammarHeritageClause := func(node HeritageClause) bool {
		types := node.types
		if checkGrammarForDisallowedTrailingComma(types) {
			return true
		}
		if types && types.length == 0 {
			listType := tokenToString(node.token)
			return grammarErrorAtPos(node, types.pos, 0, Diagnostics._0_list_cannot_be_empty, listType)
		}
		return some(types, checkGrammarExpressionWithTypeArguments)
	}
	checkGrammarExpressionWithTypeArguments := func(node /* TODO(UnionType): ExpressionWithTypeArguments | TypeQueryNode */ any) /* TODO inferred type boolean */ TODO {
		if isExpressionWithTypeArguments(node) && isImportKeyword(node.expression) && node.typeArguments {
			return grammarErrorOnNode(node, Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments)
		}
		return checkGrammarTypeArguments(node, node.typeArguments)
	}
	checkGrammarClassDeclarationHeritageClauses := func(node ClassLikeDeclaration) /* TODO inferred type boolean | undefined */ TODO {
		seenExtendsClause := false
		seenImplementsClause := false
		if !checkGrammarModifiers(node) && node.heritageClauses {
			for _, heritageClause := range node.heritageClauses {
				if heritageClause.token == SyntaxKindExtendsKeyword {
					if seenExtendsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen)
					}
					if seenImplementsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_must_precede_implements_clause)
					}
					if heritageClause.types.length > 1 {
						return grammarErrorOnFirstToken( /* TODO(ElementAccessExpression): heritageClause.types[1] */ TODO, Diagnostics.Classes_can_only_extend_a_single_class)
					}
					seenExtendsClause = true
				} else {
					Debug.assert(heritageClause.token == SyntaxKindImplementsKeyword)
					if seenImplementsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.implements_clause_already_seen)
					}
					seenImplementsClause = true
				}
				checkGrammarHeritageClause(heritageClause)
			}
		}
	}
	checkGrammarInterfaceDeclaration := func(node InterfaceDeclaration) /* TODO inferred type boolean */ TODO {
		seenExtendsClause := false
		if node.heritageClauses {
			for _, heritageClause := range node.heritageClauses {
				if heritageClause.token == SyntaxKindExtendsKeyword {
					if seenExtendsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen)
					}
					seenExtendsClause = true
				} else {
					Debug.assert(heritageClause.token == SyntaxKindImplementsKeyword)
					return grammarErrorOnFirstToken(heritageClause, Diagnostics.Interface_declaration_cannot_have_implements_clause)
				}
				checkGrammarHeritageClause(heritageClause)
			}
		}
		return false
	}
	checkGrammarComputedPropertyName := func(node Node) bool {
		if node.kind != SyntaxKindComputedPropertyName {
			return false
		}
		computedPropertyName := node
		if computedPropertyName.expression.kind == SyntaxKindBinaryExpression && (computedPropertyName.expression).operatorToken.kind == SyntaxKindCommaToken {
			return grammarErrorOnNode(computedPropertyName.expression, Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name)
		}
		return false
	}
	checkGrammarForGenerator := func(node FunctionLikeDeclaration) /* TODO inferred type boolean | undefined */ TODO {
		if node.asteriskToken {
			Debug.assert(node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindFunctionExpression || node.kind == SyntaxKindMethodDeclaration)
			if node.flags & NodeFlagsAmbient {
				return grammarErrorOnNode(node.asteriskToken, Diagnostics.Generators_are_not_allowed_in_an_ambient_context)
			}
			if !node.body {
				return grammarErrorOnNode(node.asteriskToken, Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator)
			}
		}
	}
	checkGrammarForInvalidQuestionMark := func(questionToken *QuestionToken, message DiagnosticMessage) bool {
		return !!questionToken && grammarErrorOnNode(questionToken, message)
	}
	checkGrammarForInvalidExclamationToken := func(exclamationToken *ExclamationToken, message DiagnosticMessage) bool {
		return !!exclamationToken && grammarErrorOnNode(exclamationToken, message)
	}
	checkGrammarObjectLiteralExpression := func(node ObjectLiteralExpression, inDestructuring bool) /* TODO inferred type boolean | undefined */ TODO {
		seen := make(map[__String]DeclarationMeaning)
		for _, prop := range node.properties {
			if prop.kind == SyntaxKindSpreadAssignment {
				if inDestructuring {
					expression := skipParentheses(prop.expression)
					if isArrayLiteralExpression(expression) || isObjectLiteralExpression(expression) {
						return grammarErrorOnNode(prop.expression, Diagnostics.A_rest_element_cannot_contain_a_binding_pattern)
					}
				}
				continue
			}
			name := prop.name
			if name.kind == SyntaxKindComputedPropertyName {
				checkGrammarComputedPropertyName(name)
			}
			if prop.kind == SyntaxKindShorthandPropertyAssignment && !inDestructuring && prop.objectAssignmentInitializer {
				grammarErrorOnNode(prop.equalsToken, Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern)
			}
			if name.kind == SyntaxKindPrivateIdentifier {
				grammarErrorOnNode(name, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
			}
			if canHaveModifiers(prop) && prop.modifiers {
				for _, mod := range prop.modifiers {
					if isModifier(mod) && (mod.kind != SyntaxKindAsyncKeyword || prop.kind != SyntaxKindMethodDeclaration) {
						grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod))
					}
				}
			} else if canHaveIllegalModifiers(prop) && prop.modifiers {
				for _, mod := range prop.modifiers {
					if isModifier(mod) {
						grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod))
					}
				}
			}
			var currentKind DeclarationMeaning
			switch prop.kind {
			case SyntaxKindShorthandPropertyAssignment:
				fallthrough // TODO: merge cases
			case SyntaxKindPropertyAssignment:
				checkGrammarForInvalidExclamationToken(prop.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context)
				checkGrammarForInvalidQuestionMark(prop.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional)
				if name.kind == SyntaxKindNumericLiteral {
					checkGrammarNumericLiteral(name)
				}
				if name.kind == SyntaxKindBigIntLiteral {
					addErrorOrSuggestion(true, createDiagnosticForNode(name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name))
				}
				currentKind = DeclarationMeaningPropertyAssignment
				break
			case SyntaxKindMethodDeclaration:
				currentKind = DeclarationMeaningMethod
				break
			case SyntaxKindGetAccessor:
				currentKind = DeclarationMeaningGetAccessor
				break
			case SyntaxKindSetAccessor:
				currentKind = DeclarationMeaningSetAccessor
				break
			default:
				Debug.assertNever(prop /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "Unexpected syntax kind:" + (prop as Node).kind */, TODO)
			}
			if !inDestructuring {
				effectiveName := getEffectivePropertyNameForPropertyNameNode(name)
				if effectiveName == nil {
					continue
				}
				existingKind := seen.get(effectiveName)
				if !existingKind {
					seen.set(effectiveName, currentKind)
				} else {
					if (currentKind & DeclarationMeaningMethod) && (existingKind & DeclarationMeaningMethod) {
						grammarErrorOnNode(name, Diagnostics.Duplicate_identifier_0, getTextOfNode(name))
					} else if (currentKind & DeclarationMeaningPropertyAssignment) && (existingKind & DeclarationMeaningPropertyAssignment) {
						grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name, getTextOfNode(name))
					} else if (currentKind & DeclarationMeaningGetOrSetAccessor) && (existingKind & DeclarationMeaningGetOrSetAccessor) {
						if existingKind != DeclarationMeaningGetOrSetAccessor && currentKind != existingKind {
							seen.set(effectiveName, currentKind|existingKind)
						} else {
							return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name)
						}
					} else {
						return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name)
					}
				}
			}
		}
	}
	checkGrammarJsxElement := func(node JsxOpeningLikeElement) /* TODO inferred type boolean | undefined */ TODO {
		checkGrammarJsxName(node.tagName)
		checkGrammarTypeArguments(node, node.typeArguments)
		seen := make(map[__String]bool)
		for _, attr := range node.attributes.properties {
			if attr.kind == SyntaxKindJsxSpreadAttribute {
				continue
			}
			TODO_IDENTIFIER := attr
			escapedText := getEscapedTextOfJsxAttributeName(name)
			if !seen.get(escapedText) {
				seen.set(escapedText, true)
			} else {
				return grammarErrorOnNode(name, Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name)
			}
			if initializer && initializer.kind == SyntaxKindJsxExpression && !initializer.expression {
				return grammarErrorOnNode(initializer, Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression)
			}
		}
	}
	checkGrammarJsxName := func(node JsxTagNameExpression) /* TODO inferred type boolean | undefined */ TODO {
		if isPropertyAccessExpression(node) && isJsxNamespacedName(node.expression) {
			return grammarErrorOnNode(node.expression, Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names)
		}
		if isJsxNamespacedName(node) && getJSXTransformEnabled(compilerOptions) && !isIntrinsicJsxName(node.namespace.escapedText) {
			return grammarErrorOnNode(node, Diagnostics.React_components_cannot_include_JSX_namespace_names)
		}
	}
	checkGrammarJsxExpression := func(node JsxExpression) /* TODO inferred type boolean | undefined */ TODO {
		if node.expression && isCommaSequence(node.expression) {
			return grammarErrorOnNode(node.expression, Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array)
		}
	}
	checkGrammarForInOrForOfStatement := func(forInOrOfStatement ForInOrOfStatement) bool {
		if checkGrammarStatementInAmbientContext(forInOrOfStatement) {
			return true
		}
		if forInOrOfStatement.kind == SyntaxKindForOfStatement && forInOrOfStatement.awaitModifier {
			if !(forInOrOfStatement.flags & NodeFlagsAwaitContext) {
				sourceFile := getSourceFileOfNode(forInOrOfStatement)
				if isInTopLevelContext(forInOrOfStatement) {
					if !hasParseDiagnostics(sourceFile) {
						if !isEffectiveExternalModule(sourceFile, compilerOptions) {
							diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module))
						}
						switch moduleKind {
						case ModuleKindNode16:
							fallthrough // TODO: merge cases
						case ModuleKindNodeNext:
							if sourceFile.impliedNodeFormat == ModuleKindCommonJS {
								diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level))
								break
							}
							fallthrough
						case ModuleKindES2022:
							fallthrough // TODO: merge cases
						case ModuleKindESNext:
							fallthrough // TODO: merge cases
						case ModuleKindPreserve:
							fallthrough // TODO: merge cases
						case ModuleKindSystem:
							if languageVersion >= ScriptTargetES2017 {
								break
							}
							fallthrough
						default:
							diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher))
							break
						}
					}
				} else {
					if !hasParseDiagnostics(sourceFile) {
						diagnostic := createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules)
						func_ := getContainingFunction(forInOrOfStatement)
						if func_ && func_.kind != SyntaxKindConstructor {
							Debug.assert((getFunctionFlags(func_)&FunctionFlagsAsync) == 0, "Enclosing function should never be an async function.")
							relatedInfo := createDiagnosticForNode(func_, Diagnostics.Did_you_mean_to_mark_this_function_as_async)
							addRelatedInfo(diagnostic, relatedInfo)
						}
						diagnostics.add(diagnostic)
						return true
					}
				}
			}
		}
		if isForOfStatement(forInOrOfStatement) && !(forInOrOfStatement.flags & NodeFlagsAwaitContext) && isIdentifier(forInOrOfStatement.initializer) && forInOrOfStatement.initializer.escapedText == "async" {
			grammarErrorOnNode(forInOrOfStatement.initializer, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async)
			return false
		}
		if forInOrOfStatement.initializer.kind == SyntaxKindVariableDeclarationList {
			variableList := forInOrOfStatement.initializer
			if !checkGrammarVariableDeclarationList(variableList) {
				declarations := variableList.declarations
				if !declarations.length {
					return false
				}
				if declarations.length > 1 {
					diagnostic := /* TODO(ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement                         ? Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement                         : Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement */ TODO
					return grammarErrorOnFirstToken( /* TODO(ElementAccessExpression): variableList.declarations[1] */ TODO, diagnostic)
				}
				firstDeclaration := /* TODO(ElementAccessExpression): declarations[0] */ TODO
				if firstDeclaration.initializer {
					diagnostic := /* TODO(ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement                         ? Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer                         : Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer */ TODO
					return grammarErrorOnNode(firstDeclaration.name, diagnostic)
				}
				if firstDeclaration.type_ {
					diagnostic := /* TODO(ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement                         ? Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation                         : Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation */ TODO
					return grammarErrorOnNode(firstDeclaration, diagnostic)
				}
			}
		}
		return false
	}
	checkGrammarAccessor := func(accessor AccessorDeclaration) bool {
		if !(accessor.flags & NodeFlagsAmbient) && (accessor.parent.kind != SyntaxKindTypeLiteral) && (accessor.parent.kind != SyntaxKindInterfaceDeclaration) {
			if languageVersion < ScriptTargetES2015 && isPrivateIdentifier(accessor.name) {
				return grammarErrorOnNode(accessor.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if accessor.body == nil && !hasSyntacticModifier(accessor, ModifierFlagsAbstract) {
				return grammarErrorAtPos(accessor /* TODO(MinusToken): - */ /* TODO(BinaryExpression): accessor.end - 1 */, TODO, ";".length, Diagnostics._0_expected, "{")
			}
		}
		if accessor.body {
			if hasSyntacticModifier(accessor, ModifierFlagsAbstract) {
				return grammarErrorOnNode(accessor, Diagnostics.An_abstract_accessor_cannot_have_an_implementation)
			}
			if accessor.parent.kind == SyntaxKindTypeLiteral || accessor.parent.kind == SyntaxKindInterfaceDeclaration {
				return grammarErrorOnNode(accessor.body, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts)
			}
		}
		if accessor.typeParameters {
			return grammarErrorOnNode(accessor.name, Diagnostics.An_accessor_cannot_have_type_parameters)
		}
		if !doesAccessorHaveCorrectParameterCount(accessor) {
			return grammarErrorOnNode(accessor.name /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ?                     Diagnostics.A_get_accessor_cannot_have_parameters :                     Diagnostics.A_set_accessor_must_have_exactly_one_parameter */, TODO)
		}
		if accessor.kind == SyntaxKindSetAccessor {
			if accessor.type_ {
				return grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation)
			}
			parameter := Debug.checkDefined(getSetAccessorValueParameter(accessor), "Return value does not match parameter count assertion.")
			if parameter.dotDotDotToken {
				return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_set_accessor_cannot_have_rest_parameter)
			}
			if parameter.questionToken {
				return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_set_accessor_cannot_have_an_optional_parameter)
			}
			if parameter.initializer {
				return grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer)
			}
		}
		return false
	}
	doesAccessorHaveCorrectParameterCount := func(accessor AccessorDeclaration) /* TODO inferred type boolean | import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO {
		return getAccessorThisParameter(accessor) || accessor.parameters.length == ( /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ? 0 : 1 */ TODO)
	}
	getAccessorThisParameter := func(accessor AccessorDeclaration) *ParameterDeclaration {
		if accessor.parameters.length == ( /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ? 1 : 2 */ TODO) {
			return getThisParameter(accessor)
		}
	}
	checkGrammarTypeOperatorNode := func(node TypeOperatorNode) /* TODO inferred type boolean | undefined */ TODO {
		if node.operator == SyntaxKindUniqueKeyword {
			if node.type_.kind != SyntaxKindSymbolKeyword {
				return grammarErrorOnNode(node.type_, Diagnostics._0_expected, tokenToString(SyntaxKindSymbolKeyword))
			}
			parent := walkUpParenthesizedTypes(node.parent)
			if isInJSFile(parent) && isJSDocTypeExpression(parent) {
				host := getJSDocHost(parent)
				if host {
					parent = getSingleVariableOfVariableStatement(host) || host
				}
			}
			switch parent.kind {
			case SyntaxKindVariableDeclaration:
				decl := parent
				if decl.name.kind != SyntaxKindIdentifier {
					return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name)
				}
				if !isVariableDeclarationInVariableStatement(decl) {
					return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement)
				}
				if !(decl.parent.flags & NodeFlagsConst) {
					return grammarErrorOnNode((parent).name, Diagnostics.A_variable_whose_type_is_a_unique_symbol_type_must_be_const)
				}
				break
			case SyntaxKindPropertyDeclaration:
				if !isStatic(parent) || !hasEffectiveReadonlyModifier(parent) {
					return grammarErrorOnNode((parent).name, Diagnostics.A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly)
				}
				break
			case SyntaxKindPropertySignature:
				if !hasSyntacticModifier(parent, ModifierFlagsReadonly) {
					return grammarErrorOnNode((parent).name, Diagnostics.A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly)
				}
				break
			default:
				return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_not_allowed_here)
			}
		} else if node.operator == SyntaxKindReadonlyKeyword {
			if node.type_.kind != SyntaxKindArrayType && node.type_.kind != SyntaxKindTupleType {
				return grammarErrorOnFirstToken(node, Diagnostics.readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types, tokenToString(SyntaxKindSymbolKeyword))
			}
		}
	}
	checkGrammarForInvalidDynamicName := func(node DeclarationName, message DiagnosticMessage) /* TODO inferred type boolean | undefined */ TODO {
		if isNonBindableDynamicName(node) {
			return grammarErrorOnNode(node, message)
		}
	}
	checkGrammarMethod := func(node /* TODO(UnionType): MethodDeclaration | MethodSignature */ any) /* TODO inferred type boolean | undefined */ TODO {
		if checkGrammarFunctionLikeDeclaration(node) {
			return true
		}
		if node.kind == SyntaxKindMethodDeclaration {
			if node.parent.kind == SyntaxKindObjectLiteralExpression {
				if node.modifiers && !(node.modifiers.length == 1 && first(node.modifiers).kind == SyntaxKindAsyncKeyword) {
					return grammarErrorOnFirstToken(node, Diagnostics.Modifiers_cannot_appear_here)
				} else if checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional) {
					return true
				} else if checkGrammarForInvalidExclamationToken(node.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context) {
					return true
				} else if node.body == nil {
					return grammarErrorAtPos(node /* TODO(MinusToken): - */ /* TODO(BinaryExpression): node.end - 1 */, TODO, ";".length, Diagnostics._0_expected, "{")
				}
			}
			if checkGrammarForGenerator(node) {
				return true
			}
		}
		if isClassLike(node.parent) {
			if languageVersion < ScriptTargetES2015 && isPrivateIdentifier(node.name) {
				return grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if node.flags & NodeFlagsAmbient {
				return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
			} else if node.kind == SyntaxKindMethodDeclaration && !node.body {
				return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
			}
		} else if node.parent.kind == SyntaxKindInterfaceDeclaration {
			return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
		} else if node.parent.kind == SyntaxKindTypeLiteral {
			return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
		}
	}
	checkGrammarBreakOrContinueStatement := func(node BreakOrContinueStatement) bool {
		var current Node = node
		for current {
			if isFunctionLikeOrClassStaticBlockDeclaration(current) {
				return grammarErrorOnNode(node, Diagnostics.Jump_target_cannot_cross_function_boundary)
			}
			switch current.kind {
			case SyntaxKindLabeledStatement:
				if node.label && (current).label.escapedText == node.label.escapedText {
					isMisplacedContinueLabel := node.kind == SyntaxKindContinueStatement && !isIterationStatement((current).statement, true)
					if isMisplacedContinueLabel {
						return grammarErrorOnNode(node, Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement)
					}
					return false
				}
				break
			case SyntaxKindSwitchStatement:
				if node.kind == SyntaxKindBreakStatement && !node.label {
					return false
				}
				break
			default:
				if isIterationStatement(current, false) && !node.label {
					return false
				}
				break
			}
			current = current.parent
		}
		if node.label {
			message := /* TODO(ConditionalExpression): node.kind === SyntaxKind.BreakStatement                 ? Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement                 : Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement */ TODO
			return grammarErrorOnNode(node, message)
		} else {
			message := /* TODO(ConditionalExpression): node.kind === SyntaxKind.BreakStatement                 ? Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement                 : Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement */ TODO
			return grammarErrorOnNode(node, message)
		}
	}
	checkGrammarBindingElement := func(node BindingElement) /* TODO inferred type boolean | undefined */ TODO {
		if node.dotDotDotToken {
			elements := node.parent.elements
			if node != last(elements) {
				return grammarErrorOnNode(node, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
			}
			checkGrammarForDisallowedTrailingComma(elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
			if node.propertyName {
				return grammarErrorOnNode(node.name, Diagnostics.A_rest_element_cannot_have_a_property_name)
			}
		}
		if node.dotDotDotToken && node.initializer {
			return grammarErrorAtPos(node /* TODO(MinusToken): - */ /* TODO(BinaryExpression): node.initializer.pos - 1 */, TODO, 1, Diagnostics.A_rest_element_cannot_have_an_initializer)
		}
	}
	isStringOrNumberLiteralExpression := func(expr Expression) /* TODO inferred type boolean */ TODO {
		return isStringOrNumericLiteralLike(expr) || expr.kind == SyntaxKindPrefixUnaryExpression && (expr).operator == SyntaxKindMinusToken && (expr).operand.kind == SyntaxKindNumericLiteral
	}
	isBigIntLiteralExpression := func(expr Expression) /* TODO inferred type boolean */ TODO {
		return expr.kind == SyntaxKindBigIntLiteral || expr.kind == SyntaxKindPrefixUnaryExpression && (expr).operator == SyntaxKindMinusToken && (expr).operand.kind == SyntaxKindBigIntLiteral
	}
	isSimpleLiteralEnumReference := func(expr Expression) /* TODO inferred type boolean | undefined */ TODO {
		if (isPropertyAccessExpression(expr) || (isElementAccessExpression(expr) && isStringOrNumberLiteralExpression(expr.argumentExpression))) && isEntityNameExpression(expr.expression) {
			return !!(checkExpressionCached(expr).flags & TypeFlagsEnumLike)
		}
	}
	checkAmbientInitializer := func(node /* TODO(UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature */ any) /* TODO inferred type boolean | undefined */ TODO {
		initializer := node.initializer
		if initializer {
			isInvalidInitializer := !(isStringOrNumberLiteralExpression(initializer) || isSimpleLiteralEnumReference(initializer) || initializer.kind == SyntaxKindTrueKeyword || initializer.kind == SyntaxKindFalseKeyword || isBigIntLiteralExpression(initializer))
			isConstOrReadonly := isDeclarationReadonly(node) || isVariableDeclaration(node) && (isVarConstLike(node))
			if isConstOrReadonly && !node.type_ {
				if isInvalidInitializer {
					return grammarErrorOnNode(initializer, Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference)
				}
			} else {
				return grammarErrorOnNode(initializer, Diagnostics.Initializers_are_not_allowed_in_ambient_contexts)
			}
		}
	}
	checkGrammarVariableDeclaration := func(node VariableDeclaration) /* TODO inferred type boolean */ TODO {
		nodeFlags := getCombinedNodeFlagsCached(node)
		blockScopeKind := nodeFlags & NodeFlagsBlockScoped
		if isBindingPattern(node.name) {
			switch blockScopeKind {
			case NodeFlagsAwaitUsing:
				return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "await using")
			case NodeFlagsUsing:
				return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "using")
			}
		}
		if node.parent.parent.kind != SyntaxKindForInStatement && node.parent.parent.kind != SyntaxKindForOfStatement {
			if nodeFlags & NodeFlagsAmbient {
				checkAmbientInitializer(node)
			} else if !node.initializer {
				if isBindingPattern(node.name) && !isBindingPattern(node.parent) {
					return grammarErrorOnNode(node, Diagnostics.A_destructuring_declaration_must_have_an_initializer)
				}
				switch blockScopeKind {
				case NodeFlagsAwaitUsing:
					return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "await using")
				case NodeFlagsUsing:
					return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "using")
				case NodeFlagsConst:
					return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "const")
				}
			}
		}
		if node.exclamationToken && (node.parent.parent.kind != SyntaxKindVariableStatement || !node.type_ || node.initializer || nodeFlags&NodeFlagsAmbient) {
			message := /* TODO(ConditionalExpression): node.initializer                 ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions                 : !node.type                 ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations                 : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context */ TODO
			return grammarErrorOnNode(node.exclamationToken, message)
		}
		if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && !(node.parent.parent.flags & NodeFlagsAmbient) && hasSyntacticModifier(node.parent.parent, ModifierFlagsExport) {
			checkESModuleMarker(node.name)
		}
		return !!blockScopeKind && checkGrammarNameInLetOrConstDeclarations(node.name)
	}
	checkESModuleMarker := func(name /* TODO(UnionType): Identifier | BindingPattern */ any) bool {
		if name.kind == SyntaxKindIdentifier {
			if idText(name) == "__esModule" {
				return grammarErrorOnNodeSkippedOn("noEmit", name, Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules)
			}
		} else {
			elements := name.elements
			for _, element := range elements {
				if !isOmittedExpression(element) {
					return checkESModuleMarker(element.name)
				}
			}
		}
		return false
	}
	checkGrammarNameInLetOrConstDeclarations := func(name /* TODO(UnionType): Identifier | BindingPattern */ any) bool {
		if name.kind == SyntaxKindIdentifier {
			if name.escapedText == "let" {
				return grammarErrorOnNode(name, Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations)
			}
		} else {
			elements := name.elements
			for _, element := range elements {
				if !isOmittedExpression(element) {
					checkGrammarNameInLetOrConstDeclarations(element.name)
				}
			}
		}
		return false
	}
	checkGrammarVariableDeclarationList := func(declarationList VariableDeclarationList) bool {
		declarations := declarationList.declarations
		if checkGrammarForDisallowedTrailingComma(declarationList.declarations) {
			return true
		}
		if !declarationList.declarations.length {
			return grammarErrorAtPos(declarationList, declarations.pos /* TODO(MinusToken): - */ /* TODO(BinaryExpression): declarations.end - declarations.pos */, TODO, Diagnostics.Variable_declaration_list_cannot_be_empty)
		}
		blockScopeFlags := declarationList.flags & NodeFlagsBlockScoped
		if (blockScopeFlags == NodeFlagsUsing || blockScopeFlags == NodeFlagsAwaitUsing) && isForInStatement(declarationList.parent) {
			return grammarErrorOnNode(declarationList /* TODO(ConditionalExpression): blockScopeFlags === NodeFlags.Using ?                     Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration :                     Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration */, TODO)
		}
		if blockScopeFlags == NodeFlagsAwaitUsing {
			return checkAwaitGrammar(declarationList)
		}
		return false
	}
	allowLetAndConstDeclarations := func(parent Node) bool {
		switch parent.kind {
		case SyntaxKindIfStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindDoStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindWhileStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindWithStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindForStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindForInStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindForOfStatement:
			return false
		case SyntaxKindLabeledStatement:
			return allowLetAndConstDeclarations(parent.parent)
		}
		return true
	}
	checkGrammarForDisallowedBlockScopedVariableStatement := func(node VariableStatement) /* TODO inferred type boolean | undefined */ TODO {
		if !allowLetAndConstDeclarations(node.parent) {
			blockScopeKind := getCombinedNodeFlagsCached(node.declarationList) & NodeFlagsBlockScoped
			if blockScopeKind {
				keyword := /* TODO(ConditionalExpression): blockScopeKind === NodeFlags.Let ? "let" :                     blockScopeKind === NodeFlags.Const ? "const" :                     blockScopeKind === NodeFlags.Using ? "using" :                     blockScopeKind === NodeFlags.AwaitUsing ? "await using" :                     Debug.fail("Unknown BlockScope flag") */ TODO
				return grammarErrorOnNode(node, Diagnostics._0_declarations_can_only_be_declared_inside_a_block, keyword)
			}
		}
	}
	checkGrammarMetaProperty := func(node MetaProperty) /* TODO inferred type boolean | undefined */ TODO {
		escapedText := node.name.escapedText
		switch node.keywordToken {
		case SyntaxKindNewKeyword:
			if escapedText != "target" {
				return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "target")
			}
			break
		case SyntaxKindImportKeyword:
			if escapedText != "meta" {
				return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "meta")
			}
			break
		}
	}
	hasParseDiagnostics := func(sourceFile SourceFile) bool {
		return sourceFile.parseDiagnostics.length > 0
	}
	grammarErrorOnFirstToken := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			span := getSpanOfTokenAtPosition(sourceFile, node.pos)
			diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message /* TODO(SpreadElement): ...args */, TODO))
			return true
		}
		return false
	}
	grammarErrorAtPos := func(nodeForSourceFile Node, start number, length number, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(nodeForSourceFile)
		if !hasParseDiagnostics(sourceFile) {
			diagnostics.add(createFileDiagnostic(sourceFile, start, length, message /* TODO(SpreadElement): ...args */, TODO))
			return true
		}
		return false
	}
	grammarErrorOnNodeSkippedOn := func(key CompilerOptions, node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			errorSkippedOn(key, node, message /* TODO(SpreadElement): ...args */, TODO)
			return true
		}
		return false
	}
	grammarErrorOnNode := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			diagnostics.add(createDiagnosticForNode(node, message /* TODO(SpreadElement): ...args */, TODO))
			return true
		}
		return false
	}
	checkGrammarConstructorTypeParameters := func(node ConstructorDeclaration) /* TODO inferred type boolean | undefined */ TODO {
		jsdocTypeParameters := /* TODO(ConditionalExpression): isInJSFile(node) ? getJSDocTypeParameterDeclarations(node) : undefined */ TODO
		range_ := node.typeParameters || jsdocTypeParameters && firstOrUndefined(jsdocTypeParameters)
		if range_ {
			pos := /* TODO(ConditionalExpression): range.pos === range.end ? range.pos : skipTrivia(getSourceFileOfNode(node).text, range.pos) */ TODO
			return grammarErrorAtPos(node, pos /* TODO(MinusToken): - */ /* TODO(BinaryExpression): range.end - pos */, TODO, Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration)
		}
	}
	checkGrammarConstructorTypeAnnotation := func(node ConstructorDeclaration) /* TODO inferred type boolean | undefined */ TODO {
		type_ := node.type_ || getEffectiveReturnTypeNode(node)
		if type_ {
			return grammarErrorOnNode(type_, Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration)
		}
	}
	checkGrammarProperty := func(node /* TODO(UnionType): PropertyDeclaration | PropertySignature */ any) /* TODO inferred type boolean | undefined */ TODO {
		if isComputedPropertyName(node.name) && isBinaryExpression(node.name.expression) && node.name.expression.operatorToken.kind == SyntaxKindInKeyword {
			return grammarErrorOnNode( /* TODO(ElementAccessExpression): node.parent.members[0] */ TODO, Diagnostics.A_mapped_type_may_not_declare_properties_or_methods)
		}
		if isClassLike(node.parent) {
			if isStringLiteral(node.name) && node.name.text == "constructor" {
				return grammarErrorOnNode(node.name, Diagnostics.Classes_may_not_have_a_field_named_constructor)
			}
			if checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type) {
				return true
			}
			if languageVersion < ScriptTargetES2015 && isPrivateIdentifier(node.name) {
				return grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if languageVersion < ScriptTargetES2015 && isAutoAccessorPropertyDeclaration(node) {
				return grammarErrorOnNode(node.name, Diagnostics.Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if isAutoAccessorPropertyDeclaration(node) && checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_accessor_property_cannot_be_declared_optional) {
				return true
			}
		} else if node.parent.kind == SyntaxKindInterfaceDeclaration {
			if checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type) {
				return true
			}
			Debug.assertNode(node, isPropertySignature)
			if node.initializer {
				return grammarErrorOnNode(node.initializer, Diagnostics.An_interface_property_cannot_have_an_initializer)
			}
		} else if isTypeLiteralNode(node.parent) {
			if checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type) {
				return true
			}
			Debug.assertNode(node, isPropertySignature)
			if node.initializer {
				return grammarErrorOnNode(node.initializer, Diagnostics.A_type_literal_property_cannot_have_an_initializer)
			}
		}
		if node.flags & NodeFlagsAmbient {
			checkAmbientInitializer(node)
		}
		if isPropertyDeclaration(node) && node.exclamationToken && (!isClassLike(node.parent) || !node.type_ || node.initializer || node.flags&NodeFlagsAmbient || isStatic(node) || hasAbstractModifier(node)) {
			message := /* TODO(ConditionalExpression): node.initializer                 ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions                 : !node.type                 ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations                 : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context */ TODO
			return grammarErrorOnNode(node.exclamationToken, message)
		}
	}
	checkGrammarTopLevelElementForRequiredDeclareModifier := func(node Node) bool {
		if node.kind == SyntaxKindInterfaceDeclaration || node.kind == SyntaxKindTypeAliasDeclaration || node.kind == SyntaxKindImportDeclaration || node.kind == SyntaxKindImportEqualsDeclaration || node.kind == SyntaxKindExportDeclaration || node.kind == SyntaxKindExportAssignment || node.kind == SyntaxKindNamespaceExportDeclaration || hasSyntacticModifier(node, ModifierFlagsAmbient|ModifierFlagsExport|ModifierFlagsDefault) {
			return false
		}
		return grammarErrorOnFirstToken(node, Diagnostics.Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier)
	}
	checkGrammarTopLevelElementsForRequiredDeclareModifier := func(file SourceFile) bool {
		for _, decl := range file.statements {
			if isDeclaration(decl) || decl.kind == SyntaxKindVariableStatement {
				if checkGrammarTopLevelElementForRequiredDeclareModifier(decl) {
					return true
				}
			}
		}
		return false
	}
	checkGrammarSourceFile := func(node SourceFile) bool {
		return !!(node.flags & NodeFlagsAmbient) && checkGrammarTopLevelElementsForRequiredDeclareModifier(node)
	}
	checkGrammarStatementInAmbientContext := func(node Node) bool {
		if node.flags & NodeFlagsAmbient {
			links := getNodeLinks(node)
			if !links.hasReportedStatementInAmbientContext && (isFunctionLike(node.parent) || isAccessor(node.parent)) {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): getNodeLinks(node).hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts) */ TODO
			}
			if node.parent.kind == SyntaxKindBlock || node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
				links := getNodeLinks(node.parent)
				if !links.hasReportedStatementInAmbientContext {
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.Statements_are_not_allowed_in_ambient_contexts) */ TODO
				}
			} else {
			}
		}
		return false
	}
	checkGrammarNumericLiteral := func(node NumericLiteral) {
		isFractional := getTextOfNode(node).includes(".")
		isScientific := node.numericLiteralFlags & TokenFlagsScientific
		if isFractional || isScientific {
			return
		}
		value := +node.text
		if value <= /* TODO(MinusToken): - */ /* TODO(BinaryExpression): 2 ** 53 - 1 */ TODO {
			return
		}
		addErrorOrSuggestion(false, createDiagnosticForNode(node, Diagnostics.Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers))
	}
	checkGrammarBigIntLiteral := func(node BigIntLiteral) bool {
		literalType := isLiteralTypeNode(node.parent) || isPrefixUnaryExpression(node.parent) && isLiteralTypeNode(node.parent.parent)
		if !literalType {
			if languageVersion < ScriptTargetES2020 {
				if grammarErrorOnNode(node, Diagnostics.BigInt_literals_are_not_available_when_targeting_lower_than_ES2020) {
					return true
				}
			}
		}
		return false
	}
	grammarErrorAfterFirstToken := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			span := getSpanOfTokenAtPosition(sourceFile, node.pos)
			diagnostics.add(createFileDiagnostic(sourceFile, textSpanEnd(span), 0, message /* TODO(SpreadElement): ...args */, TODO))
			return true
		}
		return false
	}
	getAmbientModules := func() []Symbol {
		if !ambientModulesCache {
			ambientModulesCache = /* TODO(ArrayLiteralExpression): [] */ TODO
			globals.forEach(func(global /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, sym /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
				if ambientModuleSymbolRegex.test(sym) {
					ambientModulesCache.push(global)
				}
			})
		}
		return ambientModulesCache
	}
	checkGrammarImportClause := func(node ImportClause) bool {
		if node.isTypeOnly && node.name && node.namedBindings {
			return grammarErrorOnNode(node, Diagnostics.A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both)
		}
		if node.isTypeOnly && node.namedBindings.kind == SyntaxKindNamedImports {
			return checkGrammarNamedImportsOrExports(node.namedBindings)
		}
		return false
	}
	checkGrammarNamedImportsOrExports := func(namedBindings NamedImportsOrExports) bool {
		return !!forEach(namedBindings.elements, func(specifier /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ImportSpecifier | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier */ TODO) /* TODO inferred type boolean | undefined */ TODO {
			if specifier.isTypeOnly {
				return grammarErrorOnFirstToken(specifier /* TODO(ConditionalExpression): specifier.kind === SyntaxKind.ImportSpecifier                         ? Diagnostics.The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement                         : Diagnostics.The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement */, TODO)
			}
		})
	}
	checkGrammarImportCallExpression := func(node ImportCall) bool {
		if compilerOptions.verbatimModuleSyntax && moduleKind == ModuleKindCommonJS {
			return grammarErrorOnNode(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
		}
		if moduleKind == ModuleKindES2015 {
			return grammarErrorOnNode(node, Diagnostics.Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext)
		}
		if node.typeArguments {
			return grammarErrorOnNode(node, Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments)
		}
		nodeArguments := node.arguments
		if moduleKind != ModuleKindESNext && moduleKind != ModuleKindNodeNext && moduleKind != ModuleKindNode16 && moduleKind != ModuleKindPreserve {
			checkGrammarForDisallowedTrailingComma(nodeArguments)
			if nodeArguments.length > 1 {
				importAttributesArgument := /* TODO(ElementAccessExpression): nodeArguments[1] */ TODO
				return grammarErrorOnNode(importAttributesArgument, Diagnostics.Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_nodenext_or_preserve)
			}
		}
		if nodeArguments.length == 0 || nodeArguments.length > 2 {
			return grammarErrorOnNode(node, Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments)
		}
		spreadElement := find(nodeArguments, isSpreadElement)
		if spreadElement {
			return grammarErrorOnNode(spreadElement, Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element)
		}
		return false
	}
	findMatchingTypeReferenceOrTypeAliasReference := func(source Type, unionTarget UnionOrIntersectionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		sourceObjectFlags := getObjectFlags(source)
		if sourceObjectFlags&(ObjectFlagsReference|ObjectFlagsAnonymous) && unionTarget.flags&TypeFlagsUnion {
			return find(unionTarget.types, func(target /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				if target.flags & TypeFlagsObject {
					overlapObjFlags := sourceObjectFlags & getObjectFlags(target)
					if overlapObjFlags & ObjectFlagsReference {
						return (source).target == (target).target
					}
					if overlapObjFlags & ObjectFlagsAnonymous {
						return !!(source).aliasSymbol && (source).aliasSymbol == (target).aliasSymbol
					}
				}
				return false
			})
		}
	}
	findBestTypeForObjectLiteral := func(source Type, unionTarget UnionOrIntersectionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if getObjectFlags(source)&ObjectFlagsObjectLiteral && someType(unionTarget, isArrayLikeType) {
			return find(unionTarget.types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return !isArrayLikeType(t)
			})
		}
	}
	findBestTypeForInvokable := func(source Type, unionTarget UnionOrIntersectionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		signatureKind := SignatureKindCall
		hasSignatures := getSignaturesOfType(source, signatureKind).length > 0 || ( /* TODO(CommaToken): , */ /* TODO(BinaryExpression): signatureKind = SignatureKind.Construct, getSignaturesOfType(source, signatureKind).length > 0 */ TODO)
		if hasSignatures {
			return find(unionTarget.types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return getSignaturesOfType(t, signatureKind).length > 0
			})
		}
	}
	findMostOverlappyType := func(source Type, unionTarget UnionOrIntersectionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		var bestMatch *Type
		if !(source.flags & (TypeFlagsPrimitive | TypeFlagsInstantiablePrimitive)) {
			matchingCount := 0
			for _, target := range unionTarget.types {
				if !(target.flags & (TypeFlagsPrimitive | TypeFlagsInstantiablePrimitive)) {
					overlap := getIntersectionType( /* TODO(ArrayLiteralExpression): [getIndexType(source), getIndexType(target)] */ TODO)
					if overlap.flags & TypeFlagsIndex {
						return target
					} else if isUnitType(overlap) || overlap.flags&TypeFlagsUnion {
						len := /* TODO(ConditionalExpression): overlap.flags & TypeFlags.Union ? countWhere((overlap as UnionType).types, isUnitType) : 1 */ TODO
						if len >= matchingCount {
							bestMatch = target
							matchingCount = len
						}
					}
				}
			}
		}
		return bestMatch
	}
	filterPrimitivesIfContainsNonPrimitive := func(type_ UnionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if maybeTypeOfKind(type_, TypeFlagsNonPrimitive) {
			result := filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO inferred type boolean */ TODO {
				return !(t.flags & TypeFlagsPrimitive)
			})
			if !(result.flags & TypeFlagsNever) {
				return result
			}
		}
		return type_
	}
	findMatchingDiscriminantType := func(source Type, target Type, isRelatedTo func(source Type, target Type) Ternary) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if target.flags&TypeFlagsUnion && source.flags&(TypeFlagsIntersection|TypeFlagsObject) {
			match := getMatchingUnionConstituentForType(target, source)
			if match {
				return match
			}
			sourceProperties := getPropertiesOfType(source)
			if sourceProperties {
				sourcePropertiesFiltered := findDiscriminantProperties(sourceProperties, target)
				if sourcePropertiesFiltered {
					discriminated := discriminateTypeByDiscriminableItems(target, map_(sourcePropertiesFiltered, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO inferred type [() => import("/home/jabaile/work/TypeScript/src/compiler/types").Type, import("/home/jabaile/work/TypeScript/src/compiler/types").__String] */ TODO {
						return ( /* TODO(ArrayLiteralExpression): [() => getTypeOfSymbol(p), p.escapedName] */ TODO)
					}), isRelatedTo)
					if discriminated != target {
						return discriminated
					}
				}
			}
		}
		return nil
	}
	getEffectivePropertyNameForPropertyNameNode := func(node PropertyName) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		name := getPropertyNameForPropertyNameNode(node)
		return /* TODO(ConditionalExpression): name ? name :             isComputedPropertyName(node) ? tryGetNameFromType(getTypeOfExpression(node.expression)) : undefined */ TODO
	}
	getCombinedModifierFlagsCached := func(node Declaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ModifierFlags */ TODO {
		if lastGetCombinedModifierFlagsNode == node {
			return lastGetCombinedModifierFlagsResult
		}
		lastGetCombinedModifierFlagsNode = node
		lastGetCombinedModifierFlagsResult = getCombinedModifierFlags(node)
		return lastGetCombinedModifierFlagsResult
	}
	getCombinedNodeFlagsCached := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").NodeFlags */ TODO {
		if lastGetCombinedNodeFlagsNode == node {
			return lastGetCombinedNodeFlagsResult
		}
		lastGetCombinedNodeFlagsNode = node
		lastGetCombinedNodeFlagsResult = getCombinedNodeFlags(node)
		return lastGetCombinedNodeFlagsResult
	}
	isVarConstLike := func(node /* TODO(UnionType): VariableDeclaration | VariableDeclarationList */ any) /* TODO inferred type boolean */ TODO {
		blockScopeKind := getCombinedNodeFlagsCached(node) & NodeFlagsBlockScoped
		return blockScopeKind == NodeFlagsConst || blockScopeKind == NodeFlagsUsing || blockScopeKind == NodeFlagsAwaitUsing
	}
	getJSXRuntimeImportSpecifier := func(file *SourceFile, specifierText string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralLike | undefined */ TODO {
		jsxImportIndex := /* TODO(ConditionalExpression): compilerOptions.importHelpers ? 1 : 0 */ TODO
		specifier := /* TODO(ElementAccessExpression): file?.imports[jsxImportIndex] */ TODO
		if specifier {
			Debug.assert(nodeIsSynthesized(specifier) && specifier.text == specifierText /* TODO(TemplateExpression): `Expected sourceFile.imports[${jsxImportIndex}] to be the synthesized JSX runtime import` */, TODO)
		}
		return specifier
	}
	getImportHelpersImportSpecifier := func(file SourceFile) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralLike */ TODO {
		Debug.assert(compilerOptions.importHelpers, "Expected importHelpers to be enabled")
		specifier := /* TODO(ElementAccessExpression): file.imports[0] */ TODO
		Debug.assert(specifier && nodeIsSynthesized(specifier) && specifier.text == "tslib", `Expected sourceFile.imports[0] to be the synthesized tslib import`)
		return specifier
	}
}
func isNotAccessor(declaration Declaration) bool {
	return !isAccessor(declaration)
}
func isNotOverload(declaration Declaration) bool {
	return (declaration.kind != SyntaxKindFunctionDeclaration && declaration.kind != SyntaxKindMethodDeclaration) || !!(declaration).body
}
func isDeclarationNameOrImportPropertyName(name Node) bool {
	switch name.parent.kind {
	case SyntaxKindImportSpecifier:
		fallthrough // TODO: merge cases
	case SyntaxKindExportSpecifier:
		return isIdentifier(name) || name.kind == SyntaxKindStringLiteral
	default:
		return isDeclarationName(name)
	}
}

/* TODO(ModuleDeclaration): namespace JsxNames {     export const JSX = "JSX" as __String;     export const IntrinsicElements = "IntrinsicElements" as __String;     export const ElementClass = "ElementClass" as __String;     export const ElementAttributesPropertyNameContainer = "ElementAttributesProperty" as __String; // TODO: Deprecate and remove support     export const ElementChildrenAttributeNameContainer = "ElementChildrenAttribute" as __String;     export const Element = "Element" as __String;     export const ElementType = "ElementType" as __String;     export const IntrinsicAttributes = "IntrinsicAttributes" as __String;     export const IntrinsicClassAttributes = "IntrinsicClassAttributes" as __String;     export const LibraryManagedAttributes = "LibraryManagedAttributes" as __String; } */
func getIterationTypesKeyFromIterationTypeKind(typeKind IterationTypeKind) /* TODO inferred type "yieldType" | "returnType" | "nextType" */ TODO {
	switch typeKind {
	case IterationTypeKindYield:
		return "yieldType"
	case IterationTypeKindReturn:
		return "returnType"
	case IterationTypeKindNext:
		return "nextType"
	}
}
func signatureHasRestParameter(s Signature) /* TODO inferred type boolean */ TODO {
	return !!(s.flags & SignatureFlagsHasRestParameter)
}
func signatureHasLiteralTypes(s Signature) /* TODO inferred type boolean */ TODO {
	return !!(s.flags & SignatureFlagsHasLiteralTypes)
}
func createBasicNodeBuilderModuleSpecifierResolutionHost(host TypeCheckerHost) ModuleSpecifierResolutionHost {
	return /* TODO(ObjectLiteralExpression): {         getCommonSourceDirectory: !!(host as Program).getCommonSourceDirectory ? () => (host as Program).getCommonSourceDirectory() : () => "",         getCurrentDirectory: () => host.getCurrentDirectory(),         getSymlinkCache: maybeBind(host, host.getSymlinkCache),         getPackageJsonInfoCache: () => host.getPackageJsonInfoCache?.(),         useCaseSensitiveFileNames: maybeBind(host, host.useCaseSensitiveFileNames),         redirectTargetsMap: host.redirectTargetsMap,         getProjectReferenceRedirect: fileName => host.getProjectReferenceRedirect(fileName),         isSourceOfProjectReferenceRedirect: fileName => host.isSourceOfProjectReferenceRedirect(fileName),         fileExists: fileName => host.fileExists(fileName),         getFileIncludeReasons: () => host.getFileIncludeReasons(),         readFile: host.readFile ? (fileName => host.readFile!(fileName)) : undefined,         getDefaultResolutionModeForFile: file => host.getDefaultResolutionModeForFile(file),         getModeForResolutionAtIndex: (file, index) => host.getModeForResolutionAtIndex(file, index),     } */ TODO
}

type NodeBuilderContext struct {
	enclosingDeclaration Node
	enclosingFile        *SourceFile
	flags                NodeBuilderFlags
	internalFlags        InternalNodeBuilderFlags
	tracker              SymbolTrackerImpl
	encounteredError     bool
	reportedDiagnostic   bool
	trackedSymbols/* TODO(ArrayType): TrackedSymbol[] */ any
	visitedTypes *Set[number]
	symbolDepth  *Map[string, number]
	inferTypeParameters/* TODO(ArrayType): TypeParameter[] */ any
	approximateLength                     number
	truncating                            bool
	mustCreateTypeParameterSymbolList     bool
	typeParameterSymbolList               *Set[number]
	mustCreateTypeParametersNamesLookups  bool
	typeParameterNames                    *Map[TypeId, Identifier]
	typeParameterNamesByText              *Set[string]
	typeParameterNamesByTextNextNameCount *Map[string, number]
	usedSymbolNames                       *Set[string]
	remappedSymbolNames                   *Map[SymbolId, string]
	remappedSymbolReferences              *Map[SymbolId, Symbol]
	reverseMappedStack/* TODO(ArrayType): ReverseMappedSymbol[] */ any
	bundled bool
	mapper  *TypeMapper
}

/* TODO(ClassDeclaration): class SymbolTrackerImpl implements SymbolTracker {     moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined = undefined;     context: NodeBuilderContext;      readonly inner: SymbolTracker | undefined = undefined;     readonly canTrackSymbol: boolean;     disableTrackSymbol = false;      constructor(context: NodeBuilderContext, tracker: SymbolTracker | undefined, moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined) {         while (tracker instanceof SymbolTrackerImpl) {             tracker = tracker.inner;         }          this.inner = tracker;         this.moduleResolverHost = moduleResolverHost;         this.context = context;         this.canTrackSymbol = !!this.inner?.trackSymbol;     }      trackSymbol(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): boolean {         if (this.inner?.trackSymbol && !this.disableTrackSymbol) {             if (this.inner.trackSymbol(symbol, enclosingDeclaration, meaning)) {                 this.onDiagnosticReported();                 return true;             }             // Skip recording type parameters as they dont contribute to late painted statements             if (!(symbol.flags & SymbolFlags.TypeParameter)) (this.context.trackedSymbols ??= []).push([symbol, enclosingDeclaration, meaning]);         }         return false;     }      reportInaccessibleThisError(): void {         if (this.inner?.reportInaccessibleThisError) {             this.onDiagnosticReported();             this.inner.reportInaccessibleThisError();         }     }      reportPrivateInBaseOfClassExpression(propertyName: string): void {         if (this.inner?.reportPrivateInBaseOfClassExpression) {             this.onDiagnosticReported();             this.inner.reportPrivateInBaseOfClassExpression(propertyName);         }     }      reportInaccessibleUniqueSymbolError(): void {         if (this.inner?.reportInaccessibleUniqueSymbolError) {             this.onDiagnosticReported();             this.inner.reportInaccessibleUniqueSymbolError();         }     }      reportCyclicStructureError(): void {         if (this.inner?.reportCyclicStructureError) {             this.onDiagnosticReported();             this.inner.reportCyclicStructureError();         }     }      reportLikelyUnsafeImportRequiredError(specifier: string): void {         if (this.inner?.reportLikelyUnsafeImportRequiredError) {             this.onDiagnosticReported();             this.inner.reportLikelyUnsafeImportRequiredError(specifier);         }     }      reportTruncationError(): void {         if (this.inner?.reportTruncationError) {             this.onDiagnosticReported();             this.inner.reportTruncationError();         }     }      reportNonlocalAugmentation(containingFile: SourceFile, parentSymbol: Symbol, augmentingSymbol: Symbol): void {         if (this.inner?.reportNonlocalAugmentation) {             this.onDiagnosticReported();             this.inner.reportNonlocalAugmentation(containingFile, parentSymbol, augmentingSymbol);         }     }      reportNonSerializableProperty(propertyName: string): void {         if (this.inner?.reportNonSerializableProperty) {             this.onDiagnosticReported();             this.inner.reportNonSerializableProperty(propertyName);         }     }      private onDiagnosticReported() {         this.context.reportedDiagnostic = true;     }      reportInferenceFallback(node: Node): void {         if (this.inner?.reportInferenceFallback) {             this.inner.reportInferenceFallback(node);         }     } } */ /* TODO(EndOfFileToken):  */