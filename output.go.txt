package output

var ambientModuleSymbolRegex = regexp.MustParse(`^".+"$`)
var anon = "(anonymous)" /* as __String & string */
type ReferenceHint int32
const (
    ReferenceHintUnspecified ReferenceHint = iota
    ReferenceHintIdentifier 
    ReferenceHintProperty 
    ReferenceHintExportAssignment 
    ReferenceHintJsx 
    ReferenceHintAsyncFunction 
    ReferenceHintExportImportEquals 
    ReferenceHintExportSpecifier 
    ReferenceHintDecorator 
)
var nextSymbolId = 1
var nextNodeId = 1
var nextMergeId = 1
var nextFlowId = 1
type IterationUse int32
const (
    IterationUseAllowsSyncIterablesFlag IterationUse = 1 << 0
    IterationUseAllowsAsyncIterablesFlag IterationUse = 1 << 1
    IterationUseAllowsStringInputFlag IterationUse = 1 << 2
    IterationUseForOfFlag IterationUse = 1 << 3
    IterationUseYieldStarFlag IterationUse = 1 << 4
    IterationUseSpreadFlag IterationUse = 1 << 5
    IterationUseDestructuringFlag IterationUse = 1 << 6
    IterationUsePossiblyOutOfBounds IterationUse = 1 << 7
    IterationUseElement IterationUse = IterationUseAllowsSyncIterablesFlag
    IterationUseSpread IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseSpreadFlag
    IterationUseDestructuring IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseDestructuringFlag
    IterationUseForOf IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
    IterationUseForAwaitOf IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
    IterationUseYieldStar IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseYieldStarFlag
    IterationUseAsyncYieldStar IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseIterationUseYieldStarFlag
    IterationUseGeneratorReturnType IterationUse = IterationUseAllowsSyncIterablesFlag
    IterationUseAsyncGeneratorReturnType IterationUse = IterationUseAllowsAsyncIterablesFlag
)
type IterationTypeKind int32
const (
    IterationTypeKindYield IterationTypeKind = iota
    IterationTypeKindReturn 
    IterationTypeKindNext 
)
type IterationTypesResolver struct {
    iterableCacheKey any /* TODO(UnionType): "iterationTypesOfAsyncIterable" | "iterationTypesOfIterable" */
    iteratorCacheKey any /* TODO(UnionType): "iterationTypesOfAsyncIterator" | "iterationTypesOfIterator" */
    iteratorSymbolName any /* TODO(UnionType): "asyncIterator" | "iterator" */
    getGlobalIteratorType func(reportErrors bool) GenericType
    getGlobalIterableType func(reportErrors bool) GenericType
    getGlobalIterableIteratorType func(reportErrors bool) GenericType
    getGlobalIteratorObjectType func(reportErrors bool) GenericType
    getGlobalGeneratorType func(reportErrors bool) GenericType
    getGlobalBuiltinIteratorTypes func() []GenericType
    resolveIterationType func(type_ Type, errorNode *Node) *Type
    mustHaveANextMethodDiagnostic DiagnosticMessage
    mustBeAMethodDiagnostic DiagnosticMessage
    mustHaveAValueDiagnostic DiagnosticMessage
}
type WideningKind int32
const (
    WideningKindNormal WideningKind = iota
    WideningKindFunctionReturn 
    WideningKindGeneratorNext 
    WideningKindGeneratorYield 
)
type TypeFacts int32
const (
    TypeFactsNone TypeFacts = 0
    TypeFactsTypeofEQString TypeFacts = 1 << 0
    TypeFactsTypeofEQNumber TypeFacts = 1 << 1
    TypeFactsTypeofEQBigInt TypeFacts = 1 << 2
    TypeFactsTypeofEQBoolean TypeFacts = 1 << 3
    TypeFactsTypeofEQSymbol TypeFacts = 1 << 4
    TypeFactsTypeofEQObject TypeFacts = 1 << 5
    TypeFactsTypeofEQFunction TypeFacts = 1 << 6
    TypeFactsTypeofEQHostObject TypeFacts = 1 << 7
    TypeFactsTypeofNEString TypeFacts = 1 << 8
    TypeFactsTypeofNENumber TypeFacts = 1 << 9
    TypeFactsTypeofNEBigInt TypeFacts = 1 << 10
    TypeFactsTypeofNEBoolean TypeFacts = 1 << 11
    TypeFactsTypeofNESymbol TypeFacts = 1 << 12
    TypeFactsTypeofNEObject TypeFacts = 1 << 13
    TypeFactsTypeofNEFunction TypeFacts = 1 << 14
    TypeFactsTypeofNEHostObject TypeFacts = 1 << 15
    TypeFactsEQUndefined TypeFacts = 1 << 16
    TypeFactsEQNull TypeFacts = 1 << 17
    TypeFactsEQUndefinedOrNull TypeFacts = 1 << 18
    TypeFactsNEUndefined TypeFacts = 1 << 19
    TypeFactsNENull TypeFacts = 1 << 20
    TypeFactsNEUndefinedOrNull TypeFacts = 1 << 21
    TypeFactsTruthy TypeFacts = 1 << 22
    TypeFactsFalsy TypeFacts = 1 << 23
    TypeFactsIsUndefined TypeFacts = 1 << 24
    TypeFactsIsNull TypeFacts = 1 << 25
    TypeFactsIsUndefinedOrNull TypeFacts = TypeFactsIsUndefined | TypeFactsIsNull
    TypeFactsAll TypeFacts = (1 << 27) - 1
    TypeFactsBaseStringStrictFacts TypeFacts = TypeFactsTypeofEQString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
    TypeFactsBaseStringFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsStringStrictFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy | TypeFactsFalsy
    TypeFactsStringFacts TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
    TypeFactsEmptyStringStrictFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsFalsy
    TypeFactsEmptyStringFacts TypeFacts = TypeFactsBaseTypeFactsStringFacts
    TypeFactsNonEmptyStringStrictFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy
    TypeFactsNonEmptyStringFacts TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
    TypeFactsBaseNumberStrictFacts TypeFacts = TypeFactsTypeofEQNumber | TypeFactsTypeofNEString | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
    TypeFactsBaseNumberFacts TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsNumberStrictFacts TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy | TypeFactsFalsy
    TypeFactsNumberFacts TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
    TypeFactsZeroNumberStrictFacts TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsFalsy
    TypeFactsZeroNumberFacts TypeFacts = TypeFactsBaseTypeFactsNumberFacts
    TypeFactsNonZeroNumberStrictFacts TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy
    TypeFactsNonZeroNumberFacts TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
    TypeFactsBaseBigIntStrictFacts TypeFacts = TypeFactsTypeofEQBigInt | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
    TypeFactsBaseBigIntFacts TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsBigIntStrictFacts TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy | TypeFactsFalsy
    TypeFactsBigIntFacts TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
    TypeFactsZeroBigIntStrictFacts TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsFalsy
    TypeFactsZeroBigIntFacts TypeFacts = TypeFactsBaseTypeFactsBigIntFacts
    TypeFactsNonZeroBigIntStrictFacts TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy
    TypeFactsNonZeroBigIntFacts TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
    TypeFactsBaseBooleanStrictFacts TypeFacts = TypeFactsTypeofEQBoolean | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
    TypeFactsBaseBooleanFacts TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsBooleanStrictFacts TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy | TypeFactsFalsy
    TypeFactsBooleanFacts TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
    TypeFactsFalseStrictFacts TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsFalsy
    TypeFactsFalseFacts TypeFacts = TypeFactsBaseTypeFactsBooleanFacts
    TypeFactsTrueStrictFacts TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy
    TypeFactsTrueFacts TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
    TypeFactsSymbolStrictFacts TypeFacts = TypeFactsTypeofEQSymbol | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
    TypeFactsSymbolFacts TypeFacts = TypeFactsSymbolStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsObjectStrictFacts TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
    TypeFactsObjectFacts TypeFacts = TypeFactsObjectStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsFunctionStrictFacts TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
    TypeFactsFunctionFacts TypeFacts = TypeFactsFunctionStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
    TypeFactsVoidFacts TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy
    TypeFactsUndefinedFacts TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy | TypeFactsIsUndefined
    TypeFactsNullFacts TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNEUndefined | TypeFactsFalsy | TypeFactsIsNull
    TypeFactsEmptyObjectStrictFacts TypeFacts = TypeFactsAll & ~(TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsTypeFactsIsUndefinedOrNull)
    TypeFactsEmptyObjectFacts TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
    TypeFactsUnknownFacts TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
    TypeFactsAllTypeofNE TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsNEUndefined
    TypeFactsOrFactsMask TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofNEObject
    TypeFactsAndFactsMask TypeFacts = TypeFactsAll & ~TypeFactsOrFactsMask
)
var typeofNEFacts ReadonlyMap[string, TypeFacts] = TODO /* TODO(NewExpression): new Map(Object.entries({     string: TypeFacts.TypeofNEString,     number: TypeFacts.TypeofNENumber,     bigint: TypeFacts.TypeofNEBigInt,     boolean: TypeFacts.TypeofNEBoolean,     symbol: TypeFacts.TypeofNESymbol,     undefined: TypeFacts.NEUndefined,     object: TypeFacts.TypeofNEObject,     function: TypeFacts.TypeofNEFunction, })) */
type TypeSystemEntity any /* TODO(UnionType): Node | Symbol | Type | Signature */
type TypeSystemPropertyName int32
const (
    TypeSystemPropertyNameType TypeSystemPropertyName = iota
    TypeSystemPropertyNameResolvedBaseConstructorType 
    TypeSystemPropertyNameDeclaredType 
    TypeSystemPropertyNameResolvedReturnType 
    TypeSystemPropertyNameImmediateBaseConstraint 
    TypeSystemPropertyNameResolvedTypeArguments 
    TypeSystemPropertyNameResolvedBaseTypes 
    TypeSystemPropertyNameWriteType 
    TypeSystemPropertyNameParameterInitializerContainsUndefined 
)
type CheckMode int32
const (
    CheckModeNormal CheckMode = 0
    CheckModeContextual CheckMode = 1 << 0
    CheckModeInferential CheckMode = 1 << 1
    CheckModeSkipContextSensitive CheckMode = 1 << 2
    CheckModeSkipGenericFunctions CheckMode = 1 << 3
    CheckModeIsForSignatureHelp CheckMode = 1 << 4
    CheckModeRestBindingElement CheckMode = 1 << 5
    CheckModeTypeOnly CheckMode = 1 << 6
)
type SignatureCheckMode int32
const (
    SignatureCheckModeNone SignatureCheckMode = 0
    SignatureCheckModeBivariantCallback SignatureCheckMode = 1 << 0
    SignatureCheckModeStrictCallback SignatureCheckMode = 1 << 1
    SignatureCheckModeIgnoreReturnTypes SignatureCheckMode = 1 << 2
    SignatureCheckModeStrictArity SignatureCheckMode = 1 << 3
    SignatureCheckModeStrictTopSignature SignatureCheckMode = 1 << 4
    SignatureCheckModeCallback SignatureCheckMode = SignatureCheckModeBivariantSignatureCheckModeCallback | SignatureCheckModeStrictSignatureCheckModeCallback
)
type IntersectionState int32
const (
    IntersectionStateNone IntersectionState = 0
    IntersectionStateSource IntersectionState = 1 << 0
    IntersectionStateTarget IntersectionState = 1 << 1
)
type RecursionFlags int32
const (
    RecursionFlagsNone RecursionFlags = 0
    RecursionFlagsSource RecursionFlags = 1 << 0
    RecursionFlagsTarget RecursionFlags = 1 << 1
    RecursionFlagsBoth RecursionFlags = RecursionFlagsSource | RecursionFlagsTarget
)
type MappedTypeModifiers int32
const (
    MappedTypeModifiersIncludeReadonly MappedTypeModifiers = 1 << 0
    MappedTypeModifiersExcludeReadonly MappedTypeModifiers = 1 << 1
    MappedTypeModifiersIncludeOptional MappedTypeModifiers = 1 << 2
    MappedTypeModifiersExcludeOptional MappedTypeModifiers = 1 << 3
)
type MappedTypeNameTypeKind int32
const (
    MappedTypeNameTypeKindNone MappedTypeNameTypeKind = iota
    MappedTypeNameTypeKindFiltering 
    MappedTypeNameTypeKindRemapping 
)
type ExpandingFlags int32
const (
    ExpandingFlagsNone ExpandingFlags = 0
    ExpandingFlagsSource ExpandingFlags = 1
    ExpandingFlagsTarget ExpandingFlags = 1 << 1
    ExpandingFlagsBoth ExpandingFlags = ExpandingFlagsSource | ExpandingFlagsTarget
)
type MembersOrExportsResolutionKind string
const (
    MembersOrExportsResolutionKindresolvedExports MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedExports"
    MembersOrExportsResolutionKindresolvedMembers MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedMembers"
)
type UnusedKind int32
const (
    UnusedKindLocal UnusedKind = iota
    UnusedKindParameter 
)
type AddUnusedDiagnostic func(containingNode Node, type_ UnusedKind, diagnostic DiagnosticWithLocation) 
var isNotOverloadAndNotAccessor = and(isNotOverload, isNotAccessor)
type DeclarationMeaning int32
const (
    DeclarationMeaningGetAccessor DeclarationMeaning = 1
    DeclarationMeaningSetAccessor DeclarationMeaning = 2
    DeclarationMeaningPropertyAssignment DeclarationMeaning = 4
    DeclarationMeaningMethod DeclarationMeaning = 8
    DeclarationMeaningPrivateStatic DeclarationMeaning = 16
    DeclarationMeaningGetOrSetAccessor DeclarationMeaning = DeclarationMeaningGetAccessor | DeclarationMeaningSetAccessor
    DeclarationMeaningPropertyAssignmentOrMethod DeclarationMeaning = DeclarationMeaningPropertyAssignment | DeclarationMeaningMethod
)
type DeclarationSpaces int32
const (
    DeclarationSpacesNone DeclarationSpaces = 0
    DeclarationSpacesExportValue DeclarationSpaces = 1 << 0
    DeclarationSpacesExportType DeclarationSpaces = 1 << 1
    DeclarationSpacesExportNamespace DeclarationSpaces = 1 << 2
)
type MinArgumentCountFlags int32
const (
    MinArgumentCountFlagsNone MinArgumentCountFlags = 0
    MinArgumentCountFlagsStrongArityForUntypedJS MinArgumentCountFlags = 1 << 0
    MinArgumentCountFlagsVoidIsNonOptional MinArgumentCountFlags = 1 << 1
)
type IntrinsicTypeKind int32
const (
    IntrinsicTypeKindUppercase IntrinsicTypeKind = iota
    IntrinsicTypeKindLowercase 
    IntrinsicTypeKindCapitalize 
    IntrinsicTypeKindUncapitalize 
    IntrinsicTypeKindNoInfer 
)
var intrinsicTypeKinds ReadonlyMap[string, IntrinsicTypeKind] = TODO /* TODO(NewExpression): new Map(Object.entries({     Uppercase: IntrinsicTypeKind.Uppercase,     Lowercase: IntrinsicTypeKind.Lowercase,     Capitalize: IntrinsicTypeKind.Capitalize,     Uncapitalize: IntrinsicTypeKind.Uncapitalize,     NoInfer: IntrinsicTypeKind.NoInfer, })) */
var SymbolLinks = TODO /* TODO(ClassExpression): class implements SymbolLinks {     declare _symbolLinksBrand: any; } */
func NodeLinks(this NodeLinks) {
    TODO /* TODO(BinaryExpression): this.flags = NodeCheckFlags.None */
}
func getNodeId(node Node) number {
}
func getSymbolId(symbol Symbol) SymbolId {
}
func isInstantiatedModule(node ModuleDeclaration, preserveConstEnums bool) {
    moduleState := getModuleInstanceState(node)
}
func createTypeChecker(host TypeCheckerHost) TypeChecker {
    var deferredDiagnosticsCallbacks []func()  = TODO /* TODO(ArrayLiteralExpression): [] */
    addLazyDiagnostic := TODO /* TODO(ArrowFunction): (arg: () => void) => {         deferredDiagnosticsCallbacks.push(arg);     } */
    var cancellationToken *CancellationToken
    var scanner *Scanner
    Symbol := TODO /* TODO(PropertyAccessExpression): objectAllocator.getSymbolConstructor */()
    Type := TODO /* TODO(PropertyAccessExpression): objectAllocator.getTypeConstructor */()
    Signature := TODO /* TODO(PropertyAccessExpression): objectAllocator.getSignatureConstructor */()
    typeCount := 0
    symbolCount := 0
    totalInstantiationCount := 0
    instantiationCount := 0
    instantiationDepth := 0
    inlineLevel := 0
    var currentNode *Node
    var varianceTypeParameter *TypeParameter
    isInferencePartiallyBlocked := TODO /* TODO(FalseKeyword): false */
    emptySymbols := createSymbolTable()
    arrayVariances := TODO /* TODO(ArrayLiteralExpression): [VarianceFlags.Covariant] */
    compilerOptions := TODO /* TODO(PropertyAccessExpression): host.getCompilerOptions */()
    languageVersion := getEmitScriptTarget(compilerOptions)
    moduleKind := getEmitModuleKind(compilerOptions)
    legacyDecorators := TODO /* TODO(PrefixUnaryExpression): !!compilerOptions.experimentalDecorators */
    useDefineForClassFields := getUseDefineForClassFields(compilerOptions)
    emitStandardClassFields := getEmitStandardClassFields(compilerOptions)
    allowSyntheticDefaultImports := getAllowSyntheticDefaultImports(compilerOptions)
    strictNullChecks := getStrictOptionValue(compilerOptions, "strictNullChecks")
    strictFunctionTypes := getStrictOptionValue(compilerOptions, "strictFunctionTypes")
    strictBindCallApply := getStrictOptionValue(compilerOptions, "strictBindCallApply")
    strictPropertyInitialization := getStrictOptionValue(compilerOptions, "strictPropertyInitialization")
    strictBuiltinIteratorReturn := getStrictOptionValue(compilerOptions, "strictBuiltinIteratorReturn")
    noImplicitAny := getStrictOptionValue(compilerOptions, "noImplicitAny")
    noImplicitThis := getStrictOptionValue(compilerOptions, "noImplicitThis")
    useUnknownInCatchVariables := getStrictOptionValue(compilerOptions, "useUnknownInCatchVariables")
    exactOptionalPropertyTypes := TODO /* TODO(PropertyAccessExpression): compilerOptions.exactOptionalPropertyTypes */
    noUncheckedSideEffectImports := TODO /* TODO(PrefixUnaryExpression): !!compilerOptions.noUncheckedSideEffectImports */
    checkBinaryExpression := createCheckBinaryExpression()
    emitResolver := createResolver()
    nodeBuilder := createNodeBuilder()
    syntacticNodeBuilder := createSyntacticTypeNodeBuilder(compilerOptions, TODO /* TODO(ObjectLiteralExpression): {         isEntityNameVisible,         isExpandoFunctionDeclaration,         getAllAccessorDeclarations: getAllAccessorDeclarationsForDeclaration,         requiresAddingImplicitUndefined,         isUndefinedIdentifierExpression(node: Identifier) {             Debug.assert(isExpressionNode(node));             return getSymbolAtLocation(node) === undefinedSymbol;         },         isDefinitelyReferenceToGlobalSymbolObject,     } */)
    evaluate := createEvaluator(TODO /* TODO(ObjectLiteralExpression): {         evaluateElementAccessExpression,         evaluateEntityNameExpression,     } */)
    globals := createSymbolTable()
    undefinedSymbol := createSymbol(TODO /* TODO(PropertyAccessExpression): SymbolFlags.Property */, "undefined" /* as __String */)
    TODO /* TODO(BinaryExpression): undefinedSymbol.declarations = [] */
    globalThisSymbol := createSymbol(TODO /* TODO(PropertyAccessExpression): SymbolFlags.Module */, "globalThis" /* as __String */, TODO /* TODO(PropertyAccessExpression): CheckFlags.Readonly */)
    TODO /* TODO(BinaryExpression): globalThisSymbol.exports = globals */
    TODO /* TODO(BinaryExpression): globalThisSymbol.declarations = [] */
    TODO /* TODO(PropertyAccessExpression): globals.set */(TODO /* TODO(PropertyAccessExpression): globalThisSymbol.escapedName */, globalThisSymbol)
    argumentsSymbol := createSymbol(TODO /* TODO(PropertyAccessExpression): SymbolFlags.Property */, "arguments" /* as __String */)
    requireSymbol := createSymbol(TODO /* TODO(PropertyAccessExpression): SymbolFlags.Property */, "require" /* as __String */)
    isolatedModulesLikeFlagName := TODO /* TODO(ConditionalExpression): compilerOptions.verbatimModuleSyntax ? "verbatimModuleSyntax" : "isolatedModules" */
    canCollectSymbolAliasAccessabilityData := TODO /* TODO(PrefixUnaryExpression): !compilerOptions.verbatimModuleSyntax */
    var apparentArgumentCount any /* TODO(NumberKeyword): number */
    var lastGetCombinedNodeFlagsNode *Node
    lastGetCombinedNodeFlagsResult := TODO /* TODO(PropertyAccessExpression): NodeFlags.None */
    var lastGetCombinedModifierFlagsNode *Declaration
    lastGetCombinedModifierFlagsResult := TODO /* TODO(PropertyAccessExpression): ModifierFlags.None */
    resolveName := createNameResolver(TODO /* TODO(ObjectLiteralExpression): {         compilerOptions,         requireSymbol,         argumentsSymbol,         globals,         getSymbolOfDeclaration,         error,         getRequiresScopeChangeCache,         setRequiresScopeChangeCache,         lookup: getSymbol,         onPropertyWithInvalidInitializer: checkAndReportErrorForInvalidInitializer,         onFailedToResolveSymbol,         onSuccessfullyResolvedSymbol,     } */)
    resolveNameForSymbolSuggestion := createNameResolver(TODO /* TODO(ObjectLiteralExpression): {         compilerOptions,         requireSymbol,         argumentsSymbol,         globals,         getSymbolOfDeclaration,         error,         getRequiresScopeChangeCache,         setRequiresScopeChangeCache,         lookup: getSuggestionForSymbolNameLookup,     } */)
    var checker TypeChecker = TODO /* TODO(ObjectLiteralExpression): {         getNodeCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.nodeCount, 0),         getIdentifierCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.identifierCount, 0),         getSymbolCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.symbolCount, symbolCount),         getTypeCount: () => typeCount,         getInstantiationCount: () => totalInstantiationCount,         getRelationCacheSizes: () => ({             assignable: assignableRelation.size,             identity: identityRelation.size,             subtype: subtypeRelation.size,             strictSubtype: strictSubtypeRelation.size,         }),         isUndefinedSymbol: symbol => symbol === undefinedSymbol,         isArgumentsSymbol: symbol => symbol === argumentsSymbol,         isUnknownSymbol: symbol => symbol === unknownSymbol,         getMergedSymbol,         symbolIsValue,         getDiagnostics,         getGlobalDiagnostics,         getRecursionIdentity,         getUnmatchedProperties,         getTypeOfSymbolAtLocation: (symbol, locationIn) => {             const location = getParseTreeNode(locationIn);             return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType;         },         getTypeOfSymbol,         getSymbolsOfParameterPropertyDeclaration: (parameterIn, parameterName) => {             const parameter = getParseTreeNode(parameterIn, isParameter);             if (parameter === undefined) return Debug.fail("Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.");             Debug.assert(isParameterPropertyDeclaration(parameter, parameter.parent));             return getSymbolsOfParameterPropertyDeclaration(parameter, escapeLeadingUnderscores(parameterName));         },         getDeclaredTypeOfSymbol,         getPropertiesOfType,         getPropertyOfType: (type, name) => getPropertyOfType(type, escapeLeadingUnderscores(name)),         getPrivateIdentifierPropertyOfType: (leftType: Type, name: string, location: Node) => {             const node = getParseTreeNode(location);             if (!node) {                 return undefined;             }             const propName = escapeLeadingUnderscores(name);             const lexicallyScopedIdentifier = lookupSymbolForPrivateIdentifierDeclaration(propName, node);             return lexicallyScopedIdentifier ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) : undefined;         },         getTypeOfPropertyOfType: (type, name) => getTypeOfPropertyOfType(type, escapeLeadingUnderscores(name)),         getIndexInfoOfType: (type, kind) => getIndexInfoOfType(type, kind === IndexKind.String ? stringType : numberType),         getIndexInfosOfType,         getIndexInfosOfIndexSymbol,         getSignaturesOfType,         getIndexTypeOfType: (type, kind) => getIndexTypeOfType(type, kind === IndexKind.String ? stringType : numberType),         getIndexType: type => getIndexType(type),         getBaseTypes,         getBaseTypeOfLiteralType,         getWidenedType,         getWidenedLiteralType,         getTypeFromTypeNode: nodeIn => {             const node = getParseTreeNode(nodeIn, isTypeNode);             return node ? getTypeFromTypeNode(node) : errorType;         },         getParameterType: getTypeAtPosition,         getParameterIdentifierInfoAtPosition,         getPromisedTypeOfPromise,         getAwaitedType: type => getAwaitedType(type),         getReturnTypeOfSignature,         isNullableType,         getNullableType,         getNonNullableType,         getNonOptionalType: removeOptionalTypeMarker,         getTypeArguments,         typeToTypeNode: nodeBuilder.typeToTypeNode,         typePredicateToTypePredicateNode: nodeBuilder.typePredicateToTypePredicateNode,         indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration,         signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration,         symbolToEntityName: nodeBuilder.symbolToEntityName,         symbolToExpression: nodeBuilder.symbolToExpression,         symbolToNode: nodeBuilder.symbolToNode,         symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations,         symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration,         typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration,         getSymbolsInScope: (locationIn, meaning) => {             const location = getParseTreeNode(locationIn);             return location ? getSymbolsInScope(location, meaning) : [];         },         getSymbolAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             // set ignoreErrors: true because any lookups invoked by the API shouldn't cause any new errors             return node ? getSymbolAtLocation(node, /*ignoreErrors* / true) : undefined;         },         getIndexInfosAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getIndexInfosAtLocation(node) : undefined;         },         getShorthandAssignmentValueSymbol: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getShorthandAssignmentValueSymbol(node) : undefined;         },         getExportSpecifierLocalTargetSymbol: nodeIn => {             const node = getParseTreeNode(nodeIn, isExportSpecifier);             return node ? getExportSpecifierLocalTargetSymbol(node) : undefined;         },         getExportSymbolOfSymbol(symbol) {             return getMergedSymbol(symbol.exportSymbol || symbol);         },         getTypeAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getTypeOfNode(node) : errorType;         },         getTypeOfAssignmentPattern: nodeIn => {             const node = getParseTreeNode(nodeIn, isAssignmentPattern);             return node && getTypeOfAssignmentPattern(node) || errorType;         },         getPropertySymbolOfDestructuringAssignment: locationIn => {             const location = getParseTreeNode(locationIn, isIdentifier);             return location ? getPropertySymbolOfDestructuringAssignment(location) : undefined;         },         signatureToString: (signature, enclosingDeclaration, flags, kind) => {             return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind);         },         typeToString: (type, enclosingDeclaration, flags) => {             return typeToString(type, getParseTreeNode(enclosingDeclaration), flags);         },         symbolToString: (symbol, enclosingDeclaration, meaning, flags) => {             return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags);         },         typePredicateToString: (predicate, enclosingDeclaration, flags) => {             return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags);         },         writeSignature: (signature, enclosingDeclaration, flags, kind, writer) => {             return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind, writer);         },         writeType: (type, enclosingDeclaration, flags, writer) => {             return typeToString(type, getParseTreeNode(enclosingDeclaration), flags, writer);         },         writeSymbol: (symbol, enclosingDeclaration, meaning, flags, writer) => {             return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags, writer);         },         writeTypePredicate: (predicate, enclosingDeclaration, flags, writer) => {             return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags, writer);         },         getAugmentedPropertiesOfType,         getRootSymbols,         getSymbolOfExpando,         getContextualType: (nodeIn: Expression, contextFlags?: ContextFlags) => {             const node = getParseTreeNode(nodeIn, isExpression);             if (!node) {                 return undefined;             }             if (contextFlags! & ContextFlags.Completions) {                 return runWithInferenceBlockedFromSourceNode(node, () => getContextualType(node, contextFlags));             }             return getContextualType(node, contextFlags);         },         getContextualTypeForObjectLiteralElement: nodeIn => {             const node = getParseTreeNode(nodeIn, isObjectLiteralElementLike);             return node ? getContextualTypeForObjectLiteralElement(node, /*contextFlags* / undefined) : undefined;         },         getContextualTypeForArgumentAtIndex: (nodeIn, argIndex) => {             const node = getParseTreeNode(nodeIn, isCallLikeExpression);             return node && getContextualTypeForArgumentAtIndex(node, argIndex);         },         getContextualTypeForJsxAttribute: nodeIn => {             const node = getParseTreeNode(nodeIn, isJsxAttributeLike);             return node && getContextualTypeForJsxAttribute(node, /*contextFlags* / undefined);         },         isContextSensitive,         getTypeOfPropertyOfContextualType,         getFullyQualifiedName,         getResolvedSignature: (node, candidatesOutArray, argumentCount) => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.Normal),         getCandidateSignaturesForStringLiteralCompletions,         getResolvedSignatureForSignatureHelp: (node, candidatesOutArray, argumentCount) => runWithoutResolvedSignatureCaching(node, () => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.IsForSignatureHelp)),         getExpandedParameters,         hasEffectiveRestParameter,         containsArgumentsReference,         getConstantValue: nodeIn => {             const node = getParseTreeNode(nodeIn, canHaveConstantValue);             return node ? getConstantValue(node) : undefined;         },         isValidPropertyAccess: (nodeIn, propertyName) => {             const node = getParseTreeNode(nodeIn, isPropertyAccessOrQualifiedNameOrImportTypeNode);             return !!node && isValidPropertyAccess(node, escapeLeadingUnderscores(propertyName));         },         isValidPropertyAccessForCompletions: (nodeIn, type, property) => {             const node = getParseTreeNode(nodeIn, isPropertyAccessExpression);             return !!node && isValidPropertyAccessForCompletions(node, type, property);         },         getSignatureFromDeclaration: declarationIn => {             const declaration = getParseTreeNode(declarationIn, isFunctionLike);             return declaration ? getSignatureFromDeclaration(declaration) : undefined;         },         isImplementationOfOverload: nodeIn => {             const node = getParseTreeNode(nodeIn, isFunctionLike);             return node ? isImplementationOfOverload(node) : undefined;         },         getImmediateAliasedSymbol,         getAliasedSymbol: resolveAlias,         getEmitResolver,         requiresAddingImplicitUndefined,         getExportsOfModule: getExportsOfModuleAsArray,         getExportsAndPropertiesOfModule,         forEachExportAndPropertyOfModule,         getSymbolWalker: createGetSymbolWalker(             getRestTypeOfSignature,             getTypePredicateOfSignature,             getReturnTypeOfSignature,             getBaseTypes,             resolveStructuredTypeMembers,             getTypeOfSymbol,             getResolvedSymbol,             getConstraintOfTypeParameter,             getFirstIdentifier,             getTypeArguments,         ),         getAmbientModules,         getJsxIntrinsicTagNamesAt,         isOptionalParameter: nodeIn => {             const node = getParseTreeNode(nodeIn, isParameter);             return node ? isOptionalParameter(node) : false;         },         tryGetMemberInModuleExports: (name, symbol) => tryGetMemberInModuleExports(escapeLeadingUnderscores(name), symbol),         tryGetMemberInModuleExportsAndProperties: (name, symbol) => tryGetMemberInModuleExportsAndProperties(escapeLeadingUnderscores(name), symbol),         tryFindAmbientModule: moduleName => tryFindAmbientModule(moduleName, /*withAugmentations* / true),         getApparentType,         getUnionType,         isTypeAssignableTo,         createAnonymousType,         createSignature,         createSymbol,         createIndexInfo,         getAnyType: () => anyType,         getStringType: () => stringType,         getStringLiteralType,         getNumberType: () => numberType,         getNumberLiteralType,         getBigIntType: () => bigintType,         getBigIntLiteralType,         createPromiseType,         createArrayType,         getElementTypeOfArrayType,         getBooleanType: () => booleanType,         getFalseType: (fresh?) => fresh ? falseType : regularFalseType,         getTrueType: (fresh?) => fresh ? trueType : regularTrueType,         getVoidType: () => voidType,         getUndefinedType: () => undefinedType,         getNullType: () => nullType,         getESSymbolType: () => esSymbolType,         getNeverType: () => neverType,         getOptionalType: () => optionalType,         getPromiseType: () => getGlobalPromiseType(/*reportErrors* / false),         getPromiseLikeType: () => getGlobalPromiseLikeType(/*reportErrors* / false),         getAnyAsyncIterableType: () => {             const type = getGlobalAsyncIterableType(/*reportErrors* / false);             if (type === emptyGenericType) return undefined;             return createTypeReference(type, [anyType, anyType, anyType]);         },         isSymbolAccessible,         isArrayType,         isTupleType,         isArrayLikeType,         isEmptyAnonymousObjectType,         isTypeInvalidDueToUnionDiscriminant,         getExactOptionalProperties,         getAllPossiblePropertiesOfTypes,         getSuggestedSymbolForNonexistentProperty,         getSuggestedSymbolForNonexistentJSXAttribute,         getSuggestedSymbolForNonexistentSymbol: (location, name, meaning) => getSuggestedSymbolForNonexistentSymbol(location, escapeLeadingUnderscores(name), meaning),         getSuggestedSymbolForNonexistentModule,         getSuggestedSymbolForNonexistentClassMember,         getBaseConstraintOfType,         getDefaultFromTypeParameter: type => type && type.flags & TypeFlags.TypeParameter ? getDefaultFromTypeParameter(type as TypeParameter) : undefined,         resolveName(name, location, meaning, excludeGlobals) {             return resolveName(location, escapeLeadingUnderscores(name), meaning, /*nameNotFoundMessage* / undefined, /*isUse* / false, excludeGlobals);         },         getJsxNamespace: n => unescapeLeadingUnderscores(getJsxNamespace(n)),         getJsxFragmentFactory: n => {             const jsxFragmentFactory = getJsxFragmentFactoryEntity(n);             return jsxFragmentFactory && unescapeLeadingUnderscores(getFirstIdentifier(jsxFragmentFactory).escapedText);         },         getAccessibleSymbolChain,         getTypePredicateOfSignature,         resolveExternalModuleName: moduleSpecifierIn => {             const moduleSpecifier = getParseTreeNode(moduleSpecifierIn, isExpression);             return moduleSpecifier && resolveExternalModuleName(moduleSpecifier, moduleSpecifier, /*ignoreErrors* / true);         },         resolveExternalModuleSymbol,         tryGetThisTypeAt: (nodeIn, includeGlobalThis, container) => {             const node = getParseTreeNode(nodeIn);             return node && tryGetThisTypeAt(node, includeGlobalThis, container);         },         getTypeArgumentConstraint: nodeIn => {             const node = getParseTreeNode(nodeIn, isTypeNode);             return node && getTypeArgumentConstraint(node);         },         getSuggestionDiagnostics: (fileIn, ct) => {             const file = getParseTreeNode(fileIn, isSourceFile) || Debug.fail("Could not determine parsed source file.");             if (skipTypeChecking(file, compilerOptions, host)) {                 return emptyArray;             }              let diagnostics: DiagnosticWithLocation[] | undefined;             try {                 // Record the cancellation token so it can be checked later on during checkSourceElement.                 // Do this in a finally block so we can ensure that it gets reset back to nothing after                 // this call is done.                 cancellationToken = ct;                  // Ensure file is type checked, with _eager_ diagnostic production, so identifiers are registered as potentially unused                 checkSourceFileWithEagerDiagnostics(file);                 Debug.assert(!!(getNodeLinks(file).flags & NodeCheckFlags.TypeChecked));                  diagnostics = addRange(diagnostics, suggestionDiagnostics.getDiagnostics(file.fileName));                 checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), (containingNode, kind, diag) => {                     if (!containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) {                         (diagnostics || (diagnostics = [])).push({ ...diag, category: DiagnosticCategory.Suggestion });                     }                 });                  return diagnostics || emptyArray;             }             finally {                 cancellationToken = undefined;             }         },          runWithCancellationToken: (token, callback) => {             try {                 cancellationToken = token;                 return callback(checker);             }             finally {                 cancellationToken = undefined;             }         },          getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,         isDeclarationVisible,         isPropertyAccessible,         getTypeOnlyAliasDeclaration,         getMemberOverrideModifierStatus,         isTypeParameterPossiblyReferenced,         typeHasCallOrConstructSignatures,         getSymbolFlags,     } */
    func getCandidateSignaturesForStringLiteralCompletions(call CallLikeExpression, editingArgument Node) {
        candidatesSet := TODO /* TODO(NewExpression): new Set<Signature>() */
        var candidates []Signature = TODO /* TODO(ArrayLiteralExpression): [] */
        runWithInferenceBlockedFromSourceNode(editingArgument, TODO /* TODO(ArrowFunction): () => getResolvedSignatureWorker(call, candidates, /*argumentCount* / undefined, CheckMode.Normal) */)
    }
    func runWithoutResolvedSignatureCaching(node *Node, fn func() T) T {
        TODO /* TODO(BinaryExpression): node = findAncestor(node, isCallLikeOrFunctionLikeExpression) */
    }
    func runWithInferenceBlockedFromSourceNode(node *Node, fn func() T) T {
        containingCall := findAncestor(node, isCallLikeExpression)
    }
    func getResolvedSignatureWorker(nodeIn CallLikeExpression, candidatesOutArray any /* TODO(ArrayType): Signature[] */, argumentCount any /* TODO(NumberKeyword): number */, checkMode CheckMode) *Signature {
        node := getParseTreeNode(nodeIn, isCallLikeExpression)
        TODO /* TODO(BinaryExpression): apparentArgumentCount = argumentCount */
        res := TODO /* TODO(ConditionalExpression): !node ? undefined : getResolvedSignature(node, candidatesOutArray, checkMode) */
        TODO /* TODO(BinaryExpression): apparentArgumentCount = undefined */
    }
    tupleTypes := TODO /* TODO(NewExpression): new Map<string, GenericType>() */
    unionTypes := TODO /* TODO(NewExpression): new Map<string, UnionType>() */
    unionOfUnionTypes := TODO /* TODO(NewExpression): new Map<string, Type>() */
    intersectionTypes := TODO /* TODO(NewExpression): new Map<string, Type>() */
    stringLiteralTypes := TODO /* TODO(NewExpression): new Map<string, StringLiteralType>() */
    numberLiteralTypes := TODO /* TODO(NewExpression): new Map<number, NumberLiteralType>() */
    bigIntLiteralTypes := TODO /* TODO(NewExpression): new Map<string, BigIntLiteralType>() */
    enumLiteralTypes := TODO /* TODO(NewExpression): new Map<string, LiteralType>() */
    indexedAccessTypes := TODO /* TODO(NewExpression): new Map<string, IndexedAccessType>() */
    templateLiteralTypes := TODO /* TODO(NewExpression): new Map<string, TemplateLiteralType>() */
    stringMappingTypes := TODO /* TODO(NewExpression): new Map<string, StringMappingType>() */
    substitutionTypes := TODO /* TODO(NewExpression): new Map<string, SubstitutionType>() */
    subtypeReductionCache := TODO /* TODO(NewExpression): new Map<string, Type[]>() */
    decoratorContextOverrideTypeCache := TODO /* TODO(NewExpression): new Map<string, Type>() */
    cachedTypes := TODO /* TODO(NewExpression): new Map<string, Type>() */
    var evolvingArrayTypes []EvolvingArrayType = TODO /* TODO(ArrayLiteralExpression): [] */
    var undefinedProperties SymbolTable = TODO /* TODO(NewExpression): new Map() */
    markerTypes := TODO /* TODO(NewExpression): new Set<number>() */
    unknownSymbol := createSymbol(TODO /* TODO(PropertyAccessExpression): SymbolFlags.Property */, "unknown" /* as __String */)
    resolvingSymbol := createSymbol(0, TODO /* TODO(PropertyAccessExpression): InternalSymbolName.Resolving */)
    unresolvedSymbols := TODO /* TODO(NewExpression): new Map<string, TransientSymbol>() */
    errorTypes := TODO /* TODO(NewExpression): new Map<string, Type>() */
    seenIntrinsicNames := TODO /* TODO(NewExpression): new Set<string>() */
    anyType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Any */, "any")
    autoType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Any */, "any", TODO /* TODO(PropertyAccessExpression): ObjectFlags.NonInferrableType */, "auto")
    wildcardType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Any */, "any", undefined, "wildcard")
    blockedStringType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Any */, "any", undefined, "blocked string")
    errorType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Any */, "error")
    unresolvedType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Any */, "unresolved")
    nonInferrableAnyType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Any */, "any", TODO /* TODO(PropertyAccessExpression): ObjectFlags.ContainsWideningType */, "non-inferrable")
    intrinsicMarkerType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Any */, "intrinsic")
    unknownType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Unknown */, "unknown")
    undefinedType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Undefined */, "undefined")
    undefinedWideningType := TODO /* TODO(ConditionalExpression): strictNullChecks ? undefinedType : createIntrinsicType(TypeFlags.Undefined, "undefined", ObjectFlags.ContainsWideningType, "widening") */
    missingType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Undefined */, "undefined", undefined, "missing")
    undefinedOrMissingType := TODO /* TODO(ConditionalExpression): exactOptionalPropertyTypes ? missingType : undefinedType */
    optionalType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Undefined */, "undefined", undefined, "optional")
    nullType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Null */, "null")
    nullWideningType := TODO /* TODO(ConditionalExpression): strictNullChecks ? nullType : createIntrinsicType(TypeFlags.Null, "null", ObjectFlags.ContainsWideningType, "widening") */
    stringType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.String */, "string")
    numberType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Number */, "number")
    bigintType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.BigInt */, "bigint")
    falseType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.BooleanLiteral */, "false", undefined, "fresh") /* as FreshableIntrinsicType */
    regularFalseType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.BooleanLiteral */, "false") /* as FreshableIntrinsicType */
    trueType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.BooleanLiteral */, "true", undefined, "fresh") /* as FreshableIntrinsicType */
    regularTrueType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.BooleanLiteral */, "true") /* as FreshableIntrinsicType */
    TODO /* TODO(BinaryExpression): trueType.regularType = regularTrueType */
    TODO /* TODO(BinaryExpression): trueType.freshType = trueType */
    TODO /* TODO(BinaryExpression): regularTrueType.regularType = regularTrueType */
    TODO /* TODO(BinaryExpression): regularTrueType.freshType = trueType */
    TODO /* TODO(BinaryExpression): falseType.regularType = regularFalseType */
    TODO /* TODO(BinaryExpression): falseType.freshType = falseType */
    TODO /* TODO(BinaryExpression): regularFalseType.regularType = regularFalseType */
    TODO /* TODO(BinaryExpression): regularFalseType.freshType = falseType */
    booleanType := getUnionType(TODO /* TODO(ArrayLiteralExpression): [regularFalseType, regularTrueType] */)
    esSymbolType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.ESSymbol */, "symbol")
    voidType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Void */, "void")
    neverType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Never */, "never")
    silentNeverType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Never */, "never", TODO /* TODO(PropertyAccessExpression): ObjectFlags.NonInferrableType */, "silent")
    implicitNeverType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Never */, "never", undefined, "implicit")
    unreachableNeverType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Never */, "never", undefined, "unreachable")
    nonPrimitiveType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.NonPrimitive */, "object")
    stringOrNumberType := getUnionType(TODO /* TODO(ArrayLiteralExpression): [stringType, numberType] */)
    stringNumberSymbolType := getUnionType(TODO /* TODO(ArrayLiteralExpression): [stringType, numberType, esSymbolType] */)
    numberOrBigIntType := getUnionType(TODO /* TODO(ArrayLiteralExpression): [numberType, bigintType] */)
    templateConstraintType := getUnionType(TODO /* TODO(ArrayLiteralExpression): [stringType, numberType, booleanType, bigintType, nullType, undefinedType] */) /* as UnionType */
    numericStringType := getTemplateLiteralType(TODO /* TODO(ArrayLiteralExpression): ["", ""] */, TODO /* TODO(ArrayLiteralExpression): [numberType] */)
    var restrictiveMapper TypeMapper = makeFunctionTypeMapper(TODO /* TODO(ArrowFunction): t => t.flags & TypeFlags.TypeParameter ? getRestrictiveTypeParameter(t as TypeParameter) : t */, TODO /* TODO(ArrowFunction): () => "(restrictive mapper)" */)
    var permissiveMapper TypeMapper = makeFunctionTypeMapper(TODO /* TODO(ArrowFunction): t => t.flags & TypeFlags.TypeParameter ? wildcardType : t */, TODO /* TODO(ArrowFunction): () => "(permissive mapper)" */)
    uniqueLiteralType := createIntrinsicType(TODO /* TODO(PropertyAccessExpression): TypeFlags.Never */, "never", undefined, "unique literal")
    var uniqueLiteralMapper TypeMapper = makeFunctionTypeMapper(TODO /* TODO(ArrowFunction): t => t.flags & TypeFlags.TypeParameter ? uniqueLiteralType : t */, TODO /* TODO(ArrowFunction): () => "(unique literal mapper)" */)
    var outofbandVarianceMarkerHandler any /* TODO(ParenthesizedType): ((onlyUnreliable: boolean) => void) */
    reportUnreliableMapper := makeFunctionTypeMapper(TODO /* TODO(ArrowFunction): t => {         if (outofbandVarianceMarkerHandler && (t === markerSuperType || t === markerSubType || t === markerOtherType)) {             outofbandVarianceMarkerHandler(/*onlyUnreliable* / true);         }         return t;     } */, TODO /* TODO(ArrowFunction): () => "(unmeasurable reporter)" */)
    reportUnmeasurableMapper := makeFunctionTypeMapper(TODO /* TODO(ArrowFunction): t => {         if (outofbandVarianceMarkerHandler && (t === markerSuperType || t === markerSubType || t === markerOtherType)) {             outofbandVarianceMarkerHandler(/*onlyUnreliable* / false);         }         return t;     } */, TODO /* TODO(ArrowFunction): () => "(unreliable reporter)" */)
    emptyObjectType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    emptyJsxObjectType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    TODO /* TODO(BinaryExpression): emptyJsxObjectType.objectFlags |= ObjectFlags.JsxAttributes */
    emptyTypeLiteralSymbol := createSymbol(TODO /* TODO(PropertyAccessExpression): SymbolFlags.TypeLiteral */, TODO /* TODO(PropertyAccessExpression): InternalSymbolName.Type */)
    TODO /* TODO(BinaryExpression): emptyTypeLiteralSymbol.members = createSymbolTable() */
    emptyTypeLiteralType := createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, emptyArray, emptyArray, emptyArray)
    unknownEmptyObjectType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    unknownUnionType := TODO /* TODO(ConditionalExpression): strictNullChecks ? getUnionType([undefinedType, nullType, unknownEmptyObjectType]) : unknownType */
    emptyGenericType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray) /* as ObjectType */ /* as GenericType */
    TODO /* TODO(BinaryExpression): emptyGenericType.instantiations = new Map<string, TypeReference>() */
    anyFunctionType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    TODO /* TODO(BinaryExpression): anyFunctionType.objectFlags |= ObjectFlags.NonInferrableType */
    noConstraintType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    circularConstraintType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    resolvingDefaultType := createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray)
    markerSuperType := createTypeParameter()
    markerSubType := createTypeParameter()
    TODO /* TODO(BinaryExpression): markerSubType.constraint = markerSuperType */
    markerOtherType := createTypeParameter()
    markerSuperTypeForCheck := createTypeParameter()
    markerSubTypeForCheck := createTypeParameter()
    TODO /* TODO(BinaryExpression): markerSubTypeForCheck.constraint = markerSuperTypeForCheck */
    noTypePredicate := createTypePredicate(TODO /* TODO(PropertyAccessExpression): TypePredicateKind.Identifier */, "<<unresolved>>", 0, anyType)
    anySignature := createSignature(undefined, undefined, undefined, emptyArray, anyType, undefined, 0, TODO /* TODO(PropertyAccessExpression): SignatureFlags.None */)
    unknownSignature := createSignature(undefined, undefined, undefined, emptyArray, errorType, undefined, 0, TODO /* TODO(PropertyAccessExpression): SignatureFlags.None */)
    resolvingSignature := createSignature(undefined, undefined, undefined, emptyArray, anyType, undefined, 0, TODO /* TODO(PropertyAccessExpression): SignatureFlags.None */)
    silentNeverSignature := createSignature(undefined, undefined, undefined, emptyArray, silentNeverType, undefined, 0, TODO /* TODO(PropertyAccessExpression): SignatureFlags.None */)
    enumNumberIndexInfo := createIndexInfo(numberType, stringType, TODO /* TODO(TrueKeyword): true */)
    iterationTypesCache := TODO /* TODO(NewExpression): new Map<string, IterationTypes>() */
    var noIterationTypes IterationTypes = TODO /* TODO(ObjectLiteralExpression): {         get yieldType(): Type {             return Debug.fail("Not supported");         },         get returnType(): Type {             return Debug.fail("Not supported");         },         get nextType(): Type {             return Debug.fail("Not supported");         },     } */
    anyIterationTypes := createIterationTypes(anyType, anyType, anyType)
    var asyncIterationTypesResolver IterationTypesResolver = TODO /* TODO(ObjectLiteralExpression): {         iterableCacheKey: "iterationTypesOfAsyncIterable",         iteratorCacheKey: "iterationTypesOfAsyncIterator",         iteratorSymbolName: "asyncIterator",         getGlobalIteratorType: getGlobalAsyncIteratorType,         getGlobalIterableType: getGlobalAsyncIterableType,         getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,         getGlobalIteratorObjectType: getGlobalAsyncIteratorObjectType,         getGlobalGeneratorType: getGlobalAsyncGeneratorType,         getGlobalBuiltinIteratorTypes: getGlobalBuiltinAsyncIteratorTypes,         resolveIterationType: (type, errorNode) => getAwaitedType(type, errorNode, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member),         mustHaveANextMethodDiagnostic: Diagnostics.An_async_iterator_must_have_a_next_method,         mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,         mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,     } */
    var syncIterationTypesResolver IterationTypesResolver = TODO /* TODO(ObjectLiteralExpression): {         iterableCacheKey: "iterationTypesOfIterable",         iteratorCacheKey: "iterationTypesOfIterator",         iteratorSymbolName: "iterator",         getGlobalIteratorType,         getGlobalIterableType,         getGlobalIterableIteratorType,         getGlobalIteratorObjectType,         getGlobalGeneratorType,         getGlobalBuiltinIteratorTypes,         resolveIterationType: (type, _errorNode) => type,         mustHaveANextMethodDiagnostic: Diagnostics.An_iterator_must_have_a_next_method,         mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_iterator_must_be_a_method,         mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,     } */
    type DuplicateInfoForSymbol struct {
        firstFileLocations []Declaration
        secondFileLocations []Declaration
        isBlockScoped bool
    }
    type DuplicateInfoForFiles struct {
        firstFile SourceFile
        secondFile SourceFile
        conflictingSymbols Map[string, DuplicateInfoForSymbol]
    }
    var amalgamatedDuplicates *Map[string, DuplicateInfoForFiles]
    reverseMappedCache := TODO /* TODO(NewExpression): new Map<string, Type | undefined>() */
    reverseHomomorphicMappedCache := TODO /* TODO(NewExpression): new Map<string, Type | undefined>() */
    var ambientModulesCache any /* TODO(ArrayType): Symbol[] */
    var patternAmbientModules []PatternAmbientModule
    var patternAmbientModuleAugmentations *Map[string, Symbol]
    var globalObjectType ObjectType
    var globalFunctionType ObjectType
    var globalCallableFunctionType ObjectType
    var globalNewableFunctionType ObjectType
    var globalArrayType GenericType
    var globalReadonlyArrayType GenericType
    var globalStringType ObjectType
    var globalNumberType ObjectType
    var globalBooleanType ObjectType
    var globalRegExpType ObjectType
    var globalThisType GenericType
    var anyArrayType Type
    var autoArrayType Type
    var anyReadonlyArrayType Type
    var deferredGlobalNonNullableTypeAlias Symbol
    var deferredGlobalESSymbolConstructorSymbol *Symbol
    var deferredGlobalESSymbolConstructorTypeSymbol *Symbol
    var deferredGlobalESSymbolType *ObjectType
    var deferredGlobalTypedPropertyDescriptorType GenericType
    var deferredGlobalPromiseType *GenericType
    var deferredGlobalPromiseLikeType *GenericType
    var deferredGlobalPromiseConstructorSymbol *Symbol
    var deferredGlobalPromiseConstructorLikeType *ObjectType
    var deferredGlobalIterableType *GenericType
    var deferredGlobalIteratorType *GenericType
    var deferredGlobalIterableIteratorType *GenericType
    var deferredGlobalIteratorObjectType *GenericType
    var deferredGlobalGeneratorType *GenericType
    var deferredGlobalIteratorYieldResultType *GenericType
    var deferredGlobalIteratorReturnResultType *GenericType
    var deferredGlobalAsyncIterableType *GenericType
    var deferredGlobalAsyncIteratorType *GenericType
    var deferredGlobalAsyncIterableIteratorType *GenericType
    var deferredGlobalBuiltinIteratorTypes any /* TODO(TypeOperator): readonly GenericType[] */
    var deferredGlobalBuiltinAsyncIteratorTypes any /* TODO(TypeOperator): readonly GenericType[] */
    var deferredGlobalAsyncIteratorObjectType *GenericType
    var deferredGlobalAsyncGeneratorType *GenericType
    var deferredGlobalTemplateStringsArrayType *ObjectType
    var deferredGlobalImportMetaType ObjectType
    var deferredGlobalImportMetaExpressionType ObjectType
    var deferredGlobalImportCallOptionsType *ObjectType
    var deferredGlobalImportAttributesType *ObjectType
    var deferredGlobalDisposableType *ObjectType
    var deferredGlobalAsyncDisposableType *ObjectType
    var deferredGlobalExtractSymbol *Symbol
    var deferredGlobalOmitSymbol *Symbol
    var deferredGlobalAwaitedSymbol *Symbol
    var deferredGlobalBigIntType *ObjectType
    var deferredGlobalNaNSymbol *Symbol
    var deferredGlobalRecordSymbol *Symbol
    var deferredGlobalClassDecoratorContextType *GenericType
    var deferredGlobalClassMethodDecoratorContextType *GenericType
    var deferredGlobalClassGetterDecoratorContextType *GenericType
    var deferredGlobalClassSetterDecoratorContextType *GenericType
    var deferredGlobalClassAccessorDecoratorContextType *GenericType
    var deferredGlobalClassAccessorDecoratorTargetType *GenericType
    var deferredGlobalClassAccessorDecoratorResultType *GenericType
    var deferredGlobalClassFieldDecoratorContextType *GenericType
    allPotentiallyUnusedIdentifiers := TODO /* TODO(NewExpression): new Map<Path, PotentiallyUnusedIdentifier[]>() */
    flowLoopStart := 0
    flowLoopCount := 0
    sharedFlowCount := 0
    flowAnalysisDisabled := TODO /* TODO(FalseKeyword): false */
    flowInvocationCount := 0
    var lastFlowNode *FlowNode
    var lastFlowNodeReachable bool
    var flowTypeCache any /* TODO(ArrayType): Type[] */
    var contextualTypeNodes []Node = TODO /* TODO(ArrayLiteralExpression): [] */
    var contextualTypes []*Type = TODO /* TODO(ArrayLiteralExpression): [] */
    var contextualIsCache []bool = TODO /* TODO(ArrayLiteralExpression): [] */
    contextualTypeCount := 0
    var contextualBindingPatterns []BindingPattern = TODO /* TODO(ArrayLiteralExpression): [] */
    var inferenceContextNodes []Node = TODO /* TODO(ArrayLiteralExpression): [] */
    var inferenceContexts []*InferenceContext = TODO /* TODO(ArrayLiteralExpression): [] */
    inferenceContextCount := 0
    emptyStringType := getStringLiteralType("")
    zeroType := getNumberLiteralType(0)
    zeroBigIntType := getBigIntLiteralType(TODO /* TODO(ObjectLiteralExpression): { negative: false, base10Value: "0" } */)
    var resolutionTargets []TypeSystemEntity = TODO /* TODO(ArrayLiteralExpression): [] */
    var resolutionResults []bool = TODO /* TODO(ArrayLiteralExpression): [] */
    var resolutionPropertyNames []TypeSystemPropertyName = TODO /* TODO(ArrayLiteralExpression): [] */
    resolutionStart := 0
    inVarianceComputation := TODO /* TODO(FalseKeyword): false */
    suggestionCount := 0
    maximumSuggestionCount := 10
    var mergedSymbols []Symbol = TODO /* TODO(ArrayLiteralExpression): [] */
    var symbolLinks []SymbolLinks = TODO /* TODO(ArrayLiteralExpression): [] */
    var nodeLinks []NodeLinks = TODO /* TODO(ArrayLiteralExpression): [] */
    var flowLoopCaches []Map[string, Type] = TODO /* TODO(ArrayLiteralExpression): [] */
    var flowLoopNodes []FlowNode = TODO /* TODO(ArrayLiteralExpression): [] */
    var flowLoopKeys []string = TODO /* TODO(ArrayLiteralExpression): [] */
    var flowLoopTypes [][]Type = TODO /* TODO(ArrayLiteralExpression): [] */
    var sharedFlowNodes []FlowNode = TODO /* TODO(ArrayLiteralExpression): [] */
    var sharedFlowTypes []FlowType = TODO /* TODO(ArrayLiteralExpression): [] */
    var flowNodeReachable []any /* TODO(BooleanKeyword): boolean */ = TODO /* TODO(ArrayLiteralExpression): [] */
    var flowNodePostSuper []any /* TODO(BooleanKeyword): boolean */ = TODO /* TODO(ArrayLiteralExpression): [] */
    var potentialThisCollisions []Node = TODO /* TODO(ArrayLiteralExpression): [] */
    var potentialNewTargetCollisions []Node = TODO /* TODO(ArrayLiteralExpression): [] */
    var potentialWeakMapSetCollisions []Node = TODO /* TODO(ArrayLiteralExpression): [] */
    var potentialReflectCollisions []Node = TODO /* TODO(ArrayLiteralExpression): [] */
    var potentialUnusedRenamedBindingElementsInTypes []BindingElement = TODO /* TODO(ArrayLiteralExpression): [] */
    var awaitedTypeStack []number = TODO /* TODO(ArrayLiteralExpression): [] */
    var reverseMappedSourceStack []Type = TODO /* TODO(ArrayLiteralExpression): [] */
    var reverseMappedTargetStack []Type = TODO /* TODO(ArrayLiteralExpression): [] */
    reverseExpandingFlags := TODO /* TODO(PropertyAccessExpression): ExpandingFlags.None */
    diagnostics := createDiagnosticCollection()
    suggestionDiagnostics := createDiagnosticCollection()
    typeofType := createTypeofType()
    var _jsxNamespace __String
    var _jsxFactoryEntity *EntityName
    subtypeRelation := TODO /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */
    strictSubtypeRelation := TODO /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */
    assignableRelation := TODO /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */
    comparableRelation := TODO /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */
    identityRelation := TODO /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */
    enumRelation := TODO /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */
    var suggestedExtensions []TODO /* TODO(TupleType): [string, string] */ = TODO /* TODO(ArrayLiteralExpression): [         [".mts", ".mjs"],         [".ts", ".js"],         [".cts", ".cjs"],         [".mjs", ".mjs"],         [".js", ".js"],         [".cjs", ".cjs"],         [".tsx", compilerOptions.jsx === JsxEmit.Preserve ? ".jsx" : ".js"],         [".jsx", ".jsx"],         [".json", ".json"],     ] */
    initializeTypeChecker()
}
func isNotAccessor(declaration Declaration) bool {
}
func isNotOverload(declaration Declaration) bool {
}
func isDeclarationNameOrImportPropertyName(name Node) bool {
}
/* TODO(ModuleDeclaration): namespace JsxNames {
    export const JSX = "JSX" as __String;
    export const IntrinsicElements = "IntrinsicElements" as __String;
    export const ElementClass = "ElementClass" as __String;
    export const ElementAttributesPropertyNameContainer = "ElementAttributesProperty" as __String; // TODO: Deprecate and remove support
    export const ElementChildrenAttributeNameContainer = "ElementChildrenAttribute" as __String;
    export const Element = "Element" as __String;
    export const ElementType = "ElementType" as __String;
    export const IntrinsicAttributes = "IntrinsicAttributes" as __String;
    export const IntrinsicClassAttributes = "IntrinsicClassAttributes" as __String;
    export const LibraryManagedAttributes = "LibraryManagedAttributes" as __String;
} */
func getIterationTypesKeyFromIterationTypeKind(typeKind IterationTypeKind) {
}
func signatureHasRestParameter(s Signature) {
}
func signatureHasLiteralTypes(s Signature) {
}
func createBasicNodeBuilderModuleSpecifierResolutionHost(host TypeCheckerHost) ModuleSpecifierResolutionHost {
}
type NodeBuilderContext struct {
    enclosingDeclaration *Node
    enclosingFile *SourceFile
    flags NodeBuilderFlags
    internalFlags InternalNodeBuilderFlags
    tracker SymbolTrackerImpl
    encounteredError bool
    reportedDiagnostic bool
    trackedSymbols any /* TODO(ArrayType): TrackedSymbol[] */
    visitedTypes *Set[number]
    symbolDepth *Map[string, number]
    inferTypeParameters any /* TODO(ArrayType): TypeParameter[] */
    approximateLength number
    truncating bool
    mustCreateTypeParameterSymbolList bool
    typeParameterSymbolList *Set[number]
    mustCreateTypeParametersNamesLookups bool
    typeParameterNames *Map[TypeId, Identifier]
    typeParameterNamesByText *Set[string]
    typeParameterNamesByTextNextNameCount *Map[string, number]
    usedSymbolNames *Set[string]
    remappedSymbolNames *Map[SymbolId, string]
    remappedSymbolReferences *Map[SymbolId, Symbol]
    reverseMappedStack any /* TODO(ArrayType): ReverseMappedSymbol[] */
    bundled bool
    mapper *TypeMapper
}
type SymbolTrackerImpl struct {
    /* TODO(ClassDeclaration): class SymbolTrackerImpl implements SymbolTracker {
        moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined = undefined;
        context: NodeBuilderContext;

        readonly inner: SymbolTracker | undefined = undefined;
        readonly canTrackSymbol: boolean;
        disableTrackSymbol = false;

        constructor(context: NodeBuilderContext, tracker: SymbolTracker | undefined, moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined) {
            while (tracker instanceof SymbolTrackerImpl) {
                tracker = tracker.inner;
            }

            this.inner = tracker;
            this.moduleResolverHost = moduleResolverHost;
            this.context = context;
            this.canTrackSymbol = !!this.inner?.trackSymbol;
        }

        trackSymbol(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): boolean {
            if (this.inner?.trackSymbol && !this.disableTrackSymbol) {
                if (this.inner.trackSymbol(symbol, enclosingDeclaration, meaning)) {
                    this.onDiagnosticReported();
                    return true;
                }
                // Skip recording type parameters as they dont contribute to late painted statements
                if (!(symbol.flags & SymbolFlags.TypeParameter)) (this.context.trackedSymbols ??= []).push([symbol, enclosingDeclaration, meaning]);
            }
            return false;
        }

        reportInaccessibleThisError(): void {
            if (this.inner?.reportInaccessibleThisError) {
                this.onDiagnosticReported();
                this.inner.reportInaccessibleThisError();
            }
        }

        reportPrivateInBaseOfClassExpression(propertyName: string): void {
            if (this.inner?.reportPrivateInBaseOfClassExpression) {
                this.onDiagnosticReported();
                this.inner.reportPrivateInBaseOfClassExpression(propertyName);
            }
        }

        reportInaccessibleUniqueSymbolError(): void {
            if (this.inner?.reportInaccessibleUniqueSymbolError) {
                this.onDiagnosticReported();
                this.inner.reportInaccessibleUniqueSymbolError();
            }
        }

        reportCyclicStructureError(): void {
            if (this.inner?.reportCyclicStructureError) {
                this.onDiagnosticReported();
                this.inner.reportCyclicStructureError();
            }
        }

        reportLikelyUnsafeImportRequiredError(specifier: string): void {
            if (this.inner?.reportLikelyUnsafeImportRequiredError) {
                this.onDiagnosticReported();
                this.inner.reportLikelyUnsafeImportRequiredError(specifier);
            }
        }

        reportTruncationError(): void {
            if (this.inner?.reportTruncationError) {
                this.onDiagnosticReported();
                this.inner.reportTruncationError();
            }
        }

        reportNonlocalAugmentation(containingFile: SourceFile, parentSymbol: Symbol, augmentingSymbol: Symbol): void {
            if (this.inner?.reportNonlocalAugmentation) {
                this.onDiagnosticReported();
                this.inner.reportNonlocalAugmentation(containingFile, parentSymbol, augmentingSymbol);
            }
        }

        reportNonSerializableProperty(propertyName: string): void {
            if (this.inner?.reportNonSerializableProperty) {
                this.onDiagnosticReported();
                this.inner.reportNonSerializableProperty(propertyName);
            }
        }

        private onDiagnosticReported() {
            this.context.reportedDiagnostic = true;
        }

        reportInferenceFallback(node: Node): void {
            if (this.inner?.reportInferenceFallback) {
                this.inner.reportInferenceFallback(node);
            }
        }
    } */
}
